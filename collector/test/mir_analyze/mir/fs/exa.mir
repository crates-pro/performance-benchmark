// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir(_1: PathBuf) -> Result<Dir, std::io::Error> {
    debug path => _1;
    let mut _0: std::result::Result<fs::dir::Dir, std::io::Error>;
    let _2: log::Level;
    let mut _3: bool;
    let mut _4: &log::Level;
    let mut _5: bool;
    let mut _6: &log::Level;
    let mut _7: &log::LevelFilter;
    let _8: log::LevelFilter;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &&std::path::PathBuf;
    let _17: &std::path::PathBuf;
    let mut _18: log::Level;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::vec::Vec<std::path::PathBuf>>;
    let mut _20: std::result::Result<std::vec::Vec<std::path::PathBuf>, std::io::Error>;
    let mut _21: std::iter::Map<std::fs::ReadDir, {closure@src/fs/dir.rs:42:32: 42:40}>;
    let mut _22: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::ReadDir>;
    let mut _23: std::result::Result<std::fs::ReadDir, std::io::Error>;
    let mut _24: &std::path::PathBuf;
    let mut _25: isize;
    let _26: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _27: std::fs::ReadDir;
    let mut _28: isize;
    let _29: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _30: std::vec::Vec<std::path::PathBuf>;
    let mut _31: fs::dir::Dir;
    let mut _32: std::path::PathBuf;
    scope 1 {
        debug lvl => _2;
        let mut _33: &(&str, &str, &str, u32);
        let mut _34: &[&str; 1];
        let mut _35: &log::LevelFilter;
    }
    scope 2 {
        debug contents => _30;
    }
    scope 3 {
        debug residual => _26;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _27;
        scope 6 {
        }
    }
    scope 7 {
        debug residual => _29;
        scope 8 {
        }
    }
    scope 9 {
        debug val => _30;
        scope 10 {
        }
    }

    bb0: {
        _2 = log::Level::Info;
        _4 = &_2;
        _35 = const _;
        _3 = <Level as PartialOrd<LevelFilter>>::le(move _4, _35) -> [return: bb1, unwind: bb21];
    }

    bb1: {
        switchInt(move _3) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _6 = &_2;
        _8 = max_level() -> [return: bb3, unwind: bb21];
    }

    bb3: {
        _7 = &_8;
        _5 = <Level as PartialOrd<LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind: bb21];
    }

    bb4: {
        switchInt(move _5) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _34 = const _;
        _11 = _34 as &[&str] (PointerCoercion(Unsize));
        _17 = &_1;
        _16 = &_17;
        _15 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_16) -> [return: bb6, unwind: bb21];
    }

    bb6: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = std::fmt::Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb7, unwind: bb21];
    }

    bb7: {
        _18 = _2;
        _33 = const _;
        _9 = __private_api_log(move _10, move _18, _33) -> [return: bb23, unwind: bb21];
    }

    bb8: {
        _24 = &_1;
        _23 = read_dir::<&PathBuf>(move _24) -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _22 = <Result<ReadDir, std::io::Error> as Try>::branch(move _23) -> [return: bb10, unwind: bb21];
    }

    bb10: {
        _25 = discriminant(_22);
        switchInt(move _25) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _27 = move ((_22 as Continue).0: std::fs::ReadDir);
        _21 = <ReadDir as Iterator>::map::<Result<PathBuf, std::io::Error>, {closure@src/fs/dir.rs:42:32: 42:40}>(move _27, const ZeroSized: {closure@src/fs/dir.rs:42:32: 42:40}) -> [return: bb14, unwind: bb21];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _26 = move ((_22 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<Dir, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _26) -> [return: bb24, unwind: bb21];
    }

    bb14: {
        _20 = <Map<ReadDir, {closure@src/fs/dir.rs:42:32: 42:40}> as Iterator>::collect::<Result<Vec<PathBuf>, std::io::Error>>(move _21) -> [return: bb15, unwind: bb21];
    }

    bb15: {
        _19 = <Result<Vec<PathBuf>, std::io::Error> as Try>::branch(move _20) -> [return: bb16, unwind: bb21];
    }

    bb16: {
        _28 = discriminant(_19);
        switchInt(move _28) -> [0: bb17, 1: bb18, otherwise: bb12];
    }

    bb17: {
        _30 = move ((_19 as Continue).0: std::vec::Vec<std::path::PathBuf>);
        _32 = move _1;
        _31 = Dir { contents: move _30, path: move _32 };
        _0 = Result::<Dir, std::io::Error>::Ok(move _31);
        goto -> bb20;
    }

    bb18: {
        _29 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<Dir, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _29) -> [return: bb25, unwind: bb21];
    }

    bb19: {
        drop(_1) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        drop(_1) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }

    bb23: {
        goto -> bb8;
    }

    bb24: {
        goto -> bb19;
    }

    bb25: {
        goto -> bb19;
    }
}

promoted[0] in dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::dir";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::dir", const "src/fs/dir.rs", const 39_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Reading directory "];
        _0 = &_1;
        return;
    }
}

promoted[2] in dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir::{closure#0}(_1: &mut {closure@src/fs/dir.rs:42:32: 42:40}, _2: Result<DirEntry, std::io::Error>) -> Result<PathBuf, std::io::Error> {
    debug result => _2;
    let mut _0: std::result::Result<std::path::PathBuf, std::io::Error>;

    bb0: {
        _0 = Result::<DirEntry, std::io::Error>::map::<PathBuf, {closure@src/fs/dir.rs:42:52: 42:59}>(move _2, const ZeroSized: {closure@src/fs/dir.rs:42:52: 42:59}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::read_dir::{closure#0}::{closure#0}(_1: {closure@src/fs/dir.rs:42:52: 42:59}, _2: DirEntry) -> PathBuf {
    debug entry => _2;
    let mut _0: std::path::PathBuf;
    let mut _3: &std::fs::DirEntry;

    bb0: {
        _3 = &_2;
        _0 = DirEntry::path(move _3) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::files(_1: &Dir, _2: DotFilter, _3: Option<&GitCache>, _4: bool) -> Files<'_, '_> {
    debug self => _1;
    debug dots => _2;
    debug git => _3;
    debug git_ignoring => _4;
    let mut _0: fs::dir::Files<'_, '_>;
    let mut _5: std::slice::Iter<'_, std::path::PathBuf>;
    let _6: &[std::path::PathBuf];
    let mut _7: &std::vec::Vec<std::path::PathBuf>;
    let mut _8: bool;
    let mut _9: fs::dir::DotsNext;

    bb0: {
        _7 = &((*_1).0: std::vec::Vec<std::path::PathBuf>);
        _6 = <Vec<PathBuf> as Deref>::deref(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = core::slice::<impl [PathBuf]>::iter(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = DotFilter::shows_dotfiles(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = DotFilter::dots(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Files::<'_, '_> { inner: move _5, dir: _1, dotfiles: move _8, dots: move _9, git: _3, git_ignoring: _4 };
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::contains(_1: &Dir, _2: &Path) -> bool {
    debug self => _1;
    debug path => _2;
    let mut _0: bool;
    let mut _3: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _4: std::slice::Iter<'_, std::path::PathBuf>;
    let _5: &[std::path::PathBuf];
    let mut _6: &std::vec::Vec<std::path::PathBuf>;
    let mut _7: {closure@src/fs/dir.rs:63:34: 63:37};
    let mut _8: &&std::path::Path;

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<std::path::PathBuf>);
        _5 = <Vec<PathBuf> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [PathBuf]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &mut _4;
        _8 = &_2;
        _7 = {closure@src/fs/dir.rs:63:34: 63:37} { path: move _8 };
        _0 = <std::slice::Iter<'_, PathBuf> as Iterator>::any::<{closure@src/fs/dir.rs:63:34: 63:37}>(move _3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::contains::{closure#0}(_1: &mut {closure@src/fs/dir.rs:63:34: 63:37}, _2: &PathBuf) -> bool {
    debug p => _2;
    debug path => (*((*_1).0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: &&std::path::Path;
    let _4: &std::path::Path;
    let mut _5: &&std::path::Path;

    bb0: {
        _4 = PathBuf::as_path(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _5 = deref_copy ((*_1).0: &&std::path::Path);
        _0 = <&Path as PartialEq>::eq(move _3, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:28:1: 28:9>::join(_1: &Dir, _2: &Path) -> PathBuf {
    debug self => _1;
    debug child => _2;
    let mut _0: std::path::PathBuf;
    let _3: &std::path::Path;
    let mut _4: &std::path::PathBuf;

    bb0: {
        _4 = &((*_1).1: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::join::<&Path>(_3, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:94:1: 94:33>::parent(_1: &Files<'_, '_>) -> PathBuf {
    debug self => _1;
    let mut _0: std::path::PathBuf;
    let _2: &std::path::Path;
    let mut _3: &std::path::PathBuf;
    let mut _4: &fs::dir::Dir;

    bb0: {
        _4 = deref_copy ((*_1).1: &fs::dir::Dir);
        _3 = &((*_4).1: std::path::PathBuf);
        _2 = <PathBuf as Deref>::deref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::join::<&str>(_2, const "..") -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:94:1: 94:33>::next_visible_file(_1: &mut Files<'_, '_>) -> Option<Result<file::File<'_>, (PathBuf, std::io::Error)>> {
    debug self => _1;
    let mut _0: std::option::Option<std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>>;
    let mut _2: std::option::Option<&std::path::PathBuf>;
    let mut _3: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _4: isize;
    let _7: &std::path::Path;
    let mut _8: &std::path::PathBuf;
    let mut _9: bool;
    let mut _10: bool;
    let _11: &str;
    let mut _12: &std::string::String;
    let mut _13: bool;
    let mut _15: std::option::Option<fs::fields::Git>;
    let mut _16: std::option::Option<&fs::feature::git::GitCache>;
    let mut _17: {closure@src/fs/dir.rs:115:51: 115:54};
    let mut _18: &&std::path::PathBuf;
    let mut _19: bool;
    let mut _20: &fs::fields::GitStatus;
    let mut _21: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>;
    let mut _22: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let mut _23: std::path::PathBuf;
    let mut _24: &std::path::PathBuf;
    let mut _25: &fs::dir::Dir;
    let mut _26: std::string::String;
    let mut _27: {closure@src/fs/dir.rs:122:43: 122:46};
    let mut _28: &&std::path::PathBuf;
    let mut _30: bool;
    scope 1 {
        debug path => _5;
        let _5: &std::path::PathBuf;
        let _6: std::string::String;
        scope 2 {
            debug filename => _6;
            let _14: fs::fields::Git;
            scope 3 {
                debug git_status => _14;
                let mut _29: &fs::fields::GitStatus;
            }
        }
    }

    bb0: {
        _30 = const false;
        goto -> bb1;
    }

    bb1: {
        _3 = &mut ((*_1).0: std::slice::Iter<'_, std::path::PathBuf>);
        _2 = <std::slice::Iter<'_, PathBuf> as Iterator>::next(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [1: bb3, otherwise: bb18];
    }

    bb3: {
        _5 = ((_2 as Some).0: &std::path::PathBuf);
        _8 = _5;
        _7 = <PathBuf as Deref>::deref(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _30 = const true;
        _6 = file::File::<'_>::filename(_7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = ((*_1).2: bool);
        switchInt(move _9) -> [0: bb6, otherwise: bb9];
    }

    bb6: {
        _12 = &_6;
        _11 = <String as Deref>::deref(move _12) -> [return: bb7, unwind: bb24];
    }

    bb7: {
        _10 = core::str::<impl str>::starts_with::<'_, char>(_11, const '.') -> [return: bb8, unwind: bb24];
    }

    bb8: {
        switchInt(move _10) -> [0: bb9, otherwise: bb19];
    }

    bb9: {
        _13 = ((*_1).5: bool);
        switchInt(move _13) -> [0: bb14, otherwise: bb10];
    }

    bb10: {
        _16 = ((*_1).4: std::option::Option<&fs::feature::git::GitCache>);
        _18 = &_5;
        _17 = {closure@src/fs/dir.rs:115:51: 115:54} { path: move _18 };
        _15 = Option::<&GitCache>::map::<fields::Git, {closure@src/fs/dir.rs:115:51: 115:54}>(move _16, move _17) -> [return: bb11, unwind: bb24];
    }

    bb11: {
        _14 = Option::<fields::Git>::unwrap_or_default(move _15) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        _20 = &(_14.1: fs::fields::GitStatus);
        _29 = const _;
        _19 = <GitStatus as PartialEq>::eq(move _20, _29) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        switchInt(move _19) -> [0: bb14, otherwise: bb19];
    }

    bb14: {
        _24 = _5;
        _23 = <PathBuf as Clone>::clone(move _24) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _25 = ((*_1).1: &fs::dir::Dir);
        _30 = const false;
        _26 = move _6;
        _22 = file::File::<'_>::from_args::<&Dir, String>(move _23, move _25, move _26) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _28 = &_5;
        _27 = {closure@src/fs/dir.rs:122:43: 122:46} { path: move _28 };
        _21 = Result::<file::File<'_>, std::io::Error>::map_err::<(PathBuf, std::io::Error), {closure@src/fs/dir.rs:122:43: 122:46}>(move _22, move _27) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _0 = Option::<Result<file::File<'_>, (PathBuf, std::io::Error)>>::Some(move _21);
        _30 = const false;
        goto -> bb21;
    }

    bb18: {
        _0 = Option::<Result<file::File<'_>, (PathBuf, std::io::Error)>>::None;
        goto -> bb21;
    }

    bb19: {
        drop(_6) -> [return: bb20, unwind continue];
    }

    bb20: {
        _30 = const false;
        goto -> bb1;
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        drop(_6) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_30) -> [0: bb22, otherwise: bb23];
    }
}

promoted[0] in dir::<impl at src/fs/dir.rs:94:1: 94:33>::next_visible_file: &GitStatus = {
    let mut _0: &fs::fields::GitStatus;
    let mut _1: fs::fields::GitStatus;

    bb0: {
        _1 = GitStatus::Ignored;
        _0 = &_1;
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:94:1: 94:33>::next_visible_file::{closure#0}(_1: {closure@src/fs/dir.rs:115:51: 115:54}, _2: &GitCache) -> fields::Git {
    debug g => _2;
    debug path => (*(_1.0: &&std::path::PathBuf));
    let mut _0: fs::fields::Git;
    let _3: &std::path::Path;
    let mut _4: &&std::path::PathBuf;
    let mut _5: &std::path::PathBuf;

    bb0: {
        _4 = deref_copy (_1.0: &&std::path::PathBuf);
        _5 = deref_copy (*_4);
        _3 = <PathBuf as Deref>::deref(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = GitCache::get(_2, _3, const false) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:94:1: 94:33>::next_visible_file::{closure#1}(_1: {closure@src/fs/dir.rs:122:43: 122:46}, _2: std::io::Error) -> (PathBuf, std::io::Error) {
    debug e => _2;
    debug path => (*(_1.0: &&std::path::PathBuf));
    let mut _0: (std::path::PathBuf, std::io::Error);
    let mut _3: std::path::PathBuf;
    let mut _4: std::io::Error;
    let mut _5: &&std::path::PathBuf;
    let mut _6: &std::path::PathBuf;

    bb0: {
        _5 = deref_copy (_1.0: &&std::path::PathBuf);
        _6 = deref_copy (*_5);
        _3 = <PathBuf as Clone>::clone(_6) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _4 = move _2;
        _0 = (move _3, move _4);
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn dir::<impl at src/fs/dir.rs:145:1: 145:46>::next(_1: &mut Files<'_, '_>) -> Option<Result<file::File<'_>, (PathBuf, std::io::Error)>> {
    debug self => _1;
    let mut _0: std::option::Option<std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>>;
    let mut _2: isize;
    let mut _3: fs::dir::DotsNext;
    let mut _4: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>;
    let mut _5: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let mut _6: fs::dir::DotsNext;
    let mut _7: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>;
    let mut _8: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let mut _9: std::path::PathBuf;
    let mut _10: &fs::dir::Files<'_, '_>;
    let mut _11: {closure@src/fs/dir.rs:159:36: 159:39};
    let mut _12: &&mut fs::dir::Files<'_, '_>;
    let mut _13: &mut fs::dir::Files<'_, '_>;
    let mut _14: &fs::dir::Dir;
    let mut _15: &fs::dir::Dir;

    bb0: {
        _2 = discriminant(((*_1).3: fs::dir::DotsNext));
        switchInt(move _2) -> [0: bb3, 1: bb6, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _13 = _1;
        _0 = Files::<'_, '_>::next_visible_file(move _13) -> [return: bb10, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = DotsNext::DotDot;
        ((*_1).3: fs::dir::DotsNext) = move _3;
        _14 = deref_copy ((*_1).1: &fs::dir::Dir);
        _5 = file::File::<'_>::new_aa_current(_14) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = Result::<file::File<'_>, std::io::Error>::map_err::<(PathBuf, std::io::Error), {closure@src/fs/dir.rs:153:36: 153:39}>(move _5, const ZeroSized: {closure@src/fs/dir.rs:153:36: 153:39}) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Option::<Result<file::File<'_>, (PathBuf, std::io::Error)>>::Some(move _4);
        goto -> bb10;
    }

    bb6: {
        _6 = DotsNext::Files;
        ((*_1).3: fs::dir::DotsNext) = move _6;
        _10 = &(*_1);
        _9 = Files::<'_, '_>::parent(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _15 = deref_copy ((*_1).1: &fs::dir::Dir);
        _8 = file::File::<'_>::new_aa_parent(move _9, _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = &_1;
        _11 = {closure@src/fs/dir.rs:159:36: 159:39} { self: move _12 };
        _7 = Result::<file::File<'_>, std::io::Error>::map_err::<(PathBuf, std::io::Error), {closure@src/fs/dir.rs:159:36: 159:39}>(move _8, move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = Option::<Result<file::File<'_>, (PathBuf, std::io::Error)>>::Some(move _7);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:145:1: 145:46>::next::{closure#0}(_1: {closure@src/fs/dir.rs:153:36: 153:39}, _2: std::io::Error) -> (PathBuf, std::io::Error) {
    debug e => _2;
    let mut _0: (std::path::PathBuf, std::io::Error);
    let mut _3: std::path::PathBuf;
    let _4: &std::path::Path;
    let _5: &str;
    let mut _6: std::io::Error;

    bb0: {
        _5 = const ".";
        _4 = Path::new::<str>(_5) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        _3 = Path::to_path_buf(_4) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _6 = move _2;
        _0 = (move _3, move _6);
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn dir::<impl at src/fs/dir.rs:145:1: 145:46>::next::{closure#1}(_1: {closure@src/fs/dir.rs:159:36: 159:39}, _2: std::io::Error) -> (PathBuf, std::io::Error) {
    debug e => _2;
    debug self => (*(_1.0: &&mut fs::dir::Files<'_, '_>));
    let mut _0: (std::path::PathBuf, std::io::Error);
    let mut _3: std::path::PathBuf;
    let mut _4: &fs::dir::Files<'_, '_>;
    let mut _5: std::io::Error;
    let mut _6: &&mut fs::dir::Files<'_, '_>;
    let mut _7: &mut fs::dir::Files<'_, '_>;

    bb0: {
        _6 = deref_copy (_1.0: &&mut fs::dir::Files<'_, '_>);
        _7 = deref_copy (*_6);
        _4 = &(*_7);
        _3 = Files::<'_, '_>::parent(move _4) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _5 = move _2;
        _0 = (move _3, move _5);
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn dir::<impl at src/fs/dir.rs:173:10: 173:19>::eq(_1: &DotFilter, _2: &DotFilter) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:173:21: 173:26>::fmt(_1: &DotFilter, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "JustFiles";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "DotfilesAndDots";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Dotfiles";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:173:34: 173:39>::clone(_1: &DotFilter) -> DotFilter {
    debug self => _1;
    let mut _0: fs::dir::DotFilter;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:186:1: 186:27>::default() -> DotFilter {
    let mut _0: fs::dir::DotFilter;

    bb0: {
        _0 = DotFilter::JustFiles;
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:192:1: 192:15>::shows_dotfiles(_1: DotFilter) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb4, 2: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = const true;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const false;
        goto -> bb5;
    }

    bb4: {
        _0 = const true;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn dir::<impl at src/fs/dir.rs:192:1: 192:15>::dots(_1: DotFilter) -> DotsNext {
    debug self => _1;
    let mut _0: fs::dir::DotsNext;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb4, 2: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = DotsNext::Dot;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = DotsNext::Files;
        goto -> bb5;
    }

    bb4: {
        _0 = DotsNext::Files;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::from_args(_1: PathBuf, _2: PD, _3: FN) -> Result<file::File<'_>, std::io::Error> {
    debug path => _1;
    debug parent_dir => _2;
    debug filename => _3;
    let mut _0: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let _4: std::option::Option<&fs::dir::Dir>;
    let mut _6: std::option::Option<std::string::String>;
    let mut _7: FN;
    let mut _8: {closure@src/fs/file.rs:74:57: 74:59};
    let mut _9: &std::path::PathBuf;
    let _11: &std::path::Path;
    let _12: &std::path::PathBuf;
    let mut _14: bool;
    let mut _15: &log::Level;
    let mut _16: bool;
    let mut _17: &log::Level;
    let mut _18: &log::LevelFilter;
    let _19: log::LevelFilter;
    let _20: ();
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&std::path::PathBuf;
    let _28: &std::path::PathBuf;
    let mut _29: log::Level;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _31: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _32: &std::path::PathBuf;
    let mut _33: isize;
    let mut _37: fs::file::File<'_>;
    let mut _38: std::path::PathBuf;
    let mut _39: std::option::Option<std::string::String>;
    let mut _40: std::string::String;
    let mut _44: bool;
    scope 1 {
        debug parent_dir => _4;
        let _5: std::string::String;
        scope 2 {
            debug name => _5;
            let _10: std::option::Option<std::string::String>;
            scope 3 {
                debug ext => _10;
                let _13: log::Level;
                let _34: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _35: std::fs::Metadata;
                scope 4 {
                    debug lvl => _13;
                    let mut _41: &(&str, &str, &str, u32);
                    let mut _42: &[&str; 1];
                    let mut _43: &log::LevelFilter;
                }
                scope 5 {
                    debug metadata => _35;
                    let _36: bool;
                    scope 10 {
                        debug is_all_all => const false;
                    }
                }
                scope 6 {
                    debug residual => _34;
                    scope 7 {
                    }
                }
                scope 8 {
                    debug val => _35;
                    scope 9 {
                    }
                }
            }
        }
    }

    bb0: {
        _44 = const false;
        _44 = const true;
        _4 = <PD as Into<Option<&Dir>>>::into(move _2) -> [return: bb1, unwind: bb28];
    }

    bb1: {
        _44 = const false;
        _7 = move _3;
        _6 = <FN as Into<Option<String>>>::into(move _7) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _9 = &_1;
        _8 = {closure@src/fs/file.rs:74:57: 74:59} { path: move _9 };
        _5 = Option::<String>::unwrap_or_else::<{closure@src/fs/file.rs:74:57: 74:59}>(move _6, move _8) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _12 = &_1;
        _11 = <PathBuf as Deref>::deref(_12) -> [return: bb4, unwind: bb24];
    }

    bb4: {
        _10 = file::File::<'_>::ext(_11) -> [return: bb5, unwind: bb24];
    }

    bb5: {
        _13 = log::Level::Debug;
        _15 = &_13;
        _43 = const _;
        _14 = <Level as PartialOrd<LevelFilter>>::le(move _15, _43) -> [return: bb6, unwind: bb23];
    }

    bb6: {
        switchInt(move _14) -> [0: bb13, otherwise: bb7];
    }

    bb7: {
        _17 = &_13;
        _19 = max_level() -> [return: bb8, unwind: bb23];
    }

    bb8: {
        _18 = &_19;
        _16 = <Level as PartialOrd<LevelFilter>>::le(move _17, move _18) -> [return: bb9, unwind: bb23];
    }

    bb9: {
        switchInt(move _16) -> [0: bb13, otherwise: bb10];
    }

    bb10: {
        _42 = const _;
        _22 = _42 as &[&str] (PointerCoercion(Unsize));
        _28 = &_1;
        _27 = &_28;
        _26 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_27) -> [return: bb11, unwind: bb23];
    }

    bb11: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb12, unwind: bb23];
    }

    bb12: {
        _29 = _13;
        _41 = const _;
        _20 = __private_api_log(move _21, move _29, _41) -> [return: bb29, unwind: bb23];
    }

    bb13: {
        _32 = &_1;
        _31 = symlink_metadata::<&PathBuf>(move _32) -> [return: bb14, unwind: bb23];
    }

    bb14: {
        _30 = <Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _31) -> [return: bb15, unwind: bb23];
    }

    bb15: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb16, 1: bb18, otherwise: bb17];
    }

    bb16: {
        _35 = move ((_30 as Continue).0: std::fs::Metadata);
        _36 = const false;
        _38 = move _1;
        _39 = move _10;
        _40 = move _5;
        _37 = file::File::<'_> { name: move _40, ext: move _39, path: move _38, metadata: move _35, parent_dir: _4, is_all_all: _36 };
        _0 = Result::<file::File<'_>, std::io::Error>::Ok(move _37);
        goto -> bb22;
    }

    bb17: {
        unreachable;
    }

    bb18: {
        _34 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<file::File<'_>, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _34) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        drop(_10) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        drop(_5) -> [return: bb21, unwind: bb28];
    }

    bb21: {
        drop(_1) -> [return: bb22, unwind continue];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_10) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_5) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_1) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_44) -> [0: bb25, otherwise: bb27];
    }

    bb29: {
        goto -> bb13;
    }
}

promoted[0] in file::<impl at src/fs/file.rs:68:1: 68:22>::from_args: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 77_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in file::<impl at src/fs/file.rs:68:1: 68:22>::from_args: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Statting file "];
        _0 = &_1;
        return;
    }
}

promoted[2] in file::<impl at src/fs/file.rs:68:1: 68:22>::from_args: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::from_args::{closure#0}(_1: {closure@src/fs/file.rs:74:57: 74:59}) -> String {
    debug path => (*(_1.0: &std::path::PathBuf));
    let mut _0: std::string::String;
    let _2: &std::path::Path;
    let mut _3: &std::path::PathBuf;

    bb0: {
        _3 = deref_copy (_1.0: &std::path::PathBuf);
        _2 = <PathBuf as Deref>::deref(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = file::File::<'_>::filename(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_current(_1: &Dir) -> Result<file::File<'_>, std::io::Error> {
    debug parent_dir => _1;
    let mut _0: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let _2: std::path::PathBuf;
    let _3: &std::path::Path;
    let mut _4: &std::path::PathBuf;
    let _6: &std::path::Path;
    let _7: &std::path::PathBuf;
    let mut _9: bool;
    let mut _10: &log::Level;
    let mut _11: bool;
    let mut _12: &log::Level;
    let mut _13: &log::LevelFilter;
    let _14: log::LevelFilter;
    let _15: ();
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&std::path::PathBuf;
    let _23: &std::path::PathBuf;
    let mut _24: log::Level;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _26: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _27: &std::path::PathBuf;
    let mut _28: isize;
    let mut _33: fs::file::File<'_>;
    let mut _34: std::path::PathBuf;
    let mut _35: std::option::Option<std::string::String>;
    let mut _36: std::string::String;
    let _37: &str;
    let mut _41: bool;
    let mut _42: bool;
    scope 1 {
        debug path => _2;
        let _5: std::option::Option<std::string::String>;
        scope 2 {
            debug ext => _5;
            let _8: log::Level;
            let _29: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _30: std::fs::Metadata;
            scope 3 {
                debug lvl => _8;
                let mut _38: &(&str, &str, &str, u32);
                let mut _39: &[&str; 1];
                let mut _40: &log::LevelFilter;
            }
            scope 4 {
                debug metadata => _30;
                let _31: bool;
                scope 9 {
                    debug is_all_all => const true;
                    let _32: std::option::Option<&fs::dir::Dir>;
                    scope 10 {
                        debug parent_dir => _32;
                    }
                }
            }
            scope 5 {
                debug residual => _29;
                scope 6 {
                }
            }
            scope 7 {
                debug val => _30;
                scope 8 {
                }
            }
        }
    }

    bb0: {
        _42 = const false;
        _41 = const false;
        _4 = &((*_1).1: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _42 = const true;
        _2 = Path::to_path_buf(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &_2;
        _6 = <PathBuf as Deref>::deref(_7) -> [return: bb3, unwind: bb29];
    }

    bb3: {
        _5 = file::File::<'_>::ext(_6) -> [return: bb4, unwind: bb29];
    }

    bb4: {
        _41 = const true;
        _8 = log::Level::Debug;
        _10 = &_8;
        _40 = const _;
        _9 = <Level as PartialOrd<LevelFilter>>::le(move _10, _40) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        switchInt(move _9) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _12 = &_8;
        _14 = max_level() -> [return: bb7, unwind: bb27];
    }

    bb7: {
        _13 = &_14;
        _11 = <Level as PartialOrd<LevelFilter>>::le(move _12, move _13) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        switchInt(move _11) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _39 = const _;
        _17 = _39 as &[&str] (PointerCoercion(Unsize));
        _23 = &_2;
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_22) -> [return: bb10, unwind: bb27];
    }

    bb10: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = std::fmt::Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _24 = _8;
        _38 = const _;
        _15 = __private_api_log(move _16, move _24, _38) -> [return: bb30, unwind: bb27];
    }

    bb12: {
        _27 = &_2;
        _26 = symlink_metadata::<&PathBuf>(move _27) -> [return: bb13, unwind: bb27];
    }

    bb13: {
        _25 = <Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _26) -> [return: bb14, unwind: bb27];
    }

    bb14: {
        _28 = discriminant(_25);
        switchInt(move _28) -> [0: bb15, 1: bb17, otherwise: bb16];
    }

    bb15: {
        _30 = move ((_25 as Continue).0: std::fs::Metadata);
        _31 = const true;
        _32 = Option::<&Dir>::Some(_1);
        _42 = const false;
        _34 = move _2;
        _41 = const false;
        _35 = move _5;
        _37 = const ".";
        _36 = <&str as Into<String>>::into(_37) -> [return: bb19, unwind: bb23];
    }

    bb16: {
        unreachable;
    }

    bb17: {
        _29 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<file::File<'_>, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _29) -> [return: bb18, unwind: bb27];
    }

    bb18: {
        drop(_5) -> [return: bb20, unwind: bb29];
    }

    bb19: {
        _33 = file::File::<'_> { name: move _36, ext: move _35, path: move _34, metadata: move _30, parent_dir: _32, is_all_all: _31 };
        _0 = Result::<file::File<'_>, std::io::Error>::Ok(move _33);
        _41 = const false;
        _42 = const false;
        goto -> bb22;
    }

    bb20: {
        _41 = const false;
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        _42 = const false;
        goto -> bb22;
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_35) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_34) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26 (cleanup): {
        drop(_5) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        switchInt(_41) -> [0: bb29, otherwise: bb26];
    }

    bb28 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        switchInt(_42) -> [0: bb25, otherwise: bb28];
    }

    bb30: {
        goto -> bb12;
    }
}

promoted[0] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_current: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 88_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_current: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Statting file "];
        _0 = &_1;
        return;
    }
}

promoted[2] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_current: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_parent(_1: PathBuf, _2: &Dir) -> Result<file::File<'_>, std::io::Error> {
    debug path => _1;
    debug parent_dir => _2;
    let mut _0: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let _3: std::option::Option<std::string::String>;
    let _4: &std::path::Path;
    let _5: &std::path::PathBuf;
    let mut _7: bool;
    let mut _8: &log::Level;
    let mut _9: bool;
    let mut _10: &log::Level;
    let mut _11: &log::LevelFilter;
    let _12: log::LevelFilter;
    let _13: ();
    let mut _14: std::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: &[core::fmt::rt::Argument<'_>];
    let _17: &[core::fmt::rt::Argument<'_>; 1];
    let _18: [core::fmt::rt::Argument<'_>; 1];
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &&std::path::PathBuf;
    let _21: &std::path::PathBuf;
    let mut _22: log::Level;
    let mut _23: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _24: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _25: &std::path::PathBuf;
    let mut _26: isize;
    let mut _31: fs::file::File<'_>;
    let mut _32: std::path::PathBuf;
    let mut _33: std::option::Option<std::string::String>;
    let mut _34: std::string::String;
    let _35: &str;
    let mut _39: bool;
    let mut _40: bool;
    scope 1 {
        debug ext => _3;
        let _6: log::Level;
        let _27: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _28: std::fs::Metadata;
        scope 2 {
            debug lvl => _6;
            let mut _36: &(&str, &str, &str, u32);
            let mut _37: &[&str; 1];
            let mut _38: &log::LevelFilter;
        }
        scope 3 {
            debug metadata => _28;
            let _29: bool;
            scope 8 {
                debug is_all_all => const true;
                let _30: std::option::Option<&fs::dir::Dir>;
                scope 9 {
                    debug parent_dir => _30;
                }
            }
        }
        scope 4 {
            debug residual => _27;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _28;
            scope 7 {
            }
        }
    }

    bb0: {
        _40 = const false;
        _39 = const false;
        _40 = const true;
        _5 = &_1;
        _4 = <PathBuf as Deref>::deref(_5) -> [return: bb1, unwind: bb26];
    }

    bb1: {
        _3 = file::File::<'_>::ext(_4) -> [return: bb2, unwind: bb26];
    }

    bb2: {
        _39 = const true;
        _6 = log::Level::Debug;
        _8 = &_6;
        _38 = const _;
        _7 = <Level as PartialOrd<LevelFilter>>::le(move _8, _38) -> [return: bb3, unwind: bb24];
    }

    bb3: {
        switchInt(move _7) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _10 = &_6;
        _12 = max_level() -> [return: bb5, unwind: bb24];
    }

    bb5: {
        _11 = &_12;
        _9 = <Level as PartialOrd<LevelFilter>>::le(move _10, move _11) -> [return: bb6, unwind: bb24];
    }

    bb6: {
        switchInt(move _9) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _37 = const _;
        _15 = _37 as &[&str] (PointerCoercion(Unsize));
        _21 = &_1;
        _20 = &_21;
        _19 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_20) -> [return: bb8, unwind: bb24];
    }

    bb8: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = std::fmt::Arguments::<'_>::new_v1(move _15, move _16) -> [return: bb9, unwind: bb24];
    }

    bb9: {
        _22 = _6;
        _36 = const _;
        _13 = __private_api_log(move _14, move _22, _36) -> [return: bb27, unwind: bb24];
    }

    bb10: {
        _25 = &_1;
        _24 = symlink_metadata::<&PathBuf>(move _25) -> [return: bb11, unwind: bb24];
    }

    bb11: {
        _23 = <Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _24) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        _26 = discriminant(_23);
        switchInt(move _26) -> [0: bb13, 1: bb15, otherwise: bb14];
    }

    bb13: {
        _28 = move ((_23 as Continue).0: std::fs::Metadata);
        _29 = const true;
        _30 = Option::<&Dir>::Some(_2);
        _40 = const false;
        _32 = move _1;
        _39 = const false;
        _33 = move _3;
        _35 = const "..";
        _34 = <&str as Into<String>>::into(_35) -> [return: bb17, unwind: bb20];
    }

    bb14: {
        unreachable;
    }

    bb15: {
        _27 = move ((_23 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<file::File<'_>, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _27) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        drop(_3) -> [return: bb18, unwind: bb26];
    }

    bb17: {
        _31 = file::File::<'_> { name: move _34, ext: move _33, path: move _32, metadata: move _28, parent_dir: _30, is_all_all: _29 };
        _0 = Result::<file::File<'_>, std::io::Error>::Ok(move _31);
        _39 = const false;
        goto -> bb19;
    }

    bb18: {
        _39 = const false;
        drop(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_33) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_32) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        drop(_3) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_39) -> [0: bb26, otherwise: bb23];
    }

    bb25 (cleanup): {
        drop(_1) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        switchInt(_40) -> [0: bb22, otherwise: bb25];
    }

    bb27: {
        goto -> bb10;
    }
}

promoted[0] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_parent: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 99_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_parent: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Statting file "];
        _0 = &_1;
        return;
    }
}

promoted[2] in file::<impl at src/fs/file.rs:68:1: 68:22>::new_aa_parent: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::filename(_1: &Path) -> String {
    debug path => _1;
    let mut _0: std::string::String;
    let mut _2: std::option::Option<std::path::Component<'_>>;
    let mut _3: &mut std::path::Components<'_>;
    let mut _4: std::path::Components<'_>;
    let mut _5: &std::path::Path;
    let mut _6: isize;
    let mut _8: &std::borrow::Cow<'_, str>;
    let _9: std::borrow::Cow<'_, str>;
    let _10: &std::ffi::OsStr;
    let _11: log::Level;
    let mut _12: bool;
    let mut _13: &log::Level;
    let mut _14: bool;
    let mut _15: &log::Level;
    let mut _16: &log::LevelFilter;
    let _17: log::LevelFilter;
    let _18: ();
    let mut _19: std::fmt::Arguments<'_>;
    let mut _20: &[&str];
    let mut _21: &[core::fmt::rt::Argument<'_>];
    let _22: &[core::fmt::rt::Argument<'_>; 1];
    let _23: [core::fmt::rt::Argument<'_>; 1];
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &&std::path::Path;
    let mut _26: log::Level;
    let mut _27: &std::path::Display<'_>;
    let _28: std::path::Display<'_>;
    let mut _29: &std::path::Path;
    scope 1 {
        debug back => _7;
        let _7: std::path::Component<'_>;
    }
    scope 2 {
        debug lvl => _11;
        let mut _30: &(&str, &str, &str, u32);
        let mut _31: &[&str; 2];
        let mut _32: &log::LevelFilter;
    }

    bb0: {
        _5 = _1;
        _4 = Path::components(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &mut _4;
        _2 = <Components<'_> as DoubleEndedIterator>::next_back(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [1: bb3, otherwise: bb7];
    }

    bb3: {
        _7 = ((_2 as Some).0: std::path::Component<'_>);
        _10 = Component::<'_>::as_os_str(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = OsStr::to_string_lossy(_10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = &_9;
        _0 = <Cow<'_, str> as ToString>::to_string(move _8) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        drop(_9) -> [return: bb17, unwind continue];
    }

    bb7: {
        _11 = log::Level::Error;
        _13 = &_11;
        _32 = const _;
        _12 = <Level as PartialOrd<LevelFilter>>::le(move _13, _32) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _12) -> [0: bb15, otherwise: bb9];
    }

    bb9: {
        _15 = &_11;
        _17 = max_level() -> [return: bb10, unwind continue];
    }

    bb10: {
        _16 = &_17;
        _14 = <Level as PartialOrd<LevelFilter>>::le(move _15, move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _14) -> [0: bb15, otherwise: bb12];
    }

    bb12: {
        _31 = const _;
        _20 = _31 as &[&str] (PointerCoercion(Unsize));
        _25 = &_1;
        _24 = core::fmt::rt::Argument::<'_>::new_debug::<&Path>(_25) -> [return: bb13, unwind continue];
    }

    bb13: {
        _23 = [move _24];
        _22 = &_23;
        _21 = _22 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _19 = std::fmt::Arguments::<'_>::new_v1(move _20, move _21) -> [return: bb14, unwind continue];
    }

    bb14: {
        _26 = _11;
        _30 = const _;
        _18 = __private_api_log(move _19, move _26, _30) -> [return: bb15, unwind continue];
    }

    bb15: {
        _29 = _1;
        _28 = Path::display(move _29) -> [return: bb16, unwind continue];
    }

    bb16: {
        _27 = &_28;
        _0 = <std::path::Display<'_> as ToString>::to_string(move _27) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_9) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }
}

promoted[0] in file::<impl at src/fs/file.rs:68:1: 68:22>::filename: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 116_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in file::<impl at src/fs/file.rs:68:1: 68:22>::filename: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Path ", const " has no last component"];
        _0 = &_1;
        return;
    }
}

promoted[2] in file::<impl at src/fs/file.rs:68:1: 68:22>::filename: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::ext(_1: &Path) -> Option<String> {
    debug path => _1;
    let mut _0: std::option::Option<std::string::String>;
    let _2: std::string::String;
    let mut _3: std::ops::ControlFlow<std::option::Option<std::convert::Infallible>, std::string::String>;
    let mut _4: std::option::Option<std::string::String>;
    let mut _5: std::option::Option<&std::ffi::OsStr>;
    let mut _6: isize;
    let _7: std::string::String;
    let mut _8: std::option::Option<usize>;
    let _9: &str;
    let mut _10: &std::string::String;
    let mut _11: {closure@src/fs/file.rs:133:18: 133:21};
    let mut _12: &std::string::String;
    scope 1 {
        debug name => _2;
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = Path::file_name(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&OsStr>::map::<String, {closure@src/fs/file.rs:130:41: 130:44}>(move _5, const ZeroSized: {closure@src/fs/file.rs:130:41: 130:44}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Option<String> as Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = move ((_3 as Continue).0: std::string::String);
        _2 = move _7;
        _10 = &_2;
        _9 = <String as Deref>::deref(move _10) -> [return: bb7, unwind: bb11];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = <Option<String> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb10, unwind continue];
    }

    bb7: {
        _8 = core::str::<impl str>::rfind::<'_, char>(_9, const '.') -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _12 = &_2;
        _11 = {closure@src/fs/file.rs:133:18: 133:21} { name: move _12 };
        _0 = Option::<usize>::map::<String, {closure@src/fs/file.rs:133:18: 133:21}>(move _8, move _11) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::ext::{closure#0}(_1: {closure@src/fs/file.rs:130:41: 130:44}, _2: &OsStr) -> String {
    debug f => _2;
    let mut _0: std::string::String;
    let mut _3: &std::borrow::Cow<'_, str>;
    let _4: std::borrow::Cow<'_, str>;

    bb0: {
        _4 = OsStr::to_string_lossy(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _0 = <Cow<'_, str> as ToString>::to_string(move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::ext::{closure#1}(_1: {closure@src/fs/file.rs:133:18: 133:21}, _2: usize) -> String {
    debug p => _2;
    debug name => (*(_1.0: &std::string::String));
    let mut _0: std::string::String;
    let _3: &str;
    let mut _4: std::ops::RangeFrom<usize>;
    let mut _5: usize;
    let mut _6: (usize, bool);
    let mut _7: &std::string::String;

    bb0: {
        _7 = deref_copy (_1.0: &std::string::String);
        _6 = CheckedAdd(_2, const 1_usize);
        assert(!move (_6.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_usize) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = move (_6.0: usize);
        _4 = RangeFrom::<usize> { start: move _5 };
        _3 = <String as std::ops::Index<RangeFrom<usize>>>::index(_7, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = str::<impl str>::to_ascii_lowercase(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_directory(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::Metadata;

    bb0: {
        _2 = &((*_1).3: std::fs::Metadata);
        _0 = std::fs::Metadata::is_dir(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::points_to_directory(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: bool;
    let _4: fs::file::FileTarget<'_>;
    let mut _5: isize;
    let mut _7: &fs::file::File<'_>;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: *const fs::file::File<'_>;
    scope 1 {
        debug target => _4;
        scope 2 {
            debug target => _6;
            let _6: std::boxed::Box<fs::file::File<'_>>;
        }
    }

    bb0: {
        _2 = file::File::<'_>::is_directory(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb12;
    }

    bb3: {
        _3 = file::File::<'_>::is_link(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _3) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _4 = file::File::<'_>::link_target(_1) -> [return: bb6, unwind continue];
    }

    bb6: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb7, otherwise: bb9];
    }

    bb7: {
        _6 = move ((_4 as Ok).0: std::boxed::Box<fs::file::File<'_>>);
        _10 = (((_6.0: std::ptr::Unique<fs::file::File<'_>>).0: std::ptr::NonNull<fs::file::File<'_>>).0: *const fs::file::File<'_>);
        _7 = &(*_10);
        _0 = file::File::<'_>::points_to_directory(move _7) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        drop(_6) -> [return: bb11, unwind: bb17];
    }

    bb9: {
        drop(_4) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = const false;
        goto -> bb12;
    }

    bb11: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb12, otherwise: bb15];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_6) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        drop(_4) -> [return: bb12, unwind continue];
    }

    bb16 (cleanup): {
        drop(_4) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb14, otherwise: bb16];
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::to_dir(_1: &file::File<'_>) -> Result<Dir, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<fs::dir::Dir, std::io::Error>;
    let mut _2: std::path::PathBuf;
    let mut _3: &std::path::PathBuf;

    bb0: {
        _3 = &((*_1).2: std::path::PathBuf);
        _2 = <PathBuf as Clone>::clone(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Dir::read_dir(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_file(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::Metadata;

    bb0: {
        _2 = &((*_1).3: std::fs::Metadata);
        _0 = std::fs::Metadata::is_file(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_executable_file(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: u32;
    let mut _3: bool;
    let mut _4: u32;
    let mut _5: u32;
    let mut _6: &std::fs::Permissions;
    let _7: std::fs::Permissions;
    let mut _8: &std::fs::Metadata;
    scope 1 {
        debug bit => const _;
    }

    bb0: {
        _2 = const _;
        _3 = file::File::<'_>::is_file(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = &((*_1).3: std::fs::Metadata);
        _7 = std::fs::Metadata::permissions(move _8) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb6;
    }

    bb4: {
        _6 = &_7;
        _5 = <std::fs::Permissions as PermissionsExt>::mode(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = BitAnd(move _5, _2);
        _0 = Eq(move _4, _2);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_link(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::FileType;
    let _3: std::fs::FileType;
    let mut _4: &std::fs::Metadata;

    bb0: {
        _4 = &((*_1).3: std::fs::Metadata);
        _3 = std::fs::Metadata::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = FileType::is_symlink(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_pipe(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::FileType;
    let _3: std::fs::FileType;
    let mut _4: &std::fs::Metadata;

    bb0: {
        _4 = &((*_1).3: std::fs::Metadata);
        _3 = std::fs::Metadata::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = <FileType as FileTypeExt>::is_fifo(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_char_device(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::FileType;
    let _3: std::fs::FileType;
    let mut _4: &std::fs::Metadata;

    bb0: {
        _4 = &((*_1).3: std::fs::Metadata);
        _3 = std::fs::Metadata::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = <FileType as FileTypeExt>::is_char_device(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_block_device(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::FileType;
    let _3: std::fs::FileType;
    let mut _4: &std::fs::Metadata;

    bb0: {
        _4 = &((*_1).3: std::fs::Metadata);
        _3 = std::fs::Metadata::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = <FileType as FileTypeExt>::is_block_device(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::is_socket(_1: &file::File<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &std::fs::FileType;
    let _3: std::fs::FileType;
    let mut _4: &std::fs::Metadata;

    bb0: {
        _4 = &((*_1).3: std::fs::Metadata);
        _3 = std::fs::Metadata::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = <FileType as FileTypeExt>::is_socket(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::reorient_target_path(_1: &file::File<'_>, _2: &Path) -> PathBuf {
    debug self => _1;
    debug path => _2;
    let mut _0: std::path::PathBuf;
    let mut _3: bool;
    let mut _4: isize;
    let mut _6: std::option::Option<&std::path::Path>;
    let _7: &std::path::Path;
    let mut _8: &std::path::PathBuf;
    let mut _9: isize;
    let _11: &std::path::Path;
    let mut _12: &std::path::PathBuf;
    scope 1 {
        debug dir => _5;
        let _5: &fs::dir::Dir;
    }
    scope 2 {
        debug parent => _10;
        let _10: &std::path::Path;
    }

    bb0: {
        _3 = Path::is_absolute(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Path::to_path_buf(_2) -> [return: bb11, unwind continue];
    }

    bb3: {
        _4 = discriminant(((*_1).4: std::option::Option<&fs::dir::Dir>));
        switchInt(move _4) -> [1: bb4, otherwise: bb5];
    }

    bb4: {
        _5 = ((((*_1).4: std::option::Option<&fs::dir::Dir>) as Some).0: &fs::dir::Dir);
        _0 = Dir::join(_5, _2) -> [return: bb11, unwind continue];
    }

    bb5: {
        _8 = &((*_1).2: std::path::PathBuf);
        _7 = <PathBuf as Deref>::deref(move _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = Path::parent(_7) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [1: bb8, otherwise: bb9];
    }

    bb8: {
        _10 = ((_6 as Some).0: &std::path::Path);
        _0 = Path::join::<&Path>(_10, _2) -> [return: bb11, unwind continue];
    }

    bb9: {
        _12 = &((*_1).2: std::path::PathBuf);
        _11 = <PathBuf as Deref>::deref(move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = Path::join::<&Path>(_11, _2) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::link_target(_1: &file::File<'_>) -> FileTarget<'_> {
    debug self => _1;
    let mut _0: fs::file::FileTarget<'_>;
    let _2: log::Level;
    let mut _3: bool;
    let mut _4: &log::Level;
    let mut _5: bool;
    let mut _6: &log::Level;
    let mut _7: &log::LevelFilter;
    let _8: log::LevelFilter;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &&std::path::PathBuf;
    let _17: &std::path::PathBuf;
    let mut _18: log::Level;
    let _19: std::path::PathBuf;
    let mut _20: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _21: &std::path::PathBuf;
    let mut _22: isize;
    let _23: std::path::PathBuf;
    let _24: std::io::Error;
    let _26: &std::path::Path;
    let _27: &std::path::PathBuf;
    let mut _28: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _29: &std::path::PathBuf;
    let mut _30: isize;
    let _33: &std::path::Path;
    let _34: &std::path::PathBuf;
    let _36: &std::path::Path;
    let _37: &std::path::PathBuf;
    let mut _39: std::option::Option<&fs::dir::Dir>;
    let mut _40: std::path::PathBuf;
    let mut _41: std::option::Option<std::string::String>;
    let mut _42: std::boxed::Box<fs::file::File<'_>>;
    let mut _45: bool;
    let mut _46: &log::Level;
    let mut _47: bool;
    let mut _48: &log::Level;
    let mut _49: &log::LevelFilter;
    let _50: log::LevelFilter;
    let _51: ();
    let mut _52: std::fmt::Arguments<'_>;
    let mut _53: &[&str];
    let mut _54: &[core::fmt::rt::Argument<'_>];
    let _55: &[core::fmt::rt::Argument<'_>; 2];
    let _56: [core::fmt::rt::Argument<'_>; 2];
    let mut _57: core::fmt::rt::Argument<'_>;
    let _58: &&std::path::PathBuf;
    let _59: &std::path::PathBuf;
    let mut _60: core::fmt::rt::Argument<'_>;
    let _61: &std::io::Error;
    let mut _62: &[core::fmt::rt::Placeholder];
    let _63: &[core::fmt::rt::Placeholder; 2];
    let _64: [core::fmt::rt::Placeholder; 2];
    let mut _65: core::fmt::rt::Placeholder;
    let mut _66: core::fmt::rt::Alignment;
    let mut _67: core::fmt::rt::Count;
    let mut _68: core::fmt::rt::Count;
    let mut _69: core::fmt::rt::Placeholder;
    let mut _70: core::fmt::rt::Alignment;
    let mut _71: core::fmt::rt::Count;
    let mut _72: core::fmt::rt::Count;
    let mut _73: core::fmt::rt::UnsafeArg;
    let mut _74: log::Level;
    let mut _75: std::path::PathBuf;
    let mut _82: bool;
    let mut _83: bool;
    scope 1 {
        debug lvl => _2;
        let mut _79: &(&str, &str, &str, u32);
        let mut _80: &[&str; 1];
        let mut _81: &log::LevelFilter;
    }
    scope 2 {
        debug path => _19;
        let _25: std::path::PathBuf;
        scope 5 {
            debug absolute_path => _25;
            let _31: std::fs::Metadata;
            let _43: std::io::Error;
            scope 6 {
                debug metadata => _31;
                let _32: std::option::Option<std::string::String>;
                scope 7 {
                    debug ext => _32;
                    let _35: std::string::String;
                    scope 8 {
                        debug name => _35;
                        let _38: fs::file::File<'_>;
                        scope 9 {
                            debug file => _38;
                        }
                    }
                }
            }
            scope 10 {
                debug e => _43;
                let _44: log::Level;
                scope 11 {
                    debug lvl => _44;
                    let mut _76: &(&str, &str, &str, u32);
                    let mut _77: &[&str; 2];
                    let mut _78: &log::LevelFilter;
                    scope 12 {
                    }
                }
            }
        }
    }
    scope 3 {
        debug p => _23;
    }
    scope 4 {
        debug e => _24;
    }

    bb0: {
        _83 = const false;
        _82 = const false;
        _2 = log::Level::Debug;
        _4 = &_2;
        _81 = const _;
        _3 = <Level as PartialOrd<LevelFilter>>::le(move _4, _81) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _6 = &_2;
        _8 = max_level() -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &_8;
        _5 = <Level as PartialOrd<LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _5) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _80 = const _;
        _11 = _80 as &[&str] (PointerCoercion(Unsize));
        _17 = &((*_1).2: std::path::PathBuf);
        _16 = &_17;
        _15 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_16) -> [return: bb6, unwind continue];
    }

    bb6: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = std::fmt::Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _18 = _2;
        _79 = const _;
        _9 = __private_api_log(move _10, move _18, _79) -> [return: bb8, unwind continue];
    }

    bb8: {
        _21 = &((*_1).2: std::path::PathBuf);
        _20 = read_link::<&PathBuf>(move _21) -> [return: bb9, unwind continue];
    }

    bb9: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _24 = move ((_20 as Err).0: std::io::Error);
        _0 = FileTarget::<'_>::Err(move _24);
        _83 = const false;
        goto -> bb37;
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _23 = move ((_20 as Ok).0: std::path::PathBuf);
        _83 = const true;
        _19 = move _23;
        _27 = &_19;
        _26 = <PathBuf as Deref>::deref(_27) -> [return: bb13, unwind: bb41];
    }

    bb13: {
        _25 = file::File::<'_>::reorient_target_path(_1, _26) -> [return: bb14, unwind: bb41];
    }

    bb14: {
        _29 = &_25;
        _28 = std::fs::metadata::<&PathBuf>(move _29) -> [return: bb15, unwind: bb40];
    }

    bb15: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb17, 1: bb16, otherwise: bb11];
    }

    bb16: {
        _43 = move ((_28 as Err).0: std::io::Error);
        _44 = log::Level::Error;
        _46 = &_44;
        _78 = const _;
        _45 = <Level as PartialOrd<LevelFilter>>::le(move _46, _78) -> [return: bb23, unwind: bb38];
    }

    bb17: {
        _31 = move ((_28 as Ok).0: std::fs::Metadata);
        _34 = &_19;
        _33 = <PathBuf as Deref>::deref(_34) -> [return: bb18, unwind: bb39];
    }

    bb18: {
        _32 = file::File::<'_>::ext(_33) -> [return: bb19, unwind: bb39];
    }

    bb19: {
        _82 = const true;
        _37 = &_19;
        _36 = <PathBuf as Deref>::deref(_37) -> [return: bb20, unwind: bb44];
    }

    bb20: {
        _35 = file::File::<'_>::filename(_36) -> [return: bb21, unwind: bb44];
    }

    bb21: {
        _39 = Option::<&Dir>::None;
        _83 = const false;
        _40 = move _19;
        _82 = const false;
        _41 = move _32;
        _38 = file::File::<'_> { name: move _35, ext: move _41, path: move _40, metadata: move _31, parent_dir: move _39, is_all_all: const false };
        _42 = Box::<file::File<'_>>::new(move _38) -> [return: bb22, unwind: bb44];
    }

    bb22: {
        _0 = FileTarget::<'_>::Ok(move _42);
        _82 = const false;
        goto -> bb35;
    }

    bb23: {
        switchInt(move _45) -> [0: bb34, otherwise: bb24];
    }

    bb24: {
        _48 = &_44;
        _50 = max_level() -> [return: bb25, unwind: bb38];
    }

    bb25: {
        _49 = &_50;
        _47 = <Level as PartialOrd<LevelFilter>>::le(move _48, move _49) -> [return: bb26, unwind: bb38];
    }

    bb26: {
        switchInt(move _47) -> [0: bb34, otherwise: bb27];
    }

    bb27: {
        _77 = const _;
        _53 = _77 as &[&str] (PointerCoercion(Unsize));
        _59 = &_19;
        _58 = &_59;
        _57 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_58) -> [return: bb28, unwind: bb38];
    }

    bb28: {
        _61 = &_43;
        _60 = core::fmt::rt::Argument::<'_>::new_debug::<std::io::Error>(_61) -> [return: bb29, unwind: bb38];
    }

    bb29: {
        _56 = [move _57, move _60];
        _55 = &_56;
        _54 = _55 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _66 = core::fmt::rt::Alignment::Unknown;
        _67 = core::fmt::rt::Count::Implied;
        _68 = core::fmt::rt::Count::Implied;
        _65 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _66, const 0_u32, move _67, move _68) -> [return: bb30, unwind: bb38];
    }

    bb30: {
        _70 = core::fmt::rt::Alignment::Unknown;
        _71 = core::fmt::rt::Count::Implied;
        _72 = core::fmt::rt::Count::Implied;
        _69 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _70, const 4_u32, move _71, move _72) -> [return: bb31, unwind: bb38];
    }

    bb31: {
        _64 = [move _65, move _69];
        _63 = &_64;
        _62 = _63 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _73 = core::fmt::rt::UnsafeArg::new() -> [return: bb32, unwind: bb38];
    }

    bb32: {
        _52 = std::fmt::Arguments::<'_>::new_v1_formatted(move _53, move _54, move _62, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb33, unwind: bb38];
    }

    bb33: {
        _74 = _44;
        _76 = const _;
        _51 = __private_api_log(move _52, move _74, _76) -> [return: bb47, unwind: bb38];
    }

    bb34: {
        _83 = const false;
        _75 = move _19;
        _0 = FileTarget::<'_>::Broken(move _75);
        drop(_43) -> [return: bb35, unwind: bb39];
    }

    bb35: {
        drop(_25) -> [return: bb36, unwind: bb46];
    }

    bb36: {
        _83 = const false;
        goto -> bb37;
    }

    bb37: {
        return;
    }

    bb38 (cleanup): {
        drop(_43) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_25) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_25) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_19) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        resume;
    }

    bb43 (cleanup): {
        drop(_32) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        switchInt(_82) -> [0: bb39, otherwise: bb43];
    }

    bb45 (cleanup): {
        drop(_19) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        switchInt(_83) -> [0: bb42, otherwise: bb45];
    }

    bb47: {
        goto -> bb34;
    }
}

promoted[0] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 260_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Error following link ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::file";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::file", const "src/fs/file.rs", const 242_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Reading link "];
        _0 = &_1;
        return;
    }
}

promoted[5] in file::<impl at src/fs/file.rs:68:1: 68:22>::link_target: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::links(_1: &file::File<'_>) -> fields::Links {
    debug self => _1;
    let mut _0: fs::fields::Links;
    let _2: u64;
    let mut _3: &std::fs::Metadata;
    let mut _4: bool;
    let mut _5: bool;
    scope 1 {
        debug count => _2;
    }

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::nlink(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = file::File::<'_>::is_file(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _4 = Gt(_2, const 1_u64);
        goto -> bb5;
    }

    bb4: {
        _4 = const false;
        goto -> bb5;
    }

    bb5: {
        _0 = fields::Links { count: _2, multiple: move _4 };
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::inode(_1: &file::File<'_>) -> Inode {
    debug self => _1;
    let mut _0: fs::fields::Inode;
    let mut _2: u64;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::ino(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Inode(move _2);
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::blocks(_1: &file::File<'_>) -> Blocks {
    debug self => _1;
    let mut _0: fs::fields::Blocks;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: u64;
    let mut _5: &std::fs::Metadata;

    bb0: {
        _2 = file::File::<'_>::is_file(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _3 = file::File::<'_>::is_link(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _3) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _5 = &((*_1).3: std::fs::Metadata);
        _4 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::blocks(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Blocks::Some(move _4);
        goto -> bb7;
    }

    bb6: {
        _0 = Blocks::None;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::user(_1: &file::File<'_>) -> fields::User {
    debug self => _1;
    let mut _0: fs::fields::User;
    let mut _2: u32;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::uid(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = fields::User(move _2);
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::group(_1: &file::File<'_>) -> fields::Group {
    debug self => _1;
    let mut _0: fs::fields::Group;
    let mut _2: u32;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::gid(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = fields::Group(move _2);
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::size(_1: &file::File<'_>) -> fields::Size {
    debug self => _1;
    let mut _0: fs::fields::Size;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let _5: [u8; 8];
    let mut _6: u64;
    let mut _7: &std::fs::Metadata;
    let mut _8: fs::fields::DeviceIDs;
    let mut _9: u8;
    let _10: usize;
    let mut _11: usize;
    let mut _12: bool;
    let mut _13: u8;
    let _14: usize;
    let mut _15: usize;
    let mut _16: bool;
    let mut _17: u64;
    let mut _18: &std::fs::Metadata;
    scope 1 {
        debug device_ids => _5;
    }

    bb0: {
        _2 = file::File::<'_>::is_directory(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = fields::Size::None;
        goto -> bb14;
    }

    bb3: {
        _3 = file::File::<'_>::is_char_device(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _3) -> [0: bb5, otherwise: bb7];
    }

    bb5: {
        _4 = file::File::<'_>::is_block_device(_1) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _4) -> [0: bb12, otherwise: bb7];
    }

    bb7: {
        _7 = &((*_1).3: std::fs::Metadata);
        _6 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::rdev(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        _5 = core::num::<impl u64>::to_be_bytes(move _6) -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = const 6_usize;
        _11 = const 8_usize;
        _12 = Lt(_10, _11);
        assert(move _12, "index out of bounds: the length is {} but the index is {}", move _11, _10) -> [success: bb10, unwind continue];
    }

    bb10: {
        _9 = _5[_10];
        _14 = const 7_usize;
        _15 = const 8_usize;
        _16 = Lt(_14, _15);
        assert(move _16, "index out of bounds: the length is {} but the index is {}", move _15, _14) -> [success: bb11, unwind continue];
    }

    bb11: {
        _13 = _5[_14];
        _8 = DeviceIDs { major: move _9, minor: move _13 };
        _0 = fields::Size::DeviceIDs(move _8);
        goto -> bb14;
    }

    bb12: {
        _18 = &((*_1).3: std::fs::Metadata);
        _17 = std::fs::Metadata::len(move _18) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = fields::Size::Some(move _17);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::modified_time(_1: &file::File<'_>) -> Option<SystemTime> {
    debug self => _1;
    let mut _0: std::option::Option<std::time::SystemTime>;
    let mut _2: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = std::fs::Metadata::modified(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<SystemTime, std::io::Error>::ok(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::changed_time(_1: &file::File<'_>) -> Option<SystemTime> {
    debug self => _1;
    let mut _0: std::option::Option<std::time::SystemTime>;
    let mut _2: i64;
    let mut _3: i64;
    let mut _4: (i64, i64);
    let mut _5: i64;
    let mut _6: &std::fs::Metadata;
    let mut _7: i64;
    let mut _8: &std::fs::Metadata;
    let mut _9: bool;
    let mut _10: i64;
    let mut _11: bool;
    let mut _12: i64;
    let mut _13: (i64, bool);
    let mut _14: (i64, bool);
    let mut _16: u64;
    let mut _17: i64;
    let mut _18: i64;
    let mut _19: u32;
    let mut _20: i64;
    let mut _21: i64;
    let mut _22: std::time::SystemTime;
    let mut _24: u64;
    let mut _25: i64;
    let mut _26: u32;
    let mut _27: i64;
    let mut _28: std::time::SystemTime;
    scope 1 {
        debug sec => _2;
        debug nanosec => _3;
        let _15: std::time::Duration;
        let _23: std::time::Duration;
        scope 2 {
            debug duration => _15;
        }
        scope 3 {
            debug duration => _23;
        }
    }

    bb0: {
        _6 = &((*_1).3: std::fs::Metadata);
        _5 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::ctime(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &((*_1).3: std::fs::Metadata);
        _7 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::ctime_nsec(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = (move _5, move _7);
        _2 = (_4.0: i64);
        _3 = (_4.1: i64);
        _10 = _2;
        _9 = Lt(move _10, const 0_i64);
        switchInt(move _9) -> [0: bb12, otherwise: bb3];
    }

    bb3: {
        _12 = _3;
        _11 = Gt(move _12, const 0_i64);
        switchInt(move _11) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _13 = CheckedAdd(_2, const 1_i64);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i64) -> [success: bb5, unwind continue];
    }

    bb5: {
        _2 = move (_13.0: i64);
        _14 = CheckedSub(_3, const 1000000000_i64);
        assert(!move (_14.1: bool), "attempt to compute `{} - {}`, which would overflow", _3, const 1000000000_i64) -> [success: bb6, unwind continue];
    }

    bb6: {
        _3 = move (_14.0: i64);
        goto -> bb7;
    }

    bb7: {
        _18 = _2;
        _17 = core::num::<impl i64>::abs(move _18) -> [return: bb8, unwind continue];
    }

    bb8: {
        _16 = move _17 as u64 (IntToInt);
        _21 = _3;
        _20 = core::num::<impl i64>::abs(move _21) -> [return: bb9, unwind continue];
    }

    bb9: {
        _19 = move _20 as u32 (IntToInt);
        _15 = std::time::Duration::new(move _16, move _19) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = <SystemTime as Sub<std::time::Duration>>::sub(const _, _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = Option::<SystemTime>::Some(move _22);
        goto -> bb15;
    }

    bb12: {
        _25 = _2;
        _24 = move _25 as u64 (IntToInt);
        _27 = _3;
        _26 = move _27 as u32 (IntToInt);
        _23 = std::time::Duration::new(move _24, move _26) -> [return: bb13, unwind continue];
    }

    bb13: {
        _28 = <SystemTime as Add<std::time::Duration>>::add(const _, _23) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = Option::<SystemTime>::Some(move _28);
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::accessed_time(_1: &file::File<'_>) -> Option<SystemTime> {
    debug self => _1;
    let mut _0: std::option::Option<std::time::SystemTime>;
    let mut _2: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = std::fs::Metadata::accessed(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<SystemTime, std::io::Error>::ok(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::created_time(_1: &file::File<'_>) -> Option<SystemTime> {
    debug self => _1;
    let mut _0: std::option::Option<std::time::SystemTime>;
    let mut _2: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _3: &std::fs::Metadata;

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = std::fs::Metadata::created(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<SystemTime, std::io::Error>::ok(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::type_char(_1: &file::File<'_>) -> Type {
    debug self => _1;
    let mut _0: fs::fields::Type;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;

    bb0: {
        _2 = file::File::<'_>::is_file(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Type::File;
        goto -> bb22;
    }

    bb3: {
        _3 = file::File::<'_>::is_directory(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _3) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = Type::Directory;
        goto -> bb22;
    }

    bb6: {
        _4 = file::File::<'_>::is_pipe(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _4) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Type::Pipe;
        goto -> bb22;
    }

    bb9: {
        _5 = file::File::<'_>::is_link(_1) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _5) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = Type::Link;
        goto -> bb22;
    }

    bb12: {
        _6 = file::File::<'_>::is_char_device(_1) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _6) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = Type::CharDevice;
        goto -> bb22;
    }

    bb15: {
        _7 = file::File::<'_>::is_block_device(_1) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _7) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = Type::BlockDevice;
        goto -> bb22;
    }

    bb18: {
        _8 = file::File::<'_>::is_socket(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        switchInt(move _8) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _0 = Type::Socket;
        goto -> bb22;
    }

    bb21: {
        _0 = Type::Special;
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::permissions(_1: &file::File<'_>) -> fields::Permissions {
    debug self => _1;
    let mut _0: fs::fields::Permissions;
    let _2: u32;
    let mut _3: &std::fs::Metadata;
    let mut _5: &u32;
    let mut _6: bool;
    let mut _7: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _8: (u32,);
    let mut _9: bool;
    let mut _10: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _11: (u32,);
    let mut _12: bool;
    let mut _13: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _14: (u32,);
    let mut _15: bool;
    let mut _16: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _17: (u32,);
    let mut _18: bool;
    let mut _19: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _20: (u32,);
    let mut _21: bool;
    let mut _22: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _23: (u32,);
    let mut _24: bool;
    let mut _25: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _26: (u32,);
    let mut _27: bool;
    let mut _28: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _29: (u32,);
    let mut _30: bool;
    let mut _31: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _32: (u32,);
    let mut _33: bool;
    let mut _34: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _35: (u32,);
    let mut _36: bool;
    let mut _37: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _38: (u32,);
    let mut _39: bool;
    let mut _40: &{closure@src/fs/file.rs:407:23: 407:28};
    let mut _41: (u32,);
    scope 1 {
        debug bits => _2;
        let _4: {closure@src/fs/file.rs:407:23: 407:28};
        scope 2 {
            debug has_bit => _4;
        }
    }

    bb0: {
        _3 = &((*_1).3: std::fs::Metadata);
        _2 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::mode(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &_2;
        _4 = {closure@src/fs/file.rs:407:23: 407:28} { bits: move _5 };
        _7 = &_4;
        _8 = (const _,);
        _6 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _7, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &_4;
        _11 = (const _,);
        _9 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _10, move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = &_4;
        _14 = (const _,);
        _12 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _13, move _14) -> [return: bb4, unwind continue];
    }

    bb4: {
        _16 = &_4;
        _17 = (const _,);
        _15 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _16, move _17) -> [return: bb5, unwind continue];
    }

    bb5: {
        _19 = &_4;
        _20 = (const _,);
        _18 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _19, move _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _22 = &_4;
        _23 = (const _,);
        _21 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _22, move _23) -> [return: bb7, unwind continue];
    }

    bb7: {
        _25 = &_4;
        _26 = (const _,);
        _24 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _25, move _26) -> [return: bb8, unwind continue];
    }

    bb8: {
        _28 = &_4;
        _29 = (const _,);
        _27 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _28, move _29) -> [return: bb9, unwind continue];
    }

    bb9: {
        _31 = &_4;
        _32 = (const _,);
        _30 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _31, move _32) -> [return: bb10, unwind continue];
    }

    bb10: {
        _34 = &_4;
        _35 = (const _,);
        _33 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _34, move _35) -> [return: bb11, unwind continue];
    }

    bb11: {
        _37 = &_4;
        _38 = (const _,);
        _36 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _37, move _38) -> [return: bb12, unwind continue];
    }

    bb12: {
        _40 = &_4;
        _41 = (const _,);
        _39 = <{closure@src/fs/file.rs:407:23: 407:28} as Fn<(u32,)>>::call(move _40, move _41) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = fields::Permissions { user_read: move _6, user_write: move _9, user_execute: move _12, group_read: move _15, group_write: move _18, group_execute: move _21, other_read: move _24, other_write: move _27, other_execute: move _30, sticky: move _33, setgid: move _36, setuid: move _39 };
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::permissions::{closure#0}(_1: &{closure@src/fs/file.rs:407:23: 407:28}, _2: u32) -> bool {
    debug bit => _2;
    debug bits => (*((*_1).0: &u32));
    let mut _0: bool;
    let mut _3: u32;
    let mut _4: u32;
    let mut _5: &u32;

    bb0: {
        _5 = deref_copy ((*_1).0: &u32);
        _4 = (*_5);
        _3 = BitAnd(move _4, _2);
        _0 = Eq(move _3, _2);
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::extension_is_one_of(_1: &file::File<'_>, _2: &[&str]) -> bool {
    debug self => _1;
    debug choices => _2;
    let mut _0: bool;
    let mut _3: &std::option::Option<std::string::String>;
    let mut _4: isize;
    let _5: &std::string::String;
    let _6: &&str;
    let _7: &str;
    let _8: &str;
    scope 1 {
        debug ext => _5;
    }

    bb0: {
        _3 = &((*_1).1: std::option::Option<std::string::String>);
        _4 = discriminant((*_3));
        switchInt(move _4) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = &(((*_3) as Some).0: std::string::String);
        _8 = <String as std::ops::Index<RangeFull>>::index(_5, const RangeFull) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = _8;
        _6 = &_7;
        _0 = core::slice::<impl [&str]>::contains(_2, _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:68:1: 68:22>::name_is_one_of(_1: &file::File<'_>, _2: &[&str]) -> bool {
    debug self => _1;
    debug choices => _2;
    let mut _0: bool;
    let _3: &&str;
    let _4: &str;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &((*_1).0: std::string::String);
        _5 = <String as std::ops::Index<RangeFull>>::index(move _6, const RangeFull) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = _5;
        _3 = &_4;
        _0 = core::slice::<impl [&str]>::contains(_2, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn file::<impl at src/fs/file.rs:446:1: 446:38>::as_ref(_1: &file::File<'_>) -> &file::File<'_> {
    debug self => _1;
    let mut _0: &fs::file::File<'_>;

    bb0: {
        _0 = _1;
        return;
    }
}

fn file::<impl at src/fs/file.rs:473:1: 473:28>::is_broken(_1: &FileTarget<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb2, 2: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _0 = const true;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

const USER_READ: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const USER_WRITE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const USER_EXECUTE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const GROUP_READ: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const GROUP_WRITE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const GROUP_EXECUTE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const OTHER_READ: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const OTHER_WRITE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const OTHER_EXECUTE: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const STICKY: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const SETGID: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

const SETUID: u32 = {
    let mut _0: u32;

    bb0: {
        _0 = const _;
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:22:10: 22:19>::eq(_1: &DirAction, _2: &DirAction) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&fs::dir_action::DirAction, &fs::dir_action::DirAction);
    let mut _7: isize;
    let mut _8: isize;
    let mut _11: &fs::dir_action::DirAction;
    let mut _12: &fs::dir_action::DirAction;
    let mut _13: &fs::dir_action::DirAction;
    let mut _14: &fs::dir_action::DirAction;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _9: &fs::dir_action::RecurseOptions;
            let _10: &fs::dir_action::RecurseOptions;
            scope 3 {
                debug __self_0 => _9;
                debug __arg1_0 => _10;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _11 = deref_copy (_6.0: &fs::dir_action::DirAction);
        _8 = discriminant((*_11));
        switchInt(move _8) -> [2: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = const false;
        goto -> bb6;
    }

    bb3: {
        _0 = const true;
        goto -> bb6;
    }

    bb4: {
        _12 = deref_copy (_6.1: &fs::dir_action::DirAction);
        _7 = discriminant((*_12));
        switchInt(move _7) -> [2: bb5, otherwise: bb3];
    }

    bb5: {
        _13 = deref_copy (_6.0: &fs::dir_action::DirAction);
        _9 = &(((*_13) as Recurse).0: fs::dir_action::RecurseOptions);
        _14 = deref_copy (_6.1: &fs::dir_action::DirAction);
        _10 = &(((*_14) as Recurse).0: fs::dir_action::RecurseOptions);
        _0 = <RecurseOptions as PartialEq>::eq(_9, _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:22:21: 22:26>::fmt(_1: &DirAction, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &fs::dir_action::RecurseOptions;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&fs::dir_action::RecurseOptions;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = &(((*_1) as Recurse).0: fs::dir_action::RecurseOptions);
        _7 = const "Recurse";
        _9 = &_6;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "AsFile";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb5, unwind continue];
    }

    bb4: {
        _5 = const "List";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:22:34: 22:39>::clone(_1: &DirAction) -> DirAction {
    debug self => _1;
    let mut _0: fs::dir_action::DirAction;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:39:1: 39:15>::recurse_options(_1: DirAction) -> Option<RecurseOptions> {
    debug self => _1;
    let mut _0: std::option::Option<fs::dir_action::RecurseOptions>;
    let mut _2: isize;
    let _3: fs::dir_action::RecurseOptions;
    scope 1 {
        debug o => _3;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [2: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<RecurseOptions>::None;
        goto -> bb3;
    }

    bb2: {
        _3 = ((_1 as Recurse).0: fs::dir_action::RecurseOptions);
        _0 = Option::<RecurseOptions>::Some(_3);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:39:1: 39:15>::treat_dirs_as_files(_1: DirAction) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;
    let _3: fs::dir_action::RecurseOptions;
    scope 1 {
        debug o => _3;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 2: bb3, otherwise: bb1];
    }

    bb1: {
        _0 = const false;
        goto -> bb4;
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _3 = ((_1 as Recurse).0: fs::dir_action::RecurseOptions);
        _0 = (_3.0: bool);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:61:10: 61:19>::eq(_1: &RecurseOptions, _2: &RecurseOptions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: &std::option::Option<usize>;
    let mut _7: &std::option::Option<usize>;

    bb0: {
        _4 = ((*_1).0: bool);
        _5 = ((*_2).0: bool);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).1: std::option::Option<usize>);
        _7 = &((*_2).1: std::option::Option<usize>);
        _0 = <Option<usize> as PartialEq>::eq(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb2: {
        _0 = const false;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:61:21: 61:26>::fmt(_1: &RecurseOptions, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &bool;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::option::Option<usize>;
    let _10: &std::option::Option<usize>;

    bb0: {
        _3 = const "RecurseOptions";
        _4 = const "tree";
        _6 = &((*_1).0: bool);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "max_depth";
        _10 = &((*_1).1: std::option::Option<usize>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:61:34: 61:39>::clone(_1: &RecurseOptions) -> RecurseOptions {
    debug self => _1;
    let mut _0: fs::dir_action::RecurseOptions;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fs::dir_action::<impl at src/fs/dir_action.rs:73:1: 73:20>::is_too_deep(_1: RecurseOptions, _2: usize) -> bool {
    debug self => _1;
    debug depth => _2;
    let mut _0: bool;
    let mut _3: isize;
    let _4: usize;
    scope 1 {
        debug d => _4;
    }

    bb0: {
        _3 = discriminant((_1.1: std::option::Option<usize>));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = (((_1.1: std::option::Option<usize>) as Some).0: usize);
        _0 = Le(_4, _2);
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

const ENABLED: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn xattr::<impl at src/fs/feature/xattr.rs:19:1: 19:29>::attributes(_1: &Path) -> Result<Vec<Attribute>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<fs::feature::xattr::Attribute>, std::io::Error>;
    let _2: &fs::feature::xattr::lister::Lister;
    let _3: fs::feature::xattr::lister::Lister;
    let mut _4: fs::feature::xattr::FollowSymlinks;

    bb0: {
        _4 = FollowSymlinks::Yes;
        _3 = Lister::new(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = list_attrs(_2, _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn xattr::<impl at src/fs/feature/xattr.rs:19:1: 19:29>::symlink_attributes(_1: &Path) -> Result<Vec<Attribute>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<fs::feature::xattr::Attribute>, std::io::Error>;
    let _2: &fs::feature::xattr::lister::Lister;
    let _3: fs::feature::xattr::lister::Lister;
    let mut _4: fs::feature::xattr::FollowSymlinks;

    bb0: {
        _4 = FollowSymlinks::No;
        _3 = Lister::new(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = list_attrs(_2, _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn xattr::<impl at src/fs/feature/xattr.rs:43:16: 43:21>::clone(_1: &FollowSymlinks) -> FollowSymlinks {
    debug self => _1;
    let mut _0: fs::feature::xattr::FollowSymlinks;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn xattr::<impl at src/fs/feature/xattr.rs:50:10: 50:15>::fmt(_1: &Attribute, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::string::String;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&usize;
    let _10: &usize;

    bb0: {
        _3 = const "Attribute";
        _4 = const "name";
        _6 = &((*_1).0: std::string::String);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "size";
        _10 = &((*_1).1: usize);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn xattr::<impl at src/fs/feature/xattr.rs:50:17: 50:22>::clone(_1: &Attribute) -> Attribute {
    debug self => _1;
    let mut _0: fs::feature::xattr::Attribute;
    let mut _2: std::string::String;
    let _3: &std::string::String;
    let mut _4: usize;
    let _5: &usize;

    bb0: {
        _3 = &((*_1).0: std::string::String);
        _2 = <String as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: usize);
        _4 = (*_5);
        _0 = Attribute { name: move _2, size: move _4 };
        return;
    }
}

fn list_attrs(_1: &Lister, _2: &Path) -> Result<Vec<Attribute>, std::io::Error> {
    debug lister => _1;
    debug path => _2;
    let mut _0: std::result::Result<std::vec::Vec<fs::feature::xattr::Attribute>, std::io::Error>;
    let _3: std::ffi::CString;
    let mut _4: std::option::Option<std::ffi::CString>;
    let mut _5: std::option::Option<&str>;
    let mut _6: isize;
    let _7: std::ffi::CString;
    let mut _8: std::io::Error;
    let mut _9: std::io::ErrorKind;
    let _11: &std::ffi::CString;
    let mut _12: std::cmp::Ordering;
    let mut _13: &isize;
    let mut _14: i8;
    let mut _15: std::io::Error;
    let mut _16: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _18: usize;
    let mut _19: isize;
    let _21: &std::ffi::CString;
    let mut _22: &mut std::vec::Vec<u8>;
    let mut _23: isize;
    let mut _24: std::cmp::Ordering;
    let mut _25: &isize;
    let mut _26: i8;
    let mut _27: std::io::Error;
    let mut _28: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _30: bool;
    let mut _31: isize;
    let mut _33: std::iter::Enumerate<std::slice::Iter<'_, u8>>;
    let mut _34: std::slice::Iter<'_, u8>;
    let _35: &[u8];
    let mut _36: &std::vec::Vec<u8>;
    let mut _38: std::iter::FilterMap<std::iter::Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}>;
    let mut _40: std::option::Option<usize>;
    let mut _41: &mut std::iter::FilterMap<std::iter::Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}>;
    let mut _42: isize;
    let mut _45: (usize, bool);
    let _47: &std::ffi::CString;
    let _48: &[u8];
    let mut _49: &std::vec::Vec<u8>;
    let mut _50: std::ops::Range<usize>;
    let mut _51: usize;
    let mut _52: bool;
    let _53: ();
    let mut _54: &mut std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _55: fs::feature::xattr::Attribute;
    let mut _56: std::string::String;
    let _57: &[u8];
    let mut _58: &std::vec::Vec<u8>;
    let mut _59: std::ops::Range<usize>;
    let mut _60: usize;
    let mut _61: usize;
    let mut _62: std::vec::Vec<fs::feature::xattr::Attribute>;
    scope 1 {
        debug c_path => _3;
        let _10: isize;
        scope 3 {
            debug bufsize => _10;
            let mut _17: std::vec::Vec<u8>;
            let mut _64: &isize;
            scope 4 {
                debug buf => _17;
                let _20: isize;
                scope 5 {
                    debug err => _20;
                    let mut _29: std::vec::Vec<fs::feature::xattr::Attribute>;
                    let mut _63: &isize;
                    scope 6 {
                        debug names => _29;
                        let _32: std::iter::FilterMap<std::iter::Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}>;
                        scope 7 {
                            debug idx => _32;
                            let mut _37: usize;
                            scope 8 {
                                debug start => _37;
                                let mut _39: std::iter::FilterMap<std::iter::Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}>;
                                scope 9 {
                                    debug iter => _39;
                                    let _43: usize;
                                    scope 10 {
                                        debug end => _43;
                                        let _44: usize;
                                        scope 11 {
                                            debug c_end => _44;
                                            let _46: isize;
                                            scope 12 {
                                                debug size => _46;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug cstring => _7;
    }

    bb0: {
        _5 = Path::to_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<&str>::and_then::<CString, {closure@src/fs/feature/xattr.rs:61:47: 61:50}>(move _5, const ZeroSized: {closure@src/fs/feature/xattr.rs:61:47: 61:50}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = Other;
        _8 = std::io::Error::new::<&str>(move _9, const "Error: path somehow contained a NUL?") -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Some).0: std::ffi::CString);
        _3 = move _7;
        _11 = &_3;
        _10 = Lister::listxattr_first(_1, _11) -> [return: bb7, unwind: bb46];
    }

    bb6: {
        _0 = Result::<Vec<Attribute>, std::io::Error>::Err(move _8);
        goto -> bb43;
    }

    bb7: {
        _13 = &_10;
        _64 = const _;
        _12 = <isize as Ord>::cmp(move _13, _64) -> [return: bb8, unwind: bb46];
    }

    bb8: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [255: bb10, 0: bb12, 1: bb9, otherwise: bb4];
    }

    bb9: {
        _19 = _10;
        _18 = move _19 as usize (IntToInt);
        _17 = from_elem::<u8>(const 0_u8, move _18) -> [return: bb14, unwind: bb46];
    }

    bb10: {
        _15 = std::io::Error::last_os_error() -> [return: bb11, unwind: bb46];
    }

    bb11: {
        _0 = Result::<Vec<Attribute>, std::io::Error>::Err(move _15);
        goto -> bb42;
    }

    bb12: {
        _16 = Vec::<Attribute>::new() -> [return: bb13, unwind: bb46];
    }

    bb13: {
        _0 = Result::<Vec<Attribute>, std::io::Error>::Ok(move _16);
        goto -> bb42;
    }

    bb14: {
        _21 = &_3;
        _22 = &mut _17;
        _23 = _10;
        _20 = Lister::listxattr_second(_1, _21, _22, move _23) -> [return: bb15, unwind: bb45];
    }

    bb15: {
        _25 = &_20;
        _63 = const _;
        _24 = <isize as Ord>::cmp(move _25, _63) -> [return: bb16, unwind: bb45];
    }

    bb16: {
        _26 = discriminant(_24);
        switchInt(move _26) -> [255: bb18, 0: bb20, 1: bb17, otherwise: bb4];
    }

    bb17: {
        _29 = Vec::<Attribute>::new() -> [return: bb22, unwind: bb45];
    }

    bb18: {
        _27 = std::io::Error::last_os_error() -> [return: bb19, unwind: bb45];
    }

    bb19: {
        _0 = Result::<Vec<Attribute>, std::io::Error>::Err(move _27);
        goto -> bb41;
    }

    bb20: {
        _28 = Vec::<Attribute>::new() -> [return: bb21, unwind: bb45];
    }

    bb21: {
        _0 = Result::<Vec<Attribute>, std::io::Error>::Ok(move _28);
        goto -> bb41;
    }

    bb22: {
        _31 = _20;
        _30 = Gt(move _31, const 0_isize);
        switchInt(move _30) -> [0: bb39, otherwise: bb23];
    }

    bb23: {
        _36 = &_17;
        _35 = <Vec<u8> as Deref>::deref(move _36) -> [return: bb24, unwind: bb44];
    }

    bb24: {
        _34 = core::slice::<impl [u8]>::iter(_35) -> [return: bb25, unwind: bb44];
    }

    bb25: {
        _33 = <std::slice::Iter<'_, u8> as Iterator>::enumerate(move _34) -> [return: bb26, unwind: bb44];
    }

    bb26: {
        _32 = <Enumerate<std::slice::Iter<'_, u8>> as Iterator>::filter_map::<usize, {closure@src/fs/feature/xattr.rs:88:53: 88:61}>(move _33, const ZeroSized: {closure@src/fs/feature/xattr.rs:88:53: 88:61}) -> [return: bb27, unwind: bb44];
    }

    bb27: {
        _37 = const 0_usize;
        _38 = <FilterMap<Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}> as IntoIterator>::into_iter(move _32) -> [return: bb28, unwind: bb44];
    }

    bb28: {
        _39 = move _38;
        goto -> bb29;
    }

    bb29: {
        _41 = &mut _39;
        _40 = <FilterMap<Enumerate<std::slice::Iter<'_, u8>>, {closure@src/fs/feature/xattr.rs:88:53: 88:61}> as Iterator>::next(_41) -> [return: bb30, unwind: bb44];
    }

    bb30: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb39, 1: bb31, otherwise: bb4];
    }

    bb31: {
        _43 = ((_40 as Some).0: usize);
        _45 = CheckedAdd(_43, const 1_usize);
        assert(!move (_45.1: bool), "attempt to compute `{} + {}`, which would overflow", _43, const 1_usize) -> [success: bb32, unwind: bb44];
    }

    bb32: {
        _44 = move (_45.0: usize);
        _47 = &_3;
        _49 = &_17;
        _51 = _37;
        _50 = std::ops::Range::<usize> { start: move _51, end: _44 };
        _48 = <Vec<u8> as std::ops::Index<std::ops::Range<usize>>>::index(move _49, move _50) -> [return: bb33, unwind: bb44];
    }

    bb33: {
        _46 = Lister::getxattr(_1, _47, _48) -> [return: bb34, unwind: bb44];
    }

    bb34: {
        _52 = Gt(_46, const 0_isize);
        switchInt(move _52) -> [0: bb38, otherwise: bb35];
    }

    bb35: {
        _54 = &mut _29;
        _58 = &_17;
        _60 = _37;
        _59 = std::ops::Range::<usize> { start: move _60, end: _43 };
        _57 = <Vec<u8> as std::ops::Index<std::ops::Range<usize>>>::index(move _58, move _59) -> [return: bb36, unwind: bb44];
    }

    bb36: {
        _56 = Lister::translate_attribute_name(_1, _57) -> [return: bb37, unwind: bb44];
    }

    bb37: {
        _61 = _46 as usize (IntToInt);
        _55 = Attribute { name: move _56, size: move _61 };
        _53 = Vec::<Attribute>::push(move _54, move _55) -> [return: bb48, unwind: bb44];
    }

    bb38: {
        _37 = _44;
        goto -> bb29;
    }

    bb39: {
        _62 = move _29;
        _0 = Result::<Vec<Attribute>, std::io::Error>::Ok(move _62);
        drop(_17) -> [return: bb40, unwind: bb46];
    }

    bb40: {
        drop(_3) -> [return: bb43, unwind continue];
    }

    bb41: {
        drop(_17) -> [return: bb42, unwind: bb46];
    }

    bb42: {
        drop(_3) -> [return: bb43, unwind continue];
    }

    bb43: {
        return;
    }

    bb44 (cleanup): {
        drop(_29) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_17) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_3) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }

    bb48: {
        goto -> bb38;
    }
}

promoted[0] in list_attrs: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

promoted[1] in list_attrs: &isize = {
    let mut _0: &isize;
    let mut _1: isize;

    bb0: {
        _1 = const 0_isize;
        _0 = &_1;
        return;
    }
}

fn list_attrs::{closure#0}(_1: {closure@src/fs/feature/xattr.rs:61:47: 61:50}, _2: &str) -> Option<CString> {
    debug s => _2;
    let mut _0: std::option::Option<std::ffi::CString>;
    let mut _3: std::result::Result<std::ffi::CString, std::ffi::NulError>;

    bb0: {
        _3 = CString::new::<&str>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<CString, NulError>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn list_attrs::{closure#1}(_1: &mut {closure@src/fs/feature/xattr.rs:88:53: 88:61}, _2: (usize, &u8)) -> Option<usize> {
    let mut _0: std::option::Option<usize>;
    let _3: usize;
    let _4: &u8;
    let mut _5: u8;
    scope 1 {
        debug i => _3;
        debug v => _4;
    }

    bb0: {
        _3 = (_2.0: usize);
        _4 = (_2.1: &u8);
        _5 = (*_4);
        switchInt(move _5) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = Option::<usize>::Some(_3);
        goto -> bb3;
    }

    bb2: {
        _0 = Option::<usize>::None;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn lister::<impl at src/fs/feature/xattr.rs:232:5: 232:16>::new(_1: FollowSymlinks) -> Lister {
    debug follow_symlinks => _1;
    let mut _0: fs::feature::xattr::lister::Lister;

    bb0: {
        _0 = Lister { follow_symlinks: _1 };
        return;
    }
}

fn lister::<impl at src/fs/feature/xattr.rs:232:5: 232:16>::translate_attribute_name(_1: &Lister, _2: &[u8]) -> String {
    debug self => _1;
    debug input => _2;
    let mut _0: std::string::String;
    let mut _3: std::borrow::Cow<'_, str>;

    bb0: {
        _3 = String::from_utf8_lossy(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Cow::<'_, str>::into_owned(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn lister::<impl at src/fs/feature/xattr.rs:232:5: 232:16>::listxattr_first(_1: &Lister, _2: &CString) -> isize {
    debug self => _1;
    debug c_path => _2;
    let mut _0: isize;
    let _3: unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize;
    let mut _4: isize;
    let mut _5: unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize;
    let mut _6: *const i8;
    let _7: &std::ffi::CStr;
    let mut _8: *mut i8;
    scope 1 {
        debug listxattr => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = discriminant(((*_1).0: fs::feature::xattr::FollowSymlinks));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = fs::feature::xattr::lister::llistxattr as unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = fs::feature::xattr::lister::listxattr as unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb4: {
        _5 = _3;
        _7 = <CString as Deref>::deref(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = CStr::as_ptr(_7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = null_mut::<i8>() -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = move _5(_6, move _8, const 0_usize) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn lister::<impl at src/fs/feature/xattr.rs:232:5: 232:16>::listxattr_second(_1: &Lister, _2: &CString, _3: &mut Vec<u8>, _4: isize) -> isize {
    debug self => _1;
    debug c_path => _2;
    debug buf => _3;
    debug bufsize => _4;
    let mut _0: isize;
    let _5: unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize;
    let mut _6: isize;
    let mut _7: unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize;
    let mut _8: *const i8;
    let _9: &std::ffi::CStr;
    let mut _10: *mut i8;
    let mut _11: *mut u8;
    let mut _12: usize;
    scope 1 {
        debug listxattr => _5;
        scope 2 {
        }
    }

    bb0: {
        _6 = discriminant(((*_1).0: fs::feature::xattr::FollowSymlinks));
        switchInt(move _6) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = fs::feature::xattr::lister::llistxattr as unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = fs::feature::xattr::lister::listxattr as unsafe extern "C" fn(*const i8, *mut i8, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb4: {
        _7 = _5;
        _9 = <CString as Deref>::deref(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = CStr::as_ptr(_9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = Vec::<u8>::as_mut_ptr(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = move _11 as *mut i8 (PtrToPtr);
        _12 = _4 as usize (IntToInt);
        _0 = move _7(_8, move _10, move _12) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn lister::<impl at src/fs/feature/xattr.rs:232:5: 232:16>::getxattr(_1: &Lister, _2: &CString, _3: &[u8]) -> isize {
    debug self => _1;
    debug c_path => _2;
    debug buf => _3;
    let mut _0: isize;
    let _4: unsafe extern "C" fn(*const i8, *const i8, *mut libc::c_void, usize) -> isize;
    let mut _5: isize;
    let mut _6: unsafe extern "C" fn(*const i8, *const i8, *mut libc::c_void, usize) -> isize;
    let mut _7: *const i8;
    let _8: &std::ffi::CStr;
    let mut _9: *const i8;
    let mut _10: *const u8;
    let mut _11: *mut libc::c_void;
    scope 1 {
        debug getxattr => _4;
        scope 2 {
        }
    }

    bb0: {
        _5 = discriminant(((*_1).0: fs::feature::xattr::FollowSymlinks));
        switchInt(move _5) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = fs::feature::xattr::lister::lgetxattr as unsafe extern "C" fn(*const i8, *const i8, *mut libc::c_void, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = fs::feature::xattr::lister::getxattr as unsafe extern "C" fn(*const i8, *const i8, *mut libc::c_void, usize) -> isize (PointerCoercion(ReifyFnPointer));
        goto -> bb4;
    }

    bb4: {
        _6 = _4;
        _8 = <CString as Deref>::deref(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = CStr::as_ptr(_8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = move _10 as *const i8 (PtrToPtr);
        _11 = null_mut::<c_void>() -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = move _6(_7, move _9, move _11, const 0_usize) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:24:1: 24:14>::has_anything_for(_1: &GitCache, _2: &Path) -> bool {
    debug self => _1;
    debug index => _2;
    let mut _0: bool;
    let mut _3: &mut std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let mut _4: std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let _5: &[fs::feature::git::GitRepo];
    let mut _6: &std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _7: {closure@src/fs/feature/git.rs:26:31: 26:34};
    let mut _8: &&std::path::Path;

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<fs::feature::git::GitRepo>);
        _5 = <Vec<GitRepo> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [GitRepo]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &mut _4;
        _8 = &_2;
        _7 = {closure@src/fs/feature/git.rs:26:31: 26:34} { index: move _8 };
        _0 = <std::slice::Iter<'_, GitRepo> as Iterator>::any::<{closure@src/fs/feature/git.rs:26:31: 26:34}>(move _3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:24:1: 24:14>::has_anything_for::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:26:31: 26:34}, _2: &GitRepo) -> bool {
    debug e => _2;
    debug index => (*((*_1).0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: &&std::path::Path;
    let mut _4: &std::path::Path;

    bb0: {
        _3 = deref_copy ((*_1).0: &&std::path::Path);
        _4 = deref_copy (*_3);
        _0 = GitRepo::has_path(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:24:1: 24:14>::get(_1: &GitCache, _2: &Path, _3: bool) -> fields::Git {
    debug self => _1;
    debug index => _2;
    debug prefix_lookup => _3;
    let mut _0: fs::fields::Git;
    let mut _4: std::option::Option<fs::fields::Git>;
    let mut _5: std::option::Option<&fs::feature::git::GitRepo>;
    let mut _6: &mut std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let mut _7: std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let _8: &[fs::feature::git::GitRepo];
    let mut _9: &std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _10: {closure@src/fs/feature/git.rs:31:19: 31:22};
    let mut _11: &&std::path::Path;
    let mut _12: {closure@src/fs/feature/git.rs:32:18: 32:24};
    let mut _13: &&std::path::Path;
    let mut _14: &bool;

    bb0: {
        _9 = &((*_1).0: std::vec::Vec<fs::feature::git::GitRepo>);
        _8 = <Vec<GitRepo> as Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = core::slice::<impl [GitRepo]>::iter(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &mut _7;
        _11 = &_2;
        _10 = {closure@src/fs/feature/git.rs:31:19: 31:22} { index: move _11 };
        _5 = <std::slice::Iter<'_, GitRepo> as Iterator>::find::<{closure@src/fs/feature/git.rs:31:19: 31:22}>(move _6, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = &_2;
        _14 = &_3;
        _12 = {closure@src/fs/feature/git.rs:32:18: 32:24} { index: move _13, prefix_lookup: move _14 };
        _4 = Option::<&GitRepo>::map::<fields::Git, {closure@src/fs/feature/git.rs:32:18: 32:24}>(move _5, move _12) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<fields::Git>::unwrap_or_default(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:24:1: 24:14>::get::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:31:19: 31:22}, _2: &&GitRepo) -> bool {
    debug e => _2;
    debug index => (*((*_1).0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: &fs::feature::git::GitRepo;
    let mut _4: &&std::path::Path;
    let mut _5: &std::path::Path;

    bb0: {
        _3 = deref_copy (*_2);
        _4 = deref_copy ((*_1).0: &&std::path::Path);
        _5 = deref_copy (*_4);
        _0 = GitRepo::has_path(_3, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:24:1: 24:14>::get::{closure#1}(_1: {closure@src/fs/feature/git.rs:32:18: 32:24}, _2: &GitRepo) -> fields::Git {
    debug repo => _2;
    debug index => (*(_1.0: &&std::path::Path));
    debug prefix_lookup => (*(_1.1: &bool));
    let mut _0: fs::fields::Git;
    let mut _3: bool;
    let mut _4: &&std::path::Path;
    let mut _5: &std::path::Path;
    let mut _6: &bool;

    bb0: {
        _4 = deref_copy (_1.0: &&std::path::Path);
        _5 = deref_copy (*_4);
        _6 = deref_copy (_1.1: &bool);
        _3 = (*_6);
        _0 = GitRepo::search(_2, _5, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter(_1: I) -> GitCache {
    debug iter => _1;
    let mut _0: fs::feature::git::GitCache;
    let _2: <I as std::iter::IntoIterator>::IntoIter;
    let mut _4: std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _5: usize;
    let mut _6: (usize, std::option::Option<usize>);
    let mut _7: &<I as std::iter::IntoIterator>::IntoIter;
    let mut _8: std::vec::Vec<std::path::PathBuf>;
    let mut _9: <I as std::iter::IntoIterator>::IntoIter;
    let mut _10: <I as std::iter::IntoIterator>::IntoIter;
    let _12: ();
    let mut _13: std::option::Option<std::path::PathBuf>;
    let mut _14: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _15: isize;
    let mut _17: bool;
    let _18: &[std::path::PathBuf];
    let mut _19: &std::vec::Vec<std::path::PathBuf>;
    let _20: &std::path::PathBuf;
    let mut _22: bool;
    let mut _23: &log::Level;
    let mut _24: bool;
    let mut _25: &log::Level;
    let mut _26: &log::LevelFilter;
    let _27: log::LevelFilter;
    let _28: ();
    let mut _29: std::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 1];
    let _33: [core::fmt::rt::Argument<'_>; 1];
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &std::path::PathBuf;
    let mut _36: log::Level;
    let mut _37: bool;
    let mut _38: &mut std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let mut _39: std::slice::Iter<'_, fs::feature::git::GitRepo>;
    let _40: &[fs::feature::git::GitRepo];
    let mut _41: &std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _42: {closure@src/fs/feature/git.rs:52:42: 52:45};
    let mut _43: &std::path::PathBuf;
    let mut _45: bool;
    let mut _46: &log::Level;
    let mut _47: bool;
    let mut _48: &log::Level;
    let mut _49: &log::LevelFilter;
    let _50: log::LevelFilter;
    let _51: ();
    let mut _52: std::fmt::Arguments<'_>;
    let mut _53: &[&str];
    let mut _54: &[core::fmt::rt::Argument<'_>];
    let _55: &[core::fmt::rt::Argument<'_>; 1];
    let _56: [core::fmt::rt::Argument<'_>; 1];
    let mut _57: core::fmt::rt::Argument<'_>;
    let _58: &std::path::PathBuf;
    let mut _59: log::Level;
    let mut _60: std::result::Result<fs::feature::git::GitRepo, std::path::PathBuf>;
    let mut _61: std::path::PathBuf;
    let mut _62: isize;
    let mut _64: std::option::Option<&mut fs::feature::git::GitRepo>;
    let mut _65: &mut std::slice::IterMut<'_, fs::feature::git::GitRepo>;
    let mut _66: std::slice::IterMut<'_, fs::feature::git::GitRepo>;
    let mut _67: &mut [fs::feature::git::GitRepo];
    let mut _68: &mut std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _69: {closure@src/fs/feature/git.rs:58:69: 58:72};
    let mut _70: &fs::feature::git::GitRepo;
    let mut _71: isize;
    let mut _74: bool;
    let mut _75: &log::Level;
    let mut _76: bool;
    let mut _77: &log::Level;
    let mut _78: &log::LevelFilter;
    let _79: log::LevelFilter;
    let _80: ();
    let mut _81: std::fmt::Arguments<'_>;
    let mut _82: &[&str];
    let mut _83: &[core::fmt::rt::Argument<'_>];
    let _84: &[core::fmt::rt::Argument<'_>; 1];
    let _85: [core::fmt::rt::Argument<'_>; 1];
    let mut _86: core::fmt::rt::Argument<'_>;
    let _87: &std::path::PathBuf;
    let mut _88: log::Level;
    let _89: ();
    let mut _90: &mut std::vec::Vec<std::path::PathBuf>;
    let mut _91: std::path::PathBuf;
    let mut _93: bool;
    let mut _94: &log::Level;
    let mut _95: bool;
    let mut _96: &log::Level;
    let mut _97: &log::LevelFilter;
    let _98: log::LevelFilter;
    let _99: ();
    let mut _100: std::fmt::Arguments<'_>;
    let mut _101: &[&str];
    let mut _102: log::Level;
    let _103: ();
    let mut _104: &mut std::vec::Vec<fs::feature::git::GitRepo>;
    let mut _105: fs::feature::git::GitRepo;
    let mut _107: &mut std::vec::Vec<std::path::PathBuf>;
    let mut _120: bool;
    let mut _121: bool;
    let mut _122: bool;
    let mut _123: bool;
    scope 1 {
        debug iter => _2;
        let mut _3: fs::feature::git::GitCache;
        scope 2 {
            debug git => _3;
            let mut _11: <I as std::iter::IntoIterator>::IntoIter;
            scope 3 {
                debug iter => _11;
                let _16: std::path::PathBuf;
                scope 4 {
                    debug path => _16;
                    let _21: log::Level;
                    let _44: log::Level;
                    let _63: fs::feature::git::GitRepo;
                    let _106: std::path::PathBuf;
                    scope 5 {
                        debug lvl => _21;
                        let mut _108: &(&str, &str, &str, u32);
                        let mut _109: &[&str; 2];
                        let mut _110: &log::LevelFilter;
                    }
                    scope 6 {
                        debug lvl => _44;
                        let mut _111: &(&str, &str, &str, u32);
                        let mut _112: &[&str; 2];
                        let mut _113: &log::LevelFilter;
                    }
                    scope 7 {
                        debug r => _63;
                        let _92: log::Level;
                        scope 8 {
                            debug r2 => _72;
                            let _72: &mut fs::feature::git::GitRepo;
                            let _73: log::Level;
                            scope 9 {
                                debug lvl => _73;
                                let mut _117: &(&str, &str, &str, u32);
                                let mut _118: &[&str; 2];
                                let mut _119: &log::LevelFilter;
                            }
                        }
                        scope 10 {
                            debug lvl => _92;
                            let mut _114: &(&str, &str, &str, u32);
                            let mut _115: &[&str; 1];
                            let mut _116: &log::LevelFilter;
                        }
                    }
                    scope 11 {
                        debug miss => _106;
                    }
                }
            }
        }
    }

    bb0: {
        _123 = const false;
        _120 = const false;
        _121 = const false;
        _122 = const false;
        _2 = <I as IntoIterator>::into_iter(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _123 = const true;
        _7 = &_2;
        _6 = <<I as IntoIterator>::IntoIter as Iterator>::size_hint(move _7) -> [return: bb2, unwind: bb83];
    }

    bb2: {
        _5 = (_6.0: usize);
        _4 = Vec::<GitRepo>::with_capacity(move _5) -> [return: bb3, unwind: bb83];
    }

    bb3: {
        _8 = Vec::<PathBuf>::new() -> [return: bb4, unwind: bb64];
    }

    bb4: {
        _3 = GitCache { repos: move _4, misses: move _8 };
        _123 = const false;
        _10 = move _2;
        _9 = <<I as IntoIterator>::IntoIter as IntoIterator>::into_iter(move _10) -> [return: bb5, unwind: bb63];
    }

    bb5: {
        _11 = move _9;
        goto -> bb6;
    }

    bb6: {
        _14 = &mut _11;
        _13 = <<I as IntoIterator>::IntoIter as Iterator>::next(_14) -> [return: bb7, unwind: bb62];
    }

    bb7: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _120 = const true;
        _16 = move ((_13 as Some).0: std::path::PathBuf);
        _19 = &(_3.1: std::vec::Vec<std::path::PathBuf>);
        _18 = <Vec<PathBuf> as Deref>::deref(move _19) -> [return: bb11, unwind: bb81];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        drop(_11) -> [return: bb61, unwind: bb63];
    }

    bb11: {
        _20 = &_16;
        _17 = core::slice::<impl [PathBuf]>::contains(_18, _20) -> [return: bb12, unwind: bb81];
    }

    bb12: {
        switchInt(move _17) -> [0: bb21, otherwise: bb13];
    }

    bb13: {
        _21 = log::Level::Debug;
        _23 = &_21;
        _110 = const _;
        _22 = <Level as PartialOrd<LevelFilter>>::le(move _23, _110) -> [return: bb14, unwind: bb81];
    }

    bb14: {
        switchInt(move _22) -> [0: bb59, otherwise: bb15];
    }

    bb15: {
        _25 = &_21;
        _27 = max_level() -> [return: bb16, unwind: bb81];
    }

    bb16: {
        _26 = &_27;
        _24 = <Level as PartialOrd<LevelFilter>>::le(move _25, move _26) -> [return: bb17, unwind: bb81];
    }

    bb17: {
        switchInt(move _24) -> [0: bb59, otherwise: bb18];
    }

    bb18: {
        _109 = const _;
        _30 = _109 as &[&str] (PointerCoercion(Unsize));
        _35 = &_16;
        _34 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_35) -> [return: bb19, unwind: bb81];
    }

    bb19: {
        _33 = [move _34];
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _29 = std::fmt::Arguments::<'_>::new_v1(move _30, move _31) -> [return: bb20, unwind: bb81];
    }

    bb20: {
        _36 = _21;
        _108 = const _;
        _28 = __private_api_log(move _29, move _36, _108) -> [return: bb84, unwind: bb81];
    }

    bb21: {
        _41 = &(_3.0: std::vec::Vec<fs::feature::git::GitRepo>);
        _40 = <Vec<GitRepo> as Deref>::deref(move _41) -> [return: bb22, unwind: bb81];
    }

    bb22: {
        _39 = core::slice::<impl [GitRepo]>::iter(_40) -> [return: bb23, unwind: bb81];
    }

    bb23: {
        _38 = &mut _39;
        _43 = &_16;
        _42 = {closure@src/fs/feature/git.rs:52:42: 52:45} { path: move _43 };
        _37 = <std::slice::Iter<'_, GitRepo> as Iterator>::any::<{closure@src/fs/feature/git.rs:52:42: 52:45}>(move _38, move _42) -> [return: bb24, unwind: bb81];
    }

    bb24: {
        switchInt(move _37) -> [0: bb33, otherwise: bb25];
    }

    bb25: {
        _44 = log::Level::Debug;
        _46 = &_44;
        _113 = const _;
        _45 = <Level as PartialOrd<LevelFilter>>::le(move _46, _113) -> [return: bb26, unwind: bb81];
    }

    bb26: {
        switchInt(move _45) -> [0: bb59, otherwise: bb27];
    }

    bb27: {
        _48 = &_44;
        _50 = max_level() -> [return: bb28, unwind: bb81];
    }

    bb28: {
        _49 = &_50;
        _47 = <Level as PartialOrd<LevelFilter>>::le(move _48, move _49) -> [return: bb29, unwind: bb81];
    }

    bb29: {
        switchInt(move _47) -> [0: bb59, otherwise: bb30];
    }

    bb30: {
        _112 = const _;
        _53 = _112 as &[&str] (PointerCoercion(Unsize));
        _58 = &_16;
        _57 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_58) -> [return: bb31, unwind: bb81];
    }

    bb31: {
        _56 = [move _57];
        _55 = &_56;
        _54 = _55 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _52 = std::fmt::Arguments::<'_>::new_v1(move _53, move _54) -> [return: bb32, unwind: bb81];
    }

    bb32: {
        _59 = _44;
        _111 = const _;
        _51 = __private_api_log(move _52, move _59, _111) -> [return: bb85, unwind: bb81];
    }

    bb33: {
        _120 = const false;
        _61 = move _16;
        _60 = GitRepo::discover(move _61) -> [return: bb34, unwind: bb81];
    }

    bb34: {
        _62 = discriminant(_60);
        switchInt(move _62) -> [0: bb36, 1: bb35, otherwise: bb9];
    }

    bb35: {
        _106 = move ((_60 as Err).0: std::path::PathBuf);
        _107 = &mut (_3.1: std::vec::Vec<std::path::PathBuf>);
        _12 = Vec::<PathBuf>::push(move _107, move _106) -> [return: bb86, unwind: bb81];
    }

    bb36: {
        _121 = const true;
        _122 = const true;
        _63 = move ((_60 as Ok).0: fs::feature::git::GitRepo);
        _68 = &mut (_3.0: std::vec::Vec<fs::feature::git::GitRepo>);
        _67 = <Vec<GitRepo> as DerefMut>::deref_mut(move _68) -> [return: bb37, unwind: bb79];
    }

    bb37: {
        _66 = core::slice::<impl [GitRepo]>::iter_mut(_67) -> [return: bb38, unwind: bb79];
    }

    bb38: {
        _65 = &mut _66;
        _70 = &_63;
        _69 = {closure@src/fs/feature/git.rs:58:69: 58:72} { r: move _70 };
        _64 = <std::slice::IterMut<'_, GitRepo> as Iterator>::find::<{closure@src/fs/feature/git.rs:58:69: 58:72}>(move _65, move _69) -> [return: bb39, unwind: bb79];
    }

    bb39: {
        _71 = discriminant(_64);
        switchInt(move _71) -> [1: bb40, otherwise: bb50];
    }

    bb40: {
        _72 = move ((_64 as Some).0: &mut fs::feature::git::GitRepo);
        _73 = log::Level::Debug;
        _75 = &_73;
        _119 = const _;
        _74 = <Level as PartialOrd<LevelFilter>>::le(move _75, _119) -> [return: bb41, unwind: bb79];
    }

    bb41: {
        switchInt(move _74) -> [0: bb48, otherwise: bb42];
    }

    bb42: {
        _77 = &_73;
        _79 = max_level() -> [return: bb43, unwind: bb79];
    }

    bb43: {
        _78 = &_79;
        _76 = <Level as PartialOrd<LevelFilter>>::le(move _77, move _78) -> [return: bb44, unwind: bb79];
    }

    bb44: {
        switchInt(move _76) -> [0: bb48, otherwise: bb45];
    }

    bb45: {
        _118 = const _;
        _82 = _118 as &[&str] (PointerCoercion(Unsize));
        _87 = &((*_72).1: std::path::PathBuf);
        _86 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_87) -> [return: bb46, unwind: bb79];
    }

    bb46: {
        _85 = [move _86];
        _84 = &_85;
        _83 = _84 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _81 = std::fmt::Arguments::<'_>::new_v1(move _82, move _83) -> [return: bb47, unwind: bb79];
    }

    bb47: {
        _88 = _73;
        _117 = const _;
        _80 = __private_api_log(move _81, move _88, _117) -> [return: bb87, unwind: bb79];
    }

    bb48: {
        _90 = &mut ((*_72).3: std::vec::Vec<std::path::PathBuf>);
        _122 = const false;
        _91 = move (_63.2: std::path::PathBuf);
        _89 = Vec::<PathBuf>::push(move _90, move _91) -> [return: bb49, unwind: bb79];
    }

    bb49: {
        drop((_63.0: std::sync::Mutex<fs::feature::git::GitContents>)) -> [return: bb70, unwind: bb68];
    }

    bb50: {
        _92 = log::Level::Debug;
        _94 = &_92;
        _116 = const _;
        _93 = <Level as PartialOrd<LevelFilter>>::le(move _94, _116) -> [return: bb51, unwind: bb79];
    }

    bb51: {
        switchInt(move _93) -> [0: bb57, otherwise: bb52];
    }

    bb52: {
        _96 = &_92;
        _98 = max_level() -> [return: bb53, unwind: bb79];
    }

    bb53: {
        _97 = &_98;
        _95 = <Level as PartialOrd<LevelFilter>>::le(move _96, move _97) -> [return: bb54, unwind: bb79];
    }

    bb54: {
        switchInt(move _95) -> [0: bb57, otherwise: bb55];
    }

    bb55: {
        _115 = const _;
        _101 = _115 as &[&str] (PointerCoercion(Unsize));
        _100 = std::fmt::Arguments::<'_>::new_const(move _101) -> [return: bb56, unwind: bb79];
    }

    bb56: {
        _102 = _92;
        _114 = const _;
        _99 = __private_api_log(move _100, move _102, _114) -> [return: bb88, unwind: bb79];
    }

    bb57: {
        _104 = &mut (_3.0: std::vec::Vec<fs::feature::git::GitRepo>);
        _121 = const false;
        _122 = const false;
        _105 = move _63;
        _103 = Vec::<GitRepo>::push(move _104, move _105) -> [return: bb58, unwind: bb79];
    }

    bb58: {
        _121 = const false;
        _122 = const false;
        goto -> bb59;
    }

    bb59: {
        switchInt(_120) -> [0: bb60, otherwise: bb71];
    }

    bb60: {
        _120 = const false;
        goto -> bb6;
    }

    bb61: {
        _0 = move _3;
        _123 = const false;
        return;
    }

    bb62 (cleanup): {
        drop(_11) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_3) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_4) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        resume;
    }

    bb66: {
        _121 = const false;
        _121 = const false;
        _122 = const false;
        _120 = const false;
        goto -> bb6;
    }

    bb67 (cleanup): {
        drop((_63.3: std::vec::Vec<std::path::PathBuf>)) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop((_63.1: std::path::PathBuf)) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb69: {
        drop((_63.3: std::vec::Vec<std::path::PathBuf>)) -> [return: bb66, unwind: bb81];
    }

    bb70: {
        drop((_63.1: std::path::PathBuf)) -> [return: bb69, unwind: bb67];
    }

    bb71: {
        drop(_16) -> [return: bb60, unwind: bb62];
    }

    bb72 (cleanup): {
        drop((_63.3: std::vec::Vec<std::path::PathBuf>)) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        switchInt(_121) -> [0: bb81, otherwise: bb72];
    }

    bb74 (cleanup): {
        switchInt(_122) -> [0: bb73, otherwise: bb75];
    }

    bb75 (cleanup): {
        drop((_63.2: std::path::PathBuf)) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        drop((_63.1: std::path::PathBuf)) -> [return: bb74, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        switchInt(_121) -> [0: bb74, otherwise: bb76];
    }

    bb78 (cleanup): {
        drop((_63.0: std::sync::Mutex<fs::feature::git::GitContents>)) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        switchInt(_121) -> [0: bb77, otherwise: bb78];
    }

    bb80 (cleanup): {
        drop(_16) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        switchInt(_120) -> [0: bb62, otherwise: bb80];
    }

    bb82 (cleanup): {
        drop(_2) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        switchInt(_123) -> [0: bb65, otherwise: bb82];
    }

    bb84: {
        goto -> bb59;
    }

    bb85: {
        goto -> bb59;
    }

    bb86: {
        goto -> bb59;
    }

    bb87: {
        goto -> bb48;
    }

    bb88: {
        goto -> bb57;
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 50_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Skipping ", const " because it already came back Gitless"];
        _0 = &_1;
        return;
    }
}

promoted[2] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 53_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Skipping ", const " because we already queried it"];
        _0 = &_1;
        return;
    }
}

promoted[5] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 64_u32);
        _0 = &_1;
        return;
    }
}

promoted[7] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Discovered new Git repo"];
        _0 = &_1;
        return;
    }
}

promoted[8] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 59_u32);
        _0 = &_1;
        return;
    }
}

promoted[10] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Adding to existing repo (workdir matches with ", const ")"];
        _0 = &_1;
        return;
    }
}

promoted[11] in feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:52:42: 52:45}, _2: &GitRepo) -> bool {
    debug e => _2;
    debug path => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let _3: &std::path::Path;
    let mut _4: &std::path::PathBuf;

    bb0: {
        _4 = deref_copy ((*_1).0: &std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = GitRepo::has_path(_2, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:38:1: 38:40>::from_iter::{closure#1}(_1: &mut {closure@src/fs/feature/git.rs:58:69: 58:72}, _2: &&mut GitRepo) -> bool {
    debug e => _2;
    debug r => (*((*_1).0: &fs::feature::git::GitRepo));
    let mut _0: bool;
    let mut _3: &fs::feature::git::GitRepo;
    let _4: &std::path::Path;
    let _5: &std::path::PathBuf;
    let mut _6: &mut fs::feature::git::GitRepo;
    let mut _7: &fs::feature::git::GitRepo;

    bb0: {
        _6 = deref_copy (*_2);
        _3 = &(*_6);
        _7 = deref_copy ((*_1).0: &fs::feature::git::GitRepo);
        _5 = &((*_7).1: std::path::PathBuf);
        _4 = <PathBuf as Deref>::deref(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = GitRepo::has_workdir(move _3, _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search(_1: &GitRepo, _2: &Path, _3: bool) -> fields::Git {
    debug self => _1;
    debug index => _2;
    debug prefix_lookup => _3;
    let mut _0: fs::fields::Git;
    let mut _4: std::sync::MutexGuard<'_, fs::feature::git::GitContents>;
    let mut _5: std::result::Result<std::sync::MutexGuard<'_, fs::feature::git::GitContents>, std::sync::PoisonError<std::sync::MutexGuard<'_, fs::feature::git::GitContents>>>;
    let mut _6: &std::sync::Mutex<fs::feature::git::GitContents>;
    let mut _7: &fs::feature::git::GitContents;
    let mut _8: &std::sync::MutexGuard<'_, fs::feature::git::GitContents>;
    let mut _9: isize;
    let mut _12: bool;
    let mut _13: &log::Level;
    let mut _14: bool;
    let mut _15: &log::Level;
    let mut _16: &log::LevelFilter;
    let _17: log::LevelFilter;
    let _18: ();
    let mut _19: std::fmt::Arguments<'_>;
    let mut _20: &[&str];
    let mut _21: &[core::fmt::rt::Argument<'_>];
    let _22: &[core::fmt::rt::Argument<'_>; 1];
    let _23: [core::fmt::rt::Argument<'_>; 1];
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &&std::path::PathBuf;
    let _26: &std::path::PathBuf;
    let mut _27: log::Level;
    let mut _29: bool;
    let mut _30: &log::Level;
    let mut _31: bool;
    let mut _32: &log::Level;
    let mut _33: &log::LevelFilter;
    let _34: log::LevelFilter;
    let _35: ();
    let mut _36: std::fmt::Arguments<'_>;
    let mut _37: &[&str];
    let mut _38: &[core::fmt::rt::Argument<'_>];
    let _39: &[core::fmt::rt::Argument<'_>; 1];
    let _40: [core::fmt::rt::Argument<'_>; 1];
    let mut _41: core::fmt::rt::Argument<'_>;
    let _42: &&std::path::PathBuf;
    let _43: &std::path::PathBuf;
    let mut _44: log::Level;
    let mut _46: fs::feature::git::GitContents;
    let mut _47: &mut fs::feature::git::GitContents;
    let mut _48: &mut std::sync::MutexGuard<'_, fs::feature::git::GitContents>;
    let mut _49: fs::feature::git::GitContents;
    let _51: &git2::Repository;
    let _52: &std::path::Path;
    let _53: &std::path::PathBuf;
    let mut _55: &fs::feature::git::Git;
    let mut _57: &mut fs::feature::git::GitContents;
    let mut _58: &mut std::sync::MutexGuard<'_, fs::feature::git::GitContents>;
    let mut _59: fs::feature::git::GitContents;
    let mut _60: fs::feature::git::Git;
    let mut _67: bool;
    scope 1 {
        debug contents => _4;
        let _28: log::Level;
        let _45: git2::Repository;
        scope 2 {
            debug statuses => _10;
            let _10: &fs::feature::git::Git;
            let _11: log::Level;
            scope 3 {
                debug lvl => _11;
                let mut _64: &(&str, &str, &str, u32);
                let mut _65: &[&str; 2];
                let mut _66: &log::LevelFilter;
            }
        }
        scope 4 {
            debug lvl => _28;
            let mut _61: &(&str, &str, &str, u32);
            let mut _62: &[&str; 2];
            let mut _63: &log::LevelFilter;
        }
        scope 5 {
            debug repo => _45;
            let _50: fs::feature::git::Git;
            scope 6 {
                debug statuses => _50;
                let _54: fs::fields::Git;
                scope 7 {
                    debug result => _54;
                    let _56: fs::feature::git::GitContents;
                    scope 8 {
                        debug _processing => _56;
                    }
                }
            }
        }
    }

    bb0: {
        _67 = const false;
        _6 = &((*_1).0: std::sync::Mutex<fs::feature::git::GitContents>);
        _5 = Mutex::<GitContents>::lock(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Result::<MutexGuard<'_, GitContents>, PoisonError<MutexGuard<'_, GitContents>>>::unwrap(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &_4;
        _7 = <MutexGuard<'_, GitContents> as Deref>::deref(move _8) -> [return: bb3, unwind: bb35];
    }

    bb3: {
        _9 = discriminant((*_7));
        switchInt(move _9) -> [2: bb4, otherwise: bb14];
    }

    bb4: {
        _10 = &(((*_7) as After).0: fs::feature::git::Git);
        _11 = log::Level::Debug;
        _13 = &_11;
        _66 = const _;
        _12 = <Level as PartialOrd<LevelFilter>>::le(move _13, _66) -> [return: bb5, unwind: bb35];
    }

    bb5: {
        switchInt(move _12) -> [0: bb12, otherwise: bb6];
    }

    bb6: {
        _15 = &_11;
        _17 = max_level() -> [return: bb7, unwind: bb35];
    }

    bb7: {
        _16 = &_17;
        _14 = <Level as PartialOrd<LevelFilter>>::le(move _15, move _16) -> [return: bb8, unwind: bb35];
    }

    bb8: {
        switchInt(move _14) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _65 = const _;
        _20 = _65 as &[&str] (PointerCoercion(Unsize));
        _26 = &((*_1).1: std::path::PathBuf);
        _25 = &_26;
        _24 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_25) -> [return: bb10, unwind: bb35];
    }

    bb10: {
        _23 = [move _24];
        _22 = &_23;
        _21 = _22 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _19 = std::fmt::Arguments::<'_>::new_v1(move _20, move _21) -> [return: bb11, unwind: bb35];
    }

    bb11: {
        _27 = _11;
        _64 = const _;
        _18 = __private_api_log(move _19, move _27, _64) -> [return: bb39, unwind: bb35];
    }

    bb12: {
        _0 = feature::git::Git::status(_10, _2, _3) -> [return: bb13, unwind: bb35];
    }

    bb13: {
        drop(_4) -> [return: bb33, unwind continue];
    }

    bb14: {
        _28 = log::Level::Debug;
        _30 = &_28;
        _63 = const _;
        _29 = <Level as PartialOrd<LevelFilter>>::le(move _30, _63) -> [return: bb15, unwind: bb35];
    }

    bb15: {
        switchInt(move _29) -> [0: bb22, otherwise: bb16];
    }

    bb16: {
        _32 = &_28;
        _34 = max_level() -> [return: bb17, unwind: bb35];
    }

    bb17: {
        _33 = &_34;
        _31 = <Level as PartialOrd<LevelFilter>>::le(move _32, move _33) -> [return: bb18, unwind: bb35];
    }

    bb18: {
        switchInt(move _31) -> [0: bb22, otherwise: bb19];
    }

    bb19: {
        _62 = const _;
        _37 = _62 as &[&str] (PointerCoercion(Unsize));
        _43 = &((*_1).1: std::path::PathBuf);
        _42 = &_43;
        _41 = core::fmt::rt::Argument::<'_>::new_debug::<&PathBuf>(_42) -> [return: bb20, unwind: bb35];
    }

    bb20: {
        _40 = [move _41];
        _39 = &_40;
        _38 = _39 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _36 = std::fmt::Arguments::<'_>::new_v1(move _37, move _38) -> [return: bb21, unwind: bb35];
    }

    bb21: {
        _44 = _28;
        _61 = const _;
        _35 = __private_api_log(move _36, move _44, _61) -> [return: bb40, unwind: bb35];
    }

    bb22: {
        _48 = &mut _4;
        _47 = <MutexGuard<'_, GitContents> as DerefMut>::deref_mut(move _48) -> [return: bb23, unwind: bb35];
    }

    bb23: {
        _49 = GitContents::Processing;
        _46 = std::mem::replace::<GitContents>(_47, move _49) -> [return: bb24, unwind: bb35];
    }

    bb24: {
        _45 = GitContents::inner_repo(move _46) -> [return: bb25, unwind: bb35];
    }

    bb25: {
        _51 = &_45;
        _53 = &((*_1).1: std::path::PathBuf);
        _52 = <PathBuf as Deref>::deref(_53) -> [return: bb26, unwind: bb34];
    }

    bb26: {
        _50 = repo_to_statuses(_51, _52) -> [return: bb27, unwind: bb34];
    }

    bb27: {
        _67 = const true;
        _55 = &_50;
        _54 = feature::git::Git::status(move _55, _2, _3) -> [return: bb28, unwind: bb38];
    }

    bb28: {
        _58 = &mut _4;
        _57 = <MutexGuard<'_, GitContents> as DerefMut>::deref_mut(move _58) -> [return: bb29, unwind: bb38];
    }

    bb29: {
        _67 = const false;
        _60 = move _50;
        _59 = GitContents::After { statuses: move _60 };
        _56 = std::mem::replace::<GitContents>(_57, move _59) -> [return: bb30, unwind: bb38];
    }

    bb30: {
        _0 = _54;
        drop(_56) -> [return: bb31, unwind: bb38];
    }

    bb31: {
        _67 = const false;
        drop(_45) -> [return: bb32, unwind: bb35];
    }

    bb32: {
        drop(_4) -> [return: bb33, unwind continue];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_45) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_4) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        resume;
    }

    bb37 (cleanup): {
        drop(_50) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_67) -> [0: bb34, otherwise: bb37];
    }

    bb39: {
        goto -> bb12;
    }

    bb40: {
        goto -> bb22;
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 140_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Querying Git repo ", const " for the first time"];
        _0 = &_1;
        return;
    }
}

promoted[2] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 136_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Git repo ", const " has been found in cache"];
        _0 = &_1;
        return;
    }
}

promoted[5] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::search: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::has_workdir(_1: &GitRepo, _2: &Path) -> bool {
    debug self => _1;
    debug path => _2;
    let mut _0: bool;
    let mut _3: &std::path::PathBuf;
    let mut _4: &&std::path::Path;

    bb0: {
        _3 = &((*_1).1: std::path::PathBuf);
        _4 = &_2;
        _0 = <PathBuf as PartialEq<&Path>>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::has_path(_1: &GitRepo, _2: &Path) -> bool {
    debug self => _1;
    debug path => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::path::Path;
    let mut _5: &std::path::PathBuf;
    let mut _6: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _7: std::slice::Iter<'_, std::path::PathBuf>;
    let _8: &[std::path::PathBuf];
    let mut _9: &std::vec::Vec<std::path::PathBuf>;
    let mut _10: {closure@src/fs/feature/git.rs:155:78: 155:81};
    let mut _11: &&std::path::Path;

    bb0: {
        _4 = _2;
        _5 = &((*_1).2: std::path::PathBuf);
        _3 = Path::starts_with::<&PathBuf>(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb6;
    }

    bb3: {
        _9 = &((*_1).3: std::vec::Vec<std::path::PathBuf>);
        _8 = <Vec<PathBuf> as Deref>::deref(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = core::slice::<impl [PathBuf]>::iter(_8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = &mut _7;
        _11 = &_2;
        _10 = {closure@src/fs/feature/git.rs:155:78: 155:81} { path: move _11 };
        _0 = <std::slice::Iter<'_, PathBuf> as Iterator>::any::<{closure@src/fs/feature/git.rs:155:78: 155:81}>(move _6, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::has_path::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:155:78: 155:81}, _2: &PathBuf) -> bool {
    debug e => _2;
    debug path => (*((*_1).0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: &&std::path::Path;
    let mut _4: &std::path::Path;

    bb0: {
        _3 = deref_copy ((*_1).0: &&std::path::Path);
        _4 = deref_copy (*_3);
        _0 = Path::starts_with::<&PathBuf>(_4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover(_1: PathBuf) -> Result<GitRepo, PathBuf> {
    debug path => _1;
    let mut _0: std::result::Result<fs::feature::git::GitRepo, std::path::PathBuf>;
    let _2: log::Level;
    let mut _3: bool;
    let mut _4: &log::Level;
    let mut _5: bool;
    let mut _6: &log::Level;
    let mut _7: &log::LevelFilter;
    let _8: log::LevelFilter;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &std::path::PathBuf;
    let mut _17: log::Level;
    let _18: git2::Repository;
    let mut _19: std::result::Result<git2::Repository, git2::Error>;
    let mut _20: &std::path::PathBuf;
    let mut _21: isize;
    let _22: git2::Repository;
    let _23: git2::Error;
    let mut _25: bool;
    let mut _26: &log::Level;
    let mut _27: bool;
    let mut _28: &log::Level;
    let mut _29: &log::LevelFilter;
    let _30: log::LevelFilter;
    let _31: ();
    let mut _32: std::fmt::Arguments<'_>;
    let mut _33: &[&str];
    let mut _34: &[core::fmt::rt::Argument<'_>];
    let _35: &[core::fmt::rt::Argument<'_>; 1];
    let _36: [core::fmt::rt::Argument<'_>; 1];
    let mut _37: core::fmt::rt::Argument<'_>;
    let _38: &git2::Error;
    let mut _39: log::Level;
    let mut _40: std::path::PathBuf;
    let mut _41: std::option::Option<&std::path::Path>;
    let mut _42: &git2::Repository;
    let mut _43: isize;
    let mut _47: fs::feature::git::GitContents;
    let mut _48: git2::Repository;
    let mut _49: fs::feature::git::GitRepo;
    let mut _50: std::sync::Mutex<fs::feature::git::GitContents>;
    let mut _51: std::path::PathBuf;
    let mut _52: std::path::PathBuf;
    let mut _53: std::vec::Vec<std::path::PathBuf>;
    let mut _55: bool;
    let mut _56: &log::Level;
    let mut _57: bool;
    let mut _58: &log::Level;
    let mut _59: &log::LevelFilter;
    let _60: log::LevelFilter;
    let _61: ();
    let mut _62: std::fmt::Arguments<'_>;
    let mut _63: &[&str];
    let mut _64: log::Level;
    let mut _65: std::path::PathBuf;
    let mut _75: bool;
    let mut _76: bool;
    let mut _77: bool;
    scope 1 {
        debug lvl => _2;
        let mut _72: &(&str, &str, &str, u32);
        let mut _73: &[&str; 1];
        let mut _74: &log::LevelFilter;
    }
    scope 2 {
        debug repo => _18;
        let _54: log::Level;
        scope 6 {
            debug workdir => _44;
            let _44: &std::path::Path;
            let _45: std::path::PathBuf;
            scope 7 {
                debug workdir => _45;
                let _46: std::sync::Mutex<fs::feature::git::GitContents>;
                scope 8 {
                    debug contents => _46;
                }
            }
        }
        scope 9 {
            debug lvl => _54;
            let mut _69: &(&str, &str, &str, u32);
            let mut _70: &[&str; 1];
            let mut _71: &log::LevelFilter;
        }
    }
    scope 3 {
        debug r => _22;
    }
    scope 4 {
        debug e => _23;
        let _24: log::Level;
        scope 5 {
            debug lvl => _24;
            let mut _66: &(&str, &str, &str, u32);
            let mut _67: &[&str; 1];
            let mut _68: &log::LevelFilter;
        }
    }

    bb0: {
        _77 = const false;
        _75 = const false;
        _76 = const false;
        _77 = const true;
        _2 = log::Level::Info;
        _4 = &_2;
        _74 = const _;
        _3 = <Level as PartialOrd<LevelFilter>>::le(move _4, _74) -> [return: bb1, unwind: bb49];
    }

    bb1: {
        switchInt(move _3) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _6 = &_2;
        _8 = max_level() -> [return: bb3, unwind: bb49];
    }

    bb3: {
        _7 = &_8;
        _5 = <Level as PartialOrd<LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind: bb49];
    }

    bb4: {
        switchInt(move _5) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _73 = const _;
        _11 = _73 as &[&str] (PointerCoercion(Unsize));
        _16 = &_1;
        _15 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_16) -> [return: bb6, unwind: bb49];
    }

    bb6: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = std::fmt::Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb7, unwind: bb49];
    }

    bb7: {
        _17 = _2;
        _72 = const _;
        _9 = __private_api_log(move _10, move _17, _72) -> [return: bb50, unwind: bb49];
    }

    bb8: {
        _20 = &_1;
        _19 = git2::Repository::discover::<&PathBuf>(move _20) -> [return: bb9, unwind: bb49];
    }

    bb9: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _23 = move ((_19 as Err).0: git2::Error);
        _24 = log::Level::Error;
        _26 = &_24;
        _68 = const _;
        _25 = <Level as PartialOrd<LevelFilter>>::le(move _26, _68) -> [return: bb13, unwind: bb41];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _22 = move ((_19 as Ok).0: git2::Repository);
        _75 = const true;
        _18 = move _22;
        _42 = &_18;
        _41 = git2::Repository::workdir(move _42) -> [return: bb21, unwind: bb47];
    }

    bb13: {
        switchInt(move _25) -> [0: bb20, otherwise: bb14];
    }

    bb14: {
        _28 = &_24;
        _30 = max_level() -> [return: bb15, unwind: bb41];
    }

    bb15: {
        _29 = &_30;
        _27 = <Level as PartialOrd<LevelFilter>>::le(move _28, move _29) -> [return: bb16, unwind: bb41];
    }

    bb16: {
        switchInt(move _27) -> [0: bb20, otherwise: bb17];
    }

    bb17: {
        _67 = const _;
        _33 = _67 as &[&str] (PointerCoercion(Unsize));
        _38 = &_23;
        _37 = core::fmt::rt::Argument::<'_>::new_debug::<git2::Error>(_38) -> [return: bb18, unwind: bb41];
    }

    bb18: {
        _36 = [move _37];
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _32 = std::fmt::Arguments::<'_>::new_v1(move _33, move _34) -> [return: bb19, unwind: bb41];
    }

    bb19: {
        _39 = _24;
        _66 = const _;
        _31 = __private_api_log(move _32, move _39, _66) -> [return: bb51, unwind: bb41];
    }

    bb20: {
        _77 = const false;
        _40 = move _1;
        _0 = Result::<GitRepo, PathBuf>::Err(move _40);
        drop(_23) -> [return: bb36, unwind: bb49];
    }

    bb21: {
        _43 = discriminant(_41);
        switchInt(move _43) -> [1: bb22, otherwise: bb26];
    }

    bb22: {
        _44 = ((_41 as Some).0: &std::path::Path);
        _45 = Path::to_path_buf(_44) -> [return: bb23, unwind: bb47];
    }

    bb23: {
        _76 = const true;
        _75 = const false;
        _48 = move _18;
        _47 = GitContents::Before { repo: move _48 };
        _46 = Mutex::<GitContents>::new(move _47) -> [return: bb24, unwind: bb45];
    }

    bb24: {
        _50 = move _46;
        _76 = const false;
        _51 = move _45;
        _77 = const false;
        _52 = move _1;
        _53 = Vec::<PathBuf>::new() -> [return: bb25, unwind: bb38];
    }

    bb25: {
        _49 = GitRepo { contents: move _50, workdir: move _51, original_path: move _52, extra_paths: move _53 };
        _0 = Result::<GitRepo, PathBuf>::Ok(move _49);
        _76 = const false;
        goto -> bb34;
    }

    bb26: {
        _54 = log::Level::Warn;
        _56 = &_54;
        _71 = const _;
        _55 = <Level as PartialOrd<LevelFilter>>::le(move _56, _71) -> [return: bb27, unwind: bb47];
    }

    bb27: {
        switchInt(move _55) -> [0: bb33, otherwise: bb28];
    }

    bb28: {
        _58 = &_54;
        _60 = max_level() -> [return: bb29, unwind: bb47];
    }

    bb29: {
        _59 = &_60;
        _57 = <Level as PartialOrd<LevelFilter>>::le(move _58, move _59) -> [return: bb30, unwind: bb47];
    }

    bb30: {
        switchInt(move _57) -> [0: bb33, otherwise: bb31];
    }

    bb31: {
        _70 = const _;
        _63 = _70 as &[&str] (PointerCoercion(Unsize));
        _62 = std::fmt::Arguments::<'_>::new_const(move _63) -> [return: bb32, unwind: bb47];
    }

    bb32: {
        _64 = _54;
        _69 = const _;
        _61 = __private_api_log(move _62, move _64, _69) -> [return: bb52, unwind: bb47];
    }

    bb33: {
        _77 = const false;
        _65 = move _1;
        _0 = Result::<GitRepo, PathBuf>::Err(move _65);
        goto -> bb34;
    }

    bb34: {
        switchInt(_75) -> [0: bb35, otherwise: bb43];
    }

    bb35: {
        _75 = const false;
        goto -> bb37;
    }

    bb36: {
        _75 = const false;
        goto -> bb37;
    }

    bb37: {
        return;
    }

    bb38 (cleanup): {
        drop(_52) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_51) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_50) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_23) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        resume;
    }

    bb43: {
        drop(_18) -> [return: bb35, unwind: bb49];
    }

    bb44 (cleanup): {
        drop(_45) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_76) -> [0: bb47, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_18) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_75) -> [0: bb49, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop(_1) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        switchInt(_77) -> [0: bb42, otherwise: bb48];
    }

    bb50: {
        goto -> bb8;
    }

    bb51: {
        goto -> bb20;
    }

    bb52: {
        goto -> bb33;
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 165_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Error discovering Git repositories: "];
        _0 = &_1;
        return;
    }
}

promoted[2] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 176_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Repository has no workdir?"];
        _0 = &_1;
        return;
    }
}

promoted[5] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 161_u32);
        _0 = &_1;
        return;
    }
}

promoted[7] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Searching for Git repository above "];
        _0 = &_1;
        return;
    }
}

promoted[8] in feature::git::<impl at src/fs/feature/git.rs:119:1: 119:13>::discover: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:183:1: 183:17>::inner_repo(_1: GitContents) -> git2::Repository {
    debug self => _1;
    let mut _0: git2::Repository;
    let mut _2: isize;
    let _3: !;
    let mut _4: &&str;
    let mut _5: isize;
    scope 1 {
        debug repo => _0;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = move ((_1 as Before).0: git2::Repository);
        _5 = discriminant(_1);
        switchInt(move _5) -> [0: bb5, otherwise: bb6];
    }

    bb2: {
        _4 = const _;
        _3 = core::panicking::unreachable_display::<&str>(_4) -> bb3;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }

    bb5: {
        return;
    }

    bb6: {
        drop(_1) -> [return: bb5, unwind continue];
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:183:1: 183:17>::inner_repo: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "Tried to extract a non-Repository";
        _0 = &_1;
        return;
    }
}

fn repo_to_statuses(_1: &git2::Repository, _2: &Path) -> feature::git::Git {
    debug repo => _1;
    debug workdir => _2;
    let mut _0: fs::feature::git::Git;
    let mut _3: std::vec::Vec<(std::path::PathBuf, git2::Status)>;
    let mut _5: bool;
    let mut _6: &log::Level;
    let mut _7: bool;
    let mut _8: &log::Level;
    let mut _9: &log::LevelFilter;
    let _10: log::LevelFilter;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &&std::path::Path;
    let mut _19: log::Level;
    let mut _20: std::result::Result<git2::Statuses<'_>, git2::Error>;
    let mut _21: std::option::Option<&mut git2::StatusOptions>;
    let mut _22: isize;
    let mut _24: git2::StatusIter<'_>;
    let mut _25: git2::StatusIter<'_>;
    let mut _26: &git2::Statuses<'_>;
    let mut _28: std::option::Option<git2::StatusEntry<'_>>;
    let mut _29: &mut git2::StatusIter<'_>;
    let mut _30: isize;
    let mut _33: &std::path::Path;
    let mut _34: &std::path::Path;
    let _35: &str;
    let mut _36: std::option::Option<&str>;
    let mut _37: &git2::StatusEntry<'_>;
    let mut _39: std::path::PathBuf;
    let mut _40: git2::Status;
    let mut _41: &git2::StatusEntry<'_>;
    let _42: ();
    let mut _43: &mut std::vec::Vec<(std::path::PathBuf, git2::Status)>;
    let mut _46: bool;
    let mut _47: &log::Level;
    let mut _48: bool;
    let mut _49: &log::Level;
    let mut _50: &log::LevelFilter;
    let _51: log::LevelFilter;
    let _52: ();
    let mut _53: std::fmt::Arguments<'_>;
    let mut _54: &[&str];
    let mut _55: &[core::fmt::rt::Argument<'_>];
    let _56: &[core::fmt::rt::Argument<'_>; 1];
    let _57: [core::fmt::rt::Argument<'_>; 1];
    let mut _58: core::fmt::rt::Argument<'_>;
    let _59: &git2::Error;
    let mut _60: log::Level;
    let mut _61: std::vec::Vec<(std::path::PathBuf, git2::Status)>;
    scope 1 {
        debug statuses => _3;
        let _4: log::Level;
        let _23: git2::Statuses<'_>;
        let _44: git2::Error;
        scope 2 {
            debug lvl => _4;
            let mut _65: &(&str, &str, &str, u32);
            let mut _66: &[&str; 1];
            let mut _67: &log::LevelFilter;
        }
        scope 3 {
            debug es => _23;
            let mut _27: git2::StatusIter<'_>;
            scope 4 {
                debug iter => _27;
                let _31: git2::StatusEntry<'_>;
                scope 5 {
                    debug e => _31;
                    let _32: std::path::PathBuf;
                    scope 6 {
                        debug path => _32;
                        let _38: (std::path::PathBuf, git2::Status);
                        scope 7 {
                            debug elem => _38;
                        }
                    }
                }
            }
        }
        scope 8 {
            debug e => _44;
            let _45: log::Level;
            scope 9 {
                debug lvl => _45;
                let mut _62: &(&str, &str, &str, u32);
                let mut _63: &[&str; 1];
                let mut _64: &log::LevelFilter;
            }
        }
    }

    bb0: {
        _3 = Vec::<(PathBuf, Status)>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = log::Level::Info;
        _6 = &_4;
        _67 = const _;
        _5 = <Level as PartialOrd<LevelFilter>>::le(move _6, _67) -> [return: bb2, unwind: bb36];
    }

    bb2: {
        switchInt(move _5) -> [0: bb9, otherwise: bb3];
    }

    bb3: {
        _8 = &_4;
        _10 = max_level() -> [return: bb4, unwind: bb36];
    }

    bb4: {
        _9 = &_10;
        _7 = <Level as PartialOrd<LevelFilter>>::le(move _8, move _9) -> [return: bb5, unwind: bb36];
    }

    bb5: {
        switchInt(move _7) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _66 = const _;
        _13 = _66 as &[&str] (PointerCoercion(Unsize));
        _18 = &_2;
        _17 = core::fmt::rt::Argument::<'_>::new_debug::<&Path>(_18) -> [return: bb7, unwind: bb36];
    }

    bb7: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _12 = std::fmt::Arguments::<'_>::new_v1(move _13, move _14) -> [return: bb8, unwind: bb36];
    }

    bb8: {
        _19 = _4;
        _65 = const _;
        _11 = __private_api_log(move _12, move _19, _65) -> [return: bb39, unwind: bb36];
    }

    bb9: {
        _21 = Option::<&mut StatusOptions>::None;
        _20 = git2::Repository::statuses(_1, move _21) -> [return: bb10, unwind: bb36];
    }

    bb10: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb13, 1: bb11, otherwise: bb12];
    }

    bb11: {
        _44 = move ((_20 as Err).0: git2::Error);
        _45 = log::Level::Error;
        _47 = &_45;
        _64 = const _;
        _46 = <Level as PartialOrd<LevelFilter>>::le(move _47, _64) -> [return: bb25, unwind: bb33];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _23 = move ((_20 as Ok).0: git2::Statuses<'_>);
        _26 = &_23;
        _25 = Statuses::<'_>::iter(move _26) -> [return: bb14, unwind: bb35];
    }

    bb14: {
        _24 = <StatusIter<'_> as IntoIterator>::into_iter(move _25) -> [return: bb15, unwind: bb35];
    }

    bb15: {
        _27 = move _24;
        goto -> bb16;
    }

    bb16: {
        _29 = &mut _27;
        _28 = <StatusIter<'_> as Iterator>::next(_29) -> [return: bb17, unwind: bb35];
    }

    bb17: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb19, 1: bb18, otherwise: bb12];
    }

    bb18: {
        _31 = move ((_28 as Some).0: git2::StatusEntry<'_>);
        _33 = _2;
        _37 = &_31;
        _36 = StatusEntry::<'_>::path(move _37) -> [return: bb20, unwind: bb35];
    }

    bb19: {
        drop(_23) -> [return: bb38, unwind: bb36];
    }

    bb20: {
        _35 = Option::<&str>::unwrap(move _36) -> [return: bb21, unwind: bb35];
    }

    bb21: {
        _34 = Path::new::<str>(_35) -> [return: bb22, unwind: bb35];
    }

    bb22: {
        _32 = Path::join::<&Path>(move _33, move _34) -> [return: bb23, unwind: bb35];
    }

    bb23: {
        _39 = move _32;
        _41 = &_31;
        _40 = StatusEntry::<'_>::status(move _41) -> [return: bb24, unwind: bb34];
    }

    bb24: {
        _38 = (move _39, move _40);
        _43 = &mut _3;
        _42 = Vec::<(PathBuf, Status)>::push(move _43, move _38) -> [return: bb40, unwind: bb35];
    }

    bb25: {
        switchInt(move _46) -> [0: bb32, otherwise: bb26];
    }

    bb26: {
        _49 = &_45;
        _51 = max_level() -> [return: bb27, unwind: bb33];
    }

    bb27: {
        _50 = &_51;
        _48 = <Level as PartialOrd<LevelFilter>>::le(move _49, move _50) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        switchInt(move _48) -> [0: bb32, otherwise: bb29];
    }

    bb29: {
        _63 = const _;
        _54 = _63 as &[&str] (PointerCoercion(Unsize));
        _59 = &_44;
        _58 = core::fmt::rt::Argument::<'_>::new_debug::<git2::Error>(_59) -> [return: bb30, unwind: bb33];
    }

    bb30: {
        _57 = [move _58];
        _56 = &_57;
        _55 = _56 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _53 = std::fmt::Arguments::<'_>::new_v1(move _54, move _55) -> [return: bb31, unwind: bb33];
    }

    bb31: {
        _60 = _45;
        _62 = const _;
        _52 = __private_api_log(move _53, move _60, _62) -> [return: bb41, unwind: bb33];
    }

    bb32: {
        drop(_44) -> [return: bb38, unwind: bb36];
    }

    bb33 (cleanup): {
        drop(_44) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_39) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_23) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_3) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        resume;
    }

    bb38: {
        _61 = move _3;
        _0 = feature::git::Git { statuses: move _61 };
        return;
    }

    bb39: {
        goto -> bb9;
    }

    bb40: {
        goto -> bb16;
    }

    bb41: {
        goto -> bb32;
    }
}

promoted[0] in repo_to_statuses: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 214_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in repo_to_statuses: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Error looking up Git statuses: "];
        _0 = &_1;
        return;
    }
}

promoted[2] in repo_to_statuses: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in repo_to_statuses: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::fs::feature::git";
        _2 = &(*_3);
        _1 = (move _2, const "exa::fs::feature::git", const "src/fs/feature/git.rs", const 204_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in repo_to_statuses: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Getting Git statuses for repo with workdir "];
        _0 = &_1;
        return;
    }
}

promoted[5] in repo_to_statuses: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::status(_1: &feature::git::Git, _2: &Path, _3: bool) -> fields::Git {
    debug self => _1;
    debug index => _2;
    debug prefix_lookup => _3;
    let mut _0: fs::fields::Git;

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = feature::git::Git::dir_status(_1, _2) -> [return: bb3, unwind continue];
    }

    bb2: {
        _0 = feature::git::Git::file_status(_1, _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::file_status(_1: &feature::git::Git, _2: &Path) -> fields::Git {
    debug self => _1;
    debug file => _2;
    let mut _0: fs::fields::Git;
    let _3: std::path::PathBuf;
    let mut _5: std::iter::Filter<std::slice::Iter<'_, (std::path::PathBuf, git2::Status)>, {closure@src/fs/feature/git.rs:252:21: 252:24}>;
    let mut _6: std::slice::Iter<'_, (std::path::PathBuf, git2::Status)>;
    let _7: &[(std::path::PathBuf, git2::Status)];
    let mut _8: &std::vec::Vec<(std::path::PathBuf, git2::Status)>;
    let mut _9: {closure@src/fs/feature/git.rs:252:21: 252:24};
    let mut _10: &std::path::PathBuf;
    let mut _11: git2::Status;
    scope 1 {
        debug path => _3;
        let _4: git2::Status;
        scope 2 {
            debug s => _4;
            let _12: fs::fields::GitStatus;
            scope 3 {
                debug staged => _12;
                let _13: fs::fields::GitStatus;
                scope 4 {
                    debug unstaged => _13;
                }
            }
        }
    }

    bb0: {
        _3 = reorient(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &((*_1).0: std::vec::Vec<(std::path::PathBuf, git2::Status)>);
        _7 = <Vec<(PathBuf, Status)> as Deref>::deref(move _8) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = core::slice::<impl [(PathBuf, Status)]>::iter(_7) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _10 = &_3;
        _9 = {closure@src/fs/feature/git.rs:252:21: 252:24} { path: move _10 };
        _5 = <std::slice::Iter<'_, (PathBuf, Status)> as Iterator>::filter::<{closure@src/fs/feature/git.rs:252:21: 252:24}>(move _6, move _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = Status::empty() -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _4 = <std::iter::Filter<std::slice::Iter<'_, (PathBuf, Status)>, {closure@src/fs/feature/git.rs:252:21: 252:24}> as Iterator>::fold::<Status, {closure@src/fs/feature/git.rs:257:42: 257:48}>(move _5, move _11, const ZeroSized: {closure@src/fs/feature/git.rs:257:42: 257:48}) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _12 = index_status(_4) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _13 = working_tree_status(_4) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _0 = fields::Git { staged: _12, unstaged: _13 };
        drop(_3) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::file_status::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:252:21: 252:24}, _2: &&(PathBuf, Status)) -> bool {
    debug p => _2;
    debug path => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &git2::Status;
    let _5: &std::path::Path;
    let mut _6: &std::path::PathBuf;
    let mut _7: &std::path::PathBuf;
    let mut _8: &git2::Status;
    let mut _9: &(std::path::PathBuf, git2::Status);
    let mut _10: &std::path::PathBuf;
    let mut _11: &(std::path::PathBuf, git2::Status);
    let mut _12: &(std::path::PathBuf, git2::Status);
    let mut _13: &std::path::PathBuf;

    bb0: {
        _9 = deref_copy (*_2);
        _4 = &((*_9).1: git2::Status);
        _8 = const _;
        _3 = <Status as PartialEq>::eq(move _4, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _10 = deref_copy ((*_1).0: &std::path::PathBuf);
        _5 = <PathBuf as Deref>::deref(_10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = deref_copy (*_2);
        _6 = &((*_11).0: std::path::PathBuf);
        _0 = Path::starts_with::<&PathBuf>(_5, move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _12 = deref_copy (*_2);
        _7 = &((*_12).0: std::path::PathBuf);
        _13 = deref_copy ((*_1).0: &std::path::PathBuf);
        _0 = <PathBuf as PartialEq>::eq(move _7, _13) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::file_status::{closure#0}: &Status = {
    let mut _0: &git2::Status;
    let mut _1: git2::Status;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::file_status::{closure#1}(_1: &mut {closure@src/fs/feature/git.rs:257:42: 257:48}, _2: Status, _3: &(PathBuf, Status)) -> Status {
    debug a => _2;
    debug b => _3;
    let mut _0: git2::Status;
    let mut _4: git2::Status;

    bb0: {
        _4 = ((*_3).1: git2::Status);
        _0 = <Status as BitOr>::bitor(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::dir_status(_1: &feature::git::Git, _2: &Path) -> fields::Git {
    debug self => _1;
    debug dir => _2;
    let mut _0: fs::fields::Git;
    let _3: std::path::PathBuf;
    let mut _5: std::iter::Filter<std::slice::Iter<'_, (std::path::PathBuf, git2::Status)>, {closure@src/fs/feature/git.rs:273:21: 273:24}>;
    let mut _6: std::slice::Iter<'_, (std::path::PathBuf, git2::Status)>;
    let _7: &[(std::path::PathBuf, git2::Status)];
    let mut _8: &std::vec::Vec<(std::path::PathBuf, git2::Status)>;
    let mut _9: {closure@src/fs/feature/git.rs:273:21: 273:24};
    let mut _10: &std::path::PathBuf;
    let mut _11: git2::Status;
    scope 1 {
        debug path => _3;
        let _4: git2::Status;
        scope 2 {
            debug s => _4;
            let _12: fs::fields::GitStatus;
            scope 3 {
                debug staged => _12;
                let _13: fs::fields::GitStatus;
                scope 4 {
                    debug unstaged => _13;
                }
            }
        }
    }

    bb0: {
        _3 = reorient(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &((*_1).0: std::vec::Vec<(std::path::PathBuf, git2::Status)>);
        _7 = <Vec<(PathBuf, Status)> as Deref>::deref(move _8) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = core::slice::<impl [(PathBuf, Status)]>::iter(_7) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _10 = &_3;
        _9 = {closure@src/fs/feature/git.rs:273:21: 273:24} { path: move _10 };
        _5 = <std::slice::Iter<'_, (PathBuf, Status)> as Iterator>::filter::<{closure@src/fs/feature/git.rs:273:21: 273:24}>(move _6, move _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = Status::empty() -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _4 = <std::iter::Filter<std::slice::Iter<'_, (PathBuf, Status)>, {closure@src/fs/feature/git.rs:273:21: 273:24}> as Iterator>::fold::<Status, {closure@src/fs/feature/git.rs:278:42: 278:48}>(move _5, move _11, const ZeroSized: {closure@src/fs/feature/git.rs:278:42: 278:48}) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _12 = index_status(_4) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _13 = working_tree_status(_4) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _0 = fields::Git { staged: _12, unstaged: _13 };
        drop(_3) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::dir_status::{closure#0}(_1: &mut {closure@src/fs/feature/git.rs:273:21: 273:24}, _2: &&(PathBuf, Status)) -> bool {
    debug p => _2;
    debug path => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &git2::Status;
    let _5: &std::path::Path;
    let mut _6: &std::path::PathBuf;
    let _7: &std::path::Path;
    let mut _8: &std::path::PathBuf;
    let mut _9: &git2::Status;
    let mut _10: &(std::path::PathBuf, git2::Status);
    let mut _11: &std::path::PathBuf;
    let mut _12: &(std::path::PathBuf, git2::Status);
    let mut _13: &(std::path::PathBuf, git2::Status);
    let mut _14: &std::path::PathBuf;

    bb0: {
        _10 = deref_copy (*_2);
        _4 = &((*_10).1: git2::Status);
        _9 = const _;
        _3 = <Status as PartialEq>::eq(move _4, _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _11 = deref_copy ((*_1).0: &std::path::PathBuf);
        _5 = <PathBuf as Deref>::deref(_11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = deref_copy (*_2);
        _6 = &((*_12).0: std::path::PathBuf);
        _0 = Path::starts_with::<&PathBuf>(_5, move _6) -> [return: bb6, unwind continue];
    }

    bb4: {
        _13 = deref_copy (*_2);
        _8 = &((*_13).0: std::path::PathBuf);
        _7 = <PathBuf as Deref>::deref(move _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _14 = deref_copy ((*_1).0: &std::path::PathBuf);
        _0 = Path::starts_with::<&PathBuf>(_7, _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::dir_status::{closure#0}: &Status = {
    let mut _0: &git2::Status;
    let mut _1: git2::Status;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn feature::git::<impl at src/fs/feature/git.rs:235:1: 235:9>::dir_status::{closure#1}(_1: &mut {closure@src/fs/feature/git.rs:278:42: 278:48}, _2: Status, _3: &(PathBuf, Status)) -> Status {
    debug a => _2;
    debug b => _3;
    let mut _0: git2::Status;
    let mut _4: git2::Status;

    bb0: {
        _4 = ((*_3).1: git2::Status);
        _0 = <Status as BitOr>::bitor(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn reorient(_1: &Path) -> PathBuf {
    debug path => _1;
    let mut _0: std::path::PathBuf;
    let _2: std::path::PathBuf;
    let mut _3: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _4: isize;
    let _5: &std::path::Path;
    let _6: &str;
    let mut _7: &&std::path::Path;
    let _8: std::path::PathBuf;
    let _9: &std::path::Path;
    let mut _10: &std::path::PathBuf;
    let mut _11: &&std::path::Path;
    let mut _12: std::result::Result<std::path::PathBuf, std::io::Error>;
    let _13: &std::path::Path;
    let mut _14: &std::path::PathBuf;
    let mut _15: std::path::PathBuf;
    let mut _16: bool;
    let mut _17: isize;
    let mut _18: isize;
    scope 1 {
        debug path => _2;
    }
    scope 2 {
        debug dir => _8;
    }

    bb0: {
        _16 = const false;
        _3 = current_dir() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _8 = move ((_3 as Ok).0: std::path::PathBuf);
        _10 = &_8;
        _9 = <PathBuf as Deref>::deref(move _10) -> [return: bb7, unwind: bb12];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = const ".";
        _5 = Path::new::<str>(_6) -> [return: bb5, unwind: bb20];
    }

    bb5: {
        _7 = &_1;
        _2 = Path::join::<&&Path>(_5, move _7) -> [return: bb6, unwind: bb20];
    }

    bb6: {
        _16 = const true;
        goto -> bb16;
    }

    bb7: {
        _11 = &_1;
        _2 = Path::join::<&&Path>(_9, move _11) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _16 = const true;
        drop(_8) -> [return: bb16, unwind: bb20];
    }

    bb9: {
        _12 = Path::canonicalize(_13) -> [return: bb10, unwind: bb18];
    }

    bb10: {
        _16 = const false;
        _15 = move _2;
        _0 = Result::<PathBuf, std::io::Error>::unwrap_or(move _12, move _15) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _16 = const false;
        return;
    }

    bb12 (cleanup): {
        drop(_8) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        _14 = &_2;
        _13 = <PathBuf as Deref>::deref(move _14) -> [return: bb9, unwind: bb18];
    }

    bb15: {
        drop(_3) -> [return: bb14, unwind: bb18];
    }

    bb16: {
        _17 = discriminant(_3);
        switchInt(move _17) -> [0: bb14, otherwise: bb15];
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_16) -> [0: bb13, otherwise: bb17];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        _18 = discriminant(_3);
        switchInt(move _18) -> [0: bb13, otherwise: bb19];
    }
}

fn working_tree_status(_1: Status) -> GitStatus {
    debug status => _1;
    let mut _0: fs::fields::GitStatus;
    let _2: git2::Status;
    let _3: &git2::Status;
    let mut _4: bool;
    let _5: git2::Status;
    let _6: &git2::Status;
    let mut _7: bool;
    let _8: git2::Status;
    let _9: &git2::Status;
    let mut _10: bool;
    let _11: git2::Status;
    let _12: &git2::Status;
    let mut _13: bool;
    let _14: git2::Status;
    let _15: &git2::Status;
    let mut _16: bool;
    let _17: git2::Status;
    let _18: &git2::Status;
    let mut _19: bool;
    let _20: git2::Status;
    let _21: &git2::Status;
    let mut _22: bool;
    scope 1 {
        debug s => _2;
        debug s => _3;
    }
    scope 2 {
        debug s => _5;
        debug s => _6;
    }
    scope 3 {
        debug s => _8;
        debug s => _9;
    }
    scope 4 {
        debug s => _11;
        debug s => _12;
    }
    scope 5 {
        debug s => _14;
        debug s => _15;
    }
    scope 6 {
        debug s => _17;
        debug s => _18;
    }
    scope 7 {
        debug s => _20;
        debug s => _21;
    }

    bb0: {
        _3 = &_1;
        _4 = Status::contains(_3, const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _2 = _1;
        _0 = GitStatus::New;
        goto -> bb22;
    }

    bb3: {
        _6 = &_1;
        _7 = Status::contains(_6, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _5 = _1;
        _0 = GitStatus::Modified;
        goto -> bb22;
    }

    bb6: {
        _9 = &_1;
        _10 = Status::contains(_9, const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _10) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _8 = _1;
        _0 = GitStatus::Deleted;
        goto -> bb22;
    }

    bb9: {
        _12 = &_1;
        _13 = Status::contains(_12, const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _13) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _11 = _1;
        _0 = GitStatus::Renamed;
        goto -> bb22;
    }

    bb12: {
        _15 = &_1;
        _16 = Status::contains(_15, const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _16) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _14 = _1;
        _0 = GitStatus::TypeChange;
        goto -> bb22;
    }

    bb15: {
        _18 = &_1;
        _19 = Status::contains(_18, const _) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _19) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _17 = _1;
        _0 = GitStatus::Ignored;
        goto -> bb22;
    }

    bb18: {
        _21 = &_1;
        _22 = Status::contains(_21, const _) -> [return: bb19, unwind continue];
    }

    bb19: {
        switchInt(move _22) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _20 = _1;
        _0 = GitStatus::Conflicted;
        goto -> bb22;
    }

    bb21: {
        _0 = GitStatus::NotModified;
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

fn index_status(_1: Status) -> GitStatus {
    debug status => _1;
    let mut _0: fs::fields::GitStatus;
    let _2: git2::Status;
    let _3: &git2::Status;
    let mut _4: bool;
    let _5: git2::Status;
    let _6: &git2::Status;
    let mut _7: bool;
    let _8: git2::Status;
    let _9: &git2::Status;
    let mut _10: bool;
    let _11: git2::Status;
    let _12: &git2::Status;
    let mut _13: bool;
    let _14: git2::Status;
    let _15: &git2::Status;
    let mut _16: bool;
    scope 1 {
        debug s => _2;
        debug s => _3;
    }
    scope 2 {
        debug s => _5;
        debug s => _6;
    }
    scope 3 {
        debug s => _8;
        debug s => _9;
    }
    scope 4 {
        debug s => _11;
        debug s => _12;
    }
    scope 5 {
        debug s => _14;
        debug s => _15;
    }

    bb0: {
        _3 = &_1;
        _4 = Status::contains(_3, const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _2 = _1;
        _0 = GitStatus::New;
        goto -> bb16;
    }

    bb3: {
        _6 = &_1;
        _7 = Status::contains(_6, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _5 = _1;
        _0 = GitStatus::Modified;
        goto -> bb16;
    }

    bb6: {
        _9 = &_1;
        _10 = Status::contains(_9, const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _10) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _8 = _1;
        _0 = GitStatus::Deleted;
        goto -> bb16;
    }

    bb9: {
        _12 = &_1;
        _13 = Status::contains(_12, const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _13) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _11 = _1;
        _0 = GitStatus::Renamed;
        goto -> bb16;
    }

    bb12: {
        _15 = &_1;
        _16 = Status::contains(_15, const _) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _16) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _14 = _1;
        _0 = GitStatus::TypeChange;
        goto -> bb16;
    }

    bb15: {
        _0 = GitStatus::NotModified;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:46:10: 46:19>::eq(_1: &Type, _2: &Type) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:46:21: 46:23>::assert_receiver_is_total_eq(_1: &Type) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:46:25: 46:35>::partial_cmp(_1: &Type, _2: &Type) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as PartialOrd>::partial_cmp(_5, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:46:37: 46:40>::cmp(_1: &Type, _2: &Type) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as Ord>::cmp(_5, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:46:48: 46:53>::clone(_1: &Type) -> Type {
    debug self => _1;
    let mut _0: fs::fields::Type;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:58:1: 58:10>::is_regular_file(_1: Type) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        _0 = Eq(_2, const 1_isize);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:66:16: 66:21>::clone(_1: &fields::Permissions) -> fields::Permissions {
    debug self => _1;
    let mut _0: fs::fields::Permissions;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:88:16: 88:21>::clone(_1: &PermissionsPlus) -> PermissionsPlus {
    debug self => _1;
    let mut _0: fs::fields::PermissionsPlus;
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:97:16: 97:21>::clone(_1: &OctalPermissions) -> OctalPermissions {
    debug self => _1;
    let mut _0: fs::fields::OctalPermissions;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:108:16: 108:21>::clone(_1: &fields::Links) -> fields::Links {
    debug self => _1;
    let mut _0: fs::fields::Links;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:122:16: 122:21>::clone(_1: &Inode) -> Inode {
    debug self => _1;
    let mut _0: fs::fields::Inode;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:127:16: 127:21>::clone(_1: &Blocks) -> Blocks {
    debug self => _1;
    let mut _0: fs::fields::Blocks;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:140:16: 140:21>::clone(_1: &fields::User) -> fields::User {
    debug self => _1;
    let mut _0: fs::fields::User;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:144:16: 144:21>::clone(_1: &fields::Group) -> fields::Group {
    debug self => _1;
    let mut _0: fs::fields::Group;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:150:16: 150:21>::clone(_1: &fields::Size) -> fields::Size {
    debug self => _1;
    let mut _0: fs::fields::Size;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:181:16: 181:21>::clone(_1: &DeviceIDs) -> DeviceIDs {
    debug self => _1;
    let mut _0: fs::fields::DeviceIDs;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:189:16: 189:21>::clone(_1: &fields::Time) -> fields::Time {
    debug self => _1;
    let mut _0: fs::fields::Time;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:189:23: 189:32>::eq(_1: &fields::Time, _2: &fields::Time) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: i64;
    let mut _5: i64;
    let mut _6: i64;
    let mut _7: i64;

    bb0: {
        _4 = ((*_1).0: i64);
        _5 = ((*_2).0: i64);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = ((*_1).1: i64);
        _7 = ((*_2).1: i64);
        _0 = Eq(move _6, move _7);
        goto -> bb3;
    }

    bb2: {
        _0 = const false;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:189:34: 189:36>::assert_receiver_is_total_eq(_1: &fields::Time) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:189:38: 189:48>::partial_cmp(_1: &fields::Time, _2: &fields::Time) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let mut _3: std::option::Option<std::cmp::Ordering>;
    let _4: &i64;
    let _5: &i64;
    let mut _6: i8;
    let mut _7: isize;
    let _8: &i64;
    let _9: &i64;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: i64);
        _5 = &((*_2).0: i64);
        _3 = <i64 as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb5;
    }

    bb3: {
        _6 = discriminant(((_3 as Some).0: std::cmp::Ordering));
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb4: {
        _8 = &((*_1).1: i64);
        _9 = &((*_2).1: i64);
        _0 = <i64 as PartialOrd>::partial_cmp(_8, _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:189:50: 189:53>::cmp(_1: &fields::Time, _2: &fields::Time) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let mut _3: std::cmp::Ordering;
    let _4: &i64;
    let _5: &i64;
    let mut _6: i8;
    let _7: &i64;
    let _8: &i64;
    scope 1 {
        debug cmp => _3;
    }

    bb0: {
        _4 = &((*_1).0: i64);
        _5 = &((*_2).0: i64);
        _3 = <i64 as Ord>::cmp(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _3;
        goto -> bb4;
    }

    bb3: {
        _7 = &((*_1).1: i64);
        _8 = &((*_2).1: i64);
        _0 = <i64 as Ord>::cmp(_7, _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:199:10: 199:19>::eq(_1: &GitStatus, _2: &GitStatus) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:199:27: 199:32>::clone(_1: &GitStatus) -> GitStatus {
    debug self => _1;
    let mut _0: fs::fields::GitStatus;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:232:16: 232:21>::clone(_1: &fields::Git) -> fields::Git {
    debug self => _1;
    let mut _0: fs::fields::Git;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fields::<impl at src/fs/fields.rs:238:1: 238:21>::default() -> fields::Git {
    let mut _0: fs::fields::Git;
    let mut _1: fs::fields::GitStatus;
    let mut _2: fs::fields::GitStatus;

    bb0: {
        _1 = GitStatus::NotModified;
        _2 = GitStatus::NotModified;
        _0 = fields::Git { staged: move _1, unstaged: move _2 };
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:26:10: 26:19>::eq(_1: &FileFilter, _2: &FileFilter) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: &fs::filter::SortField;
    let mut _8: &fs::filter::SortField;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: &fs::dir::DotFilter;
    let mut _17: &fs::dir::DotFilter;
    let mut _18: bool;
    let mut _19: &fs::filter::IgnorePatterns;
    let mut _20: &fs::filter::IgnorePatterns;
    let mut _21: &fs::filter::GitIgnore;
    let mut _22: &fs::filter::GitIgnore;

    bb0: {
        _4 = ((*_1).0: bool);
        _5 = ((*_2).0: bool);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb10, otherwise: bb1];
    }

    bb1: {
        _7 = &((*_1).1: fs::filter::SortField);
        _8 = &((*_2).1: fs::filter::SortField);
        _6 = <SortField as PartialEq>::eq(move _7, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _6) -> [0: bb10, otherwise: bb3];
    }

    bb3: {
        _10 = ((*_1).2: bool);
        _11 = ((*_2).2: bool);
        _9 = Eq(move _10, move _11);
        switchInt(move _9) -> [0: bb10, otherwise: bb4];
    }

    bb4: {
        _13 = ((*_1).3: bool);
        _14 = ((*_2).3: bool);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _16 = &((*_1).4: fs::dir::DotFilter);
        _17 = &((*_2).4: fs::dir::DotFilter);
        _15 = <DotFilter as PartialEq>::eq(move _16, move _17) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _15) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _19 = &((*_1).5: fs::filter::IgnorePatterns);
        _20 = &((*_2).5: fs::filter::IgnorePatterns);
        _18 = <IgnorePatterns as PartialEq>::eq(move _19, move _20) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _18) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _21 = &((*_1).6: fs::filter::GitIgnore);
        _22 = &((*_2).6: fs::filter::GitIgnore);
        _0 = <GitIgnore as PartialEq>::eq(move _21, move _22) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = const false;
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:26:21: 26:26>::fmt(_1: &FileFilter, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 7];
    let _5: [&dyn std::fmt::Debug; 7];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &bool;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &fs::filter::SortField;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &bool;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &bool;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &fs::dir::DotFilter;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &fs::filter::IgnorePatterns;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&fs::filter::GitIgnore;
    let _20: &fs::filter::GitIgnore;
    let _21: &str;
    let mut _22: &[&str];
    let mut _23: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _23 = const _;
        _7 = &((*_1).0: bool);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: fs::filter::SortField);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: bool);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: bool);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: fs::dir::DotFilter);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: fs::filter::IgnorePatterns);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _20 = &((*_1).6: fs::filter::GitIgnore);
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _21 = const "FileFilter";
        _22 = _23 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _21, move _22, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in fs::filter::<impl at src/fs/filter.rs:26:21: 26:26>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "sort_field";
        _2 = &(*_3);
        _5 = const "reverse";
        _4 = &(*_5);
        _7 = const "only_dirs";
        _6 = &(*_7);
        _9 = const "dot_filter";
        _8 = &(*_9);
        _11 = const "ignore_patterns";
        _10 = &(*_11);
        _13 = const "git_ignore";
        _12 = &(*_13);
        _1 = [const "list_dirs_first", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:26:28: 26:33>::clone(_1: &FileFilter) -> FileFilter {
    debug self => _1;
    let mut _0: fs::filter::FileFilter;
    let mut _2: bool;
    let _3: &bool;
    let mut _4: fs::filter::SortField;
    let _5: &fs::filter::SortField;
    let mut _6: bool;
    let _7: &bool;
    let mut _8: bool;
    let _9: &bool;
    let mut _10: fs::dir::DotFilter;
    let _11: &fs::dir::DotFilter;
    let mut _12: fs::filter::IgnorePatterns;
    let _13: &fs::filter::IgnorePatterns;
    let mut _14: fs::filter::GitIgnore;
    let _15: &fs::filter::GitIgnore;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _5 = &((*_1).1: fs::filter::SortField);
        _4 = <SortField as Clone>::clone(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &((*_1).2: bool);
        _6 = (*_7);
        _9 = &((*_1).3: bool);
        _8 = (*_9);
        _11 = &((*_1).4: fs::dir::DotFilter);
        _10 = <DotFilter as Clone>::clone(_11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = &((*_1).5: fs::filter::IgnorePatterns);
        _12 = <IgnorePatterns as Clone>::clone(_13) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = &((*_1).6: fs::filter::GitIgnore);
        _14 = <GitIgnore as Clone>::clone(_15) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = FileFilter { list_dirs_first: move _2, sort_field: move _4, reverse: move _6, only_dirs: move _8, dot_filter: move _10, ignore_patterns: move _12, git_ignore: move _14 };
        return;
    }

    bb5 (cleanup): {
        drop(_12) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::filter_child_files(_1: &FileFilter, _2: &mut Vec<file::File<'_>>) -> () {
    debug self => _1;
    debug files => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: {closure@src/fs/filter.rs:95:22: 95:25};
    let mut _5: &&fs::filter::FileFilter;
    let mut _6: bool;
    let _7: ();

    bb0: {
        _5 = &_1;
        _4 = {closure@src/fs/filter.rs:95:22: 95:25} { self: move _5 };
        _3 = Vec::<file::File<'_>>::retain::<{closure@src/fs/filter.rs:95:22: 95:25}>(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = ((*_1).3: bool);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _7 = Vec::<file::File<'_>>::retain::<for<'a> fn(&'a file::File<'_>) -> bool {file::File::<'_>::is_directory}>(_2, file::File::<'_>::is_directory) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::filter_child_files::{closure#0}(_1: &mut {closure@src/fs/filter.rs:95:22: 95:25}, _2: &file::File<'_>) -> bool {
    debug f => _2;
    debug self => (*((*_1).0: &&fs::filter::FileFilter));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &fs::filter::IgnorePatterns;
    let _5: &str;
    let _6: &std::string::String;
    let mut _7: &&fs::filter::FileFilter;
    let mut _8: &fs::filter::FileFilter;

    bb0: {
        _7 = deref_copy ((*_1).0: &&fs::filter::FileFilter);
        _8 = deref_copy (*_7);
        _4 = &((*_8).5: fs::filter::IgnorePatterns);
        _6 = &((*_2).0: std::string::String);
        _5 = <String as Deref>::deref(_6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = IgnorePatterns::is_ignored(move _4, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Not(move _3);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::filter_argument_files(_1: &FileFilter, _2: &mut Vec<file::File<'_>>) -> () {
    debug self => _1;
    debug files => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: {closure@src/fs/filter.rs:112:22: 112:25};
    let mut _5: &&fs::filter::FileFilter;

    bb0: {
        _5 = &_1;
        _4 = {closure@src/fs/filter.rs:112:22: 112:25} { self: move _5 };
        _3 = Vec::<file::File<'_>>::retain::<{closure@src/fs/filter.rs:112:22: 112:25}>(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::filter_argument_files::{closure#0}(_1: &mut {closure@src/fs/filter.rs:112:22: 112:25}, _2: &file::File<'_>) -> bool {
    debug f => _2;
    debug self => (*((*_1).0: &&fs::filter::FileFilter));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &fs::filter::IgnorePatterns;
    let _5: &str;
    let _6: &std::string::String;
    let mut _7: &&fs::filter::FileFilter;
    let mut _8: &fs::filter::FileFilter;

    bb0: {
        _7 = deref_copy ((*_1).0: &&fs::filter::FileFilter);
        _8 = deref_copy (*_7);
        _4 = &((*_8).5: fs::filter::IgnorePatterns);
        _6 = &((*_2).0: std::string::String);
        _5 = <String as Deref>::deref(_6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = IgnorePatterns::is_ignored(move _4, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Not(move _3);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::sort_files(_1: &FileFilter, _2: &mut Vec<F>) -> () {
    debug self => _1;
    debug files => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &mut [F];
    let mut _5: {closure@src/fs/filter.rs:121:23: 121:29};
    let mut _6: &&fs::filter::FileFilter;
    let mut _7: bool;
    let _8: ();
    let mut _9: &mut [F];
    let mut _10: bool;
    let _11: ();
    let mut _12: &mut [F];

    bb0: {
        _4 = <Vec<F> as DerefMut>::deref_mut(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_1;
        _5 = {closure@src/fs/filter.rs:121:23: 121:29} { self: move _6 };
        _3 = slice::<impl [F]>::sort_by::<{closure@src/fs/filter.rs:121:23: 121:29}>(_4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = ((*_1).2: bool);
        switchInt(move _7) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _9 = <Vec<F> as DerefMut>::deref_mut(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = core::slice::<impl [F]>::reverse(_9) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = ((*_1).0: bool);
        switchInt(move _10) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _12 = <Vec<F> as DerefMut>::deref_mut(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = slice::<impl [F]>::sort_by::<{closure@src/fs/filter.rs:132:27: 132:33}>(_12, const ZeroSized: {closure@src/fs/filter.rs:132:27: 132:33}) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::sort_files::{closure#0}(_1: &mut {closure@src/fs/filter.rs:121:23: 121:29}, _2: &F, _3: &F) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    debug self => (*((*_1).0: &&fs::filter::FileFilter));
    let mut _0: std::cmp::Ordering;
    let mut _4: fs::filter::SortField;
    let _5: &fs::file::File<'_>;
    let _6: &fs::file::File<'_>;
    let mut _7: &&fs::filter::FileFilter;
    let mut _8: &fs::filter::FileFilter;

    bb0: {
        _7 = deref_copy ((*_1).0: &&fs::filter::FileFilter);
        _8 = deref_copy (*_7);
        _4 = ((*_8).1: fs::filter::SortField);
        _5 = <F as AsRef<file::File<'_>>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <F as AsRef<file::File<'_>>>::as_ref(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = SortField::compare_files(move _4, _5, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:91:1: 91:16>::sort_files::{closure#1}(_1: &mut {closure@src/fs/filter.rs:132:27: 132:33}, _2: &F, _3: &F) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    let mut _0: std::cmp::Ordering;
    let mut _4: &bool;
    let _5: bool;
    let _6: &fs::file::File<'_>;
    let _7: &bool;
    let _8: bool;
    let _9: &fs::file::File<'_>;

    bb0: {
        _6 = <F as AsRef<file::File<'_>>>::as_ref(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = file::File::<'_>::points_to_directory(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = &_5;
        _9 = <F as AsRef<file::File<'_>>>::as_ref(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = file::File::<'_>::points_to_directory(_9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = &_8;
        _0 = <bool as Ord>::cmp(move _4, _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:142:10: 142:19>::eq(_1: &SortField, _2: &SortField) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&fs::filter::SortField, &fs::filter::SortField);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _17: &fs::filter::SortField;
    let mut _18: &fs::filter::SortField;
    let mut _19: &fs::filter::SortField;
    let mut _20: &fs::filter::SortField;
    let mut _21: &fs::filter::SortField;
    let mut _22: &fs::filter::SortField;
    let mut _23: &fs::filter::SortField;
    let mut _24: &fs::filter::SortField;
    let mut _25: &fs::filter::SortField;
    let mut _26: &fs::filter::SortField;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &fs::filter::SortCase;
            let _12: &fs::filter::SortCase;
            let _13: &fs::filter::SortCase;
            let _14: &fs::filter::SortCase;
            let _15: &fs::filter::SortCase;
            let _16: &fs::filter::SortCase;
            scope 3 {
                debug __self_0 => _11;
                debug __arg1_0 => _12;
            }
            scope 4 {
                debug __self_0 => _13;
                debug __arg1_0 => _14;
            }
            scope 5 {
                debug __self_0 => _15;
                debug __arg1_0 => _16;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _17 = deref_copy (_6.0: &fs::filter::SortField);
        _10 = discriminant((*_17));
        switchInt(move _10) -> [1: bb4, 2: bb5, 11: bb6, otherwise: bb3];
    }

    bb2: {
        _0 = const false;
        goto -> bb10;
    }

    bb3: {
        _0 = const true;
        goto -> bb10;
    }

    bb4: {
        _18 = deref_copy (_6.1: &fs::filter::SortField);
        _7 = discriminant((*_18));
        switchInt(move _7) -> [1: bb7, otherwise: bb3];
    }

    bb5: {
        _19 = deref_copy (_6.1: &fs::filter::SortField);
        _8 = discriminant((*_19));
        switchInt(move _8) -> [2: bb8, otherwise: bb3];
    }

    bb6: {
        _20 = deref_copy (_6.1: &fs::filter::SortField);
        _9 = discriminant((*_20));
        switchInt(move _9) -> [11: bb9, otherwise: bb3];
    }

    bb7: {
        _21 = deref_copy (_6.0: &fs::filter::SortField);
        _11 = &(((*_21) as Name).0: fs::filter::SortCase);
        _22 = deref_copy (_6.1: &fs::filter::SortField);
        _12 = &(((*_22) as Name).0: fs::filter::SortCase);
        _0 = <SortCase as PartialEq>::eq(_11, _12) -> [return: bb10, unwind continue];
    }

    bb8: {
        _23 = deref_copy (_6.0: &fs::filter::SortField);
        _13 = &(((*_23) as Extension).0: fs::filter::SortCase);
        _24 = deref_copy (_6.1: &fs::filter::SortField);
        _14 = &(((*_24) as Extension).0: fs::filter::SortCase);
        _0 = <SortCase as PartialEq>::eq(_13, _14) -> [return: bb10, unwind continue];
    }

    bb9: {
        _25 = deref_copy (_6.0: &fs::filter::SortField);
        _15 = &(((*_25) as NameMixHidden).0: fs::filter::SortCase);
        _26 = deref_copy (_6.1: &fs::filter::SortField);
        _16 = &(((*_26) as NameMixHidden).0: fs::filter::SortCase);
        _0 = <SortCase as PartialEq>::eq(_15, _16) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:142:21: 142:26>::fmt(_1: &SortField, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &fs::filter::SortCase;
    let _6: &str;
    let mut _7: &dyn std::fmt::Debug;
    let _8: &&fs::filter::SortCase;
    let _9: &fs::filter::SortCase;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&fs::filter::SortCase;
    let _13: &str;
    let _14: &str;
    let _15: &str;
    let _16: &str;
    let _17: &str;
    let _18: &str;
    let _19: &str;
    let _20: &str;
    let _21: &fs::filter::SortCase;
    let _22: &str;
    let mut _23: &dyn std::fmt::Debug;
    let _24: &&fs::filter::SortCase;
    scope 1 {
        debug __self_0 => _5;
    }
    scope 2 {
        debug __self_0 => _9;
    }
    scope 3 {
        debug __self_0 => _21;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 9: bb12, 10: bb13, 11: bb1, otherwise: bb2];
    }

    bb1: {
        _21 = &(((*_1) as NameMixHidden).0: fs::filter::SortCase);
        _22 = const "NameMixHidden";
        _24 = &_21;
        _23 = _24 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _22, move _23) -> [return: bb14, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "Unsorted";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb14, unwind continue];
    }

    bb4: {
        _5 = &(((*_1) as Name).0: fs::filter::SortCase);
        _6 = const "Name";
        _8 = &_5;
        _7 = _8 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _6, move _7) -> [return: bb14, unwind continue];
    }

    bb5: {
        _9 = &(((*_1) as Extension).0: fs::filter::SortCase);
        _10 = const "Extension";
        _12 = &_9;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _10, move _11) -> [return: bb14, unwind continue];
    }

    bb6: {
        _13 = const "Size";
        _0 = Formatter::<'_>::write_str(_2, _13) -> [return: bb14, unwind continue];
    }

    bb7: {
        _14 = const "FileInode";
        _0 = Formatter::<'_>::write_str(_2, _14) -> [return: bb14, unwind continue];
    }

    bb8: {
        _15 = const "ModifiedDate";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb14, unwind continue];
    }

    bb9: {
        _16 = const "AccessedDate";
        _0 = Formatter::<'_>::write_str(_2, _16) -> [return: bb14, unwind continue];
    }

    bb10: {
        _17 = const "ChangedDate";
        _0 = Formatter::<'_>::write_str(_2, _17) -> [return: bb14, unwind continue];
    }

    bb11: {
        _18 = const "CreatedDate";
        _0 = Formatter::<'_>::write_str(_2, _18) -> [return: bb14, unwind continue];
    }

    bb12: {
        _19 = const "FileType";
        _0 = Formatter::<'_>::write_str(_2, _19) -> [return: bb14, unwind continue];
    }

    bb13: {
        _20 = const "ModifiedAge";
        _0 = Formatter::<'_>::write_str(_2, _20) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:142:34: 142:39>::clone(_1: &SortField) -> SortField {
    debug self => _1;
    let mut _0: fs::filter::SortField;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:222:10: 222:19>::eq(_1: &SortCase, _2: &SortCase) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:222:21: 222:26>::fmt(_1: &SortCase, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "AaBbCc";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "ABCabc";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:222:34: 222:39>::clone(_1: &SortCase) -> SortCase {
    debug self => _1;
    let mut _0: fs::filter::SortCase;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:233:1: 233:15>::compare_files(_1: SortField, _2: &file::File<'_>, _3: &file::File<'_>) -> std::cmp::Ordering {
    debug self => _1;
    debug a => _2;
    debug b => _3;
    let mut _0: std::cmp::Ordering;
    let mut _4: isize;
    let mut _5: isize;
    let mut _6: isize;
    let mut _7: isize;
    let _8: &str;
    let _9: &std::string::String;
    let _10: &str;
    let _11: &std::string::String;
    let _12: &str;
    let _13: &std::string::String;
    let _14: &str;
    let _15: &std::string::String;
    let mut _16: &u64;
    let _17: u64;
    let mut _18: &std::fs::Metadata;
    let _19: &u64;
    let _20: u64;
    let mut _21: &std::fs::Metadata;
    let mut _22: &u64;
    let _23: u64;
    let mut _24: &std::fs::Metadata;
    let _25: &u64;
    let _26: u64;
    let mut _27: &std::fs::Metadata;
    let mut _28: &std::option::Option<std::time::SystemTime>;
    let _29: std::option::Option<std::time::SystemTime>;
    let _30: &std::option::Option<std::time::SystemTime>;
    let _31: std::option::Option<std::time::SystemTime>;
    let mut _32: &std::option::Option<std::time::SystemTime>;
    let _33: std::option::Option<std::time::SystemTime>;
    let _34: &std::option::Option<std::time::SystemTime>;
    let _35: std::option::Option<std::time::SystemTime>;
    let mut _36: &std::option::Option<std::time::SystemTime>;
    let _37: std::option::Option<std::time::SystemTime>;
    let _38: &std::option::Option<std::time::SystemTime>;
    let _39: std::option::Option<std::time::SystemTime>;
    let mut _40: &std::option::Option<std::time::SystemTime>;
    let _41: std::option::Option<std::time::SystemTime>;
    let _42: &std::option::Option<std::time::SystemTime>;
    let _43: std::option::Option<std::time::SystemTime>;
    let mut _44: &std::option::Option<std::time::SystemTime>;
    let _45: std::option::Option<std::time::SystemTime>;
    let _46: &std::option::Option<std::time::SystemTime>;
    let _47: std::option::Option<std::time::SystemTime>;
    let mut _48: std::cmp::Ordering;
    let mut _49: &fs::fields::Type;
    let _50: fs::fields::Type;
    let _51: &fs::fields::Type;
    let _52: fs::fields::Type;
    let mut _53: i8;
    let _54: &str;
    let mut _55: &std::string::String;
    let _56: &str;
    let mut _57: &std::string::String;
    let mut _58: std::cmp::Ordering;
    let mut _59: &std::option::Option<std::string::String>;
    let _60: &std::option::Option<std::string::String>;
    let mut _61: i8;
    let _62: &str;
    let mut _63: &std::string::String;
    let _64: &str;
    let mut _65: &std::string::String;
    let mut _66: std::cmp::Ordering;
    let mut _67: &std::option::Option<std::string::String>;
    let _68: &std::option::Option<std::string::String>;
    let mut _69: i8;
    let _70: &str;
    let mut _71: &std::string::String;
    let _72: &str;
    let mut _73: &std::string::String;
    let _74: &str;
    let _75: &str;
    let _76: &std::string::String;
    let _77: &str;
    let _78: &str;
    let _79: &std::string::String;
    let _80: &str;
    let _81: &str;
    let _82: &std::string::String;
    let _83: &str;
    let _84: &str;
    let _85: &std::string::String;
    scope 1 {
        debug order => _48;
    }
    scope 2 {
        debug order => _58;
    }
    scope 3 {
        debug order => _66;
    }

    bb0: {
        _7 = discriminant(_1);
        switchInt(move _7) -> [0: bb6, 1: bb1, 2: bb3, 3: bb13, 4: bb16, 5: bb19, 6: bb22, 7: bb25, 8: bb28, 9: bb34, 10: bb31, 11: bb4, otherwise: bb2];
    }

    bb1: {
        _4 = discriminant(((_1 as Name).0: fs::filter::SortCase));
        switchInt(move _4) -> [0: bb7, 1: bb10, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = discriminant(((_1 as Extension).0: fs::filter::SortCase));
        switchInt(move _5) -> [0: bb42, 1: bb48, otherwise: bb2];
    }

    bb4: {
        _6 = discriminant(((_1 as NameMixHidden).0: fs::filter::SortCase));
        switchInt(move _6) -> [0: bb54, 1: bb5, otherwise: bb2];
    }

    bb5: {
        _82 = &((*_2).0: std::string::String);
        _81 = <String as Deref>::deref(_82) -> [return: bb59, unwind continue];
    }

    bb6: {
        _0 = Equal;
        goto -> bb63;
    }

    bb7: {
        _9 = &((*_2).0: std::string::String);
        _8 = <String as Deref>::deref(_9) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = &((*_3).0: std::string::String);
        _10 = <String as Deref>::deref(_11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = compare(_8, _10) -> [return: bb63, unwind continue];
    }

    bb10: {
        _13 = &((*_2).0: std::string::String);
        _12 = <String as Deref>::deref(_13) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = &((*_3).0: std::string::String);
        _14 = <String as Deref>::deref(_15) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = compare_ignore_case(_12, _14) -> [return: bb63, unwind continue];
    }

    bb13: {
        _18 = &((*_2).3: std::fs::Metadata);
        _17 = std::fs::Metadata::len(move _18) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = &_17;
        _21 = &((*_3).3: std::fs::Metadata);
        _20 = std::fs::Metadata::len(move _21) -> [return: bb15, unwind continue];
    }

    bb15: {
        _19 = &_20;
        _0 = <u64 as Ord>::cmp(move _16, _19) -> [return: bb63, unwind continue];
    }

    bb16: {
        _24 = &((*_2).3: std::fs::Metadata);
        _23 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::ino(move _24) -> [return: bb17, unwind continue];
    }

    bb17: {
        _22 = &_23;
        _27 = &((*_3).3: std::fs::Metadata);
        _26 = <std::fs::Metadata as std::os::unix::fs::MetadataExt>::ino(move _27) -> [return: bb18, unwind continue];
    }

    bb18: {
        _25 = &_26;
        _0 = <u64 as Ord>::cmp(move _22, _25) -> [return: bb63, unwind continue];
    }

    bb19: {
        _29 = file::File::<'_>::modified_time(_2) -> [return: bb20, unwind continue];
    }

    bb20: {
        _28 = &_29;
        _31 = file::File::<'_>::modified_time(_3) -> [return: bb21, unwind continue];
    }

    bb21: {
        _30 = &_31;
        _0 = <Option<SystemTime> as Ord>::cmp(move _28, _30) -> [return: bb63, unwind continue];
    }

    bb22: {
        _33 = file::File::<'_>::accessed_time(_2) -> [return: bb23, unwind continue];
    }

    bb23: {
        _32 = &_33;
        _35 = file::File::<'_>::accessed_time(_3) -> [return: bb24, unwind continue];
    }

    bb24: {
        _34 = &_35;
        _0 = <Option<SystemTime> as Ord>::cmp(move _32, _34) -> [return: bb63, unwind continue];
    }

    bb25: {
        _37 = file::File::<'_>::changed_time(_2) -> [return: bb26, unwind continue];
    }

    bb26: {
        _36 = &_37;
        _39 = file::File::<'_>::changed_time(_3) -> [return: bb27, unwind continue];
    }

    bb27: {
        _38 = &_39;
        _0 = <Option<SystemTime> as Ord>::cmp(move _36, _38) -> [return: bb63, unwind continue];
    }

    bb28: {
        _41 = file::File::<'_>::created_time(_2) -> [return: bb29, unwind continue];
    }

    bb29: {
        _40 = &_41;
        _43 = file::File::<'_>::created_time(_3) -> [return: bb30, unwind continue];
    }

    bb30: {
        _42 = &_43;
        _0 = <Option<SystemTime> as Ord>::cmp(move _40, _42) -> [return: bb63, unwind continue];
    }

    bb31: {
        _45 = file::File::<'_>::modified_time(_3) -> [return: bb32, unwind continue];
    }

    bb32: {
        _44 = &_45;
        _47 = file::File::<'_>::modified_time(_2) -> [return: bb33, unwind continue];
    }

    bb33: {
        _46 = &_47;
        _0 = <Option<SystemTime> as Ord>::cmp(move _44, _46) -> [return: bb63, unwind continue];
    }

    bb34: {
        _50 = file::File::<'_>::type_char(_2) -> [return: bb35, unwind continue];
    }

    bb35: {
        _49 = &_50;
        _52 = file::File::<'_>::type_char(_3) -> [return: bb36, unwind continue];
    }

    bb36: {
        _51 = &_52;
        _48 = <Type as Ord>::cmp(move _49, _51) -> [return: bb37, unwind continue];
    }

    bb37: {
        _53 = discriminant(_48);
        switchInt(move _53) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _0 = _48;
        goto -> bb63;
    }

    bb39: {
        _55 = &((*_2).0: std::string::String);
        _54 = <String as Deref>::deref(move _55) -> [return: bb40, unwind continue];
    }

    bb40: {
        _57 = &((*_3).0: std::string::String);
        _56 = <String as Deref>::deref(move _57) -> [return: bb41, unwind continue];
    }

    bb41: {
        _0 = compare(_54, _56) -> [return: bb63, unwind continue];
    }

    bb42: {
        _59 = &((*_2).1: std::option::Option<std::string::String>);
        _60 = &((*_3).1: std::option::Option<std::string::String>);
        _58 = <Option<String> as Ord>::cmp(move _59, _60) -> [return: bb43, unwind continue];
    }

    bb43: {
        _61 = discriminant(_58);
        switchInt(move _61) -> [0: bb45, otherwise: bb44];
    }

    bb44: {
        _0 = _58;
        goto -> bb63;
    }

    bb45: {
        _63 = &((*_2).0: std::string::String);
        _62 = <String as Deref>::deref(move _63) -> [return: bb46, unwind continue];
    }

    bb46: {
        _65 = &((*_3).0: std::string::String);
        _64 = <String as Deref>::deref(move _65) -> [return: bb47, unwind continue];
    }

    bb47: {
        _0 = compare(_62, _64) -> [return: bb63, unwind continue];
    }

    bb48: {
        _67 = &((*_2).1: std::option::Option<std::string::String>);
        _68 = &((*_3).1: std::option::Option<std::string::String>);
        _66 = <Option<String> as Ord>::cmp(move _67, _68) -> [return: bb49, unwind continue];
    }

    bb49: {
        _69 = discriminant(_66);
        switchInt(move _69) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _0 = _66;
        goto -> bb63;
    }

    bb51: {
        _71 = &((*_2).0: std::string::String);
        _70 = <String as Deref>::deref(move _71) -> [return: bb52, unwind continue];
    }

    bb52: {
        _73 = &((*_3).0: std::string::String);
        _72 = <String as Deref>::deref(move _73) -> [return: bb53, unwind continue];
    }

    bb53: {
        _0 = compare_ignore_case(_70, _72) -> [return: bb63, unwind continue];
    }

    bb54: {
        _76 = &((*_2).0: std::string::String);
        _75 = <String as Deref>::deref(_76) -> [return: bb55, unwind continue];
    }

    bb55: {
        _74 = SortField::strip_dot(_75) -> [return: bb56, unwind continue];
    }

    bb56: {
        _79 = &((*_3).0: std::string::String);
        _78 = <String as Deref>::deref(_79) -> [return: bb57, unwind continue];
    }

    bb57: {
        _77 = SortField::strip_dot(_78) -> [return: bb58, unwind continue];
    }

    bb58: {
        _0 = compare(_74, _77) -> [return: bb63, unwind continue];
    }

    bb59: {
        _80 = SortField::strip_dot(_81) -> [return: bb60, unwind continue];
    }

    bb60: {
        _85 = &((*_3).0: std::string::String);
        _84 = <String as Deref>::deref(_85) -> [return: bb61, unwind continue];
    }

    bb61: {
        _83 = SortField::strip_dot(_84) -> [return: bb62, unwind continue];
    }

    bb62: {
        _0 = compare_ignore_case(_80, _83) -> [return: bb63, unwind continue];
    }

    bb63: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:233:1: 233:15>::strip_dot(_1: &str) -> &str {
    debug n => _1;
    let mut _0: &str;
    let mut _2: bool;
    let _3: &str;
    let mut _4: std::ops::RangeFrom<usize>;

    bb0: {
        _2 = core::str::<impl str>::starts_with::<'_, char>(_1, const '.') -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _4 = RangeFrom::<usize> { start: const 1_usize };
        _3 = <str as std::ops::Index<RangeFrom<usize>>>::index(_1, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = _3;
        goto -> bb5;
    }

    bb4: {
        _0 = _1;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:296:10: 296:19>::eq(_1: &IgnorePatterns, _2: &IgnorePatterns) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &std::vec::Vec<glob::Pattern>;
    let mut _4: &std::vec::Vec<glob::Pattern>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<glob::Pattern>);
        _4 = &((*_2).0: std::vec::Vec<glob::Pattern>);
        _0 = <Vec<glob::Pattern> as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:296:21: 296:28>::default() -> IgnorePatterns {
    let mut _0: fs::filter::IgnorePatterns;
    let mut _1: std::vec::Vec<glob::Pattern>;

    bb0: {
        _1 = <Vec<glob::Pattern> as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = IgnorePatterns { patterns: move _1 };
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:296:30: 296:35>::fmt(_1: &IgnorePatterns, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::vec::Vec<glob::Pattern>;
    let _7: &std::vec::Vec<glob::Pattern>;

    bb0: {
        _3 = const "IgnorePatterns";
        _4 = const "patterns";
        _7 = &((*_1).0: std::vec::Vec<glob::Pattern>);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:296:37: 296:42>::clone(_1: &IgnorePatterns) -> IgnorePatterns {
    debug self => _1;
    let mut _0: fs::filter::IgnorePatterns;
    let mut _2: std::vec::Vec<glob::Pattern>;
    let _3: &std::vec::Vec<glob::Pattern>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<glob::Pattern>);
        _2 = <Vec<glob::Pattern> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = IgnorePatterns { patterns: move _2 };
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:301:1: 301:52>::from_iter(_1: I) -> IgnorePatterns {
    debug iter => _1;
    let mut _0: fs::filter::IgnorePatterns;
    let _2: std::vec::Vec<glob::Pattern>;
    let mut _3: <I as std::iter::IntoIterator>::IntoIter;
    scope 1 {
        debug patterns => _2;
    }

    bb0: {
        _3 = <I as IntoIterator>::into_iter(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <<I as IntoIterator>::IntoIter as Iterator>::collect::<Vec<glob::Pattern>>(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = IgnorePatterns { patterns: move _2 };
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::parse_from_iter(_1: I) -> (IgnorePatterns, Vec<PatternError>) {
    debug iter => _1;
    let mut _0: (fs::filter::IgnorePatterns, std::vec::Vec<glob::PatternError>);
    let _2: <I as std::iter::IntoIterator>::IntoIter;
    let mut _4: (usize, std::option::Option<usize>);
    let mut _5: &<I as std::iter::IntoIterator>::IntoIter;
    let mut _6: isize;
    let mut _9: <I as std::iter::IntoIterator>::IntoIter;
    let mut _10: <I as std::iter::IntoIterator>::IntoIter;
    let _12: ();
    let mut _13: std::option::Option<&str>;
    let mut _14: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _15: isize;
    let mut _17: std::result::Result<glob::Pattern, glob::PatternError>;
    let mut _18: isize;
    let mut _20: &mut std::vec::Vec<glob::Pattern>;
    let mut _22: &mut std::vec::Vec<glob::PatternError>;
    let mut _23: fs::filter::IgnorePatterns;
    let mut _24: std::vec::Vec<glob::Pattern>;
    let mut _25: std::vec::Vec<glob::PatternError>;
    let mut _26: bool;
    scope 1 {
        debug iter => _2;
        let mut _3: std::vec::Vec<glob::Pattern>;
        let _7: usize;
        scope 2 {
            debug patterns => _3;
            let mut _8: std::vec::Vec<glob::PatternError>;
            scope 4 {
                debug errors => _8;
                let mut _11: <I as std::iter::IntoIterator>::IntoIter;
                scope 5 {
                    debug iter => _11;
                    let _16: &str;
                    scope 6 {
                        debug input => _16;
                        let _19: glob::Pattern;
                        let _21: glob::PatternError;
                        scope 7 {
                            debug pat => _19;
                        }
                        scope 8 {
                            debug e => _21;
                        }
                    }
                }
            }
        }
        scope 3 {
            debug count => _7;
        }
    }

    bb0: {
        _26 = const false;
        _2 = <I as IntoIterator>::into_iter(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _26 = const true;
        _5 = &_2;
        _4 = <<I as IntoIterator>::IntoIter as Iterator>::size_hint(move _5) -> [return: bb2, unwind: bb22];
    }

    bb2: {
        _6 = discriminant((_4.1: std::option::Option<usize>));
        switchInt(move _6) -> [1: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = Vec::<glob::Pattern>::new() -> [return: bb23, unwind: bb22];
    }

    bb4: {
        _7 = (((_4.1: std::option::Option<usize>) as Some).0: usize);
        _3 = Vec::<glob::Pattern>::with_capacity(_7) -> [return: bb24, unwind: bb22];
    }

    bb5: {
        _8 = Vec::<PatternError>::new() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _26 = const false;
        _10 = move _2;
        _9 = <<I as IntoIterator>::IntoIter as IntoIterator>::into_iter(move _10) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _11 = move _9;
        goto -> bb8;
    }

    bb8: {
        _14 = &mut _11;
        _13 = <<I as IntoIterator>::IntoIter as Iterator>::next(_14) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _16 = ((_13 as Some).0: &str);
        _17 = glob::Pattern::new(_16) -> [return: bb13, unwind: bb17];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        drop(_11) -> [return: bb16, unwind: bb18];
    }

    bb13: {
        _18 = discriminant(_17);
        switchInt(move _18) -> [0: bb15, 1: bb14, otherwise: bb11];
    }

    bb14: {
        _21 = move ((_17 as Err).0: glob::PatternError);
        _22 = &mut _8;
        _12 = Vec::<PatternError>::push(move _22, move _21) -> [return: bb25, unwind: bb17];
    }

    bb15: {
        _19 = move ((_17 as Ok).0: glob::Pattern);
        _20 = &mut _3;
        _12 = Vec::<glob::Pattern>::push(move _20, move _19) -> [return: bb26, unwind: bb17];
    }

    bb16: {
        _24 = move _3;
        _23 = IgnorePatterns { patterns: move _24 };
        _25 = move _8;
        _0 = (move _23, move _25);
        _26 = const false;
        return;
    }

    bb17 (cleanup): {
        drop(_11) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        switchInt(_26) -> [0: bb20, otherwise: bb21];
    }

    bb23: {
        goto -> bb5;
    }

    bb24: {
        goto -> bb5;
    }

    bb25: {
        goto -> bb8;
    }

    bb26: {
        goto -> bb8;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::empty() -> IgnorePatterns {
    let mut _0: fs::filter::IgnorePatterns;
    let mut _1: std::vec::Vec<glob::Pattern>;

    bb0: {
        _1 = Vec::<glob::Pattern>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = IgnorePatterns { patterns: move _1 };
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::is_ignored(_1: &IgnorePatterns, _2: &str) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &mut std::slice::Iter<'_, glob::Pattern>;
    let mut _4: std::slice::Iter<'_, glob::Pattern>;
    let _5: &[glob::Pattern];
    let mut _6: &std::vec::Vec<glob::Pattern>;
    let mut _7: {closure@src/fs/filter.rs:346:34: 346:37};
    let mut _8: &&str;

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<glob::Pattern>);
        _5 = <Vec<glob::Pattern> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [glob::Pattern]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &mut _4;
        _8 = &_2;
        _7 = {closure@src/fs/filter.rs:346:34: 346:37} { file: move _8 };
        _0 = <std::slice::Iter<'_, glob::Pattern> as Iterator>::any::<{closure@src/fs/filter.rs:346:34: 346:37}>(move _3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::is_ignored::{closure#0}(_1: &mut {closure@src/fs/filter.rs:346:34: 346:37}, _2: &glob::Pattern) -> bool {
    debug p => _2;
    debug file => (*((*_1).0: &&str));
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &str;

    bb0: {
        _3 = deref_copy ((*_1).0: &&str);
        _4 = deref_copy (*_3);
        _0 = glob::Pattern::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::is_ignored_path(_1: &IgnorePatterns, _2: &Path) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &mut std::slice::Iter<'_, glob::Pattern>;
    let mut _4: std::slice::Iter<'_, glob::Pattern>;
    let _5: &[glob::Pattern];
    let mut _6: &std::vec::Vec<glob::Pattern>;
    let mut _7: {closure@src/fs/filter.rs:351:34: 351:37};
    let mut _8: &&std::path::Path;

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<glob::Pattern>);
        _5 = <Vec<glob::Pattern> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [glob::Pattern]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &mut _4;
        _8 = &_2;
        _7 = {closure@src/fs/filter.rs:351:34: 351:37} { file: move _8 };
        _0 = <std::slice::Iter<'_, glob::Pattern> as Iterator>::any::<{closure@src/fs/filter.rs:351:34: 351:37}>(move _3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:311:1: 311:20>::is_ignored_path::{closure#0}(_1: &mut {closure@src/fs/filter.rs:351:34: 351:37}, _2: &glob::Pattern) -> bool {
    debug p => _2;
    debug file => (*((*_1).0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: &&std::path::Path;
    let mut _4: &std::path::Path;

    bb0: {
        _3 = deref_copy ((*_1).0: &&std::path::Path);
        _4 = deref_copy (*_3);
        _0 = glob::Pattern::matches_path(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:360:10: 360:19>::eq(_1: &GitIgnore, _2: &GitIgnore) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:360:21: 360:26>::fmt(_1: &GitIgnore, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "Off";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "CheckAndIgnore";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn fs::filter::<impl at src/fs/filter.rs:360:34: 360:39>::clone(_1: &GitIgnore) -> GitIgnore {
    debug self => _1;
    let mut _0: fs::filter::GitIgnore;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:14:10: 14:15>::fmt(_1: &FileExtensions, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "FileExtensions";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:14:17: 14:24>::default() -> FileExtensions {
    let mut _0: info::filetype::FileExtensions;

    bb0: {
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:14:26: 14:35>::eq(_1: &FileExtensions, _2: &FileExtensions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_immediate(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &str;
    let mut _5: &std::string::String;
    let _6: std::string::String;
    let _7: &str;
    let mut _8: &std::string::String;
    let mut _9: bool;
    let _10: &str;
    let mut _11: &std::string::String;
    let mut _12: &[&str];
    let mut _13: &[&str; 31];

    bb0: {
        _8 = &((*_2).0: std::string::String);
        _7 = <String as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = str::<impl str>::to_lowercase(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_6;
        _4 = <String as Deref>::deref(move _5) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _3 = core::str::<impl str>::starts_with::<'_, &str>(_4, const "readme") -> [return: bb4, unwind: bb13];
    }

    bb4: {
        switchInt(move _3) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        drop(_6) -> [return: bb10, unwind continue];
    }

    bb6: {
        drop(_6) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = &((*_2).0: std::string::String);
        _10 = <String as Deref>::deref(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = core::str::<impl str>::ends_with::<'_, &str>(_10, const ".ninja") -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _9) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = const true;
        goto -> bb12;
    }

    bb11: {
        _13 = const _;
        _12 = _13 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::name_is_one_of(_2, move _12) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_6) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_immediate: &[&str; 31] = {
    let mut _0: &[&str; 31];
    let mut _1: [&str; 31];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;
    let mut _40: &str;
    let mut _41: &str;
    let mut _42: &str;
    let mut _43: &str;
    let mut _44: &str;
    let mut _45: &str;
    let mut _46: &str;
    let mut _47: &str;
    let mut _48: &str;
    let mut _49: &str;
    let mut _50: &str;
    let mut _51: &str;
    let mut _52: &str;
    let mut _53: &str;
    let mut _54: &str;
    let mut _55: &str;
    let mut _56: &str;
    let mut _57: &str;
    let mut _58: &str;
    let mut _59: &str;
    let mut _60: &str;
    let mut _61: &str;
    let mut _62: &str;
    let mut _63: &str;

    bb0: {
        _3 = const "Makefile";
        _2 = &(*_3);
        _5 = const "Cargo.toml";
        _4 = &(*_5);
        _7 = const "SConstruct";
        _6 = &(*_7);
        _9 = const "CMakeLists.txt";
        _8 = &(*_9);
        _11 = const "build.gradle";
        _10 = &(*_11);
        _13 = const "pom.xml";
        _12 = &(*_13);
        _15 = const "Rakefile";
        _14 = &(*_15);
        _17 = const "package.json";
        _16 = &(*_17);
        _19 = const "Gruntfile.js";
        _18 = &(*_19);
        _21 = const "Gruntfile.coffee";
        _20 = &(*_21);
        _23 = const "BUILD";
        _22 = &(*_23);
        _25 = const "BUILD.bazel";
        _24 = &(*_25);
        _27 = const "WORKSPACE";
        _26 = &(*_27);
        _29 = const "build.xml";
        _28 = &(*_29);
        _31 = const "webpack.config.js";
        _30 = &(*_31);
        _33 = const "meson.build";
        _32 = &(*_33);
        _35 = const "composer.json";
        _34 = &(*_35);
        _37 = const "RoboFile.php";
        _36 = &(*_37);
        _39 = const "PKGBUILD";
        _38 = &(*_39);
        _41 = const "Justfile";
        _40 = &(*_41);
        _43 = const "Procfile";
        _42 = &(*_43);
        _45 = const "Dockerfile";
        _44 = &(*_45);
        _47 = const "Containerfile";
        _46 = &(*_47);
        _49 = const "Vagrantfile";
        _48 = &(*_49);
        _51 = const "Brewfile";
        _50 = &(*_51);
        _53 = const "Gemfile";
        _52 = &(*_53);
        _55 = const "Pipfile";
        _54 = &(*_55);
        _57 = const "build.sbt";
        _56 = &(*_57);
        _59 = const "mix.exs";
        _58 = &(*_59);
        _61 = const "bsconfig.json";
        _60 = &(*_61);
        _63 = const "tsconfig.json";
        _62 = &(*_63);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50, move _52, move _54, move _56, move _58, move _60, move _62];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_image(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 28];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_image: &[&str; 28] = {
    let mut _0: &[&str; 28];
    let mut _1: [&str; 28];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;
    let mut _40: &str;
    let mut _41: &str;
    let mut _42: &str;
    let mut _43: &str;
    let mut _44: &str;
    let mut _45: &str;
    let mut _46: &str;
    let mut _47: &str;
    let mut _48: &str;
    let mut _49: &str;
    let mut _50: &str;
    let mut _51: &str;
    let mut _52: &str;
    let mut _53: &str;
    let mut _54: &str;
    let mut _55: &str;
    let mut _56: &str;
    let mut _57: &str;

    bb0: {
        _3 = const "png";
        _2 = &(*_3);
        _5 = const "jpeg";
        _4 = &(*_5);
        _7 = const "jpg";
        _6 = &(*_7);
        _9 = const "gif";
        _8 = &(*_9);
        _11 = const "bmp";
        _10 = &(*_11);
        _13 = const "tiff";
        _12 = &(*_13);
        _15 = const "tif";
        _14 = &(*_15);
        _17 = const "ppm";
        _16 = &(*_17);
        _19 = const "pgm";
        _18 = &(*_19);
        _21 = const "pbm";
        _20 = &(*_21);
        _23 = const "pnm";
        _22 = &(*_23);
        _25 = const "webp";
        _24 = &(*_25);
        _27 = const "raw";
        _26 = &(*_27);
        _29 = const "arw";
        _28 = &(*_29);
        _31 = const "svg";
        _30 = &(*_31);
        _33 = const "stl";
        _32 = &(*_33);
        _35 = const "eps";
        _34 = &(*_35);
        _37 = const "dvi";
        _36 = &(*_37);
        _39 = const "ps";
        _38 = &(*_39);
        _41 = const "cbr";
        _40 = &(*_41);
        _43 = const "jpf";
        _42 = &(*_43);
        _45 = const "cbz";
        _44 = &(*_45);
        _47 = const "xpm";
        _46 = &(*_47);
        _49 = const "ico";
        _48 = &(*_49);
        _51 = const "cr2";
        _50 = &(*_51);
        _53 = const "orf";
        _52 = &(*_53);
        _55 = const "nef";
        _54 = &(*_55);
        _57 = const "heif";
        _56 = &(*_57);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46, move _48, move _50, move _52, move _54, move _56];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_video(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 16];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_video: &[&str; 16] = {
    let mut _0: &[&str; 16];
    let mut _1: [&str; 16];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;

    bb0: {
        _3 = const "avi";
        _2 = &(*_3);
        _5 = const "flv";
        _4 = &(*_5);
        _7 = const "m2v";
        _6 = &(*_7);
        _9 = const "m4v";
        _8 = &(*_9);
        _11 = const "mkv";
        _10 = &(*_11);
        _13 = const "mov";
        _12 = &(*_13);
        _15 = const "mp4";
        _14 = &(*_15);
        _17 = const "mpeg";
        _16 = &(*_17);
        _19 = const "mpg";
        _18 = &(*_19);
        _21 = const "ogm";
        _20 = &(*_21);
        _23 = const "ogv";
        _22 = &(*_23);
        _25 = const "vob";
        _24 = &(*_25);
        _27 = const "wmv";
        _26 = &(*_27);
        _29 = const "webm";
        _28 = &(*_29);
        _31 = const "m2ts";
        _30 = &(*_31);
        _33 = const "heic";
        _32 = &(*_33);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_music(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 7];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_music: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;

    bb0: {
        _3 = const "aac";
        _2 = &(*_3);
        _5 = const "m4a";
        _4 = &(*_5);
        _7 = const "mp3";
        _6 = &(*_7);
        _9 = const "ogg";
        _8 = &(*_9);
        _11 = const "wma";
        _10 = &(*_11);
        _13 = const "mka";
        _12 = &(*_13);
        _15 = const "opus";
        _14 = &(*_15);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_lossless(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 4];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_lossless: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;

    bb0: {
        _3 = const "alac";
        _2 = &(*_3);
        _5 = const "ape";
        _4 = &(*_5);
        _7 = const "flac";
        _6 = &(*_7);
        _9 = const "wav";
        _8 = &(*_9);
        _1 = [move _2, move _4, move _6, move _8];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_crypto(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 8];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_crypto: &[&str; 8] = {
    let mut _0: &[&str; 8];
    let mut _1: [&str; 8];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;

    bb0: {
        _3 = const "asc";
        _2 = &(*_3);
        _5 = const "enc";
        _4 = &(*_5);
        _7 = const "gpg";
        _6 = &(*_7);
        _9 = const "pgp";
        _8 = &(*_9);
        _11 = const "sig";
        _10 = &(*_11);
        _13 = const "signature";
        _12 = &(*_13);
        _15 = const "pfx";
        _14 = &(*_15);
        _17 = const "p12";
        _16 = &(*_17);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_document(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 19];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_document: &[&str; 19] = {
    let mut _0: &[&str; 19];
    let mut _1: [&str; 19];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;

    bb0: {
        _3 = const "djvu";
        _2 = &(*_3);
        _5 = const "doc";
        _4 = &(*_5);
        _7 = const "docx";
        _6 = &(*_7);
        _9 = const "dvi";
        _8 = &(*_9);
        _11 = const "eml";
        _10 = &(*_11);
        _13 = const "eps";
        _12 = &(*_13);
        _15 = const "fotd";
        _14 = &(*_15);
        _17 = const "key";
        _16 = &(*_17);
        _19 = const "keynote";
        _18 = &(*_19);
        _21 = const "numbers";
        _20 = &(*_21);
        _23 = const "odp";
        _22 = &(*_23);
        _25 = const "odt";
        _24 = &(*_25);
        _27 = const "pages";
        _26 = &(*_27);
        _29 = const "pdf";
        _28 = &(*_29);
        _31 = const "ppt";
        _30 = &(*_31);
        _33 = const "pptx";
        _32 = &(*_33);
        _35 = const "rtf";
        _34 = &(*_35);
        _37 = const "xls";
        _36 = &(*_37);
        _39 = const "xlsx";
        _38 = &(*_39);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_compressed(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: &[&str];
    let mut _4: &[&str; 23];

    bb0: {
        _4 = const _;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_compressed: &[&str; 23] = {
    let mut _0: &[&str; 23];
    let mut _1: [&str; 23];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &str;
    let mut _35: &str;
    let mut _36: &str;
    let mut _37: &str;
    let mut _38: &str;
    let mut _39: &str;
    let mut _40: &str;
    let mut _41: &str;
    let mut _42: &str;
    let mut _43: &str;
    let mut _44: &str;
    let mut _45: &str;
    let mut _46: &str;
    let mut _47: &str;

    bb0: {
        _3 = const "zip";
        _2 = &(*_3);
        _5 = const "tar";
        _4 = &(*_5);
        _7 = const "Z";
        _6 = &(*_7);
        _9 = const "z";
        _8 = &(*_9);
        _11 = const "gz";
        _10 = &(*_11);
        _13 = const "bz2";
        _12 = &(*_13);
        _15 = const "a";
        _14 = &(*_15);
        _17 = const "ar";
        _16 = &(*_17);
        _19 = const "7z";
        _18 = &(*_19);
        _21 = const "iso";
        _20 = &(*_21);
        _23 = const "dmg";
        _22 = &(*_23);
        _25 = const "tc";
        _24 = &(*_25);
        _27 = const "rar";
        _26 = &(*_27);
        _29 = const "par";
        _28 = &(*_29);
        _31 = const "tgz";
        _30 = &(*_31);
        _33 = const "xz";
        _32 = &(*_33);
        _35 = const "txz";
        _34 = &(*_35);
        _37 = const "lz";
        _36 = &(*_37);
        _39 = const "tlz";
        _38 = &(*_39);
        _41 = const "lzma";
        _40 = &(*_41);
        _43 = const "deb";
        _42 = &(*_43);
        _45 = const "rpm";
        _44 = &(*_45);
        _47 = const "zst";
        _46 = &(*_47);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38, move _40, move _42, move _44, move _46];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_temp(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &str;
    let mut _5: &std::string::String;
    let mut _6: bool;
    let _7: &str;
    let mut _8: &std::string::String;
    let mut _9: bool;
    let _10: &str;
    let mut _11: &std::string::String;
    let mut _12: &[&str];
    let mut _13: &[&str; 6];

    bb0: {
        _5 = &((*_2).0: std::string::String);
        _4 = <String as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = core::str::<impl str>::ends_with::<'_, char>(_4, const '~') -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb3, otherwise: bb9];
    }

    bb3: {
        _8 = &((*_2).0: std::string::String);
        _7 = <String as Deref>::deref(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = core::str::<impl str>::starts_with::<'_, char>(_7, const '#') -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _6) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _11 = &((*_2).0: std::string::String);
        _10 = <String as Deref>::deref(move _11) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = core::str::<impl str>::ends_with::<'_, char>(_10, const '#') -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = const true;
        goto -> bb11;
    }

    bb10: {
        _13 = const _;
        _12 = _13 as &[&str] (PointerCoercion(Unsize));
        _0 = file::File::<'_>::extension_is_one_of(_2, move _12) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_temp: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "tmp";
        _2 = &(*_3);
        _5 = const "swp";
        _4 = &(*_5);
        _7 = const "swo";
        _6 = &(*_7);
        _9 = const "swn";
        _8 = &(*_9);
        _11 = const "bak";
        _10 = &(*_11);
        _13 = const "bk";
        _12 = &(*_13);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_compiled(_1: &FileExtensions, _2: &file::File<'_>) -> bool {
    debug self => _1;
    debug file => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &[&str];
    let mut _5: isize;
    let mut _7: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _8: std::slice::Iter<'_, std::path::PathBuf>;
    let _9: &[std::path::PathBuf];
    let mut _10: &std::vec::Vec<std::path::PathBuf>;
    let _11: std::vec::Vec<std::path::PathBuf>;
    let mut _12: {closure@src/info/filetype.rs:97:48: 97:54};
    let mut _13: &&fs::dir::Dir;
    let mut _14: &[&str; 7];
    scope 1 {
        debug dir => _6;
        let _6: &fs::dir::Dir;
    }

    bb0: {
        _14 = const _;
        _4 = _14 as &[&str] (PointerCoercion(Unsize));
        _3 = file::File::<'_>::extension_is_one_of(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb10;
    }

    bb3: {
        _5 = discriminant(((*_2).4: std::option::Option<&fs::dir::Dir>));
        switchInt(move _5) -> [1: bb4, otherwise: bb9];
    }

    bb4: {
        _6 = ((((*_2).4: std::option::Option<&fs::dir::Dir>) as Some).0: &fs::dir::Dir);
        _11 = sources::<impl file::File<'_>>::get_source_files(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = &_11;
        _9 = <Vec<PathBuf> as Deref>::deref(move _10) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _8 = core::slice::<impl [PathBuf]>::iter(_9) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _7 = &mut _8;
        _13 = &_6;
        _12 = {closure@src/info/filetype.rs:97:48: 97:54} { dir: move _13 };
        _0 = <std::slice::Iter<'_, PathBuf> as Iterator>::any::<{closure@src/info/filetype.rs:97:48: 97:54}>(move _7, move _12) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        drop(_11) -> [return: bb10, unwind continue];
    }

    bb9: {
        _0 = const false;
        goto -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_11) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

promoted[0] in info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_compiled: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;

    bb0: {
        _3 = const "class";
        _2 = &(*_3);
        _5 = const "elc";
        _4 = &(*_5);
        _7 = const "hi";
        _6 = &(*_7);
        _9 = const "o";
        _8 = &(*_9);
        _11 = const "pyc";
        _10 = &(*_11);
        _13 = const "zwc";
        _12 = &(*_13);
        _15 = const "ko";
        _14 = &(*_15);
        _1 = [move _2, move _4, move _6, move _8, move _10, move _12, move _14];
        _0 = &_1;
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:17:1: 17:20>::is_compiled::{closure#0}(_1: &mut {closure@src/info/filetype.rs:97:48: 97:54}, _2: &PathBuf) -> bool {
    debug path => _2;
    debug dir => (*((*_1).0: &&fs::dir::Dir));
    let mut _0: bool;
    let _3: &std::path::Path;
    let mut _4: &&fs::dir::Dir;
    let mut _5: &fs::dir::Dir;

    bb0: {
        _4 = deref_copy ((*_1).0: &&fs::dir::Dir);
        _5 = deref_copy (*_4);
        _3 = <PathBuf as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Dir::contains(_5, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:105:1: 105:36>::colour_file(_1: &FileExtensions, _2: &file::File<'_>) -> Option<Style> {
    debug self => _1;
    debug file => _2;
    let mut _0: std::option::Option<ansi_term::Style>;
    let mut _3: ansi_term::Style;
    let _4: &fs::file::File<'_>;
    let _5: &&fs::file::File<'_>;
    let mut _6: bool;
    let mut _7: ansi_term::Colour;
    let _8: &fs::file::File<'_>;
    let _9: &&fs::file::File<'_>;
    let mut _10: bool;
    let mut _11: &ansi_term::Style;
    let _12: ansi_term::Style;
    let mut _13: ansi_term::Colour;
    let _14: &fs::file::File<'_>;
    let _15: &&fs::file::File<'_>;
    let mut _16: bool;
    let mut _17: ansi_term::Colour;
    let _18: &fs::file::File<'_>;
    let _19: &&fs::file::File<'_>;
    let mut _20: bool;
    let mut _21: ansi_term::Colour;
    let _22: &fs::file::File<'_>;
    let _23: &&fs::file::File<'_>;
    let mut _24: bool;
    let mut _25: ansi_term::Colour;
    let _26: &fs::file::File<'_>;
    let _27: &&fs::file::File<'_>;
    let mut _28: bool;
    let mut _29: ansi_term::Colour;
    let _30: &fs::file::File<'_>;
    let _31: &&fs::file::File<'_>;
    let mut _32: bool;
    let mut _33: ansi_term::Colour;
    let _34: &fs::file::File<'_>;
    let _35: &&fs::file::File<'_>;
    let mut _36: bool;
    let mut _37: ansi_term::Colour;
    let _38: &fs::file::File<'_>;
    let _39: &&fs::file::File<'_>;
    let mut _40: bool;
    let mut _41: ansi_term::Colour;
    let _42: &fs::file::File<'_>;
    let _43: &&fs::file::File<'_>;
    let mut _44: bool;
    let mut _45: ansi_term::Colour;
    let mut _46: &fs::file::File<'_>;
    let mut _47: &fs::file::File<'_>;
    let mut _48: &fs::file::File<'_>;
    let mut _49: &fs::file::File<'_>;
    let mut _50: &fs::file::File<'_>;
    let mut _51: &fs::file::File<'_>;
    let mut _52: &fs::file::File<'_>;
    let mut _53: &fs::file::File<'_>;
    let mut _54: &fs::file::File<'_>;
    let mut _55: &fs::file::File<'_>;
    scope 1 {
        debug f => _4;
        debug f => _5;
    }
    scope 2 {
        debug f => _8;
        debug f => _9;
    }
    scope 3 {
        debug f => _14;
        debug f => _15;
    }
    scope 4 {
        debug f => _18;
        debug f => _19;
    }
    scope 5 {
        debug f => _22;
        debug f => _23;
    }
    scope 6 {
        debug f => _26;
        debug f => _27;
    }
    scope 7 {
        debug f => _30;
        debug f => _31;
    }
    scope 8 {
        debug f => _34;
        debug f => _35;
    }
    scope 9 {
        debug f => _38;
        debug f => _39;
    }
    scope 10 {
        debug f => _42;
        debug f => _43;
    }

    bb0: {
        _5 = &_2;
        _46 = deref_copy (*_5);
        _6 = FileExtensions::is_temp(_1, _46) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _4 = _2;
        _7 = ansi_term::Colour::Fixed(const 244_u8);
        _3 = Color::normal(move _7) -> [return: bb32, unwind continue];
    }

    bb3: {
        _9 = &_2;
        _47 = deref_copy (*_9);
        _10 = FileExtensions::is_immediate(_1, _47) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _10) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _8 = _2;
        _13 = ansi_term::Colour::Yellow;
        _12 = Color::bold(move _13) -> [return: bb7, unwind continue];
    }

    bb6: {
        _15 = &_2;
        _48 = deref_copy (*_15);
        _16 = FileExtensions::is_image(_1, _48) -> [return: bb8, unwind continue];
    }

    bb7: {
        _11 = &_12;
        _3 = Style::underline(move _11) -> [return: bb32, unwind continue];
    }

    bb8: {
        switchInt(move _16) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _14 = _2;
        _17 = ansi_term::Colour::Fixed(const 133_u8);
        _3 = Color::normal(move _17) -> [return: bb32, unwind continue];
    }

    bb10: {
        _19 = &_2;
        _49 = deref_copy (*_19);
        _20 = FileExtensions::is_video(_1, _49) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _20) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _18 = _2;
        _21 = ansi_term::Colour::Fixed(const 135_u8);
        _3 = Color::normal(move _21) -> [return: bb32, unwind continue];
    }

    bb13: {
        _23 = &_2;
        _50 = deref_copy (*_23);
        _24 = FileExtensions::is_music(_1, _50) -> [return: bb14, unwind continue];
    }

    bb14: {
        switchInt(move _24) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _22 = _2;
        _25 = ansi_term::Colour::Fixed(const 92_u8);
        _3 = Color::normal(move _25) -> [return: bb32, unwind continue];
    }

    bb16: {
        _27 = &_2;
        _51 = deref_copy (*_27);
        _28 = FileExtensions::is_lossless(_1, _51) -> [return: bb17, unwind continue];
    }

    bb17: {
        switchInt(move _28) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _26 = _2;
        _29 = ansi_term::Colour::Fixed(const 93_u8);
        _3 = Color::normal(move _29) -> [return: bb32, unwind continue];
    }

    bb19: {
        _31 = &_2;
        _52 = deref_copy (*_31);
        _32 = FileExtensions::is_crypto(_1, _52) -> [return: bb20, unwind continue];
    }

    bb20: {
        switchInt(move _32) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _30 = _2;
        _33 = ansi_term::Colour::Fixed(const 109_u8);
        _3 = Color::normal(move _33) -> [return: bb32, unwind continue];
    }

    bb22: {
        _35 = &_2;
        _53 = deref_copy (*_35);
        _36 = FileExtensions::is_document(_1, _53) -> [return: bb23, unwind continue];
    }

    bb23: {
        switchInt(move _36) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _34 = _2;
        _37 = ansi_term::Colour::Fixed(const 105_u8);
        _3 = Color::normal(move _37) -> [return: bb32, unwind continue];
    }

    bb25: {
        _39 = &_2;
        _54 = deref_copy (*_39);
        _40 = FileExtensions::is_compressed(_1, _54) -> [return: bb26, unwind continue];
    }

    bb26: {
        switchInt(move _40) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _38 = _2;
        _41 = ansi_term::Colour::Red;
        _3 = Color::normal(move _41) -> [return: bb32, unwind continue];
    }

    bb28: {
        _43 = &_2;
        _55 = deref_copy (*_43);
        _44 = FileExtensions::is_compiled(_1, _55) -> [return: bb29, unwind continue];
    }

    bb29: {
        switchInt(move _44) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _42 = _2;
        _45 = ansi_term::Colour::Fixed(const 137_u8);
        _3 = Color::normal(move _45) -> [return: bb32, unwind continue];
    }

    bb31: {
        _0 = Option::<Style>::None;
        goto -> bb33;
    }

    bb32: {
        _0 = Option::<Style>::Some(move _3);
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

fn info::filetype::<impl at src/info/filetype.rs:125:1: 125:33>::icon_file(_1: &FileExtensions, _2: &file::File<'_>) -> Option<char> {
    debug self => _1;
    debug file => _2;
    let mut _0: std::option::Option<char>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: char;
    let mut _6: output::icons::Icons;
    let mut _7: bool;
    let mut _8: char;
    let mut _9: output::icons::Icons;
    let mut _10: bool;
    let mut _11: char;
    let mut _12: output::icons::Icons;

    bb0: {
        _3 = FileExtensions::is_music(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _4 = FileExtensions::is_lossless(_1, _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _6 = Icons::Audio;
        _5 = Icons::value(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Option::<char>::Some(move _5);
        goto -> bb15;
    }

    bb6: {
        _7 = FileExtensions::is_image(_1, _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _7) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        _9 = Icons::Image;
        _8 = Icons::value(move _9) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = Option::<char>::Some(move _8);
        goto -> bb15;
    }

    bb10: {
        _10 = FileExtensions::is_video(_1, _2) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _10) -> [0: bb14, otherwise: bb12];
    }

    bb12: {
        _12 = Icons::Video;
        _11 = Icons::value(move _12) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = Option::<char>::Some(move _11);
        goto -> bb15;
    }

    bb14: {
        _0 = Option::<char>::None;
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn sources::<impl at src/info/sources.rs:6:1: 6:18>::get_source_files(_1: &file::File<'_>) -> Vec<PathBuf> {
    debug self => _1;
    let mut _0: std::vec::Vec<std::path::PathBuf>;
    let mut _2: &std::option::Option<std::string::String>;
    let mut _3: isize;
    let _5: &str;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: std::boxed::Box<[std::path::PathBuf]>;
    let mut _19: std::boxed::Box<[std::path::PathBuf; 4]>;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: *mut u8;
    let mut _23: std::boxed::Box<[std::path::PathBuf; 4]>;
    let mut _24: std::path::PathBuf;
    let _25: &std::path::Path;
    let mut _26: &std::path::PathBuf;
    let mut _27: std::path::PathBuf;
    let _28: &std::path::Path;
    let mut _29: &std::path::PathBuf;
    let mut _30: std::path::PathBuf;
    let _31: &std::path::Path;
    let mut _32: &std::path::PathBuf;
    let mut _33: std::path::PathBuf;
    let _34: &std::path::Path;
    let mut _35: &std::path::PathBuf;
    let mut _36: std::boxed::Box<[std::path::PathBuf]>;
    let mut _37: std::boxed::Box<[std::path::PathBuf; 2]>;
    let mut _38: usize;
    let mut _39: usize;
    let mut _40: *mut u8;
    let mut _41: std::boxed::Box<[std::path::PathBuf; 2]>;
    let mut _42: std::path::PathBuf;
    let _43: &std::path::Path;
    let mut _44: &std::path::PathBuf;
    let mut _45: std::path::PathBuf;
    let _46: &std::path::Path;
    let mut _47: &std::path::PathBuf;
    let mut _48: std::boxed::Box<[std::path::PathBuf]>;
    let mut _49: std::boxed::Box<[std::path::PathBuf; 1]>;
    let mut _50: usize;
    let mut _51: usize;
    let mut _52: *mut u8;
    let mut _53: std::boxed::Box<[std::path::PathBuf; 1]>;
    let mut _54: std::path::PathBuf;
    let _55: &std::path::Path;
    let mut _56: &std::path::PathBuf;
    let mut _57: &mut std::boxed::Box<[std::path::PathBuf; 1]>;
    let mut _58: ();
    let mut _59: &mut std::boxed::Box<[std::path::PathBuf; 2]>;
    let mut _60: ();
    let mut _61: &mut std::boxed::Box<[std::path::PathBuf; 4]>;
    let mut _62: ();
    let mut _63: *const [std::path::PathBuf; 4];
    let mut _64: *const [std::path::PathBuf; 2];
    let mut _65: *const [std::path::PathBuf; 1];
    scope 1 {
        debug ext => _4;
        let _4: &std::string::String;
        let mut _66: *const ();
        let mut _67: usize;
        let mut _68: usize;
        let mut _69: usize;
        let mut _70: usize;
        let mut _71: bool;
        let mut _72: *const ();
        let mut _73: usize;
        let mut _74: usize;
        let mut _75: usize;
        let mut _76: usize;
        let mut _77: bool;
        let mut _78: *const ();
        let mut _79: usize;
        let mut _80: usize;
        let mut _81: usize;
        let mut _82: usize;
        let mut _83: bool;
        scope 2 {
        }
        scope 3 {
        }
        scope 4 {
        }
    }

    bb0: {
        _2 = &((*_1).1: std::option::Option<std::string::String>);
        _3 = discriminant((*_2));
        switchInt(move _3) -> [1: bb1, otherwise: bb47];
    }

    bb1: {
        _4 = &(((*_2) as Some).0: std::string::String);
        _5 = <String as std::ops::Index<RangeFull>>::index(_4, const RangeFull) -> [return: bb2, unwind continue];
    }

    bb2: {
        _17 = <str as PartialEq>::eq(_5, const "css") -> [return: bb28, unwind continue];
    }

    bb3: {
        _20 = SizeOf([std::path::PathBuf; 4]);
        _21 = AlignOf([std::path::PathBuf; 4]);
        _22 = alloc::alloc::exchange_malloc(move _20, move _21) -> [return: bb29, unwind continue];
    }

    bb4: {
        _16 = <str as PartialEq>::eq(_5, const "js") -> [return: bb27, unwind continue];
    }

    bb5: {
        _38 = SizeOf([std::path::PathBuf; 2]);
        _39 = AlignOf([std::path::PathBuf; 2]);
        _40 = alloc::alloc::exchange_malloc(move _38, move _39) -> [return: bb38, unwind continue];
    }

    bb6: {
        _15 = <str as PartialEq>::eq(_5, const "aux") -> [return: bb26, unwind continue];
    }

    bb7: {
        _14 = <str as PartialEq>::eq(_5, const "bbl") -> [return: bb25, unwind continue];
    }

    bb8: {
        _13 = <str as PartialEq>::eq(_5, const "bcf") -> [return: bb24, unwind continue];
    }

    bb9: {
        _12 = <str as PartialEq>::eq(_5, const "blg") -> [return: bb23, unwind continue];
    }

    bb10: {
        _11 = <str as PartialEq>::eq(_5, const "fdb_latexmk") -> [return: bb22, unwind continue];
    }

    bb11: {
        _10 = <str as PartialEq>::eq(_5, const "fls") -> [return: bb21, unwind continue];
    }

    bb12: {
        _9 = <str as PartialEq>::eq(_5, const "lof") -> [return: bb20, unwind continue];
    }

    bb13: {
        _8 = <str as PartialEq>::eq(_5, const "log") -> [return: bb19, unwind continue];
    }

    bb14: {
        _7 = <str as PartialEq>::eq(_5, const "lot") -> [return: bb18, unwind continue];
    }

    bb15: {
        _6 = <str as PartialEq>::eq(_5, const "toc") -> [return: bb17, unwind continue];
    }

    bb16: {
        _0 = Vec::<PathBuf>::new() -> [return: bb48, unwind continue];
    }

    bb17: {
        switchInt(move _6) -> [0: bb16, otherwise: bb43];
    }

    bb18: {
        switchInt(move _7) -> [0: bb15, otherwise: bb43];
    }

    bb19: {
        switchInt(move _8) -> [0: bb14, otherwise: bb43];
    }

    bb20: {
        switchInt(move _9) -> [0: bb13, otherwise: bb43];
    }

    bb21: {
        switchInt(move _10) -> [0: bb12, otherwise: bb43];
    }

    bb22: {
        switchInt(move _11) -> [0: bb11, otherwise: bb43];
    }

    bb23: {
        switchInt(move _12) -> [0: bb10, otherwise: bb43];
    }

    bb24: {
        switchInt(move _13) -> [0: bb9, otherwise: bb43];
    }

    bb25: {
        switchInt(move _14) -> [0: bb8, otherwise: bb43];
    }

    bb26: {
        switchInt(move _15) -> [0: bb7, otherwise: bb43];
    }

    bb27: {
        switchInt(move _16) -> [0: bb6, otherwise: bb5];
    }

    bb28: {
        switchInt(move _17) -> [0: bb4, otherwise: bb3];
    }

    bb29: {
        _23 = ShallowInitBox(move _22, [std::path::PathBuf; 4]);
        _26 = &((*_1).2: std::path::PathBuf);
        _25 = <PathBuf as Deref>::deref(move _26) -> [return: bb30, unwind: bb56];
    }

    bb30: {
        _24 = Path::with_extension::<&str>(_25, const "sass") -> [return: bb31, unwind: bb56];
    }

    bb31: {
        _29 = &((*_1).2: std::path::PathBuf);
        _28 = <PathBuf as Deref>::deref(move _29) -> [return: bb32, unwind: bb52];
    }

    bb32: {
        _27 = Path::with_extension::<&str>(_28, const "scss") -> [return: bb33, unwind: bb52];
    }

    bb33: {
        _32 = &((*_1).2: std::path::PathBuf);
        _31 = <PathBuf as Deref>::deref(move _32) -> [return: bb34, unwind: bb51];
    }

    bb34: {
        _30 = Path::with_extension::<&str>(_31, const "styl") -> [return: bb35, unwind: bb51];
    }

    bb35: {
        _35 = &((*_1).2: std::path::PathBuf);
        _34 = <PathBuf as Deref>::deref(move _35) -> [return: bb36, unwind: bb50];
    }

    bb36: {
        _33 = Path::with_extension::<&str>(_34, const "less") -> [return: bb37, unwind: bb50];
    }

    bb37: {
        _63 = (((_23.0: std::ptr::Unique<[std::path::PathBuf; 4]>).0: std::ptr::NonNull<[std::path::PathBuf; 4]>).0: *const [std::path::PathBuf; 4]);
        _78 = _63 as *const () (PtrToPtr);
        _79 = _78 as usize (Transmute);
        _80 = AlignOf([std::path::PathBuf; 4]);
        _81 = Sub(_80, const 1_usize);
        _82 = BitAnd(_79, _81);
        _83 = Eq(_82, const 0_usize);
        assert(_83, "misaligned pointer dereference: address must be a multiple of {} but is {}", _80, _79) -> [success: bb59, unwind unreachable];
    }

    bb38: {
        _41 = ShallowInitBox(move _40, [std::path::PathBuf; 2]);
        _44 = &((*_1).2: std::path::PathBuf);
        _43 = <PathBuf as Deref>::deref(move _44) -> [return: bb39, unwind: bb55];
    }

    bb39: {
        _42 = Path::with_extension::<&str>(_43, const "coffee") -> [return: bb40, unwind: bb55];
    }

    bb40: {
        _47 = &((*_1).2: std::path::PathBuf);
        _46 = <PathBuf as Deref>::deref(move _47) -> [return: bb41, unwind: bb49];
    }

    bb41: {
        _45 = Path::with_extension::<&str>(_46, const "ts") -> [return: bb42, unwind: bb49];
    }

    bb42: {
        _64 = (((_41.0: std::ptr::Unique<[std::path::PathBuf; 2]>).0: std::ptr::NonNull<[std::path::PathBuf; 2]>).0: *const [std::path::PathBuf; 2]);
        _72 = _64 as *const () (PtrToPtr);
        _73 = _72 as usize (Transmute);
        _74 = AlignOf([std::path::PathBuf; 2]);
        _75 = Sub(_74, const 1_usize);
        _76 = BitAnd(_73, _75);
        _77 = Eq(_76, const 0_usize);
        assert(_77, "misaligned pointer dereference: address must be a multiple of {} but is {}", _74, _73) -> [success: bb58, unwind unreachable];
    }

    bb43: {
        _50 = SizeOf([std::path::PathBuf; 1]);
        _51 = AlignOf([std::path::PathBuf; 1]);
        _52 = alloc::alloc::exchange_malloc(move _50, move _51) -> [return: bb44, unwind continue];
    }

    bb44: {
        _53 = ShallowInitBox(move _52, [std::path::PathBuf; 1]);
        _56 = &((*_1).2: std::path::PathBuf);
        _55 = <PathBuf as Deref>::deref(move _56) -> [return: bb45, unwind: bb54];
    }

    bb45: {
        _54 = Path::with_extension::<&str>(_55, const "tex") -> [return: bb46, unwind: bb54];
    }

    bb46: {
        _65 = (((_53.0: std::ptr::Unique<[std::path::PathBuf; 1]>).0: std::ptr::NonNull<[std::path::PathBuf; 1]>).0: *const [std::path::PathBuf; 1]);
        _66 = _65 as *const () (PtrToPtr);
        _67 = _66 as usize (Transmute);
        _68 = AlignOf([std::path::PathBuf; 1]);
        _69 = Sub(_68, const 1_usize);
        _70 = BitAnd(_67, _69);
        _71 = Eq(_70, const 0_usize);
        assert(_71, "misaligned pointer dereference: address must be a multiple of {} but is {}", _68, _67) -> [success: bb57, unwind unreachable];
    }

    bb47: {
        _0 = Vec::<PathBuf>::new() -> [return: bb48, unwind continue];
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_42) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_30) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_27) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_24) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        resume;
    }

    bb54 (cleanup): {
        _57 = &mut _53;
        _58 = <Box<[PathBuf; 1]> as Drop>::drop(move _57) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        _59 = &mut _41;
        _60 = <Box<[PathBuf; 2]> as Drop>::drop(move _59) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        _61 = &mut _23;
        _62 = <Box<[PathBuf; 4]> as Drop>::drop(move _61) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb57: {
        (*_65) = [move _54];
        _49 = move _53;
        _48 = move _49 as std::boxed::Box<[std::path::PathBuf]> (PointerCoercion(Unsize));
        _0 = slice::<impl [PathBuf]>::into_vec::<std::alloc::Global>(move _48) -> [return: bb48, unwind continue];
    }

    bb58: {
        (*_64) = [move _42, move _45];
        _37 = move _41;
        _36 = move _37 as std::boxed::Box<[std::path::PathBuf]> (PointerCoercion(Unsize));
        _0 = slice::<impl [PathBuf]>::into_vec::<std::alloc::Global>(move _36) -> [return: bb48, unwind continue];
    }

    bb59: {
        (*_63) = [move _24, move _27, move _30, move _33];
        _19 = move _23;
        _18 = move _19 as std::boxed::Box<[std::path::PathBuf]> (PointerCoercion(Unsize));
        _0 = slice::<impl [PathBuf]>::into_vec::<std::alloc::Global>(move _18) -> [return: bb48, unwind continue];
    }

    bb60 (cleanup): {
        goto -> bb53;
    }

    bb61 (cleanup): {
        goto -> bb53;
    }

    bb62 (cleanup): {
        goto -> bb53;
    }
}

fn configure(_1: Option<T>) -> () {
    debug ev => _1;
    let mut _0: ();
    let _2: T;
    let mut _3: isize;
    let _4: T;
    let mut _6: &T;
    let mut _7: bool;
    let mut _8: &std::ffi::OsStr;
    let mut _9: bool;
    let mut _10: &&std::ffi::OsStr;
    let _11: ();
    let mut _12: log::LevelFilter;
    let _13: ();
    let mut _14: log::LevelFilter;
    let mut _16: &dyn log::Log;
    let _17: &logger::Logger;
    let mut _18: isize;
    let _20: ();
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &log::SetLoggerError;
    scope 1 {
        debug ev => _2;
        let _5: &std::ffi::OsStr;
        scope 3 {
            debug env_var => _5;
            let _15: std::result::Result<(), log::SetLoggerError>;
            let mut _29: &&str;
            scope 4 {
                debug result => _15;
                scope 5 {
                    debug e => const SetLoggerError(());
                    let _19: log::SetLoggerError;
                    let mut _28: &[&str; 2];
                }
            }
        }
    }
    scope 2 {
        debug v => _4;
    }

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb16, 1: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _4 = move ((_1 as Some).0: T);
        _2 = move _4;
        _6 = &_2;
        _5 = <T as AsRef<OsStr>>::as_ref(move _6) -> [return: bb3, unwind: bb17];
    }

    bb3: {
        _8 = _5;
        _7 = OsStr::is_empty(move _8) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        drop(_2) -> [return: bb16, unwind continue];
    }

    bb6: {
        _10 = &_5;
        _29 = const _;
        _9 = <&OsStr as PartialEq<&str>>::eq(move _10, _29) -> [return: bb7, unwind: bb17];
    }

    bb7: {
        switchInt(move _9) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _12 = log::LevelFilter::Trace;
        _11 = set_max_level(move _12) -> [return: bb19, unwind: bb17];
    }

    bb9: {
        _14 = log::LevelFilter::Debug;
        _13 = set_max_level(move _14) -> [return: bb20, unwind: bb17];
    }

    bb10: {
        _17 = const _;
        _16 = _17 as &dyn log::Log (PointerCoercion(Unsize));
        _15 = set_logger(move _16) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _18 = discriminant(_15);
        switchInt(move _18) -> [1: bb12, otherwise: bb15];
    }

    bb12: {
        _28 = const _;
        _22 = _28 as &[&str] (PointerCoercion(Unsize));
        _27 = &_19;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<SetLoggerError>(_27) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        _20 = _eprint(move _21) -> [return: bb21, unwind: bb17];
    }

    bb15: {
        drop(_2) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        goto -> bb10;
    }

    bb20: {
        goto -> bb10;
    }

    bb21: {
        goto -> bb15;
    }
}

promoted[0] in configure: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Failed to initialise logger: ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in configure: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "trace";
        _0 = &_1;
        return;
    }
}

fn logger::<impl at src/logger.rs:35:10: 35:15>::fmt(_1: &Logger, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "Logger";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const GLOBAL_LOGGER: &Logger = {
    let mut _0: &logger::Logger;
    let _1: &logger::Logger;
    let _2: logger::Logger;
    let mut _3: &logger::Logger;

    bb0: {
        StorageLive(_1);
        _3 = const _;
        _1 = &(*_3);
        _0 = &(*_1);
        StorageDead(_1);
        return;
    }
}

promoted[0] in GLOBAL_LOGGER: &Logger = {
    let mut _0: &logger::Logger;
    let mut _1: logger::Logger;

    bb0: {
        _1 = Logger;
        _0 = &_1;
        return;
    }
}

fn logger::<impl at src/logger.rs:40:1: 40:25>::enabled(_1: &Logger, _2: &log::Metadata<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn logger::<impl at src/logger.rs:40:1: 40:25>::log(_1: &Logger, _2: &Record<'_>) -> () {
    debug self => _1;
    debug record => _2;
    let mut _0: ();
    let _3: ansi_term::ANSIGenericString<'_, str>;
    let mut _4: ansi_term::Colour;
    let mut _6: log::Level;
    let mut _8: ansi_term::Colour;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 5];
    let _14: [core::fmt::rt::Argument<'_>; 5];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &ansi_term::ANSIGenericString<'_, str>;
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &ansi_term::ANSIGenericString<'_, str>;
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &&str;
    let _21: &str;
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &ansi_term::ANSIGenericString<'_, str>;
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &&std::fmt::Arguments<'_>;
    let _26: &std::fmt::Arguments<'_>;
    scope 1 {
        debug open => _3;
        let _5: ansi_term::ANSIGenericString<'_, str>;
        scope 2 {
            debug level => _5;
            let _7: ansi_term::ANSIGenericString<'_, str>;
            scope 3 {
                debug close => _7;
                let mut _27: &[&str; 6];
            }
        }
    }

    bb0: {
        _4 = ansi_term::Colour::Fixed(const 243_u8);
        _3 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _4, const "[") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Record::<'_>::level(_2) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _5 = level(move _6) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _8 = ansi_term::Colour::Fixed(const 243_u8);
        _7 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _8, const "]") -> [return: bb4, unwind: bb18];
    }

    bb4: {
        _27 = const _;
        _11 = _27 as &[&str] (PointerCoercion(Unsize));
        _16 = &_3;
        _15 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericString<'_, str>>(_16) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _18 = &_5;
        _17 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericString<'_, str>>(_18) -> [return: bb6, unwind: bb17];
    }

    bb6: {
        _21 = Record::<'_>::target(_2) -> [return: bb7, unwind: bb17];
    }

    bb7: {
        _20 = &_21;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_20) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _23 = &_7;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericString<'_, str>>(_23) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _26 = Record::<'_>::args(_2) -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _25 = &_26;
        _24 = core::fmt::rt::Argument::<'_>::new_display::<&std::fmt::Arguments<'_>>(_25) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _14 = [move _15, move _17, move _19, move _22, move _24];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = std::fmt::Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _9 = _eprint(move _10) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        drop(_7) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        drop(_5) -> [return: bb15, unwind: bb19];
    }

    bb15: {
        drop(_3) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_7) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }
}

promoted[0] in logger::<impl at src/logger.rs:40:1: 40:25>::log: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];

    bb0: {
        _1 = [const "", const "", const " ", const "", const " ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn logger::<impl at src/logger.rs:40:1: 40:25>::flush(_1: &Logger) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn level(_1: Level) -> ANSIGenericString<'_, str> {
    debug level => _1;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _2: usize;
    let mut _3: ansi_term::Colour;
    let mut _4: ansi_term::Colour;
    let mut _5: ansi_term::Colour;
    let mut _6: ansi_term::Colour;
    let mut _7: ansi_term::Colour;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb3, 2: bb4, 3: bb5, 4: bb6, 5: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = ansi_term::Colour::Fixed(const 245_u8);
        _0 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _7, const "TRACE") -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = ansi_term::Colour::Red;
        _0 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _3, const "ERROR") -> [return: bb7, unwind continue];
    }

    bb4: {
        _4 = ansi_term::Colour::Yellow;
        _0 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _4, const "WARN") -> [return: bb7, unwind continue];
    }

    bb5: {
        _5 = ansi_term::Colour::Cyan;
        _0 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _5, const "INFO") -> [return: bb7, unwind continue];
    }

    bb6: {
        _6 = ansi_term::Colour::Blue;
        _0 = ansi_term::display::<impl Color>::paint::<'_, &str, str>(move _6, const "DEBUG") -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn options::dir_action::<impl at src/options/dir_action.rs:9:1: 9:15>::deduce(_1: &MatchedFlags<'_>, _2: bool) -> Result<DirAction, OptionsError> {
    debug matches => _1;
    debug can_tree => _2;
    let mut _0: std::result::Result<fs::dir_action::DirAction, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _4: std::result::Result<bool, options::error::OptionsError>;
    let _5: &options::parser::Arg;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _8: bool;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _10: std::result::Result<bool, options::error::OptionsError>;
    let _11: &options::parser::Arg;
    let mut _12: isize;
    let mut _15: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _16: std::result::Result<bool, options::error::OptionsError>;
    let _17: &options::parser::Arg;
    let mut _18: isize;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: usize;
    let _24: &options::parser::Arg;
    let mut _25: options::error::OptionsError;
    let _26: &options::parser::Arg;
    let _27: &options::parser::Arg;
    let _28: &options::parser::Arg;
    let mut _29: options::error::OptionsError;
    let _30: &options::parser::Arg;
    let _31: &options::parser::Arg;
    let mut _32: options::error::OptionsError;
    let _33: &options::parser::Arg;
    let _34: &options::parser::Arg;
    let mut _35: fs::dir_action::DirAction;
    let mut _36: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::dir_action::RecurseOptions>;
    let mut _37: std::result::Result<fs::dir_action::RecurseOptions, options::error::OptionsError>;
    let mut _38: isize;
    let mut _41: fs::dir_action::DirAction;
    let mut _42: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::dir_action::RecurseOptions>;
    let mut _43: std::result::Result<fs::dir_action::RecurseOptions, options::error::OptionsError>;
    let mut _44: isize;
    let mut _47: fs::dir_action::DirAction;
    let mut _48: fs::dir_action::DirAction;
    scope 1 {
        debug recurse => _8;
        let _13: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _14: bool;
        scope 6 {
            debug as_file => _14;
            let _19: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _20: bool;
            scope 11 {
                debug tree => _20;
                let _39: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _40: fs::dir_action::RecurseOptions;
                let _45: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _46: fs::dir_action::RecurseOptions;
                scope 16 {
                    debug residual => _39;
                    scope 17 {
                    }
                }
                scope 18 {
                    debug val => _40;
                    scope 19 {
                    }
                }
                scope 20 {
                    debug residual => _45;
                    scope 21 {
                    }
                }
                scope 22 {
                    debug val => _46;
                    scope 23 {
                    }
                }
            }
            scope 12 {
                debug residual => _19;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _20;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _13;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _14;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = const {alloc6: &Arg};
        _4 = MatchedFlags::<'_>::has(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<bool, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: bool);
        _11 = const {alloc7: &Arg};
        _10 = MatchedFlags::<'_>::has(_1, _11) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<DirAction, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb42, unwind continue];
    }

    bb6: {
        _9 = <Result<bool, OptionsError> as Try>::branch(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _14 = ((_9 as Continue).0: bool);
        _17 = const {alloc8: &Arg};
        _16 = MatchedFlags::<'_>::has(_1, _17) -> [return: bb10, unwind continue];
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<DirAction, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _13) -> [return: bb42, unwind continue];
    }

    bb10: {
        _15 = <Result<bool, OptionsError> as Try>::branch(move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        _18 = discriminant(_15);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _20 = ((_15 as Continue).0: bool);
        _21 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb14, unwind continue];
    }

    bb13: {
        _19 = move ((_15 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<DirAction, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _19) -> [return: bb42, unwind continue];
    }

    bb14: {
        switchInt(move _21) -> [0: bb26, otherwise: bb15];
    }

    bb15: {
        switchInt(_8) -> [0: bb16, otherwise: bb20];
    }

    bb16: {
        switchInt(_20) -> [0: bb17, otherwise: bb20];
    }

    bb17: {
        _24 = const {alloc9: &Arg};
        _23 = MatchedFlags::<'_>::count(_1, _24) -> [return: bb18, unwind continue];
    }

    bb18: {
        _22 = Gt(move _23, const 0_usize);
        switchInt(move _22) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _26 = const {alloc9: &Arg};
        _27 = const {alloc6: &Arg};
        _28 = const {alloc8: &Arg};
        _25 = OptionsError::Useless2(_26, _27, _28);
        _0 = Result::<DirAction, OptionsError>::Err(move _25);
        goto -> bb42;
    }

    bb20: {
        switchInt(_8) -> [0: bb23, otherwise: bb21];
    }

    bb21: {
        switchInt(_14) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _30 = const {alloc6: &Arg};
        _31 = const {alloc7: &Arg};
        _29 = OptionsError::Conflict(_30, _31);
        _0 = Result::<DirAction, OptionsError>::Err(move _29);
        goto -> bb42;
    }

    bb23: {
        switchInt(_20) -> [0: bb26, otherwise: bb24];
    }

    bb24: {
        switchInt(_14) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _33 = const {alloc8: &Arg};
        _34 = const {alloc7: &Arg};
        _32 = OptionsError::Conflict(_33, _34);
        _0 = Result::<DirAction, OptionsError>::Err(move _32);
        goto -> bb42;
    }

    bb26: {
        switchInt(_20) -> [0: bb33, otherwise: bb27];
    }

    bb27: {
        switchInt(_2) -> [0: bb33, otherwise: bb28];
    }

    bb28: {
        _37 = options::dir_action::<impl RecurseOptions>::deduce(_1, const true) -> [return: bb29, unwind continue];
    }

    bb29: {
        _36 = <Result<RecurseOptions, OptionsError> as Try>::branch(move _37) -> [return: bb30, unwind continue];
    }

    bb30: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb31, 1: bb32, otherwise: bb4];
    }

    bb31: {
        _40 = ((_36 as Continue).0: fs::dir_action::RecurseOptions);
        _35 = DirAction::Recurse(_40);
        _0 = Result::<DirAction, OptionsError>::Ok(move _35);
        goto -> bb42;
    }

    bb32: {
        _39 = move ((_36 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<DirAction, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _39) -> [return: bb42, unwind continue];
    }

    bb33: {
        switchInt(_8) -> [0: bb39, otherwise: bb34];
    }

    bb34: {
        _43 = options::dir_action::<impl RecurseOptions>::deduce(_1, const false) -> [return: bb35, unwind continue];
    }

    bb35: {
        _42 = <Result<RecurseOptions, OptionsError> as Try>::branch(move _43) -> [return: bb36, unwind continue];
    }

    bb36: {
        _44 = discriminant(_42);
        switchInt(move _44) -> [0: bb37, 1: bb38, otherwise: bb4];
    }

    bb37: {
        _46 = ((_42 as Continue).0: fs::dir_action::RecurseOptions);
        _41 = DirAction::Recurse(_46);
        _0 = Result::<DirAction, OptionsError>::Ok(move _41);
        goto -> bb42;
    }

    bb38: {
        _45 = move ((_42 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<DirAction, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _45) -> [return: bb42, unwind continue];
    }

    bb39: {
        switchInt(_14) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _47 = DirAction::AsFile;
        _0 = Result::<DirAction, OptionsError>::Ok(move _47);
        goto -> bb42;
    }

    bb41: {
        _48 = DirAction::List;
        _0 = Result::<DirAction, OptionsError>::Ok(move _48);
        goto -> bb42;
    }

    bb42: {
        return;
    }
}

alloc9 (static: LEVEL, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4186<imm>  
    0x20  05 00 00 00 00 00 00 00 01 4c __ __ __ __ __ __  .........L
}

alloc4186 (size: 5, align: 1) {
    6c 65 76 65 6c                                   level
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

alloc7 (static: LIST_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4180<imm>  
    0x20  09 00 00 00 00 00 00 00 01 64 __ __ __ __ __ __  .........d
}

alloc4180 (size: 9, align: 1) {
    6c 69 73 74 2d 64 69 72 73                       list-dirs
}

alloc6 (static: RECURSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4132<imm>  
    0x20  07 00 00 00 00 00 00 00 01 52 __ __ __ __ __ __  .........R
}

alloc4132 (size: 7, align: 1) {
    72 65 63 75 72 73 65                             recurse
}

fn options::dir_action::<impl at src/options/dir_action.rs:51:1: 51:20>::deduce(_1: &MatchedFlags<'_>, _2: bool) -> Result<RecurseOptions, OptionsError> {
    debug matches => _1;
    debug tree => _2;
    let mut _0: std::result::Result<fs::dir_action::RecurseOptions, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _4: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let _5: &options::parser::Arg;
    let mut _6: isize;
    let mut _9: isize;
    let mut _12: std::result::Result<usize, std::num::ParseIntError>;
    let _13: &str;
    let mut _14: &std::borrow::Cow<'_, str>;
    let mut _15: isize;
    let mut _17: fs::dir_action::RecurseOptions;
    let mut _18: std::option::Option<usize>;
    let _21: &options::parser::Arg;
    let mut _22: options::error::OptionsError;
    let mut _23: std::string::String;
    let mut _24: &std::borrow::Cow<'_, str>;
    let mut _25: fs::dir_action::RecurseOptions;
    let mut _26: std::option::Option<usize>;
    scope 1 {
        debug level => _10;
        let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _8: std::option::Option<&std::ffi::OsStr>;
        let _10: &std::ffi::OsStr;
        let _11: std::borrow::Cow<'_, str>;
        scope 2 {
            debug residual => _7;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _8;
            scope 5 {
            }
        }
        scope 6 {
            debug arg_str => _11;
            let _16: usize;
            let _19: std::num::ParseIntError;
            scope 7 {
                debug l => _16;
            }
            scope 8 {
                debug e => _19;
                let _20: options::error::NumberSource;
                scope 9 {
                    debug source => _20;
                }
            }
        }
    }

    bb0: {
        _5 = const {alloc9: &Arg};
        _4 = MatchedFlags::<'_>::get(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb7, otherwise: bb6];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<RecurseOptions, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb15, unwind continue];
    }

    bb6: {
        _26 = Option::<usize>::None;
        _25 = RecurseOptions { tree: _2, max_depth: move _26 };
        _0 = Result::<RecurseOptions, OptionsError>::Ok(move _25);
        goto -> bb15;
    }

    bb7: {
        _10 = ((_8 as Some).0: &std::ffi::OsStr);
        _11 = OsStr::to_string_lossy(_10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _14 = &_11;
        _13 = <Cow<'_, str> as Deref>::deref(move _14) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _12 = core::str::<impl str>::parse::<usize>(_13) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _15 = discriminant(_12);
        switchInt(move _15) -> [0: bb12, 1: bb11, otherwise: bb4];
    }

    bb11: {
        _19 = move ((_12 as Err).0: std::num::ParseIntError);
        _21 = const {alloc9: &Arg};
        _20 = NumberSource::Arg(_21);
        _24 = &_11;
        _23 = <Cow<'_, str> as ToString>::to_string(move _24) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        _16 = ((_12 as Ok).0: usize);
        _18 = Option::<usize>::Some(_16);
        _17 = RecurseOptions { tree: _2, max_depth: move _18 };
        _0 = Result::<RecurseOptions, OptionsError>::Ok(move _17);
        goto -> bb14;
    }

    bb13: {
        _22 = OptionsError::FailedParse(move _23, move _20, move _19);
        _0 = Result::<RecurseOptions, OptionsError>::Err(move _22);
        goto -> bb14;
    }

    bb14: {
        drop(_11) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_11) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

alloc9 (static: LEVEL, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4186<imm>  
    0x20  05 00 00 00 00 00 00 00 01 4c __ __ __ __ __ __  .........L
}

alloc4186 (size: 5, align: 1) {
    6c 65 76 65 6c                                   level
}

fn options::file_name::<impl at src/options/file_name.rs:8:1: 8:13>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<output::file_name::Options, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::file_name::Options, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::file_name::Classify>;
    let mut _4: std::result::Result<output::file_name::Classify, options::error::OptionsError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: output::file_name::Classify;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::file_name::ShowIcons>;
    let mut _9: std::result::Result<output::file_name::ShowIcons, options::error::OptionsError>;
    let mut _10: isize;
    let mut _13: output::file_name::Options;
    scope 1 {
        debug classify => _7;
        let _11: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _12: output::file_name::ShowIcons;
        scope 6 {
            debug show_icons => _12;
        }
        scope 7 {
            debug residual => _11;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = options::file_name::<impl Classify>::deduce(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<Classify, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: output::file_name::Classify);
        _9 = options::file_name::<impl ShowIcons>::deduce::<V>(_1, _2) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::file_name::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb10, unwind continue];
    }

    bb6: {
        _8 = <Result<ShowIcons, OptionsError> as Try>::branch(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: output::file_name::ShowIcons);
        _13 = output::file_name::Options { classify: _7, show_icons: _12 };
        _0 = Result::<output::file_name::Options, OptionsError>::Ok(move _13);
        goto -> bb10;
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::file_name::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn options::file_name::<impl at src/options/file_name.rs:17:1: 17:14>::deduce(_1: &MatchedFlags<'_>) -> Result<Classify, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::file_name::Classify, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _3: std::result::Result<bool, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: bool;
    let mut _8: output::file_name::Classify;
    let mut _9: output::file_name::Classify;
    scope 1 {
        debug flagged => _7;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = const {alloc10: &Arg};
        _3 = MatchedFlags::<'_>::has(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<bool, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: bool);
        switchInt(_7) -> [0: bb7, otherwise: bb6];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Classify, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb8, unwind continue];
    }

    bb6: {
        _8 = Classify::AddFileIndicators;
        _0 = Result::<Classify, OptionsError>::Ok(move _8);
        goto -> bb8;
    }

    bb7: {
        _9 = Classify::JustFilenames;
        _0 = Result::<Classify, OptionsError>::Ok(move _9);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

alloc10 (static: CLASSIFY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4142<imm>  
    0x20  08 00 00 00 00 00 00 00 01 46 __ __ __ __ __ __  .........F
}

alloc4142 (size: 8, align: 1) {
    63 6c 61 73 73 69 66 79                          classify
}

fn options::file_name::<impl at src/options/file_name.rs:26:1: 26:15>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<ShowIcons, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::file_name::ShowIcons, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _4: std::result::Result<bool, options::error::OptionsError>;
    let _5: &options::parser::Arg;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _8: bool;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _10: std::result::Result<bool, options::error::OptionsError>;
    let _11: &options::parser::Arg;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _14: bool;
    let mut _15: output::file_name::ShowIcons;
    let mut _16: std::option::Option<std::string::String>;
    let mut _17: std::option::Option<std::ffi::OsString>;
    let mut _18: &str;
    let mut _19: &&str;
    let mut _20: isize;
    let mut _22: std::result::Result<u32, std::num::ParseIntError>;
    let _23: &str;
    let mut _24: &std::string::String;
    let mut _25: isize;
    let mut _27: output::file_name::ShowIcons;
    let mut _30: &str;
    let mut _31: &&str;
    let mut _32: options::error::OptionsError;
    let mut _33: std::string::String;
    let mut _34: output::file_name::ShowIcons;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: isize;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _13;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _14;
        scope 8 {
        }
    }
    scope 9 {
        debug columns => _21;
        let _21: std::string::String;
        let _26: u32;
        let _28: std::num::ParseIntError;
        scope 10 {
            debug width => _26;
        }
        scope 11 {
            debug e => _28;
            let _29: options::error::NumberSource;
            scope 12 {
                debug source => _29;
            }
        }
    }

    bb0: {
        _35 = const false;
        _36 = const false;
        _5 = const {alloc11: &Arg};
        _4 = MatchedFlags::<'_>::has(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<bool, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: bool);
        switchInt(_8) -> [0: bb24, otherwise: bb10];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<ShowIcons, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb21, unwind continue];
    }

    bb6: {
        _9 = <Result<bool, OptionsError> as Try>::branch(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _14 = ((_9 as Continue).0: bool);
        switchInt(_14) -> [0: bb10, otherwise: bb25];
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<ShowIcons, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _13) -> [return: bb21, unwind continue];
    }

    bb10: {
        _15 = ShowIcons::Off;
        _0 = Result::<ShowIcons, OptionsError>::Ok(move _15);
        goto -> bb21;
    }

    bb11: {
        _16 = Option::<OsString>::and_then::<String, {closure@src/options/file_name.rs:31:79: 31:82}>(move _17, const ZeroSized: {closure@src/options/file_name.rs:31:79: 31:82}) -> [return: bb12, unwind continue];
    }

    bb12: {
        _36 = const true;
        _20 = discriminant(_16);
        switchInt(move _20) -> [1: bb13, otherwise: bb19];
    }

    bb13: {
        _36 = const false;
        _35 = const true;
        _21 = move ((_16 as Some).0: std::string::String);
        _24 = &_21;
        _23 = <String as Deref>::deref(move _24) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _22 = core::str::<impl str>::parse::<u32>(_23) -> [return: bb15, unwind: bb22];
    }

    bb15: {
        _25 = discriminant(_22);
        switchInt(move _25) -> [0: bb17, 1: bb16, otherwise: bb4];
    }

    bb16: {
        _28 = move ((_22 as Err).0: std::num::ParseIntError);
        _31 = const {alloc13: &&str};
        _30 = (*_31);
        _29 = NumberSource::Env(move _30);
        _35 = const false;
        _33 = move _21;
        _32 = OptionsError::FailedParse(move _33, move _29, move _28);
        _0 = Result::<ShowIcons, OptionsError>::Err(move _32);
        goto -> bb18;
    }

    bb17: {
        _26 = ((_22 as Ok).0: u32);
        _27 = ShowIcons::On(_26);
        _0 = Result::<ShowIcons, OptionsError>::Ok(move _27);
        goto -> bb18;
    }

    bb18: {
        switchInt(_35) -> [0: bb20, otherwise: bb26];
    }

    bb19: {
        _34 = ShowIcons::On(const 1_u32);
        _0 = Result::<ShowIcons, OptionsError>::Ok(move _34);
        goto -> bb30;
    }

    bb20: {
        _35 = const false;
        goto -> bb30;
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_21) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }

    bb24: {
        _11 = const {alloc12: &Arg};
        _10 = MatchedFlags::<'_>::has(_1, _11) -> [return: bb6, unwind continue];
    }

    bb25: {
        _19 = const {alloc13: &&str};
        _18 = (*_19);
        _17 = <V as vars::Vars>::get(_2, move _18) -> [return: bb11, unwind continue];
    }

    bb26: {
        drop(_21) -> [return: bb20, unwind continue];
    }

    bb27: {
        _36 = const false;
        goto -> bb21;
    }

    bb28: {
        switchInt(_36) -> [0: bb27, otherwise: bb29];
    }

    bb29: {
        drop(((_16 as Some).0: std::string::String)) -> [return: bb27, unwind continue];
    }

    bb30: {
        _37 = discriminant(_16);
        switchInt(move _37) -> [1: bb28, otherwise: bb27];
    }
}

alloc13 (static: EXA_ICON_SPACING, size: 16, align: 8) {
    alloc1034<imm> 10 00 00 00 00 00 00 00  ........
}

alloc1034 (size: 16, align: 1) {
    45 58 41 5f 49 43 4f 4e 5f 53 50 41 43 49 4e 47  EXA_ICON_SPACING
}

alloc12 (static: ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4263<imm>  
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4263 (size: 5, align: 1) {
    69 63 6f 6e 73                                   icons
}

alloc11 (static: NO_ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4349<imm>  
    0x20  08 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4349 (size: 8, align: 1) {
    6e 6f 2d 69 63 6f 6e 73                          no-icons
}

fn options::file_name::<impl at src/options/file_name.rs:26:1: 26:15>::deduce::{closure#0}(_1: {closure@src/options/file_name.rs:31:79: 31:82}, _2: OsString) -> Option<String> {
    debug s => _2;
    let mut _0: std::option::Option<std::string::String>;
    let mut _3: std::result::Result<std::string::String, std::ffi::OsString>;

    bb0: {
        _3 = OsString::into_string(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<String, OsString>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn options::filter::<impl at src/options/filter.rs:10:1: 10:16>::deduce(_1: &MatchedFlags<'_>) -> Result<FileFilter, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<fs::filter::FileFilter, options::error::OptionsError>;
    let mut _2: fs::filter::FileFilter;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _4: std::result::Result<bool, options::error::OptionsError>;
    let _5: &options::parser::Arg;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _8: bool;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _10: std::result::Result<bool, options::error::OptionsError>;
    let _11: &options::parser::Arg;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _14: bool;
    let mut _15: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _16: std::result::Result<bool, options::error::OptionsError>;
    let _17: &options::parser::Arg;
    let mut _18: isize;
    let _19: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _20: bool;
    let mut _21: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::filter::SortField>;
    let mut _22: std::result::Result<fs::filter::SortField, options::error::OptionsError>;
    let mut _23: isize;
    let _24: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _25: fs::filter::SortField;
    let mut _26: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::dir::DotFilter>;
    let mut _27: std::result::Result<fs::dir::DotFilter, options::error::OptionsError>;
    let mut _28: isize;
    let _29: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _30: fs::dir::DotFilter;
    let mut _31: fs::filter::IgnorePatterns;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::filter::IgnorePatterns>;
    let mut _33: std::result::Result<fs::filter::IgnorePatterns, options::error::OptionsError>;
    let mut _34: isize;
    let _35: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _36: fs::filter::IgnorePatterns;
    let mut _37: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::filter::GitIgnore>;
    let mut _38: std::result::Result<fs::filter::GitIgnore, options::error::OptionsError>;
    let mut _39: isize;
    let _40: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _41: fs::filter::GitIgnore;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _13;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _14;
        scope 8 {
        }
    }
    scope 9 {
        debug residual => _19;
        scope 10 {
        }
    }
    scope 11 {
        debug val => _20;
        scope 12 {
        }
    }
    scope 13 {
        debug residual => _24;
        scope 14 {
        }
    }
    scope 15 {
        debug val => _25;
        scope 16 {
        }
    }
    scope 17 {
        debug residual => _29;
        scope 18 {
        }
    }
    scope 19 {
        debug val => _30;
        scope 20 {
        }
    }
    scope 21 {
        debug residual => _35;
        scope 22 {
        }
    }
    scope 23 {
        debug val => _36;
        scope 24 {
        }
    }
    scope 25 {
        debug residual => _40;
        scope 26 {
        }
    }
    scope 27 {
        debug val => _41;
        scope 28 {
        }
    }

    bb0: {
        _5 = const {alloc14: &Arg};
        _4 = MatchedFlags::<'_>::has(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<bool, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: bool);
        _11 = const {alloc15: &Arg};
        _10 = MatchedFlags::<'_>::has(_1, _11) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb31, unwind continue];
    }

    bb6: {
        _9 = <Result<bool, OptionsError> as Try>::branch(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _14 = ((_9 as Continue).0: bool);
        _17 = const {alloc16: &Arg};
        _16 = MatchedFlags::<'_>::has(_1, _17) -> [return: bb10, unwind continue];
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _13) -> [return: bb31, unwind continue];
    }

    bb10: {
        _15 = <Result<bool, OptionsError> as Try>::branch(move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        _18 = discriminant(_15);
        switchInt(move _18) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _20 = ((_15 as Continue).0: bool);
        _22 = options::filter::<impl SortField>::deduce(_1) -> [return: bb14, unwind continue];
    }

    bb13: {
        _19 = move ((_15 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _19) -> [return: bb31, unwind continue];
    }

    bb14: {
        _21 = <Result<SortField, OptionsError> as Try>::branch(move _22) -> [return: bb15, unwind continue];
    }

    bb15: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb16, 1: bb17, otherwise: bb4];
    }

    bb16: {
        _25 = ((_21 as Continue).0: fs::filter::SortField);
        _27 = options::filter::<impl DotFilter>::deduce(_1) -> [return: bb18, unwind continue];
    }

    bb17: {
        _24 = move ((_21 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _24) -> [return: bb31, unwind continue];
    }

    bb18: {
        _26 = <Result<DotFilter, OptionsError> as Try>::branch(move _27) -> [return: bb19, unwind continue];
    }

    bb19: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb20, 1: bb21, otherwise: bb4];
    }

    bb20: {
        _30 = ((_26 as Continue).0: fs::dir::DotFilter);
        _33 = options::filter::<impl IgnorePatterns>::deduce(_1) -> [return: bb22, unwind continue];
    }

    bb21: {
        _29 = move ((_26 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _29) -> [return: bb31, unwind continue];
    }

    bb22: {
        _32 = <Result<IgnorePatterns, OptionsError> as Try>::branch(move _33) -> [return: bb23, unwind continue];
    }

    bb23: {
        _34 = discriminant(_32);
        switchInt(move _34) -> [0: bb24, 1: bb25, otherwise: bb4];
    }

    bb24: {
        _36 = move ((_32 as Continue).0: fs::filter::IgnorePatterns);
        _31 = move _36;
        _38 = options::filter::<impl GitIgnore>::deduce(_1) -> [return: bb26, unwind: bb33];
    }

    bb25: {
        _35 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _35) -> [return: bb31, unwind continue];
    }

    bb26: {
        _37 = <Result<GitIgnore, OptionsError> as Try>::branch(move _38) -> [return: bb27, unwind: bb33];
    }

    bb27: {
        _39 = discriminant(_37);
        switchInt(move _39) -> [0: bb28, 1: bb29, otherwise: bb4];
    }

    bb28: {
        _41 = ((_37 as Continue).0: fs::filter::GitIgnore);
        _2 = FileFilter { list_dirs_first: _8, sort_field: _25, reverse: _14, only_dirs: _20, dot_filter: _30, ignore_patterns: move _31, git_ignore: _41 };
        _0 = Result::<FileFilter, OptionsError>::Ok(move _2);
        goto -> bb31;
    }

    bb29: {
        _40 = move ((_37 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<FileFilter, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _40) -> [return: bb30, unwind: bb32];
    }

    bb30: {
        drop(_31) -> [return: bb31, unwind continue];
    }

    bb31: {
        return;
    }

    bb32 (cleanup): {
        drop(_31) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_31) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        resume;
    }
}

alloc16 (static: ONLY_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4233<imm>  
    0x20  09 00 00 00 00 00 00 00 01 44 __ __ __ __ __ __  .........D
}

alloc4233 (size: 9, align: 1) {
    6f 6e 6c 79 2d 64 69 72 73                       only-dirs
}

alloc15 (static: REVERSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4191<imm>  
    0x20  07 00 00 00 00 00 00 00 01 72 __ __ __ __ __ __  .........r
}

alloc4191 (size: 7, align: 1) {
    72 65 76 65 72 73 65                             reverse
}

alloc14 (static: DIRS_FIRST, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4228<imm>  
    0x20  17 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4228 (size: 23, align: 1) {
    0x00  67 72 6f 75 70 2d 64 69 72 65 63 74 6f 72 69 65  group-directorie
    0x10  73 2d 66 69 72 73 74                             s-first
}

fn options::filter::<impl at src/options/filter.rs:26:1: 26:15>::deduce(_1: &MatchedFlags<'_>) -> Result<SortField, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<fs::filter::SortField, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _3: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: std::option::Option<&std::ffi::OsStr>;
    let mut _8: isize;
    let _9: &std::ffi::OsStr;
    let mut _10: fs::filter::SortField;
    let mut _11: std::option::Option<&str>;
    let mut _12: isize;
    let mut _14: options::error::OptionsError;
    let _15: &options::parser::Arg;
    let mut _16: std::ffi::OsString;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: fs::filter::SortCase;
    let mut _51: fs::filter::SortCase;
    let mut _52: fs::filter::SortCase;
    let mut _53: fs::filter::SortCase;
    let mut _54: fs::filter::SortCase;
    let mut _55: fs::filter::SortCase;
    let mut _56: options::error::OptionsError;
    let _57: &options::parser::Arg;
    let mut _58: std::ffi::OsString;
    let mut _59: fs::filter::SortField;
    scope 1 {
        debug word => _9;
        let _13: &str;
        scope 7 {
            debug word => _13;
            let _17: fs::filter::SortField;
            scope 9 {
                debug field => _17;
            }
        }
        scope 8 {
            debug w => _13;
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }
    scope 6 {
        debug w => _9;
    }

    bb0: {
        _4 = const {alloc17: &Arg};
        _3 = MatchedFlags::<'_>::get(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb6, 1: bb7, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<SortField, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb94, unwind continue];
    }

    bb6: {
        _10 = <SortField as Default>::default() -> [return: bb8, unwind continue];
    }

    bb7: {
        _9 = ((_7 as Some).0: &std::ffi::OsStr);
        _11 = OsStr::to_str(_9) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = Result::<SortField, OptionsError>::Ok(move _10);
        goto -> bb94;
    }

    bb9: {
        _12 = discriminant(_11);
        switchInt(move _12) -> [0: bb10, 1: bb11, otherwise: bb4];
    }

    bb10: {
        _15 = const {alloc17: &Arg};
        _16 = <&OsStr as Into<OsString>>::into(_9) -> [return: bb12, unwind continue];
    }

    bb11: {
        _13 = ((_11 as Some).0: &str);
        _49 = <str as PartialEq>::eq(_13, const "name") -> [return: bb79, unwind continue];
    }

    bb12: {
        _14 = OptionsError::BadArgument(_15, move _16);
        _0 = Result::<SortField, OptionsError>::Err(move _14);
        goto -> bb94;
    }

    bb13: {
        _48 = <str as PartialEq>::eq(_13, const "filename") -> [return: bb78, unwind continue];
    }

    bb14: {
        _47 = <str as PartialEq>::eq(_13, const "Name") -> [return: bb77, unwind continue];
    }

    bb15: {
        _46 = <str as PartialEq>::eq(_13, const "Filename") -> [return: bb76, unwind continue];
    }

    bb16: {
        _45 = <str as PartialEq>::eq(_13, const ".name") -> [return: bb75, unwind continue];
    }

    bb17: {
        _44 = <str as PartialEq>::eq(_13, const ".filename") -> [return: bb74, unwind continue];
    }

    bb18: {
        _43 = <str as PartialEq>::eq(_13, const ".Name") -> [return: bb73, unwind continue];
    }

    bb19: {
        _42 = <str as PartialEq>::eq(_13, const ".Filename") -> [return: bb72, unwind continue];
    }

    bb20: {
        _41 = <str as PartialEq>::eq(_13, const "size") -> [return: bb71, unwind continue];
    }

    bb21: {
        _40 = <str as PartialEq>::eq(_13, const "filesize") -> [return: bb70, unwind continue];
    }

    bb22: {
        _39 = <str as PartialEq>::eq(_13, const "ext") -> [return: bb69, unwind continue];
    }

    bb23: {
        _38 = <str as PartialEq>::eq(_13, const "extension") -> [return: bb68, unwind continue];
    }

    bb24: {
        _37 = <str as PartialEq>::eq(_13, const "Ext") -> [return: bb67, unwind continue];
    }

    bb25: {
        _36 = <str as PartialEq>::eq(_13, const "Extension") -> [return: bb66, unwind continue];
    }

    bb26: {
        _35 = <str as PartialEq>::eq(_13, const "date") -> [return: bb65, unwind continue];
    }

    bb27: {
        _34 = <str as PartialEq>::eq(_13, const "time") -> [return: bb64, unwind continue];
    }

    bb28: {
        _33 = <str as PartialEq>::eq(_13, const "mod") -> [return: bb63, unwind continue];
    }

    bb29: {
        _32 = <str as PartialEq>::eq(_13, const "modified") -> [return: bb62, unwind continue];
    }

    bb30: {
        _31 = <str as PartialEq>::eq(_13, const "new") -> [return: bb61, unwind continue];
    }

    bb31: {
        _30 = <str as PartialEq>::eq(_13, const "newest") -> [return: bb60, unwind continue];
    }

    bb32: {
        _29 = <str as PartialEq>::eq(_13, const "age") -> [return: bb59, unwind continue];
    }

    bb33: {
        _28 = <str as PartialEq>::eq(_13, const "old") -> [return: bb58, unwind continue];
    }

    bb34: {
        _27 = <str as PartialEq>::eq(_13, const "oldest") -> [return: bb57, unwind continue];
    }

    bb35: {
        _26 = <str as PartialEq>::eq(_13, const "ch") -> [return: bb56, unwind continue];
    }

    bb36: {
        _25 = <str as PartialEq>::eq(_13, const "changed") -> [return: bb55, unwind continue];
    }

    bb37: {
        _24 = <str as PartialEq>::eq(_13, const "acc") -> [return: bb54, unwind continue];
    }

    bb38: {
        _23 = <str as PartialEq>::eq(_13, const "accessed") -> [return: bb53, unwind continue];
    }

    bb39: {
        _22 = <str as PartialEq>::eq(_13, const "cr") -> [return: bb52, unwind continue];
    }

    bb40: {
        _21 = <str as PartialEq>::eq(_13, const "created") -> [return: bb51, unwind continue];
    }

    bb41: {
        _20 = <str as PartialEq>::eq(_13, const "inode") -> [return: bb50, unwind continue];
    }

    bb42: {
        _17 = SortField::FileInode;
        goto -> bb93;
    }

    bb43: {
        _19 = <str as PartialEq>::eq(_13, const "type") -> [return: bb49, unwind continue];
    }

    bb44: {
        _17 = SortField::FileType;
        goto -> bb93;
    }

    bb45: {
        _18 = <str as PartialEq>::eq(_13, const "none") -> [return: bb48, unwind continue];
    }

    bb46: {
        _17 = SortField::Unsorted;
        goto -> bb93;
    }

    bb47: {
        _57 = const {alloc17: &Arg};
        _58 = <&str as Into<OsString>>::into(_13) -> [return: bb92, unwind continue];
    }

    bb48: {
        switchInt(move _18) -> [0: bb47, otherwise: bb46];
    }

    bb49: {
        switchInt(move _19) -> [0: bb45, otherwise: bb44];
    }

    bb50: {
        switchInt(move _20) -> [0: bb43, otherwise: bb42];
    }

    bb51: {
        switchInt(move _21) -> [0: bb41, otherwise: bb91];
    }

    bb52: {
        switchInt(move _22) -> [0: bb40, otherwise: bb91];
    }

    bb53: {
        switchInt(move _23) -> [0: bb39, otherwise: bb90];
    }

    bb54: {
        switchInt(move _24) -> [0: bb38, otherwise: bb90];
    }

    bb55: {
        switchInt(move _25) -> [0: bb37, otherwise: bb89];
    }

    bb56: {
        switchInt(move _26) -> [0: bb36, otherwise: bb89];
    }

    bb57: {
        switchInt(move _27) -> [0: bb35, otherwise: bb88];
    }

    bb58: {
        switchInt(move _28) -> [0: bb34, otherwise: bb88];
    }

    bb59: {
        switchInt(move _29) -> [0: bb33, otherwise: bb88];
    }

    bb60: {
        switchInt(move _30) -> [0: bb32, otherwise: bb87];
    }

    bb61: {
        switchInt(move _31) -> [0: bb31, otherwise: bb87];
    }

    bb62: {
        switchInt(move _32) -> [0: bb30, otherwise: bb87];
    }

    bb63: {
        switchInt(move _33) -> [0: bb29, otherwise: bb87];
    }

    bb64: {
        switchInt(move _34) -> [0: bb28, otherwise: bb87];
    }

    bb65: {
        switchInt(move _35) -> [0: bb27, otherwise: bb87];
    }

    bb66: {
        switchInt(move _36) -> [0: bb26, otherwise: bb86];
    }

    bb67: {
        switchInt(move _37) -> [0: bb25, otherwise: bb86];
    }

    bb68: {
        switchInt(move _38) -> [0: bb24, otherwise: bb85];
    }

    bb69: {
        switchInt(move _39) -> [0: bb23, otherwise: bb85];
    }

    bb70: {
        switchInt(move _40) -> [0: bb22, otherwise: bb84];
    }

    bb71: {
        switchInt(move _41) -> [0: bb21, otherwise: bb84];
    }

    bb72: {
        switchInt(move _42) -> [0: bb20, otherwise: bb83];
    }

    bb73: {
        switchInt(move _43) -> [0: bb19, otherwise: bb83];
    }

    bb74: {
        switchInt(move _44) -> [0: bb18, otherwise: bb82];
    }

    bb75: {
        switchInt(move _45) -> [0: bb17, otherwise: bb82];
    }

    bb76: {
        switchInt(move _46) -> [0: bb16, otherwise: bb81];
    }

    bb77: {
        switchInt(move _47) -> [0: bb15, otherwise: bb81];
    }

    bb78: {
        switchInt(move _48) -> [0: bb14, otherwise: bb80];
    }

    bb79: {
        switchInt(move _49) -> [0: bb13, otherwise: bb80];
    }

    bb80: {
        _50 = SortCase::AaBbCc;
        _17 = SortField::Name(move _50);
        goto -> bb93;
    }

    bb81: {
        _51 = SortCase::ABCabc;
        _17 = SortField::Name(move _51);
        goto -> bb93;
    }

    bb82: {
        _52 = SortCase::AaBbCc;
        _17 = SortField::NameMixHidden(move _52);
        goto -> bb93;
    }

    bb83: {
        _53 = SortCase::ABCabc;
        _17 = SortField::NameMixHidden(move _53);
        goto -> bb93;
    }

    bb84: {
        _17 = SortField::Size;
        goto -> bb93;
    }

    bb85: {
        _54 = SortCase::AaBbCc;
        _17 = SortField::Extension(move _54);
        goto -> bb93;
    }

    bb86: {
        _55 = SortCase::ABCabc;
        _17 = SortField::Extension(move _55);
        goto -> bb93;
    }

    bb87: {
        _17 = SortField::ModifiedDate;
        goto -> bb93;
    }

    bb88: {
        _17 = SortField::ModifiedAge;
        goto -> bb93;
    }

    bb89: {
        _17 = SortField::ChangedDate;
        goto -> bb93;
    }

    bb90: {
        _17 = SortField::AccessedDate;
        goto -> bb93;
    }

    bb91: {
        _17 = SortField::CreatedDate;
        goto -> bb93;
    }

    bb92: {
        _56 = OptionsError::BadArgument(_57, move _58);
        _0 = Result::<SortField, OptionsError>::Err(move _56);
        goto -> bb94;
    }

    bb93: {
        _59 = _17;
        _0 = Result::<SortField, OptionsError>::Ok(move _59);
        goto -> bb94;
    }

    bb94: {
        return;
    }
}

alloc17 (static: SORT, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4196<imm>  ........
    0x10  0c 00 00 00 00 00 00 00 alloc4212<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 73 __ __ __ __ __ __  .........s
}

alloc4196 (size: 192, align: 8) {
    0x00  alloc4195<imm> 04 00 00 00 00 00 00 00  ........
    0x10  alloc4197<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4198<imm> 04 00 00 00 00 00 00 00  ........
    0x30  alloc4199<imm> 09 00 00 00 00 00 00 00  ........
    0x40  alloc4200<imm> 09 00 00 00 00 00 00 00  ........
    0x50  alloc4201<imm> 08 00 00 00 00 00 00 00  ........
    0x60  alloc4202<imm> 07 00 00 00 00 00 00 00  ........
    0x70  alloc4203<imm> 08 00 00 00 00 00 00 00  ........
    0x80  alloc4204<imm> 07 00 00 00 00 00 00 00  ........
    0x90  alloc4205<imm> 05 00 00 00 00 00 00 00  ........
    0xa0  alloc4206<imm> 04 00 00 00 00 00 00 00  ........
    0xb0  alloc4207<imm> 04 00 00 00 00 00 00 00  ........
}

alloc4195 (size: 4, align: 1) {
    6e 61 6d 65                                      name
}

alloc4197 (size: 4, align: 1) {
    4e 61 6d 65                                      Name
}

alloc4198 (size: 4, align: 1) {
    73 69 7a 65                                      size
}

alloc4199 (size: 9, align: 1) {
    65 78 74 65 6e 73 69 6f 6e                       extension
}

alloc4200 (size: 9, align: 1) {
    45 78 74 65 6e 73 69 6f 6e                       Extension
}

alloc4201 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4202 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4203 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4204 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4205 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc4206 (size: 4, align: 1) {
    74 79 70 65                                      type
}

alloc4207 (size: 4, align: 1) {
    6e 6f 6e 65                                      none
}

alloc4212 (size: 4, align: 1) {
    73 6f 72 74                                      sort
}

fn options::filter::<impl at src/options/filter.rs:141:1: 141:27>::default() -> SortField {
    let mut _0: fs::filter::SortField;
    let mut _1: fs::filter::SortCase;

    bb0: {
        _1 = SortCase::AaBbCc;
        _0 = SortField::Name(move _1);
        return;
    }
}

fn options::filter::<impl at src/options/filter.rs:148:1: 148:15>::deduce(_1: &MatchedFlags<'_>) -> Result<DotFilter, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<fs::dir::DotFilter, options::error::OptionsError>;
    let _2: usize;
    let _3: &options::parser::Arg;
    let mut _4: fs::dir::DotFilter;
    let mut _5: fs::dir::DotFilter;
    let mut _6: bool;
    let mut _7: usize;
    let _8: &options::parser::Arg;
    let mut _9: options::error::OptionsError;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: options::error::OptionsError;
    let _13: &options::parser::Arg;
    let _14: &options::parser::Arg;
    let mut _15: fs::dir::DotFilter;
    scope 1 {
        debug count => _2;
    }

    bb0: {
        _3 = const {alloc18: &Arg};
        _2 = MatchedFlags::<'_>::count(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = DotFilter::JustFiles;
        _0 = Result::<DotFilter, OptionsError>::Ok(move _4);
        goto -> bb13;
    }

    bb3: {
        switchInt(move _2) -> [1: bb4, otherwise: bb5];
    }

    bb4: {
        _5 = DotFilter::Dotfiles;
        _0 = Result::<DotFilter, OptionsError>::Ok(move _5);
        goto -> bb13;
    }

    bb5: {
        _8 = const {alloc8: &Arg};
        _7 = MatchedFlags::<'_>::count(_1, _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = Gt(move _7, const 0_usize);
        switchInt(move _6) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _9 = OptionsError::TreeAllAll;
        _0 = Result::<DotFilter, OptionsError>::Err(move _9);
        goto -> bb13;
    }

    bb8: {
        _10 = Ge(_2, const 3_usize);
        switchInt(move _10) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _11 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _11) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _13 = const {alloc18: &Arg};
        _14 = const {alloc18: &Arg};
        _12 = OptionsError::Conflict(_13, _14);
        _0 = Result::<DotFilter, OptionsError>::Err(move _12);
        goto -> bb13;
    }

    bb12: {
        _15 = DotFilter::DotfilesAndDots;
        _0 = Result::<DotFilter, OptionsError>::Ok(move _15);
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

alloc18 (static: ALL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4175<imm>  
    0x20  03 00 00 00 00 00 00 00 01 61 __ __ __ __ __ __  .........a
}

alloc4175 (size: 3, align: 1) {
    61 6c 6c                                         all
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

fn options::filter::<impl at src/options/filter.rs:178:1: 178:20>::deduce(_1: &MatchedFlags<'_>) -> Result<IgnorePatterns, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<fs::filter::IgnorePatterns, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _3: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: std::option::Option<&std::ffi::OsStr>;
    let mut _8: isize;
    let _9: &std::ffi::OsStr;
    let mut _10: fs::filter::IgnorePatterns;
    let mut _13: (fs::filter::IgnorePatterns, std::vec::Vec<glob::PatternError>);
    let mut _14: std::str::Split<'_, char>;
    let _15: &str;
    let mut _16: &std::borrow::Cow<'_, str>;
    let _17: std::borrow::Cow<'_, str>;
    let mut _18: std::option::Option<glob::PatternError>;
    let mut _19: &mut std::vec::Vec<glob::PatternError>;
    let mut _20: isize;
    let mut _22: options::error::OptionsError;
    let mut _23: fs::filter::IgnorePatterns;
    let mut _24: bool;
    scope 1 {
        debug inputs => _9;
        let _11: fs::filter::IgnorePatterns;
        let mut _12: std::vec::Vec<glob::PatternError>;
        scope 7 {
            debug patterns => _11;
            debug errors => _12;
            let _21: glob::PatternError;
            scope 8 {
                debug e => _21;
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }
    scope 6 {
        debug is => _9;
    }

    bb0: {
        _24 = const false;
        _4 = const {alloc19: &Arg};
        _3 = MatchedFlags::<'_>::get(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb6, 1: bb7, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<IgnorePatterns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb21, unwind continue];
    }

    bb6: {
        _10 = IgnorePatterns::empty() -> [return: bb8, unwind continue];
    }

    bb7: {
        _9 = ((_7 as Some).0: &std::ffi::OsStr);
        _17 = OsStr::to_string_lossy(_9) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = Result::<IgnorePatterns, OptionsError>::Ok(move _10);
        goto -> bb21;
    }

    bb9: {
        _16 = &_17;
        _15 = <Cow<'_, str> as Deref>::deref(move _16) -> [return: bb10, unwind: bb23];
    }

    bb10: {
        _14 = core::str::<impl str>::split::<'_, char>(_15, const '|') -> [return: bb11, unwind: bb23];
    }

    bb11: {
        _13 = IgnorePatterns::parse_from_iter::<'_, std::str::Split<'_, char>>(move _14) -> [return: bb12, unwind: bb23];
    }

    bb12: {
        _24 = const true;
        _11 = move (_13.0: fs::filter::IgnorePatterns);
        _12 = move (_13.1: std::vec::Vec<glob::PatternError>);
        drop(_17) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _19 = &mut _12;
        _18 = Vec::<PatternError>::pop(move _19) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb15, 1: bb16, otherwise: bb4];
    }

    bb15: {
        _24 = const false;
        _23 = move _11;
        _0 = Result::<IgnorePatterns, OptionsError>::Ok(move _23);
        goto -> bb18;
    }

    bb16: {
        _21 = move ((_18 as Some).0: glob::PatternError);
        _22 = <PatternError as Into<OptionsError>>::into(move _21) -> [return: bb17, unwind: bb22];
    }

    bb17: {
        _0 = Result::<IgnorePatterns, OptionsError>::Err(move _22);
        goto -> bb18;
    }

    bb18: {
        drop(_12) -> [return: bb19, unwind: bb27];
    }

    bb19: {
        switchInt(_24) -> [0: bb20, otherwise: bb25];
    }

    bb20: {
        _24 = const false;
        goto -> bb21;
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_12) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_17) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        resume;
    }

    bb25: {
        drop(_11) -> [return: bb20, unwind continue];
    }

    bb26 (cleanup): {
        drop(_11) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        switchInt(_24) -> [0: bb24, otherwise: bb26];
    }
}

alloc19 (static: IGNORE_GLOB, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4218<imm>  
    0x20  0b 00 00 00 00 00 00 00 01 49 __ __ __ __ __ __  .........I
}

alloc4218 (size: 11, align: 1) {
    69 67 6e 6f 72 65 2d 67 6c 6f 62                 ignore-glob
}

fn options::filter::<impl at src/options/filter.rs:206:1: 206:15>::deduce(_1: &MatchedFlags<'_>) -> Result<GitIgnore, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<fs::filter::GitIgnore, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _3: std::result::Result<bool, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: bool;
    let mut _8: fs::filter::GitIgnore;
    let mut _9: fs::filter::GitIgnore;
    scope 1 {
        debug residual => _6;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _7;
        scope 4 {
        }
    }

    bb0: {
        _4 = const {alloc20: &Arg};
        _3 = MatchedFlags::<'_>::has(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<bool, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: bool);
        switchInt(_7) -> [0: bb8, otherwise: bb7];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<GitIgnore, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7: {
        _8 = GitIgnore::CheckAndIgnore;
        _0 = Result::<GitIgnore, OptionsError>::Ok(move _8);
        goto -> bb6;
    }

    bb8: {
        _9 = GitIgnore::Off;
        _0 = Result::<GitIgnore, OptionsError>::Ok(move _9);
        goto -> bb6;
    }
}

alloc20 (static: GIT_IGNORE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4223<imm>  
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4223 (size: 10, align: 1) {
    67 69 74 2d 69 67 6e 6f 72 65                    git-ignore
}

static VERSION: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 118_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "version", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static HELP: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 63_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "help", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ONE_LINE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 49_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "oneline", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static LONG: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 108_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "long", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static GRID: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 71_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "grid", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ACROSS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 120_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "across", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static RECURSE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 82_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "recurse", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static TREE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 84_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "tree", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static CLASSIFY: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 70_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "classify", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static COLOR: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;
    let mut _4: &[&str];
    let _5: &[&str];

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = &(*_5);
        _3 = Option::<&[&str]>::Some(move _4);
        StorageDead(_4);
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "color", takes_value: move _2 };
        StorageDead(_5);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static COLOUR: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;
    let mut _4: &[&str];
    let _5: &[&str];

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = &(*_5);
        _3 = Option::<&[&str]>::Some(move _4);
        StorageDead(_4);
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "colour", takes_value: move _2 };
        StorageDead(_5);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

const COLOURS: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 3];
    let _2: &[&str; 3];
    let _3: [&str; 3];
    let mut _4: &[&str; 3];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in COLOURS: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "always", const "auto", const "never"];
        _0 = &_1;
        return;
    }
}

static COLOR_SCALE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "color-scale", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static COLOUR_SCALE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "colour-scale", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ALL: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 97_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "all", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static LIST_DIRS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 100_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "list-dirs", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static LEVEL: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 76_u8);
        StorageLive(_2);
        StorageLive(_3);
        _3 = Option::<&[&str]>::None;
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "level", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static REVERSE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 114_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "reverse", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static SORT: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;
    let mut _4: &[&str];
    let _5: &[&str];

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 115_u8);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = &(*_5);
        _3 = Option::<&[&str]>::Some(move _4);
        StorageDead(_4);
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "sort", takes_value: move _2 };
        StorageDead(_5);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static IGNORE_GLOB: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 73_u8);
        StorageLive(_2);
        StorageLive(_3);
        _3 = Option::<&[&str]>::None;
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "ignore-glob", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static GIT_IGNORE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "git-ignore", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static DIRS_FIRST: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "group-directories-first", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ONLY_DIRS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 68_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "only-dirs", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

const SORTS: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 12];
    let _2: &[&str; 12];
    let _3: [&str; 12];
    let mut _4: &[&str; 12];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in SORTS: &[&str; 12] = {
    let mut _0: &[&str; 12];
    let mut _1: [&str; 12];

    bb0: {
        _1 = [const "name", const "Name", const "size", const "extension", const "Extension", const "modified", const "changed", const "accessed", const "created", const "inode", const "type", const "none"];
        _0 = &_1;
        return;
    }
}

static BINARY: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 98_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "binary", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static BYTES: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 66_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "bytes", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static GROUP: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 103_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "group", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static NUMERIC: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 110_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "numeric", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static HEADER: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 104_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "header", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ICONS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "icons", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static INODE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 105_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "inode", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static LINKS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 72_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "links", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static MODIFIED: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 109_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "modified", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static CHANGED: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "changed", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static BLOCKS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 83_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "blocks", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static TIME: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;
    let mut _4: &[&str];
    let _5: &[&str];

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 116_u8);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = &(*_5);
        _3 = Option::<&[&str]>::Some(move _4);
        StorageDead(_4);
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "time", takes_value: move _2 };
        StorageDead(_5);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ACCESSED: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 117_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "accessed", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static CREATED: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 85_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "created", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static flags::TIME_STYLE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;
    let mut _3: std::option::Option<&[&str]>;
    let mut _4: &[&str];
    let _5: &[&str];

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        StorageLive(_5);
        _5 = const _;
        _4 = &(*_5);
        _3 = Option::<&[&str]>::Some(move _4);
        StorageDead(_4);
        _2 = TakesValue::Necessary(move _3);
        StorageDead(_3);
        _0 = Arg { short: move _1, long: const "time-style", takes_value: move _2 };
        StorageDead(_5);
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

const TIMES: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 4];
    let _2: &[&str; 4];
    let _3: [&str; 4];
    let mut _4: &[&str; 4];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in TIMES: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "modified", const "changed", const "accessed", const "created"];
        _0 = &_1;
        return;
    }
}

const TIME_STYLES: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 4];
    let _2: &[&str; 4];
    let _3: [&str; 4];
    let mut _4: &[&str; 4];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in TIME_STYLES: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "default", const "long-iso", const "full-iso", const "iso"];
        _0 = &_1;
        return;
    }
}

static NO_PERMISSIONS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "no-permissions", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static NO_FILESIZE: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "no-filesize", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static NO_USER: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "no-user", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static NO_TIME: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "no-time", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static NO_ICONS: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "no-icons", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static GIT: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "git", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static EXTENDED: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::Some(const 64_u8);
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "extended", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static OCTAL: Arg = {
    let mut _0: options::parser::Arg;
    let mut _1: std::option::Option<u8>;
    let mut _2: options::parser::TakesValue;

    bb0: {
        StorageLive(_1);
        _1 = Option::<u8>::None;
        StorageLive(_2);
        _2 = TakesValue::Forbidden;
        _0 = Arg { short: move _1, long: const "octal-permissions", takes_value: move _2 };
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

static ALL_ARGS: options::parser::Args = {
    let mut _0: options::parser::Args;
    let mut _1: &[&options::parser::Arg];
    let mut _2: &[&options::parser::Arg; 45];
    let _3: &[&options::parser::Arg; 45];
    let _4: [&options::parser::Arg; 45];
    let mut _5: &options::parser::Arg;
    let _6: &options::parser::Arg;
    let _7: &options::parser::Arg;
    let mut _8: &options::parser::Arg;
    let _9: &options::parser::Arg;
    let mut _10: &options::parser::Arg;
    let _11: &options::parser::Arg;
    let _12: &options::parser::Arg;
    let mut _13: &options::parser::Arg;
    let _14: &options::parser::Arg;
    let _15: &options::parser::Arg;
    let mut _16: &options::parser::Arg;
    let _17: &options::parser::Arg;
    let _18: &options::parser::Arg;
    let mut _19: &options::parser::Arg;
    let _20: &options::parser::Arg;
    let _21: &options::parser::Arg;
    let mut _22: &options::parser::Arg;
    let _23: &options::parser::Arg;
    let _24: &options::parser::Arg;
    let mut _25: &options::parser::Arg;
    let _26: &options::parser::Arg;
    let _27: &options::parser::Arg;
    let mut _28: &options::parser::Arg;
    let _29: &options::parser::Arg;
    let _30: &options::parser::Arg;
    let mut _31: &options::parser::Arg;
    let _32: &options::parser::Arg;
    let _33: &options::parser::Arg;
    let mut _34: &options::parser::Arg;
    let _35: &options::parser::Arg;
    let _36: &options::parser::Arg;
    let mut _37: &options::parser::Arg;
    let _38: &options::parser::Arg;
    let _39: &options::parser::Arg;
    let mut _40: &options::parser::Arg;
    let _41: &options::parser::Arg;
    let _42: &options::parser::Arg;
    let mut _43: &options::parser::Arg;
    let _44: &options::parser::Arg;
    let _45: &options::parser::Arg;
    let mut _46: &options::parser::Arg;
    let _47: &options::parser::Arg;
    let _48: &options::parser::Arg;
    let mut _49: &options::parser::Arg;
    let _50: &options::parser::Arg;
    let _51: &options::parser::Arg;
    let mut _52: &options::parser::Arg;
    let _53: &options::parser::Arg;
    let _54: &options::parser::Arg;
    let mut _55: &options::parser::Arg;
    let _56: &options::parser::Arg;
    let _57: &options::parser::Arg;
    let mut _58: &options::parser::Arg;
    let _59: &options::parser::Arg;
    let _60: &options::parser::Arg;
    let mut _61: &options::parser::Arg;
    let _62: &options::parser::Arg;
    let _63: &options::parser::Arg;
    let mut _64: &options::parser::Arg;
    let _65: &options::parser::Arg;
    let _66: &options::parser::Arg;
    let mut _67: &options::parser::Arg;
    let _68: &options::parser::Arg;
    let _69: &options::parser::Arg;
    let mut _70: &options::parser::Arg;
    let _71: &options::parser::Arg;
    let _72: &options::parser::Arg;
    let mut _73: &options::parser::Arg;
    let _74: &options::parser::Arg;
    let _75: &options::parser::Arg;
    let mut _76: &options::parser::Arg;
    let _77: &options::parser::Arg;
    let _78: &options::parser::Arg;
    let mut _79: &options::parser::Arg;
    let _80: &options::parser::Arg;
    let _81: &options::parser::Arg;
    let mut _82: &options::parser::Arg;
    let _83: &options::parser::Arg;
    let _84: &options::parser::Arg;
    let mut _85: &options::parser::Arg;
    let _86: &options::parser::Arg;
    let _87: &options::parser::Arg;
    let mut _88: &options::parser::Arg;
    let _89: &options::parser::Arg;
    let _90: &options::parser::Arg;
    let mut _91: &options::parser::Arg;
    let _92: &options::parser::Arg;
    let _93: &options::parser::Arg;
    let mut _94: &options::parser::Arg;
    let _95: &options::parser::Arg;
    let _96: &options::parser::Arg;
    let mut _97: &options::parser::Arg;
    let _98: &options::parser::Arg;
    let _99: &options::parser::Arg;
    let mut _100: &options::parser::Arg;
    let _101: &options::parser::Arg;
    let _102: &options::parser::Arg;
    let mut _103: &options::parser::Arg;
    let _104: &options::parser::Arg;
    let _105: &options::parser::Arg;
    let mut _106: &options::parser::Arg;
    let _107: &options::parser::Arg;
    let _108: &options::parser::Arg;
    let mut _109: &options::parser::Arg;
    let _110: &options::parser::Arg;
    let _111: &options::parser::Arg;
    let mut _112: &options::parser::Arg;
    let _113: &options::parser::Arg;
    let _114: &options::parser::Arg;
    let mut _115: &options::parser::Arg;
    let _116: &options::parser::Arg;
    let _117: &options::parser::Arg;
    let mut _118: &options::parser::Arg;
    let _119: &options::parser::Arg;
    let _120: &options::parser::Arg;
    let mut _121: &options::parser::Arg;
    let _122: &options::parser::Arg;
    let _123: &options::parser::Arg;
    let mut _124: &options::parser::Arg;
    let _125: &options::parser::Arg;
    let _126: &options::parser::Arg;
    let mut _127: &options::parser::Arg;
    let _128: &options::parser::Arg;
    let _129: &options::parser::Arg;
    let mut _130: &options::parser::Arg;
    let _131: &options::parser::Arg;
    let _132: &options::parser::Arg;
    let mut _133: &options::parser::Arg;
    let _134: &options::parser::Arg;
    let _135: &options::parser::Arg;
    let mut _136: &options::parser::Arg;
    let _137: &options::parser::Arg;
    let _138: &options::parser::Arg;
    let mut _139: &[&options::parser::Arg; 45];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        _139 = const _;
        _3 = &(*_139);
        _2 = &(*_3);
        _1 = move _2 as &[&options::parser::Arg] (PointerCoercion(Unsize));
        StorageDead(_2);
        _0 = options::parser::Args(move _1);
        StorageDead(_3);
        StorageDead(_1);
        return;
    }
}

promoted[0] in ALL_ARGS: &[&Arg; 45] = {
    let mut _0: &[&options::parser::Arg; 45];
    let mut _1: [&options::parser::Arg; 45];
    let mut _2: &options::parser::Arg;
    let mut _3: &options::parser::Arg;
    let mut _4: &options::parser::Arg;
    let mut _5: &options::parser::Arg;
    let mut _6: &options::parser::Arg;
    let mut _7: &options::parser::Arg;
    let mut _8: &options::parser::Arg;
    let mut _9: &options::parser::Arg;
    let mut _10: &options::parser::Arg;
    let mut _11: &options::parser::Arg;
    let mut _12: &options::parser::Arg;
    let mut _13: &options::parser::Arg;
    let mut _14: &options::parser::Arg;
    let mut _15: &options::parser::Arg;
    let mut _16: &options::parser::Arg;
    let mut _17: &options::parser::Arg;
    let mut _18: &options::parser::Arg;
    let mut _19: &options::parser::Arg;
    let mut _20: &options::parser::Arg;
    let mut _21: &options::parser::Arg;
    let mut _22: &options::parser::Arg;
    let mut _23: &options::parser::Arg;
    let mut _24: &options::parser::Arg;
    let mut _25: &options::parser::Arg;
    let mut _26: &options::parser::Arg;
    let mut _27: &options::parser::Arg;
    let mut _28: &options::parser::Arg;
    let mut _29: &options::parser::Arg;
    let mut _30: &options::parser::Arg;
    let mut _31: &options::parser::Arg;
    let mut _32: &options::parser::Arg;
    let mut _33: &options::parser::Arg;
    let mut _34: &options::parser::Arg;
    let mut _35: &options::parser::Arg;
    let mut _36: &options::parser::Arg;
    let mut _37: &options::parser::Arg;
    let mut _38: &options::parser::Arg;
    let mut _39: &options::parser::Arg;
    let mut _40: &options::parser::Arg;
    let mut _41: &options::parser::Arg;
    let mut _42: &options::parser::Arg;
    let mut _43: &options::parser::Arg;
    let mut _44: &options::parser::Arg;
    let mut _45: &options::parser::Arg;
    let mut _46: &options::parser::Arg;
    let mut _47: &options::parser::Arg;
    let mut _48: &options::parser::Arg;
    let mut _49: &options::parser::Arg;
    let mut _50: &options::parser::Arg;
    let mut _51: &options::parser::Arg;
    let mut _52: &options::parser::Arg;
    let mut _53: &options::parser::Arg;
    let mut _54: &options::parser::Arg;
    let mut _55: &options::parser::Arg;
    let mut _56: &options::parser::Arg;
    let mut _57: &options::parser::Arg;
    let mut _58: &options::parser::Arg;
    let mut _59: &options::parser::Arg;
    let mut _60: &options::parser::Arg;
    let mut _61: &options::parser::Arg;
    let mut _62: &options::parser::Arg;
    let mut _63: &options::parser::Arg;
    let mut _64: &options::parser::Arg;
    let mut _65: &options::parser::Arg;
    let mut _66: &options::parser::Arg;
    let mut _67: &options::parser::Arg;
    let mut _68: &options::parser::Arg;
    let mut _69: &options::parser::Arg;
    let mut _70: &options::parser::Arg;
    let mut _71: &options::parser::Arg;
    let mut _72: &options::parser::Arg;
    let mut _73: &options::parser::Arg;
    let mut _74: &options::parser::Arg;
    let mut _75: &options::parser::Arg;
    let mut _76: &options::parser::Arg;
    let mut _77: &options::parser::Arg;
    let mut _78: &options::parser::Arg;
    let mut _79: &options::parser::Arg;
    let mut _80: &options::parser::Arg;
    let mut _81: &options::parser::Arg;
    let mut _82: &options::parser::Arg;
    let mut _83: &options::parser::Arg;
    let mut _84: &options::parser::Arg;
    let mut _85: &options::parser::Arg;
    let mut _86: &options::parser::Arg;
    let mut _87: &options::parser::Arg;
    let mut _88: &options::parser::Arg;
    let mut _89: &options::parser::Arg;
    let mut _90: &options::parser::Arg;
    let mut _91: &options::parser::Arg;
    let mut _92: &options::parser::Arg;
    let mut _93: &options::parser::Arg;
    let mut _94: &options::parser::Arg;
    let mut _95: &options::parser::Arg;
    let mut _96: &options::parser::Arg;
    let mut _97: &options::parser::Arg;
    let mut _98: &options::parser::Arg;
    let mut _99: &options::parser::Arg;
    let mut _100: &options::parser::Arg;
    let mut _101: &options::parser::Arg;
    let mut _102: &options::parser::Arg;
    let mut _103: &options::parser::Arg;
    let mut _104: &options::parser::Arg;
    let mut _105: &options::parser::Arg;
    let mut _106: &options::parser::Arg;
    let mut _107: &options::parser::Arg;
    let mut _108: &options::parser::Arg;
    let mut _109: &options::parser::Arg;
    let mut _110: &options::parser::Arg;
    let mut _111: &options::parser::Arg;
    let mut _112: &options::parser::Arg;
    let mut _113: &options::parser::Arg;
    let mut _114: &options::parser::Arg;
    let mut _115: &options::parser::Arg;
    let mut _116: &options::parser::Arg;
    let mut _117: &options::parser::Arg;
    let mut _118: &options::parser::Arg;
    let mut _119: &options::parser::Arg;
    let mut _120: &options::parser::Arg;
    let mut _121: &options::parser::Arg;
    let mut _122: &options::parser::Arg;
    let mut _123: &options::parser::Arg;
    let mut _124: &options::parser::Arg;
    let mut _125: &options::parser::Arg;
    let mut _126: &options::parser::Arg;
    let mut _127: &options::parser::Arg;
    let mut _128: &options::parser::Arg;
    let mut _129: &options::parser::Arg;
    let mut _130: &options::parser::Arg;
    let mut _131: &options::parser::Arg;
    let mut _132: &options::parser::Arg;
    let mut _133: &options::parser::Arg;
    let mut _134: &options::parser::Arg;
    let mut _135: &options::parser::Arg;

    bb0: {
        _4 = const {alloc21: &Arg};
        _3 = &(*_4);
        _2 = &(*_3);
        _6 = const {alloc22: &Arg};
        _5 = &(*_6);
        _9 = const {alloc23: &Arg};
        _8 = &(*_9);
        _7 = &(*_8);
        _12 = const {alloc24: &Arg};
        _11 = &(*_12);
        _10 = &(*_11);
        _15 = const {alloc25: &Arg};
        _14 = &(*_15);
        _13 = &(*_14);
        _18 = const {alloc26: &Arg};
        _17 = &(*_18);
        _16 = &(*_17);
        _21 = const {alloc6: &Arg};
        _20 = &(*_21);
        _19 = &(*_20);
        _24 = const {alloc8: &Arg};
        _23 = &(*_24);
        _22 = &(*_23);
        _27 = const {alloc10: &Arg};
        _26 = &(*_27);
        _25 = &(*_26);
        _30 = const {alloc27: &Arg};
        _29 = &(*_30);
        _28 = &(*_29);
        _33 = const {alloc28: &Arg};
        _32 = &(*_33);
        _31 = &(*_32);
        _36 = const {alloc29: &Arg};
        _35 = &(*_36);
        _34 = &(*_35);
        _39 = const {alloc30: &Arg};
        _38 = &(*_39);
        _37 = &(*_38);
        _42 = const {alloc18: &Arg};
        _41 = &(*_42);
        _40 = &(*_41);
        _45 = const {alloc7: &Arg};
        _44 = &(*_45);
        _43 = &(*_44);
        _48 = const {alloc9: &Arg};
        _47 = &(*_48);
        _46 = &(*_47);
        _51 = const {alloc15: &Arg};
        _50 = &(*_51);
        _49 = &(*_50);
        _54 = const {alloc17: &Arg};
        _53 = &(*_54);
        _52 = &(*_53);
        _57 = const {alloc14: &Arg};
        _56 = &(*_57);
        _55 = &(*_56);
        _60 = const {alloc19: &Arg};
        _59 = &(*_60);
        _58 = &(*_59);
        _63 = const {alloc20: &Arg};
        _62 = &(*_63);
        _61 = &(*_62);
        _66 = const {alloc16: &Arg};
        _65 = &(*_66);
        _64 = &(*_65);
        _69 = const {alloc31: &Arg};
        _68 = &(*_69);
        _67 = &(*_68);
        _72 = const {alloc32: &Arg};
        _71 = &(*_72);
        _70 = &(*_71);
        _75 = const {alloc33: &Arg};
        _74 = &(*_75);
        _73 = &(*_74);
        _78 = const {alloc34: &Arg};
        _77 = &(*_78);
        _76 = &(*_77);
        _81 = const {alloc35: &Arg};
        _80 = &(*_81);
        _79 = &(*_80);
        _84 = const {alloc12: &Arg};
        _83 = &(*_84);
        _82 = &(*_83);
        _87 = const {alloc36: &Arg};
        _86 = &(*_87);
        _85 = &(*_86);
        _90 = const {alloc37: &Arg};
        _89 = &(*_90);
        _88 = &(*_89);
        _93 = const {alloc38: &Arg};
        _92 = &(*_93);
        _91 = &(*_92);
        _96 = const {alloc39: &Arg};
        _95 = &(*_96);
        _94 = &(*_95);
        _99 = const {alloc40: &Arg};
        _98 = &(*_99);
        _97 = &(*_98);
        _102 = const {alloc41: &Arg};
        _101 = &(*_102);
        _100 = &(*_101);
        _105 = const {alloc42: &Arg};
        _104 = &(*_105);
        _103 = &(*_104);
        _108 = const {alloc43: &Arg};
        _107 = &(*_108);
        _106 = &(*_107);
        _111 = const {alloc44: &Arg};
        _110 = &(*_111);
        _109 = &(*_110);
        _114 = const {alloc45: &Arg};
        _113 = &(*_114);
        _112 = &(*_113);
        _117 = const {alloc46: &Arg};
        _116 = &(*_117);
        _115 = &(*_116);
        _120 = const {alloc47: &Arg};
        _119 = &(*_120);
        _118 = &(*_119);
        _123 = const {alloc48: &Arg};
        _122 = &(*_123);
        _121 = &(*_122);
        _126 = const {alloc11: &Arg};
        _125 = &(*_126);
        _124 = &(*_125);
        _129 = const {alloc49: &Arg};
        _128 = &(*_129);
        _127 = &(*_128);
        _132 = const {alloc50: &Arg};
        _131 = &(*_132);
        _130 = &(*_131);
        _135 = const {alloc51: &Arg};
        _134 = &(*_135);
        _133 = &(*_134);
        _1 = [move _2, move _5, move _7, move _10, move _13, move _16, move _19, move _22, move _25, move _28, move _31, move _34, move _37, move _40, move _43, move _46, move _49, move _52, move _55, move _58, move _61, move _64, move _67, move _70, move _73, move _76, move _79, move _82, move _85, move _88, move _91, move _94, move _97, move _100, move _103, move _106, move _109, move _112, move _115, move _118, move _121, move _124, move _127, move _130, move _133];
        _0 = &_1;
        return;
    }
}

alloc51 (static: OCTAL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4364<imm>  
    0x20  11 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4364 (size: 17, align: 1) {
    0x00  6f 63 74 61 6c 2d 70 65 72 6d 69 73 73 69 6f 6e  octal-permission
    0x10  73                                               s
}

alloc50 (static: EXTENDED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4359<imm>  
    0x20  08 00 00 00 00 00 00 00 01 40 __ __ __ __ __ __  .........@
}

alloc4359 (size: 8, align: 1) {
    65 78 74 65 6e 64 65 64                          extended
}

alloc49 (static: GIT, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4354<imm>  
    0x20  03 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4354 (size: 3, align: 1) {
    67 69 74                                         git
}

alloc48 (static: NO_TIME, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4344<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4344 (size: 7, align: 1) {
    6e 6f 2d 74 69 6d 65                             no-time
}

alloc47 (static: NO_USER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4339<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4339 (size: 7, align: 1) {
    6e 6f 2d 75 73 65 72                             no-user
}

alloc46 (static: NO_FILESIZE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4334<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4334 (size: 11, align: 1) {
    6e 6f 2d 66 69 6c 65 73 69 7a 65                 no-filesize
}

alloc45 (static: NO_PERMISSIONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4329<imm>  
    0x20  0e 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4329 (size: 14, align: 1) {
    6e 6f 2d 70 65 72 6d 69 73 73 69 6f 6e 73        no-permissions
}

alloc44 (static: flags::TIME_STYLE, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4316<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4324<imm>  ........
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4316 (size: 64, align: 8) {
    0x00  alloc4315<imm> 07 00 00 00 00 00 00 00  ........
    0x10  alloc4317<imm> 08 00 00 00 00 00 00 00  ........
    0x20  alloc4318<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4319<imm> 03 00 00 00 00 00 00 00  ........
}

alloc4315 (size: 7, align: 1) {
    64 65 66 61 75 6c 74                             default
}

alloc4317 (size: 8, align: 1) {
    6c 6f 6e 67 2d 69 73 6f                          long-iso
}

alloc4318 (size: 8, align: 1) {
    66 75 6c 6c 2d 69 73 6f                          full-iso
}

alloc4319 (size: 3, align: 1) {
    69 73 6f                                         iso
}

alloc4324 (size: 10, align: 1) {
    74 69 6d 65 2d 73 74 79 6c 65                    time-style
}

alloc43 (static: CREATED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4311<imm>  
    0x20  07 00 00 00 00 00 00 00 01 55 __ __ __ __ __ __  .........U
}

alloc4311 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc42 (static: ACCESSED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4306<imm>  
    0x20  08 00 00 00 00 00 00 00 01 75 __ __ __ __ __ __  .........u
}

alloc4306 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc41 (static: TIME, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4293<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4301<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 74 __ __ __ __ __ __  .........t
}

alloc4293 (size: 64, align: 8) {
    0x00  alloc4292<imm> 08 00 00 00 00 00 00 00  ........
    0x10  alloc4294<imm> 07 00 00 00 00 00 00 00  ........
    0x20  alloc4295<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4296<imm> 07 00 00 00 00 00 00 00  ........
}

alloc4292 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4294 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4295 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4296 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4301 (size: 4, align: 1) {
    74 69 6d 65                                      time
}

alloc40 (static: BLOCKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4288<imm>  
    0x20  06 00 00 00 00 00 00 00 01 53 __ __ __ __ __ __  .........S
}

alloc4288 (size: 6, align: 1) {
    62 6c 6f 63 6b 73                                blocks
}

alloc39 (static: CHANGED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4283<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4283 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc38 (static: MODIFIED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4278<imm>  
    0x20  08 00 00 00 00 00 00 00 01 6d __ __ __ __ __ __  .........m
}

alloc4278 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc37 (static: LINKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4273<imm>  
    0x20  05 00 00 00 00 00 00 00 01 48 __ __ __ __ __ __  .........H
}

alloc4273 (size: 5, align: 1) {
    6c 69 6e 6b 73                                   links
}

alloc36 (static: INODE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4268<imm>  
    0x20  05 00 00 00 00 00 00 00 01 69 __ __ __ __ __ __  .........i
}

alloc4268 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc35 (static: HEADER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4258<imm>  
    0x20  06 00 00 00 00 00 00 00 01 68 __ __ __ __ __ __  .........h
}

alloc4258 (size: 6, align: 1) {
    68 65 61 64 65 72                                header
}

alloc34 (static: NUMERIC, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4253<imm>  
    0x20  07 00 00 00 00 00 00 00 01 6e __ __ __ __ __ __  .........n
}

alloc4253 (size: 7, align: 1) {
    6e 75 6d 65 72 69 63                             numeric
}

alloc33 (static: GROUP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4248<imm>  
    0x20  05 00 00 00 00 00 00 00 01 67 __ __ __ __ __ __  .........g
}

alloc4248 (size: 5, align: 1) {
    67 72 6f 75 70                                   group
}

alloc32 (static: BYTES, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4243<imm>  
    0x20  05 00 00 00 00 00 00 00 01 42 __ __ __ __ __ __  .........B
}

alloc4243 (size: 5, align: 1) {
    62 79 74 65 73                                   bytes
}

alloc31 (static: BINARY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4238<imm>  
    0x20  06 00 00 00 00 00 00 00 01 62 __ __ __ __ __ __  .........b
}

alloc4238 (size: 6, align: 1) {
    62 69 6e 61 72 79                                binary
}

alloc30 (static: COLOUR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4170<imm>  
    0x20  0c 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4170 (size: 12, align: 1) {
    63 6f 6c 6f 75 72 2d 73 63 61 6c 65              colour-scale
}

alloc29 (static: COLOR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4165<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4165 (size: 11, align: 1) {
    63 6f 6c 6f 72 2d 73 63 61 6c 65                 color-scale
}

alloc28 (static: COLOUR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4160<imm>  ........
    0x20  06 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4147 (size: 48, align: 8) {
    0x00  alloc4146<imm> 06 00 00 00 00 00 00 00  ........
    0x10  alloc4148<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4149<imm> 05 00 00 00 00 00 00 00  ........
}

alloc4146 (size: 6, align: 1) {
    61 6c 77 61 79 73                                always
}

alloc4148 (size: 4, align: 1) {
    61 75 74 6f                                      auto
}

alloc4149 (size: 5, align: 1) {
    6e 65 76 65 72                                   never
}

alloc4160 (size: 6, align: 1) {
    63 6f 6c 6f 75 72                                colour
}

alloc27 (static: COLOR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4154<imm>  ........
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4154 (size: 5, align: 1) {
    63 6f 6c 6f 72                                   color
}

alloc26 (static: ACROSS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4127<imm>  
    0x20  06 00 00 00 00 00 00 00 01 78 __ __ __ __ __ __  .........x
}

alloc4127 (size: 6, align: 1) {
    61 63 72 6f 73 73                                across
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc23 (static: ONE_LINE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4112<imm>  
    0x20  07 00 00 00 00 00 00 00 01 31 __ __ __ __ __ __  .........1
}

alloc4112 (size: 7, align: 1) {
    6f 6e 65 6c 69 6e 65                             oneline
}

alloc22 (static: HELP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4107<imm>  
    0x20  04 00 00 00 00 00 00 00 01 3f __ __ __ __ __ __  .........?
}

alloc4107 (size: 4, align: 1) {
    68 65 6c 70                                      help
}

alloc21 (static: VERSION, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4102<imm>  
    0x20  07 00 00 00 00 00 00 00 01 76 __ __ __ __ __ __  .........v
}

alloc4102 (size: 7, align: 1) {
    76 65 72 73 69 6f 6e                             version
}

alloc20 (static: GIT_IGNORE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4223<imm>  
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4223 (size: 10, align: 1) {
    67 69 74 2d 69 67 6e 6f 72 65                    git-ignore
}

alloc19 (static: IGNORE_GLOB, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4218<imm>  
    0x20  0b 00 00 00 00 00 00 00 01 49 __ __ __ __ __ __  .........I
}

alloc4218 (size: 11, align: 1) {
    69 67 6e 6f 72 65 2d 67 6c 6f 62                 ignore-glob
}

alloc18 (static: ALL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4175<imm>  
    0x20  03 00 00 00 00 00 00 00 01 61 __ __ __ __ __ __  .........a
}

alloc4175 (size: 3, align: 1) {
    61 6c 6c                                         all
}

alloc17 (static: SORT, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4196<imm>  ........
    0x10  0c 00 00 00 00 00 00 00 alloc4212<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 73 __ __ __ __ __ __  .........s
}

alloc4196 (size: 192, align: 8) {
    0x00  alloc4195<imm> 04 00 00 00 00 00 00 00  ........
    0x10  alloc4197<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4198<imm> 04 00 00 00 00 00 00 00  ........
    0x30  alloc4199<imm> 09 00 00 00 00 00 00 00  ........
    0x40  alloc4200<imm> 09 00 00 00 00 00 00 00  ........
    0x50  alloc4201<imm> 08 00 00 00 00 00 00 00  ........
    0x60  alloc4202<imm> 07 00 00 00 00 00 00 00  ........
    0x70  alloc4203<imm> 08 00 00 00 00 00 00 00  ........
    0x80  alloc4204<imm> 07 00 00 00 00 00 00 00  ........
    0x90  alloc4205<imm> 05 00 00 00 00 00 00 00  ........
    0xa0  alloc4206<imm> 04 00 00 00 00 00 00 00  ........
    0xb0  alloc4207<imm> 04 00 00 00 00 00 00 00  ........
}

alloc4195 (size: 4, align: 1) {
    6e 61 6d 65                                      name
}

alloc4197 (size: 4, align: 1) {
    4e 61 6d 65                                      Name
}

alloc4198 (size: 4, align: 1) {
    73 69 7a 65                                      size
}

alloc4199 (size: 9, align: 1) {
    65 78 74 65 6e 73 69 6f 6e                       extension
}

alloc4200 (size: 9, align: 1) {
    45 78 74 65 6e 73 69 6f 6e                       Extension
}

alloc4201 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4202 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4203 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4204 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4205 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc4206 (size: 4, align: 1) {
    74 79 70 65                                      type
}

alloc4207 (size: 4, align: 1) {
    6e 6f 6e 65                                      none
}

alloc4212 (size: 4, align: 1) {
    73 6f 72 74                                      sort
}

alloc16 (static: ONLY_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4233<imm>  
    0x20  09 00 00 00 00 00 00 00 01 44 __ __ __ __ __ __  .........D
}

alloc4233 (size: 9, align: 1) {
    6f 6e 6c 79 2d 64 69 72 73                       only-dirs
}

alloc15 (static: REVERSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4191<imm>  
    0x20  07 00 00 00 00 00 00 00 01 72 __ __ __ __ __ __  .........r
}

alloc4191 (size: 7, align: 1) {
    72 65 76 65 72 73 65                             reverse
}

alloc14 (static: DIRS_FIRST, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4228<imm>  
    0x20  17 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4228 (size: 23, align: 1) {
    0x00  67 72 6f 75 70 2d 64 69 72 65 63 74 6f 72 69 65  group-directorie
    0x10  73 2d 66 69 72 73 74                             s-first
}

alloc12 (static: ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4263<imm>  
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4263 (size: 5, align: 1) {
    69 63 6f 6e 73                                   icons
}

alloc11 (static: NO_ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4349<imm>  
    0x20  08 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4349 (size: 8, align: 1) {
    6e 6f 2d 69 63 6f 6e 73                          no-icons
}

alloc10 (static: CLASSIFY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4142<imm>  
    0x20  08 00 00 00 00 00 00 00 01 46 __ __ __ __ __ __  .........F
}

alloc4142 (size: 8, align: 1) {
    63 6c 61 73 73 69 66 79                          classify
}

alloc9 (static: LEVEL, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4186<imm>  
    0x20  05 00 00 00 00 00 00 00 01 4c __ __ __ __ __ __  .........L
}

alloc4186 (size: 5, align: 1) {
    6c 65 76 65 6c                                   level
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

alloc7 (static: LIST_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4180<imm>  
    0x20  09 00 00 00 00 00 00 00 01 64 __ __ __ __ __ __  .........d
}

alloc4180 (size: 9, align: 1) {
    6c 69 73 74 2d 64 69 72 73                       list-dirs
}

alloc6 (static: RECURSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4132<imm>  
    0x20  07 00 00 00 00 00 00 00 01 52 __ __ __ __ __ __  .........R
}

alloc4132 (size: 7, align: 1) {
    72 65 63 75 72 73 65                             recurse
}

fn options::theme::<impl at src/options/theme.rs:6:1: 6:13>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<theme::Options, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<theme::Options, options::error::OptionsError>;
    let _3: theme::UseColours;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, theme::UseColours>;
    let mut _5: std::result::Result<theme::UseColours, options::error::OptionsError>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _8: theme::UseColours;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, theme::ColourScale>;
    let mut _10: std::result::Result<theme::ColourScale, options::error::OptionsError>;
    let mut _11: isize;
    let mut _15: bool;
    let mut _16: &theme::UseColours;
    let mut _17: theme::Options;
    let mut _18: theme::UseColours;
    let mut _19: theme::Definitions;
    scope 1 {
        debug use_colours => _3;
        let _12: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _13: theme::ColourScale;
        scope 6 {
            debug colour_scale => _13;
            let _14: theme::Definitions;
            let mut _20: &theme::UseColours;
            scope 11 {
                debug definitions => _14;
            }
        }
        scope 7 {
            debug residual => _12;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _13;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = options::theme::<impl UseColours>::deduce(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<UseColours, OptionsError> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_4 as Continue).0: theme::UseColours);
        _3 = _8;
        _10 = options::theme::<impl ColourScale>::deduce(_1) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<theme::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb14, unwind continue];
    }

    bb6: {
        _9 = <Result<ColourScale, OptionsError> as Try>::branch(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _13 = ((_9 as Continue).0: theme::ColourScale);
        _16 = &_3;
        _20 = const _;
        _15 = <UseColours as PartialEq>::eq(move _16, _20) -> [return: bb10, unwind continue];
    }

    bb9: {
        _12 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<theme::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _12) -> [return: bb14, unwind continue];
    }

    bb10: {
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _14 = <Definitions as Default>::default() -> [return: bb13, unwind continue];
    }

    bb12: {
        _14 = options::theme::<impl Definitions>::deduce::<V>(_2) -> [return: bb13, unwind continue];
    }

    bb13: {
        _18 = _3;
        _19 = move _14;
        _17 = theme::Options { use_colours: move _18, colour_scale: _13, definitions: move _19 };
        _0 = Result::<theme::Options, OptionsError>::Ok(move _17);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

promoted[0] in options::theme::<impl at src/options/theme.rs:6:1: 6:13>::deduce: &UseColours = {
    let mut _0: &theme::UseColours;
    let mut _1: theme::UseColours;

    bb0: {
        _1 = UseColours::Never;
        _0 = &_1;
        return;
    }
}

fn options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce(_1: &MatchedFlags<'_>) -> Result<UseColours, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<theme::UseColours, options::error::OptionsError>;
    let _2: &std::ffi::OsStr;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _4: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: std::option::Option<&std::ffi::OsStr>;
    let mut _8: isize;
    let _9: &std::ffi::OsStr;
    let mut _10: theme::UseColours;
    let mut _11: bool;
    let mut _12: &&std::ffi::OsStr;
    let mut _13: theme::UseColours;
    let mut _14: bool;
    let mut _15: &&std::ffi::OsStr;
    let mut _16: bool;
    let mut _17: &&std::ffi::OsStr;
    let mut _18: theme::UseColours;
    let mut _19: bool;
    let mut _20: &&std::ffi::OsStr;
    let mut _21: theme::UseColours;
    let mut _22: options::error::OptionsError;
    let _23: &options::parser::Arg;
    let mut _24: std::ffi::OsString;
    let mut _25: &std::ffi::OsStr;
    scope 1 {
        debug word => _2;
        let mut _26: &&str;
        let mut _27: &&str;
        let mut _28: &&str;
        let mut _29: &&str;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }
    scope 6 {
        debug w => _9;
    }

    bb0: {
        _4 = MatchedFlags::<'_>::get_where::<{closure@src/options/theme.rs:25:44: 25:47}>(_1, const ZeroSized: {closure@src/options/theme.rs:25:44: 25:47}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb6, 1: bb7, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<UseColours, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb20, unwind continue];
    }

    bb6: {
        _10 = UseColours::Automatic;
        _0 = Result::<UseColours, OptionsError>::Ok(move _10);
        goto -> bb20;
    }

    bb7: {
        _9 = ((_7 as Some).0: &std::ffi::OsStr);
        _2 = _9;
        _12 = &_2;
        _29 = const _;
        _11 = <&OsStr as PartialEq<&str>>::eq(move _12, _29) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _13 = UseColours::Always;
        _0 = Result::<UseColours, OptionsError>::Ok(move _13);
        goto -> bb20;
    }

    bb10: {
        _15 = &_2;
        _28 = const _;
        _14 = <&OsStr as PartialEq<&str>>::eq(move _15, _28) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _14) -> [0: bb12, otherwise: bb14];
    }

    bb12: {
        _17 = &_2;
        _27 = const _;
        _16 = <&OsStr as PartialEq<&str>>::eq(move _17, _27) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _16) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _18 = UseColours::Automatic;
        _0 = Result::<UseColours, OptionsError>::Ok(move _18);
        goto -> bb20;
    }

    bb15: {
        _20 = &_2;
        _26 = const _;
        _19 = <&OsStr as PartialEq<&str>>::eq(move _20, _26) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _19) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _21 = UseColours::Never;
        _0 = Result::<UseColours, OptionsError>::Ok(move _21);
        goto -> bb20;
    }

    bb18: {
        _23 = const {alloc27: &Arg};
        _25 = _2;
        _24 = <&OsStr as Into<OsString>>::into(move _25) -> [return: bb19, unwind continue];
    }

    bb19: {
        _22 = OptionsError::BadArgument(_23, move _24);
        _0 = Result::<UseColours, OptionsError>::Err(move _22);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

alloc27 (static: COLOR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4154<imm>  ........
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4147 (size: 48, align: 8) {
    0x00  alloc4146<imm> 06 00 00 00 00 00 00 00  ........
    0x10  alloc4148<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4149<imm> 05 00 00 00 00 00 00 00  ........
}

alloc4146 (size: 6, align: 1) {
    61 6c 77 61 79 73                                always
}

alloc4148 (size: 4, align: 1) {
    61 75 74 6f                                      auto
}

alloc4149 (size: 5, align: 1) {
    6e 65 76 65 72                                   never
}

alloc4154 (size: 5, align: 1) {
    63 6f 6c 6f 72                                   color
}

promoted[0] in options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "never";
        _0 = &_1;
        return;
    }
}

promoted[1] in options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "automatic";
        _0 = &_1;
        return;
    }
}

promoted[2] in options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "auto";
        _0 = &_1;
        return;
    }
}

promoted[3] in options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "always";
        _0 = &_1;
        return;
    }
}

fn options::theme::<impl at src/options/theme.rs:23:1: 23:16>::deduce::{closure#0}(_1: &{closure@src/options/theme.rs:25:44: 25:47}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let _5: &options::parser::Arg;

    bb0: {
        _4 = const {alloc27: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const {alloc28: &Arg};
        _0 = Flag::matches(_2, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

alloc28 (static: COLOUR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4160<imm>  ........
    0x20  06 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4147 (size: 48, align: 8) {
    0x00  alloc4146<imm> 06 00 00 00 00 00 00 00  ........
    0x10  alloc4148<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4149<imm> 05 00 00 00 00 00 00 00  ........
}

alloc4146 (size: 6, align: 1) {
    61 6c 77 61 79 73                                always
}

alloc4148 (size: 4, align: 1) {
    61 75 74 6f                                      auto
}

alloc4149 (size: 5, align: 1) {
    6e 65 76 65 72                                   never
}

alloc4160 (size: 6, align: 1) {
    63 6f 6c 6f 75 72                                colour
}

alloc27 (static: COLOR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4154<imm>  ........
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4154 (size: 5, align: 1) {
    63 6f 6c 6f 72                                   color
}

fn options::theme::<impl at src/options/theme.rs:46:1: 46:17>::deduce(_1: &MatchedFlags<'_>) -> Result<ColourScale, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<theme::ColourScale, options::error::OptionsError>;
    let mut _2: bool;
    let mut _3: &std::option::Option<&options::parser::Flag>;
    let _4: std::option::Option<&options::parser::Flag>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&options::parser::Flag>>;
    let mut _6: std::result::Result<std::option::Option<&options::parser::Flag>, options::error::OptionsError>;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _9: std::option::Option<&options::parser::Flag>;
    let mut _10: theme::ColourScale;
    let mut _11: theme::ColourScale;
    scope 1 {
        debug residual => _8;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _9;
        scope 4 {
        }
    }

    bb0: {
        _6 = MatchedFlags::<'_>::has_where::<{closure@src/options/theme.rs:48:30: 48:33}>(_1, const ZeroSized: {closure@src/options/theme.rs:48:30: 48:33}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = <Result<Option<&Flag>, OptionsError> as Try>::branch(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_5 as Continue).0: std::option::Option<&options::parser::Flag>);
        _4 = _9;
        _3 = &_4;
        _2 = Option::<&Flag>::is_some(move _3) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<ColourScale, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _8) -> [return: bb7, unwind continue];
    }

    bb6: {
        switchInt(move _2) -> [0: bb9, otherwise: bb8];
    }

    bb7: {
        return;
    }

    bb8: {
        _10 = ColourScale::Gradient;
        _0 = Result::<ColourScale, OptionsError>::Ok(move _10);
        goto -> bb7;
    }

    bb9: {
        _11 = ColourScale::Fixed;
        _0 = Result::<ColourScale, OptionsError>::Ok(move _11);
        goto -> bb7;
    }
}

fn options::theme::<impl at src/options/theme.rs:46:1: 46:17>::deduce::{closure#0}(_1: &{closure@src/options/theme.rs:48:30: 48:33}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let _5: &options::parser::Arg;

    bb0: {
        _4 = const {alloc29: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const {alloc30: &Arg};
        _0 = Flag::matches(_2, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

alloc30 (static: COLOUR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4170<imm>  
    0x20  0c 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4170 (size: 12, align: 1) {
    63 6f 6c 6f 75 72 2d 73 63 61 6c 65              colour-scale
}

alloc29 (static: COLOR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4165<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4165 (size: 11, align: 1) {
    63 6f 6c 6f 72 2d 73 63 61 6c 65                 color-scale
}

fn options::theme::<impl at src/options/theme.rs:58:1: 58:17>::deduce(_1: &V) -> Definitions {
    debug vars => _1;
    let mut _0: theme::Definitions;
    let _2: std::option::Option<std::string::String>;
    let mut _3: std::option::Option<std::ffi::OsString>;
    let mut _4: &str;
    let mut _5: &&str;
    let mut _7: std::option::Option<std::ffi::OsString>;
    let mut _8: &str;
    let mut _9: &&str;
    let mut _10: std::option::Option<std::string::String>;
    scope 1 {
        debug ls => _2;
        let _6: std::option::Option<std::string::String>;
        scope 2 {
            debug exa => _6;
        }
    }

    bb0: {
        _5 = const {alloc52: &&str};
        _4 = (*_5);
        _3 = <V as vars::Vars>::get(_1, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<OsString>::map::<String, {closure@src/options/theme.rs:60:50: 60:53}>(move _3, const ZeroSized: {closure@src/options/theme.rs:60:50: 60:53}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = const {alloc53: &&str};
        _8 = (*_9);
        _7 = <V as vars::Vars>::get(_1, move _8) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _6 = Option::<OsString>::map::<String, {closure@src/options/theme.rs:61:50: 61:53}>(move _7, const ZeroSized: {closure@src/options/theme.rs:61:50: 61:53}) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _10 = move _2;
        _0 = Definitions { ls: move _10, exa: move _6 };
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

alloc53 (static: EXA_COLORS, size: 16, align: 8) {
    alloc1199<imm> 0a 00 00 00 00 00 00 00  ........
}

alloc1199 (size: 10, align: 1) {
    45 58 41 5f 43 4f 4c 4f 52 53                    EXA_COLORS
}

alloc52 (static: LS_COLORS, size: 16, align: 8) {
    alloc1197<imm> 09 00 00 00 00 00 00 00  ........
}

alloc1197 (size: 9, align: 1) {
    4c 53 5f 43 4f 4c 4f 52 53                       LS_COLORS
}

fn options::theme::<impl at src/options/theme.rs:58:1: 58:17>::deduce::{closure#0}(_1: {closure@src/options/theme.rs:60:50: 60:53}, _2: OsString) -> String {
    debug e => _2;
    let mut _0: std::string::String;
    let mut _3: &std::borrow::Cow<'_, str>;
    let _4: std::borrow::Cow<'_, str>;
    let _5: &std::ffi::OsStr;
    let mut _6: &std::ffi::OsString;

    bb0: {
        _6 = &_2;
        _5 = <OsString as Deref>::deref(move _6) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _4 = OsStr::to_string_lossy(_5) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _3 = &_4;
        _0 = <Cow<'_, str> as ToString>::to_string(move _3) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn options::theme::<impl at src/options/theme.rs:58:1: 58:17>::deduce::{closure#1}(_1: {closure@src/options/theme.rs:61:50: 61:53}, _2: OsString) -> String {
    debug e => _2;
    let mut _0: std::string::String;
    let mut _3: &std::borrow::Cow<'_, str>;
    let _4: std::borrow::Cow<'_, str>;
    let _5: &std::ffi::OsStr;
    let mut _6: &std::ffi::OsString;

    bb0: {
        _6 = &_2;
        _5 = <OsString as Deref>::deref(move _6) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _4 = OsStr::to_string_lossy(_5) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _3 = &_4;
        _0 = <Cow<'_, str> as ToString>::to_string(move _3) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn view::<impl at src/options/view.rs:11:1: 11:10>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<View, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::View, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::Mode>;
    let mut _4: std::result::Result<output::Mode, options::error::OptionsError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: output::Mode;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::TerminalWidth>;
    let mut _9: std::result::Result<output::TerminalWidth, options::error::OptionsError>;
    let mut _10: isize;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::file_name::Options>;
    let mut _14: std::result::Result<output::file_name::Options, options::error::OptionsError>;
    let mut _15: isize;
    let mut _18: output::View;
    scope 1 {
        debug mode => _7;
        let _11: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _12: output::TerminalWidth;
        scope 6 {
            debug width => _12;
            let _16: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _17: output::file_name::Options;
            scope 11 {
                debug file_style => _17;
            }
            scope 12 {
                debug residual => _16;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _17;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _11;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = view::<impl output::Mode>::deduce::<V>(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<output::Mode, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: output::Mode);
        _9 = view::<impl TerminalWidth>::deduce::<V>(_2) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<View, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb14, unwind continue];
    }

    bb6: {
        _8 = <Result<TerminalWidth, OptionsError> as Try>::branch(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: output::TerminalWidth);
        _14 = options::file_name::<impl output::file_name::Options>::deduce::<V>(_1, _2) -> [return: bb10, unwind continue];
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<View, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _11) -> [return: bb14, unwind continue];
    }

    bb10: {
        _13 = <Result<output::file_name::Options, OptionsError> as Try>::branch(move _14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _17 = ((_13 as Continue).0: output::file_name::Options);
        _18 = View { mode: move _7, width: _12, file_style: _17 };
        _0 = Result::<View, OptionsError>::Ok(move _18);
        goto -> bb14;
    }

    bb13: {
        _16 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<View, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _16) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

fn view::<impl at src/options/view.rs:21:1: 21:10>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<output::Mode, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::Mode, options::error::OptionsError>;
    let _3: std::option::Option<&options::parser::Flag>;
    let mut _4: isize;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>>;
    let mut _7: std::result::Result<(), options::error::OptionsError>;
    let mut _8: isize;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::grid::Options>;
    let mut _11: std::result::Result<output::grid::Options, options::error::OptionsError>;
    let mut _12: isize;
    let mut _15: output::Mode;
    let mut _16: bool;
    let _17: &options::parser::Arg;
    let mut _18: bool;
    let _19: &options::parser::Arg;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _21: std::result::Result<bool, options::error::OptionsError>;
    let _22: &options::parser::Arg;
    let mut _23: isize;
    let mut _26: bool;
    let _27: &options::parser::Arg;
    let mut _28: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _29: std::result::Result<bool, options::error::OptionsError>;
    let _30: &options::parser::Arg;
    let mut _31: isize;
    let mut _34: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _35: std::result::Result<bool, options::error::OptionsError>;
    let _36: &options::parser::Arg;
    let mut _37: isize;
    let mut _40: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::details::Options>;
    let mut _41: std::result::Result<output::details::Options, options::error::OptionsError>;
    let mut _42: isize;
    let mut _46: bool;
    let mut _47: &std::option::Option<&options::parser::Flag>;
    let mut _48: bool;
    let _49: &options::parser::Flag;
    let mut _50: std::option::Option<&options::parser::Flag>;
    let _51: &options::parser::Arg;
    let mut _52: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _53: std::result::Result<bool, options::error::OptionsError>;
    let _54: &options::parser::Arg;
    let mut _55: isize;
    let mut _58: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::grid::Options>;
    let mut _59: std::result::Result<output::grid::Options, options::error::OptionsError>;
    let mut _60: isize;
    let mut _63: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::grid_details::RowThreshold>;
    let mut _64: std::result::Result<output::grid_details::RowThreshold, options::error::OptionsError>;
    let mut _65: isize;
    let mut _69: output::Mode;
    let mut _70: output::Mode;
    let mut _71: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>>;
    let mut _72: std::result::Result<(), options::error::OptionsError>;
    let mut _73: isize;
    let mut _75: bool;
    let _76: &options::parser::Arg;
    let mut _77: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _78: std::result::Result<bool, options::error::OptionsError>;
    let _79: &options::parser::Arg;
    let mut _80: isize;
    let mut _83: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::details::Options>;
    let mut _84: std::result::Result<output::details::Options, options::error::OptionsError>;
    let mut _85: isize;
    let mut _88: output::Mode;
    let mut _89: bool;
    let _90: &options::parser::Arg;
    let mut _91: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _92: std::result::Result<bool, options::error::OptionsError>;
    let _93: &options::parser::Arg;
    let mut _94: isize;
    let mut _97: output::Mode;
    let mut _98: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::grid::Options>;
    let mut _99: std::result::Result<output::grid::Options, options::error::OptionsError>;
    let mut _100: isize;
    let mut _103: output::Mode;
    scope 1 {
        debug flag => _3;
        let _5: &options::parser::Flag;
        let _9: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _13: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _14: output::grid::Options;
        scope 2 {
            debug flag => _5;
            let _24: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _25: bool;
            let _32: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _33: bool;
            let _38: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _39: bool;
            let _74: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _81: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _82: bool;
            let _95: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _96: bool;
            let _101: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _102: output::grid::Options;
            scope 13 {
                debug residual => _24;
                scope 14 {
                }
            }
            scope 15 {
                debug val => _25;
                scope 16 {
                }
            }
            scope 17 {
                debug residual => _32;
                scope 18 {
                }
            }
            scope 19 {
                debug val => _33;
                scope 20 {
                }
            }
            scope 21 {
                let _43: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _44: output::details::Options;
                scope 26 {
                    debug details => _44;
                    let _45: std::option::Option<&options::parser::Flag>;
                    scope 31 {
                        debug flag => _45;
                        let _56: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                        let _57: bool;
                        scope 32 {
                            let _61: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                            let _62: output::grid::Options;
                            scope 37 {
                                debug grid => _62;
                                let _66: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                                let _67: output::grid_details::RowThreshold;
                                scope 42 {
                                    debug row_threshold => _67;
                                    let _68: output::grid_details::Options;
                                    scope 47 {
                                        debug grid_details => _68;
                                    }
                                }
                                scope 43 {
                                    debug residual => _66;
                                    scope 44 {
                                    }
                                }
                                scope 45 {
                                    debug val => _67;
                                    scope 46 {
                                    }
                                }
                            }
                            scope 38 {
                                debug residual => _61;
                                scope 39 {
                                }
                            }
                            scope 40 {
                                debug val => _62;
                                scope 41 {
                                }
                            }
                        }
                        scope 33 {
                            debug residual => _56;
                            scope 34 {
                            }
                        }
                        scope 35 {
                            debug val => _57;
                            scope 36 {
                            }
                        }
                    }
                }
                scope 27 {
                    debug residual => _43;
                    scope 28 {
                    }
                }
                scope 29 {
                    debug val => _44;
                    scope 30 {
                    }
                }
            }
            scope 22 {
                debug residual => _38;
                scope 23 {
                }
            }
            scope 24 {
                debug val => _39;
                scope 25 {
                }
            }
            scope 48 {
                debug residual => _74;
                scope 49 {
                }
            }
            scope 50 {
                debug val => const ();
                scope 51 {
                }
            }
            scope 52 {
                let _86: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _87: output::details::Options;
                scope 57 {
                    debug details => _87;
                }
                scope 58 {
                    debug residual => _86;
                    scope 59 {
                    }
                }
                scope 60 {
                    debug val => _87;
                    scope 61 {
                    }
                }
            }
            scope 53 {
                debug residual => _81;
                scope 54 {
                }
            }
            scope 55 {
                debug val => _82;
                scope 56 {
                }
            }
            scope 62 {
            }
            scope 63 {
                debug residual => _95;
                scope 64 {
                }
            }
            scope 65 {
                debug val => _96;
                scope 66 {
                }
            }
            scope 67 {
                debug grid => _102;
            }
            scope 68 {
                debug residual => _101;
                scope 69 {
                }
            }
            scope 70 {
                debug val => _102;
                scope 71 {
                }
            }
        }
        scope 3 {
            debug f => _5;
        }
        scope 4 {
            debug residual => _9;
            scope 5 {
            }
        }
        scope 6 {
            debug val => const ();
            scope 7 {
            }
        }
        scope 8 {
            debug grid => _14;
        }
        scope 9 {
            debug residual => _13;
            scope 10 {
            }
        }
        scope 11 {
            debug val => _14;
            scope 12 {
            }
        }
    }

    bb0: {
        _3 = MatchedFlags::<'_>::has_where_any::<{closure@src/options/view.rs:32:42: 32:45}>(_1, const ZeroSized: {closure@src/options/view.rs:32:42: 32:45}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _7 = view::<impl output::Mode>::strict_check_long_flags(_1) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: &options::parser::Flag);
        _17 = const {alloc24: &Arg};
        _16 = Flag::matches(_5, _17) -> [return: bb13, unwind continue];
    }

    bb5: {
        _6 = <Result<(), OptionsError> as Try>::branch(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb8, otherwise: bb3];
    }

    bb7: {
        _11 = view::<impl grid::Options>::deduce(_1) -> [return: bb9, unwind continue];
    }

    bb8: {
        _9 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _9) -> [return: bb83, unwind continue];
    }

    bb9: {
        _10 = <Result<grid::Options, OptionsError> as Try>::branch(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb11, 1: bb12, otherwise: bb3];
    }

    bb11: {
        _14 = ((_10 as Continue).0: output::grid::Options);
        _15 = output::Mode::Grid(_14);
        _0 = Result::<output::Mode, OptionsError>::Ok(move _15);
        goto -> bb83;
    }

    bb12: {
        _13 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _13) -> [return: bb83, unwind continue];
    }

    bb13: {
        switchInt(move _16) -> [0: bb14, otherwise: bb28];
    }

    bb14: {
        _19 = const {alloc8: &Arg};
        _18 = Flag::matches(_5, _19) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _18) -> [0: bb21, otherwise: bb16];
    }

    bb16: {
        _22 = const {alloc24: &Arg};
        _21 = MatchedFlags::<'_>::has(_1, _22) -> [return: bb17, unwind continue];
    }

    bb17: {
        _20 = <Result<bool, OptionsError> as Try>::branch(move _21) -> [return: bb18, unwind continue];
    }

    bb18: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb19, 1: bb20, otherwise: bb3];
    }

    bb19: {
        _25 = ((_20 as Continue).0: bool);
        switchInt(_25) -> [0: bb21, otherwise: bb28];
    }

    bb20: {
        _24 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _24) -> [return: bb83, unwind continue];
    }

    bb21: {
        _27 = const {alloc25: &Arg};
        _26 = Flag::matches(_5, _27) -> [return: bb22, unwind continue];
    }

    bb22: {
        switchInt(move _26) -> [0: bb56, otherwise: bb23];
    }

    bb23: {
        _30 = const {alloc24: &Arg};
        _29 = MatchedFlags::<'_>::has(_1, _30) -> [return: bb24, unwind continue];
    }

    bb24: {
        _28 = <Result<bool, OptionsError> as Try>::branch(move _29) -> [return: bb25, unwind continue];
    }

    bb25: {
        _31 = discriminant(_28);
        switchInt(move _31) -> [0: bb26, 1: bb27, otherwise: bb3];
    }

    bb26: {
        _33 = ((_28 as Continue).0: bool);
        switchInt(_33) -> [0: bb56, otherwise: bb28];
    }

    bb27: {
        _32 = move ((_28 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _32) -> [return: bb83, unwind continue];
    }

    bb28: {
        _36 = const {alloc24: &Arg};
        _35 = MatchedFlags::<'_>::has(_1, _36) -> [return: bb29, unwind continue];
    }

    bb29: {
        _34 = <Result<bool, OptionsError> as Try>::branch(move _35) -> [return: bb30, unwind continue];
    }

    bb30: {
        _37 = discriminant(_34);
        switchInt(move _37) -> [0: bb31, 1: bb32, otherwise: bb3];
    }

    bb31: {
        _39 = ((_34 as Continue).0: bool);
        _41 = view::<impl details::Options>::deduce_long::<V>(_1, _2) -> [return: bb33, unwind continue];
    }

    bb32: {
        _38 = move ((_34 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _38) -> [return: bb83, unwind continue];
    }

    bb33: {
        _40 = <Result<details::Options, OptionsError> as Try>::branch(move _41) -> [return: bb34, unwind continue];
    }

    bb34: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb35, 1: bb36, otherwise: bb3];
    }

    bb35: {
        _44 = move ((_40 as Continue).0: output::details::Options);
        _45 = MatchedFlags::<'_>::has_where_any::<{closure@src/options/view.rs:51:46: 51:49}>(_1, const ZeroSized: {closure@src/options/view.rs:51:46: 51:49}) -> [return: bb37, unwind continue];
    }

    bb36: {
        _43 = move ((_40 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _43) -> [return: bb83, unwind continue];
    }

    bb37: {
        _47 = &_45;
        _46 = Option::<&Flag>::is_some(move _47) -> [return: bb38, unwind continue];
    }

    bb38: {
        switchInt(move _46) -> [0: bb55, otherwise: bb39];
    }

    bb39: {
        _50 = _45;
        _49 = Option::<&Flag>::unwrap(move _50) -> [return: bb40, unwind continue];
    }

    bb40: {
        _51 = const {alloc25: &Arg};
        _48 = Flag::matches(_49, _51) -> [return: bb41, unwind continue];
    }

    bb41: {
        switchInt(move _48) -> [0: bb55, otherwise: bb42];
    }

    bb42: {
        _54 = const {alloc25: &Arg};
        _53 = MatchedFlags::<'_>::has(_1, _54) -> [return: bb43, unwind continue];
    }

    bb43: {
        _52 = <Result<bool, OptionsError> as Try>::branch(move _53) -> [return: bb44, unwind continue];
    }

    bb44: {
        _55 = discriminant(_52);
        switchInt(move _55) -> [0: bb45, 1: bb46, otherwise: bb3];
    }

    bb45: {
        _57 = ((_52 as Continue).0: bool);
        _59 = view::<impl grid::Options>::deduce(_1) -> [return: bb47, unwind continue];
    }

    bb46: {
        _56 = move ((_52 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _56) -> [return: bb83, unwind continue];
    }

    bb47: {
        _58 = <Result<grid::Options, OptionsError> as Try>::branch(move _59) -> [return: bb48, unwind continue];
    }

    bb48: {
        _60 = discriminant(_58);
        switchInt(move _60) -> [0: bb49, 1: bb50, otherwise: bb3];
    }

    bb49: {
        _62 = ((_58 as Continue).0: output::grid::Options);
        _64 = view::<impl RowThreshold>::deduce::<V>(_2) -> [return: bb51, unwind continue];
    }

    bb50: {
        _61 = move ((_58 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _61) -> [return: bb83, unwind continue];
    }

    bb51: {
        _63 = <Result<RowThreshold, OptionsError> as Try>::branch(move _64) -> [return: bb52, unwind continue];
    }

    bb52: {
        _65 = discriminant(_63);
        switchInt(move _65) -> [0: bb53, 1: bb54, otherwise: bb3];
    }

    bb53: {
        _67 = ((_63 as Continue).0: output::grid_details::RowThreshold);
        _68 = grid_details::Options { grid: _62, details: move _44, row_threshold: _67 };
        _69 = output::Mode::GridDetails(move _68);
        _0 = Result::<output::Mode, OptionsError>::Ok(move _69);
        goto -> bb83;
    }

    bb54: {
        _66 = move ((_63 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _66) -> [return: bb83, unwind continue];
    }

    bb55: {
        _70 = output::Mode::Details(move _44);
        _0 = Result::<output::Mode, OptionsError>::Ok(move _70);
        goto -> bb83;
    }

    bb56: {
        _72 = view::<impl output::Mode>::strict_check_long_flags(_1) -> [return: bb57, unwind continue];
    }

    bb57: {
        _71 = <Result<(), OptionsError> as Try>::branch(move _72) -> [return: bb58, unwind continue];
    }

    bb58: {
        _73 = discriminant(_71);
        switchInt(move _73) -> [0: bb59, 1: bb60, otherwise: bb3];
    }

    bb59: {
        _76 = const {alloc8: &Arg};
        _75 = Flag::matches(_5, _76) -> [return: bb61, unwind continue];
    }

    bb60: {
        _74 = move ((_71 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _74) -> [return: bb83, unwind continue];
    }

    bb61: {
        switchInt(move _75) -> [0: bb71, otherwise: bb62];
    }

    bb62: {
        _79 = const {alloc8: &Arg};
        _78 = MatchedFlags::<'_>::has(_1, _79) -> [return: bb63, unwind continue];
    }

    bb63: {
        _77 = <Result<bool, OptionsError> as Try>::branch(move _78) -> [return: bb64, unwind continue];
    }

    bb64: {
        _80 = discriminant(_77);
        switchInt(move _80) -> [0: bb65, 1: bb66, otherwise: bb3];
    }

    bb65: {
        _82 = ((_77 as Continue).0: bool);
        _84 = view::<impl details::Options>::deduce_tree(_1) -> [return: bb67, unwind continue];
    }

    bb66: {
        _81 = move ((_77 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _81) -> [return: bb83, unwind continue];
    }

    bb67: {
        _83 = <Result<details::Options, OptionsError> as Try>::branch(move _84) -> [return: bb68, unwind continue];
    }

    bb68: {
        _85 = discriminant(_83);
        switchInt(move _85) -> [0: bb69, 1: bb70, otherwise: bb3];
    }

    bb69: {
        _87 = move ((_83 as Continue).0: output::details::Options);
        _88 = output::Mode::Details(move _87);
        _0 = Result::<output::Mode, OptionsError>::Ok(move _88);
        goto -> bb83;
    }

    bb70: {
        _86 = move ((_83 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _86) -> [return: bb83, unwind continue];
    }

    bb71: {
        _90 = const {alloc23: &Arg};
        _89 = Flag::matches(_5, _90) -> [return: bb72, unwind continue];
    }

    bb72: {
        switchInt(move _89) -> [0: bb78, otherwise: bb73];
    }

    bb73: {
        _93 = const {alloc23: &Arg};
        _92 = MatchedFlags::<'_>::has(_1, _93) -> [return: bb74, unwind continue];
    }

    bb74: {
        _91 = <Result<bool, OptionsError> as Try>::branch(move _92) -> [return: bb75, unwind continue];
    }

    bb75: {
        _94 = discriminant(_91);
        switchInt(move _94) -> [0: bb76, 1: bb77, otherwise: bb3];
    }

    bb76: {
        _96 = ((_91 as Continue).0: bool);
        _97 = output::Mode::Lines;
        _0 = Result::<output::Mode, OptionsError>::Ok(move _97);
        goto -> bb83;
    }

    bb77: {
        _95 = move ((_91 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _95) -> [return: bb83, unwind continue];
    }

    bb78: {
        _99 = view::<impl grid::Options>::deduce(_1) -> [return: bb79, unwind continue];
    }

    bb79: {
        _98 = <Result<grid::Options, OptionsError> as Try>::branch(move _99) -> [return: bb80, unwind continue];
    }

    bb80: {
        _100 = discriminant(_98);
        switchInt(move _100) -> [0: bb81, 1: bb82, otherwise: bb3];
    }

    bb81: {
        _102 = ((_98 as Continue).0: output::grid::Options);
        _103 = output::Mode::Grid(_102);
        _0 = Result::<output::Mode, OptionsError>::Ok(move _103);
        goto -> bb83;
    }

    bb82: {
        _101 = move ((_98 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<output::Mode, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _101) -> [return: bb83, unwind continue];
    }

    bb83: {
        return;
    }
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc23 (static: ONE_LINE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4112<imm>  
    0x20  07 00 00 00 00 00 00 00 01 31 __ __ __ __ __ __  .........1
}

alloc4112 (size: 7, align: 1) {
    6f 6e 65 6c 69 6e 65                             oneline
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

fn view::<impl at src/options/view.rs:21:1: 21:10>::deduce::{closure#0}(_1: &{closure@src/options/view.rs:32:42: 32:45}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let mut _5: bool;
    let _6: &options::parser::Arg;
    let mut _7: bool;
    let _8: &options::parser::Arg;
    let _9: &options::parser::Arg;

    bb0: {
        _4 = const {alloc24: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb6];
    }

    bb2: {
        _6 = const {alloc23: &Arg};
        _5 = Flag::matches(_2, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _8 = const {alloc25: &Arg};
        _7 = Flag::matches(_2, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = const true;
        goto -> bb8;
    }

    bb7: {
        _9 = const {alloc8: &Arg};
        _0 = Flag::matches(_2, _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc23 (static: ONE_LINE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4112<imm>  
    0x20  07 00 00 00 00 00 00 00 01 31 __ __ __ __ __ __  .........1
}

alloc4112 (size: 7, align: 1) {
    6f 6e 65 6c 69 6e 65                             oneline
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

fn view::<impl at src/options/view.rs:21:1: 21:10>::deduce::{closure#1}(_1: &{closure@src/options/view.rs:51:46: 51:49}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let _5: &options::parser::Arg;

    bb0: {
        _4 = const {alloc25: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const {alloc8: &Arg};
        _0 = Flag::matches(_2, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

fn view::<impl at src/options/view.rs:21:1: 21:10>::strict_check_long_flags(_1: &MatchedFlags<'_>) -> Result<(), OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<(), options::error::OptionsError>;
    let mut _2: bool;
    let mut _3: std::slice::Iter<'_, &options::parser::Arg>;
    let mut _4: &[&options::parser::Arg; 9];
    let _5: [&options::parser::Arg; 9];
    let _6: &options::parser::Arg;
    let _7: &options::parser::Arg;
    let _8: &options::parser::Arg;
    let _9: &options::parser::Arg;
    let _10: &options::parser::Arg;
    let _11: &options::parser::Arg;
    let _12: &options::parser::Arg;
    let _13: &options::parser::Arg;
    let _14: &options::parser::Arg;
    let mut _15: std::slice::Iter<'_, &options::parser::Arg>;
    let mut _16: std::option::Option<&&options::parser::Arg>;
    let mut _17: &mut std::slice::Iter<'_, &options::parser::Arg>;
    let mut _18: isize;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _21: std::result::Result<bool, options::error::OptionsError>;
    let mut _22: isize;
    let mut _25: options::error::OptionsError;
    let _26: &options::parser::Arg;
    let mut _27: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _28: std::result::Result<bool, options::error::OptionsError>;
    let _29: &options::parser::Arg;
    let mut _30: isize;
    let _31: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _32: bool;
    let mut _33: options::error::OptionsError;
    let _34: &options::parser::Arg;
    let _35: &options::parser::Arg;
    let mut _36: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _37: std::result::Result<bool, options::error::OptionsError>;
    let _38: &options::parser::Arg;
    let mut _39: isize;
    let _40: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _41: bool;
    let mut _42: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _43: std::result::Result<bool, options::error::OptionsError>;
    let _44: &options::parser::Arg;
    let mut _45: isize;
    let _46: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _47: bool;
    let mut _48: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _49: std::result::Result<bool, options::error::OptionsError>;
    let _50: &options::parser::Arg;
    let mut _51: isize;
    let _52: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _53: bool;
    let mut _54: options::error::OptionsError;
    let _55: &options::parser::Arg;
    let _56: &options::parser::Arg;
    let _57: &options::parser::Arg;
    let mut _58: &options::parser::Arg;
    let mut _59: &options::parser::Arg;
    scope 1 {
        debug iter => _15;
        let _19: &&options::parser::Arg;
        scope 2 {
            debug option => _19;
            let _23: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _24: bool;
            scope 3 {
                debug residual => _23;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _24;
                scope 6 {
                }
            }
        }
    }
    scope 7 {
        debug residual => _31;
        scope 8 {
        }
    }
    scope 9 {
        debug val => _32;
        scope 10 {
        }
    }
    scope 11 {
        debug residual => _40;
        scope 12 {
        }
    }
    scope 13 {
        debug val => _41;
        scope 14 {
        }
    }
    scope 15 {
        debug residual => _46;
        scope 16 {
        }
    }
    scope 17 {
        debug val => _47;
        scope 18 {
        }
    }
    scope 19 {
        debug residual => _52;
        scope 20 {
        }
    }
    scope 21 {
        debug val => _53;
        scope 22 {
        }
    }

    bb0: {
        _2 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb29, otherwise: bb2];
    }

    bb2: {
        _6 = const {alloc31: &Arg};
        _7 = const {alloc32: &Arg};
        _8 = const {alloc36: &Arg};
        _9 = const {alloc37: &Arg};
        _10 = const {alloc35: &Arg};
        _11 = const {alloc40: &Arg};
        _12 = const {alloc41: &Arg};
        _13 = const {alloc33: &Arg};
        _14 = const {alloc34: &Arg};
        _5 = [_6, _7, _8, _9, _10, _11, _12, _13, _14];
        _4 = &_5;
        _3 = <&[&Arg; 9] as IntoIterator>::into_iter(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = move _3;
        goto -> bb4;
    }

    bb4: {
        _17 = &mut _15;
        _16 = <std::slice::Iter<'_, &Arg> as Iterator>::next(_17) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _19 = ((_16 as Some).0: &&options::parser::Arg);
        _58 = deref_copy (*_19);
        _21 = MatchedFlags::<'_>::has(_1, _58) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _29 = const {alloc49: &Arg};
        _28 = MatchedFlags::<'_>::has(_1, _29) -> [return: bb13, unwind continue];
    }

    bb9: {
        _20 = <Result<bool, OptionsError> as Try>::branch(move _21) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb11, 1: bb12, otherwise: bb7];
    }

    bb11: {
        _24 = ((_20 as Continue).0: bool);
        switchInt(_24) -> [0: bb4, otherwise: bb31];
    }

    bb12: {
        _23 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<(), OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _23) -> [return: bb30, unwind continue];
    }

    bb13: {
        _27 = <Result<bool, OptionsError> as Try>::branch(move _28) -> [return: bb14, unwind continue];
    }

    bb14: {
        _30 = discriminant(_27);
        switchInt(move _30) -> [0: bb15, 1: bb16, otherwise: bb7];
    }

    bb15: {
        _32 = ((_27 as Continue).0: bool);
        switchInt(_32) -> [0: bb33, otherwise: bb32];
    }

    bb16: {
        _31 = move ((_27 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<(), OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _31) -> [return: bb30, unwind continue];
    }

    bb17: {
        _36 = <Result<bool, OptionsError> as Try>::branch(move _37) -> [return: bb18, unwind continue];
    }

    bb18: {
        _39 = discriminant(_36);
        switchInt(move _39) -> [0: bb19, 1: bb20, otherwise: bb7];
    }

    bb19: {
        _41 = ((_36 as Continue).0: bool);
        switchInt(_41) -> [0: bb29, otherwise: bb34];
    }

    bb20: {
        _40 = move ((_36 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<(), OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _40) -> [return: bb30, unwind continue];
    }

    bb21: {
        _42 = <Result<bool, OptionsError> as Try>::branch(move _43) -> [return: bb22, unwind continue];
    }

    bb22: {
        _45 = discriminant(_42);
        switchInt(move _45) -> [0: bb23, 1: bb24, otherwise: bb7];
    }

    bb23: {
        _47 = ((_42 as Continue).0: bool);
        switchInt(_47) -> [0: bb35, otherwise: bb29];
    }

    bb24: {
        _46 = move ((_42 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<(), OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _46) -> [return: bb30, unwind continue];
    }

    bb25: {
        _48 = <Result<bool, OptionsError> as Try>::branch(move _49) -> [return: bb26, unwind continue];
    }

    bb26: {
        _51 = discriminant(_48);
        switchInt(move _51) -> [0: bb27, 1: bb28, otherwise: bb7];
    }

    bb27: {
        _53 = ((_48 as Continue).0: bool);
        switchInt(_53) -> [0: bb36, otherwise: bb29];
    }

    bb28: {
        _52 = move ((_48 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<(), OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _52) -> [return: bb30, unwind continue];
    }

    bb29: {
        _0 = Result::<(), OptionsError>::Ok(const ());
        goto -> bb30;
    }

    bb30: {
        return;
    }

    bb31: {
        _59 = deref_copy (*_19);
        _26 = const {alloc24: &Arg};
        _25 = OptionsError::Useless(_59, const false, _26);
        _0 = Result::<(), OptionsError>::Err(move _25);
        goto -> bb30;
    }

    bb32: {
        _34 = const {alloc49: &Arg};
        _35 = const {alloc24: &Arg};
        _33 = OptionsError::Useless(_34, const false, _35);
        _0 = Result::<(), OptionsError>::Err(move _33);
        goto -> bb30;
    }

    bb33: {
        _38 = const {alloc9: &Arg};
        _37 = MatchedFlags::<'_>::has(_1, _38) -> [return: bb17, unwind continue];
    }

    bb34: {
        _44 = const {alloc6: &Arg};
        _43 = MatchedFlags::<'_>::has(_1, _44) -> [return: bb21, unwind continue];
    }

    bb35: {
        _50 = const {alloc8: &Arg};
        _49 = MatchedFlags::<'_>::has(_1, _50) -> [return: bb25, unwind continue];
    }

    bb36: {
        _55 = const {alloc9: &Arg};
        _56 = const {alloc6: &Arg};
        _57 = const {alloc8: &Arg};
        _54 = OptionsError::Useless2(_55, _56, _57);
        _0 = Result::<(), OptionsError>::Err(move _54);
        goto -> bb30;
    }
}

alloc49 (static: GIT, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4354<imm>  
    0x20  03 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4354 (size: 3, align: 1) {
    67 69 74                                         git
}

alloc41 (static: TIME, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4293<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4301<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 74 __ __ __ __ __ __  .........t
}

alloc4293 (size: 64, align: 8) {
    0x00  alloc4292<imm> 08 00 00 00 00 00 00 00  ........
    0x10  alloc4294<imm> 07 00 00 00 00 00 00 00  ........
    0x20  alloc4295<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4296<imm> 07 00 00 00 00 00 00 00  ........
}

alloc4292 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4294 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4295 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4296 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4301 (size: 4, align: 1) {
    74 69 6d 65                                      time
}

alloc40 (static: BLOCKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4288<imm>  
    0x20  06 00 00 00 00 00 00 00 01 53 __ __ __ __ __ __  .........S
}

alloc4288 (size: 6, align: 1) {
    62 6c 6f 63 6b 73                                blocks
}

alloc37 (static: LINKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4273<imm>  
    0x20  05 00 00 00 00 00 00 00 01 48 __ __ __ __ __ __  .........H
}

alloc4273 (size: 5, align: 1) {
    6c 69 6e 6b 73                                   links
}

alloc36 (static: INODE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4268<imm>  
    0x20  05 00 00 00 00 00 00 00 01 69 __ __ __ __ __ __  .........i
}

alloc4268 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc35 (static: HEADER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4258<imm>  
    0x20  06 00 00 00 00 00 00 00 01 68 __ __ __ __ __ __  .........h
}

alloc4258 (size: 6, align: 1) {
    68 65 61 64 65 72                                header
}

alloc34 (static: NUMERIC, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4253<imm>  
    0x20  07 00 00 00 00 00 00 00 01 6e __ __ __ __ __ __  .........n
}

alloc4253 (size: 7, align: 1) {
    6e 75 6d 65 72 69 63                             numeric
}

alloc33 (static: GROUP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4248<imm>  
    0x20  05 00 00 00 00 00 00 00 01 67 __ __ __ __ __ __  .........g
}

alloc4248 (size: 5, align: 1) {
    67 72 6f 75 70                                   group
}

alloc32 (static: BYTES, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4243<imm>  
    0x20  05 00 00 00 00 00 00 00 01 42 __ __ __ __ __ __  .........B
}

alloc4243 (size: 5, align: 1) {
    62 79 74 65 73                                   bytes
}

alloc31 (static: BINARY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4238<imm>  
    0x20  06 00 00 00 00 00 00 00 01 62 __ __ __ __ __ __  .........b
}

alloc4238 (size: 6, align: 1) {
    62 69 6e 61 72 79                                binary
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc9 (static: LEVEL, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4186<imm>  
    0x20  05 00 00 00 00 00 00 00 01 4c __ __ __ __ __ __  .........L
}

alloc4186 (size: 5, align: 1) {
    6c 65 76 65 6c                                   level
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

alloc6 (static: RECURSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4132<imm>  
    0x20  07 00 00 00 00 00 00 00 01 52 __ __ __ __ __ __  .........R
}

alloc4132 (size: 7, align: 1) {
    72 65 63 75 72 73 65                             recurse
}

fn view::<impl at src/options/view.rs:107:1: 107:19>::deduce(_1: &MatchedFlags<'_>) -> Result<grid::Options, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::grid::Options, options::error::OptionsError>;
    let _2: output::grid::Options;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _4: std::result::Result<bool, options::error::OptionsError>;
    let _5: &options::parser::Arg;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _8: bool;
    scope 1 {
        debug grid => _2;
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = const {alloc26: &Arg};
        _4 = MatchedFlags::<'_>::has(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<bool, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: bool);
        _2 = grid::Options { across: _8 };
        _0 = Result::<grid::Options, OptionsError>::Ok(_2);
        goto -> bb6;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<grid::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

alloc26 (static: ACROSS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4127<imm>  
    0x20  06 00 00 00 00 00 00 00 01 78 __ __ __ __ __ __  .........x
}

alloc4127 (size: 6, align: 1) {
    61 63 72 6f 73 73                                across
}

fn view::<impl at src/options/view.rs:118:1: 118:22>::deduce_tree(_1: &MatchedFlags<'_>) -> Result<details::Options, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::details::Options, options::error::OptionsError>;
    let _2: output::details::Options;
    let mut _3: std::option::Option<output::table::Options>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _7: std::result::Result<bool, options::error::OptionsError>;
    let _8: &options::parser::Arg;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _11: bool;
    scope 1 {
        debug details => _2;
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _3 = Option::<table::Options>::None;
        _5 = const _;
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _8 = const {alloc50: &Arg};
        _7 = MatchedFlags::<'_>::has(_1, _8) -> [return: bb3, unwind continue];
    }

    bb2: {
        _4 = const false;
        goto -> bb8;
    }

    bb3: {
        _6 = <Result<bool, OptionsError> as Try>::branch(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_6 as Continue).0: bool);
        _4 = _11;
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb8: {
        _2 = details::Options { table: move _3, header: const false, xattr: move _4 };
        _0 = Result::<details::Options, OptionsError>::Ok(move _2);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

alloc50 (static: EXTENDED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4359<imm>  
    0x20  08 00 00 00 00 00 00 00 01 40 __ __ __ __ __ __  .........@
}

alloc4359 (size: 8, align: 1) {
    65 78 74 65 6e 64 65 64                          extended
}

fn view::<impl at src/options/view.rs:118:1: 118:22>::deduce_long(_1: &MatchedFlags<'_>, _2: &V) -> Result<details::Options, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::details::Options, options::error::OptionsError>;
    let mut _3: bool;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _5: std::result::Result<bool, options::error::OptionsError>;
    let _6: &options::parser::Arg;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _9: bool;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _11: std::result::Result<bool, options::error::OptionsError>;
    let _12: &options::parser::Arg;
    let mut _13: isize;
    let _14: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _15: bool;
    let mut _16: options::error::OptionsError;
    let _17: &options::parser::Arg;
    let _18: &options::parser::Arg;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _20: std::result::Result<bool, options::error::OptionsError>;
    let _21: &options::parser::Arg;
    let mut _22: isize;
    let _23: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _24: bool;
    let mut _25: options::error::OptionsError;
    let _26: &options::parser::Arg;
    let _27: &options::parser::Arg;
    let mut _28: output::details::Options;
    let mut _29: std::option::Option<output::table::Options>;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::table::Options>;
    let mut _31: std::result::Result<output::table::Options, options::error::OptionsError>;
    let mut _32: isize;
    let _33: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _34: output::table::Options;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _36: std::result::Result<bool, options::error::OptionsError>;
    let _37: &options::parser::Arg;
    let mut _38: isize;
    let _39: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _44: std::result::Result<bool, options::error::OptionsError>;
    let _45: &options::parser::Arg;
    let mut _46: isize;
    let _47: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _48: bool;
    scope 1 {
        debug residual => _8;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _9;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _14;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _15;
        scope 8 {
        }
    }
    scope 9 {
        debug residual => _23;
        scope 10 {
        }
    }
    scope 11 {
        debug val => _24;
        scope 12 {
        }
    }
    scope 13 {
        debug residual => _33;
        scope 14 {
        }
    }
    scope 15 {
        debug val => _34;
        scope 16 {
        }
    }
    scope 17 {
        debug residual => _39;
        scope 18 {
        }
    }
    scope 19 {
        debug val => _40;
        scope 20 {
        }
    }
    scope 21 {
        debug residual => _47;
        scope 22 {
        }
    }
    scope 23 {
        debug val => _48;
        scope 24 {
        }
    }

    bb0: {
        _3 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb17, otherwise: bb2];
    }

    bb2: {
        _6 = const {alloc26: &Arg};
        _5 = MatchedFlags::<'_>::has(_1, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Result<bool, OptionsError> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_4 as Continue).0: bool);
        switchInt(_9) -> [0: bb12, otherwise: bb34];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _8) -> [return: bb33, unwind continue];
    }

    bb8: {
        _10 = <Result<bool, OptionsError> as Try>::branch(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb6];
    }

    bb10: {
        _15 = ((_10 as Continue).0: bool);
        switchInt(_15) -> [0: bb35, otherwise: bb12];
    }

    bb11: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _14) -> [return: bb33, unwind continue];
    }

    bb12: {
        _21 = const {alloc23: &Arg};
        _20 = MatchedFlags::<'_>::has(_1, _21) -> [return: bb13, unwind continue];
    }

    bb13: {
        _19 = <Result<bool, OptionsError> as Try>::branch(move _20) -> [return: bb14, unwind continue];
    }

    bb14: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb15, 1: bb16, otherwise: bb6];
    }

    bb15: {
        _24 = ((_19 as Continue).0: bool);
        switchInt(_24) -> [0: bb17, otherwise: bb36];
    }

    bb16: {
        _23 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _23) -> [return: bb33, unwind continue];
    }

    bb17: {
        _31 = view::<impl table::Options>::deduce::<V>(_1, _2) -> [return: bb18, unwind continue];
    }

    bb18: {
        _30 = <Result<table::Options, OptionsError> as Try>::branch(move _31) -> [return: bb19, unwind continue];
    }

    bb19: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb20, 1: bb21, otherwise: bb6];
    }

    bb20: {
        _34 = move ((_30 as Continue).0: output::table::Options);
        _29 = Option::<table::Options>::Some(move _34);
        _37 = const {alloc35: &Arg};
        _36 = MatchedFlags::<'_>::has(_1, _37) -> [return: bb22, unwind continue];
    }

    bb21: {
        _33 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _33) -> [return: bb33, unwind continue];
    }

    bb22: {
        _35 = <Result<bool, OptionsError> as Try>::branch(move _36) -> [return: bb23, unwind continue];
    }

    bb23: {
        _38 = discriminant(_35);
        switchInt(move _38) -> [0: bb24, 1: bb25, otherwise: bb6];
    }

    bb24: {
        _40 = ((_35 as Continue).0: bool);
        _42 = const _;
        switchInt(move _42) -> [0: bb27, otherwise: bb26];
    }

    bb25: {
        _39 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _39) -> [return: bb33, unwind continue];
    }

    bb26: {
        _45 = const {alloc50: &Arg};
        _44 = MatchedFlags::<'_>::has(_1, _45) -> [return: bb28, unwind continue];
    }

    bb27: {
        _41 = const false;
        goto -> bb32;
    }

    bb28: {
        _43 = <Result<bool, OptionsError> as Try>::branch(move _44) -> [return: bb29, unwind continue];
    }

    bb29: {
        _46 = discriminant(_43);
        switchInt(move _46) -> [0: bb30, 1: bb31, otherwise: bb6];
    }

    bb30: {
        _48 = ((_43 as Continue).0: bool);
        _41 = _48;
        goto -> bb32;
    }

    bb31: {
        _47 = move ((_43 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<details::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _47) -> [return: bb33, unwind continue];
    }

    bb32: {
        _28 = details::Options { table: move _29, header: _40, xattr: move _41 };
        _0 = Result::<details::Options, OptionsError>::Ok(move _28);
        goto -> bb33;
    }

    bb33: {
        return;
    }

    bb34: {
        _12 = const {alloc25: &Arg};
        _11 = MatchedFlags::<'_>::has(_1, _12) -> [return: bb8, unwind continue];
    }

    bb35: {
        _17 = const {alloc26: &Arg};
        _18 = const {alloc24: &Arg};
        _16 = OptionsError::Useless(_17, const true, _18);
        _0 = Result::<details::Options, OptionsError>::Err(move _16);
        goto -> bb33;
    }

    bb36: {
        _26 = const {alloc23: &Arg};
        _27 = const {alloc24: &Arg};
        _25 = OptionsError::Useless(_26, const true, _27);
        _0 = Result::<details::Options, OptionsError>::Err(move _25);
        goto -> bb33;
    }
}

alloc50 (static: EXTENDED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4359<imm>  
    0x20  08 00 00 00 00 00 00 00 01 40 __ __ __ __ __ __  .........@
}

alloc4359 (size: 8, align: 1) {
    65 78 74 65 6e 64 65 64                          extended
}

alloc35 (static: HEADER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4258<imm>  
    0x20  06 00 00 00 00 00 00 00 01 68 __ __ __ __ __ __  .........h
}

alloc4258 (size: 6, align: 1) {
    68 65 61 64 65 72                                header
}

alloc26 (static: ACROSS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4127<imm>  
    0x20  06 00 00 00 00 00 00 00 01 78 __ __ __ __ __ __  .........x
}

alloc4127 (size: 6, align: 1) {
    61 63 72 6f 73 73                                across
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc23 (static: ONE_LINE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4112<imm>  
    0x20  07 00 00 00 00 00 00 00 01 31 __ __ __ __ __ __  .........1
}

alloc4112 (size: 7, align: 1) {
    6f 6e 65 6c 69 6e 65                             oneline
}

fn view::<impl at src/options/view.rs:148:1: 148:19>::deduce(_1: &V) -> Result<TerminalWidth, OptionsError> {
    debug vars => _1;
    let mut _0: std::result::Result<output::TerminalWidth, options::error::OptionsError>;
    let mut _2: std::option::Option<std::string::String>;
    let mut _3: std::option::Option<std::ffi::OsString>;
    let mut _4: &str;
    let mut _5: &&str;
    let mut _6: isize;
    let mut _8: std::result::Result<usize, std::num::ParseIntError>;
    let _9: &str;
    let mut _10: &std::string::String;
    let mut _11: isize;
    let mut _13: output::TerminalWidth;
    let mut _16: &str;
    let mut _17: &&str;
    let mut _18: options::error::OptionsError;
    let mut _19: std::string::String;
    let mut _20: output::TerminalWidth;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: isize;
    scope 1 {
        debug columns => _7;
        let _7: std::string::String;
        let _12: usize;
        let _14: std::num::ParseIntError;
        scope 2 {
            debug width => _12;
        }
        scope 3 {
            debug e => _14;
            let _15: options::error::NumberSource;
            scope 4 {
                debug source => _15;
            }
        }
    }

    bb0: {
        _21 = const false;
        _22 = const false;
        _5 = const {alloc54: &&str};
        _4 = (*_5);
        _3 = <V as vars::Vars>::get(_1, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<OsString>::and_then::<String, {closure@src/options/view.rs:152:65: 152:68}>(move _3, const ZeroSized: {closure@src/options/view.rs:152:65: 152:68}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _22 = const true;
        _6 = discriminant(_2);
        switchInt(move _6) -> [1: bb3, otherwise: bb10];
    }

    bb3: {
        _22 = const false;
        _21 = const true;
        _7 = move ((_2 as Some).0: std::string::String);
        _10 = &_7;
        _9 = <String as Deref>::deref(move _10) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _8 = core::str::<impl str>::parse::<usize>(_9) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _14 = move ((_8 as Err).0: std::num::ParseIntError);
        _17 = const {alloc54: &&str};
        _16 = (*_17);
        _15 = NumberSource::Env(move _16);
        _21 = const false;
        _19 = move _7;
        _18 = OptionsError::FailedParse(move _19, move _15, move _14);
        _0 = Result::<TerminalWidth, OptionsError>::Err(move _18);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _12 = ((_8 as Ok).0: usize);
        _13 = TerminalWidth::Set(_12);
        _0 = Result::<TerminalWidth, OptionsError>::Ok(move _13);
        goto -> bb9;
    }

    bb9: {
        switchInt(_21) -> [0: bb11, otherwise: bb14];
    }

    bb10: {
        _20 = TerminalWidth::Automatic;
        _0 = Result::<TerminalWidth, OptionsError>::Ok(move _20);
        goto -> bb18;
    }

    bb11: {
        _21 = const false;
        goto -> bb18;
    }

    bb12 (cleanup): {
        drop(_7) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        drop(_7) -> [return: bb11, unwind continue];
    }

    bb15: {
        _22 = const false;
        return;
    }

    bb16: {
        switchInt(_22) -> [0: bb15, otherwise: bb17];
    }

    bb17: {
        drop(((_2 as Some).0: std::string::String)) -> [return: bb15, unwind continue];
    }

    bb18: {
        _23 = discriminant(_2);
        switchInt(move _23) -> [1: bb16, otherwise: bb15];
    }
}

alloc54 (static: COLUMNS, size: 16, align: 8) {
    alloc1251<imm> 07 00 00 00 00 00 00 00  ........
}

alloc1251 (size: 7, align: 1) {
    43 4f 4c 55 4d 4e 53                             COLUMNS
}

fn view::<impl at src/options/view.rs:148:1: 148:19>::deduce::{closure#0}(_1: {closure@src/options/view.rs:152:65: 152:68}, _2: OsString) -> Option<String> {
    debug s => _2;
    let mut _0: std::option::Option<std::string::String>;
    let mut _3: std::result::Result<std::string::String, std::ffi::OsString>;

    bb0: {
        _3 = OsString::into_string(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<String, OsString>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn view::<impl at src/options/view.rs:170:1: 170:18>::deduce(_1: &V) -> Result<RowThreshold, OptionsError> {
    debug vars => _1;
    let mut _0: std::result::Result<output::grid_details::RowThreshold, options::error::OptionsError>;
    let mut _2: std::option::Option<std::string::String>;
    let mut _3: std::option::Option<std::ffi::OsString>;
    let mut _4: &str;
    let mut _5: &&str;
    let mut _6: isize;
    let mut _8: std::result::Result<usize, std::num::ParseIntError>;
    let _9: &str;
    let mut _10: &std::string::String;
    let mut _11: isize;
    let mut _13: output::grid_details::RowThreshold;
    let mut _16: &str;
    let mut _17: &&str;
    let mut _18: options::error::OptionsError;
    let mut _19: std::string::String;
    let mut _20: output::grid_details::RowThreshold;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: isize;
    scope 1 {
        debug columns => _7;
        let _7: std::string::String;
        let _12: usize;
        let _14: std::num::ParseIntError;
        scope 2 {
            debug rows => _12;
        }
        scope 3 {
            debug e => _14;
            let _15: options::error::NumberSource;
            scope 4 {
                debug source => _15;
            }
        }
    }

    bb0: {
        _21 = const false;
        _22 = const false;
        _5 = const {alloc55: &&str};
        _4 = (*_5);
        _3 = <V as vars::Vars>::get(_1, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<OsString>::and_then::<String, {closure@src/options/view.rs:174:71: 174:74}>(move _3, const ZeroSized: {closure@src/options/view.rs:174:71: 174:74}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _22 = const true;
        _6 = discriminant(_2);
        switchInt(move _6) -> [1: bb3, otherwise: bb10];
    }

    bb3: {
        _22 = const false;
        _21 = const true;
        _7 = move ((_2 as Some).0: std::string::String);
        _10 = &_7;
        _9 = <String as Deref>::deref(move _10) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _8 = core::str::<impl str>::parse::<usize>(_9) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _14 = move ((_8 as Err).0: std::num::ParseIntError);
        _17 = const {alloc55: &&str};
        _16 = (*_17);
        _15 = NumberSource::Env(move _16);
        _21 = const false;
        _19 = move _7;
        _18 = OptionsError::FailedParse(move _19, move _15, move _14);
        _0 = Result::<RowThreshold, OptionsError>::Err(move _18);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _12 = ((_8 as Ok).0: usize);
        _13 = RowThreshold::MinimumRows(_12);
        _0 = Result::<RowThreshold, OptionsError>::Ok(move _13);
        goto -> bb9;
    }

    bb9: {
        switchInt(_21) -> [0: bb11, otherwise: bb14];
    }

    bb10: {
        _20 = RowThreshold::AlwaysGrid;
        _0 = Result::<RowThreshold, OptionsError>::Ok(move _20);
        goto -> bb18;
    }

    bb11: {
        _21 = const false;
        goto -> bb18;
    }

    bb12 (cleanup): {
        drop(_7) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        drop(_7) -> [return: bb11, unwind continue];
    }

    bb15: {
        _22 = const false;
        return;
    }

    bb16: {
        switchInt(_22) -> [0: bb15, otherwise: bb17];
    }

    bb17: {
        drop(((_2 as Some).0: std::string::String)) -> [return: bb15, unwind continue];
    }

    bb18: {
        _23 = discriminant(_2);
        switchInt(move _23) -> [1: bb16, otherwise: bb15];
    }
}

alloc55 (static: EXA_GRID_ROWS, size: 16, align: 8) {
    alloc1263<imm> 0d 00 00 00 00 00 00 00  ........
}

alloc1263 (size: 13, align: 1) {
    45 58 41 5f 47 52 49 44 5f 52 4f 57 53           EXA_GRID_ROWS
}

fn view::<impl at src/options/view.rs:170:1: 170:18>::deduce::{closure#0}(_1: {closure@src/options/view.rs:174:71: 174:74}, _2: OsString) -> Option<String> {
    debug s => _2;
    let mut _0: std::option::Option<std::string::String>;
    let mut _3: std::result::Result<std::string::String, std::ffi::OsString>;

    bb0: {
        _3 = OsString::into_string(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<String, OsString>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn view::<impl at src/options/view.rs:192:1: 192:18>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<table::Options, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::table::Options, options::error::OptionsError>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::time::TimeFormat>;
    let mut _4: std::result::Result<output::time::TimeFormat, options::error::OptionsError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: output::time::TimeFormat;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::table::SizeFormat>;
    let mut _9: std::result::Result<output::table::SizeFormat, options::error::OptionsError>;
    let mut _10: isize;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::table::UserFormat>;
    let mut _14: std::result::Result<output::table::UserFormat, options::error::OptionsError>;
    let mut _15: isize;
    let mut _18: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::table::Columns>;
    let mut _19: std::result::Result<output::table::Columns, options::error::OptionsError>;
    let mut _20: isize;
    let mut _23: output::table::Options;
    scope 1 {
        debug time_format => _7;
        let _11: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _12: output::table::SizeFormat;
        scope 6 {
            debug size_format => _12;
            let _16: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _17: output::table::UserFormat;
            scope 11 {
                debug user_format => _17;
                let _21: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _22: output::table::Columns;
                scope 16 {
                    debug columns => _22;
                }
                scope 17 {
                    debug residual => _21;
                    scope 18 {
                    }
                }
                scope 19 {
                    debug val => _22;
                    scope 20 {
                    }
                }
            }
            scope 12 {
                debug residual => _16;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _17;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _11;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = view::<impl TimeFormat>::deduce::<V>(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<TimeFormat, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: output::time::TimeFormat);
        _9 = view::<impl SizeFormat>::deduce(_1) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<table::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb18, unwind continue];
    }

    bb6: {
        _8 = <Result<SizeFormat, OptionsError> as Try>::branch(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: output::table::SizeFormat);
        _14 = view::<impl UserFormat>::deduce(_1) -> [return: bb10, unwind continue];
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<table::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _11) -> [return: bb18, unwind continue];
    }

    bb10: {
        _13 = <Result<UserFormat, OptionsError> as Try>::branch(move _14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _17 = ((_13 as Continue).0: output::table::UserFormat);
        _19 = view::<impl Columns>::deduce(_1) -> [return: bb14, unwind continue];
    }

    bb13: {
        _16 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<table::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _16) -> [return: bb18, unwind continue];
    }

    bb14: {
        _18 = <Result<Columns, OptionsError> as Try>::branch(move _19) -> [return: bb15, unwind continue];
    }

    bb15: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb16, 1: bb17, otherwise: bb4];
    }

    bb16: {
        _22 = ((_18 as Continue).0: output::table::Columns);
        _23 = table::Options { size_format: _12, time_format: _7, user_format: _17, columns: _22 };
        _0 = Result::<table::Options, OptionsError>::Ok(move _23);
        goto -> bb18;
    }

    bb17: {
        _21 = move ((_18 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<table::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _21) -> [return: bb18, unwind continue];
    }

    bb18: {
        return;
    }
}

fn view::<impl at src/options/view.rs:203:1: 203:13>::deduce(_1: &MatchedFlags<'_>) -> Result<Columns, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::table::Columns, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::table::TimeTypes>;
    let mut _3: std::result::Result<output::table::TimeTypes, options::error::OptionsError>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _6: output::table::TimeTypes;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _8: std::result::Result<bool, options::error::OptionsError>;
    let _9: &options::parser::Arg;
    let mut _10: isize;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _14: std::result::Result<bool, options::error::OptionsError>;
    let _15: &options::parser::Arg;
    let mut _16: isize;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _20: std::result::Result<bool, options::error::OptionsError>;
    let _21: &options::parser::Arg;
    let mut _22: isize;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _26: std::result::Result<bool, options::error::OptionsError>;
    let _27: &options::parser::Arg;
    let mut _28: isize;
    let mut _31: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _32: std::result::Result<bool, options::error::OptionsError>;
    let _33: &options::parser::Arg;
    let mut _34: isize;
    let mut _37: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _38: std::result::Result<bool, options::error::OptionsError>;
    let _39: &options::parser::Arg;
    let mut _40: isize;
    let mut _44: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _45: std::result::Result<bool, options::error::OptionsError>;
    let _46: &options::parser::Arg;
    let mut _47: isize;
    let mut _51: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _52: std::result::Result<bool, options::error::OptionsError>;
    let _53: &options::parser::Arg;
    let mut _54: isize;
    let mut _58: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _59: std::result::Result<bool, options::error::OptionsError>;
    let _60: &options::parser::Arg;
    let mut _61: isize;
    let mut _64: output::table::Columns;
    scope 1 {
        debug time_types => _6;
        let _11: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _12: bool;
        scope 6 {
            debug git => _12;
            let _17: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _18: bool;
            scope 11 {
                debug blocks => _18;
                let _23: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _24: bool;
                scope 16 {
                    debug group => _24;
                    let _29: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                    let _30: bool;
                    scope 21 {
                        debug inode => _30;
                        let _35: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                        let _36: bool;
                        scope 26 {
                            debug links => _36;
                            let _41: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                            let _42: bool;
                            scope 31 {
                                debug octal => _42;
                                let _43: bool;
                                let _48: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                                let _49: bool;
                                scope 36 {
                                    debug permissions => _43;
                                    let _50: bool;
                                    let _55: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                                    let _56: bool;
                                    scope 41 {
                                        debug filesize => _50;
                                        let _57: bool;
                                        let _62: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                                        let _63: bool;
                                        scope 46 {
                                            debug user => _57;
                                        }
                                        scope 47 {
                                            debug residual => _62;
                                            scope 48 {
                                            }
                                        }
                                        scope 49 {
                                            debug val => _63;
                                            scope 50 {
                                            }
                                        }
                                    }
                                    scope 42 {
                                        debug residual => _55;
                                        scope 43 {
                                        }
                                    }
                                    scope 44 {
                                        debug val => _56;
                                        scope 45 {
                                        }
                                    }
                                }
                                scope 37 {
                                    debug residual => _48;
                                    scope 38 {
                                    }
                                }
                                scope 39 {
                                    debug val => _49;
                                    scope 40 {
                                    }
                                }
                            }
                            scope 32 {
                                debug residual => _41;
                                scope 33 {
                                }
                            }
                            scope 34 {
                                debug val => _42;
                                scope 35 {
                                }
                            }
                        }
                        scope 27 {
                            debug residual => _35;
                            scope 28 {
                            }
                        }
                        scope 29 {
                            debug val => _36;
                            scope 30 {
                            }
                        }
                    }
                    scope 22 {
                        debug residual => _29;
                        scope 23 {
                        }
                    }
                    scope 24 {
                        debug val => _30;
                        scope 25 {
                        }
                    }
                }
                scope 17 {
                    debug residual => _23;
                    scope 18 {
                    }
                }
                scope 19 {
                    debug val => _24;
                    scope 20 {
                    }
                }
            }
            scope 12 {
                debug residual => _17;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _18;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _11;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _5;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _6;
        scope 5 {
        }
    }

    bb0: {
        _3 = view::<impl TimeTypes>::deduce(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<TimeTypes, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: output::table::TimeTypes);
        _9 = const {alloc49: &Arg};
        _8 = MatchedFlags::<'_>::has(_1, _9) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _5) -> [return: bb42, unwind continue];
    }

    bb6: {
        _7 = <Result<bool, OptionsError> as Try>::branch(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_7 as Continue).0: bool);
        _15 = const {alloc40: &Arg};
        _14 = MatchedFlags::<'_>::has(_1, _15) -> [return: bb10, unwind continue];
    }

    bb9: {
        _11 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _11) -> [return: bb42, unwind continue];
    }

    bb10: {
        _13 = <Result<bool, OptionsError> as Try>::branch(move _14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _16 = discriminant(_13);
        switchInt(move _16) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _18 = ((_13 as Continue).0: bool);
        _21 = const {alloc33: &Arg};
        _20 = MatchedFlags::<'_>::has(_1, _21) -> [return: bb14, unwind continue];
    }

    bb13: {
        _17 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _17) -> [return: bb42, unwind continue];
    }

    bb14: {
        _19 = <Result<bool, OptionsError> as Try>::branch(move _20) -> [return: bb15, unwind continue];
    }

    bb15: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb16, 1: bb17, otherwise: bb4];
    }

    bb16: {
        _24 = ((_19 as Continue).0: bool);
        _27 = const {alloc36: &Arg};
        _26 = MatchedFlags::<'_>::has(_1, _27) -> [return: bb18, unwind continue];
    }

    bb17: {
        _23 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _23) -> [return: bb42, unwind continue];
    }

    bb18: {
        _25 = <Result<bool, OptionsError> as Try>::branch(move _26) -> [return: bb19, unwind continue];
    }

    bb19: {
        _28 = discriminant(_25);
        switchInt(move _28) -> [0: bb20, 1: bb21, otherwise: bb4];
    }

    bb20: {
        _30 = ((_25 as Continue).0: bool);
        _33 = const {alloc37: &Arg};
        _32 = MatchedFlags::<'_>::has(_1, _33) -> [return: bb22, unwind continue];
    }

    bb21: {
        _29 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _29) -> [return: bb42, unwind continue];
    }

    bb22: {
        _31 = <Result<bool, OptionsError> as Try>::branch(move _32) -> [return: bb23, unwind continue];
    }

    bb23: {
        _34 = discriminant(_31);
        switchInt(move _34) -> [0: bb24, 1: bb25, otherwise: bb4];
    }

    bb24: {
        _36 = ((_31 as Continue).0: bool);
        _39 = const {alloc51: &Arg};
        _38 = MatchedFlags::<'_>::has(_1, _39) -> [return: bb26, unwind continue];
    }

    bb25: {
        _35 = move ((_31 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _35) -> [return: bb42, unwind continue];
    }

    bb26: {
        _37 = <Result<bool, OptionsError> as Try>::branch(move _38) -> [return: bb27, unwind continue];
    }

    bb27: {
        _40 = discriminant(_37);
        switchInt(move _40) -> [0: bb28, 1: bb29, otherwise: bb4];
    }

    bb28: {
        _42 = ((_37 as Continue).0: bool);
        _46 = const {alloc45: &Arg};
        _45 = MatchedFlags::<'_>::has(_1, _46) -> [return: bb30, unwind continue];
    }

    bb29: {
        _41 = move ((_37 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _41) -> [return: bb42, unwind continue];
    }

    bb30: {
        _44 = <Result<bool, OptionsError> as Try>::branch(move _45) -> [return: bb31, unwind continue];
    }

    bb31: {
        _47 = discriminant(_44);
        switchInt(move _47) -> [0: bb32, 1: bb33, otherwise: bb4];
    }

    bb32: {
        _49 = ((_44 as Continue).0: bool);
        _43 = Not(_49);
        _53 = const {alloc46: &Arg};
        _52 = MatchedFlags::<'_>::has(_1, _53) -> [return: bb34, unwind continue];
    }

    bb33: {
        _48 = move ((_44 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _48) -> [return: bb42, unwind continue];
    }

    bb34: {
        _51 = <Result<bool, OptionsError> as Try>::branch(move _52) -> [return: bb35, unwind continue];
    }

    bb35: {
        _54 = discriminant(_51);
        switchInt(move _54) -> [0: bb36, 1: bb37, otherwise: bb4];
    }

    bb36: {
        _56 = ((_51 as Continue).0: bool);
        _50 = Not(_56);
        _60 = const {alloc47: &Arg};
        _59 = MatchedFlags::<'_>::has(_1, _60) -> [return: bb38, unwind continue];
    }

    bb37: {
        _55 = move ((_51 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _55) -> [return: bb42, unwind continue];
    }

    bb38: {
        _58 = <Result<bool, OptionsError> as Try>::branch(move _59) -> [return: bb39, unwind continue];
    }

    bb39: {
        _61 = discriminant(_58);
        switchInt(move _61) -> [0: bb40, 1: bb41, otherwise: bb4];
    }

    bb40: {
        _63 = ((_58 as Continue).0: bool);
        _57 = Not(_63);
        _64 = Columns { time_types: _6, inode: _30, links: _36, blocks: _18, group: _24, git: _12, octal: _42, permissions: _43, filesize: _50, user: _57 };
        _0 = Result::<Columns, OptionsError>::Ok(move _64);
        goto -> bb42;
    }

    bb41: {
        _62 = move ((_58 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<Columns, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _62) -> [return: bb42, unwind continue];
    }

    bb42: {
        return;
    }
}

alloc51 (static: OCTAL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4364<imm>  
    0x20  11 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4364 (size: 17, align: 1) {
    0x00  6f 63 74 61 6c 2d 70 65 72 6d 69 73 73 69 6f 6e  octal-permission
    0x10  73                                               s
}

alloc49 (static: GIT, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4354<imm>  
    0x20  03 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4354 (size: 3, align: 1) {
    67 69 74                                         git
}

alloc47 (static: NO_USER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4339<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4339 (size: 7, align: 1) {
    6e 6f 2d 75 73 65 72                             no-user
}

alloc46 (static: NO_FILESIZE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4334<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4334 (size: 11, align: 1) {
    6e 6f 2d 66 69 6c 65 73 69 7a 65                 no-filesize
}

alloc45 (static: NO_PERMISSIONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4329<imm>  
    0x20  0e 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4329 (size: 14, align: 1) {
    6e 6f 2d 70 65 72 6d 69 73 73 69 6f 6e 73        no-permissions
}

alloc40 (static: BLOCKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4288<imm>  
    0x20  06 00 00 00 00 00 00 00 01 53 __ __ __ __ __ __  .........S
}

alloc4288 (size: 6, align: 1) {
    62 6c 6f 63 6b 73                                blocks
}

alloc37 (static: LINKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4273<imm>  
    0x20  05 00 00 00 00 00 00 00 01 48 __ __ __ __ __ __  .........H
}

alloc4273 (size: 5, align: 1) {
    6c 69 6e 6b 73                                   links
}

alloc36 (static: INODE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4268<imm>  
    0x20  05 00 00 00 00 00 00 00 01 69 __ __ __ __ __ __  .........i
}

alloc4268 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc33 (static: GROUP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4248<imm>  
    0x20  05 00 00 00 00 00 00 00 01 67 __ __ __ __ __ __  .........g
}

alloc4248 (size: 5, align: 1) {
    67 72 6f 75 70                                   group
}

fn view::<impl at src/options/view.rs:223:1: 223:16>::deduce(_1: &MatchedFlags<'_>) -> Result<SizeFormat, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::table::SizeFormat, options::error::OptionsError>;
    let _2: std::option::Option<&options::parser::Flag>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&options::parser::Flag>>;
    let mut _4: std::result::Result<std::option::Option<&options::parser::Flag>, options::error::OptionsError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: std::option::Option<&options::parser::Flag>;
    let mut _8: output::table::SizeFormat;
    let mut _9: isize;
    let mut _12: bool;
    let _13: &options::parser::Arg;
    let mut _16: bool;
    let _17: &options::parser::Arg;
    let mut _18: &options::parser::Flag;
    let mut _19: &options::parser::Flag;
    scope 1 {
        debug flag => _2;
        let _10: &options::parser::Flag;
        let _11: &&options::parser::Flag;
        let _14: &options::parser::Flag;
        let _15: &&options::parser::Flag;
        scope 6 {
            debug f => _10;
            debug f => _11;
        }
        scope 7 {
            debug f => _14;
            debug f => _15;
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = MatchedFlags::<'_>::has_where::<{closure@src/options/view.rs:234:38: 234:41}>(_1, const ZeroSized: {closure@src/options/view.rs:234:38: 234:41}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<Option<&Flag>, OptionsError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: std::option::Option<&options::parser::Flag>);
        _2 = _7;
        _9 = discriminant(_2);
        switchInt(move _9) -> [1: bb7, otherwise: bb6];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<SizeFormat, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb14, unwind continue];
    }

    bb6: {
        _8 = SizeFormat::DecimalBytes;
        goto -> bb13;
    }

    bb7: {
        _11 = &((_2 as Some).0: &options::parser::Flag);
        _18 = deref_copy (*_11);
        _13 = const {alloc31: &Arg};
        _12 = Flag::matches(_18, _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _12) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _10 = ((_2 as Some).0: &options::parser::Flag);
        _8 = SizeFormat::BinaryBytes;
        goto -> bb13;
    }

    bb10: {
        _15 = &((_2 as Some).0: &options::parser::Flag);
        _19 = deref_copy (*_15);
        _17 = const {alloc32: &Arg};
        _16 = Flag::matches(_19, _17) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _16) -> [0: bb6, otherwise: bb12];
    }

    bb12: {
        _14 = ((_2 as Some).0: &options::parser::Flag);
        _8 = SizeFormat::JustBytes;
        goto -> bb13;
    }

    bb13: {
        _0 = Result::<SizeFormat, OptionsError>::Ok(move _8);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

alloc32 (static: BYTES, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4243<imm>  
    0x20  05 00 00 00 00 00 00 00 01 42 __ __ __ __ __ __  .........B
}

alloc4243 (size: 5, align: 1) {
    62 79 74 65 73                                   bytes
}

alloc31 (static: BINARY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4238<imm>  
    0x20  06 00 00 00 00 00 00 00 01 62 __ __ __ __ __ __  .........b
}

alloc4238 (size: 6, align: 1) {
    62 69 6e 61 72 79                                binary
}

fn view::<impl at src/options/view.rs:223:1: 223:16>::deduce::{closure#0}(_1: &{closure@src/options/view.rs:234:38: 234:41}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let _5: &options::parser::Arg;

    bb0: {
        _4 = const {alloc31: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const {alloc32: &Arg};
        _0 = Flag::matches(_2, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

alloc32 (static: BYTES, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4243<imm>  
    0x20  05 00 00 00 00 00 00 00 01 42 __ __ __ __ __ __  .........B
}

alloc4243 (size: 5, align: 1) {
    62 79 74 65 73                                   bytes
}

alloc31 (static: BINARY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4238<imm>  
    0x20  06 00 00 00 00 00 00 00 01 62 __ __ __ __ __ __  .........b
}

alloc4238 (size: 6, align: 1) {
    62 69 6e 61 72 79                                binary
}

fn view::<impl at src/options/view.rs:245:1: 245:16>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<TimeFormat, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<output::time::TimeFormat, options::error::OptionsError>;
    let _3: std::ffi::OsString;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _5: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let _6: &options::parser::Arg;
    let mut _7: isize;
    let mut _10: isize;
    let mut _12: std::option::Option<std::ffi::OsString>;
    let mut _13: &str;
    let mut _14: &&str;
    let mut _15: isize;
    let _16: &std::ffi::OsString;
    let _17: &&std::ffi::OsString;
    let mut _18: bool;
    let _19: &std::ffi::OsStr;
    let mut _20: &std::ffi::OsString;
    let mut _21: output::time::TimeFormat;
    let mut _22: bool;
    let mut _23: &&std::ffi::OsString;
    let _24: &std::ffi::OsString;
    let mut _25: output::time::TimeFormat;
    let mut _26: bool;
    let mut _27: &&std::ffi::OsString;
    let _28: &std::ffi::OsString;
    let mut _29: output::time::TimeFormat;
    let mut _30: bool;
    let mut _31: &&std::ffi::OsString;
    let _32: &std::ffi::OsString;
    let mut _33: output::time::TimeFormat;
    let mut _34: bool;
    let mut _35: &&std::ffi::OsString;
    let _36: &std::ffi::OsString;
    let mut _37: output::time::TimeFormat;
    let mut _38: options::error::OptionsError;
    let _39: &options::parser::Arg;
    let mut _40: std::ffi::OsString;
    let mut _45: &std::ffi::OsString;
    let mut _46: bool;
    scope 1 {
        debug word => _3;
        let mut _41: &&str;
        let mut _42: &&str;
        let mut _43: &&str;
        let mut _44: &&str;
    }
    scope 2 {
        debug w => _11;
        let _8: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _9: std::option::Option<&std::ffi::OsStr>;
        let _11: &std::ffi::OsStr;
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
    }
    scope 7 {
        debug t => _16;
        debug t => _17;
    }

    bb0: {
        _46 = const false;
        _6 = const {alloc44: &Arg};
        _5 = MatchedFlags::<'_>::get(_1, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_4 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _10 = discriminant(_9);
        switchInt(move _10) -> [1: bb7, otherwise: bb6];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeFormat, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _8) -> [return: bb36, unwind continue];
    }

    bb6: {
        _14 = const {alloc56: &&str};
        _13 = (*_14);
        _12 = <V as vars::Vars>::get(_2, move _13) -> [return: bb9, unwind continue];
    }

    bb7: {
        _11 = ((_9 as Some).0: &std::ffi::OsStr);
        _3 = OsStr::to_os_string(_11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _46 = const true;
        goto -> bb34;
    }

    bb9: {
        _15 = discriminant(_12);
        switchInt(move _15) -> [1: bb11, otherwise: bb10];
    }

    bb10: {
        _21 = TimeFormat::DefaultFormat;
        _0 = Result::<TimeFormat, OptionsError>::Ok(move _21);
        drop(_12) -> [return: bb36, unwind continue];
    }

    bb11: {
        _16 = &((_12 as Some).0: std::ffi::OsString);
        _17 = &_16;
        _45 = deref_copy (*_17);
        _19 = <OsString as Deref>::deref(_45) -> [return: bb12, unwind: bb32];
    }

    bb12: {
        _18 = OsStr::is_empty(_19) -> [return: bb13, unwind: bb32];
    }

    bb13: {
        switchInt(move _18) -> [0: bb14, otherwise: bb10];
    }

    bb14: {
        _20 = _16;
        _3 = <OsString as Clone>::clone(move _20) -> [return: bb15, unwind: bb32];
    }

    bb15: {
        _46 = const true;
        drop(_12) -> [return: bb34, unwind continue];
    }

    bb16: {
        switchInt(move _22) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _25 = TimeFormat::DefaultFormat;
        _0 = Result::<TimeFormat, OptionsError>::Ok(move _25);
        goto -> bb28;
    }

    bb18: {
        _28 = &_3;
        _27 = &_28;
        _43 = const _;
        _26 = <&OsString as PartialEq<&str>>::eq(move _27, _43) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        switchInt(move _26) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _29 = TimeFormat::ISOFormat;
        _0 = Result::<TimeFormat, OptionsError>::Ok(move _29);
        goto -> bb28;
    }

    bb21: {
        _32 = &_3;
        _31 = &_32;
        _42 = const _;
        _30 = <&OsString as PartialEq<&str>>::eq(move _31, _42) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        switchInt(move _30) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _33 = TimeFormat::LongISO;
        _0 = Result::<TimeFormat, OptionsError>::Ok(move _33);
        goto -> bb28;
    }

    bb24: {
        _36 = &_3;
        _35 = &_36;
        _41 = const _;
        _34 = <&OsString as PartialEq<&str>>::eq(move _35, _41) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        switchInt(move _34) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _37 = TimeFormat::FullISO;
        _0 = Result::<TimeFormat, OptionsError>::Ok(move _37);
        goto -> bb28;
    }

    bb27: {
        _39 = const {alloc44: &Arg};
        _46 = const false;
        _40 = move _3;
        _38 = OptionsError::BadArgument(_39, move _40);
        _0 = Result::<TimeFormat, OptionsError>::Err(move _38);
        goto -> bb28;
    }

    bb28: {
        switchInt(_46) -> [0: bb29, otherwise: bb35];
    }

    bb29: {
        _46 = const false;
        goto -> bb30;
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_3) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_12) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }

    bb34: {
        _24 = &_3;
        _23 = &_24;
        _44 = const _;
        _22 = <&OsString as PartialEq<&str>>::eq(move _23, _44) -> [return: bb16, unwind: bb31];
    }

    bb35: {
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb36: {
        _46 = const false;
        goto -> bb30;
    }
}

alloc56 (static: vars::TIME_STYLE, size: 16, align: 8) {
    alloc1287<imm> 0a 00 00 00 00 00 00 00  ........
}

alloc1287 (size: 10, align: 1) {
    54 49 4d 45 5f 53 54 59 4c 45                    TIME_STYLE
}

alloc44 (static: flags::TIME_STYLE, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4316<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4324<imm>  ........
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4316 (size: 64, align: 8) {
    0x00  alloc4315<imm> 07 00 00 00 00 00 00 00  ........
    0x10  alloc4317<imm> 08 00 00 00 00 00 00 00  ........
    0x20  alloc4318<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4319<imm> 03 00 00 00 00 00 00 00  ........
}

alloc4315 (size: 7, align: 1) {
    64 65 66 61 75 6c 74                             default
}

alloc4317 (size: 8, align: 1) {
    6c 6f 6e 67 2d 69 73 6f                          long-iso
}

alloc4318 (size: 8, align: 1) {
    66 75 6c 6c 2d 69 73 6f                          full-iso
}

alloc4319 (size: 3, align: 1) {
    69 73 6f                                         iso
}

alloc4324 (size: 10, align: 1) {
    74 69 6d 65 2d 73 74 79 6c 65                    time-style
}

promoted[0] in view::<impl at src/options/view.rs:245:1: 245:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "full-iso";
        _0 = &_1;
        return;
    }
}

promoted[1] in view::<impl at src/options/view.rs:245:1: 245:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "long-iso";
        _0 = &_1;
        return;
    }
}

promoted[2] in view::<impl at src/options/view.rs:245:1: 245:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "iso";
        _0 = &_1;
        return;
    }
}

promoted[3] in view::<impl at src/options/view.rs:245:1: 245:16>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "default";
        _0 = &_1;
        return;
    }
}

fn view::<impl at src/options/view.rs:280:1: 280:16>::deduce(_1: &MatchedFlags<'_>) -> Result<UserFormat, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::table::UserFormat, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _3: std::result::Result<bool, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: bool;
    let mut _8: output::table::UserFormat;
    scope 1 {
        debug flag => _7;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = const {alloc34: &Arg};
        _3 = MatchedFlags::<'_>::has(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<bool, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: bool);
        switchInt(_7) -> [0: bb7, otherwise: bb6];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<UserFormat, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb9, unwind continue];
    }

    bb6: {
        _8 = UserFormat::Numeric;
        goto -> bb8;
    }

    bb7: {
        _8 = UserFormat::Name;
        goto -> bb8;
    }

    bb8: {
        _0 = Result::<UserFormat, OptionsError>::Ok(move _8);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

alloc34 (static: NUMERIC, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4253<imm>  
    0x20  07 00 00 00 00 00 00 00 01 6e __ __ __ __ __ __  .........n
}

alloc4253 (size: 7, align: 1) {
    6e 75 6d 65 72 69 63                             numeric
}

fn view::<impl at src/options/view.rs:288:1: 288:15>::deduce(_1: &MatchedFlags<'_>) -> Result<TimeTypes, OptionsError> {
    debug matches => _1;
    let mut _0: std::result::Result<output::table::TimeTypes, options::error::OptionsError>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, std::option::Option<&std::ffi::OsStr>>;
    let mut _3: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let _4: &options::parser::Arg;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _7: std::option::Option<&std::ffi::OsStr>;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _9: std::result::Result<bool, options::error::OptionsError>;
    let _10: &options::parser::Arg;
    let mut _11: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _15: std::result::Result<bool, options::error::OptionsError>;
    let _16: &options::parser::Arg;
    let mut _17: isize;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _21: std::result::Result<bool, options::error::OptionsError>;
    let _22: &options::parser::Arg;
    let mut _23: isize;
    let mut _26: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _27: std::result::Result<bool, options::error::OptionsError>;
    let _28: &options::parser::Arg;
    let mut _29: isize;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, bool>;
    let mut _33: std::result::Result<bool, options::error::OptionsError>;
    let _34: &options::parser::Arg;
    let mut _35: isize;
    let mut _39: isize;
    let mut _41: options::error::OptionsError;
    let _42: &options::parser::Arg;
    let _43: &options::parser::Arg;
    let mut _44: options::error::OptionsError;
    let _45: &options::parser::Arg;
    let _46: &options::parser::Arg;
    let mut _47: options::error::OptionsError;
    let _48: &options::parser::Arg;
    let _49: &options::parser::Arg;
    let mut _50: options::error::OptionsError;
    let _51: &options::parser::Arg;
    let _52: &options::parser::Arg;
    let mut _53: bool;
    let mut _54: &&std::ffi::OsStr;
    let mut _55: bool;
    let mut _56: &&std::ffi::OsStr;
    let mut _57: bool;
    let mut _58: &&std::ffi::OsStr;
    let mut _59: bool;
    let mut _60: &&std::ffi::OsStr;
    let mut _61: bool;
    let mut _62: &&std::ffi::OsStr;
    let mut _63: bool;
    let mut _64: &&std::ffi::OsStr;
    let mut _65: bool;
    let mut _66: &&std::ffi::OsStr;
    let mut _67: bool;
    let mut _68: &&std::ffi::OsStr;
    let mut _69: options::error::OptionsError;
    let _70: &options::parser::Arg;
    let mut _71: std::ffi::OsString;
    let mut _72: &std::ffi::OsStr;
    let mut _73: output::table::TimeTypes;
    scope 1 {
        debug possible_word => _7;
        let _12: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _13: bool;
        scope 6 {
            debug modified => _13;
            let _18: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _19: bool;
            scope 11 {
                debug changed => _19;
                let _24: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _25: bool;
                scope 16 {
                    debug accessed => _25;
                    let _30: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                    let _31: bool;
                    scope 21 {
                        debug created => _31;
                        let _36: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                        let _37: bool;
                        scope 26 {
                            debug no_time => _37;
                            let _38: output::table::TimeTypes;
                            scope 31 {
                                debug time_types => _38;
                            }
                            scope 32 {
                                debug word => _40;
                                let _40: &std::ffi::OsStr;
                                let mut _74: &&str;
                                let mut _75: &&str;
                                let mut _76: &&str;
                                let mut _77: &&str;
                                let mut _78: &&str;
                                let mut _79: &&str;
                                let mut _80: &&str;
                                let mut _81: &&str;
                            }
                        }
                        scope 27 {
                            debug residual => _36;
                            scope 28 {
                            }
                        }
                        scope 29 {
                            debug val => _37;
                            scope 30 {
                            }
                        }
                    }
                    scope 22 {
                        debug residual => _30;
                        scope 23 {
                        }
                    }
                    scope 24 {
                        debug val => _31;
                        scope 25 {
                        }
                    }
                }
                scope 17 {
                    debug residual => _24;
                    scope 18 {
                    }
                }
                scope 19 {
                    debug val => _25;
                    scope 20 {
                    }
                }
            }
            scope 12 {
                debug residual => _18;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _19;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _12;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _13;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = const {alloc41: &Arg};
        _3 = MatchedFlags::<'_>::get(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<Option<&OsStr>, OptionsError> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: std::option::Option<&std::ffi::OsStr>);
        _10 = const {alloc38: &Arg};
        _9 = MatchedFlags::<'_>::has(_1, _10) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _6) -> [return: bb65, unwind continue];
    }

    bb6: {
        _8 = <Result<bool, OptionsError> as Try>::branch(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _13 = ((_8 as Continue).0: bool);
        _16 = const {alloc39: &Arg};
        _15 = MatchedFlags::<'_>::has(_1, _16) -> [return: bb10, unwind continue];
    }

    bb9: {
        _12 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _12) -> [return: bb65, unwind continue];
    }

    bb10: {
        _14 = <Result<bool, OptionsError> as Try>::branch(move _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        _17 = discriminant(_14);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _19 = ((_14 as Continue).0: bool);
        _22 = const {alloc42: &Arg};
        _21 = MatchedFlags::<'_>::has(_1, _22) -> [return: bb14, unwind continue];
    }

    bb13: {
        _18 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _18) -> [return: bb65, unwind continue];
    }

    bb14: {
        _20 = <Result<bool, OptionsError> as Try>::branch(move _21) -> [return: bb15, unwind continue];
    }

    bb15: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb16, 1: bb17, otherwise: bb4];
    }

    bb16: {
        _25 = ((_20 as Continue).0: bool);
        _28 = const {alloc43: &Arg};
        _27 = MatchedFlags::<'_>::has(_1, _28) -> [return: bb18, unwind continue];
    }

    bb17: {
        _24 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _24) -> [return: bb65, unwind continue];
    }

    bb18: {
        _26 = <Result<bool, OptionsError> as Try>::branch(move _27) -> [return: bb19, unwind continue];
    }

    bb19: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb20, 1: bb21, otherwise: bb4];
    }

    bb20: {
        _31 = ((_26 as Continue).0: bool);
        _34 = const {alloc48: &Arg};
        _33 = MatchedFlags::<'_>::has(_1, _34) -> [return: bb22, unwind continue];
    }

    bb21: {
        _30 = move ((_26 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _30) -> [return: bb65, unwind continue];
    }

    bb22: {
        _32 = <Result<bool, OptionsError> as Try>::branch(move _33) -> [return: bb23, unwind continue];
    }

    bb23: {
        _35 = discriminant(_32);
        switchInt(move _35) -> [0: bb24, 1: bb25, otherwise: bb4];
    }

    bb24: {
        _37 = ((_32 as Continue).0: bool);
        switchInt(_37) -> [0: bb27, otherwise: bb26];
    }

    bb25: {
        _36 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<TimeTypes, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _36) -> [return: bb65, unwind continue];
    }

    bb26: {
        _38 = TimeTypes { modified: const false, changed: const false, accessed: const false, created: const false };
        goto -> bb64;
    }

    bb27: {
        _39 = discriminant(_7);
        switchInt(move _39) -> [1: bb28, otherwise: bb58];
    }

    bb28: {
        _40 = ((_7 as Some).0: &std::ffi::OsStr);
        switchInt(_13) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _42 = const {alloc38: &Arg};
        _43 = const {alloc41: &Arg};
        _41 = OptionsError::Useless(_42, const true, _43);
        _0 = Result::<TimeTypes, OptionsError>::Err(move _41);
        goto -> bb65;
    }

    bb30: {
        switchInt(_19) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _45 = const {alloc39: &Arg};
        _46 = const {alloc41: &Arg};
        _44 = OptionsError::Useless(_45, const true, _46);
        _0 = Result::<TimeTypes, OptionsError>::Err(move _44);
        goto -> bb65;
    }

    bb32: {
        switchInt(_25) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _48 = const {alloc42: &Arg};
        _49 = const {alloc41: &Arg};
        _47 = OptionsError::Useless(_48, const true, _49);
        _0 = Result::<TimeTypes, OptionsError>::Err(move _47);
        goto -> bb65;
    }

    bb34: {
        switchInt(_31) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _51 = const {alloc43: &Arg};
        _52 = const {alloc41: &Arg};
        _50 = OptionsError::Useless(_51, const true, _52);
        _0 = Result::<TimeTypes, OptionsError>::Err(move _50);
        goto -> bb65;
    }

    bb36: {
        _54 = &_40;
        _81 = const _;
        _53 = <&OsStr as PartialEq<&str>>::eq(move _54, _81) -> [return: bb37, unwind continue];
    }

    bb37: {
        switchInt(move _53) -> [0: bb38, otherwise: bb40];
    }

    bb38: {
        _56 = &_40;
        _80 = const _;
        _55 = <&OsStr as PartialEq<&str>>::eq(move _56, _80) -> [return: bb39, unwind continue];
    }

    bb39: {
        switchInt(move _55) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _38 = TimeTypes { modified: const true, changed: const false, accessed: const false, created: const false };
        goto -> bb64;
    }

    bb41: {
        _58 = &_40;
        _79 = const _;
        _57 = <&OsStr as PartialEq<&str>>::eq(move _58, _79) -> [return: bb42, unwind continue];
    }

    bb42: {
        switchInt(move _57) -> [0: bb43, otherwise: bb45];
    }

    bb43: {
        _60 = &_40;
        _78 = const _;
        _59 = <&OsStr as PartialEq<&str>>::eq(move _60, _78) -> [return: bb44, unwind continue];
    }

    bb44: {
        switchInt(move _59) -> [0: bb46, otherwise: bb45];
    }

    bb45: {
        _38 = TimeTypes { modified: const false, changed: const true, accessed: const false, created: const false };
        goto -> bb64;
    }

    bb46: {
        _62 = &_40;
        _77 = const _;
        _61 = <&OsStr as PartialEq<&str>>::eq(move _62, _77) -> [return: bb47, unwind continue];
    }

    bb47: {
        switchInt(move _61) -> [0: bb48, otherwise: bb50];
    }

    bb48: {
        _64 = &_40;
        _76 = const _;
        _63 = <&OsStr as PartialEq<&str>>::eq(move _64, _76) -> [return: bb49, unwind continue];
    }

    bb49: {
        switchInt(move _63) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _38 = TimeTypes { modified: const false, changed: const false, accessed: const true, created: const false };
        goto -> bb64;
    }

    bb51: {
        _66 = &_40;
        _75 = const _;
        _65 = <&OsStr as PartialEq<&str>>::eq(move _66, _75) -> [return: bb52, unwind continue];
    }

    bb52: {
        switchInt(move _65) -> [0: bb53, otherwise: bb55];
    }

    bb53: {
        _68 = &_40;
        _74 = const _;
        _67 = <&OsStr as PartialEq<&str>>::eq(move _68, _74) -> [return: bb54, unwind continue];
    }

    bb54: {
        switchInt(move _67) -> [0: bb56, otherwise: bb55];
    }

    bb55: {
        _38 = TimeTypes { modified: const false, changed: const false, accessed: const false, created: const true };
        goto -> bb64;
    }

    bb56: {
        _70 = const {alloc41: &Arg};
        _72 = _40;
        _71 = <&OsStr as Into<OsString>>::into(move _72) -> [return: bb57, unwind continue];
    }

    bb57: {
        _69 = OptionsError::BadArgument(_70, move _71);
        _0 = Result::<TimeTypes, OptionsError>::Err(move _69);
        goto -> bb65;
    }

    bb58: {
        switchInt(_13) -> [0: bb59, otherwise: bb62];
    }

    bb59: {
        switchInt(_19) -> [0: bb60, otherwise: bb62];
    }

    bb60: {
        switchInt(_25) -> [0: bb61, otherwise: bb62];
    }

    bb61: {
        switchInt(_31) -> [0: bb63, otherwise: bb62];
    }

    bb62: {
        _38 = TimeTypes { modified: _13, changed: _19, accessed: _25, created: _31 };
        goto -> bb64;
    }

    bb63: {
        _38 = <TimeTypes as Default>::default() -> [return: bb64, unwind continue];
    }

    bb64: {
        _73 = _38;
        _0 = Result::<TimeTypes, OptionsError>::Ok(move _73);
        goto -> bb65;
    }

    bb65: {
        return;
    }
}

alloc48 (static: NO_TIME, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4344<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4344 (size: 7, align: 1) {
    6e 6f 2d 74 69 6d 65                             no-time
}

alloc43 (static: CREATED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4311<imm>  
    0x20  07 00 00 00 00 00 00 00 01 55 __ __ __ __ __ __  .........U
}

alloc4311 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc42 (static: ACCESSED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4306<imm>  
    0x20  08 00 00 00 00 00 00 00 01 75 __ __ __ __ __ __  .........u
}

alloc4306 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc41 (static: TIME, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4293<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4301<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 74 __ __ __ __ __ __  .........t
}

alloc4293 (size: 64, align: 8) {
    0x00  alloc4292<imm> 08 00 00 00 00 00 00 00  ........
    0x10  alloc4294<imm> 07 00 00 00 00 00 00 00  ........
    0x20  alloc4295<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4296<imm> 07 00 00 00 00 00 00 00  ........
}

alloc4292 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4294 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4295 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4296 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4301 (size: 4, align: 1) {
    74 69 6d 65                                      time
}

alloc39 (static: CHANGED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4283<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4283 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc38 (static: MODIFIED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4278<imm>  
    0x20  08 00 00 00 00 00 00 00 01 6d __ __ __ __ __ __  .........m
}

alloc4278 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

promoted[0] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "created";
        _0 = &_1;
        return;
    }
}

promoted[1] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "cr";
        _0 = &_1;
        return;
    }
}

promoted[2] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "accessed";
        _0 = &_1;
        return;
    }
}

promoted[3] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "acc";
        _0 = &_1;
        return;
    }
}

promoted[4] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "changed";
        _0 = &_1;
        return;
    }
}

promoted[5] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ch";
        _0 = &_1;
        return;
    }
}

promoted[6] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "modified";
        _0 = &_1;
        return;
    }
}

promoted[7] in view::<impl at src/options/view.rs:288:1: 288:15>::deduce: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "mod";
        _0 = &_1;
        return;
    }
}

fn options::error::<impl at src/options/error.rs:10:10: 10:19>::eq(_1: &OptionsError, _2: &OptionsError) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&options::error::OptionsError, &options::error::OptionsError);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _11: isize;
    let mut _12: isize;
    let mut _13: isize;
    let mut _14: isize;
    let mut _15: isize;
    let mut _16: isize;
    let mut _23: bool;
    let mut _30: bool;
    let mut _35: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _52: bool;
    let mut _53: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _64: &options::error::OptionsError;
    let mut _65: &options::error::OptionsError;
    let mut _66: &options::error::OptionsError;
    let mut _67: &options::error::OptionsError;
    let mut _68: &options::error::OptionsError;
    let mut _69: &options::error::OptionsError;
    let mut _70: &options::error::OptionsError;
    let mut _71: &options::error::OptionsError;
    let mut _72: &options::error::OptionsError;
    let mut _73: &options::error::OptionsError;
    let mut _74: &options::error::OptionsError;
    let mut _75: &options::error::OptionsError;
    let mut _76: &options::error::OptionsError;
    let mut _77: &options::error::OptionsError;
    let mut _78: &options::error::OptionsError;
    let mut _79: &options::error::OptionsError;
    let mut _80: &options::error::OptionsError;
    let mut _81: &options::error::OptionsError;
    let mut _82: &options::error::OptionsError;
    let mut _83: &options::error::OptionsError;
    let mut _84: &options::error::OptionsError;
    let mut _85: &options::error::OptionsError;
    let mut _86: &options::error::OptionsError;
    let mut _87: &options::error::OptionsError;
    let mut _88: &options::error::OptionsError;
    let mut _89: &options::error::OptionsError;
    let mut _90: &options::error::OptionsError;
    let mut _91: &options::error::OptionsError;
    let mut _92: &options::error::OptionsError;
    let mut _93: &options::error::OptionsError;
    let mut _94: &options::error::OptionsError;
    let mut _95: &options::error::OptionsError;
    let mut _96: &options::error::OptionsError;
    let mut _97: &options::error::OptionsError;
    let mut _98: &options::error::OptionsError;
    let mut _99: &options::error::OptionsError;
    let mut _100: &options::error::OptionsError;
    let mut _101: &options::error::OptionsError;
    let mut _102: &options::error::OptionsError;
    let mut _103: &options::error::OptionsError;
    let mut _104: &options::error::OptionsError;
    let mut _105: &options::error::OptionsError;
    let mut _106: &options::error::OptionsError;
    let mut _107: &options::error::OptionsError;
    let mut _108: &options::error::OptionsError;
    let mut _109: &options::error::OptionsError;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _17: &options::parser::ParseError;
            let _18: &options::parser::ParseError;
            let _19: &&options::parser::Arg;
            let _20: &std::ffi::OsString;
            let _21: &&options::parser::Arg;
            let _22: &std::ffi::OsString;
            let _24: &std::string::String;
            let _25: &std::string::String;
            let _26: &options::parser::Flag;
            let _27: &options::parser::Flag;
            let _28: &options::parser::Flag;
            let _29: &options::parser::Flag;
            let _31: &&options::parser::Arg;
            let _32: &&options::parser::Arg;
            let _33: &&options::parser::Arg;
            let _34: &&options::parser::Arg;
            let _36: &&options::parser::Arg;
            let _37: &bool;
            let _38: &&options::parser::Arg;
            let _39: &&options::parser::Arg;
            let _40: &bool;
            let _41: &&options::parser::Arg;
            let _46: &&options::parser::Arg;
            let _47: &&options::parser::Arg;
            let _48: &&options::parser::Arg;
            let _49: &&options::parser::Arg;
            let _50: &&options::parser::Arg;
            let _51: &&options::parser::Arg;
            let _54: &std::string::String;
            let _55: &options::error::NumberSource;
            let _56: &std::num::ParseIntError;
            let _57: &std::string::String;
            let _58: &options::error::NumberSource;
            let _59: &std::num::ParseIntError;
            let _62: &std::string::String;
            let _63: &std::string::String;
            scope 3 {
                debug __self_0 => _17;
                debug __arg1_0 => _18;
            }
            scope 4 {
                debug __self_0 => _19;
                debug __self_1 => _20;
                debug __arg1_0 => _21;
                debug __arg1_1 => _22;
            }
            scope 5 {
                debug __self_0 => _24;
                debug __arg1_0 => _25;
            }
            scope 6 {
                debug __self_0 => _26;
                debug __self_1 => _27;
                debug __arg1_0 => _28;
                debug __arg1_1 => _29;
            }
            scope 7 {
                debug __self_0 => _31;
                debug __self_1 => _32;
                debug __arg1_0 => _33;
                debug __arg1_1 => _34;
            }
            scope 8 {
                debug __self_0 => _36;
                debug __self_1 => _37;
                debug __self_2 => _38;
                debug __arg1_0 => _39;
                debug __arg1_1 => _40;
                debug __arg1_2 => _41;
            }
            scope 9 {
                debug __self_0 => _46;
                debug __self_1 => _47;
                debug __self_2 => _48;
                debug __arg1_0 => _49;
                debug __arg1_1 => _50;
                debug __arg1_2 => _51;
            }
            scope 10 {
                debug __self_0 => _54;
                debug __self_1 => _55;
                debug __self_2 => _56;
                debug __arg1_0 => _57;
                debug __arg1_1 => _58;
                debug __arg1_2 => _59;
            }
            scope 11 {
                debug __self_0 => _62;
                debug __arg1_0 => _63;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _64 = deref_copy (_6.0: &options::error::OptionsError);
        _16 = discriminant((*_64));
        switchInt(move _16) -> [0: bb3, 1: bb5, 2: bb6, 3: bb7, 4: bb8, 5: bb9, 6: bb10, 8: bb11, 9: bb12, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb45;
    }

    bb3: {
        _65 = deref_copy (_6.1: &options::error::OptionsError);
        _7 = discriminant((*_65));
        switchInt(move _7) -> [0: bb13, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb45;
    }

    bb5: {
        _66 = deref_copy (_6.1: &options::error::OptionsError);
        _8 = discriminant((*_66));
        switchInt(move _8) -> [1: bb14, otherwise: bb4];
    }

    bb6: {
        _67 = deref_copy (_6.1: &options::error::OptionsError);
        _9 = discriminant((*_67));
        switchInt(move _9) -> [2: bb18, otherwise: bb4];
    }

    bb7: {
        _68 = deref_copy (_6.1: &options::error::OptionsError);
        _10 = discriminant((*_68));
        switchInt(move _10) -> [3: bb19, otherwise: bb4];
    }

    bb8: {
        _69 = deref_copy (_6.1: &options::error::OptionsError);
        _11 = discriminant((*_69));
        switchInt(move _11) -> [4: bb23, otherwise: bb4];
    }

    bb9: {
        _70 = deref_copy (_6.1: &options::error::OptionsError);
        _12 = discriminant((*_70));
        switchInt(move _12) -> [5: bb27, otherwise: bb4];
    }

    bb10: {
        _71 = deref_copy (_6.1: &options::error::OptionsError);
        _13 = discriminant((*_71));
        switchInt(move _13) -> [6: bb32, otherwise: bb4];
    }

    bb11: {
        _72 = deref_copy (_6.1: &options::error::OptionsError);
        _14 = discriminant((*_72));
        switchInt(move _14) -> [8: bb38, otherwise: bb4];
    }

    bb12: {
        _73 = deref_copy (_6.1: &options::error::OptionsError);
        _15 = discriminant((*_73));
        switchInt(move _15) -> [9: bb44, otherwise: bb4];
    }

    bb13: {
        _74 = deref_copy (_6.0: &options::error::OptionsError);
        _17 = &(((*_74) as Parse).0: options::parser::ParseError);
        _75 = deref_copy (_6.1: &options::error::OptionsError);
        _18 = &(((*_75) as Parse).0: options::parser::ParseError);
        _0 = <ParseError as PartialEq>::eq(_17, _18) -> [return: bb45, unwind continue];
    }

    bb14: {
        _76 = deref_copy (_6.0: &options::error::OptionsError);
        _19 = &(((*_76) as BadArgument).0: &options::parser::Arg);
        _77 = deref_copy (_6.0: &options::error::OptionsError);
        _20 = &(((*_77) as BadArgument).1: std::ffi::OsString);
        _78 = deref_copy (_6.1: &options::error::OptionsError);
        _21 = &(((*_78) as BadArgument).0: &options::parser::Arg);
        _79 = deref_copy (_6.1: &options::error::OptionsError);
        _22 = &(((*_79) as BadArgument).1: std::ffi::OsString);
        _23 = <&Arg as PartialEq>::eq(_19, _21) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _23) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _0 = <OsString as PartialEq>::eq(_20, _22) -> [return: bb45, unwind continue];
    }

    bb17: {
        _0 = const false;
        goto -> bb45;
    }

    bb18: {
        _80 = deref_copy (_6.0: &options::error::OptionsError);
        _24 = &(((*_80) as Unsupported).0: std::string::String);
        _81 = deref_copy (_6.1: &options::error::OptionsError);
        _25 = &(((*_81) as Unsupported).0: std::string::String);
        _0 = <String as PartialEq>::eq(_24, _25) -> [return: bb45, unwind continue];
    }

    bb19: {
        _82 = deref_copy (_6.0: &options::error::OptionsError);
        _26 = &(((*_82) as Duplicate).0: options::parser::Flag);
        _83 = deref_copy (_6.0: &options::error::OptionsError);
        _27 = &(((*_83) as Duplicate).1: options::parser::Flag);
        _84 = deref_copy (_6.1: &options::error::OptionsError);
        _28 = &(((*_84) as Duplicate).0: options::parser::Flag);
        _85 = deref_copy (_6.1: &options::error::OptionsError);
        _29 = &(((*_85) as Duplicate).1: options::parser::Flag);
        _30 = <Flag as PartialEq>::eq(_26, _28) -> [return: bb20, unwind continue];
    }

    bb20: {
        switchInt(move _30) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = <Flag as PartialEq>::eq(_27, _29) -> [return: bb45, unwind continue];
    }

    bb22: {
        _0 = const false;
        goto -> bb45;
    }

    bb23: {
        _86 = deref_copy (_6.0: &options::error::OptionsError);
        _31 = &(((*_86) as Conflict).0: &options::parser::Arg);
        _87 = deref_copy (_6.0: &options::error::OptionsError);
        _32 = &(((*_87) as Conflict).1: &options::parser::Arg);
        _88 = deref_copy (_6.1: &options::error::OptionsError);
        _33 = &(((*_88) as Conflict).0: &options::parser::Arg);
        _89 = deref_copy (_6.1: &options::error::OptionsError);
        _34 = &(((*_89) as Conflict).1: &options::parser::Arg);
        _35 = <&Arg as PartialEq>::eq(_31, _33) -> [return: bb24, unwind continue];
    }

    bb24: {
        switchInt(move _35) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _0 = <&Arg as PartialEq>::eq(_32, _34) -> [return: bb45, unwind continue];
    }

    bb26: {
        _0 = const false;
        goto -> bb45;
    }

    bb27: {
        _90 = deref_copy (_6.0: &options::error::OptionsError);
        _36 = &(((*_90) as Useless).0: &options::parser::Arg);
        _91 = deref_copy (_6.0: &options::error::OptionsError);
        _37 = &(((*_91) as Useless).1: bool);
        _92 = deref_copy (_6.0: &options::error::OptionsError);
        _38 = &(((*_92) as Useless).2: &options::parser::Arg);
        _93 = deref_copy (_6.1: &options::error::OptionsError);
        _39 = &(((*_93) as Useless).0: &options::parser::Arg);
        _94 = deref_copy (_6.1: &options::error::OptionsError);
        _40 = &(((*_94) as Useless).1: bool);
        _95 = deref_copy (_6.1: &options::error::OptionsError);
        _41 = &(((*_95) as Useless).2: &options::parser::Arg);
        _42 = <&Arg as PartialEq>::eq(_36, _39) -> [return: bb28, unwind continue];
    }

    bb28: {
        switchInt(move _42) -> [0: bb31, otherwise: bb29];
    }

    bb29: {
        _44 = (*_37);
        _45 = (*_40);
        _43 = Eq(move _44, move _45);
        switchInt(move _43) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _0 = <&Arg as PartialEq>::eq(_38, _41) -> [return: bb45, unwind continue];
    }

    bb31: {
        _0 = const false;
        goto -> bb45;
    }

    bb32: {
        _96 = deref_copy (_6.0: &options::error::OptionsError);
        _46 = &(((*_96) as Useless2).0: &options::parser::Arg);
        _97 = deref_copy (_6.0: &options::error::OptionsError);
        _47 = &(((*_97) as Useless2).1: &options::parser::Arg);
        _98 = deref_copy (_6.0: &options::error::OptionsError);
        _48 = &(((*_98) as Useless2).2: &options::parser::Arg);
        _99 = deref_copy (_6.1: &options::error::OptionsError);
        _49 = &(((*_99) as Useless2).0: &options::parser::Arg);
        _100 = deref_copy (_6.1: &options::error::OptionsError);
        _50 = &(((*_100) as Useless2).1: &options::parser::Arg);
        _101 = deref_copy (_6.1: &options::error::OptionsError);
        _51 = &(((*_101) as Useless2).2: &options::parser::Arg);
        _52 = <&Arg as PartialEq>::eq(_46, _49) -> [return: bb33, unwind continue];
    }

    bb33: {
        switchInt(move _52) -> [0: bb37, otherwise: bb34];
    }

    bb34: {
        _53 = <&Arg as PartialEq>::eq(_47, _50) -> [return: bb35, unwind continue];
    }

    bb35: {
        switchInt(move _53) -> [0: bb37, otherwise: bb36];
    }

    bb36: {
        _0 = <&Arg as PartialEq>::eq(_48, _51) -> [return: bb45, unwind continue];
    }

    bb37: {
        _0 = const false;
        goto -> bb45;
    }

    bb38: {
        _102 = deref_copy (_6.0: &options::error::OptionsError);
        _54 = &(((*_102) as FailedParse).0: std::string::String);
        _103 = deref_copy (_6.0: &options::error::OptionsError);
        _55 = &(((*_103) as FailedParse).1: options::error::NumberSource);
        _104 = deref_copy (_6.0: &options::error::OptionsError);
        _56 = &(((*_104) as FailedParse).2: std::num::ParseIntError);
        _105 = deref_copy (_6.1: &options::error::OptionsError);
        _57 = &(((*_105) as FailedParse).0: std::string::String);
        _106 = deref_copy (_6.1: &options::error::OptionsError);
        _58 = &(((*_106) as FailedParse).1: options::error::NumberSource);
        _107 = deref_copy (_6.1: &options::error::OptionsError);
        _59 = &(((*_107) as FailedParse).2: std::num::ParseIntError);
        _60 = <String as PartialEq>::eq(_54, _57) -> [return: bb39, unwind continue];
    }

    bb39: {
        switchInt(move _60) -> [0: bb43, otherwise: bb40];
    }

    bb40: {
        _61 = <NumberSource as PartialEq>::eq(_55, _58) -> [return: bb41, unwind continue];
    }

    bb41: {
        switchInt(move _61) -> [0: bb43, otherwise: bb42];
    }

    bb42: {
        _0 = <ParseIntError as PartialEq>::eq(_56, _59) -> [return: bb45, unwind continue];
    }

    bb43: {
        _0 = const false;
        goto -> bb45;
    }

    bb44: {
        _108 = deref_copy (_6.0: &options::error::OptionsError);
        _62 = &(((*_108) as FailedGlobPattern).0: std::string::String);
        _109 = deref_copy (_6.1: &options::error::OptionsError);
        _63 = &(((*_109) as FailedGlobPattern).0: std::string::String);
        _0 = <String as PartialEq>::eq(_62, _63) -> [return: bb45, unwind continue];
    }

    bb45: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:10:21: 10:26>::fmt(_1: &OptionsError, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &options::parser::ParseError;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&options::parser::ParseError;
    let _8: &&options::parser::Arg;
    let _9: &std::ffi::OsString;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &&std::ffi::OsString;
    let _14: &std::string::String;
    let _15: &str;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&std::string::String;
    let _18: &options::parser::Flag;
    let _19: &options::parser::Flag;
    let _20: &str;
    let mut _21: &dyn std::fmt::Debug;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &&options::parser::Flag;
    let _24: &&options::parser::Arg;
    let _25: &&options::parser::Arg;
    let _26: &str;
    let mut _27: &dyn std::fmt::Debug;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &&&options::parser::Arg;
    let _30: &&options::parser::Arg;
    let _31: &bool;
    let _32: &&options::parser::Arg;
    let _33: &str;
    let mut _34: &dyn std::fmt::Debug;
    let mut _35: &dyn std::fmt::Debug;
    let mut _36: &dyn std::fmt::Debug;
    let _37: &&&options::parser::Arg;
    let _38: &&options::parser::Arg;
    let _39: &&options::parser::Arg;
    let _40: &&options::parser::Arg;
    let _41: &str;
    let mut _42: &dyn std::fmt::Debug;
    let mut _43: &dyn std::fmt::Debug;
    let mut _44: &dyn std::fmt::Debug;
    let _45: &&&options::parser::Arg;
    let _46: &str;
    let _47: &std::string::String;
    let _48: &options::error::NumberSource;
    let _49: &std::num::ParseIntError;
    let _50: &str;
    let mut _51: &dyn std::fmt::Debug;
    let mut _52: &dyn std::fmt::Debug;
    let mut _53: &dyn std::fmt::Debug;
    let _54: &&std::num::ParseIntError;
    let _55: &std::string::String;
    let _56: &str;
    let mut _57: &dyn std::fmt::Debug;
    let _58: &&std::string::String;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
        debug __self_1 => _9;
    }
    scope 3 {
        debug __self_0 => _14;
    }
    scope 4 {
        debug __self_0 => _18;
        debug __self_1 => _19;
    }
    scope 5 {
        debug __self_0 => _24;
        debug __self_1 => _25;
    }
    scope 6 {
        debug __self_0 => _30;
        debug __self_1 => _31;
        debug __self_2 => _32;
    }
    scope 7 {
        debug __self_0 => _38;
        debug __self_1 => _39;
        debug __self_2 => _40;
    }
    scope 8 {
        debug __self_0 => _47;
        debug __self_1 => _48;
        debug __self_2 => _49;
    }
    scope 9 {
        debug __self_0 => _55;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 9: bb1, otherwise: bb2];
    }

    bb1: {
        _55 = &(((*_1) as FailedGlobPattern).0: std::string::String);
        _56 = const "FailedGlobPattern";
        _58 = &_55;
        _57 = _58 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _56, move _57) -> [return: bb12, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Parse).0: options::parser::ParseError);
        _5 = const "Parse";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb12, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as BadArgument).0: &options::parser::Arg);
        _9 = &(((*_1) as BadArgument).1: std::ffi::OsString);
        _10 = const "BadArgument";
        _11 = _8 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &_9;
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _10, move _11, move _12) -> [return: bb12, unwind continue];
    }

    bb5: {
        _14 = &(((*_1) as Unsupported).0: std::string::String);
        _15 = const "Unsupported";
        _17 = &_14;
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _15, move _16) -> [return: bb12, unwind continue];
    }

    bb6: {
        _18 = &(((*_1) as Duplicate).0: options::parser::Flag);
        _19 = &(((*_1) as Duplicate).1: options::parser::Flag);
        _20 = const "Duplicate";
        _21 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _23 = &_19;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _20, move _21, move _22) -> [return: bb12, unwind continue];
    }

    bb7: {
        _24 = &(((*_1) as Conflict).0: &options::parser::Arg);
        _25 = &(((*_1) as Conflict).1: &options::parser::Arg);
        _26 = const "Conflict";
        _27 = _24 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _29 = &_25;
        _28 = _29 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _26, move _27, move _28) -> [return: bb12, unwind continue];
    }

    bb8: {
        _30 = &(((*_1) as Useless).0: &options::parser::Arg);
        _31 = &(((*_1) as Useless).1: bool);
        _32 = &(((*_1) as Useless).2: &options::parser::Arg);
        _33 = const "Useless";
        _34 = _30 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _35 = _31 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _37 = &_32;
        _36 = _37 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field3_finish(_2, _33, move _34, move _35, move _36) -> [return: bb12, unwind continue];
    }

    bb9: {
        _38 = &(((*_1) as Useless2).0: &options::parser::Arg);
        _39 = &(((*_1) as Useless2).1: &options::parser::Arg);
        _40 = &(((*_1) as Useless2).2: &options::parser::Arg);
        _41 = const "Useless2";
        _42 = _38 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _43 = _39 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _45 = &_40;
        _44 = _45 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field3_finish(_2, _41, move _42, move _43, move _44) -> [return: bb12, unwind continue];
    }

    bb10: {
        _46 = const "TreeAllAll";
        _0 = Formatter::<'_>::write_str(_2, _46) -> [return: bb12, unwind continue];
    }

    bb11: {
        _47 = &(((*_1) as FailedParse).0: std::string::String);
        _48 = &(((*_1) as FailedParse).1: options::error::NumberSource);
        _49 = &(((*_1) as FailedParse).2: std::num::ParseIntError);
        _50 = const "FailedParse";
        _51 = _47 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _52 = _48 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _54 = &_49;
        _53 = _54 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field3_finish(_2, _50, move _51, move _52, move _53) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:47:10: 47:19>::eq(_1: &NumberSource, _2: &NumberSource) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&options::error::NumberSource, &options::error::NumberSource);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _14: &options::error::NumberSource;
    let mut _15: &options::error::NumberSource;
    let mut _16: &options::error::NumberSource;
    let mut _17: &options::error::NumberSource;
    let mut _18: &options::error::NumberSource;
    let mut _19: &options::error::NumberSource;
    let mut _20: &options::error::NumberSource;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _10: &&options::parser::Arg;
            let _11: &&options::parser::Arg;
            let _12: &&str;
            let _13: &&str;
            scope 3 {
                debug __self_0 => _10;
                debug __arg1_0 => _11;
            }
            scope 4 {
                debug __self_0 => _12;
                debug __arg1_0 => _13;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _14 = deref_copy (_6.0: &options::error::NumberSource);
        _9 = discriminant((*_14));
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb8;
    }

    bb3: {
        _15 = deref_copy (_6.1: &options::error::NumberSource);
        _7 = discriminant((*_15));
        switchInt(move _7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _16 = deref_copy (_6.1: &options::error::NumberSource);
        _8 = discriminant((*_16));
        switchInt(move _8) -> [1: bb7, otherwise: bb4];
    }

    bb6: {
        _17 = deref_copy (_6.0: &options::error::NumberSource);
        _10 = &(((*_17) as Arg).0: &options::parser::Arg);
        _18 = deref_copy (_6.1: &options::error::NumberSource);
        _11 = &(((*_18) as Arg).0: &options::parser::Arg);
        _0 = <&Arg as PartialEq>::eq(_10, _11) -> [return: bb8, unwind continue];
    }

    bb7: {
        _19 = deref_copy (_6.0: &options::error::NumberSource);
        _12 = &(((*_19) as Env).0: &str);
        _20 = deref_copy (_6.1: &options::error::NumberSource);
        _13 = &(((*_20) as Env).0: &str);
        _0 = <&str as PartialEq>::eq(_12, _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:47:21: 47:26>::fmt(_1: &NumberSource, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &&options::parser::Arg;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&&options::parser::Arg;
    let _8: &&str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&&str;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Env).0: &str);
        _9 = const "Env";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Arg).0: &options::parser::Arg);
        _5 = const "Arg";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:57:1: 57:47>::from(_1: PatternError) -> OptionsError {
    debug error => _1;
    let mut _0: options::error::OptionsError;
    let mut _2: std::string::String;
    let mut _3: &glob::PatternError;

    bb0: {
        _3 = &_1;
        _2 = <PatternError as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = OptionsError::FailedGlobPattern(move _2);
        return;
    }
}

fn options::error::<impl at src/options/error.rs:63:1: 63:35>::fmt(_1: &NumberSource, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &&options::parser::Arg;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &&&options::parser::Arg;
    let _12: &&str;
    let mut _13: std::fmt::Arguments<'_>;
    let mut _14: &[&str];
    let mut _15: &[core::fmt::rt::Argument<'_>];
    let _16: &[core::fmt::rt::Argument<'_>; 1];
    let _17: [core::fmt::rt::Argument<'_>; 1];
    let mut _18: core::fmt::rt::Argument<'_>;
    let _19: &&&str;
    scope 1 {
        debug arg => _4;
        let mut _21: &[&str; 1];
    }
    scope 2 {
        debug env => _12;
        let mut _20: &[&str; 1];
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _12 = &(((*_1) as Env).0: &str);
        _20 = const _;
        _14 = _20 as &[&str] (PointerCoercion(Unsize));
        _19 = &_12;
        _18 = core::fmt::rt::Argument::<'_>::new_display::<&&str>(_19) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Arg).0: &options::parser::Arg);
        _21 = const _;
        _6 = _21 as &[&str] (PointerCoercion(Unsize));
        _11 = &_4;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb8, unwind continue];
    }

    bb6: {
        _17 = [move _18];
        _16 = &_17;
        _15 = _16 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _13 = std::fmt::Arguments::<'_>::new_v1(move _14, move _15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Formatter::<'_>::write_fmt(_2, move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

promoted[0] in options::error::<impl at src/options/error.rs:63:1: 63:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "environment variable "];
        _0 = &_1;
        return;
    }
}

promoted[1] in options::error::<impl at src/options/error.rs:63:1: 63:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "option "];
        _0 = &_1;
        return;
    }
}

fn options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt(_1: &OptionsError, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &&options::parser::Arg;
    let _5: &std::ffi::OsString;
    let mut _6: isize;
    let mut _7: isize;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 3];
    let _13: [core::fmt::rt::Argument<'_>; 3];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &&&options::parser::Arg;
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &&std::ffi::OsString;
    let mut _18: core::fmt::rt::Argument<'_>;
    let _19: &options::error::Choices;
    let _20: options::error::Choices;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 2];
    let _25: [core::fmt::rt::Argument<'_>; 2];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&&options::parser::Arg;
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &&std::ffi::OsString;
    let _30: &options::parser::ParseError;
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 1];
    let _35: [core::fmt::rt::Argument<'_>; 1];
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &&options::parser::ParseError;
    let _38: &std::string::String;
    let mut _39: std::fmt::Arguments<'_>;
    let mut _40: &[&str];
    let mut _41: &[core::fmt::rt::Argument<'_>];
    let _42: &[core::fmt::rt::Argument<'_>; 1];
    let _43: [core::fmt::rt::Argument<'_>; 1];
    let mut _44: core::fmt::rt::Argument<'_>;
    let _45: &&std::string::String;
    let _46: &&options::parser::Arg;
    let _47: &&options::parser::Arg;
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 2];
    let _52: [core::fmt::rt::Argument<'_>; 2];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &&&options::parser::Arg;
    let mut _55: core::fmt::rt::Argument<'_>;
    let _56: &&&options::parser::Arg;
    let _57: &options::parser::Flag;
    let _58: &&options::parser::Flag;
    let _59: &options::parser::Flag;
    let _60: &&options::parser::Flag;
    let mut _61: bool;
    let mut _62: std::fmt::Arguments<'_>;
    let mut _63: &[&str];
    let mut _64: &[core::fmt::rt::Argument<'_>];
    let _65: &[core::fmt::rt::Argument<'_>; 1];
    let _66: [core::fmt::rt::Argument<'_>; 1];
    let mut _67: core::fmt::rt::Argument<'_>;
    let _68: &&options::parser::Flag;
    let _69: &options::parser::Flag;
    let _70: &options::parser::Flag;
    let mut _71: std::fmt::Arguments<'_>;
    let mut _72: &[&str];
    let mut _73: &[core::fmt::rt::Argument<'_>];
    let _74: &[core::fmt::rt::Argument<'_>; 2];
    let _75: [core::fmt::rt::Argument<'_>; 2];
    let mut _76: core::fmt::rt::Argument<'_>;
    let _77: &&options::parser::Flag;
    let mut _78: core::fmt::rt::Argument<'_>;
    let _79: &&options::parser::Flag;
    let _80: &&options::parser::Arg;
    let _81: &&options::parser::Arg;
    let mut _82: std::fmt::Arguments<'_>;
    let mut _83: &[&str];
    let mut _84: &[core::fmt::rt::Argument<'_>];
    let _85: &[core::fmt::rt::Argument<'_>; 2];
    let _86: [core::fmt::rt::Argument<'_>; 2];
    let mut _87: core::fmt::rt::Argument<'_>;
    let _88: &&&options::parser::Arg;
    let mut _89: core::fmt::rt::Argument<'_>;
    let _90: &&&options::parser::Arg;
    let _91: &&options::parser::Arg;
    let _92: &&options::parser::Arg;
    let mut _93: std::fmt::Arguments<'_>;
    let mut _94: &[&str];
    let mut _95: &[core::fmt::rt::Argument<'_>];
    let _96: &[core::fmt::rt::Argument<'_>; 2];
    let _97: [core::fmt::rt::Argument<'_>; 2];
    let mut _98: core::fmt::rt::Argument<'_>;
    let _99: &&&options::parser::Arg;
    let mut _100: core::fmt::rt::Argument<'_>;
    let _101: &&&options::parser::Arg;
    let _102: &&options::parser::Arg;
    let _103: &&options::parser::Arg;
    let _104: &&options::parser::Arg;
    let mut _105: std::fmt::Arguments<'_>;
    let mut _106: &[&str];
    let mut _107: &[core::fmt::rt::Argument<'_>];
    let _108: &[core::fmt::rt::Argument<'_>; 3];
    let _109: [core::fmt::rt::Argument<'_>; 3];
    let mut _110: core::fmt::rt::Argument<'_>;
    let _111: &&&options::parser::Arg;
    let mut _112: core::fmt::rt::Argument<'_>;
    let _113: &&&options::parser::Arg;
    let mut _114: core::fmt::rt::Argument<'_>;
    let _115: &&&options::parser::Arg;
    let mut _116: std::fmt::Arguments<'_>;
    let mut _117: &[&str];
    let _118: &std::string::String;
    let _119: &options::error::NumberSource;
    let _120: &std::num::ParseIntError;
    let mut _121: std::fmt::Arguments<'_>;
    let mut _122: &[&str];
    let mut _123: &[core::fmt::rt::Argument<'_>];
    let _124: &[core::fmt::rt::Argument<'_>; 3];
    let _125: [core::fmt::rt::Argument<'_>; 3];
    let mut _126: core::fmt::rt::Argument<'_>;
    let _127: &&std::string::String;
    let mut _128: core::fmt::rt::Argument<'_>;
    let _129: &&options::error::NumberSource;
    let mut _130: core::fmt::rt::Argument<'_>;
    let _131: &&std::num::ParseIntError;
    let _132: &std::string::String;
    let mut _133: std::fmt::Arguments<'_>;
    let mut _134: &[&str];
    let mut _135: &[core::fmt::rt::Argument<'_>];
    let _136: &[core::fmt::rt::Argument<'_>; 1];
    let _137: [core::fmt::rt::Argument<'_>; 1];
    let mut _138: core::fmt::rt::Argument<'_>;
    let _139: &&std::string::String;
    let mut _142: &[&str; 1];
    let mut _153: &options::parser::Arg;
    let mut _154: &options::parser::Arg;
    let mut _155: &options::parser::Arg;
    scope 1 {
        debug arg => _4;
        debug attempt => _5;
        let mut _151: &[&str; 3];
        scope 2 {
            debug values => _8;
            let _8: &[&str];
            let mut _152: &[&str; 4];
        }
    }
    scope 3 {
        debug e => _30;
        let mut _150: &[&str; 1];
    }
    scope 4 {
        debug e => _38;
        let mut _149: &[&str; 1];
    }
    scope 5 {
        debug a => _46;
        debug b => _47;
        let mut _148: &[&str; 2];
    }
    scope 6 {
        debug a => _57;
        debug a => _58;
        debug b => _59;
        debug b => _60;
        let mut _147: &[&str; 2];
    }
    scope 7 {
        debug a => _69;
        debug b => _70;
        let mut _146: &[&str; 2];
    }
    scope 8 {
        debug a => _80;
        debug b => _81;
        let mut _145: &[&str; 2];
    }
    scope 9 {
        debug a => _91;
        debug b => _92;
        let mut _144: &[&str; 2];
    }
    scope 10 {
        debug a => _102;
        debug b1 => _103;
        debug b2 => _104;
        let mut _143: &[&str; 3];
    }
    scope 11 {
        debug s => _118;
        debug n => _119;
        debug e => _120;
        let mut _141: &[&str; 3];
    }
    scope 12 {
        debug e => _132;
        let mut _140: &[&str; 1];
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb15, 1: bb4, 2: bb18, 3: bb25, 4: bb21, 5: bb1, 6: bb42, 7: bb47, 8: bb49, 9: bb2, otherwise: bb3];
    }

    bb1: {
        switchInt((((*_1) as Useless).1: bool)) -> [0: bb34, otherwise: bb38];
    }

    bb2: {
        _132 = &(((*_1) as FailedGlobPattern).0: std::string::String);
        _140 = const _;
        _134 = _140 as &[&str] (PointerCoercion(Unsize));
        _139 = &_132;
        _138 = core::fmt::rt::Argument::<'_>::new_display::<&String>(_139) -> [return: bb54, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _4 = &(((*_1) as BadArgument).0: &options::parser::Arg);
        _5 = &(((*_1) as BadArgument).1: std::ffi::OsString);
        _153 = deref_copy (*_4);
        _7 = discriminant(((*_153).2: options::parser::TakesValue));
        switchInt(move _7) -> [0: bb5, otherwise: bb11];
    }

    bb5: {
        _154 = deref_copy (*_4);
        _6 = discriminant(((((*_154).2: options::parser::TakesValue) as Necessary).0: std::option::Option<&[&str]>));
        switchInt(move _6) -> [1: bb6, otherwise: bb11];
    }

    bb6: {
        _155 = deref_copy (*_4);
        _8 = ((((((*_155).2: options::parser::TakesValue) as Necessary).0: std::option::Option<&[&str]>) as Some).0: &[&str]);
        _152 = const _;
        _10 = _152 as &[&str] (PointerCoercion(Unsize));
        _15 = &_4;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _17 = &_5;
        _16 = core::fmt::rt::Argument::<'_>::new_debug::<&OsString>(_17) -> [return: bb8, unwind continue];
    }

    bb8: {
        _20 = Choices(_8);
        _19 = &_20;
        _18 = core::fmt::rt::Argument::<'_>::new_display::<Choices>(_19) -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = [move _14, move _16, move _18];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = std::fmt::Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = Formatter::<'_>::write_fmt(_2, move _9) -> [return: bb56, unwind continue];
    }

    bb11: {
        _151 = const _;
        _22 = _151 as &[&str] (PointerCoercion(Unsize));
        _27 = &_4;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_27) -> [return: bb12, unwind continue];
    }

    bb12: {
        _29 = &_5;
        _28 = core::fmt::rt::Argument::<'_>::new_debug::<&OsString>(_29) -> [return: bb13, unwind continue];
    }

    bb13: {
        _25 = [move _26, move _28];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = Formatter::<'_>::write_fmt(_2, move _21) -> [return: bb56, unwind continue];
    }

    bb15: {
        _30 = &(((*_1) as Parse).0: options::parser::ParseError);
        _150 = const _;
        _32 = _150 as &[&str] (PointerCoercion(Unsize));
        _37 = &_30;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<&ParseError>(_37) -> [return: bb16, unwind continue];
    }

    bb16: {
        _35 = [move _36];
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = std::fmt::Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = Formatter::<'_>::write_fmt(_2, move _31) -> [return: bb56, unwind continue];
    }

    bb18: {
        _38 = &(((*_1) as Unsupported).0: std::string::String);
        _149 = const _;
        _40 = _149 as &[&str] (PointerCoercion(Unsize));
        _45 = &_38;
        _44 = core::fmt::rt::Argument::<'_>::new_display::<&String>(_45) -> [return: bb19, unwind continue];
    }

    bb19: {
        _43 = [move _44];
        _42 = &_43;
        _41 = _42 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = std::fmt::Arguments::<'_>::new_v1(move _40, move _41) -> [return: bb20, unwind continue];
    }

    bb20: {
        _0 = Formatter::<'_>::write_fmt(_2, move _39) -> [return: bb56, unwind continue];
    }

    bb21: {
        _46 = &(((*_1) as Conflict).0: &options::parser::Arg);
        _47 = &(((*_1) as Conflict).1: &options::parser::Arg);
        _148 = const _;
        _49 = _148 as &[&str] (PointerCoercion(Unsize));
        _54 = &_46;
        _53 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_54) -> [return: bb22, unwind continue];
    }

    bb22: {
        _56 = &_47;
        _55 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_56) -> [return: bb23, unwind continue];
    }

    bb23: {
        _52 = [move _53, move _55];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = std::fmt::Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb24, unwind continue];
    }

    bb24: {
        _0 = Formatter::<'_>::write_fmt(_2, move _48) -> [return: bb56, unwind continue];
    }

    bb25: {
        _57 = &(((*_1) as Duplicate).0: options::parser::Flag);
        _58 = &_57;
        _59 = &(((*_1) as Duplicate).1: options::parser::Flag);
        _60 = &_59;
        _61 = <&Flag as PartialEq>::eq(_58, _60) -> [return: bb26, unwind continue];
    }

    bb26: {
        switchInt(move _61) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _147 = const _;
        _63 = _147 as &[&str] (PointerCoercion(Unsize));
        _68 = &_57;
        _67 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_68) -> [return: bb29, unwind continue];
    }

    bb28: {
        _69 = &(((*_1) as Duplicate).0: options::parser::Flag);
        _70 = &(((*_1) as Duplicate).1: options::parser::Flag);
        _146 = const _;
        _72 = _146 as &[&str] (PointerCoercion(Unsize));
        _77 = &_69;
        _76 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_77) -> [return: bb31, unwind continue];
    }

    bb29: {
        _66 = [move _67];
        _65 = &_66;
        _64 = _65 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _62 = std::fmt::Arguments::<'_>::new_v1(move _63, move _64) -> [return: bb30, unwind continue];
    }

    bb30: {
        _0 = Formatter::<'_>::write_fmt(_2, move _62) -> [return: bb56, unwind continue];
    }

    bb31: {
        _79 = &_70;
        _78 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_79) -> [return: bb32, unwind continue];
    }

    bb32: {
        _75 = [move _76, move _78];
        _74 = &_75;
        _73 = _74 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _71 = std::fmt::Arguments::<'_>::new_v1(move _72, move _73) -> [return: bb33, unwind continue];
    }

    bb33: {
        _0 = Formatter::<'_>::write_fmt(_2, move _71) -> [return: bb56, unwind continue];
    }

    bb34: {
        _80 = &(((*_1) as Useless).0: &options::parser::Arg);
        _81 = &(((*_1) as Useless).2: &options::parser::Arg);
        _145 = const _;
        _83 = _145 as &[&str] (PointerCoercion(Unsize));
        _88 = &_80;
        _87 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_88) -> [return: bb35, unwind continue];
    }

    bb35: {
        _90 = &_81;
        _89 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_90) -> [return: bb36, unwind continue];
    }

    bb36: {
        _86 = [move _87, move _89];
        _85 = &_86;
        _84 = _85 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _82 = std::fmt::Arguments::<'_>::new_v1(move _83, move _84) -> [return: bb37, unwind continue];
    }

    bb37: {
        _0 = Formatter::<'_>::write_fmt(_2, move _82) -> [return: bb56, unwind continue];
    }

    bb38: {
        _91 = &(((*_1) as Useless).0: &options::parser::Arg);
        _92 = &(((*_1) as Useless).2: &options::parser::Arg);
        _144 = const _;
        _94 = _144 as &[&str] (PointerCoercion(Unsize));
        _99 = &_91;
        _98 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_99) -> [return: bb39, unwind continue];
    }

    bb39: {
        _101 = &_92;
        _100 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_101) -> [return: bb40, unwind continue];
    }

    bb40: {
        _97 = [move _98, move _100];
        _96 = &_97;
        _95 = _96 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _93 = std::fmt::Arguments::<'_>::new_v1(move _94, move _95) -> [return: bb41, unwind continue];
    }

    bb41: {
        _0 = Formatter::<'_>::write_fmt(_2, move _93) -> [return: bb56, unwind continue];
    }

    bb42: {
        _102 = &(((*_1) as Useless2).0: &options::parser::Arg);
        _103 = &(((*_1) as Useless2).1: &options::parser::Arg);
        _104 = &(((*_1) as Useless2).2: &options::parser::Arg);
        _143 = const _;
        _106 = _143 as &[&str] (PointerCoercion(Unsize));
        _111 = &_102;
        _110 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_111) -> [return: bb43, unwind continue];
    }

    bb43: {
        _113 = &_103;
        _112 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_113) -> [return: bb44, unwind continue];
    }

    bb44: {
        _115 = &_104;
        _114 = core::fmt::rt::Argument::<'_>::new_display::<&&Arg>(_115) -> [return: bb45, unwind continue];
    }

    bb45: {
        _109 = [move _110, move _112, move _114];
        _108 = &_109;
        _107 = _108 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _105 = std::fmt::Arguments::<'_>::new_v1(move _106, move _107) -> [return: bb46, unwind continue];
    }

    bb46: {
        _0 = Formatter::<'_>::write_fmt(_2, move _105) -> [return: bb56, unwind continue];
    }

    bb47: {
        _142 = const _;
        _117 = _142 as &[&str] (PointerCoercion(Unsize));
        _116 = std::fmt::Arguments::<'_>::new_const(move _117) -> [return: bb48, unwind continue];
    }

    bb48: {
        _0 = Formatter::<'_>::write_fmt(_2, move _116) -> [return: bb56, unwind continue];
    }

    bb49: {
        _118 = &(((*_1) as FailedParse).0: std::string::String);
        _119 = &(((*_1) as FailedParse).1: options::error::NumberSource);
        _120 = &(((*_1) as FailedParse).2: std::num::ParseIntError);
        _141 = const _;
        _122 = _141 as &[&str] (PointerCoercion(Unsize));
        _127 = &_118;
        _126 = core::fmt::rt::Argument::<'_>::new_debug::<&String>(_127) -> [return: bb50, unwind continue];
    }

    bb50: {
        _129 = &_119;
        _128 = core::fmt::rt::Argument::<'_>::new_display::<&NumberSource>(_129) -> [return: bb51, unwind continue];
    }

    bb51: {
        _131 = &_120;
        _130 = core::fmt::rt::Argument::<'_>::new_display::<&ParseIntError>(_131) -> [return: bb52, unwind continue];
    }

    bb52: {
        _125 = [move _126, move _128, move _130];
        _124 = &_125;
        _123 = _124 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _121 = std::fmt::Arguments::<'_>::new_v1(move _122, move _123) -> [return: bb53, unwind continue];
    }

    bb53: {
        _0 = Formatter::<'_>::write_fmt(_2, move _121) -> [return: bb56, unwind continue];
    }

    bb54: {
        _137 = [move _138];
        _136 = &_137;
        _135 = _136 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _133 = std::fmt::Arguments::<'_>::new_v1(move _134, move _135) -> [return: bb55, unwind continue];
    }

    bb55: {
        _0 = Formatter::<'_>::write_fmt(_2, move _133) -> [return: bb56, unwind continue];
    }

    bb56: {
        return;
    }
}

promoted[0] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to parse glob pattern: "];
        _0 = &_1;
        return;
    }
}

promoted[1] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Value ", const " not valid for ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Option --tree is useless given --all --all"];
        _0 = &_1;
        return;
    }
}

promoted[3] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Option ", const " is useless without options ", const " or "];
        _0 = &_1;
        return;
    }
}

promoted[4] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Option ", const " is useless given option "];
        _0 = &_1;
        return;
    }
}

promoted[5] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Option ", const " is useless without option "];
        _0 = &_1;
        return;
    }
}

promoted[6] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Flag ", const " conflicts with flag "];
        _0 = &_1;
        return;
    }
}

promoted[7] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Flag ", const " was given twice"];
        _0 = &_1;
        return;
    }
}

promoted[8] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Option ", const " conflicts with option "];
        _0 = &_1;
        return;
    }
}

promoted[9] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[10] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[11] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Option ", const " has no ", const " setting"];
        _0 = &_1;
        return;
    }
}

promoted[12] in options::error::<impl at src/options/error.rs:72:1: 72:35>::fmt: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "Option ", const " has no ", const " setting (", const ")"];
        _0 = &_1;
        return;
    }
}

fn options::error::<impl at src/options/error.rs:100:1: 100:18>::suggestion(_1: &OptionsError) -> Option<&str> {
    debug self => _1;
    let mut _0: std::option::Option<&str>;
    let mut _2: isize;
    let mut _3: isize;
    let _4: &&options::parser::Arg;
    let _5: &&&options::parser::Arg;
    let _6: &std::ffi::OsString;
    let _7: &&std::ffi::OsString;
    let mut _8: bool;
    let mut _9: &&options::parser::Arg;
    let _10: &options::parser::Arg;
    let _11: &options::parser::Arg;
    let mut _12: bool;
    let _13: &str;
    let _14: &options::parser::Flag;
    let _15: &&options::parser::Flag;
    let mut _16: bool;
    let _17: &str;
    let mut _18: &options::parser::Flag;
    let mut _19: &&str;
    let mut _20: &&options::parser::Arg;
    let mut _21: &options::parser::Flag;
    scope 1 {
        debug time => _4;
        debug time => _5;
        debug r => _6;
        debug r => _7;
    }
    scope 2 {
        debug flag => _14;
        debug flag => _15;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _2 = discriminant((((*_1) as Parse).0: options::parser::ParseError));
        switchInt(move _2) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<&str>::None;
        goto -> bb11;
    }

    bb3: {
        _4 = &(((*_1) as BadArgument).0: &options::parser::Arg);
        _5 = &_4;
        _6 = &(((*_1) as BadArgument).1: std::ffi::OsString);
        _7 = &_6;
        _20 = deref_copy (*_5);
        _11 = const {alloc41: &Arg};
        _10 = _11;
        _9 = &_10;
        _8 = <&Arg as PartialEq>::eq(_20, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _8) -> [0: bb2, otherwise: bb5];
    }

    bb5: {
        _19 = const _;
        _12 = <&OsString as PartialEq<&str>>::eq(_7, _19) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _12) -> [0: bb2, otherwise: bb7];
    }

    bb7: {
        _13 = const "To sort oldest files last, try \"--sort oldest\", or just \"-sold\"";
        _0 = Option::<&str>::Some(_13);
        goto -> bb11;
    }

    bb8: {
        _14 = &(((((*_1) as Parse).0: options::parser::ParseError) as NeedsValue).0: options::parser::Flag);
        _15 = &_14;
        _21 = deref_copy (*_15);
        _18 = const _;
        _16 = <Flag as PartialEq>::eq(_21, _18) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _16) -> [0: bb2, otherwise: bb10];
    }

    bb10: {
        _17 = const "To sort newest files last, try \"--sort newest\", or just \"-snew\"";
        _0 = Option::<&str>::Some(_17);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

alloc41 (static: TIME, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4293<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4301<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 74 __ __ __ __ __ __  .........t
}

alloc4293 (size: 64, align: 8) {
    0x00  alloc4292<imm> 08 00 00 00 00 00 00 00  ........
    0x10  alloc4294<imm> 07 00 00 00 00 00 00 00  ........
    0x20  alloc4295<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4296<imm> 07 00 00 00 00 00 00 00  ........
}

alloc4292 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4294 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4295 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4296 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4301 (size: 4, align: 1) {
    74 69 6d 65                                      time
}

promoted[0] in options::error::<impl at src/options/error.rs:100:1: 100:18>::suggestion: &Flag = {
    let mut _0: &options::parser::Flag;
    let mut _1: options::parser::Flag;

    bb0: {
        _1 = Flag::Short(const 116_u8);
        _0 = &_1;
        return;
    }
}

promoted[1] in options::error::<impl at src/options/error.rs:100:1: 100:18>::suggestion: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "r";
        _0 = &_1;
        return;
    }
}

fn options::error::<impl at src/options/error.rs:122:10: 122:19>::eq(_1: &Choices, _2: &Choices) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &&[&str];
    let mut _4: &&[&str];

    bb0: {
        _3 = &((*_1).0: &[&str]);
        _4 = &((*_2).0: &[&str]);
        _0 = <&[&str] as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:122:21: 122:26>::fmt(_1: &Choices, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&&[&str];
    let _6: &&[&str];

    bb0: {
        _3 = const "Choices";
        _6 = &((*_1).0: &[&str]);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::error::<impl at src/options/error.rs:125:1: 125:30>::fmt(_1: &Choices, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &std::string::String;
    let _10: std::string::String;
    let _11: &str;
    let mut _12: &[&str; 1];
    let mut _13: &[&str];

    bb0: {
        _12 = const _;
        _4 = _12 as &[&str] (PointerCoercion(Unsize));
        _13 = deref_copy ((*_1).0: &[&str]);
        _11 = const ", ";
        _10 = slice::<impl [&str]>::join::<&str>(_13, _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<String>(_9) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = std::fmt::Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_10) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_10) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

promoted[0] in options::error::<impl at src/options/error.rs:125:1: 125:30>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "choices: "];
        _0 = &_1;
        return;
    }
}

static USAGE_PART1: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Usage:\n  exa [options] [files...]\n\nMETA OPTIONS\n  -?, --help         show list of command-line options\n  -v, --version      show version of exa\n\nDISPLAY OPTIONS\n  -1, --oneline      display one entry per line\n  -l, --long         display extended file metadata as a table\n  -G, --grid         display entries as a grid (default)\n  -x, --across       sort the grid across, rather than downwards\n  -R, --recurse      recurse into directories\n  -T, --tree         recurse into directories as a tree\n  -F, --classify     display type indicator by file names\n  --colo[u]r=WHEN    when to use terminal colours (always, auto, never)\n  --colo[u]r-scale   highlight levels of file sizes distinctly\n  --icons            display icons\n  --no-icons         don't display icons (always overrides --icons)\n\nFILTERING AND SORTING OPTIONS\n  -a, --all                  show hidden and 'dot' files\n  -d, --list-dirs            list directories as files; don't list their contents\n  -L, --level DEPTH          limit the depth of recursion\n  -r, --reverse              reverse the sort order\n  -s, --sort SORT_FIELD      which field to sort by\n  --group-directories-first  list directories before other files\n  -D, --only-dirs            list only directories\n  -I, --ignore-glob GLOBS    glob patterns (pipe-separated) of files to ignore";
        return;
    }
}

static USAGE_PART2: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "  Valid sort fields:         name, Name, extension, Extension, size, type,\n                             modified, accessed, created, inode, and none.\n                             date, time, old, and new all refer to modified.\n\nLONG VIEW OPTIONS\n  -b, --binary         list file sizes with binary prefixes\n  -B, --bytes          list file sizes in bytes, without any prefixes\n  -g, --group          list each file's group\n  -h, --header         add a header row to each column\n  -H, --links          list each file's number of hard links\n  -i, --inode          list each file's inode number\n  -m, --modified       use the modified timestamp field\n  -n, --numeric        list numeric user and group IDs\n  -S, --blocks         show number of file system blocks\n  -t, --time FIELD     which timestamp field to list (modified, accessed, created)\n  -u, --accessed       use the accessed timestamp field\n  -U, --created        use the created timestamp field\n  --changed            use the changed timestamp field\n  --time-style         how to format timestamps (default, iso, long-iso, full-iso)\n  --no-permissions     suppress the permissions field\n  --octal-permissions  list each file's permission in octal format\n  --no-filesize        suppress the filesize field\n  --no-user            suppress the user field\n  --no-time            suppress the time field";
        return;
    }
}

static GIT_FILTER_HELP: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "  --git-ignore               ignore files mentioned in '.gitignore'";
        return;
    }
}

static GIT_VIEW_HELP: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "  --git                list each file's Git status, if tracked or ignored";
        return;
    }
}

static EXTENDED_HELP: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "  -@, --extended       list each file's extended attributes and sizes";
        return;
    }
}

fn help::<impl at src/options/help.rs:72:10: 72:19>::eq(_1: &HelpString, _2: &HelpString) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn help::<impl at src/options/help.rs:72:21: 72:26>::fmt(_1: &HelpString, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "HelpString";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn help::<impl at src/options/help.rs:72:34: 72:39>::clone(_1: &HelpString) -> HelpString {
    debug self => _1;
    let mut _0: options::help::HelpString;

    bb0: {
        return;
    }
}

fn help::<impl at src/options/help.rs:75:1: 75:16>::deduce(_1: &MatchedFlags<'_>) -> Option<HelpString> {
    debug matches => _1;
    let mut _0: std::option::Option<options::help::HelpString>;
    let mut _2: bool;
    let mut _3: usize;
    let _4: &options::parser::Arg;

    bb0: {
        _4 = const {alloc22: &Arg};
        _3 = MatchedFlags::<'_>::count(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Gt(move _3, const 0_usize);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<HelpString>::Some(const HelpString);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<HelpString>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

alloc22 (static: HELP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4107<imm>  
    0x20  04 00 00 00 00 00 00 00 01 3f __ __ __ __ __ __  .........?
}

alloc4107 (size: 4, align: 1) {
    68 65 6c 70                                      help
}

fn help::<impl at src/options/help.rs:94:1: 94:33>::fmt(_1: &HelpString, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _4: std::result::Result<(), std::fmt::Error>;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &&str;
    let mut _12: isize;
    let mut _13: bool;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _15: std::result::Result<(), std::fmt::Error>;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&str;
    let mut _23: isize;
    let mut _24: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _25: std::result::Result<(), std::fmt::Error>;
    let mut _26: std::fmt::Arguments<'_>;
    let mut _27: &[&str];
    let mut _28: &[core::fmt::rt::Argument<'_>];
    let _29: &[core::fmt::rt::Argument<'_>; 1];
    let _30: [core::fmt::rt::Argument<'_>; 1];
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &&str;
    let mut _33: isize;
    let mut _34: bool;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _36: std::result::Result<(), std::fmt::Error>;
    let mut _37: std::fmt::Arguments<'_>;
    let mut _38: &[&str];
    let mut _39: &[core::fmt::rt::Argument<'_>];
    let _40: &[core::fmt::rt::Argument<'_>; 1];
    let _41: [core::fmt::rt::Argument<'_>; 1];
    let mut _42: core::fmt::rt::Argument<'_>;
    let _43: &&str;
    let mut _44: isize;
    let mut _45: bool;
    let mut _46: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _47: std::result::Result<(), std::fmt::Error>;
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 1];
    let _52: [core::fmt::rt::Argument<'_>; 1];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &&str;
    let mut _55: isize;
    let mut _56: std::fmt::Arguments<'_>;
    let mut _57: &[&str];
    let mut _58: &[&str; 1];
    let mut _59: &[&str; 1];
    let mut _60: &[&str; 1];
    let mut _61: &[&str; 1];
    let mut _62: &[&str; 1];
    let mut _63: &[&str; 1];
    scope 1 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 2 {
        }
    }
    scope 3 {
        debug val => const ();
        scope 4 {
        }
    }
    scope 5 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 6 {
        }
    }
    scope 7 {
        debug val => const ();
        scope 8 {
        }
    }
    scope 9 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 10 {
        }
    }
    scope 11 {
        debug val => const ();
        scope 12 {
        }
    }
    scope 13 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 14 {
        }
    }
    scope 15 {
        debug val => const ();
        scope 16 {
        }
    }
    scope 17 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 18 {
        }
    }
    scope 19 {
        debug val => const ();
        scope 20 {
        }
    }

    bb0: {
        _63 = const _;
        _6 = _63 as &[&str] (PointerCoercion(Unsize));
        _11 = const {alloc57: &&str};
        _10 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <Result<(), std::fmt::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_3);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = const true;
        switchInt(move _13) -> [0: bb14, otherwise: bb8];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb36, unwind continue];
    }

    bb8: {
        _62 = const _;
        _17 = _62 as &[&str] (PointerCoercion(Unsize));
        _22 = const {alloc58: &&str};
        _21 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_22) -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = std::fmt::Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb10, unwind continue];
    }

    bb10: {
        _15 = Formatter::<'_>::write_fmt(_2, move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        _14 = <Result<(), std::fmt::Error> as Try>::branch(move _15) -> [return: bb12, unwind continue];
    }

    bb12: {
        _23 = discriminant(_14);
        switchInt(move _23) -> [0: bb14, 1: bb13, otherwise: bb6];
    }

    bb13: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb36, unwind continue];
    }

    bb14: {
        _61 = const _;
        _27 = _61 as &[&str] (PointerCoercion(Unsize));
        _32 = const {alloc59: &&str};
        _31 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_32) -> [return: bb15, unwind continue];
    }

    bb15: {
        _30 = [move _31];
        _29 = &_30;
        _28 = _29 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _26 = std::fmt::Arguments::<'_>::new_v1(move _27, move _28) -> [return: bb16, unwind continue];
    }

    bb16: {
        _25 = Formatter::<'_>::write_fmt(_2, move _26) -> [return: bb17, unwind continue];
    }

    bb17: {
        _24 = <Result<(), std::fmt::Error> as Try>::branch(move _25) -> [return: bb18, unwind continue];
    }

    bb18: {
        _33 = discriminant(_24);
        switchInt(move _33) -> [0: bb19, 1: bb20, otherwise: bb6];
    }

    bb19: {
        _34 = const true;
        switchInt(move _34) -> [0: bb27, otherwise: bb21];
    }

    bb20: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb36, unwind continue];
    }

    bb21: {
        _60 = const _;
        _38 = _60 as &[&str] (PointerCoercion(Unsize));
        _43 = const {alloc60: &&str};
        _42 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_43) -> [return: bb22, unwind continue];
    }

    bb22: {
        _41 = [move _42];
        _40 = &_41;
        _39 = _40 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _37 = std::fmt::Arguments::<'_>::new_v1(move _38, move _39) -> [return: bb23, unwind continue];
    }

    bb23: {
        _36 = Formatter::<'_>::write_fmt(_2, move _37) -> [return: bb24, unwind continue];
    }

    bb24: {
        _35 = <Result<(), std::fmt::Error> as Try>::branch(move _36) -> [return: bb25, unwind continue];
    }

    bb25: {
        _44 = discriminant(_35);
        switchInt(move _44) -> [0: bb27, 1: bb26, otherwise: bb6];
    }

    bb26: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb36, unwind continue];
    }

    bb27: {
        _45 = const _;
        switchInt(move _45) -> [0: bb34, otherwise: bb28];
    }

    bb28: {
        _59 = const _;
        _49 = _59 as &[&str] (PointerCoercion(Unsize));
        _54 = const {alloc61: &&str};
        _53 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_54) -> [return: bb29, unwind continue];
    }

    bb29: {
        _52 = [move _53];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = std::fmt::Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb30, unwind continue];
    }

    bb30: {
        _47 = Formatter::<'_>::write_fmt(_2, move _48) -> [return: bb31, unwind continue];
    }

    bb31: {
        _46 = <Result<(), std::fmt::Error> as Try>::branch(move _47) -> [return: bb32, unwind continue];
    }

    bb32: {
        _55 = discriminant(_46);
        switchInt(move _55) -> [0: bb34, 1: bb33, otherwise: bb6];
    }

    bb33: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb36, unwind continue];
    }

    bb34: {
        _58 = const _;
        _57 = _58 as &[&str] (PointerCoercion(Unsize));
        _56 = std::fmt::Arguments::<'_>::new_const(move _57) -> [return: bb35, unwind continue];
    }

    bb35: {
        _0 = Formatter::<'_>::write_fmt(_2, move _56) -> [return: bb36, unwind continue];
    }

    bb36: {
        return;
    }
}

alloc61 (static: EXTENDED_HELP, size: 16, align: 8) {
    alloc4378<imm> 45 00 00 00 00 00 00 00  E.......
}

alloc4378 (size: 69, align: 1) {
    0x00  20 20 2d 40 2c 20 2d 2d 65 78 74 65 6e 64 65 64    -@, --extended
    0x10  20 20 20 20 20 20 20 6c 69 73 74 20 65 61 63 68         list each
    0x20  20 66 69 6c 65 27 73 20 65 78 74 65 6e 64 65 64   file's extended
    0x30  20 61 74 74 72 69 62 75 74 65 73 20 61 6e 64 20   attributes and 
    0x40  73 69 7a 65 73                                   sizes
}

alloc60 (static: GIT_VIEW_HELP, size: 16, align: 8) {
    alloc4376<imm> 49 00 00 00 00 00 00 00  I.......
}

alloc4376 (size: 73, align: 1) {
    0x00  20 20 2d 2d 67 69 74 20 20 20 20 20 20 20 20 20    --git         
    0x10  20 20 20 20 20 20 20 6c 69 73 74 20 65 61 63 68         list each
    0x20  20 66 69 6c 65 27 73 20 47 69 74 20 73 74 61 74   file's Git stat
    0x30  75 73 2c 20 69 66 20 74 72 61 63 6b 65 64 20 6f  us, if tracked o
    0x40  72 20 69 67 6e 6f 72 65 64                       r ignored
}

alloc59 (static: USAGE_PART2, size: 16, align: 8) {
    alloc4372<imm> 4c 05 00 00 00 00 00 00  L.......
}

alloc4372 (size: 1356, align: 1) {
    0x000  20 20 56 61 6c 69 64 20 73 6f 72 74 20 66 69 65    Valid sort fie
    0x010  6c 64 73 3a 20 20 20 20 20 20 20 20 20 6e 61 6d  lds:         nam
    0x020  65 2c 20 4e 61 6d 65 2c 20 65 78 74 65 6e 73 69  e, Name, extensi
    0x030  6f 6e 2c 20 45 78 74 65 6e 73 69 6f 6e 2c 20 73  on, Extension, s
    0x040  69 7a 65 2c 20 74 79 70 65 2c 0a 20 20 20 20 20  ize, type,.     
    0x050  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                  
    0x060  20 20 20 20 20 20 20 20 6d 6f 64 69 66 69 65 64          modified
    0x070  2c 20 61 63 63 65 73 73 65 64 2c 20 63 72 65 61  , accessed, crea
    0x080  74 65 64 2c 20 69 6e 6f 64 65 2c 20 61 6e 64 20  ted, inode, and 
    0x090  6e 6f 6e 65 2e 0a 20 20 20 20 20 20 20 20 20 20  none..          
    0x0a0  20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                  
    0x0b0  20 20 20 64 61 74 65 2c 20 74 69 6d 65 2c 20 6f     date, time, o
    0x0c0  6c 64 2c 20 61 6e 64 20 6e 65 77 20 61 6c 6c 20  ld, and new all 
    0x0d0  72 65 66 65 72 20 74 6f 20 6d 6f 64 69 66 69 65  refer to modifie
    0x0e0  64 2e 0a 0a 4c 4f 4e 47 20 56 49 45 57 20 4f 50  d...LONG VIEW OP
    0x0f0  54 49 4f 4e 53 0a 20 20 2d 62 2c 20 2d 2d 62 69  TIONS.  -b, --bi
    0x100  6e 61 72 79 20 20 20 20 20 20 20 20 20 6c 69 73  nary         lis
    0x110  74 20 66 69 6c 65 20 73 69 7a 65 73 20 77 69 74  t file sizes wit
    0x120  68 20 62 69 6e 61 72 79 20 70 72 65 66 69 78 65  h binary prefixe
    0x130  73 0a 20 20 2d 42 2c 20 2d 2d 62 79 74 65 73 20  s.  -B, --bytes 
    0x140  20 20 20 20 20 20 20 20 20 6c 69 73 74 20 66 69           list fi
    0x150  6c 65 20 73 69 7a 65 73 20 69 6e 20 62 79 74 65  le sizes in byte
    0x160  73 2c 20 77 69 74 68 6f 75 74 20 61 6e 79 20 70  s, without any p
    0x170  72 65 66 69 78 65 73 0a 20 20 2d 67 2c 20 2d 2d  refixes.  -g, --
    0x180  67 72 6f 75 70 20 20 20 20 20 20 20 20 20 20 6c  group          l
    0x190  69 73 74 20 65 61 63 68 20 66 69 6c 65 27 73 20  ist each file's 
    0x1a0  67 72 6f 75 70 0a 20 20 2d 68 2c 20 2d 2d 68 65  group.  -h, --he
    0x1b0  61 64 65 72 20 20 20 20 20 20 20 20 20 61 64 64  ader         add
    0x1c0  20 61 20 68 65 61 64 65 72 20 72 6f 77 20 74 6f   a header row to
    0x1d0  20 65 61 63 68 20 63 6f 6c 75 6d 6e 0a 20 20 2d   each column.  -
    0x1e0  48 2c 20 2d 2d 6c 69 6e 6b 73 20 20 20 20 20 20  H, --links      
    0x1f0  20 20 20 20 6c 69 73 74 20 65 61 63 68 20 66 69      list each fi
    0x200  6c 65 27 73 20 6e 75 6d 62 65 72 20 6f 66 20 68  le's number of h
    0x210  61 72 64 20 6c 69 6e 6b 73 0a 20 20 2d 69 2c 20  ard links.  -i, 
    0x220  2d 2d 69 6e 6f 64 65 20 20 20 20 20 20 20 20 20  --inode         
    0x230  20 6c 69 73 74 20 65 61 63 68 20 66 69 6c 65 27   list each file'
    0x240  73 20 69 6e 6f 64 65 20 6e 75 6d 62 65 72 0a 20  s inode number. 
    0x250  20 2d 6d 2c 20 2d 2d 6d 6f 64 69 66 69 65 64 20   -m, --modified 
    0x260  20 20 20 20 20 20 75 73 65 20 74 68 65 20 6d 6f        use the mo
    0x270  64 69 66 69 65 64 20 74 69 6d 65 73 74 61 6d 70  dified timestamp
    0x280  20 66 69 65 6c 64 0a 20 20 2d 6e 2c 20 2d 2d 6e   field.  -n, --n
    0x290  75 6d 65 72 69 63 20 20 20 20 20 20 20 20 6c 69  umeric        li
    0x2a0  73 74 20 6e 75 6d 65 72 69 63 20 75 73 65 72 20  st numeric user 
    0x2b0  61 6e 64 20 67 72 6f 75 70 20 49 44 73 0a 20 20  and group IDs.  
    0x2c0  2d 53 2c 20 2d 2d 62 6c 6f 63 6b 73 20 20 20 20  -S, --blocks    
    0x2d0  20 20 20 20 20 73 68 6f 77 20 6e 75 6d 62 65 72       show number
    0x2e0  20 6f 66 20 66 69 6c 65 20 73 79 73 74 65 6d 20   of file system 
    0x2f0  62 6c 6f 63 6b 73 0a 20 20 2d 74 2c 20 2d 2d 74  blocks.  -t, --t
    0x300  69 6d 65 20 46 49 45 4c 44 20 20 20 20 20 77 68  ime FIELD     wh
    0x310  69 63 68 20 74 69 6d 65 73 74 61 6d 70 20 66 69  ich timestamp fi
    0x320  65 6c 64 20 74 6f 20 6c 69 73 74 20 28 6d 6f 64  eld to list (mod
    0x330  69 66 69 65 64 2c 20 61 63 63 65 73 73 65 64 2c  ified, accessed,
    0x340  20 63 72 65 61 74 65 64 29 0a 20 20 2d 75 2c 20   created).  -u, 
    0x350  2d 2d 61 63 63 65 73 73 65 64 20 20 20 20 20 20  --accessed      
    0x360  20 75 73 65 20 74 68 65 20 61 63 63 65 73 73 65   use the accesse
    0x370  64 20 74 69 6d 65 73 74 61 6d 70 20 66 69 65 6c  d timestamp fiel
    0x380  64 0a 20 20 2d 55 2c 20 2d 2d 63 72 65 61 74 65  d.  -U, --create
    0x390  64 20 20 20 20 20 20 20 20 75 73 65 20 74 68 65  d        use the
    0x3a0  20 63 72 65 61 74 65 64 20 74 69 6d 65 73 74 61   created timesta
    0x3b0  6d 70 20 66 69 65 6c 64 0a 20 20 2d 2d 63 68 61  mp field.  --cha
    0x3c0  6e 67 65 64 20 20 20 20 20 20 20 20 20 20 20 20  nged            
    0x3d0  75 73 65 20 74 68 65 20 63 68 61 6e 67 65 64 20  use the changed 
    0x3e0  74 69 6d 65 73 74 61 6d 70 20 66 69 65 6c 64 0a  timestamp field.
    0x3f0  20 20 2d 2d 74 69 6d 65 2d 73 74 79 6c 65 20 20    --time-style  
    0x400  20 20 20 20 20 20 20 68 6f 77 20 74 6f 20 66 6f         how to fo
    0x410  72 6d 61 74 20 74 69 6d 65 73 74 61 6d 70 73 20  rmat timestamps 
    0x420  28 64 65 66 61 75 6c 74 2c 20 69 73 6f 2c 20 6c  (default, iso, l
    0x430  6f 6e 67 2d 69 73 6f 2c 20 66 75 6c 6c 2d 69 73  ong-iso, full-is
    0x440  6f 29 0a 20 20 2d 2d 6e 6f 2d 70 65 72 6d 69 73  o).  --no-permis
    0x450  73 69 6f 6e 73 20 20 20 20 20 73 75 70 70 72 65  sions     suppre
    0x460  73 73 20 74 68 65 20 70 65 72 6d 69 73 73 69 6f  ss the permissio
    0x470  6e 73 20 66 69 65 6c 64 0a 20 20 2d 2d 6f 63 74  ns field.  --oct
    0x480  61 6c 2d 70 65 72 6d 69 73 73 69 6f 6e 73 20 20  al-permissions  
    0x490  6c 69 73 74 20 65 61 63 68 20 66 69 6c 65 27 73  list each file's
    0x4a0  20 70 65 72 6d 69 73 73 69 6f 6e 20 69 6e 20 6f   permission in o
    0x4b0  63 74 61 6c 20 66 6f 72 6d 61 74 0a 20 20 2d 2d  ctal format.  --
    0x4c0  6e 6f 2d 66 69 6c 65 73 69 7a 65 20 20 20 20 20  no-filesize     
    0x4d0  20 20 20 73 75 70 70 72 65 73 73 20 74 68 65 20     suppress the 
    0x4e0  66 69 6c 65 73 69 7a 65 20 66 69 65 6c 64 0a 20  filesize field. 
    0x4f0  20 2d 2d 6e 6f 2d 75 73 65 72 20 20 20 20 20 20   --no-user      
    0x500  20 20 20 20 20 20 73 75 70 70 72 65 73 73 20 74        suppress t
    0x510  68 65 20 75 73 65 72 20 66 69 65 6c 64 0a 20 20  he user field.  
    0x520  2d 2d 6e 6f 2d 74 69 6d 65 20 20 20 20 20 20 20  --no-time       
    0x530  20 20 20 20 20 73 75 70 70 72 65 73 73 20 74 68       suppress th
    0x540  65 20 74 69 6d 65 20 66 69 65 6c 64              e time field
}

alloc58 (static: GIT_FILTER_HELP, size: 16, align: 8) {
    alloc4374<imm> 43 00 00 00 00 00 00 00  C.......
}

alloc4374 (size: 67, align: 1) {
    0x00  20 20 2d 2d 67 69 74 2d 69 67 6e 6f 72 65 20 20    --git-ignore  
    0x10  20 20 20 20 20 20 20 20 20 20 20 20 20 69 67 6e               ign
    0x20  6f 72 65 20 66 69 6c 65 73 20 6d 65 6e 74 69 6f  ore files mentio
    0x30  6e 65 64 20 69 6e 20 27 2e 67 69 74 69 67 6e 6f  ned in '.gitigno
    0x40  72 65 27                                         re'
}

alloc57 (static: USAGE_PART1, size: 16, align: 8) {
    alloc4370<imm> 26 05 00 00 00 00 00 00  &.......
}

alloc4370 (size: 1318, align: 1) {
    0x000  55 73 61 67 65 3a 0a 20 20 65 78 61 20 5b 6f 70  Usage:.  exa [op
    0x010  74 69 6f 6e 73 5d 20 5b 66 69 6c 65 73 2e 2e 2e  tions] [files...
    0x020  5d 0a 0a 4d 45 54 41 20 4f 50 54 49 4f 4e 53 0a  ]..META OPTIONS.
    0x030  20 20 2d 3f 2c 20 2d 2d 68 65 6c 70 20 20 20 20    -?, --help    
    0x040  20 20 20 20 20 73 68 6f 77 20 6c 69 73 74 20 6f       show list o
    0x050  66 20 63 6f 6d 6d 61 6e 64 2d 6c 69 6e 65 20 6f  f command-line o
    0x060  70 74 69 6f 6e 73 0a 20 20 2d 76 2c 20 2d 2d 76  ptions.  -v, --v
    0x070  65 72 73 69 6f 6e 20 20 20 20 20 20 73 68 6f 77  ersion      show
    0x080  20 76 65 72 73 69 6f 6e 20 6f 66 20 65 78 61 0a   version of exa.
    0x090  0a 44 49 53 50 4c 41 59 20 4f 50 54 49 4f 4e 53  .DISPLAY OPTIONS
    0x0a0  0a 20 20 2d 31 2c 20 2d 2d 6f 6e 65 6c 69 6e 65  .  -1, --oneline
    0x0b0  20 20 20 20 20 20 64 69 73 70 6c 61 79 20 6f 6e        display on
    0x0c0  65 20 65 6e 74 72 79 20 70 65 72 20 6c 69 6e 65  e entry per line
    0x0d0  0a 20 20 2d 6c 2c 20 2d 2d 6c 6f 6e 67 20 20 20  .  -l, --long   
    0x0e0  20 20 20 20 20 20 64 69 73 70 6c 61 79 20 65 78        display ex
    0x0f0  74 65 6e 64 65 64 20 66 69 6c 65 20 6d 65 74 61  tended file meta
    0x100  64 61 74 61 20 61 73 20 61 20 74 61 62 6c 65 0a  data as a table.
    0x110  20 20 2d 47 2c 20 2d 2d 67 72 69 64 20 20 20 20    -G, --grid    
    0x120  20 20 20 20 20 64 69 73 70 6c 61 79 20 65 6e 74       display ent
    0x130  72 69 65 73 20 61 73 20 61 20 67 72 69 64 20 28  ries as a grid (
    0x140  64 65 66 61 75 6c 74 29 0a 20 20 2d 78 2c 20 2d  default).  -x, -
    0x150  2d 61 63 72 6f 73 73 20 20 20 20 20 20 20 73 6f  -across       so
    0x160  72 74 20 74 68 65 20 67 72 69 64 20 61 63 72 6f  rt the grid acro
    0x170  73 73 2c 20 72 61 74 68 65 72 20 74 68 61 6e 20  ss, rather than 
    0x180  64 6f 77 6e 77 61 72 64 73 0a 20 20 2d 52 2c 20  downwards.  -R, 
    0x190  2d 2d 72 65 63 75 72 73 65 20 20 20 20 20 20 72  --recurse      r
    0x1a0  65 63 75 72 73 65 20 69 6e 74 6f 20 64 69 72 65  ecurse into dire
    0x1b0  63 74 6f 72 69 65 73 0a 20 20 2d 54 2c 20 2d 2d  ctories.  -T, --
    0x1c0  74 72 65 65 20 20 20 20 20 20 20 20 20 72 65 63  tree         rec
    0x1d0  75 72 73 65 20 69 6e 74 6f 20 64 69 72 65 63 74  urse into direct
    0x1e0  6f 72 69 65 73 20 61 73 20 61 20 74 72 65 65 0a  ories as a tree.
    0x1f0  20 20 2d 46 2c 20 2d 2d 63 6c 61 73 73 69 66 79    -F, --classify
    0x200  20 20 20 20 20 64 69 73 70 6c 61 79 20 74 79 70       display typ
    0x210  65 20 69 6e 64 69 63 61 74 6f 72 20 62 79 20 66  e indicator by f
    0x220  69 6c 65 20 6e 61 6d 65 73 0a 20 20 2d 2d 63 6f  ile names.  --co
    0x230  6c 6f 5b 75 5d 72 3d 57 48 45 4e 20 20 20 20 77  lo[u]r=WHEN    w
    0x240  68 65 6e 20 74 6f 20 75 73 65 20 74 65 72 6d 69  hen to use termi
    0x250  6e 61 6c 20 63 6f 6c 6f 75 72 73 20 28 61 6c 77  nal colours (alw
    0x260  61 79 73 2c 20 61 75 74 6f 2c 20 6e 65 76 65 72  ays, auto, never
    0x270  29 0a 20 20 2d 2d 63 6f 6c 6f 5b 75 5d 72 2d 73  ).  --colo[u]r-s
    0x280  63 61 6c 65 20 20 20 68 69 67 68 6c 69 67 68 74  cale   highlight
    0x290  20 6c 65 76 65 6c 73 20 6f 66 20 66 69 6c 65 20   levels of file 
    0x2a0  73 69 7a 65 73 20 64 69 73 74 69 6e 63 74 6c 79  sizes distinctly
    0x2b0  0a 20 20 2d 2d 69 63 6f 6e 73 20 20 20 20 20 20  .  --icons      
    0x2c0  20 20 20 20 20 20 64 69 73 70 6c 61 79 20 69 63        display ic
    0x2d0  6f 6e 73 0a 20 20 2d 2d 6e 6f 2d 69 63 6f 6e 73  ons.  --no-icons
    0x2e0  20 20 20 20 20 20 20 20 20 64 6f 6e 27 74 20 64           don't d
    0x2f0  69 73 70 6c 61 79 20 69 63 6f 6e 73 20 28 61 6c  isplay icons (al
    0x300  77 61 79 73 20 6f 76 65 72 72 69 64 65 73 20 2d  ways overrides -
    0x310  2d 69 63 6f 6e 73 29 0a 0a 46 49 4c 54 45 52 49  -icons)..FILTERI
    0x320  4e 47 20 41 4e 44 20 53 4f 52 54 49 4e 47 20 4f  NG AND SORTING O
    0x330  50 54 49 4f 4e 53 0a 20 20 2d 61 2c 20 2d 2d 61  PTIONS.  -a, --a
    0x340  6c 6c 20 20 20 20 20 20 20 20 20 20 20 20 20 20  ll              
    0x350  20 20 20 20 73 68 6f 77 20 68 69 64 64 65 6e 20      show hidden 
    0x360  61 6e 64 20 27 64 6f 74 27 20 66 69 6c 65 73 0a  and 'dot' files.
    0x370  20 20 2d 64 2c 20 2d 2d 6c 69 73 74 2d 64 69 72    -d, --list-dir
    0x380  73 20 20 20 20 20 20 20 20 20 20 20 20 6c 69 73  s            lis
    0x390  74 20 64 69 72 65 63 74 6f 72 69 65 73 20 61 73  t directories as
    0x3a0  20 66 69 6c 65 73 3b 20 64 6f 6e 27 74 20 6c 69   files; don't li
    0x3b0  73 74 20 74 68 65 69 72 20 63 6f 6e 74 65 6e 74  st their content
    0x3c0  73 0a 20 20 2d 4c 2c 20 2d 2d 6c 65 76 65 6c 20  s.  -L, --level 
    0x3d0  44 45 50 54 48 20 20 20 20 20 20 20 20 20 20 6c  DEPTH          l
    0x3e0  69 6d 69 74 20 74 68 65 20 64 65 70 74 68 20 6f  imit the depth o
    0x3f0  66 20 72 65 63 75 72 73 69 6f 6e 0a 20 20 2d 72  f recursion.  -r
    0x400  2c 20 2d 2d 72 65 76 65 72 73 65 20 20 20 20 20  , --reverse     
    0x410  20 20 20 20 20 20 20 20 20 72 65 76 65 72 73 65           reverse
    0x420  20 74 68 65 20 73 6f 72 74 20 6f 72 64 65 72 0a   the sort order.
    0x430  20 20 2d 73 2c 20 2d 2d 73 6f 72 74 20 53 4f 52    -s, --sort SOR
    0x440  54 5f 46 49 45 4c 44 20 20 20 20 20 20 77 68 69  T_FIELD      whi
    0x450  63 68 20 66 69 65 6c 64 20 74 6f 20 73 6f 72 74  ch field to sort
    0x460  20 62 79 0a 20 20 2d 2d 67 72 6f 75 70 2d 64 69   by.  --group-di
    0x470  72 65 63 74 6f 72 69 65 73 2d 66 69 72 73 74 20  rectories-first 
    0x480  20 6c 69 73 74 20 64 69 72 65 63 74 6f 72 69 65   list directorie
    0x490  73 20 62 65 66 6f 72 65 20 6f 74 68 65 72 20 66  s before other f
    0x4a0  69 6c 65 73 0a 20 20 2d 44 2c 20 2d 2d 6f 6e 6c  iles.  -D, --onl
    0x4b0  79 2d 64 69 72 73 20 20 20 20 20 20 20 20 20 20  y-dirs          
    0x4c0  20 20 6c 69 73 74 20 6f 6e 6c 79 20 64 69 72 65    list only dire
    0x4d0  63 74 6f 72 69 65 73 0a 20 20 2d 49 2c 20 2d 2d  ctories.  -I, --
    0x4e0  69 67 6e 6f 72 65 2d 67 6c 6f 62 20 47 4c 4f 42  ignore-glob GLOB
    0x4f0  53 20 20 20 20 67 6c 6f 62 20 70 61 74 74 65 72  S    glob patter
    0x500  6e 73 20 28 70 69 70 65 2d 73 65 70 61 72 61 74  ns (pipe-separat
    0x510  65 64 29 20 6f 66 20 66 69 6c 65 73 20 74 6f 20  ed) of files to 
    0x520  69 67 6e 6f 72 65                                ignore
}

promoted[0] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[5] in help::<impl at src/options/help.rs:94:1: 94:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:55:10: 55:19>::eq(_1: &Flag, _2: &Flag) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&options::parser::Flag, &options::parser::Flag);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _12: u8;
    let mut _13: u8;
    let mut _16: &options::parser::Flag;
    let mut _17: &options::parser::Flag;
    let mut _18: &options::parser::Flag;
    let mut _19: &options::parser::Flag;
    let mut _20: &options::parser::Flag;
    let mut _21: &options::parser::Flag;
    let mut _22: &options::parser::Flag;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _10: &u8;
            let _11: &u8;
            let _14: &&str;
            let _15: &&str;
            scope 3 {
                debug __self_0 => _10;
                debug __arg1_0 => _11;
            }
            scope 4 {
                debug __self_0 => _14;
                debug __arg1_0 => _15;
            }
            scope 5 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _16 = deref_copy (_6.0: &options::parser::Flag);
        _9 = discriminant((*_16));
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb8;
    }

    bb3: {
        _17 = deref_copy (_6.1: &options::parser::Flag);
        _7 = discriminant((*_17));
        switchInt(move _7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _18 = deref_copy (_6.1: &options::parser::Flag);
        _8 = discriminant((*_18));
        switchInt(move _8) -> [1: bb7, otherwise: bb4];
    }

    bb6: {
        _19 = deref_copy (_6.0: &options::parser::Flag);
        _10 = &(((*_19) as Short).0: u8);
        _20 = deref_copy (_6.1: &options::parser::Flag);
        _11 = &(((*_20) as Short).0: u8);
        _12 = (*_10);
        _13 = (*_11);
        _0 = Eq(move _12, move _13);
        goto -> bb8;
    }

    bb7: {
        _21 = deref_copy (_6.0: &options::parser::Flag);
        _14 = &(((*_21) as Long).0: &str);
        _22 = deref_copy (_6.1: &options::parser::Flag);
        _15 = &(((*_22) as Long).0: &str);
        _0 = <&str as PartialEq>::eq(_14, _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:55:21: 55:26>::fmt(_1: &Flag, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &u8;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&u8;
    let _8: &&str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&&str;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Long).0: &str);
        _9 = const "Long";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Short).0: u8);
        _5 = const "Short";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:55:34: 55:39>::clone(_1: &Flag) -> Flag {
    debug self => _1;
    let mut _0: options::parser::Flag;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:61:1: 61:10>::matches(_1: &Flag, _2: &Arg) -> bool {
    debug self => _1;
    debug arg => _2;
    let mut _0: bool;
    let mut _3: isize;
    let _4: &u8;
    let mut _5: &std::option::Option<u8>;
    let mut _6: &std::option::Option<u8>;
    let _7: std::option::Option<u8>;
    let mut _8: u8;
    let _9: &&str;
    let mut _10: &&str;
    scope 1 {
        debug short => _4;
    }
    scope 2 {
        debug long => _9;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = &(((*_1) as Long).0: &str);
        _10 = &((*_2).1: &str);
        _0 = <&str as PartialEq>::eq(move _10, _9) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Short).0: u8);
        _5 = &((*_2).0: std::option::Option<u8>);
        _8 = (*_4);
        _7 = Option::<u8>::Some(move _8);
        _6 = &_7;
        _0 = <Option<u8> as PartialEq>::eq(move _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:70:1: 70:27>::fmt(_1: &Flag, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &u8;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &char;
    let _12: char;
    let mut _13: u8;
    let _14: &&str;
    let mut _15: std::fmt::Arguments<'_>;
    let mut _16: &[&str];
    let mut _17: &[core::fmt::rt::Argument<'_>];
    let _18: &[core::fmt::rt::Argument<'_>; 1];
    let _19: [core::fmt::rt::Argument<'_>; 1];
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &&&str;
    scope 1 {
        debug short => _4;
        let mut _23: &[&str; 1];
    }
    scope 2 {
        debug long => _14;
        let mut _22: &[&str; 1];
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _14 = &(((*_1) as Long).0: &str);
        _22 = const _;
        _16 = _22 as &[&str] (PointerCoercion(Unsize));
        _21 = &_14;
        _20 = core::fmt::rt::Argument::<'_>::new_display::<&&str>(_21) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Short).0: u8);
        _23 = const _;
        _6 = _23 as &[&str] (PointerCoercion(Unsize));
        _13 = (*_4);
        _12 = move _13 as char (IntToInt);
        _11 = &_12;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<char>(_11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb8, unwind continue];
    }

    bb6: {
        _19 = [move _20];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _15 = std::fmt::Arguments::<'_>::new_v1(move _16, move _17) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Formatter::<'_>::write_fmt(_2, move _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

promoted[0] in options::parser::<impl at src/options/parser.rs:70:1: 70:27>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "--"];
        _0 = &_1;
        return;
    }
}

promoted[1] in options::parser::<impl at src/options/parser.rs:70:1: 70:27>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "-"];
        _0 = &_1;
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:80:10: 80:19>::eq(_1: &Strictness, _2: &Strictness) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:80:21: 80:26>::fmt(_1: &Strictness, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "UseLastArguments";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "ComplainAboutRedundantArguments";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:80:34: 80:39>::clone(_1: &Strictness) -> Strictness {
    debug self => _1;
    let mut _0: options::parser::Strictness;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:94:16: 94:21>::clone(_1: &TakesValue) -> TakesValue {
    debug self => _1;
    let mut _0: options::parser::TakesValue;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:94:23: 94:32>::eq(_1: &TakesValue, _2: &TakesValue) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&options::parser::TakesValue, &options::parser::TakesValue);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _14: &options::parser::TakesValue;
    let mut _15: &options::parser::TakesValue;
    let mut _16: &options::parser::TakesValue;
    let mut _17: &options::parser::TakesValue;
    let mut _18: &options::parser::TakesValue;
    let mut _19: &options::parser::TakesValue;
    let mut _20: &options::parser::TakesValue;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _10: &std::option::Option<&[&str]>;
            let _11: &std::option::Option<&[&str]>;
            let _12: &std::option::Option<&[&str]>;
            let _13: &std::option::Option<&[&str]>;
            scope 3 {
                debug __self_0 => _10;
                debug __arg1_0 => _11;
            }
            scope 4 {
                debug __self_0 => _12;
                debug __arg1_0 => _13;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _14 = deref_copy (_6.0: &options::parser::TakesValue);
        _9 = discriminant((*_14));
        switchInt(move _9) -> [0: bb3, 2: bb5, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb8;
    }

    bb3: {
        _15 = deref_copy (_6.1: &options::parser::TakesValue);
        _7 = discriminant((*_15));
        switchInt(move _7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb8;
    }

    bb5: {
        _16 = deref_copy (_6.1: &options::parser::TakesValue);
        _8 = discriminant((*_16));
        switchInt(move _8) -> [2: bb7, otherwise: bb4];
    }

    bb6: {
        _17 = deref_copy (_6.0: &options::parser::TakesValue);
        _10 = &(((*_17) as Necessary).0: std::option::Option<&[&str]>);
        _18 = deref_copy (_6.1: &options::parser::TakesValue);
        _11 = &(((*_18) as Necessary).0: std::option::Option<&[&str]>);
        _0 = <Option<&[&str]> as PartialEq>::eq(_10, _11) -> [return: bb8, unwind continue];
    }

    bb7: {
        _19 = deref_copy (_6.0: &options::parser::TakesValue);
        _12 = &(((*_19) as Optional).0: std::option::Option<&[&str]>);
        _20 = deref_copy (_6.1: &options::parser::TakesValue);
        _13 = &(((*_20) as Optional).0: std::option::Option<&[&str]>);
        _0 = <Option<&[&str]> as PartialEq>::eq(_12, _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:94:34: 94:39>::fmt(_1: &TakesValue, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &std::option::Option<&[&str]>;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&std::option::Option<&[&str]>;
    let _8: &str;
    let _9: &std::option::Option<&[&str]>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&std::option::Option<&[&str]>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _9;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = &(((*_1) as Optional).0: std::option::Option<&[&str]>);
        _10 = const "Optional";
        _12 = &_9;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _10, move _11) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Necessary).0: std::option::Option<&[&str]>);
        _5 = const "Necessary";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _8 = const "Forbidden";
        _0 = Formatter::<'_>::write_str(_2, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:111:10: 111:19>::eq(_1: &Arg, _2: &Arg) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<u8>;
    let mut _5: &std::option::Option<u8>;
    let mut _6: bool;
    let mut _7: &&str;
    let mut _8: &&str;
    let mut _9: &options::parser::TakesValue;
    let mut _10: &options::parser::TakesValue;

    bb0: {
        _4 = &((*_1).0: std::option::Option<u8>);
        _5 = &((*_2).0: std::option::Option<u8>);
        _3 = <Option<u8> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: &str);
        _8 = &((*_2).1: &str);
        _6 = <&str as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = &((*_1).2: options::parser::TakesValue);
        _10 = &((*_2).2: options::parser::TakesValue);
        _0 = <TakesValue as PartialEq>::eq(move _9, move _10) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = const false;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:111:21: 111:26>::fmt(_1: &Arg, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<u8>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&str;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&options::parser::TakesValue;
    let _13: &options::parser::TakesValue;

    bb0: {
        _3 = const "Arg";
        _4 = const "short";
        _6 = &((*_1).0: std::option::Option<u8>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "long";
        _9 = &((*_1).1: &str);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "takes_value";
        _13 = &((*_1).2: options::parser::TakesValue);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:111:34: 111:39>::clone(_1: &Arg) -> Arg {
    debug self => _1;
    let mut _0: options::parser::Arg;
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:125:1: 125:26>::fmt(_1: &Arg, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _4: std::result::Result<(), std::fmt::Error>;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &&str;
    let mut _12: isize;
    let mut _13: isize;
    let mut _15: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _16: std::result::Result<(), std::fmt::Error>;
    let mut _17: std::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[core::fmt::rt::Argument<'_>];
    let _20: &[core::fmt::rt::Argument<'_>; 1];
    let _21: [core::fmt::rt::Argument<'_>; 1];
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &char;
    let _24: char;
    let mut _25: isize;
    let mut _27: &[&str; 1];
    scope 1 {
        debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 2 {
        }
    }
    scope 3 {
        debug val => const ();
        scope 4 {
        }
    }
    scope 5 {
        debug short => _14;
        let _14: u8;
        let mut _26: &[&str; 2];
        scope 6 {
            debug residual => const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
    }

    bb0: {
        _27 = const _;
        _6 = _27 as &[&str] (PointerCoercion(Unsize));
        _11 = &((*_1).1: &str);
        _10 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <Result<(), std::fmt::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_3);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = discriminant(((*_1).0: std::option::Option<u8>));
        switchInt(move _13) -> [1: bb8, otherwise: bb14];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb15, unwind continue];
    }

    bb8: {
        _14 = ((((*_1).0: std::option::Option<u8>) as Some).0: u8);
        _26 = const _;
        _18 = _26 as &[&str] (PointerCoercion(Unsize));
        _24 = _14 as char (IntToInt);
        _23 = &_24;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<char>(_23) -> [return: bb9, unwind continue];
    }

    bb9: {
        _21 = [move _22];
        _20 = &_21;
        _19 = _20 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = std::fmt::Arguments::<'_>::new_v1(move _18, move _19) -> [return: bb10, unwind continue];
    }

    bb10: {
        _16 = Formatter::<'_>::write_fmt(_2, move _17) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = <Result<(), std::fmt::Error> as Try>::branch(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _25 = discriminant(_15);
        switchInt(move _25) -> [0: bb14, 1: bb13, otherwise: bb6];
    }

    bb13: {
        _0 = <Result<(), std::fmt::Error> as FromResidual<Result<Infallible, std::fmt::Error>>>::from_residual(const Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb15, unwind continue];
    }

    bb14: {
        _0 = Result::<(), std::fmt::Error>::Ok(const ());
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

promoted[0] in options::parser::<impl at src/options/parser.rs:125:1: 125:26>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const " (-", const ")"];
        _0 = &_1;
        return;
    }
}

promoted[1] in options::parser::<impl at src/options/parser.rs:125:1: 125:26>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "--"];
        _0 = &_1;
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:139:10: 139:19>::eq(_1: &options::parser::Args, _2: &options::parser::Args) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &&[&options::parser::Arg];
    let mut _4: &&[&options::parser::Arg];

    bb0: {
        _3 = &((*_1).0: &[&options::parser::Arg]);
        _4 = &((*_2).0: &[&options::parser::Arg]);
        _0 = <&[&Arg] as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:139:21: 139:26>::fmt(_1: &options::parser::Args, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&&[&options::parser::Arg];
    let _6: &&[&options::parser::Arg];

    bb0: {
        _3 = const "Args";
        _6 = &((*_1).0: &[&options::parser::Arg]);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:142:1: 142:10>::parse(_1: &options::parser::Args, _2: I, _3: Strictness) -> Result<options::parser::Matches<'_>, ParseError> {
    debug self => _1;
    debug inputs => _2;
    debug strictness => _3;
    let mut _0: std::result::Result<options::parser::Matches<'_>, options::parser::ParseError>;
    let mut _4: bool;
    let mut _8: I;
    let mut _9: ();
    let mut _10: std::option::Option<&std::ffi::OsStr>;
    let mut _11: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _12: isize;
    let mut _15: &std::ffi::OsStr;
    let mut _16: bool;
    let mut _17: &mut std::vec::Vec<&std::ffi::OsStr>;
    let mut _18: &std::ffi::OsStr;
    let mut _19: bool;
    let mut _20: &&std::ffi::OsStr;
    let mut _21: bool;
    let mut _22: &[u8];
    let _23: &[u8; 2];
    let _25: &[u8];
    let mut _26: std::ops::RangeFrom<usize>;
    let mut _27: std::option::Option<(&std::ffi::OsStr, &std::ffi::OsStr)>;
    let mut _28: isize;
    let mut _31: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::parser::ParseError>, &options::parser::Arg>;
    let mut _32: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _33: isize;
    let mut _37: &str;
    let mut _38: isize;
    let mut _39: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _40: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _41: std::option::Option<&std::ffi::OsStr>;
    let mut _42: options::parser::ParseError;
    let mut _43: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::parser::ParseError>, &options::parser::Arg>;
    let mut _44: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _45: isize;
    let mut _49: &str;
    let mut _50: isize;
    let mut _51: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _52: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _53: std::option::Option<&std::ffi::OsStr>;
    let mut _55: std::option::Option<&std::ffi::OsStr>;
    let mut _56: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _57: isize;
    let _59: ();
    let mut _60: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _61: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _62: std::option::Option<&std::ffi::OsStr>;
    let mut _63: options::parser::ParseError;
    let mut _64: std::option::Option<&std::ffi::OsStr>;
    let mut _65: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _66: isize;
    let _68: ();
    let mut _69: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _70: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _71: std::option::Option<&std::ffi::OsStr>;
    let _72: ();
    let mut _73: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _74: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _75: std::option::Option<&std::ffi::OsStr>;
    let mut _76: bool;
    let mut _77: &[u8];
    let _78: &[u8; 1];
    let mut _79: bool;
    let mut _80: &&std::ffi::OsStr;
    let _82: &[u8];
    let mut _83: std::ops::RangeFrom<usize>;
    let mut _84: std::option::Option<(&std::ffi::OsStr, &std::ffi::OsStr)>;
    let mut _85: isize;
    let mut _90: (&u8, &[u8]);
    let mut _91: std::option::Option<(&u8, &[u8])>;
    let _92: &[u8];
    let mut _93: std::slice::Iter<'_, u8>;
    let mut _95: std::option::Option<&u8>;
    let mut _96: &mut std::slice::Iter<'_, u8>;
    let mut _97: isize;
    let mut _99: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::parser::ParseError>, &options::parser::Arg>;
    let mut _100: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _101: u8;
    let mut _102: isize;
    let mut _106: u8;
    let mut _107: isize;
    let _108: ();
    let mut _109: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _110: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _111: std::option::Option<&std::ffi::OsStr>;
    let mut _113: options::parser::ParseError;
    let mut _114: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::parser::ParseError>, &options::parser::Arg>;
    let mut _115: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _116: u8;
    let mut _117: isize;
    let mut _121: u8;
    let mut _122: std::option::Option<u8>;
    let mut _123: isize;
    let _124: ();
    let mut _125: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _126: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _127: std::option::Option<&std::ffi::OsStr>;
    let mut _128: options::parser::ParseError;
    let mut _129: std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, u8>>>;
    let mut _130: std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, u8>>>;
    let mut _131: std::iter::Enumerate<std::slice::Iter<'_, u8>>;
    let mut _132: std::slice::Iter<'_, u8>;
    let _134: ();
    let mut _135: std::option::Option<(usize, &u8)>;
    let mut _136: &mut std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, u8>>>;
    let mut _137: isize;
    let mut _140: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::parser::ParseError>, &options::parser::Arg>;
    let mut _141: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _142: u8;
    let mut _143: isize;
    let mut _147: u8;
    let mut _148: isize;
    let mut _149: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _150: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _151: std::option::Option<&std::ffi::OsStr>;
    let mut _153: bool;
    let mut _154: usize;
    let mut _155: usize;
    let mut _156: (usize, bool);
    let _157: &[u8];
    let mut _158: std::ops::RangeFrom<usize>;
    let mut _159: usize;
    let mut _160: (usize, bool);
    let _161: ();
    let mut _162: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _163: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _164: std::option::Option<&std::ffi::OsStr>;
    let _165: &std::ffi::OsStr;
    let mut _166: std::option::Option<&std::ffi::OsStr>;
    let mut _167: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _168: isize;
    let _170: ();
    let mut _171: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _172: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _173: std::option::Option<&std::ffi::OsStr>;
    let mut _174: isize;
    let mut _175: !;
    let mut _176: options::parser::ParseError;
    let mut _177: std::option::Option<&[&str]>;
    let _178: ();
    let mut _179: &mut std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _180: (options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _181: std::option::Option<&std::ffi::OsStr>;
    let mut _182: &mut std::vec::Vec<&std::ffi::OsStr>;
    let mut _183: &std::ffi::OsStr;
    let mut _184: options::parser::Matches<'_>;
    let mut _185: std::vec::Vec<&std::ffi::OsStr>;
    let mut _186: options::parser::MatchedFlags<'_>;
    let mut _187: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _190: bool;
    let mut _191: bool;
    let mut _192: bool;
    scope 1 {
        debug parsing => _4;
        let mut _5: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
        scope 2 {
            debug result_flags => _5;
            let mut _6: std::vec::Vec<&std::ffi::OsStr>;
            scope 3 {
                debug frees => _6;
                let mut _7: <I as std::iter::IntoIterator>::IntoIter;
                scope 4 {
                    debug inputs => _7;
                    scope 5 {
                        debug arg => _13;
                        let _13: &std::ffi::OsStr;
                        let _14: &[u8];
                        scope 6 {
                            debug bytes => _14;
                            let _24: &std::ffi::OsStr;
                            let _81: &std::ffi::OsStr;
                            let mut _188: &&str;
                            let mut _189: &&str;
                            scope 7 {
                                debug long_arg_name => _24;
                                let _46: std::result::Result<std::convert::Infallible, options::parser::ParseError>;
                                let _47: &options::parser::Arg;
                                scope 8 {
                                    debug before => _29;
                                    debug after => _30;
                                    let _29: &std::ffi::OsStr;
                                    let _30: &std::ffi::OsStr;
                                    let _34: std::result::Result<std::convert::Infallible, options::parser::ParseError>;
                                    let _35: &options::parser::Arg;
                                    scope 9 {
                                        debug arg => _35;
                                        let _36: options::parser::Flag;
                                        scope 14 {
                                            debug flag => _36;
                                        }
                                    }
                                    scope 10 {
                                        debug residual => _34;
                                        scope 11 {
                                        }
                                    }
                                    scope 12 {
                                        debug val => _35;
                                        scope 13 {
                                        }
                                    }
                                }
                                scope 15 {
                                    debug arg => _47;
                                    let _48: options::parser::Flag;
                                    scope 20 {
                                        debug flag => _48;
                                        let _54: std::option::Option<&[&str]>;
                                        scope 21 {
                                            debug values => _54;
                                            scope 22 {
                                                debug next_arg => _58;
                                                let _58: &std::ffi::OsStr;
                                            }
                                        }
                                        scope 23 {
                                            debug next_arg => _67;
                                            let _67: &std::ffi::OsStr;
                                        }
                                    }
                                }
                                scope 16 {
                                    debug residual => _46;
                                    scope 17 {
                                    }
                                }
                                scope 18 {
                                    debug val => _47;
                                    scope 19 {
                                    }
                                }
                            }
                            scope 24 {
                                debug short_arg => _81;
                                let mut _133: std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, u8>>>;
                                scope 25 {
                                    debug before => _86;
                                    debug after => _87;
                                    let _86: &std::ffi::OsStr;
                                    let _87: &std::ffi::OsStr;
                                    let _88: &u8;
                                    let _89: &[u8];
                                    scope 26 {
                                        debug arg_with_value => _88;
                                        debug other_args => _89;
                                        let mut _94: std::slice::Iter<'_, u8>;
                                        let _118: std::result::Result<std::convert::Infallible, options::parser::ParseError>;
                                        let _119: &options::parser::Arg;
                                        scope 27 {
                                            debug iter => _94;
                                            let _98: &u8;
                                            scope 28 {
                                                debug byte => _98;
                                                let _103: std::result::Result<std::convert::Infallible, options::parser::ParseError>;
                                                let _104: &options::parser::Arg;
                                                scope 29 {
                                                    debug arg => _104;
                                                    let _105: options::parser::Flag;
                                                    scope 34 {
                                                        debug flag => _105;
                                                        let _112: std::option::Option<&[&str]>;
                                                        scope 35 {
                                                            debug values => _112;
                                                        }
                                                    }
                                                }
                                                scope 30 {
                                                    debug residual => _103;
                                                    scope 31 {
                                                    }
                                                }
                                                scope 32 {
                                                    debug val => _104;
                                                    scope 33 {
                                                    }
                                                }
                                            }
                                        }
                                        scope 36 {
                                            debug arg => _119;
                                            let _120: options::parser::Flag;
                                            scope 41 {
                                                debug flag => _120;
                                            }
                                        }
                                        scope 37 {
                                            debug residual => _118;
                                            scope 38 {
                                            }
                                        }
                                        scope 39 {
                                            debug val => _119;
                                            scope 40 {
                                            }
                                        }
                                    }
                                }
                                scope 42 {
                                    debug iter => _133;
                                    let _138: usize;
                                    let _139: &u8;
                                    scope 43 {
                                        debug index => _138;
                                        debug byte => _139;
                                        let _144: std::result::Result<std::convert::Infallible, options::parser::ParseError>;
                                        let _145: &options::parser::Arg;
                                        scope 44 {
                                            debug arg => _145;
                                            let _146: options::parser::Flag;
                                            scope 49 {
                                                debug flag => _146;
                                                let _152: std::option::Option<&[&str]>;
                                                scope 50 {
                                                    debug values => _152;
                                                    scope 51 {
                                                        debug remnants => _157;
                                                    }
                                                    scope 52 {
                                                        debug next_arg => _169;
                                                        let _169: &std::ffi::OsStr;
                                                    }
                                                }
                                            }
                                        }
                                        scope 45 {
                                            debug residual => _144;
                                            scope 46 {
                                            }
                                        }
                                        scope 47 {
                                            debug val => _145;
                                            scope 48 {
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _192 = const false;
        _191 = const false;
        _190 = const false;
        _192 = const true;
        _4 = const true;
        _5 = Vec::<(Flag, Option<&OsStr>)>::new() -> [return: bb1, unwind: bb112];
    }

    bb1: {
        _191 = const true;
        _6 = Vec::<&OsStr>::new() -> [return: bb2, unwind: bb110];
    }

    bb2: {
        _190 = const true;
        _192 = const false;
        _8 = move _2;
        _7 = <I as IntoIterator>::into_iter(move _8) -> [return: bb113, unwind: bb108];
    }

    bb3: {
        _11 = &mut _7;
        _10 = <<I as IntoIterator>::IntoIter as Iterator>::next(move _11) -> [return: bb4, unwind: bb105];
    }

    bb4: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [1: bb5, otherwise: bb98];
    }

    bb5: {
        _13 = ((_10 as Some).0: &std::ffi::OsStr);
        _15 = _13;
        _14 = <OsStr as OsStrExt>::as_bytes(move _15) -> [return: bb6, unwind: bb105];
    }

    bb6: {
        _16 = _4;
        switchInt(move _16) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _17 = &mut _6;
        _18 = _13;
        _9 = Vec::<&OsStr>::push(move _17, move _18) -> [return: bb114, unwind: bb105];
    }

    bb8: {
        _20 = &_13;
        _189 = const _;
        _19 = <&OsStr as PartialEq<&str>>::eq(move _20, _189) -> [return: bb9, unwind: bb105];
    }

    bb9: {
        switchInt(move _19) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _4 = const false;
        goto -> bb3;
    }

    bb11: {
        _23 = const b"--";
        _22 = _23 as &[u8] (PointerCoercion(Unsize));
        _21 = core::slice::<impl [u8]>::starts_with(_14, move _22) -> [return: bb12, unwind: bb105];
    }

    bb12: {
        switchInt(move _21) -> [0: bb39, otherwise: bb13];
    }

    bb13: {
        _26 = RangeFrom::<usize> { start: const 2_usize };
        _25 = <[u8] as std::ops::Index<RangeFrom<usize>>>::index(_14, move _26) -> [return: bb14, unwind: bb105];
    }

    bb14: {
        _24 = <OsStr as OsStrExt>::from_bytes(_25) -> [return: bb15, unwind: bb105];
    }

    bb15: {
        _27 = split_on_equals(_24) -> [return: bb16, unwind: bb105];
    }

    bb16: {
        _28 = discriminant(_27);
        switchInt(move _28) -> [1: bb17, otherwise: bb25];
    }

    bb17: {
        _29 = (((_27 as Some).0: (&std::ffi::OsStr, &std::ffi::OsStr)).0: &std::ffi::OsStr);
        _30 = (((_27 as Some).0: (&std::ffi::OsStr, &std::ffi::OsStr)).1: &std::ffi::OsStr);
        _32 = options::parser::Args::lookup_long(_1, _29) -> [return: bb18, unwind: bb105];
    }

    bb18: {
        _31 = <Result<&Arg, ParseError> as Try>::branch(move _32) -> [return: bb19, unwind: bb105];
    }

    bb19: {
        _33 = discriminant(_31);
        switchInt(move _33) -> [0: bb20, 1: bb22, otherwise: bb21];
    }

    bb20: {
        _35 = ((_31 as Continue).0: &options::parser::Arg);
        _37 = ((*_35).1: &str);
        _36 = Flag::Long(move _37);
        _38 = discriminant(((*_35).2: options::parser::TakesValue));
        switchInt(move _38) -> [0: bb24, 1: bb23, 2: bb24, otherwise: bb21];
    }

    bb21: {
        unreachable;
    }

    bb22: {
        _34 = move ((_31 as Break).0: std::result::Result<std::convert::Infallible, options::parser::ParseError>);
        _0 = <Result<options::parser::Matches<'_>, ParseError> as FromResidual<Result<Infallible, ParseError>>>::from_residual(move _34) -> [return: bb115, unwind: bb105];
    }

    bb23: {
        _42 = ParseError::ForbiddenValue { flag: _36 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Err(move _42);
        goto -> bb100;
    }

    bb24: {
        _39 = &mut _5;
        _41 = Option::<&OsStr>::Some(_30);
        _40 = (_36, move _41);
        _9 = Vec::<(Flag, Option<&OsStr>)>::push(move _39, move _40) -> [return: bb116, unwind: bb105];
    }

    bb25: {
        _44 = options::parser::Args::lookup_long(_1, _24) -> [return: bb26, unwind: bb105];
    }

    bb26: {
        _43 = <Result<&Arg, ParseError> as Try>::branch(move _44) -> [return: bb27, unwind: bb105];
    }

    bb27: {
        _45 = discriminant(_43);
        switchInt(move _45) -> [0: bb28, 1: bb29, otherwise: bb21];
    }

    bb28: {
        _47 = ((_43 as Continue).0: &options::parser::Arg);
        _49 = ((*_47).1: &str);
        _48 = Flag::Long(move _49);
        _50 = discriminant(((*_47).2: options::parser::TakesValue));
        switchInt(move _50) -> [0: bb32, 1: bb31, 2: bb30, otherwise: bb21];
    }

    bb29: {
        _46 = move ((_43 as Break).0: std::result::Result<std::convert::Infallible, options::parser::ParseError>);
        _0 = <Result<options::parser::Matches<'_>, ParseError> as FromResidual<Result<Infallible, ParseError>>>::from_residual(move _46) -> [return: bb117, unwind: bb105];
    }

    bb30: {
        _65 = &mut _7;
        _64 = <<I as IntoIterator>::IntoIter as Iterator>::next(move _65) -> [return: bb36, unwind: bb105];
    }

    bb31: {
        _51 = &mut _5;
        _53 = Option::<&OsStr>::None;
        _52 = (_48, move _53);
        _9 = Vec::<(Flag, Option<&OsStr>)>::push(move _51, move _52) -> [return: bb118, unwind: bb105];
    }

    bb32: {
        _54 = ((((*_47).2: options::parser::TakesValue) as Necessary).0: std::option::Option<&[&str]>);
        _56 = &mut _7;
        _55 = <<I as IntoIterator>::IntoIter as Iterator>::next(move _56) -> [return: bb33, unwind: bb105];
    }

    bb33: {
        _57 = discriminant(_55);
        switchInt(move _57) -> [1: bb34, otherwise: bb35];
    }

    bb34: {
        _58 = ((_55 as Some).0: &std::ffi::OsStr);
        _60 = &mut _5;
        _62 = Option::<&OsStr>::Some(_58);
        _61 = (_48, move _62);
        _59 = Vec::<(Flag, Option<&OsStr>)>::push(move _60, move _61) -> [return: bb119, unwind: bb105];
    }

    bb35: {
        _63 = ParseError::NeedsValue { flag: _48, values: _54 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Err(move _63);
        goto -> bb100;
    }

    bb36: {
        _66 = discriminant(_64);
        switchInt(move _66) -> [1: bb37, otherwise: bb38];
    }

    bb37: {
        _67 = ((_64 as Some).0: &std::ffi::OsStr);
        _69 = &mut _5;
        _71 = Option::<&OsStr>::Some(_67);
        _70 = (_48, move _71);
        _68 = Vec::<(Flag, Option<&OsStr>)>::push(move _69, move _70) -> [return: bb120, unwind: bb105];
    }

    bb38: {
        _73 = &mut _5;
        _75 = Option::<&OsStr>::None;
        _74 = (_48, move _75);
        _72 = Vec::<(Flag, Option<&OsStr>)>::push(move _73, move _74) -> [return: bb121, unwind: bb105];
    }

    bb39: {
        _78 = const b"-";
        _77 = _78 as &[u8] (PointerCoercion(Unsize));
        _76 = core::slice::<impl [u8]>::starts_with(_14, move _77) -> [return: bb40, unwind: bb105];
    }

    bb40: {
        switchInt(move _76) -> [0: bb97, otherwise: bb41];
    }

    bb41: {
        _80 = &_13;
        _188 = const _;
        _79 = <&OsStr as PartialEq<&str>>::ne(move _80, _188) -> [return: bb42, unwind: bb105];
    }

    bb42: {
        switchInt(move _79) -> [0: bb97, otherwise: bb43];
    }

    bb43: {
        _83 = RangeFrom::<usize> { start: const 1_usize };
        _82 = <[u8] as std::ops::Index<RangeFrom<usize>>>::index(_14, move _83) -> [return: bb44, unwind: bb105];
    }

    bb44: {
        _81 = <OsStr as OsStrExt>::from_bytes(_82) -> [return: bb45, unwind: bb105];
    }

    bb45: {
        _84 = split_on_equals(_81) -> [return: bb46, unwind: bb105];
    }

    bb46: {
        _85 = discriminant(_84);
        switchInt(move _85) -> [1: bb47, otherwise: bb69];
    }

    bb47: {
        _86 = (((_84 as Some).0: (&std::ffi::OsStr, &std::ffi::OsStr)).0: &std::ffi::OsStr);
        _87 = (((_84 as Some).0: (&std::ffi::OsStr, &std::ffi::OsStr)).1: &std::ffi::OsStr);
        _92 = <OsStr as OsStrExt>::as_bytes(_86) -> [return: bb48, unwind: bb105];
    }

    bb48: {
        _91 = core::slice::<impl [u8]>::split_last(_92) -> [return: bb49, unwind: bb105];
    }

    bb49: {
        _90 = Option::<(&u8, &[u8])>::unwrap(move _91) -> [return: bb50, unwind: bb105];
    }

    bb50: {
        _88 = (_90.0: &u8);
        _89 = (_90.1: &[u8]);
        _93 = <&[u8] as IntoIterator>::into_iter(_89) -> [return: bb51, unwind: bb105];
    }

    bb51: {
        _94 = move _93;
        goto -> bb52;
    }

    bb52: {
        _96 = &mut _94;
        _95 = <std::slice::Iter<'_, u8> as Iterator>::next(_96) -> [return: bb53, unwind: bb105];
    }

    bb53: {
        _97 = discriminant(_95);
        switchInt(move _97) -> [0: bb55, 1: bb54, otherwise: bb21];
    }

    bb54: {
        _98 = ((_95 as Some).0: &u8);
        _101 = (*_98);
        _100 = options::parser::Args::lookup_short(_1, move _101) -> [return: bb56, unwind: bb105];
    }

    bb55: {
        _116 = (*_88);
        _115 = options::parser::Args::lookup_short(_1, move _116) -> [return: bb62, unwind: bb105];
    }

    bb56: {
        _99 = <Result<&Arg, ParseError> as Try>::branch(move _100) -> [return: bb57, unwind: bb105];
    }

    bb57: {
        _102 = discriminant(_99);
        switchInt(move _102) -> [0: bb58, 1: bb59, otherwise: bb21];
    }

    bb58: {
        _104 = ((_99 as Continue).0: &options::parser::Arg);
        _106 = (*_98);
        _105 = Flag::Short(move _106);
        _107 = discriminant(((*_104).2: options::parser::TakesValue));
        switchInt(move _107) -> [0: bb60, 1: bb61, 2: bb61, otherwise: bb21];
    }

    bb59: {
        _103 = move ((_99 as Break).0: std::result::Result<std::convert::Infallible, options::parser::ParseError>);
        _0 = <Result<options::parser::Matches<'_>, ParseError> as FromResidual<Result<Infallible, ParseError>>>::from_residual(move _103) -> [return: bb122, unwind: bb105];
    }

    bb60: {
        _112 = ((((*_104).2: options::parser::TakesValue) as Necessary).0: std::option::Option<&[&str]>);
        _113 = ParseError::NeedsValue { flag: _105, values: _112 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Err(move _113);
        goto -> bb100;
    }

    bb61: {
        _109 = &mut _5;
        _111 = Option::<&OsStr>::None;
        _110 = (_105, move _111);
        _108 = Vec::<(Flag, Option<&OsStr>)>::push(move _109, move _110) -> [return: bb123, unwind: bb105];
    }

    bb62: {
        _114 = <Result<&Arg, ParseError> as Try>::branch(move _115) -> [return: bb63, unwind: bb105];
    }

    bb63: {
        _117 = discriminant(_114);
        switchInt(move _117) -> [0: bb64, 1: bb65, otherwise: bb21];
    }

    bb64: {
        _119 = ((_114 as Continue).0: &options::parser::Arg);
        _122 = ((*_119).0: std::option::Option<u8>);
        _121 = Option::<u8>::unwrap(move _122) -> [return: bb66, unwind: bb105];
    }

    bb65: {
        _118 = move ((_114 as Break).0: std::result::Result<std::convert::Infallible, options::parser::ParseError>);
        _0 = <Result<options::parser::Matches<'_>, ParseError> as FromResidual<Result<Infallible, ParseError>>>::from_residual(move _118) -> [return: bb124, unwind: bb105];
    }

    bb66: {
        _120 = Flag::Short(move _121);
        _123 = discriminant(((*_119).2: options::parser::TakesValue));
        switchInt(move _123) -> [0: bb68, 1: bb67, 2: bb68, otherwise: bb21];
    }

    bb67: {
        _128 = ParseError::ForbiddenValue { flag: _120 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Err(move _128);
        goto -> bb100;
    }

    bb68: {
        _125 = &mut _5;
        _127 = Option::<&OsStr>::Some(_87);
        _126 = (_120, move _127);
        _124 = Vec::<(Flag, Option<&OsStr>)>::push(move _125, move _126) -> [return: bb125, unwind: bb105];
    }

    bb69: {
        _132 = core::slice::<impl [u8]>::iter(_14) -> [return: bb70, unwind: bb105];
    }

    bb70: {
        _131 = <std::slice::Iter<'_, u8> as Iterator>::enumerate(move _132) -> [return: bb71, unwind: bb105];
    }

    bb71: {
        _130 = <Enumerate<std::slice::Iter<'_, u8>> as Iterator>::skip(move _131, const 1_usize) -> [return: bb72, unwind: bb105];
    }

    bb72: {
        _129 = <std::iter::Skip<Enumerate<std::slice::Iter<'_, u8>>> as IntoIterator>::into_iter(move _130) -> [return: bb73, unwind: bb105];
    }

    bb73: {
        _133 = move _129;
        goto -> bb74;
    }

    bb74: {
        _136 = &mut _133;
        _135 = <std::iter::Skip<Enumerate<std::slice::Iter<'_, u8>>> as Iterator>::next(_136) -> [return: bb75, unwind: bb105];
    }

    bb75: {
        _137 = discriminant(_135);
        switchInt(move _137) -> [0: bb3, 1: bb76, otherwise: bb21];
    }

    bb76: {
        _138 = (((_135 as Some).0: (usize, &u8)).0: usize);
        _139 = (((_135 as Some).0: (usize, &u8)).1: &u8);
        _142 = (*_139);
        _141 = options::parser::Args::lookup_short(_1, move _142) -> [return: bb77, unwind: bb105];
    }

    bb77: {
        _140 = <Result<&Arg, ParseError> as Try>::branch(move _141) -> [return: bb78, unwind: bb105];
    }

    bb78: {
        _143 = discriminant(_140);
        switchInt(move _143) -> [0: bb79, 1: bb80, otherwise: bb21];
    }

    bb79: {
        _145 = ((_140 as Continue).0: &options::parser::Arg);
        _147 = (*_139);
        _146 = Flag::Short(move _147);
        _148 = discriminant(((*_145).2: options::parser::TakesValue));
        switchInt(move _148) -> [0: bb84, 1: bb82, 2: bb81, otherwise: bb21];
    }

    bb80: {
        _144 = move ((_140 as Break).0: std::result::Result<std::convert::Infallible, options::parser::ParseError>);
        _0 = <Result<options::parser::Matches<'_>, ParseError> as FromResidual<Result<Infallible, ParseError>>>::from_residual(move _144) -> [return: bb126, unwind: bb105];
    }

    bb81: {
        _152 = ((((*_145).2: options::parser::TakesValue) as Optional).0: std::option::Option<&[&str]>);
        goto -> bb83;
    }

    bb82: {
        _149 = &mut _5;
        _151 = Option::<&OsStr>::None;
        _150 = (_146, move _151);
        _134 = Vec::<(Flag, Option<&OsStr>)>::push(move _149, move _150) -> [return: bb127, unwind: bb105];
    }

    bb83: {
        _155 = Len((*_14));
        _156 = CheckedSub(_155, const 1_usize);
        assert(!move (_156.1: bool), "attempt to compute `{} - {}`, which would overflow", move _155, const 1_usize) -> [success: bb85, unwind: bb105];
    }

    bb84: {
        _152 = ((((*_145).2: options::parser::TakesValue) as Necessary).0: std::option::Option<&[&str]>);
        goto -> bb83;
    }

    bb85: {
        _154 = move (_156.0: usize);
        _153 = Lt(_138, move _154);
        switchInt(move _153) -> [0: bb90, otherwise: bb86];
    }

    bb86: {
        _160 = CheckedAdd(_138, const 1_usize);
        assert(!move (_160.1: bool), "attempt to compute `{} + {}`, which would overflow", _138, const 1_usize) -> [success: bb87, unwind: bb105];
    }

    bb87: {
        _159 = move (_160.0: usize);
        _158 = RangeFrom::<usize> { start: move _159 };
        _157 = <[u8] as std::ops::Index<RangeFrom<usize>>>::index(_14, move _158) -> [return: bb88, unwind: bb105];
    }

    bb88: {
        _162 = &mut _5;
        _165 = <OsStr as OsStrExt>::from_bytes(_157) -> [return: bb89, unwind: bb105];
    }

    bb89: {
        _164 = Option::<&OsStr>::Some(_165);
        _163 = (_146, move _164);
        _161 = Vec::<(Flag, Option<&OsStr>)>::push(move _162, move _163) -> [return: bb128, unwind: bb105];
    }

    bb90: {
        _167 = &mut _7;
        _166 = <<I as IntoIterator>::IntoIter as Iterator>::next(move _167) -> [return: bb91, unwind: bb105];
    }

    bb91: {
        _168 = discriminant(_166);
        switchInt(move _168) -> [1: bb92, otherwise: bb93];
    }

    bb92: {
        _169 = ((_166 as Some).0: &std::ffi::OsStr);
        _171 = &mut _5;
        _173 = Option::<&OsStr>::Some(_169);
        _172 = (_146, move _173);
        _170 = Vec::<(Flag, Option<&OsStr>)>::push(move _171, move _172) -> [return: bb129, unwind: bb105];
    }

    bb93: {
        _174 = discriminant(((*_145).2: options::parser::TakesValue));
        switchInt(move _174) -> [0: bb96, 1: bb95, 2: bb94, otherwise: bb21];
    }

    bb94: {
        _179 = &mut _5;
        _181 = Option::<&OsStr>::None;
        _180 = (_146, move _181);
        _178 = Vec::<(Flag, Option<&OsStr>)>::push(move _179, move _180) -> [return: bb130, unwind: bb105];
    }

    bb95: {
        _175 = core::panicking::panic(const "internal error: entered unreachable code") -> bb105;
    }

    bb96: {
        _177 = _152;
        _176 = ParseError::NeedsValue { flag: _146, values: move _177 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Err(move _176);
        goto -> bb100;
    }

    bb97: {
        _182 = &mut _6;
        _183 = _13;
        _9 = Vec::<&OsStr>::push(move _182, move _183) -> [return: bb131, unwind: bb105];
    }

    bb98: {
        _190 = const false;
        _185 = move _6;
        _191 = const false;
        _187 = move _5;
        _186 = MatchedFlags::<'_> { flags: move _187, strictness: _3 };
        _184 = options::parser::Matches::<'_> { flags: move _186, frees: move _185 };
        _0 = Result::<options::parser::Matches<'_>, ParseError>::Ok(move _184);
        drop(_7) -> [return: bb99, unwind: bb108];
    }

    bb99: {
        _190 = const false;
        _191 = const false;
        goto -> bb104;
    }

    bb100: {
        drop(_7) -> [return: bb101, unwind: bb108];
    }

    bb101: {
        drop(_6) -> [return: bb102, unwind: bb110];
    }

    bb102: {
        _190 = const false;
        drop(_5) -> [return: bb103, unwind: bb112];
    }

    bb103: {
        _191 = const false;
        goto -> bb104;
    }

    bb104: {
        return;
    }

    bb105 (cleanup): {
        drop(_7) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb106 (cleanup): {
        resume;
    }

    bb107 (cleanup): {
        drop(_6) -> [return: bb110, unwind terminate(cleanup)];
    }

    bb108 (cleanup): {
        switchInt(_190) -> [0: bb110, otherwise: bb107];
    }

    bb109 (cleanup): {
        drop(_5) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        switchInt(_191) -> [0: bb112, otherwise: bb109];
    }

    bb111 (cleanup): {
        drop(_2) -> [return: bb106, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        switchInt(_192) -> [0: bb106, otherwise: bb111];
    }

    bb113: {
        goto -> bb3;
    }

    bb114: {
        goto -> bb3;
    }

    bb115: {
        goto -> bb100;
    }

    bb116: {
        goto -> bb3;
    }

    bb117: {
        goto -> bb100;
    }

    bb118: {
        goto -> bb3;
    }

    bb119: {
        goto -> bb3;
    }

    bb120: {
        goto -> bb3;
    }

    bb121: {
        goto -> bb3;
    }

    bb122: {
        goto -> bb100;
    }

    bb123: {
        goto -> bb52;
    }

    bb124: {
        goto -> bb100;
    }

    bb125: {
        goto -> bb3;
    }

    bb126: {
        goto -> bb100;
    }

    bb127: {
        goto -> bb74;
    }

    bb128: {
        goto -> bb3;
    }

    bb129: {
        goto -> bb74;
    }

    bb130: {
        goto -> bb74;
    }

    bb131: {
        goto -> bb3;
    }
}

alloc63 (size: 1, align: 1) {
    2d                                               -
}

alloc62 (size: 2, align: 1) {
    2d 2d                                            --
}

promoted[0] in options::parser::<impl at src/options/parser.rs:142:1: 142:10>::parse: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "-";
        _0 = &_1;
        return;
    }
}

promoted[1] in options::parser::<impl at src/options/parser.rs:142:1: 142:10>::parse: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "--";
        _0 = &_1;
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:142:1: 142:10>::lookup_short(_1: &options::parser::Args, _2: u8) -> Result<&Arg, ParseError> {
    debug self => _1;
    debug short => _2;
    let mut _0: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _3: std::option::Option<&&options::parser::Arg>;
    let mut _4: &mut std::slice::Iter<'_, &options::parser::Arg>;
    let mut _5: std::slice::Iter<'_, &options::parser::Arg>;
    let mut _6: {closure@src/options/parser.rs:329:34: 329:39};
    let mut _7: &u8;
    let mut _8: isize;
    let _9: &&options::parser::Arg;
    let mut _10: options::parser::ParseError;
    let mut _11: u8;
    let mut _12: &[&options::parser::Arg];
    let mut _13: &options::parser::Arg;
    scope 1 {
        debug arg => _9;
    }

    bb0: {
        _12 = deref_copy ((*_1).0: &[&options::parser::Arg]);
        _5 = core::slice::<impl [&Arg]>::iter(_12) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _5;
        _7 = &_2;
        _6 = {closure@src/options/parser.rs:329:34: 329:39} { short: move _7 };
        _3 = <std::slice::Iter<'_, &Arg> as Iterator>::find::<{closure@src/options/parser.rs:329:34: 329:39}>(move _4, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _11 = _2;
        _10 = ParseError::UnknownShortArgument { attempt: move _11 };
        _0 = Result::<&Arg, ParseError>::Err(move _10);
        goto -> bb6;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = ((_3 as Some).0: &&options::parser::Arg);
        _13 = deref_copy (*_9);
        _0 = Result::<&Arg, ParseError>::Ok(_13);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:142:1: 142:10>::lookup_short::{closure#0}(_1: &mut {closure@src/options/parser.rs:329:34: 329:39}, _2: &&&Arg) -> bool {
    debug arg => _2;
    debug short => (*((*_1).0: &u8));
    let mut _0: bool;
    let mut _3: &std::option::Option<u8>;
    let mut _4: &std::option::Option<u8>;
    let _5: std::option::Option<u8>;
    let mut _6: u8;
    let mut _7: &&options::parser::Arg;
    let mut _8: &options::parser::Arg;
    let mut _9: &u8;

    bb0: {
        _7 = deref_copy (*_2);
        _8 = deref_copy (*_7);
        _3 = &((*_8).0: std::option::Option<u8>);
        _9 = deref_copy ((*_1).0: &u8);
        _6 = (*_9);
        _5 = Option::<u8>::Some(move _6);
        _4 = &_5;
        _0 = <Option<u8> as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:142:1: 142:10>::lookup_long(_1: &options::parser::Args, _2: &OsStr) -> Result<&Arg, ParseError> {
    debug self => _1;
    debug long => _2;
    let mut _0: std::result::Result<&options::parser::Arg, options::parser::ParseError>;
    let mut _3: std::option::Option<&&options::parser::Arg>;
    let mut _4: &mut std::slice::Iter<'_, &options::parser::Arg>;
    let mut _5: std::slice::Iter<'_, &options::parser::Arg>;
    let mut _6: {closure@src/options/parser.rs:336:34: 336:39};
    let mut _7: &&std::ffi::OsStr;
    let mut _8: isize;
    let _9: &&options::parser::Arg;
    let mut _10: options::parser::ParseError;
    let mut _11: std::ffi::OsString;
    let mut _12: &std::ffi::OsStr;
    let mut _13: &[&options::parser::Arg];
    let mut _14: &options::parser::Arg;
    scope 1 {
        debug arg => _9;
    }

    bb0: {
        _13 = deref_copy ((*_1).0: &[&options::parser::Arg]);
        _5 = core::slice::<impl [&Arg]>::iter(_13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _5;
        _7 = &_2;
        _6 = {closure@src/options/parser.rs:336:34: 336:39} { long: move _7 };
        _3 = <std::slice::Iter<'_, &Arg> as Iterator>::find::<{closure@src/options/parser.rs:336:34: 336:39}>(move _4, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _12 = _2;
        _11 = OsStr::to_os_string(move _12) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = ((_3 as Some).0: &&options::parser::Arg);
        _14 = deref_copy (*_9);
        _0 = Result::<&Arg, ParseError>::Ok(_14);
        goto -> bb7;
    }

    bb6: {
        _10 = ParseError::UnknownArgument { attempt: move _11 };
        _0 = Result::<&Arg, ParseError>::Err(move _10);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:142:1: 142:10>::lookup_long::{closure#0}(_1: &mut {closure@src/options/parser.rs:336:34: 336:39}, _2: &&&Arg) -> bool {
    debug arg => _2;
    debug long => (*((*_1).0: &&std::ffi::OsStr));
    let mut _0: bool;
    let mut _3: &&str;
    let mut _4: &&options::parser::Arg;
    let mut _5: &options::parser::Arg;
    let mut _6: &&std::ffi::OsStr;

    bb0: {
        _4 = deref_copy (*_2);
        _5 = deref_copy (*_4);
        _3 = &((*_5).1: &str);
        _6 = deref_copy ((*_1).0: &&std::ffi::OsStr);
        _0 = <&str as PartialEq<&OsStr>>::eq(move _3, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:345:10: 345:19>::eq(_1: &options::parser::Matches<'_>, _2: &options::parser::Matches<'_>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &options::parser::MatchedFlags<'_>;
    let mut _5: &options::parser::MatchedFlags<'_>;
    let mut _6: &std::vec::Vec<&std::ffi::OsStr>;
    let mut _7: &std::vec::Vec<&std::ffi::OsStr>;

    bb0: {
        _4 = &((*_1).0: options::parser::MatchedFlags<'_>);
        _5 = &((*_2).0: options::parser::MatchedFlags<'_>);
        _3 = <MatchedFlags<'_> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: std::vec::Vec<&std::ffi::OsStr>);
        _7 = &((*_2).1: std::vec::Vec<&std::ffi::OsStr>);
        _0 = <Vec<&OsStr> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:345:21: 345:26>::fmt(_1: &options::parser::Matches<'_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &options::parser::MatchedFlags<'_>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::vec::Vec<&std::ffi::OsStr>;
    let _10: &std::vec::Vec<&std::ffi::OsStr>;

    bb0: {
        _3 = const "Matches";
        _4 = const "flags";
        _6 = &((*_1).0: options::parser::MatchedFlags<'_>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "frees";
        _10 = &((*_1).1: std::vec::Vec<&std::ffi::OsStr>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:356:10: 356:19>::eq(_1: &MatchedFlags<'_>, _2: &MatchedFlags<'_>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _5: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _6: &options::parser::Strictness;
    let mut _7: &options::parser::Strictness;

    bb0: {
        _4 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _5 = &((*_2).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _3 = <Vec<(Flag, Option<&OsStr>)> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: options::parser::Strictness);
        _7 = &((*_2).1: options::parser::Strictness);
        _0 = <Strictness as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:356:21: 356:26>::fmt(_1: &MatchedFlags<'_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&options::parser::Strictness;
    let _10: &options::parser::Strictness;

    bb0: {
        _3 = const "MatchedFlags";
        _4 = const "flags";
        _6 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "strictness";
        _10 = &((*_1).1: options::parser::Strictness);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has(_1: &MatchedFlags<'_>, _2: &Arg) -> Result<bool, OptionsError> {
    debug self => _1;
    debug arg => _2;
    let mut _0: std::result::Result<bool, options::error::OptionsError>;
    let mut _3: std::result::Result<std::option::Option<&options::parser::Flag>, options::error::OptionsError>;
    let mut _4: {closure@src/options/parser.rs:377:24: 377:30};
    let mut _5: &&options::parser::Arg;

    bb0: {
        _5 = &_2;
        _4 = {closure@src/options/parser.rs:377:24: 377:30} { arg: move _5 };
        _3 = MatchedFlags::<'_>::has_where::<{closure@src/options/parser.rs:377:24: 377:30}>(_1, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<Option<&Flag>, OptionsError>::map::<bool, {closure@src/options/parser.rs:378:18: 378:24}>(move _3, const ZeroSized: {closure@src/options/parser.rs:378:18: 378:24}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has::{closure#0}(_1: &{closure@src/options/parser.rs:377:24: 377:30}, _2: &Flag) -> bool {
    debug flag => _2;
    debug arg => (*((*_1).0: &&options::parser::Arg));
    let mut _0: bool;
    let mut _3: &&options::parser::Arg;
    let mut _4: &options::parser::Arg;

    bb0: {
        _3 = deref_copy ((*_1).0: &&options::parser::Arg);
        _4 = deref_copy (*_3);
        _0 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has::{closure#1}(_1: {closure@src/options/parser.rs:378:18: 378:24}, _2: Option<&Flag>) -> bool {
    debug flag => _2;
    let mut _0: bool;
    let mut _3: &std::option::Option<&options::parser::Flag>;

    bb0: {
        _3 = &_2;
        _0 = Option::<&Flag>::is_some(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where(_1: &MatchedFlags<'_>, _2: P) -> Result<Option<&Flag>, OptionsError> {
    debug self => _1;
    debug predicate => _2;
    let mut _0: std::result::Result<std::option::Option<&options::parser::Flag>, options::error::OptionsError>;
    let mut _3: bool;
    let _4: std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _5: std::iter::Filter<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>, {closure@src/options/parser.rs:390:35: 390:42}>;
    let mut _6: std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _7: &[(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _8: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _9: {closure@src/options/parser.rs:390:35: 390:42};
    let mut _10: &P;
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _14: std::option::Option<&options::parser::Flag>;
    let mut _15: std::option::Option<&&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _16: &[&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _17: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _18: options::error::OptionsError;
    let mut _19: options::parser::Flag;
    let mut _20: &&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _21: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _22: options::parser::Flag;
    let mut _23: &&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _24: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _25: std::option::Option<&options::parser::Flag>;
    let mut _26: P;
    let mut _27: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _28: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _29: bool;
    scope 1 {
        debug all => _4;
    }

    bb0: {
        _29 = const false;
        _29 = const true;
        _3 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb1, unwind: bb24];
    }

    bb1: {
        switchInt(move _3) -> [0: bb16, otherwise: bb2];
    }

    bb2: {
        _8 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _7 = <Vec<(Flag, Option<&OsStr>)> as Deref>::deref(move _8) -> [return: bb3, unwind: bb24];
    }

    bb3: {
        _6 = core::slice::<impl [(Flag, Option<&OsStr>)]>::iter(_7) -> [return: bb4, unwind: bb24];
    }

    bb4: {
        _10 = &_2;
        _9 = {closure@src/options/parser.rs:390:35: 390:42} { predicate: move _10 };
        _5 = <std::slice::Iter<'_, (Flag, Option<&OsStr>)> as Iterator>::filter::<{closure@src/options/parser.rs:390:35: 390:42}>(move _6, move _9) -> [return: bb5, unwind: bb24];
    }

    bb5: {
        _4 = <std::iter::Filter<std::slice::Iter<'_, (Flag, Option<&OsStr>)>, {closure@src/options/parser.rs:390:35: 390:42}> as Iterator>::collect::<Vec<&(Flag, Option<&OsStr>)>>(move _5) -> [return: bb6, unwind: bb24];
    }

    bb6: {
        _13 = &_4;
        _12 = Vec::<&(Flag, Option<&OsStr>)>::len(move _13) -> [return: bb7, unwind: bb20];
    }

    bb7: {
        _11 = Lt(move _12, const 2_usize);
        switchInt(move _11) -> [0: bb12, otherwise: bb8];
    }

    bb8: {
        _17 = &_4;
        _16 = <Vec<&(Flag, Option<&OsStr>)> as Deref>::deref(move _17) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _15 = core::slice::<impl [&(Flag, Option<&OsStr>)]>::first(_16) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _14 = Option::<&&(Flag, Option<&OsStr>)>::map::<&Flag, {closure@src/options/parser.rs:393:51: 393:54}>(move _15, const ZeroSized: {closure@src/options/parser.rs:393:51: 393:54}) -> [return: bb11, unwind: bb20];
    }

    bb11: {
        _0 = Result::<Option<&Flag>, OptionsError>::Ok(move _14);
        goto -> bb15;
    }

    bb12: {
        _21 = &_4;
        _20 = <Vec<&(Flag, Option<&OsStr>)> as std::ops::Index<usize>>::index(move _21, const 0_usize) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _27 = deref_copy (*_20);
        _19 = ((*_27).0: options::parser::Flag);
        _24 = &_4;
        _23 = <Vec<&(Flag, Option<&OsStr>)> as std::ops::Index<usize>>::index(move _24, const 1_usize) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _28 = deref_copy (*_23);
        _22 = ((*_28).0: options::parser::Flag);
        _18 = OptionsError::Duplicate(move _19, move _22);
        _0 = Result::<Option<&Flag>, OptionsError>::Err(move _18);
        goto -> bb15;
    }

    bb15: {
        drop(_4) -> [return: bb18, unwind: bb24];
    }

    bb16: {
        _29 = const false;
        _26 = move _2;
        _25 = MatchedFlags::<'_>::has_where_any::<P>(_1, move _26) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _0 = Result::<Option<&Flag>, OptionsError>::Ok(move _25);
        goto -> bb18;
    }

    bb18: {
        switchInt(_29) -> [0: bb19, otherwise: bb22];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_4) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }

    bb22: {
        drop(_2) -> [return: bb19, unwind continue];
    }

    bb23 (cleanup): {
        drop(_2) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_29) -> [0: bb21, otherwise: bb23];
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where::{closure#0}(_1: &mut {closure@src/options/parser.rs:390:35: 390:42}, _2: &&(Flag, Option<&OsStr>)) -> bool {
    debug tuple => _2;
    debug predicate => (*((*_1).0: &P));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<&std::ffi::OsStr>;
    let mut _5: (&options::parser::Flag,);
    let _6: &options::parser::Flag;
    let mut _7: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _8: &P;
    let mut _9: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);

    bb0: {
        _7 = deref_copy (*_2);
        _4 = &((*_7).1: std::option::Option<&std::ffi::OsStr>);
        _3 = Option::<&OsStr>::is_none(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = deref_copy ((*_1).0: &P);
        _9 = deref_copy (*_2);
        _6 = &((*_9).0: options::parser::Flag);
        _5 = (_6,);
        _0 = <P as Fn<(&Flag,)>>::call(_8, move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where::{closure#1}(_1: {closure@src/options/parser.rs:393:51: 393:54}, _2: &&(Flag, Option<&OsStr>)) -> &Flag {
    debug t => _2;
    let mut _0: &options::parser::Flag;
    let mut _3: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);

    bb0: {
        _3 = deref_copy (*_2);
        _0 = &((*_3).0: options::parser::Flag);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where_any(_1: &MatchedFlags<'_>, _2: P) -> Option<&Flag> {
    debug self => _1;
    debug predicate => _2;
    let mut _0: std::option::Option<&options::parser::Flag>;
    let mut _3: std::option::Option<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _4: &mut std::iter::Rev<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>>;
    let mut _5: std::iter::Rev<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>>;
    let mut _6: std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _7: &[(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _8: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _9: {closure@src/options/parser.rs:408:19: 408:26};
    let mut _10: &P;

    bb0: {
        _8 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _7 = <Vec<(Flag, Option<&OsStr>)> as Deref>::deref(move _8) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _6 = core::slice::<impl [(Flag, Option<&OsStr>)]>::iter(_7) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _5 = <std::slice::Iter<'_, (Flag, Option<&OsStr>)> as Iterator>::rev(move _6) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _4 = &mut _5;
        _10 = &_2;
        _9 = {closure@src/options/parser.rs:408:19: 408:26} { predicate: move _10 };
        _3 = <Rev<std::slice::Iter<'_, (Flag, Option<&OsStr>)>> as Iterator>::find::<{closure@src/options/parser.rs:408:19: 408:26}>(move _4, move _9) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _0 = Option::<&(Flag, Option<&OsStr>)>::map::<&Flag, {closure@src/options/parser.rs:409:18: 409:25}>(move _3, const ZeroSized: {closure@src/options/parser.rs:409:18: 409:25}) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where_any::{closure#0}(_1: &mut {closure@src/options/parser.rs:408:19: 408:26}, _2: &&(Flag, Option<&OsStr>)) -> bool {
    debug tuple => _2;
    debug predicate => (*((*_1).0: &P));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<&std::ffi::OsStr>;
    let mut _5: (&options::parser::Flag,);
    let _6: &options::parser::Flag;
    let mut _7: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _8: &P;
    let mut _9: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);

    bb0: {
        _7 = deref_copy (*_2);
        _4 = &((*_7).1: std::option::Option<&std::ffi::OsStr>);
        _3 = Option::<&OsStr>::is_none(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = deref_copy ((*_1).0: &P);
        _9 = deref_copy (*_2);
        _6 = &((*_9).0: options::parser::Flag);
        _5 = (_6,);
        _0 = <P as Fn<(&Flag,)>>::call(_8, move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::has_where_any::{closure#1}(_1: {closure@src/options/parser.rs:409:18: 409:25}, _2: &(Flag, Option<&OsStr>)) -> &Flag {
    debug tuple => _2;
    let mut _0: &options::parser::Flag;

    bb0: {
        _0 = &((*_2).0: options::parser::Flag);
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get(_1: &MatchedFlags<'_>, _2: &Arg) -> Result<Option<&OsStr>, OptionsError> {
    debug self => _1;
    debug arg => _2;
    let mut _0: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let mut _3: {closure@src/options/parser.rs:420:24: 420:30};
    let mut _4: &&options::parser::Arg;

    bb0: {
        _4 = &_2;
        _3 = {closure@src/options/parser.rs:420:24: 420:30} { arg: move _4 };
        _0 = MatchedFlags::<'_>::get_where::<{closure@src/options/parser.rs:420:24: 420:30}>(_1, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get::{closure#0}(_1: &{closure@src/options/parser.rs:420:24: 420:30}, _2: &Flag) -> bool {
    debug flag => _2;
    debug arg => (*((*_1).0: &&options::parser::Arg));
    let mut _0: bool;
    let mut _3: &&options::parser::Arg;
    let mut _4: &options::parser::Arg;

    bb0: {
        _3 = deref_copy ((*_1).0: &&options::parser::Arg);
        _4 = deref_copy (*_3);
        _0 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get_where(_1: &MatchedFlags<'_>, _2: P) -> Result<Option<&OsStr>, OptionsError> {
    debug self => _1;
    debug predicate => _2;
    let mut _0: std::result::Result<std::option::Option<&std::ffi::OsStr>, options::error::OptionsError>;
    let mut _3: bool;
    let _4: std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _5: std::iter::Filter<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>, {closure@src/options/parser.rs:432:37: 432:44}>;
    let mut _6: std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _7: &[(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _8: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _9: {closure@src/options/parser.rs:432:37: 432:44};
    let mut _10: &P;
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _14: std::option::Option<&std::ffi::OsStr>;
    let mut _15: std::option::Option<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _16: std::option::Option<&&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _17: &[&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _18: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _19: options::error::OptionsError;
    let mut _20: options::parser::Flag;
    let mut _21: &&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _22: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _23: options::parser::Flag;
    let mut _24: &&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _25: &std::vec::Vec<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _26: std::option::Option<&std::ffi::OsStr>;
    let mut _27: std::option::Option<&(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _28: &mut std::iter::Rev<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>>;
    let mut _29: std::iter::Rev<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>>;
    let mut _30: std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _31: &[(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _32: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _33: {closure@src/options/parser.rs:440:35: 440:42};
    let mut _34: &P;
    let mut _35: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _36: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    scope 1 {
        debug those => _4;
    }
    scope 2 {
        debug found => _26;
    }

    bb0: {
        _3 = MatchedFlags::<'_>::is_strict(_1) -> [return: bb1, unwind: bb26];
    }

    bb1: {
        switchInt(move _3) -> [0: bb17, otherwise: bb2];
    }

    bb2: {
        _8 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _7 = <Vec<(Flag, Option<&OsStr>)> as Deref>::deref(move _8) -> [return: bb3, unwind: bb26];
    }

    bb3: {
        _6 = core::slice::<impl [(Flag, Option<&OsStr>)]>::iter(_7) -> [return: bb4, unwind: bb26];
    }

    bb4: {
        _10 = &_2;
        _9 = {closure@src/options/parser.rs:432:37: 432:44} { predicate: move _10 };
        _5 = <std::slice::Iter<'_, (Flag, Option<&OsStr>)> as Iterator>::filter::<{closure@src/options/parser.rs:432:37: 432:44}>(move _6, move _9) -> [return: bb5, unwind: bb26];
    }

    bb5: {
        _4 = <std::iter::Filter<std::slice::Iter<'_, (Flag, Option<&OsStr>)>, {closure@src/options/parser.rs:432:37: 432:44}> as Iterator>::collect::<Vec<&(Flag, Option<&OsStr>)>>(move _5) -> [return: bb6, unwind: bb26];
    }

    bb6: {
        _13 = &_4;
        _12 = Vec::<&(Flag, Option<&OsStr>)>::len(move _13) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _11 = Lt(move _12, const 2_usize);
        switchInt(move _11) -> [0: bb13, otherwise: bb8];
    }

    bb8: {
        _18 = &_4;
        _17 = <Vec<&(Flag, Option<&OsStr>)> as Deref>::deref(move _18) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _16 = core::slice::<impl [&(Flag, Option<&OsStr>)]>::first(_17) -> [return: bb10, unwind: bb25];
    }

    bb10: {
        _15 = Option::<&&(Flag, Option<&OsStr>)>::cloned(move _16) -> [return: bb11, unwind: bb25];
    }

    bb11: {
        _14 = Option::<&(Flag, Option<&OsStr>)>::map::<&OsStr, {closure@src/options/parser.rs:435:64: 435:67}>(move _15, const ZeroSized: {closure@src/options/parser.rs:435:64: 435:67}) -> [return: bb12, unwind: bb25];
    }

    bb12: {
        _0 = Result::<Option<&OsStr>, OptionsError>::Ok(move _14);
        goto -> bb16;
    }

    bb13: {
        _22 = &_4;
        _21 = <Vec<&(Flag, Option<&OsStr>)> as std::ops::Index<usize>>::index(move _22, const 0_usize) -> [return: bb14, unwind: bb25];
    }

    bb14: {
        _35 = deref_copy (*_21);
        _20 = ((*_35).0: options::parser::Flag);
        _25 = &_4;
        _24 = <Vec<&(Flag, Option<&OsStr>)> as std::ops::Index<usize>>::index(move _25, const 1_usize) -> [return: bb15, unwind: bb25];
    }

    bb15: {
        _36 = deref_copy (*_24);
        _23 = ((*_36).0: options::parser::Flag);
        _19 = OptionsError::Duplicate(move _20, move _23);
        _0 = Result::<Option<&OsStr>, OptionsError>::Err(move _19);
        goto -> bb16;
    }

    bb16: {
        drop(_4) -> [return: bb23, unwind: bb26];
    }

    bb17: {
        _32 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _31 = <Vec<(Flag, Option<&OsStr>)> as Deref>::deref(move _32) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _30 = core::slice::<impl [(Flag, Option<&OsStr>)]>::iter(_31) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _29 = <std::slice::Iter<'_, (Flag, Option<&OsStr>)> as Iterator>::rev(move _30) -> [return: bb20, unwind: bb26];
    }

    bb20: {
        _28 = &mut _29;
        _34 = &_2;
        _33 = {closure@src/options/parser.rs:440:35: 440:42} { predicate: move _34 };
        _27 = <Rev<std::slice::Iter<'_, (Flag, Option<&OsStr>)>> as Iterator>::find::<{closure@src/options/parser.rs:440:35: 440:42}>(move _28, move _33) -> [return: bb21, unwind: bb26];
    }

    bb21: {
        _26 = Option::<&(Flag, Option<&OsStr>)>::map::<&OsStr, {closure@src/options/parser.rs:441:34: 441:41}>(move _27, const ZeroSized: {closure@src/options/parser.rs:441:34: 441:41}) -> [return: bb22, unwind: bb26];
    }

    bb22: {
        _0 = Result::<Option<&OsStr>, OptionsError>::Ok(_26);
        goto -> bb23;
    }

    bb23: {
        drop(_2) -> [return: bb24, unwind continue];
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_4) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_2) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get_where::{closure#0}(_1: &mut {closure@src/options/parser.rs:432:37: 432:44}, _2: &&(Flag, Option<&OsStr>)) -> bool {
    debug tuple => _2;
    debug predicate => (*((*_1).0: &P));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<&std::ffi::OsStr>;
    let mut _5: (&options::parser::Flag,);
    let _6: &options::parser::Flag;
    let mut _7: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _8: &P;
    let mut _9: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);

    bb0: {
        _7 = deref_copy (*_2);
        _4 = &((*_7).1: std::option::Option<&std::ffi::OsStr>);
        _3 = Option::<&OsStr>::is_some(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = deref_copy ((*_1).0: &P);
        _9 = deref_copy (*_2);
        _6 = &((*_9).0: options::parser::Flag);
        _5 = (_6,);
        _0 = <P as Fn<(&Flag,)>>::call(_8, move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get_where::{closure#1}(_1: {closure@src/options/parser.rs:435:64: 435:67}, _2: &(Flag, Option<&OsStr>)) -> &OsStr {
    debug t => _2;
    let mut _0: &std::ffi::OsStr;
    let mut _3: std::option::Option<&std::ffi::OsStr>;

    bb0: {
        _3 = ((*_2).1: std::option::Option<&std::ffi::OsStr>);
        _0 = Option::<&OsStr>::unwrap(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get_where::{closure#2}(_1: &mut {closure@src/options/parser.rs:440:35: 440:42}, _2: &&(Flag, Option<&OsStr>)) -> bool {
    debug tuple => _2;
    debug predicate => (*((*_1).0: &P));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<&std::ffi::OsStr>;
    let mut _5: (&options::parser::Flag,);
    let _6: &options::parser::Flag;
    let mut _7: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _8: &P;
    let mut _9: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);

    bb0: {
        _7 = deref_copy (*_2);
        _4 = &((*_7).1: std::option::Option<&std::ffi::OsStr>);
        _3 = Option::<&OsStr>::is_some(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = deref_copy ((*_1).0: &P);
        _9 = deref_copy (*_2);
        _6 = &((*_9).0: options::parser::Flag);
        _5 = (_6,);
        _0 = <P as Fn<(&Flag,)>>::call(_8, move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::get_where::{closure#3}(_1: {closure@src/options/parser.rs:441:34: 441:41}, _2: &(Flag, Option<&OsStr>)) -> &OsStr {
    debug tuple => _2;
    let mut _0: &std::ffi::OsStr;
    let mut _3: std::option::Option<&std::ffi::OsStr>;

    bb0: {
        _3 = ((*_2).1: std::option::Option<&std::ffi::OsStr>);
        _0 = Option::<&OsStr>::unwrap(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::count(_1: &MatchedFlags<'_>, _2: &Arg) -> usize {
    debug self => _1;
    debug arg => _2;
    let mut _0: usize;
    let mut _3: std::iter::Filter<std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>, {closure@src/options/parser.rs:453:21: 453:28}>;
    let mut _4: std::slice::Iter<'_, (options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let _5: &[(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)];
    let mut _6: &std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>;
    let mut _7: {closure@src/options/parser.rs:453:21: 453:28};
    let mut _8: &&options::parser::Arg;

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<(options::parser::Flag, std::option::Option<&std::ffi::OsStr>)>);
        _5 = <Vec<(Flag, Option<&OsStr>)> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [(Flag, Option<&OsStr>)]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &_2;
        _7 = {closure@src/options/parser.rs:453:21: 453:28} { arg: move _8 };
        _3 = <std::slice::Iter<'_, (Flag, Option<&OsStr>)> as Iterator>::filter::<{closure@src/options/parser.rs:453:21: 453:28}>(move _4, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <std::iter::Filter<std::slice::Iter<'_, (Flag, Option<&OsStr>)>, {closure@src/options/parser.rs:453:21: 453:28}> as Iterator>::count(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::count::{closure#0}(_1: &mut {closure@src/options/parser.rs:453:21: 453:28}, _2: &&(Flag, Option<&OsStr>)) -> bool {
    debug tuple => _2;
    debug arg => (*((*_1).0: &&options::parser::Arg));
    let mut _0: bool;
    let mut _3: &options::parser::Flag;
    let mut _4: &(options::parser::Flag, std::option::Option<&std::ffi::OsStr>);
    let mut _5: &&options::parser::Arg;
    let mut _6: &options::parser::Arg;

    bb0: {
        _4 = deref_copy (*_2);
        _3 = &((*_4).0: options::parser::Flag);
        _5 = deref_copy ((*_1).0: &&options::parser::Arg);
        _6 = deref_copy (*_5);
        _0 = Flag::matches(move _3, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:371:1: 371:26>::is_strict(_1: &MatchedFlags<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &options::parser::Strictness;
    let mut _3: &options::parser::Strictness;

    bb0: {
        _2 = &((*_1).1: options::parser::Strictness);
        _3 = const _;
        _0 = <Strictness as PartialEq>::eq(move _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in options::parser::<impl at src/options/parser.rs:371:1: 371:26>::is_strict: &Strictness = {
    let mut _0: &options::parser::Strictness;
    let mut _1: options::parser::Strictness;

    bb0: {
        _1 = Strictness::ComplainAboutRedundantArguments;
        _0 = &_1;
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:467:10: 467:19>::eq(_1: &ParseError, _2: &ParseError) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&options::parser::ParseError, &options::parser::ParseError);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _11: isize;
    let mut _16: bool;
    let mut _21: u8;
    let mut _22: u8;
    let mut _25: &options::parser::ParseError;
    let mut _26: &options::parser::ParseError;
    let mut _27: &options::parser::ParseError;
    let mut _28: &options::parser::ParseError;
    let mut _29: &options::parser::ParseError;
    let mut _30: &options::parser::ParseError;
    let mut _31: &options::parser::ParseError;
    let mut _32: &options::parser::ParseError;
    let mut _33: &options::parser::ParseError;
    let mut _34: &options::parser::ParseError;
    let mut _35: &options::parser::ParseError;
    let mut _36: &options::parser::ParseError;
    let mut _37: &options::parser::ParseError;
    let mut _38: &options::parser::ParseError;
    let mut _39: &options::parser::ParseError;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _12: &options::parser::Flag;
            let _13: &std::option::Option<&[&str]>;
            let _14: &options::parser::Flag;
            let _15: &std::option::Option<&[&str]>;
            let _17: &options::parser::Flag;
            let _18: &options::parser::Flag;
            let _19: &u8;
            let _20: &u8;
            let _23: &std::ffi::OsString;
            let _24: &std::ffi::OsString;
            scope 3 {
                debug __self_0 => _12;
                debug __self_1 => _13;
                debug __arg1_0 => _14;
                debug __arg1_1 => _15;
            }
            scope 4 {
                debug __self_0 => _17;
                debug __arg1_0 => _18;
            }
            scope 5 {
                debug __self_0 => _19;
                debug __arg1_0 => _20;
            }
            scope 6 {
                debug __self_0 => _23;
                debug __arg1_0 => _24;
            }
            scope 7 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _25 = deref_copy (_6.0: &options::parser::ParseError);
        _11 = discriminant((*_25));
        switchInt(move _11) -> [0: bb3, 1: bb5, 2: bb6, 3: bb7, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb15;
    }

    bb3: {
        _26 = deref_copy (_6.1: &options::parser::ParseError);
        _7 = discriminant((*_26));
        switchInt(move _7) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _27 = deref_copy (_6.1: &options::parser::ParseError);
        _8 = discriminant((*_27));
        switchInt(move _8) -> [1: bb12, otherwise: bb4];
    }

    bb6: {
        _28 = deref_copy (_6.1: &options::parser::ParseError);
        _9 = discriminant((*_28));
        switchInt(move _9) -> [2: bb13, otherwise: bb4];
    }

    bb7: {
        _29 = deref_copy (_6.1: &options::parser::ParseError);
        _10 = discriminant((*_29));
        switchInt(move _10) -> [3: bb14, otherwise: bb4];
    }

    bb8: {
        _30 = deref_copy (_6.0: &options::parser::ParseError);
        _12 = &(((*_30) as NeedsValue).0: options::parser::Flag);
        _31 = deref_copy (_6.0: &options::parser::ParseError);
        _13 = &(((*_31) as NeedsValue).1: std::option::Option<&[&str]>);
        _32 = deref_copy (_6.1: &options::parser::ParseError);
        _14 = &(((*_32) as NeedsValue).0: options::parser::Flag);
        _33 = deref_copy (_6.1: &options::parser::ParseError);
        _15 = &(((*_33) as NeedsValue).1: std::option::Option<&[&str]>);
        _16 = <Flag as PartialEq>::eq(_12, _14) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _16) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = <Option<&[&str]> as PartialEq>::eq(_13, _15) -> [return: bb15, unwind continue];
    }

    bb11: {
        _0 = const false;
        goto -> bb15;
    }

    bb12: {
        _34 = deref_copy (_6.0: &options::parser::ParseError);
        _17 = &(((*_34) as ForbiddenValue).0: options::parser::Flag);
        _35 = deref_copy (_6.1: &options::parser::ParseError);
        _18 = &(((*_35) as ForbiddenValue).0: options::parser::Flag);
        _0 = <Flag as PartialEq>::eq(_17, _18) -> [return: bb15, unwind continue];
    }

    bb13: {
        _36 = deref_copy (_6.0: &options::parser::ParseError);
        _19 = &(((*_36) as UnknownShortArgument).0: u8);
        _37 = deref_copy (_6.1: &options::parser::ParseError);
        _20 = &(((*_37) as UnknownShortArgument).0: u8);
        _21 = (*_19);
        _22 = (*_20);
        _0 = Eq(move _21, move _22);
        goto -> bb15;
    }

    bb14: {
        _38 = deref_copy (_6.0: &options::parser::ParseError);
        _23 = &(((*_38) as UnknownArgument).0: std::ffi::OsString);
        _39 = deref_copy (_6.1: &options::parser::ParseError);
        _24 = &(((*_39) as UnknownArgument).0: std::ffi::OsString);
        _0 = <OsString as PartialEq>::eq(_23, _24) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:467:21: 467:26>::fmt(_1: &ParseError, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &options::parser::Flag;
    let _5: &std::option::Option<&[&str]>;
    let _6: &str;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&std::option::Option<&[&str]>;
    let _12: &options::parser::Flag;
    let _13: &str;
    let _14: &str;
    let mut _15: &dyn std::fmt::Debug;
    let _16: &&options::parser::Flag;
    let _17: &u8;
    let _18: &str;
    let _19: &str;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &&u8;
    let _22: &std::ffi::OsString;
    let _23: &str;
    let _24: &str;
    let mut _25: &dyn std::fmt::Debug;
    let _26: &&std::ffi::OsString;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
    }
    scope 2 {
        debug __self_0 => _12;
    }
    scope 3 {
        debug __self_0 => _17;
    }
    scope 4 {
        debug __self_0 => _22;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _22 = &(((*_1) as UnknownArgument).0: std::ffi::OsString);
        _23 = const "UnknownArgument";
        _24 = const "attempt";
        _26 = &_22;
        _25 = _26 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _23, _24, move _25) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as NeedsValue).0: options::parser::Flag);
        _5 = &(((*_1) as NeedsValue).1: std::option::Option<&[&str]>);
        _6 = const "NeedsValue";
        _7 = const "flag";
        _8 = _4 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = const "values";
        _11 = &_5;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _6, _7, move _8, _9, move _10) -> [return: bb6, unwind continue];
    }

    bb4: {
        _12 = &(((*_1) as ForbiddenValue).0: options::parser::Flag);
        _13 = const "ForbiddenValue";
        _14 = const "flag";
        _16 = &_12;
        _15 = _16 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _13, _14, move _15) -> [return: bb6, unwind continue];
    }

    bb5: {
        _17 = &(((*_1) as UnknownShortArgument).0: u8);
        _18 = const "UnknownShortArgument";
        _19 = const "attempt";
        _21 = &_17;
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _18, _19, move _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt(_1: &ParseError, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let mut _4: isize;
    let _5: &options::parser::Flag;
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 1];
    let _10: [core::fmt::rt::Argument<'_>; 1];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &&options::parser::Flag;
    let _13: &options::parser::Flag;
    let _14: &&[&str];
    let mut _15: std::fmt::Arguments<'_>;
    let mut _16: &[&str];
    let mut _17: &[core::fmt::rt::Argument<'_>];
    let _18: &[core::fmt::rt::Argument<'_>; 2];
    let _19: [core::fmt::rt::Argument<'_>; 2];
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &&options::parser::Flag;
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &options::error::Choices;
    let _24: options::error::Choices;
    let _25: &options::parser::Flag;
    let mut _26: std::fmt::Arguments<'_>;
    let mut _27: &[&str];
    let mut _28: &[core::fmt::rt::Argument<'_>];
    let _29: &[core::fmt::rt::Argument<'_>; 1];
    let _30: [core::fmt::rt::Argument<'_>; 1];
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &&options::parser::Flag;
    let _33: &u8;
    let mut _34: std::fmt::Arguments<'_>;
    let mut _35: &[&str];
    let mut _36: &[core::fmt::rt::Argument<'_>];
    let _37: &[core::fmt::rt::Argument<'_>; 1];
    let _38: [core::fmt::rt::Argument<'_>; 1];
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &char;
    let _41: char;
    let mut _42: u8;
    let _43: &std::ffi::OsString;
    let mut _44: std::fmt::Arguments<'_>;
    let mut _45: &[&str];
    let mut _46: &[core::fmt::rt::Argument<'_>];
    let _47: &[core::fmt::rt::Argument<'_>; 1];
    let _48: [core::fmt::rt::Argument<'_>; 1];
    let mut _49: core::fmt::rt::Argument<'_>;
    let _50: &std::borrow::Cow<'_, str>;
    let _51: std::borrow::Cow<'_, str>;
    let _52: &std::ffi::OsStr;
    let mut _58: &[&str];
    scope 1 {
        debug flag => _5;
        let mut _57: &[&str; 2];
    }
    scope 2 {
        debug flag => _13;
        debug cs => _14;
        let mut _56: &[&str; 3];
    }
    scope 3 {
        debug flag => _25;
        let mut _55: &[&str; 2];
    }
    scope 4 {
        debug attempt => _33;
        let mut _54: &[&str; 1];
    }
    scope 5 {
        debug attempt => _43;
        let mut _53: &[&str; 1];
    }

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb1, 1: bb11, 2: bb14, 3: bb3, otherwise: bb2];
    }

    bb1: {
        _3 = discriminant((((*_1) as NeedsValue).1: std::option::Option<&[&str]>));
        switchInt(move _3) -> [0: bb4, 1: bb7, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _43 = &(((*_1) as UnknownArgument).0: std::ffi::OsString);
        _53 = const _;
        _45 = _53 as &[&str] (PointerCoercion(Unsize));
        _52 = <OsString as Deref>::deref(_43) -> [return: bb17, unwind continue];
    }

    bb4: {
        _5 = &(((*_1) as NeedsValue).0: options::parser::Flag);
        _57 = const _;
        _7 = _57 as &[&str] (PointerCoercion(Unsize));
        _12 = &_5;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_12) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = [move _11];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _6 = std::fmt::Arguments::<'_>::new_v1(move _7, move _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb22, unwind continue];
    }

    bb7: {
        _13 = &(((*_1) as NeedsValue).0: options::parser::Flag);
        _14 = &(((((*_1) as NeedsValue).1: std::option::Option<&[&str]>) as Some).0: &[&str]);
        _56 = const _;
        _16 = _56 as &[&str] (PointerCoercion(Unsize));
        _21 = &_13;
        _20 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_21) -> [return: bb8, unwind continue];
    }

    bb8: {
        _58 = deref_copy (*_14);
        _24 = Choices(_58);
        _23 = &_24;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<Choices>(_23) -> [return: bb9, unwind continue];
    }

    bb9: {
        _19 = [move _20, move _22];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _15 = std::fmt::Arguments::<'_>::new_v1(move _16, move _17) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = Formatter::<'_>::write_fmt(_2, move _15) -> [return: bb22, unwind continue];
    }

    bb11: {
        _25 = &(((*_1) as ForbiddenValue).0: options::parser::Flag);
        _55 = const _;
        _27 = _55 as &[&str] (PointerCoercion(Unsize));
        _32 = &_25;
        _31 = core::fmt::rt::Argument::<'_>::new_display::<&Flag>(_32) -> [return: bb12, unwind continue];
    }

    bb12: {
        _30 = [move _31];
        _29 = &_30;
        _28 = _29 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _26 = std::fmt::Arguments::<'_>::new_v1(move _27, move _28) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = Formatter::<'_>::write_fmt(_2, move _26) -> [return: bb22, unwind continue];
    }

    bb14: {
        _33 = &(((*_1) as UnknownShortArgument).0: u8);
        _54 = const _;
        _35 = _54 as &[&str] (PointerCoercion(Unsize));
        _42 = (*_33);
        _41 = move _42 as char (IntToInt);
        _40 = &_41;
        _39 = core::fmt::rt::Argument::<'_>::new_display::<char>(_40) -> [return: bb15, unwind continue];
    }

    bb15: {
        _38 = [move _39];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _34 = std::fmt::Arguments::<'_>::new_v1(move _35, move _36) -> [return: bb16, unwind continue];
    }

    bb16: {
        _0 = Formatter::<'_>::write_fmt(_2, move _34) -> [return: bb22, unwind continue];
    }

    bb17: {
        _51 = OsStr::to_string_lossy(_52) -> [return: bb18, unwind continue];
    }

    bb18: {
        _50 = &_51;
        _49 = core::fmt::rt::Argument::<'_>::new_display::<Cow<'_, str>>(_50) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        _48 = [move _49];
        _47 = &_48;
        _46 = _47 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _44 = std::fmt::Arguments::<'_>::new_v1(move _45, move _46) -> [return: bb20, unwind: bb23];
    }

    bb20: {
        _0 = Formatter::<'_>::write_fmt(_2, move _44) -> [return: bb21, unwind: bb23];
    }

    bb21: {
        drop(_51) -> [return: bb22, unwind continue];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_51) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        resume;
    }
}

promoted[0] in options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Unknown argument --"];
        _0 = &_1;
        return;
    }
}

promoted[1] in options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Unknown argument -"];
        _0 = &_1;
        return;
    }
}

promoted[2] in options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Flag ", const " cannot take a value"];
        _0 = &_1;
        return;
    }
}

promoted[3] in options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "Flag ", const " needs a value (", const ")"];
        _0 = &_1;
        return;
    }
}

promoted[4] in options::parser::<impl at src/options/parser.rs:486:1: 486:33>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Flag ", const " needs a value"];
        _0 = &_1;
        return;
    }
}

fn split_on_equals(_1: &OsStr) -> Option<(&OsStr, &OsStr)> {
    debug input => _1;
    let mut _0: std::option::Option<(&std::ffi::OsStr, &std::ffi::OsStr)>;
    let mut _2: std::option::Option<usize>;
    let mut _3: &mut std::slice::Iter<'_, u8>;
    let mut _4: std::slice::Iter<'_, u8>;
    let _5: &[u8];
    let mut _6: isize;
    let mut _10: (&[u8], &[u8]);
    let _11: &[u8];
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: usize;
    let mut _15: (&std::ffi::OsStr, &std::ffi::OsStr);
    let _16: &std::ffi::OsStr;
    let _17: &std::ffi::OsStr;
    let _18: &[u8];
    let mut _19: std::ops::RangeFrom<usize>;
    scope 1 {
        debug index => _7;
        let _7: usize;
        let _8: &[u8];
        let _9: &[u8];
        scope 2 {
            debug before => _8;
            debug after => _9;
        }
    }

    bb0: {
        _5 = <OsStr as OsStrExt>::as_bytes(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [u8]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &mut _4;
        _2 = <std::slice::Iter<'_, u8> as Iterator>::position::<{closure@src/options/parser.rs:504:59: 504:65}>(move _3, const ZeroSized: {closure@src/options/parser.rs:504:59: 504:65}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [1: bb4, otherwise: bb13];
    }

    bb4: {
        _7 = ((_2 as Some).0: usize);
        _11 = <OsStr as OsStrExt>::as_bytes(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = core::slice::<impl [u8]>::split_at(_11, _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = (_10.0: &[u8]);
        _9 = (_10.1: &[u8]);
        _12 = core::slice::<impl [u8]>::is_empty(_8) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _12) -> [0: bb8, otherwise: bb13];
    }

    bb8: {
        _14 = Len((*_9));
        _13 = Ge(move _14, const 2_usize);
        switchInt(move _13) -> [0: bb13, otherwise: bb9];
    }

    bb9: {
        _16 = <OsStr as OsStrExt>::from_bytes(_8) -> [return: bb10, unwind continue];
    }

    bb10: {
        _19 = RangeFrom::<usize> { start: const 1_usize };
        _18 = <[u8] as std::ops::Index<RangeFrom<usize>>>::index(_9, move _19) -> [return: bb11, unwind continue];
    }

    bb11: {
        _17 = <OsStr as OsStrExt>::from_bytes(_18) -> [return: bb12, unwind continue];
    }

    bb12: {
        _15 = (_16, _17);
        _0 = Option::<(&OsStr, &OsStr)>::Some(move _15);
        goto -> bb14;
    }

    bb13: {
        _0 = Option::<(&OsStr, &OsStr)>::None;
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn split_on_equals::{closure#0}(_1: &mut {closure@src/options/parser.rs:504:59: 504:65}, _2: &u8) -> bool {
    debug elem => _2;
    let mut _0: bool;
    let mut _3: u8;

    bb0: {
        _3 = (*_2);
        _0 = Eq(move _3, const 61_u8);
        return;
    }
}

static LS_COLORS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "LS_COLORS";
        return;
    }
}

static COLUMNS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "COLUMNS";
        return;
    }
}

static vars::TIME_STYLE: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "TIME_STYLE";
        return;
    }
}

static EXA_COLORS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXA_COLORS";
        return;
    }
}

static EXA_STRICT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXA_STRICT";
        return;
    }
}

static EXA_DEBUG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXA_DEBUG";
        return;
    }
}

static EXA_GRID_ROWS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXA_GRID_ROWS";
        return;
    }
}

static EXA_ICON_SPACING: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXA_ICON_SPACING";
        return;
    }
}

fn version::<impl at src/options/version.rs:11:10: 11:19>::eq(_1: &VersionString, _2: &VersionString) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn version::<impl at src/options/version.rs:11:21: 11:26>::fmt(_1: &VersionString, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "VersionString";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn version::<impl at src/options/version.rs:11:34: 11:39>::clone(_1: &VersionString) -> VersionString {
    debug self => _1;
    let mut _0: options::version::VersionString;

    bb0: {
        return;
    }
}

fn version::<impl at src/options/version.rs:15:1: 15:19>::deduce(_1: &MatchedFlags<'_>) -> Option<VersionString> {
    debug matches => _1;
    let mut _0: std::option::Option<options::version::VersionString>;
    let mut _2: bool;
    let mut _3: usize;
    let _4: &options::parser::Arg;

    bb0: {
        _4 = const {alloc21: &Arg};
        _3 = MatchedFlags::<'_>::count(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Gt(move _3, const 0_usize);
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<VersionString>::Some(const VersionString);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<VersionString>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

alloc21 (static: VERSION, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4102<imm>  
    0x20  07 00 00 00 00 00 00 00 01 76 __ __ __ __ __ __  .........v
}

alloc4102 (size: 7, align: 1) {
    76 65 72 73 69 6f 6e                             version
}

fn version::<impl at src/options/version.rs:32:1: 32:36>::fmt(_1: &VersionString, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 0];
    let _7: [core::fmt::rt::Argument<'_>; 0];
    let mut _8: &[&str; 1];

    bb0: {
        _8 = const _;
        _4 = _8 as &[&str] (PointerCoercion(Unsize));
        _7 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = std::fmt::Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

promoted[0] in version::<impl at src/options/version.rs:32:1: 32:36>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "exa - list files on the command-line\nv0.10.1 [+git] (pre-release debug build!)\nhttps://the.exa.website/\n"];
        _0 = &_1;
        return;
    }
}

fn options::<impl at src/options/mod.rs:104:10: 104:15>::fmt(_1: &options::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &fs::dir_action::DirAction;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &fs::filter::FileFilter;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &output::View;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&theme::Options;
    let _16: &theme::Options;

    bb0: {
        _3 = const "Options";
        _4 = const "dir_action";
        _6 = &((*_1).0: fs::dir_action::DirAction);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "filter";
        _9 = &((*_1).1: fs::filter::FileFilter);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "view";
        _12 = &((*_1).2: output::View);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "theme";
        _16 = &((*_1).3: theme::Options);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn options::<impl at src/options/mod.rs:124:1: 124:13>::parse(_1: I, _2: &V) -> OptionsResult<'_> {
    debug args => _1;
    debug vars => _2;
    let mut _0: options::OptionsResult<'_>;
    let _3: options::parser::Strictness;
    let mut _4: std::option::Option<std::ffi::OsString>;
    let mut _5: &str;
    let mut _6: &&str;
    let mut _7: isize;
    let _8: &std::ffi::OsString;
    let _9: &&std::ffi::OsString;
    let mut _10: bool;
    let _11: &std::ffi::OsStr;
    let mut _14: std::result::Result<options::parser::Matches<'_>, options::parser::ParseError>;
    let _15: &options::parser::Args;
    let mut _16: I;
    let mut _17: options::parser::Strictness;
    let mut _18: isize;
    let mut _21: options::error::OptionsError;
    let mut _22: std::option::Option<options::help::HelpString>;
    let _23: &options::parser::MatchedFlags<'_>;
    let mut _24: isize;
    let mut _25: std::option::Option<options::version::VersionString>;
    let _26: &options::parser::MatchedFlags<'_>;
    let mut _27: isize;
    let mut _28: std::result::Result<options::Options, options::error::OptionsError>;
    let _29: &options::parser::MatchedFlags<'_>;
    let mut _30: isize;
    let mut _32: std::vec::Vec<&std::ffi::OsStr>;
    let mut _34: &std::ffi::OsString;
    let mut _35: bool;
    let mut _36: bool;
    scope 1 {
        debug strictness => _3;
        let _12: options::parser::MatchedFlags<'_>;
        let _13: std::vec::Vec<&std::ffi::OsStr>;
        let _19: options::parser::Matches<'_>;
        let _20: options::parser::ParseError;
        scope 3 {
            debug flags => _12;
            debug frees => _13;
            let _31: options::Options;
            let _33: options::error::OptionsError;
            scope 6 {
                debug help => const HelpString;
            }
            scope 7 {
                debug version => const VersionString;
            }
            scope 8 {
                debug options => _31;
            }
            scope 9 {
                debug oe => _33;
            }
        }
        scope 4 {
            debug m => _19;
        }
        scope 5 {
            debug pe => _20;
        }
    }
    scope 2 {
        debug t => _8;
        debug t => _9;
    }

    bb0: {
        _36 = const false;
        _35 = const false;
        _36 = const true;
        _6 = const {alloc64: &&str};
        _5 = (*_6);
        _4 = <V as vars::Vars>::get(_2, move _5) -> [return: bb1, unwind: bb35];
    }

    bb1: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb3, 1: bb4, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = Strictness::UseLastArguments;
        goto -> bb9;
    }

    bb4: {
        _8 = &((_4 as Some).0: std::ffi::OsString);
        _9 = &_8;
        _34 = deref_copy (*_9);
        _11 = <OsString as Deref>::deref(_34) -> [return: bb5, unwind: bb31];
    }

    bb5: {
        _10 = OsStr::is_empty(_11) -> [return: bb6, unwind: bb31];
    }

    bb6: {
        switchInt(move _10) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _3 = Strictness::UseLastArguments;
        goto -> bb9;
    }

    bb8: {
        _3 = Strictness::ComplainAboutRedundantArguments;
        goto -> bb9;
    }

    bb9: {
        drop(_4) -> [return: bb10, unwind: bb35];
    }

    bb10: {
        _15 = const {alloc65: &options::parser::Args};
        _36 = const false;
        _16 = move _1;
        _17 = _3;
        _14 = options::parser::Args::parse::<'_, I>(_15, move _16, move _17) -> [return: bb11, unwind: bb35];
    }

    bb11: {
        _18 = discriminant(_14);
        switchInt(move _18) -> [0: bb13, 1: bb12, otherwise: bb2];
    }

    bb12: {
        _20 = move ((_14 as Err).0: options::parser::ParseError);
        _21 = OptionsError::Parse(move _20);
        _0 = OptionsResult::<'_>::InvalidOptions(move _21);
        goto -> bb27;
    }

    bb13: {
        _19 = move ((_14 as Ok).0: options::parser::Matches<'_>);
        _12 = move (_19.0: options::parser::MatchedFlags<'_>);
        _35 = const true;
        _13 = move (_19.1: std::vec::Vec<&std::ffi::OsStr>);
        _23 = &_12;
        _22 = HelpString::deduce(_23) -> [return: bb14, unwind: bb29];
    }

    bb14: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [1: bb15, otherwise: bb16];
    }

    bb15: {
        _0 = OptionsResult::<'_>::Help(const HelpString);
        goto -> bb25;
    }

    bb16: {
        _26 = &_12;
        _25 = VersionString::deduce(_26) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [1: bb18, otherwise: bb19];
    }

    bb18: {
        _0 = OptionsResult::<'_>::Version(const VersionString);
        goto -> bb25;
    }

    bb19: {
        _29 = &_12;
        _28 = options::Options::deduce::<V>(_29, _2) -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb22, 1: bb21, otherwise: bb2];
    }

    bb21: {
        _33 = move ((_28 as Err).0: options::error::OptionsError);
        _0 = OptionsResult::<'_>::InvalidOptions(move _33);
        goto -> bb23;
    }

    bb22: {
        _31 = move ((_28 as Ok).0: options::Options);
        _35 = const false;
        _32 = move _13;
        _0 = OptionsResult::<'_>::Ok(move _31, move _32);
        goto -> bb23;
    }

    bb23: {
        switchInt(_35) -> [0: bb24, otherwise: bb33];
    }

    bb24: {
        _35 = const false;
        drop(_12) -> [return: bb27, unwind: bb35];
    }

    bb25: {
        drop(_13) -> [return: bb26, unwind: bb30];
    }

    bb26: {
        _35 = const false;
        drop(_12) -> [return: bb27, unwind: bb35];
    }

    bb27: {
        return;
    }

    bb28 (cleanup): {
        drop(_12) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_13) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_12) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_4) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        drop(_13) -> [return: bb24, unwind: bb28];
    }

    bb34 (cleanup): {
        drop(_1) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        switchInt(_36) -> [0: bb32, otherwise: bb34];
    }
}

alloc65 (static: ALL_ARGS, size: 16, align: 8) {
    alloc4367<imm> 2d 00 00 00 00 00 00 00  -.......
}

alloc4367 (size: 360, align: 8) {
    0x000  alloc21<imm> alloc22<imm>  
    0x010  alloc23<imm> alloc24<imm>  
    0x020  alloc25<imm> alloc26<imm>  
    0x030  alloc6<imm> alloc8<imm>  
    0x040  alloc10<imm> alloc27<imm>  
    0x050  alloc28<imm> alloc29<imm>  
    0x060  alloc30<imm> alloc18<imm>  
    0x070  alloc7<imm> alloc9<imm>  
    0x080  alloc15<imm> alloc17<imm>  
    0x090  alloc14<imm> alloc19<imm>  
    0x0a0  alloc20<imm> alloc16<imm>  
    0x0b0  alloc31<imm> alloc32<imm>  
    0x0c0  alloc33<imm> alloc34<imm>  
    0x0d0  alloc35<imm> alloc12<imm>  
    0x0e0  alloc36<imm> alloc37<imm>  
    0x0f0  alloc38<imm> alloc39<imm>  
    0x100  alloc40<imm> alloc41<imm>  
    0x110  alloc42<imm> alloc43<imm>  
    0x120  alloc44<imm> alloc45<imm>  
    0x130  alloc46<imm> alloc47<imm>  
    0x140  alloc48<imm> alloc11<imm>  
    0x150  alloc49<imm> alloc50<imm>  
    0x160  alloc51<imm>                          
}

alloc21 (static: VERSION, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4102<imm>  
    0x20  07 00 00 00 00 00 00 00 01 76 __ __ __ __ __ __  .........v
}

alloc4102 (size: 7, align: 1) {
    76 65 72 73 69 6f 6e                             version
}

alloc22 (static: HELP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4107<imm>  
    0x20  04 00 00 00 00 00 00 00 01 3f __ __ __ __ __ __  .........?
}

alloc4107 (size: 4, align: 1) {
    68 65 6c 70                                      help
}

alloc23 (static: ONE_LINE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4112<imm>  
    0x20  07 00 00 00 00 00 00 00 01 31 __ __ __ __ __ __  .........1
}

alloc4112 (size: 7, align: 1) {
    6f 6e 65 6c 69 6e 65                             oneline
}

alloc24 (static: LONG, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4117<imm>  
    0x20  04 00 00 00 00 00 00 00 01 6c __ __ __ __ __ __  .........l
}

alloc4117 (size: 4, align: 1) {
    6c 6f 6e 67                                      long
}

alloc25 (static: GRID, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4122<imm>  
    0x20  04 00 00 00 00 00 00 00 01 47 __ __ __ __ __ __  .........G
}

alloc4122 (size: 4, align: 1) {
    67 72 69 64                                      grid
}

alloc26 (static: ACROSS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4127<imm>  
    0x20  06 00 00 00 00 00 00 00 01 78 __ __ __ __ __ __  .........x
}

alloc4127 (size: 6, align: 1) {
    61 63 72 6f 73 73                                across
}

alloc6 (static: RECURSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4132<imm>  
    0x20  07 00 00 00 00 00 00 00 01 52 __ __ __ __ __ __  .........R
}

alloc4132 (size: 7, align: 1) {
    72 65 63 75 72 73 65                             recurse
}

alloc8 (static: TREE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4137<imm>  
    0x20  04 00 00 00 00 00 00 00 01 54 __ __ __ __ __ __  .........T
}

alloc4137 (size: 4, align: 1) {
    74 72 65 65                                      tree
}

alloc10 (static: CLASSIFY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4142<imm>  
    0x20  08 00 00 00 00 00 00 00 01 46 __ __ __ __ __ __  .........F
}

alloc4142 (size: 8, align: 1) {
    63 6c 61 73 73 69 66 79                          classify
}

alloc27 (static: COLOR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4154<imm>  ........
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4147 (size: 48, align: 8) {
    0x00  alloc4146<imm> 06 00 00 00 00 00 00 00  ........
    0x10  alloc4148<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4149<imm> 05 00 00 00 00 00 00 00  ........
}

alloc4146 (size: 6, align: 1) {
    61 6c 77 61 79 73                                always
}

alloc4148 (size: 4, align: 1) {
    61 75 74 6f                                      auto
}

alloc4149 (size: 5, align: 1) {
    6e 65 76 65 72                                   never
}

alloc4154 (size: 5, align: 1) {
    63 6f 6c 6f 72                                   color
}

alloc28 (static: COLOUR, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4147<imm>  ........
    0x10  03 00 00 00 00 00 00 00 alloc4160<imm>  ........
    0x20  06 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4160 (size: 6, align: 1) {
    63 6f 6c 6f 75 72                                colour
}

alloc29 (static: COLOR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4165<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4165 (size: 11, align: 1) {
    63 6f 6c 6f 72 2d 73 63 61 6c 65                 color-scale
}

alloc30 (static: COLOUR_SCALE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4170<imm>  
    0x20  0c 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4170 (size: 12, align: 1) {
    63 6f 6c 6f 75 72 2d 73 63 61 6c 65              colour-scale
}

alloc18 (static: ALL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4175<imm>  
    0x20  03 00 00 00 00 00 00 00 01 61 __ __ __ __ __ __  .........a
}

alloc4175 (size: 3, align: 1) {
    61 6c 6c                                         all
}

alloc7 (static: LIST_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4180<imm>  
    0x20  09 00 00 00 00 00 00 00 01 64 __ __ __ __ __ __  .........d
}

alloc4180 (size: 9, align: 1) {
    6c 69 73 74 2d 64 69 72 73                       list-dirs
}

alloc9 (static: LEVEL, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4186<imm>  
    0x20  05 00 00 00 00 00 00 00 01 4c __ __ __ __ __ __  .........L
}

alloc4186 (size: 5, align: 1) {
    6c 65 76 65 6c                                   level
}

alloc15 (static: REVERSE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4191<imm>  
    0x20  07 00 00 00 00 00 00 00 01 72 __ __ __ __ __ __  .........r
}

alloc4191 (size: 7, align: 1) {
    72 65 76 65 72 73 65                             reverse
}

alloc17 (static: SORT, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4196<imm>  ........
    0x10  0c 00 00 00 00 00 00 00 alloc4212<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 73 __ __ __ __ __ __  .........s
}

alloc4196 (size: 192, align: 8) {
    0x00  alloc4195<imm> 04 00 00 00 00 00 00 00  ........
    0x10  alloc4197<imm> 04 00 00 00 00 00 00 00  ........
    0x20  alloc4198<imm> 04 00 00 00 00 00 00 00  ........
    0x30  alloc4199<imm> 09 00 00 00 00 00 00 00  ........
    0x40  alloc4200<imm> 09 00 00 00 00 00 00 00  ........
    0x50  alloc4201<imm> 08 00 00 00 00 00 00 00  ........
    0x60  alloc4202<imm> 07 00 00 00 00 00 00 00  ........
    0x70  alloc4203<imm> 08 00 00 00 00 00 00 00  ........
    0x80  alloc4204<imm> 07 00 00 00 00 00 00 00  ........
    0x90  alloc4205<imm> 05 00 00 00 00 00 00 00  ........
    0xa0  alloc4206<imm> 04 00 00 00 00 00 00 00  ........
    0xb0  alloc4207<imm> 04 00 00 00 00 00 00 00  ........
}

alloc4195 (size: 4, align: 1) {
    6e 61 6d 65                                      name
}

alloc4197 (size: 4, align: 1) {
    4e 61 6d 65                                      Name
}

alloc4198 (size: 4, align: 1) {
    73 69 7a 65                                      size
}

alloc4199 (size: 9, align: 1) {
    65 78 74 65 6e 73 69 6f 6e                       extension
}

alloc4200 (size: 9, align: 1) {
    45 78 74 65 6e 73 69 6f 6e                       Extension
}

alloc4201 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4202 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4203 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4204 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4205 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc4206 (size: 4, align: 1) {
    74 79 70 65                                      type
}

alloc4207 (size: 4, align: 1) {
    6e 6f 6e 65                                      none
}

alloc4212 (size: 4, align: 1) {
    73 6f 72 74                                      sort
}

alloc14 (static: DIRS_FIRST, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4228<imm>  
    0x20  17 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4228 (size: 23, align: 1) {
    0x00  67 72 6f 75 70 2d 64 69 72 65 63 74 6f 72 69 65  group-directorie
    0x10  73 2d 66 69 72 73 74                             s-first
}

alloc19 (static: IGNORE_GLOB, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00  ................
    0x10  __ __ __ __ __ __ __ __ alloc4218<imm>  
    0x20  0b 00 00 00 00 00 00 00 01 49 __ __ __ __ __ __  .........I
}

alloc4218 (size: 11, align: 1) {
    69 67 6e 6f 72 65 2d 67 6c 6f 62                 ignore-glob
}

alloc20 (static: GIT_IGNORE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4223<imm>  
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4223 (size: 10, align: 1) {
    67 69 74 2d 69 67 6e 6f 72 65                    git-ignore
}

alloc16 (static: ONLY_DIRS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4233<imm>  
    0x20  09 00 00 00 00 00 00 00 01 44 __ __ __ __ __ __  .........D
}

alloc4233 (size: 9, align: 1) {
    6f 6e 6c 79 2d 64 69 72 73                       only-dirs
}

alloc31 (static: BINARY, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4238<imm>  
    0x20  06 00 00 00 00 00 00 00 01 62 __ __ __ __ __ __  .........b
}

alloc4238 (size: 6, align: 1) {
    62 69 6e 61 72 79                                binary
}

alloc32 (static: BYTES, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4243<imm>  
    0x20  05 00 00 00 00 00 00 00 01 42 __ __ __ __ __ __  .........B
}

alloc4243 (size: 5, align: 1) {
    62 79 74 65 73                                   bytes
}

alloc33 (static: GROUP, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4248<imm>  
    0x20  05 00 00 00 00 00 00 00 01 67 __ __ __ __ __ __  .........g
}

alloc4248 (size: 5, align: 1) {
    67 72 6f 75 70                                   group
}

alloc34 (static: NUMERIC, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4253<imm>  
    0x20  07 00 00 00 00 00 00 00 01 6e __ __ __ __ __ __  .........n
}

alloc4253 (size: 7, align: 1) {
    6e 75 6d 65 72 69 63                             numeric
}

alloc35 (static: HEADER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4258<imm>  
    0x20  06 00 00 00 00 00 00 00 01 68 __ __ __ __ __ __  .........h
}

alloc4258 (size: 6, align: 1) {
    68 65 61 64 65 72                                header
}

alloc12 (static: ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4263<imm>  
    0x20  05 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4263 (size: 5, align: 1) {
    69 63 6f 6e 73                                   icons
}

alloc36 (static: INODE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4268<imm>  
    0x20  05 00 00 00 00 00 00 00 01 69 __ __ __ __ __ __  .........i
}

alloc4268 (size: 5, align: 1) {
    69 6e 6f 64 65                                   inode
}

alloc37 (static: LINKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4273<imm>  
    0x20  05 00 00 00 00 00 00 00 01 48 __ __ __ __ __ __  .........H
}

alloc4273 (size: 5, align: 1) {
    6c 69 6e 6b 73                                   links
}

alloc38 (static: MODIFIED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4278<imm>  
    0x20  08 00 00 00 00 00 00 00 01 6d __ __ __ __ __ __  .........m
}

alloc4278 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc39 (static: CHANGED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4283<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4283 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc40 (static: BLOCKS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4288<imm>  
    0x20  06 00 00 00 00 00 00 00 01 53 __ __ __ __ __ __  .........S
}

alloc4288 (size: 6, align: 1) {
    62 6c 6f 63 6b 73                                blocks
}

alloc41 (static: TIME, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4293<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4301<imm>  ........
    0x20  04 00 00 00 00 00 00 00 01 74 __ __ __ __ __ __  .........t
}

alloc4293 (size: 64, align: 8) {
    0x00  alloc4292<imm> 08 00 00 00 00 00 00 00  ........
    0x10  alloc4294<imm> 07 00 00 00 00 00 00 00  ........
    0x20  alloc4295<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4296<imm> 07 00 00 00 00 00 00 00  ........
}

alloc4292 (size: 8, align: 1) {
    6d 6f 64 69 66 69 65 64                          modified
}

alloc4294 (size: 7, align: 1) {
    63 68 61 6e 67 65 64                             changed
}

alloc4295 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc4296 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc4301 (size: 4, align: 1) {
    74 69 6d 65                                      time
}

alloc42 (static: ACCESSED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4306<imm>  
    0x20  08 00 00 00 00 00 00 00 01 75 __ __ __ __ __ __  .........u
}

alloc4306 (size: 8, align: 1) {
    61 63 63 65 73 73 65 64                          accessed
}

alloc43 (static: CREATED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4311<imm>  
    0x20  07 00 00 00 00 00 00 00 01 55 __ __ __ __ __ __  .........U
}

alloc4311 (size: 7, align: 1) {
    63 72 65 61 74 65 64                             created
}

alloc44 (static: flags::TIME_STYLE, size: 48, align: 8) {
    0x00  00 00 00 00 00 00 00 00 alloc4316<imm>  ........
    0x10  04 00 00 00 00 00 00 00 alloc4324<imm>  ........
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4316 (size: 64, align: 8) {
    0x00  alloc4315<imm> 07 00 00 00 00 00 00 00  ........
    0x10  alloc4317<imm> 08 00 00 00 00 00 00 00  ........
    0x20  alloc4318<imm> 08 00 00 00 00 00 00 00  ........
    0x30  alloc4319<imm> 03 00 00 00 00 00 00 00  ........
}

alloc4315 (size: 7, align: 1) {
    64 65 66 61 75 6c 74                             default
}

alloc4317 (size: 8, align: 1) {
    6c 6f 6e 67 2d 69 73 6f                          long-iso
}

alloc4318 (size: 8, align: 1) {
    66 75 6c 6c 2d 69 73 6f                          full-iso
}

alloc4319 (size: 3, align: 1) {
    69 73 6f                                         iso
}

alloc4324 (size: 10, align: 1) {
    74 69 6d 65 2d 73 74 79 6c 65                    time-style
}

alloc45 (static: NO_PERMISSIONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4329<imm>  
    0x20  0e 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4329 (size: 14, align: 1) {
    6e 6f 2d 70 65 72 6d 69 73 73 69 6f 6e 73        no-permissions
}

alloc46 (static: NO_FILESIZE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4334<imm>  
    0x20  0b 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4334 (size: 11, align: 1) {
    6e 6f 2d 66 69 6c 65 73 69 7a 65                 no-filesize
}

alloc47 (static: NO_USER, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4339<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4339 (size: 7, align: 1) {
    6e 6f 2d 75 73 65 72                             no-user
}

alloc48 (static: NO_TIME, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4344<imm>  
    0x20  07 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4344 (size: 7, align: 1) {
    6e 6f 2d 74 69 6d 65                             no-time
}

alloc11 (static: NO_ICONS, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4349<imm>  
    0x20  08 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4349 (size: 8, align: 1) {
    6e 6f 2d 69 63 6f 6e 73                          no-icons
}

alloc49 (static: GIT, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4354<imm>  
    0x20  03 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4354 (size: 3, align: 1) {
    67 69 74                                         git
}

alloc50 (static: EXTENDED, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4359<imm>  
    0x20  08 00 00 00 00 00 00 00 01 40 __ __ __ __ __ __  .........@
}

alloc4359 (size: 8, align: 1) {
    65 78 74 65 6e 64 65 64                          extended
}

alloc51 (static: OCTAL, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4364<imm>  
    0x20  11 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4364 (size: 17, align: 1) {
    0x00  6f 63 74 61 6c 2d 70 65 72 6d 69 73 73 69 6f 6e  octal-permission
    0x10  73                                               s
}

alloc64 (static: EXA_STRICT, size: 16, align: 8) {
    alloc1757<imm> 0a 00 00 00 00 00 00 00  ........
}

alloc1757 (size: 10, align: 1) {
    45 58 41 5f 53 54 52 49 43 54                    EXA_STRICT
}

fn options::<impl at src/options/mod.rs:124:1: 124:13>::should_scan_for_git(_1: &options::Options) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &fs::filter::GitIgnore;
    let mut _4: isize;
    let mut _5: isize;
    let mut _6: isize;
    let _7: &output::table::Options;
    let mut _8: &fs::filter::GitIgnore;
    scope 1 {
        debug table => _7;
    }

    bb0: {
        _3 = &(((*_1).1: fs::filter::FileFilter).6: fs::filter::GitIgnore);
        _8 = const _;
        _2 = <GitIgnore as PartialEq>::eq(move _3, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb10;
    }

    bb3: {
        _6 = discriminant((((*_1).2: output::View).0: output::Mode));
        switchInt(move _6) -> [1: bb5, 2: bb6, otherwise: bb4];
    }

    bb4: {
        _0 = const false;
        goto -> bb10;
    }

    bb5: {
        _4 = discriminant(((((((*_1).2: output::View).0: output::Mode) as Details).0: output::details::Options).0: std::option::Option<output::table::Options>));
        switchInt(move _4) -> [1: bb8, otherwise: bb4];
    }

    bb6: {
        _5 = discriminant((((((((*_1).2: output::View).0: output::Mode) as GridDetails).0: output::grid_details::Options).1: output::details::Options).0: std::option::Option<output::table::Options>));
        switchInt(move _5) -> [1: bb9, otherwise: bb4];
    }

    bb7: {
        _0 = (((*_7).3: output::table::Columns).5: bool);
        goto -> bb10;
    }

    bb8: {
        _7 = &((((((((*_1).2: output::View).0: output::Mode) as Details).0: output::details::Options).0: std::option::Option<output::table::Options>) as Some).0: output::table::Options);
        goto -> bb7;
    }

    bb9: {
        _7 = &(((((((((*_1).2: output::View).0: output::Mode) as GridDetails).0: output::grid_details::Options).1: output::details::Options).0: std::option::Option<output::table::Options>) as Some).0: output::table::Options);
        goto -> bb7;
    }

    bb10: {
        return;
    }
}

promoted[0] in options::<impl at src/options/mod.rs:124:1: 124:13>::should_scan_for_git: &GitIgnore = {
    let mut _0: &fs::filter::GitIgnore;
    let mut _1: fs::filter::GitIgnore;

    bb0: {
        _1 = GitIgnore::CheckAndIgnore;
        _0 = &_1;
        return;
    }
}

fn options::<impl at src/options/mod.rs:124:1: 124:13>::deduce(_1: &MatchedFlags<'_>, _2: &V) -> Result<options::Options, OptionsError> {
    debug matches => _1;
    debug vars => _2;
    let mut _0: std::result::Result<options::Options, options::error::OptionsError>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: &std::option::Option<&options::parser::Flag>;
    let _6: std::option::Option<&options::parser::Flag>;
    let mut _7: options::error::OptionsError;
    let _8: std::string::String;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, output::View>;
    let mut _12: std::result::Result<output::View, options::error::OptionsError>;
    let mut _13: isize;
    let _14: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
    let _15: output::View;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::dir_action::DirAction>;
    let mut _17: std::result::Result<fs::dir_action::DirAction, options::error::OptionsError>;
    let mut _18: bool;
    let mut _19: isize;
    let mut _20: isize;
    let mut _24: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, fs::filter::FileFilter>;
    let mut _25: std::result::Result<fs::filter::FileFilter, options::error::OptionsError>;
    let mut _26: isize;
    let mut _29: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, options::error::OptionsError>, theme::Options>;
    let mut _30: std::result::Result<theme::Options, options::error::OptionsError>;
    let mut _31: isize;
    let mut _34: options::Options;
    let mut _35: fs::filter::FileFilter;
    let mut _36: &[&str; 1];
    scope 1 {
        debug res => _8;
    }
    scope 2 {
        debug view => _15;
        let _21: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
        let _22: fs::dir_action::DirAction;
        scope 7 {
            debug dir_action => _22;
            let _23: fs::filter::FileFilter;
            let _27: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
            let _28: fs::filter::FileFilter;
            scope 12 {
                debug filter => _23;
                let _32: std::result::Result<std::convert::Infallible, options::error::OptionsError>;
                let _33: theme::Options;
                scope 17 {
                    debug theme => _33;
                }
                scope 18 {
                    debug residual => _32;
                    scope 19 {
                    }
                }
                scope 20 {
                    debug val => _33;
                    scope 21 {
                    }
                }
            }
            scope 13 {
                debug residual => _27;
                scope 14 {
                }
            }
            scope 15 {
                debug val => _28;
                scope 16 {
                }
            }
        }
        scope 8 {
            debug residual => _21;
            scope 9 {
            }
        }
        scope 10 {
            debug val => _22;
            scope 11 {
            }
        }
    }
    scope 3 {
        debug residual => _14;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _15;
        scope 6 {
        }
    }

    bb0: {
        _3 = const false;
        switchInt(move _3) -> [0: bb7, otherwise: bb1];
    }

    bb1: {
        _6 = MatchedFlags::<'_>::has_where_any::<{closure@src/options/mod.rs:180:39: 180:42}>(_1, const ZeroSized: {closure@src/options/mod.rs:180:39: 180:42}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_6;
        _4 = Option::<&Flag>::is_some(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _36 = const _;
        _10 = _36 as &[&str] (PointerCoercion(Unsize));
        _9 = std::fmt::Arguments::<'_>::new_const(move _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = format(move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = OptionsError::Unsupported(move _8);
        _0 = Result::<options::Options, OptionsError>::Err(move _7);
        goto -> bb26;
    }

    bb7: {
        _12 = view::<impl View>::deduce::<V>(_1, _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = <Result<View, OptionsError> as Try>::branch(move _12) -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb10, 1: bb12, otherwise: bb11];
    }

    bb10: {
        _15 = move ((_11 as Continue).0: output::View);
        _19 = discriminant((_15.0: output::Mode));
        _18 = Eq(_19, const 1_isize);
        _17 = options::dir_action::<impl DirAction>::deduce(_1, move _18) -> [return: bb13, unwind continue];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _14 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<options::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _14) -> [return: bb26, unwind continue];
    }

    bb13: {
        _16 = <Result<DirAction, OptionsError> as Try>::branch(move _17) -> [return: bb14, unwind continue];
    }

    bb14: {
        _20 = discriminant(_16);
        switchInt(move _20) -> [0: bb15, 1: bb16, otherwise: bb11];
    }

    bb15: {
        _22 = ((_16 as Continue).0: fs::dir_action::DirAction);
        _25 = options::filter::<impl FileFilter>::deduce(_1) -> [return: bb17, unwind continue];
    }

    bb16: {
        _21 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<options::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _21) -> [return: bb26, unwind continue];
    }

    bb17: {
        _24 = <Result<FileFilter, OptionsError> as Try>::branch(move _25) -> [return: bb18, unwind continue];
    }

    bb18: {
        _26 = discriminant(_24);
        switchInt(move _26) -> [0: bb19, 1: bb20, otherwise: bb11];
    }

    bb19: {
        _28 = move ((_24 as Continue).0: fs::filter::FileFilter);
        _23 = move _28;
        _30 = options::theme::<impl theme::Options>::deduce::<V>(_1, _2) -> [return: bb21, unwind: bb27];
    }

    bb20: {
        _27 = move ((_24 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<options::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _27) -> [return: bb26, unwind continue];
    }

    bb21: {
        _29 = <Result<theme::Options, OptionsError> as Try>::branch(move _30) -> [return: bb22, unwind: bb27];
    }

    bb22: {
        _31 = discriminant(_29);
        switchInt(move _31) -> [0: bb23, 1: bb24, otherwise: bb11];
    }

    bb23: {
        _33 = move ((_29 as Continue).0: theme::Options);
        _35 = move _23;
        _34 = options::Options { dir_action: _22, filter: move _35, view: move _15, theme: move _33 };
        _0 = Result::<options::Options, OptionsError>::Ok(move _34);
        goto -> bb26;
    }

    bb24: {
        _32 = move ((_29 as Break).0: std::result::Result<std::convert::Infallible, options::error::OptionsError>);
        _0 = <Result<options::Options, OptionsError> as FromResidual<Result<Infallible, OptionsError>>>::from_residual(move _32) -> [return: bb25, unwind: bb27];
    }

    bb25: {
        drop(_23) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_23) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }
}

promoted[0] in options::<impl at src/options/mod.rs:124:1: 124:13>::deduce: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Options --git and --git-ignore can't be used because `git` feature was disabled in this build of exa"];
        _0 = &_1;
        return;
    }
}

fn options::<impl at src/options/mod.rs:124:1: 124:13>::deduce::{closure#0}(_1: &{closure@src/options/mod.rs:180:39: 180:42}, _2: &Flag) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &options::parser::Arg;
    let _5: &options::parser::Arg;

    bb0: {
        _4 = const {alloc49: &Arg};
        _3 = Flag::matches(_2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const {alloc20: &Arg};
        _0 = Flag::matches(_2, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

alloc49 (static: GIT, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4354<imm>  
    0x20  03 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4354 (size: 3, align: 1) {
    67 69 74                                         git
}

alloc20 (static: GIT_IGNORE, size: 48, align: 8) {
    0x00  01 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ alloc4223<imm>  
    0x20  0a 00 00 00 00 00 00 00 00 __ __ __ __ __ __ __  .........
}

alloc4223 (size: 10, align: 1) {
    67 69 74 2d 69 67 6e 6f 72 65                    git-ignore
}

fn options::<impl at src/options/mod.rs:197:10: 197:15>::fmt(_1: &OptionsResult<'_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &options::Options;
    let _5: &std::vec::Vec<&std::ffi::OsStr>;
    let _6: &str;
    let mut _7: &dyn std::fmt::Debug;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::vec::Vec<&std::ffi::OsStr>;
    let _10: &options::error::OptionsError;
    let _11: &str;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &&options::error::OptionsError;
    let _14: &options::help::HelpString;
    let _15: &str;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&options::help::HelpString;
    let _18: &options::version::VersionString;
    let _19: &str;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &&options::version::VersionString;
    scope 1 {
        debug __self_0 => _4;
        debug __self_1 => _5;
    }
    scope 2 {
        debug __self_0 => _10;
    }
    scope 3 {
        debug __self_0 => _14;
    }
    scope 4 {
        debug __self_0 => _18;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _18 = &(((*_1) as Version).0: options::version::VersionString);
        _19 = const "Version";
        _21 = &_18;
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _19, move _20) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Ok).0: options::Options);
        _5 = &(((*_1) as Ok).1: std::vec::Vec<&std::ffi::OsStr>);
        _6 = const "Ok";
        _7 = _4 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &_5;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field2_finish(_2, _6, move _7, move _8) -> [return: bb6, unwind continue];
    }

    bb4: {
        _10 = &(((*_1) as InvalidOptions).0: options::error::OptionsError);
        _11 = const "InvalidOptions";
        _13 = &_10;
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _11, move _12) -> [return: bb6, unwind continue];
    }

    bb5: {
        _14 = &(((*_1) as Help).0: options::help::HelpString);
        _15 = const "Help";
        _17 = &_14;
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _15, move _16) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn details::<impl at src/output/details.rs:94:10: 94:19>::eq(_1: &details::Options, _2: &details::Options) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<output::table::Options>;
    let mut _5: &std::option::Option<output::table::Options>;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;

    bb0: {
        _4 = &((*_1).0: std::option::Option<output::table::Options>);
        _5 = &((*_2).0: std::option::Option<output::table::Options>);
        _3 = <Option<table::Options> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _7 = ((*_1).1: bool);
        _8 = ((*_2).1: bool);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _9 = ((*_1).2: bool);
        _10 = ((*_2).2: bool);
        _0 = Eq(move _9, move _10);
        goto -> bb5;
    }

    bb4: {
        _0 = const false;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn details::<impl at src/output/details.rs:94:21: 94:26>::fmt(_1: &details::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<output::table::Options>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&bool;
    let _13: &bool;

    bb0: {
        _3 = const "Options";
        _4 = const "table";
        _6 = &((*_1).0: std::option::Option<output::table::Options>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "header";
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "xattr";
        _13 = &((*_1).2: bool);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn details::<impl at src/output/details.rs:141:1: 141:37>::as_ref(_1: &Egg<'_>) -> &file::File<'_> {
    debug self => _1;
    let mut _0: &fs::file::File<'_>;

    bb0: {
        _0 = deref_copy ((*_1).4: &fs::file::File<'_>);
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render(_1: details::Render<'_>, _2: &mut W) -> Result<(), std::io::Error> {
    debug self => _1;
    debug w => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: scoped_threadpool::Pool;
    let mut _4: u32;
    let mut _5: usize;
    let mut _7: isize;
    let mut _9: (std::option::Option<&fs::feature::git::GitCache>, std::option::Option<&fs::dir::Dir>);
    let mut _10: std::option::Option<&fs::feature::git::GitCache>;
    let mut _11: std::option::Option<&fs::dir::Dir>;
    let mut _12: isize;
    let mut _13: isize;
    let mut _16: bool;
    let _17: &std::path::Path;
    let _18: &std::path::PathBuf;
    let mut _19: std::option::Option<&fs::feature::git::GitCache>;
    let mut _21: bool;
    let mut _22: &mut std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _23: std::slice::Iter<'_, fs::file::File<'_>>;
    let _24: &[fs::file::File<'_>];
    let mut _25: &std::vec::Vec<fs::file::File<'_>>;
    let mut _26: {closure@src/output/details.rs:156:67: 156:70};
    let mut _27: &&fs::feature::git::GitCache;
    let mut _28: std::option::Option<&fs::feature::git::GitCache>;
    let mut _30: std::option::Option<&fs::feature::git::GitCache>;
    let _31: &&theme::Theme;
    let mut _32: bool;
    let mut _34: &output::table::Table<'_>;
    let _35: ();
    let mut _36: &mut output::table::Table<'_>;
    let _37: &output::table::Row;
    let _38: ();
    let mut _39: &mut std::vec::Vec<output::details::Row>;
    let mut _40: output::details::Row;
    let mut _41: &output::details::Render<'_>;
    let mut _42: output::table::Row;
    let mut _44: output::table::Table<'_>;
    let _45: ();
    let mut _46: &output::details::Render<'_>;
    let mut _47: &mut scoped_threadpool::Pool;
    let mut _48: &mut std::option::Option<output::table::Table<'_>>;
    let mut _49: &mut std::vec::Vec<output::details::Row>;
    let _50: &[fs::file::File<'_>];
    let _51: &std::vec::Vec<fs::file::File<'_>>;
    let mut _52: output::tree::TreeDepth;
    let mut _53: output::details::TableIter<'_>;
    let mut _54: output::details::TableIter<'_>;
    let mut _55: &output::details::Render<'_>;
    let mut _56: output::table::Table<'_>;
    let mut _57: std::option::Option<output::table::Table<'_>>;
    let mut _58: std::vec::Vec<output::details::Row>;
    let mut _60: std::option::Option<output::cell::TextCell>;
    let mut _61: &mut output::details::TableIter<'_>;
    let mut _62: isize;
    let mut _64: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _65: std::result::Result<(), std::io::Error>;
    let mut _66: std::fmt::Arguments<'_>;
    let mut _67: &[&str];
    let mut _68: &[core::fmt::rt::Argument<'_>];
    let _69: &[core::fmt::rt::Argument<'_>; 1];
    let _70: [core::fmt::rt::Argument<'_>; 1];
    let mut _71: core::fmt::rt::Argument<'_>;
    let _72: &ansi_term::ANSIGenericStrings<'_, str>;
    let _73: ansi_term::ANSIGenericStrings<'_, str>;
    let _74: &output::cell::TextCellContents;
    let mut _75: &output::cell::TextCell;
    let mut _76: isize;
    let _78: ();
    let mut _79: &output::details::Render<'_>;
    let mut _80: &mut scoped_threadpool::Pool;
    let mut _81: &mut std::option::Option<output::table::Table<'_>>;
    let mut _82: std::option::Option<output::table::Table<'_>>;
    let mut _83: &mut std::vec::Vec<output::details::Row>;
    let _84: &[fs::file::File<'_>];
    let _85: &std::vec::Vec<fs::file::File<'_>>;
    let mut _86: output::tree::TreeDepth;
    let mut _87: output::details::Iter;
    let mut _88: output::details::Iter;
    let mut _89: &output::details::Render<'_>;
    let mut _90: std::vec::Vec<output::details::Row>;
    let mut _92: std::option::Option<output::cell::TextCell>;
    let mut _93: &mut output::details::Iter;
    let mut _94: isize;
    let mut _96: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _97: std::result::Result<(), std::io::Error>;
    let mut _98: std::fmt::Arguments<'_>;
    let mut _99: &[&str];
    let mut _100: &[core::fmt::rt::Argument<'_>];
    let _101: &[core::fmt::rt::Argument<'_>; 1];
    let _102: [core::fmt::rt::Argument<'_>; 1];
    let mut _103: core::fmt::rt::Argument<'_>;
    let _104: &ansi_term::ANSIGenericStrings<'_, str>;
    let _105: ansi_term::ANSIGenericStrings<'_, str>;
    let _106: &output::cell::TextCellContents;
    let mut _107: &output::cell::TextCell;
    let mut _108: isize;
    let mut _112: &output::details::Options;
    let mut _113: &output::details::Options;
    let mut _114: &theme::Theme;
    let mut _115: &output::details::Options;
    let mut _116: bool;
    let mut _117: bool;
    let mut _118: bool;
    let mut _119: bool;
    scope 1 {
        debug pool => _3;
        let mut _6: std::vec::Vec<output::details::Row>;
        scope 2 {
            debug rows => _6;
            let mut _91: output::details::Iter;
            scope 3 {
                debug table => _8;
                let _8: &output::table::Options;
                let _14: &fs::feature::git::GitCache;
                let _15: &fs::dir::Dir;
                let _20: &fs::feature::git::GitCache;
                let mut _29: output::table::Table<'_>;
                scope 4 {
                    debug g => _14;
                    debug d => _15;
                }
                scope 5 {
                    debug g => _20;
                }
                scope 6 {
                    debug table => _29;
                    let _33: output::table::Row;
                    let mut _43: std::option::Option<output::table::Table<'_>>;
                    scope 7 {
                        debug header => _33;
                    }
                    scope 8 {
                        debug table => _43;
                        let mut _59: output::details::TableIter<'_>;
                        scope 9 {
                            debug iter => _59;
                            let _63: output::cell::TextCell;
                            scope 10 {
                                debug row => _63;
                                let _77: std::result::Result<std::convert::Infallible, std::io::Error>;
                                let mut _111: &[&str; 2];
                                scope 11 {
                                    debug residual => _77;
                                    scope 12 {
                                    }
                                }
                                scope 13 {
                                    debug val => const ();
                                    scope 14 {
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 15 {
                debug iter => _91;
                let _95: output::cell::TextCell;
                scope 16 {
                    debug row => _95;
                    let _109: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let mut _110: &[&str; 2];
                    scope 17 {
                        debug residual => _109;
                        scope 18 {
                        }
                    }
                    scope 19 {
                        debug val => const ();
                        scope 20 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _119 = const false;
        _118 = const false;
        _117 = const false;
        _116 = const false;
        _5 = num_cpus::get() -> [return: bb1, unwind: bb78];
    }

    bb1: {
        _4 = move _5 as u32 (IntToInt);
        _3 = Pool::new(move _4) -> [return: bb2, unwind: bb78];
    }

    bb2: {
        _6 = Vec::<details::Row>::new() -> [return: bb3, unwind: bb77];
    }

    bb3: {
        _119 = const true;
        _112 = deref_copy (_1.4: &output::details::Options);
        _7 = discriminant(((*_112).0: std::option::Option<output::table::Options>));
        switchInt(move _7) -> [1: bb4, otherwise: bb44];
    }

    bb4: {
        _113 = deref_copy (_1.4: &output::details::Options);
        _8 = &((((*_113).0: std::option::Option<output::table::Options>) as Some).0: output::table::Options);
        _10 = (_1.8: std::option::Option<&fs::feature::git::GitCache>);
        _11 = (_1.0: std::option::Option<&fs::dir::Dir>);
        _9 = (move _10, move _11);
        _13 = discriminant((_9.0: std::option::Option<&fs::feature::git::GitCache>));
        switchInt(move _13) -> [0: bb16, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = discriminant((_9.1: std::option::Option<&fs::dir::Dir>));
        switchInt(move _12) -> [0: bb11, 1: bb7, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = (((_9.0: std::option::Option<&fs::feature::git::GitCache>) as Some).0: &fs::feature::git::GitCache);
        _15 = (((_9.1: std::option::Option<&fs::dir::Dir>) as Some).0: &fs::dir::Dir);
        _18 = &((*_15).1: std::path::PathBuf);
        _17 = <PathBuf as Deref>::deref(_18) -> [return: bb8, unwind: bb87];
    }

    bb8: {
        _16 = GitCache::has_anything_for(_14, _17) -> [return: bb9, unwind: bb87];
    }

    bb9: {
        switchInt(move _16) -> [0: bb10, otherwise: bb16];
    }

    bb10: {
        _19 = Option::<&GitCache>::None;
        (_1.8: std::option::Option<&fs::feature::git::GitCache>) = move _19;
        goto -> bb16;
    }

    bb11: {
        _20 = (((_9.0: std::option::Option<&fs::feature::git::GitCache>) as Some).0: &fs::feature::git::GitCache);
        _25 = &(_1.1: std::vec::Vec<fs::file::File<'_>>);
        _24 = <Vec<file::File<'_>> as Deref>::deref(move _25) -> [return: bb12, unwind: bb87];
    }

    bb12: {
        _23 = core::slice::<impl [file::File<'_>]>::iter(_24) -> [return: bb13, unwind: bb87];
    }

    bb13: {
        _22 = &mut _23;
        _27 = &_20;
        _26 = {closure@src/output/details.rs:156:67: 156:70} { g: move _27 };
        _21 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::any::<{closure@src/output/details.rs:156:67: 156:70}>(move _22, move _26) -> [return: bb14, unwind: bb87];
    }

    bb14: {
        switchInt(move _21) -> [0: bb15, otherwise: bb16];
    }

    bb15: {
        _28 = Option::<&GitCache>::None;
        (_1.8: std::option::Option<&fs::feature::git::GitCache>) = move _28;
        goto -> bb16;
    }

    bb16: {
        _30 = (_1.8: std::option::Option<&fs::feature::git::GitCache>);
        _31 = &(_1.2: &theme::Theme);
        _114 = deref_copy (*_31);
        _29 = Table::<'_>::new(_8, move _30, _114) -> [return: bb17, unwind: bb87];
    }

    bb17: {
        _118 = const true;
        _115 = deref_copy (_1.4: &output::details::Options);
        _32 = ((*_115).1: bool);
        switchInt(move _32) -> [0: bb23, otherwise: bb18];
    }

    bb18: {
        _34 = &_29;
        _33 = Table::<'_>::header_row(move _34) -> [return: bb19, unwind: bb85];
    }

    bb19: {
        _117 = const true;
        _36 = &mut _29;
        _37 = &_33;
        _35 = Table::<'_>::add_widths(move _36, _37) -> [return: bb20, unwind: bb83];
    }

    bb20: {
        _39 = &mut _6;
        _41 = &_1;
        _117 = const false;
        _42 = move _33;
        _40 = details::Render::<'_>::render_header(move _41, move _42) -> [return: bb21, unwind: bb83];
    }

    bb21: {
        _38 = Vec::<details::Row>::push(move _39, move _40) -> [return: bb22, unwind: bb83];
    }

    bb22: {
        _117 = const false;
        goto -> bb23;
    }

    bb23: {
        _118 = const false;
        _44 = move _29;
        _116 = const true;
        _43 = Option::<Table<'_>>::Some(move _44);
        _46 = &_1;
        _47 = &mut _3;
        _48 = &mut _43;
        _49 = &mut _6;
        _51 = &(_1.1: std::vec::Vec<fs::file::File<'_>>);
        _50 = <Vec<file::File<'_>> as Deref>::deref(_51) -> [return: bb24, unwind: bb81];
    }

    bb24: {
        _52 = TreeDepth::root() -> [return: bb25, unwind: bb81];
    }

    bb25: {
        _45 = details::Render::<'_>::add_files_to_table(move _46, _47, _48, _49, _50, move _52) -> [return: bb26, unwind: bb81];
    }

    bb26: {
        _55 = &_1;
        _116 = const false;
        _57 = move _43;
        _56 = Option::<Table<'_>>::unwrap(move _57) -> [return: bb27, unwind: bb81];
    }

    bb27: {
        _119 = const false;
        _58 = move _6;
        _54 = details::Render::<'_>::iterate_with_table(move _55, move _56, move _58) -> [return: bb28, unwind: bb81];
    }

    bb28: {
        _53 = <TableIter<'_> as IntoIterator>::into_iter(move _54) -> [return: bb29, unwind: bb81];
    }

    bb29: {
        _59 = move _53;
        goto -> bb30;
    }

    bb30: {
        _61 = &mut _59;
        _60 = <TableIter<'_> as Iterator>::next(_61) -> [return: bb31, unwind: bb76];
    }

    bb31: {
        _62 = discriminant(_60);
        switchInt(move _62) -> [0: bb33, 1: bb32, otherwise: bb6];
    }

    bb32: {
        _63 = move ((_60 as Some).0: output::cell::TextCell);
        _111 = const _;
        _67 = _111 as &[&str] (PointerCoercion(Unsize));
        _75 = &_63;
        _74 = <TextCell as Deref>::deref(move _75) -> [return: bb34, unwind: bb75];
    }

    bb33: {
        drop(_59) -> [return: bb43, unwind: bb81];
    }

    bb34: {
        _73 = TextCellContents::strings(_74) -> [return: bb35, unwind: bb75];
    }

    bb35: {
        _72 = &_73;
        _71 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericStrings<'_, str>>(_72) -> [return: bb36, unwind: bb75];
    }

    bb36: {
        _70 = [move _71];
        _69 = &_70;
        _68 = _69 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _66 = std::fmt::Arguments::<'_>::new_v1(move _67, move _68) -> [return: bb37, unwind: bb75];
    }

    bb37: {
        _65 = <W as std::io::Write>::write_fmt(_2, move _66) -> [return: bb38, unwind: bb75];
    }

    bb38: {
        _64 = <Result<(), std::io::Error> as Try>::branch(move _65) -> [return: bb39, unwind: bb75];
    }

    bb39: {
        _76 = discriminant(_64);
        switchInt(move _76) -> [0: bb40, 1: bb41, otherwise: bb6];
    }

    bb40: {
        drop(_63) -> [return: bb30, unwind: bb76];
    }

    bb41: {
        _77 = move ((_64 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _77) -> [return: bb42, unwind: bb75];
    }

    bb42: {
        drop(_63) -> [return: bb67, unwind: bb76];
    }

    bb43: {
        _116 = const false;
        _118 = const false;
        goto -> bb64;
    }

    bb44: {
        _79 = &_1;
        _80 = &mut _3;
        _82 = Option::<Table<'_>>::None;
        _81 = &mut _82;
        _83 = &mut _6;
        _85 = &(_1.1: std::vec::Vec<fs::file::File<'_>>);
        _84 = <Vec<file::File<'_>> as Deref>::deref(_85) -> [return: bb45, unwind: bb74];
    }

    bb45: {
        _86 = TreeDepth::root() -> [return: bb46, unwind: bb74];
    }

    bb46: {
        _78 = details::Render::<'_>::add_files_to_table(move _79, _80, _81, _83, _84, move _86) -> [return: bb47, unwind: bb74];
    }

    bb47: {
        drop(_82) -> [return: bb48, unwind: bb87];
    }

    bb48: {
        _89 = &_1;
        _119 = const false;
        _90 = move _6;
        _88 = details::Render::<'_>::iterate(move _89, move _90) -> [return: bb49, unwind: bb87];
    }

    bb49: {
        _87 = <details::Iter as IntoIterator>::into_iter(move _88) -> [return: bb50, unwind: bb87];
    }

    bb50: {
        _91 = move _87;
        goto -> bb51;
    }

    bb51: {
        _93 = &mut _91;
        _92 = <details::Iter as Iterator>::next(_93) -> [return: bb52, unwind: bb73];
    }

    bb52: {
        _94 = discriminant(_92);
        switchInt(move _94) -> [0: bb54, 1: bb53, otherwise: bb6];
    }

    bb53: {
        _95 = move ((_92 as Some).0: output::cell::TextCell);
        _110 = const _;
        _99 = _110 as &[&str] (PointerCoercion(Unsize));
        _107 = &_95;
        _106 = <TextCell as Deref>::deref(move _107) -> [return: bb55, unwind: bb72];
    }

    bb54: {
        drop(_91) -> [return: bb64, unwind: bb87];
    }

    bb55: {
        _105 = TextCellContents::strings(_106) -> [return: bb56, unwind: bb72];
    }

    bb56: {
        _104 = &_105;
        _103 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericStrings<'_, str>>(_104) -> [return: bb57, unwind: bb72];
    }

    bb57: {
        _102 = [move _103];
        _101 = &_102;
        _100 = _101 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _98 = std::fmt::Arguments::<'_>::new_v1(move _99, move _100) -> [return: bb58, unwind: bb72];
    }

    bb58: {
        _97 = <W as std::io::Write>::write_fmt(_2, move _98) -> [return: bb59, unwind: bb72];
    }

    bb59: {
        _96 = <Result<(), std::io::Error> as Try>::branch(move _97) -> [return: bb60, unwind: bb72];
    }

    bb60: {
        _108 = discriminant(_96);
        switchInt(move _108) -> [0: bb61, 1: bb62, otherwise: bb6];
    }

    bb61: {
        drop(_95) -> [return: bb51, unwind: bb73];
    }

    bb62: {
        _109 = move ((_96 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _109) -> [return: bb63, unwind: bb72];
    }

    bb63: {
        drop(_95) -> [return: bb66, unwind: bb73];
    }

    bb64: {
        _0 = Result::<(), std::io::Error>::Ok(const ());
        _119 = const false;
        drop(_3) -> [return: bb65, unwind: bb78];
    }

    bb65: {
        drop(_1) -> [return: bb71, unwind continue];
    }

    bb66: {
        drop(_91) -> [return: bb69, unwind: bb87];
    }

    bb67: {
        drop(_59) -> [return: bb68, unwind: bb81];
    }

    bb68: {
        _116 = const false;
        _118 = const false;
        goto -> bb69;
    }

    bb69: {
        _119 = const false;
        drop(_3) -> [return: bb70, unwind: bb78];
    }

    bb70: {
        drop(_1) -> [return: bb71, unwind continue];
    }

    bb71: {
        return;
    }

    bb72 (cleanup): {
        drop(_95) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        drop(_91) -> [return: bb87, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        drop(_82) -> [return: bb87, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        drop(_63) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        drop(_59) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        drop(_3) -> [return: bb78, unwind terminate(cleanup)];
    }

    bb78 (cleanup): {
        drop(_1) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        resume;
    }

    bb80 (cleanup): {
        drop(_43) -> [return: bb85, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        switchInt(_116) -> [0: bb85, otherwise: bb80];
    }

    bb82 (cleanup): {
        drop(_33) -> [return: bb85, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        switchInt(_117) -> [0: bb85, otherwise: bb82];
    }

    bb84 (cleanup): {
        drop(_29) -> [return: bb87, unwind terminate(cleanup)];
    }

    bb85 (cleanup): {
        switchInt(_118) -> [0: bb87, otherwise: bb84];
    }

    bb86 (cleanup): {
        drop(_6) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb87 (cleanup): {
        switchInt(_119) -> [0: bb77, otherwise: bb86];
    }
}

promoted[0] in details::<impl at src/output/details.rs:148:1: 148:20>::render: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in details::<impl at src/output/details.rs:148:1: 148:20>::render: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render::{closure#0}(_1: &mut {closure@src/output/details.rs:156:67: 156:70}, _2: &file::File<'_>) -> bool {
    debug f => _2;
    debug g => (*((*_1).0: &&fs::feature::git::GitCache));
    let mut _0: bool;
    let _3: &std::path::Path;
    let _4: &std::path::PathBuf;
    let mut _5: &&fs::feature::git::GitCache;
    let mut _6: &fs::feature::git::GitCache;

    bb0: {
        _5 = deref_copy ((*_1).0: &&fs::feature::git::GitCache);
        _6 = deref_copy (*_5);
        _4 = &((*_2).2: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = GitCache::has_anything_for(_6, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table(_1: &details::Render<'_>, _2: &mut Pool, _3: &mut Option<Table<'_>>, _4: &mut Vec<details::Row>, _5: &[file::File<'_>], _6: TreeDepth) -> () {
    debug self => _1;
    debug pool => _2;
    debug table => _3;
    debug rows => _4;
    debug src => _5;
    debug depth => _6;
    let mut _0: ();
    let mut _7: std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let mut _8: std::iter::Map<std::ops::Range<usize>, {closure@src/output/details.rs:195:48: 195:51}>;
    let mut _9: std::ops::Range<usize>;
    let mut _10: usize;
    let mut _11: &[fs::file::File<'_>];
    let _12: ();
    let mut _13: {closure@src/output/details.rs:197:21: 197:29};
    let mut _14: &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let mut _15: &&mut std::option::Option<output::table::Table<'_>>;
    let mut _16: &&[fs::file::File<'_>];
    let mut _17: &&output::details::Render<'_>;
    let mut _18: &output::tree::TreeDepth;
    let mut _20: std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let _21: ();
    let mut _22: &mut std::vec::Vec<output::details::Egg<'_>>;
    let mut _23: output::tree::Iter<std::vec::IntoIter<output::details::Egg<'_>>>;
    let mut _24: output::tree::Iter<std::vec::IntoIter<output::details::Egg<'_>>>;
    let mut _25: output::tree::TreeDepth;
    let mut _26: std::vec::IntoIter<output::details::Egg<'_>>;
    let mut _27: std::vec::Vec<output::details::Egg<'_>>;
    let mut _29: std::option::Option<(output::tree::TreeParams, output::details::Egg<'_>)>;
    let mut _30: &mut output::tree::Iter<std::vec::IntoIter<output::details::Egg<'_>>>;
    let mut _31: isize;
    let mut _36: (std::option::Option<&mut output::table::Table<'_>>, std::option::Option<&output::table::Row>);
    let mut _37: std::option::Option<&mut output::table::Table<'_>>;
    let mut _38: &mut std::option::Option<output::table::Table<'_>>;
    let mut _39: std::option::Option<&output::table::Row>;
    let mut _40: &std::option::Option<output::table::Row>;
    let mut _41: isize;
    let mut _42: isize;
    let _45: ();
    let mut _47: output::cell::TextCellContents;
    let mut _48: &output::file_name::FileName<'_, '_, theme::Theme>;
    let _49: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _50: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _51: output::file_name::Options;
    let mut _53: std::option::Option<output::table::Row>;
    let mut _54: output::cell::TextCell;
    let _55: ();
    let mut _56: isize;
    let mut _58: fs::dir::Files<'_, '_>;
    let mut _59: fs::dir::Files<'_, '_>;
    let mut _60: fs::dir::DotFilter;
    let mut _61: std::option::Option<&fs::feature::git::GitCache>;
    let mut _62: bool;
    let mut _64: std::option::Option<std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>>;
    let mut _65: &mut fs::dir::Files<'_, '_>;
    let mut _66: isize;
    let mut _68: isize;
    let _70: ();
    let mut _71: &mut std::vec::Vec<fs::file::File<'_>>;
    let _74: ();
    let mut _75: &mut std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _76: (std::io::Error, std::option::Option<std::path::PathBuf>);
    let mut _77: std::option::Option<std::path::PathBuf>;
    let _78: ();
    let mut _79: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _80: bool;
    let mut _81: &std::vec::Vec<fs::file::File<'_>>;
    let mut _82: std::vec::IntoIter<fs::feature::xattr::Attribute>;
    let mut _83: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _85: std::option::Option<fs::feature::xattr::Attribute>;
    let mut _86: &mut std::vec::IntoIter<fs::feature::xattr::Attribute>;
    let mut _87: isize;
    let _89: ();
    let mut _90: output::details::Row;
    let mut _91: &output::details::Render<'_>;
    let _92: &fs::feature::xattr::Attribute;
    let mut _93: output::tree::TreeParams;
    let mut _94: output::tree::TreeDepth;
    let mut _95: output::tree::TreeDepth;
    let mut _96: std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _97: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _99: std::option::Option<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _100: &mut std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _101: isize;
    let _104: ();
    let mut _105: output::details::Row;
    let mut _106: &output::details::Render<'_>;
    let _107: &std::io::Error;
    let mut _108: output::tree::TreeParams;
    let mut _109: output::tree::TreeDepth;
    let mut _110: output::tree::TreeDepth;
    let mut _111: std::option::Option<std::path::PathBuf>;
    let _112: ();
    let mut _113: &output::details::Render<'_>;
    let mut _114: &mut std::option::Option<output::table::Table<'_>>;
    let _115: &[fs::file::File<'_>];
    let _116: &std::vec::Vec<fs::file::File<'_>>;
    let mut _117: output::tree::TreeDepth;
    let mut _118: output::tree::TreeDepth;
    let mut _120: &std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _121: std::iter::Enumerate<std::vec::IntoIter<fs::feature::xattr::Attribute>>;
    let mut _122: std::iter::Enumerate<std::vec::IntoIter<fs::feature::xattr::Attribute>>;
    let mut _123: std::vec::IntoIter<fs::feature::xattr::Attribute>;
    let mut _124: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _126: std::option::Option<(usize, fs::feature::xattr::Attribute)>;
    let mut _127: &mut std::iter::Enumerate<std::vec::IntoIter<fs::feature::xattr::Attribute>>;
    let mut _128: isize;
    let mut _132: output::tree::TreeDepth;
    let mut _133: output::tree::TreeDepth;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: &std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _137: usize;
    let mut _138: (usize, bool);
    let mut _140: &output::details::Render<'_>;
    let _141: &fs::feature::xattr::Attribute;
    let _142: ();
    let mut _144: &std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _145: std::iter::Enumerate<std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>>;
    let mut _146: std::iter::Enumerate<std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>>;
    let mut _147: std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _148: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _150: std::option::Option<(usize, (std::io::Error, std::option::Option<std::path::PathBuf>))>;
    let mut _151: &mut std::iter::Enumerate<std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>>;
    let mut _152: isize;
    let mut _157: output::tree::TreeDepth;
    let mut _158: output::tree::TreeDepth;
    let mut _159: bool;
    let mut _160: usize;
    let mut _161: (usize, bool);
    let mut _163: &output::details::Render<'_>;
    let _164: &std::io::Error;
    let mut _165: std::option::Option<std::path::PathBuf>;
    let _166: ();
    let mut _167: &fs::filter::FileFilter;
    let mut _168: &mut output::table::Table<'_>;
    let mut _169: &output::file_name::Options;
    let mut _170: &fs::file::File<'_>;
    let mut _171: &theme::Theme;
    let mut _172: &fs::filter::FileFilter;
    let mut _173: &fs::filter::FileFilter;
    let mut _174: bool;
    let mut _175: bool;
    let mut _176: bool;
    let mut _177: bool;
    let mut _178: bool;
    let mut _179: bool;
    let mut _180: bool;
    let mut _181: bool;
    let mut _182: bool;
    scope 1 {
        debug file_eggs => _7;
        let mut _19: std::vec::Vec<output::details::Egg<'_>>;
        scope 2 {
            debug file_eggs => _19;
            let mut _28: output::tree::Iter<std::vec::IntoIter<output::details::Egg<'_>>>;
            scope 4 {
                debug iter => _28;
                let _32: output::tree::TreeParams;
                let _33: output::details::Egg<'_>;
                scope 5 {
                    debug tree_params => _32;
                    debug egg => _33;
                    let mut _34: std::vec::Vec<fs::file::File<'_>>;
                    scope 6 {
                        debug files => _34;
                        let mut _35: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
                        scope 7 {
                            debug errors => _35;
                            let _46: output::cell::TextCell;
                            scope 8 {
                                debug t => _43;
                                debug row => _44;
                                let _43: &mut &mut output::table::Table<'_>;
                                let _44: &output::table::Row;
                            }
                            scope 9 {
                                debug file_name => _46;
                                let _52: output::details::Row;
                                scope 10 {
                                    debug row => _52;
                                    let _119: usize;
                                    scope 11 {
                                        debug dir => _57;
                                        let _57: &fs::dir::Dir;
                                        let mut _63: fs::dir::Files<'_, '_>;
                                        let mut _84: std::vec::IntoIter<fs::feature::xattr::Attribute>;
                                        let mut _98: std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
                                        scope 12 {
                                            debug iter => _63;
                                            let _67: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>;
                                            scope 13 {
                                                debug file_to_add => _67;
                                                let _69: fs::file::File<'_>;
                                                let _72: std::path::PathBuf;
                                                let _73: std::io::Error;
                                                scope 14 {
                                                    debug f => _69;
                                                }
                                                scope 15 {
                                                    debug path => _72;
                                                    debug e => _73;
                                                }
                                            }
                                        }
                                        scope 16 {
                                            debug iter => _84;
                                            let _88: fs::feature::xattr::Attribute;
                                            scope 17 {
                                                debug xattr => _88;
                                            }
                                        }
                                        scope 18 {
                                            debug iter => _98;
                                            let _102: std::io::Error;
                                            let _103: std::option::Option<std::path::PathBuf>;
                                            scope 19 {
                                                debug error => _102;
                                                debug path => _103;
                                            }
                                        }
                                    }
                                    scope 20 {
                                        debug count => _119;
                                        let mut _125: std::iter::Enumerate<std::vec::IntoIter<fs::feature::xattr::Attribute>>;
                                        let _143: usize;
                                        scope 21 {
                                            debug iter => _125;
                                            let _129: usize;
                                            let _130: fs::feature::xattr::Attribute;
                                            scope 22 {
                                                debug index => _129;
                                                debug xattr => _130;
                                                let _131: output::tree::TreeParams;
                                                scope 23 {
                                                    debug params => _131;
                                                    let _139: output::details::Row;
                                                    scope 24 {
                                                        debug r => _139;
                                                    }
                                                }
                                            }
                                        }
                                        scope 25 {
                                            debug count => _143;
                                            let mut _149: std::iter::Enumerate<std::vec::IntoIter<(std::io::Error, std::option::Option<std::path::PathBuf>)>>;
                                            scope 26 {
                                                debug iter => _149;
                                                let _153: usize;
                                                let _154: std::io::Error;
                                                let _155: std::option::Option<std::path::PathBuf>;
                                                scope 27 {
                                                    debug index => _153;
                                                    debug error => _154;
                                                    debug path => _155;
                                                    let _156: output::tree::TreeParams;
                                                    scope 28 {
                                                        debug params => _156;
                                                        let _162: output::details::Row;
                                                        scope 29 {
                                                            debug r => _162;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 3 {
        }
    }

    bb0: {
        _182 = const false;
        _181 = const false;
        _177 = const false;
        _176 = const false;
        _175 = const false;
        _174 = const false;
        _180 = const false;
        _179 = const false;
        _178 = const false;
        _11 = _5;
        _10 = Len((*_11));
        _9 = std::ops::Range::<usize> { start: const 0_usize, end: move _10 };
        _8 = <std::ops::Range<usize> as Iterator>::map::<MaybeUninit<Egg<'_>>, {closure@src/output/details.rs:195:48: 195:51}>(move _9, const ZeroSized: {closure@src/output/details.rs:195:48: 195:51}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _182 = const true;
        _7 = <Map<std::ops::Range<usize>, {closure@src/output/details.rs:195:48: 195:51}> as Iterator>::collect::<Vec<MaybeUninit<Egg<'_>>>>(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _14 = &mut _7;
        _15 = &_3;
        _16 = &_5;
        _17 = &_1;
        _18 = &_6;
        _13 = {closure@src/output/details.rs:197:21: 197:29} { file_eggs: move _14, table: move _15, src: move _16, self: move _17, depth: move _18 };
        _12 = Pool::scoped::<'_, '_, {closure@src/output/details.rs:197:21: 197:29}, ()>(_2, move _13) -> [return: bb3, unwind: bb129];
    }

    bb3: {
        _182 = const false;
        _20 = move _7;
        _19 = move _20 as std::vec::Vec<output::details::Egg<'_>> (Transmute);
        _181 = const true;
        _167 = deref_copy ((*_1).6: &fs::filter::FileFilter);
        _22 = &mut _19;
        _21 = FileFilter::sort_files::<'_, Egg<'_>>(_167, _22) -> [return: bb4, unwind: bb127];
    }

    bb4: {
        _25 = _6;
        _181 = const false;
        _27 = move _19;
        _26 = <Vec<Egg<'_>> as IntoIterator>::into_iter(move _27) -> [return: bb5, unwind: bb127];
    }

    bb5: {
        _24 = TreeDepth::iterate_over::<std::vec::IntoIter<Egg<'_>>, Egg<'_>>(move _25, move _26) -> [return: bb6, unwind: bb127];
    }

    bb6: {
        _23 = <tree::Iter<std::vec::IntoIter<Egg<'_>>> as IntoIterator>::into_iter(move _24) -> [return: bb7, unwind: bb127];
    }

    bb7: {
        _28 = move _23;
        goto -> bb8;
    }

    bb8: {
        _30 = &mut _28;
        _29 = <tree::Iter<std::vec::IntoIter<Egg<'_>>> as Iterator>::next(_30) -> [return: bb9, unwind: bb107];
    }

    bb9: {
        _31 = discriminant(_29);
        switchInt(move _31) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _32 = (((_29 as Some).0: (output::tree::TreeParams, output::details::Egg<'_>)).0: output::tree::TreeParams);
        _178 = const true;
        _179 = const true;
        _180 = const true;
        _33 = move (((_29 as Some).0: (output::tree::TreeParams, output::details::Egg<'_>)).1: output::details::Egg<'_>);
        _34 = Vec::<file::File<'_>>::new() -> [return: bb13, unwind: bb125];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        drop(_28) -> [return: bb96, unwind: bb127];
    }

    bb13: {
        _180 = const false;
        _177 = const true;
        _35 = move (_33.2: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>);
        _38 = _3;
        _37 = Option::<Table<'_>>::as_mut(move _38) -> [return: bb14, unwind: bb118];
    }

    bb14: {
        _40 = &(_33.0: std::option::Option<output::table::Row>);
        _39 = Option::<table::Row>::as_ref(move _40) -> [return: bb15, unwind: bb118];
    }

    bb15: {
        _36 = (move _37, move _39);
        _42 = discriminant((_36.0: std::option::Option<&mut output::table::Table<'_>>));
        switchInt(move _42) -> [1: bb16, otherwise: bb18];
    }

    bb16: {
        _41 = discriminant((_36.1: std::option::Option<&output::table::Row>));
        switchInt(move _41) -> [1: bb17, otherwise: bb18];
    }

    bb17: {
        _43 = &mut (((_36.0: std::option::Option<&mut output::table::Table<'_>>) as Some).0: &mut output::table::Table<'_>);
        _44 = (((_36.1: std::option::Option<&output::table::Row>) as Some).0: &output::table::Row);
        _168 = deref_copy (*_43);
        _45 = Table::<'_>::add_widths(_168, _44) -> [return: bb130, unwind: bb118];
    }

    bb18: {
        _169 = deref_copy ((*_1).3: &output::file_name::Options);
        _51 = (*_169);
        _170 = deref_copy (_33.4: &fs::file::File<'_>);
        _171 = deref_copy ((*_1).2: &theme::Theme);
        _50 = output::file_name::Options::for_file::<Theme>(move _51, _170, _171) -> [return: bb19, unwind: bb118];
    }

    bb19: {
        _49 = FileName::<'_, '_, Theme>::with_link_paths(move _50) -> [return: bb20, unwind: bb118];
    }

    bb20: {
        _48 = &_49;
        _47 = FileName::<'_, '_, Theme>::paint(move _48) -> [return: bb21, unwind: bb105];
    }

    bb21: {
        _46 = TextCellContents::promote(move _47) -> [return: bb22, unwind: bb105];
    }

    bb22: {
        _176 = const true;
        drop(_49) -> [return: bb23, unwind: bb116];
    }

    bb23: {
        _179 = const false;
        _53 = move (_33.0: std::option::Option<output::table::Row>);
        _176 = const false;
        _54 = move _46;
        _52 = details::Row { cells: move _53, name: move _54, tree: _32 };
        _55 = Vec::<details::Row>::push(_4, move _52) -> [return: bb24, unwind: bb116];
    }

    bb24: {
        _56 = discriminant((_33.3: std::option::Option<fs::dir::Dir>));
        switchInt(move _56) -> [1: bb25, otherwise: bb61];
    }

    bb25: {
        _57 = &(((_33.3: std::option::Option<fs::dir::Dir>) as Some).0: fs::dir::Dir);
        _172 = deref_copy ((*_1).6: &fs::filter::FileFilter);
        _60 = ((*_172).4: fs::dir::DotFilter);
        _61 = ((*_1).8: std::option::Option<&fs::feature::git::GitCache>);
        _62 = ((*_1).7: bool);
        _59 = Dir::files(_57, move _60, move _61, move _62) -> [return: bb26, unwind: bb116];
    }

    bb26: {
        _58 = <Files<'_, '_> as IntoIterator>::into_iter(move _59) -> [return: bb27, unwind: bb116];
    }

    bb27: {
        _63 = move _58;
        goto -> bb28;
    }

    bb28: {
        _65 = &mut _63;
        _64 = <Files<'_, '_> as Iterator>::next(_65) -> [return: bb29, unwind: bb116];
    }

    bb29: {
        _66 = discriminant(_64);
        switchInt(move _66) -> [0: bb31, 1: bb30, otherwise: bb11];
    }

    bb30: {
        _67 = move ((_64 as Some).0: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>);
        _68 = discriminant(_67);
        switchInt(move _68) -> [0: bb33, 1: bb32, otherwise: bb11];
    }

    bb31: {
        _173 = deref_copy ((*_1).6: &fs::filter::FileFilter);
        _79 = &mut _34;
        _78 = FileFilter::filter_child_files(_173, _79) -> [return: bb35, unwind: bb116];
    }

    bb32: {
        _72 = move (((_67 as Err).0: (std::path::PathBuf, std::io::Error)).0: std::path::PathBuf);
        _73 = move (((_67 as Err).0: (std::path::PathBuf, std::io::Error)).1: std::io::Error);
        _75 = &mut _35;
        _77 = Option::<PathBuf>::Some(move _72);
        _76 = (move _73, move _77);
        _74 = Vec::<(std::io::Error, Option<PathBuf>)>::push(move _75, move _76) -> [return: bb131, unwind: bb116];
    }

    bb33: {
        _69 = move ((_67 as Ok).0: fs::file::File<'_>);
        _71 = &mut _34;
        _70 = Vec::<file::File<'_>>::push(move _71, move _69) -> [return: bb132, unwind: bb116];
    }

    bb34: {
        goto -> bb28;
    }

    bb35: {
        _81 = &_34;
        _80 = Vec::<file::File<'_>>::is_empty(move _81) -> [return: bb36, unwind: bb116];
    }

    bb36: {
        switchInt(move _80) -> [0: bb37, otherwise: bb61];
    }

    bb37: {
        _178 = const false;
        _83 = move (_33.1: std::vec::Vec<fs::feature::xattr::Attribute>);
        _82 = <Vec<Attribute> as IntoIterator>::into_iter(move _83) -> [return: bb38, unwind: bb116];
    }

    bb38: {
        _84 = move _82;
        goto -> bb39;
    }

    bb39: {
        _86 = &mut _84;
        _85 = <std::vec::IntoIter<Attribute> as Iterator>::next(_86) -> [return: bb40, unwind: bb104];
    }

    bb40: {
        _87 = discriminant(_85);
        switchInt(move _87) -> [0: bb42, 1: bb41, otherwise: bb11];
    }

    bb41: {
        _88 = move ((_85 as Some).0: fs::feature::xattr::Attribute);
        _91 = _1;
        _92 = &_88;
        _95 = _6;
        _94 = TreeDepth::deeper(move _95) -> [return: bb43, unwind: bb103];
    }

    bb42: {
        drop(_84) -> [return: bb47, unwind: bb116];
    }

    bb43: {
        _93 = TreeParams::new(move _94, const false) -> [return: bb44, unwind: bb103];
    }

    bb44: {
        _90 = details::Render::<'_>::render_xattr(move _91, _92, move _93) -> [return: bb45, unwind: bb103];
    }

    bb45: {
        _89 = Vec::<details::Row>::push(_4, move _90) -> [return: bb46, unwind: bb103];
    }

    bb46: {
        drop(_88) -> [return: bb39, unwind: bb104];
    }

    bb47: {
        _177 = const false;
        _97 = move _35;
        _96 = <Vec<(std::io::Error, Option<PathBuf>)> as IntoIterator>::into_iter(move _97) -> [return: bb48, unwind: bb116];
    }

    bb48: {
        _98 = move _96;
        goto -> bb49;
    }

    bb49: {
        _100 = &mut _98;
        _99 = <std::vec::IntoIter<(std::io::Error, Option<PathBuf>)> as Iterator>::next(_100) -> [return: bb50, unwind: bb102];
    }

    bb50: {
        _101 = discriminant(_99);
        switchInt(move _101) -> [0: bb52, 1: bb51, otherwise: bb11];
    }

    bb51: {
        _102 = move (((_99 as Some).0: (std::io::Error, std::option::Option<std::path::PathBuf>)).0: std::io::Error);
        _175 = const true;
        _103 = move (((_99 as Some).0: (std::io::Error, std::option::Option<std::path::PathBuf>)).1: std::option::Option<std::path::PathBuf>);
        _106 = _1;
        _107 = &_102;
        _110 = _6;
        _109 = TreeDepth::deeper(move _110) -> [return: bb53, unwind: bb114];
    }

    bb52: {
        drop(_98) -> [return: bb57, unwind: bb116];
    }

    bb53: {
        _108 = TreeParams::new(move _109, const false) -> [return: bb54, unwind: bb114];
    }

    bb54: {
        _175 = const false;
        _111 = move _103;
        _105 = details::Render::<'_>::render_error(move _106, _107, move _108, move _111) -> [return: bb55, unwind: bb114];
    }

    bb55: {
        _104 = Vec::<details::Row>::push(_4, move _105) -> [return: bb56, unwind: bb114];
    }

    bb56: {
        _175 = const false;
        drop(_102) -> [return: bb49, unwind: bb102];
    }

    bb57: {
        _113 = _1;
        _114 = _3;
        _116 = &_34;
        _115 = <Vec<file::File<'_>> as Deref>::deref(_116) -> [return: bb58, unwind: bb116];
    }

    bb58: {
        _118 = _6;
        _117 = TreeDepth::deeper(move _118) -> [return: bb59, unwind: bb116];
    }

    bb59: {
        _112 = details::Render::<'_>::add_files_to_table(move _113, _2, move _114, _4, _115, move _117) -> [return: bb60, unwind: bb116];
    }

    bb60: {
        _176 = const false;
        _177 = const false;
        drop(_34) -> [return: bb95, unwind: bb125];
    }

    bb61: {
        _120 = &(_33.1: std::vec::Vec<fs::feature::xattr::Attribute>);
        _119 = Vec::<Attribute>::len(move _120) -> [return: bb62, unwind: bb116];
    }

    bb62: {
        _178 = const false;
        _124 = move (_33.1: std::vec::Vec<fs::feature::xattr::Attribute>);
        _123 = <Vec<Attribute> as IntoIterator>::into_iter(move _124) -> [return: bb63, unwind: bb116];
    }

    bb63: {
        _122 = <std::vec::IntoIter<Attribute> as Iterator>::enumerate(move _123) -> [return: bb64, unwind: bb116];
    }

    bb64: {
        _121 = <Enumerate<std::vec::IntoIter<Attribute>> as IntoIterator>::into_iter(move _122) -> [return: bb65, unwind: bb116];
    }

    bb65: {
        _125 = move _121;
        goto -> bb66;
    }

    bb66: {
        _127 = &mut _125;
        _126 = <Enumerate<std::vec::IntoIter<Attribute>> as Iterator>::next(_127) -> [return: bb67, unwind: bb100];
    }

    bb67: {
        _128 = discriminant(_126);
        switchInt(move _128) -> [0: bb69, 1: bb68, otherwise: bb11];
    }

    bb68: {
        _129 = (((_126 as Some).0: (usize, fs::feature::xattr::Attribute)).0: usize);
        _130 = move (((_126 as Some).0: (usize, fs::feature::xattr::Attribute)).1: fs::feature::xattr::Attribute);
        _133 = _6;
        _132 = TreeDepth::deeper(move _133) -> [return: bb70, unwind: bb99];
    }

    bb69: {
        drop(_125) -> [return: bb79, unwind: bb116];
    }

    bb70: {
        _136 = &_35;
        _135 = Vec::<(std::io::Error, Option<PathBuf>)>::is_empty(move _136) -> [return: bb71, unwind: bb99];
    }

    bb71: {
        switchInt(move _135) -> [0: bb73, otherwise: bb72];
    }

    bb72: {
        _138 = CheckedSub(_119, const 1_usize);
        assert(!move (_138.1: bool), "attempt to compute `{} - {}`, which would overflow", _119, const 1_usize) -> [success: bb74, unwind: bb99];
    }

    bb73: {
        _134 = const false;
        goto -> bb75;
    }

    bb74: {
        _137 = move (_138.0: usize);
        _134 = Eq(_129, move _137);
        goto -> bb75;
    }

    bb75: {
        _131 = TreeParams::new(move _132, move _134) -> [return: bb76, unwind: bb99];
    }

    bb76: {
        _140 = _1;
        _141 = &_130;
        _139 = details::Render::<'_>::render_xattr(move _140, _141, _131) -> [return: bb77, unwind: bb99];
    }

    bb77: {
        _142 = Vec::<details::Row>::push(_4, move _139) -> [return: bb78, unwind: bb99];
    }

    bb78: {
        drop(_130) -> [return: bb66, unwind: bb100];
    }

    bb79: {
        _144 = &_35;
        _143 = Vec::<(std::io::Error, Option<PathBuf>)>::len(move _144) -> [return: bb80, unwind: bb116];
    }

    bb80: {
        _177 = const false;
        _148 = move _35;
        _147 = <Vec<(std::io::Error, Option<PathBuf>)> as IntoIterator>::into_iter(move _148) -> [return: bb81, unwind: bb116];
    }

    bb81: {
        _146 = <std::vec::IntoIter<(std::io::Error, Option<PathBuf>)> as Iterator>::enumerate(move _147) -> [return: bb82, unwind: bb116];
    }

    bb82: {
        _145 = <Enumerate<std::vec::IntoIter<(std::io::Error, Option<PathBuf>)>> as IntoIterator>::into_iter(move _146) -> [return: bb83, unwind: bb116];
    }

    bb83: {
        _149 = move _145;
        goto -> bb84;
    }

    bb84: {
        _151 = &mut _149;
        _150 = <Enumerate<std::vec::IntoIter<(std::io::Error, Option<PathBuf>)>> as Iterator>::next(_151) -> [return: bb85, unwind: bb98];
    }

    bb85: {
        _152 = discriminant(_150);
        switchInt(move _152) -> [0: bb87, 1: bb86, otherwise: bb11];
    }

    bb86: {
        _154 = move ((((_150 as Some).0: (usize, (std::io::Error, std::option::Option<std::path::PathBuf>))).1: (std::io::Error, std::option::Option<std::path::PathBuf>)).0: std::io::Error);
        _174 = const true;
        _155 = move ((((_150 as Some).0: (usize, (std::io::Error, std::option::Option<std::path::PathBuf>))).1: (std::io::Error, std::option::Option<std::path::PathBuf>)).1: std::option::Option<std::path::PathBuf>);
        _153 = (((_150 as Some).0: (usize, (std::io::Error, std::option::Option<std::path::PathBuf>))).0: usize);
        _158 = _6;
        _157 = TreeDepth::deeper(move _158) -> [return: bb88, unwind: bb112];
    }

    bb87: {
        drop(_149) -> [return: bb93, unwind: bb116];
    }

    bb88: {
        _161 = CheckedSub(_143, const 1_usize);
        assert(!move (_161.1: bool), "attempt to compute `{} - {}`, which would overflow", _143, const 1_usize) -> [success: bb89, unwind: bb112];
    }

    bb89: {
        _160 = move (_161.0: usize);
        _159 = Eq(_153, move _160);
        _156 = TreeParams::new(move _157, move _159) -> [return: bb90, unwind: bb112];
    }

    bb90: {
        _163 = _1;
        _164 = &_154;
        _174 = const false;
        _165 = move _155;
        _162 = details::Render::<'_>::render_error(move _163, _164, _156, move _165) -> [return: bb91, unwind: bb112];
    }

    bb91: {
        _166 = Vec::<details::Row>::push(_4, move _162) -> [return: bb92, unwind: bb112];
    }

    bb92: {
        _174 = const false;
        drop(_154) -> [return: bb84, unwind: bb98];
    }

    bb93: {
        _176 = const false;
        _177 = const false;
        drop(_34) -> [return: bb94, unwind: bb125];
    }

    bb94: {
        drop((_33.3: std::option::Option<fs::dir::Dir>)) -> [return: bb109, unwind: bb107];
    }

    bb95: {
        drop((_33.3: std::option::Option<fs::dir::Dir>)) -> [return: bb110, unwind: bb107];
    }

    bb96: {
        _181 = const false;
        _182 = const false;
        return;
    }

    bb97 (cleanup): {
        drop(_154) -> [return: bb98, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        drop(_149) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb99 (cleanup): {
        drop(_130) -> [return: bb100, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        drop(_125) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb101 (cleanup): {
        drop(_102) -> [return: bb102, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        drop(_98) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        drop(_88) -> [return: bb104, unwind terminate(cleanup)];
    }

    bb104 (cleanup): {
        drop(_84) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        drop(_49) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb106 (cleanup): {
        drop(_34) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        drop(_28) -> [return: bb127, unwind terminate(cleanup)];
    }

    bb108 (cleanup): {
        resume;
    }

    bb109: {
        _178 = const false;
        _179 = const false;
        _180 = const false;
        goto -> bb8;
    }

    bb110: {
        _178 = const false;
        _179 = const false;
        _180 = const false;
        goto -> bb8;
    }

    bb111 (cleanup): {
        drop(_155) -> [return: bb97, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        switchInt(_174) -> [0: bb97, otherwise: bb111];
    }

    bb113 (cleanup): {
        drop(_103) -> [return: bb101, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        switchInt(_175) -> [0: bb101, otherwise: bb113];
    }

    bb115 (cleanup): {
        drop(_46) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        switchInt(_176) -> [0: bb118, otherwise: bb115];
    }

    bb117 (cleanup): {
        drop(_35) -> [return: bb106, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        switchInt(_177) -> [0: bb106, otherwise: bb117];
    }

    bb119 (cleanup): {
        drop((_33.3: std::option::Option<fs::dir::Dir>)) -> [return: bb107, unwind terminate(cleanup)];
    }

    bb120 (cleanup): {
        switchInt(_180) -> [0: bb119, otherwise: bb121];
    }

    bb121 (cleanup): {
        drop((_33.2: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>)) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb122 (cleanup): {
        switchInt(_178) -> [0: bb120, otherwise: bb123];
    }

    bb123 (cleanup): {
        drop((_33.1: std::vec::Vec<fs::feature::xattr::Attribute>)) -> [return: bb120, unwind terminate(cleanup)];
    }

    bb124 (cleanup): {
        drop((_33.0: std::option::Option<output::table::Row>)) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        switchInt(_179) -> [0: bb122, otherwise: bb124];
    }

    bb126 (cleanup): {
        drop(_19) -> [return: bb129, unwind terminate(cleanup)];
    }

    bb127 (cleanup): {
        switchInt(_181) -> [0: bb129, otherwise: bb126];
    }

    bb128 (cleanup): {
        drop(_7) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb129 (cleanup): {
        switchInt(_182) -> [0: bb108, otherwise: bb128];
    }

    bb130: {
        goto -> bb18;
    }

    bb131: {
        goto -> bb34;
    }

    bb132: {
        goto -> bb34;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#0}(_1: &mut {closure@src/output/details.rs:195:48: 195:51}, _2: usize) -> MaybeUninit<Egg<'_>> {
    let mut _0: std::mem::MaybeUninit<output::details::Egg<'_>>;

    bb0: {
        _0 = MaybeUninit::<Egg<'_>>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}(_1: {closure@src/output/details.rs:197:21: 197:29}, _2: &scoped_threadpool::Scope<'_, '_>) -> () {
    debug scoped => _2;
    debug file_eggs => (*(_1.0: &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>));
    debug table => (*(_1.1: &&mut std::option::Option<output::table::Table<'_>>));
    debug src => (*(_1.2: &&[fs::file::File<'_>]));
    debug self => (*(_1.3: &&output::details::Render<'_>));
    debug depth => (*(_1.4: &output::tree::TreeDepth));
    let mut _0: ();
    let _3: std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>;
    let mut _4: std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>;
    let mut _6: &std::option::Option<output::table::Table<'_>>;
    let mut _7: std::iter::Enumerate<std::slice::Iter<'_, fs::file::File<'_>>>;
    let mut _8: std::iter::Enumerate<std::slice::Iter<'_, fs::file::File<'_>>>;
    let mut _9: std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _11: std::option::Option<(usize, &fs::file::File<'_>)>;
    let mut _12: &mut std::iter::Enumerate<std::slice::Iter<'_, fs::file::File<'_>>>;
    let mut _13: isize;
    let _17: &std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>;
    let _18: ();
    let mut _19: {closure@src/output/details.rs:204:32: 204:39};
    let mut _20: &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let mut _21: &&mut std::option::Option<output::table::Table<'_>>;
    let mut _22: &mut std::option::Option<output::table::Table<'_>>;
    let mut _23: &&[fs::file::File<'_>];
    let mut _24: &[fs::file::File<'_>];
    let mut _25: &&output::details::Render<'_>;
    let mut _26: &output::tree::TreeDepth;
    scope 1 {
        debug file_eggs => _3;
        let _5: std::option::Option<&output::table::Table<'_>>;
        scope 2 {
            debug table => _5;
            let mut _10: std::iter::Enumerate<std::slice::Iter<'_, fs::file::File<'_>>>;
            scope 3 {
                debug iter => _10;
                let _14: usize;
                let _15: &fs::file::File<'_>;
                scope 4 {
                    debug idx => _14;
                    debug file => _15;
                    let _16: std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>;
                    scope 5 {
                        debug file_eggs => _16;
                    }
                }
            }
        }
    }

    bb0: {
        _20 = deref_copy (_1.0: &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>);
        _4 = Mutex::<&mut Vec<MaybeUninit<Egg<'_>>>>::new(_20) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Arc::<Mutex<&mut Vec<MaybeUninit<Egg<'_>>>>>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _21 = deref_copy (_1.1: &&mut std::option::Option<output::table::Table<'_>>);
        _22 = deref_copy (*_21);
        _6 = &(*_22);
        _5 = Option::<Table<'_>>::as_ref(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _23 = deref_copy (_1.2: &&[fs::file::File<'_>]);
        _24 = deref_copy (*_23);
        _9 = core::slice::<impl [file::File<'_>]>::iter(_24) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _8 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::enumerate(move _9) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _7 = <Enumerate<std::slice::Iter<'_, file::File<'_>>> as IntoIterator>::into_iter(move _8) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _10 = move _7;
        goto -> bb7;
    }

    bb7: {
        _12 = &mut _10;
        _11 = <Enumerate<std::slice::Iter<'_, file::File<'_>>> as Iterator>::next(_12) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _14 = (((_11 as Some).0: (usize, &fs::file::File<'_>)).0: usize);
        _15 = (((_11 as Some).0: (usize, &fs::file::File<'_>)).1: &fs::file::File<'_>);
        _17 = &_3;
        _16 = <Arc<Mutex<&mut Vec<MaybeUninit<Egg<'_>>>>> as Clone>::clone(_17) -> [return: bb12, unwind: bb14];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        drop(_3) -> [return: bb13, unwind continue];
    }

    bb12: {
        _25 = deref_copy (_1.3: &&output::details::Render<'_>);
        _26 = deref_copy (_1.4: &output::tree::TreeDepth);
        _19 = {closure@src/output/details.rs:204:32: 204:39} { file: _15, self: (*_25), table: _5, depth: (*_26), file_eggs: move _16, idx: _14 };
        _18 = scoped_threadpool::Scope::<'_, '_>::execute::<{closure@src/output/details.rs:204:32: 204:39}>(_2, move _19) -> [return: bb16, unwind: bb14];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        goto -> bb7;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}::{closure#0}(_1: {closure@src/output/details.rs:204:32: 204:39}) -> () {
    debug file => (_1.0: &fs::file::File<'_>);
    debug self => (_1.1: &output::details::Render<'_>);
    debug table => (_1.2: std::option::Option<&output::table::Table<'_>>);
    debug depth => (_1.3: output::tree::TreeDepth);
    debug file_eggs => (_1.4: std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>);
    debug idx => (_1.5: usize);
    let mut _0: ();
    let mut _2: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _4: bool;
    let mut _5: std::result::Result<std::vec::Vec<fs::feature::xattr::Attribute>, std::io::Error>;
    let _6: &std::path::Path;
    let mut _7: &std::path::PathBuf;
    let mut _8: isize;
    let _10: ();
    let mut _11: &mut std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _13: bool;
    let _14: ();
    let mut _15: &mut std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _16: (std::io::Error, std::option::Option<std::path::PathBuf>);
    let mut _17: std::io::Error;
    let mut _18: std::option::Option<std::path::PathBuf>;
    let mut _20: bool;
    let mut _21: &log::Level;
    let mut _22: bool;
    let mut _23: &log::Level;
    let mut _24: &log::LevelFilter;
    let _25: log::LevelFilter;
    let _26: ();
    let mut _27: std::fmt::Arguments<'_>;
    let mut _28: &[&str];
    let mut _29: &[core::fmt::rt::Argument<'_>];
    let _30: &[core::fmt::rt::Argument<'_>; 2];
    let _31: [core::fmt::rt::Argument<'_>; 2];
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &std::path::PathBuf;
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &std::io::Error;
    let mut _36: &[core::fmt::rt::Placeholder];
    let _37: &[core::fmt::rt::Placeholder; 2];
    let _38: [core::fmt::rt::Placeholder; 2];
    let mut _39: core::fmt::rt::Placeholder;
    let mut _40: core::fmt::rt::Alignment;
    let mut _41: core::fmt::rt::Count;
    let mut _42: core::fmt::rt::Count;
    let mut _43: core::fmt::rt::Placeholder;
    let mut _44: core::fmt::rt::Alignment;
    let mut _45: core::fmt::rt::Count;
    let mut _46: core::fmt::rt::Count;
    let mut _47: core::fmt::rt::UnsafeArg;
    let mut _48: log::Level;
    let mut _50: std::option::Option<&&output::table::Table<'_>>;
    let mut _51: &std::option::Option<&output::table::Table<'_>>;
    let mut _52: {closure@src/output/details.rs:247:47: 247:50};
    let mut _53: &&fs::file::File<'_>;
    let mut _54: &std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _55: bool;
    let _56: ();
    let mut _57: &mut std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _59: isize;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: usize;
    let mut _65: std::result::Result<fs::dir::Dir, std::io::Error>;
    let mut _66: isize;
    let mut _68: std::option::Option<fs::dir::Dir>;
    let _70: ();
    let mut _71: &mut std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _72: (std::io::Error, std::option::Option<std::path::PathBuf>);
    let mut _73: std::option::Option<std::path::PathBuf>;
    let mut _75: std::option::Option<output::table::Row>;
    let mut _76: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _77: std::vec::Vec<(std::io::Error, std::option::Option<std::path::PathBuf>)>;
    let mut _78: std::option::Option<fs::dir::Dir>;
    let mut _79: *mut output::details::Egg<'_>;
    let mut _80: &mut std::mem::MaybeUninit<output::details::Egg<'_>>;
    let mut _81: &mut &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let mut _82: &mut std::sync::MutexGuard<'_, &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>;
    let mut _83: std::sync::MutexGuard<'_, &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>;
    let mut _84: std::result::Result<std::sync::MutexGuard<'_, &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>, std::sync::PoisonError<std::sync::MutexGuard<'_, &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>>;
    let _85: &std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>;
    let mut _86: &std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>;
    let mut _87: usize;
    let mut _88: output::details::Egg<'_>;
    let mut _92: &fs::file::File<'_>;
    let mut _93: &output::details::Render<'_>;
    let mut _94: &output::details::Options;
    let mut _95: &fs::file::File<'_>;
    let mut _96: &output::details::Render<'_>;
    let mut _97: &output::details::Options;
    let mut _98: &output::details::Render<'_>;
    let mut _99: &output::details::Render<'_>;
    let mut _100: &fs::file::File<'_>;
    let mut _101: &fs::file::File<'_>;
    let mut _102: &fs::file::File<'_>;
    let mut _103: &mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: bool;
    let mut _107: bool;
    let mut _108: bool;
    let mut _109: bool;
    scope 1 {
        debug errors => _2;
        let mut _3: std::vec::Vec<fs::feature::xattr::Attribute>;
        scope 2 {
            debug xattrs => _3;
            let _9: std::vec::Vec<fs::feature::xattr::Attribute>;
            let _12: std::io::Error;
            let _49: std::option::Option<output::table::Row>;
            scope 3 {
                debug xs => _9;
            }
            scope 4 {
                debug e => _12;
                let _19: log::Level;
                scope 5 {
                    debug lvl => _19;
                    let mut _89: &(&str, &str, &str, u32);
                    let mut _90: &[&str; 2];
                    let mut _91: &log::LevelFilter;
                    scope 6 {
                    }
                }
            }
            scope 7 {
                debug table_row => _49;
                let mut _58: std::option::Option<fs::dir::Dir>;
                scope 8 {
                    debug dir => _58;
                    let _74: output::details::Egg<'_>;
                    scope 9 {
                        debug r => _60;
                        let _60: fs::dir_action::RecurseOptions;
                        let _67: fs::dir::Dir;
                        let _69: std::io::Error;
                        scope 10 {
                            debug d => _67;
                        }
                        scope 11 {
                            debug e => _69;
                        }
                    }
                    scope 12 {
                        debug egg => _74;
                        scope 13 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _109 = const false;
        _108 = const false;
        _104 = const false;
        _107 = const false;
        _106 = const false;
        _105 = const false;
        _2 = Vec::<(std::io::Error, Option<PathBuf>)>::new() -> [return: bb1, unwind: bb52];
    }

    bb1: {
        _109 = const true;
        _3 = Vec::<Attribute>::new() -> [return: bb2, unwind: bb66];
    }

    bb2: {
        _108 = const true;
        _4 = const _;
        switchInt(move _4) -> [0: bb24, otherwise: bb3];
    }

    bb3: {
        _92 = deref_copy (_1.0: &fs::file::File<'_>);
        _7 = &((*_92).2: std::path::PathBuf);
        _6 = <PathBuf as Deref>::deref(move _7) -> [return: bb4, unwind: bb64];
    }

    bb4: {
        _5 = <Path as FileAttributes>::attributes(_6) -> [return: bb5, unwind: bb64];
    }

    bb5: {
        _8 = discriminant(_5);
        switchInt(move _8) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _104 = const true;
        _12 = move ((_5 as Err).0: std::io::Error);
        _93 = deref_copy (_1.1: &output::details::Render<'_>);
        _94 = deref_copy ((*_93).4: &output::details::Options);
        _13 = ((*_94).2: bool);
        switchInt(move _13) -> [0: bb10, otherwise: bb9];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _9 = move ((_5 as Ok).0: std::vec::Vec<fs::feature::xattr::Attribute>);
        _11 = &mut _3;
        _10 = <Vec<Attribute> as Extend<Attribute>>::extend::<Vec<Attribute>>(move _11, move _9) -> [return: bb67, unwind: bb64];
    }

    bb9: {
        _15 = &mut _2;
        _104 = const false;
        _17 = move _12;
        _18 = Option::<PathBuf>::None;
        _16 = (move _17, move _18);
        _14 = Vec::<(std::io::Error, Option<PathBuf>)>::push(move _15, move _16) -> [return: bb68, unwind: bb62];
    }

    bb10: {
        _19 = log::Level::Error;
        _21 = &_19;
        _91 = const _;
        _20 = <Level as PartialOrd<LevelFilter>>::le(move _21, _91) -> [return: bb11, unwind: bb62];
    }

    bb11: {
        switchInt(move _20) -> [0: bb22, otherwise: bb12];
    }

    bb12: {
        _23 = &_19;
        _25 = max_level() -> [return: bb13, unwind: bb62];
    }

    bb13: {
        _24 = &_25;
        _22 = <Level as PartialOrd<LevelFilter>>::le(move _23, move _24) -> [return: bb14, unwind: bb62];
    }

    bb14: {
        switchInt(move _22) -> [0: bb22, otherwise: bb15];
    }

    bb15: {
        _90 = const _;
        _28 = _90 as &[&str] (PointerCoercion(Unsize));
        _95 = deref_copy (_1.0: &fs::file::File<'_>);
        _33 = &((*_95).2: std::path::PathBuf);
        _32 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_33) -> [return: bb16, unwind: bb62];
    }

    bb16: {
        _35 = &_12;
        _34 = core::fmt::rt::Argument::<'_>::new_debug::<std::io::Error>(_35) -> [return: bb17, unwind: bb62];
    }

    bb17: {
        _31 = [move _32, move _34];
        _30 = &_31;
        _29 = _30 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _40 = core::fmt::rt::Alignment::Unknown;
        _41 = core::fmt::rt::Count::Implied;
        _42 = core::fmt::rt::Count::Implied;
        _39 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _40, const 0_u32, move _41, move _42) -> [return: bb18, unwind: bb62];
    }

    bb18: {
        _44 = core::fmt::rt::Alignment::Unknown;
        _45 = core::fmt::rt::Count::Implied;
        _46 = core::fmt::rt::Count::Implied;
        _43 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _44, const 4_u32, move _45, move _46) -> [return: bb19, unwind: bb62];
    }

    bb19: {
        _38 = [move _39, move _43];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _47 = core::fmt::rt::UnsafeArg::new() -> [return: bb20, unwind: bb62];
    }

    bb20: {
        _27 = std::fmt::Arguments::<'_>::new_v1_formatted(move _28, move _29, move _36, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb21, unwind: bb62];
    }

    bb21: {
        _48 = _19;
        _89 = const _;
        _26 = __private_api_log(move _27, move _48, _89) -> [return: bb69, unwind: bb62];
    }

    bb22: {
        switchInt(_104) -> [0: bb23, otherwise: bb54];
    }

    bb23: {
        _104 = const false;
        goto -> bb24;
    }

    bb24: {
        _51 = &(_1.2: std::option::Option<&output::table::Table<'_>>);
        _50 = Option::<&Table<'_>>::as_ref(move _51) -> [return: bb25, unwind: bb64];
    }

    bb25: {
        _53 = &(_1.0: &fs::file::File<'_>);
        _54 = &_3;
        _52 = {closure@src/output/details.rs:247:47: 247:50} { file: move _53, xattrs: move _54 };
        _49 = Option::<&&Table<'_>>::map::<table::Row, {closure@src/output/details.rs:247:47: 247:50}>(move _50, move _52) -> [return: bb26, unwind: bb64];
    }

    bb26: {
        _107 = const true;
        _96 = deref_copy (_1.1: &output::details::Render<'_>);
        _97 = deref_copy ((*_96).4: &output::details::Options);
        _55 = ((*_97).2: bool);
        switchInt(move _55) -> [0: bb27, otherwise: bb28];
    }

    bb27: {
        _57 = &mut _3;
        _56 = Vec::<Attribute>::clear(move _57) -> [return: bb70, unwind: bb60];
    }

    bb28: {
        _106 = const true;
        _58 = Option::<Dir>::None;
        _98 = deref_copy (_1.1: &output::details::Render<'_>);
        _59 = discriminant(((*_98).5: std::option::Option<fs::dir_action::RecurseOptions>));
        switchInt(move _59) -> [1: bb29, otherwise: bb40];
    }

    bb29: {
        _99 = deref_copy (_1.1: &output::details::Render<'_>);
        _60 = ((((*_99).5: std::option::Option<fs::dir_action::RecurseOptions>) as Some).0: fs::dir_action::RecurseOptions);
        _100 = deref_copy (_1.0: &fs::file::File<'_>);
        _61 = file::File::<'_>::is_directory(_100) -> [return: bb30, unwind: bb58];
    }

    bb30: {
        switchInt(move _61) -> [0: bb40, otherwise: bb31];
    }

    bb31: {
        _62 = (_60.0: bool);
        switchInt(move _62) -> [0: bb40, otherwise: bb32];
    }

    bb32: {
        _64 = ((_1.3: output::tree::TreeDepth).0: usize);
        _63 = RecurseOptions::is_too_deep(_60, move _64) -> [return: bb33, unwind: bb58];
    }

    bb33: {
        switchInt(move _63) -> [0: bb34, otherwise: bb40];
    }

    bb34: {
        _101 = deref_copy (_1.0: &fs::file::File<'_>);
        _65 = file::File::<'_>::to_dir(_101) -> [return: bb35, unwind: bb58];
    }

    bb35: {
        _66 = discriminant(_65);
        switchInt(move _66) -> [0: bb37, 1: bb36, otherwise: bb7];
    }

    bb36: {
        _69 = move ((_65 as Err).0: std::io::Error);
        _71 = &mut _2;
        _73 = Option::<PathBuf>::None;
        _72 = (move _69, move _73);
        _70 = Vec::<(std::io::Error, Option<PathBuf>)>::push(move _71, move _72) -> [return: bb71, unwind: bb58];
    }

    bb37: {
        _67 = move ((_65 as Ok).0: fs::dir::Dir);
        _68 = Option::<Dir>::Some(move _67);
        drop(_58) -> [return: bb38, unwind: bb39];
    }

    bb38: {
        _106 = const true;
        _58 = move _68;
        goto -> bb40;
    }

    bb39 (cleanup): {
        _106 = const true;
        _58 = move _68;
        goto -> bb58;
    }

    bb40: {
        _107 = const false;
        _75 = move _49;
        _108 = const false;
        _76 = move _3;
        _109 = const false;
        _77 = move _2;
        _106 = const false;
        _78 = move _58;
        _102 = deref_copy (_1.0: &fs::file::File<'_>);
        _105 = const true;
        _74 = Egg::<'_> { table_row: move _75, xattrs: move _76, errors: move _77, dir: move _78, file: _102 };
        _86 = &(_1.4: std::sync::Arc<std::sync::Mutex<&mut std::vec::Vec<std::mem::MaybeUninit<output::details::Egg<'_>>>>>);
        _85 = <Arc<Mutex<&mut Vec<MaybeUninit<Egg<'_>>>>> as Deref>::deref(move _86) -> [return: bb41, unwind: bb51];
    }

    bb41: {
        _84 = Mutex::<&mut Vec<MaybeUninit<Egg<'_>>>>::lock(_85) -> [return: bb42, unwind: bb51];
    }

    bb42: {
        _83 = Result::<MutexGuard<'_, &mut Vec<MaybeUninit<Egg<'_>>>>, PoisonError<MutexGuard<'_, &mut Vec<MaybeUninit<Egg<'_>>>>>>::unwrap(move _84) -> [return: bb43, unwind: bb51];
    }

    bb43: {
        _82 = &mut _83;
        _81 = <MutexGuard<'_, &mut Vec<MaybeUninit<Egg<'_>>>> as DerefMut>::deref_mut(move _82) -> [return: bb44, unwind: bb56];
    }

    bb44: {
        _103 = deref_copy (*_81);
        _87 = (_1.5: usize);
        _80 = <Vec<MaybeUninit<Egg<'_>>> as IndexMut<usize>>::index_mut(_103, move _87) -> [return: bb45, unwind: bb56];
    }

    bb45: {
        _79 = MaybeUninit::<Egg<'_>>::as_mut_ptr(_80) -> [return: bb46, unwind: bb56];
    }

    bb46: {
        _105 = const false;
        _88 = move _74;
        _0 = std::ptr::write::<Egg<'_>>(move _79, move _88) -> [return: bb47, unwind: bb56];
    }

    bb47: {
        _105 = const false;
        _106 = const false;
        _107 = const false;
        _108 = const false;
        _109 = const false;
        drop(_83) -> [return: bb48, unwind: bb52];
    }

    bb48: {
        drop(_1) -> [return: bb49, unwind continue];
    }

    bb49: {
        return;
    }

    bb50 (cleanup): {
        drop(_83) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_74) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_1) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        resume;
    }

    bb54: {
        drop(_12) -> [return: bb23, unwind: bb64];
    }

    bb55 (cleanup): {
        drop(_74) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        switchInt(_105) -> [0: bb50, otherwise: bb55];
    }

    bb57 (cleanup): {
        drop(_58) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        switchInt(_106) -> [0: bb60, otherwise: bb57];
    }

    bb59 (cleanup): {
        drop(_49) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        switchInt(_107) -> [0: bb64, otherwise: bb59];
    }

    bb61 (cleanup): {
        drop(_12) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        switchInt(_104) -> [0: bb64, otherwise: bb61];
    }

    bb63 (cleanup): {
        drop(_3) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        switchInt(_108) -> [0: bb66, otherwise: bb63];
    }

    bb65 (cleanup): {
        drop(_2) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        switchInt(_109) -> [0: bb52, otherwise: bb65];
    }

    bb67: {
        goto -> bb24;
    }

    bb68: {
        goto -> bb22;
    }

    bb69: {
        goto -> bb22;
    }

    bb70: {
        goto -> bb28;
    }

    bb71: {
        goto -> bb40;
    }
}

promoted[0] in details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}::{closure#0}: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::output::details";
        _2 = &(*_3);
        _1 = (move _2, const "exa::output::details", const "src/output/details.rs", const 240_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Error looking up xattr for ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}::{closure#0}: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::add_files_to_table::{closure#1}::{closure#0}::{closure#0}(_1: {closure@src/output/details.rs:247:47: 247:50}, _2: &&Table<'_>) -> table::Row {
    debug t => _2;
    debug file => (*(_1.0: &&fs::file::File<'_>));
    debug xattrs => (*(_1.1: &std::vec::Vec<fs::feature::xattr::Attribute>));
    let mut _0: output::table::Row;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: &output::table::Table<'_>;
    let mut _6: &&fs::file::File<'_>;
    let mut _7: &fs::file::File<'_>;
    let mut _8: &std::vec::Vec<fs::feature::xattr::Attribute>;

    bb0: {
        _5 = deref_copy (*_2);
        _6 = deref_copy (_1.0: &&fs::file::File<'_>);
        _7 = deref_copy (*_6);
        _8 = deref_copy (_1.1: &std::vec::Vec<fs::feature::xattr::Attribute>);
        _4 = Vec::<Attribute>::is_empty(_8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Not(move _4);
        _0 = Table::<'_>::row_for_file(_5, _7, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render_header(_1: &details::Render<'_>, _2: table::Row) -> details::Row {
    debug self => _1;
    debug header => _2;
    let mut _0: output::details::Row;
    let mut _3: output::tree::TreeParams;
    let mut _4: output::tree::TreeDepth;
    let mut _5: std::option::Option<output::table::Row>;
    let mut _6: output::table::Row;
    let mut _7: output::cell::TextCell;
    let mut _8: ansi_term::Style;
    let mut _9: &theme::Theme;
    let mut _10: bool;

    bb0: {
        _10 = const false;
        _10 = const true;
        _4 = TreeDepth::root() -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _3 = TreeParams::new(move _4, const false) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _10 = const false;
        _6 = move _2;
        _5 = Option::<table::Row>::Some(move _6);
        _9 = deref_copy ((*_1).2: &theme::Theme);
        _8 = (((*_9).0: theme::ui_styles::UiStyles).11: ansi_term::Style);
        _7 = TextCell::paint_str(move _8, const "Name") -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = details::Row { cells: move _5, name: move _7, tree: move _3 };
        return;
    }

    bb4 (cleanup): {
        drop(_5) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        switchInt(_10) -> [0: bb5, otherwise: bb6];
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render_error(_1: &details::Render<'_>, _2: &std::io::Error, _3: TreeParams, _4: Option<PathBuf>) -> details::Row {
    debug self => _1;
    debug error => _2;
    debug tree => _3;
    debug path => _4;
    let mut _0: output::details::Row;
    let _5: std::string::String;
    let mut _6: isize;
    let _7: std::path::PathBuf;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 2];
    let _13: [core::fmt::rt::Argument<'_>; 2];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &std::path::Display<'_>;
    let _16: std::path::Display<'_>;
    let _17: &std::path::Path;
    let mut _18: &std::path::PathBuf;
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &&std::io::Error;
    let _21: std::string::String;
    let mut _22: std::fmt::Arguments<'_>;
    let mut _23: &[&str];
    let mut _24: &[core::fmt::rt::Argument<'_>];
    let _25: &[core::fmt::rt::Argument<'_>; 1];
    let _26: [core::fmt::rt::Argument<'_>; 1];
    let mut _27: core::fmt::rt::Argument<'_>;
    let _28: &&std::io::Error;
    let mut _30: ansi_term::Style;
    let mut _31: std::string::String;
    let mut _32: std::option::Option<output::table::Row>;
    let mut _33: &[&str; 2];
    let mut _35: &theme::Theme;
    let mut _36: bool;
    scope 1 {
        debug error_message => _5;
        let _29: output::cell::TextCell;
        scope 5 {
            debug name => _29;
        }
    }
    scope 2 {
        debug path => _7;
        let _8: std::string::String;
        let mut _34: &[&str; 3];
        scope 3 {
            debug res => _8;
        }
    }
    scope 4 {
        debug res => _21;
    }

    bb0: {
        _36 = const false;
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _33 = const _;
        _23 = _33 as &[&str] (PointerCoercion(Unsize));
        _28 = &_2;
        _27 = core::fmt::rt::Argument::<'_>::new_display::<&std::io::Error>(_28) -> [return: bb10, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _7 = move ((_4 as Some).0: std::path::PathBuf);
        _34 = const _;
        _10 = _34 as &[&str] (PointerCoercion(Unsize));
        _18 = &_7;
        _17 = <PathBuf as Deref>::deref(move _18) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _16 = Path::display(_17) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _15 = &_16;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_15) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _20 = &_2;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<&std::io::Error>(_20) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _13 = [move _14, move _19];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = std::fmt::Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _8 = format(move _9) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _36 = const true;
        _5 = move _8;
        drop(_7) -> [return: bb13, unwind continue];
    }

    bb10: {
        _26 = [move _27];
        _25 = &_26;
        _24 = _25 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _22 = std::fmt::Arguments::<'_>::new_v1(move _23, move _24) -> [return: bb11, unwind continue];
    }

    bb11: {
        _21 = format(move _22) -> [return: bb12, unwind continue];
    }

    bb12: {
        _36 = const true;
        _5 = move _21;
        goto -> bb13;
    }

    bb13: {
        _35 = deref_copy ((*_1).2: &theme::Theme);
        _30 = <Theme as output::file_name::Colours>::broken_symlink(_35) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _36 = const false;
        _31 = move _5;
        _29 = TextCell::paint(move _30, move _31) -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _32 = Option::<table::Row>::None;
        _0 = details::Row { cells: move _32, name: move _29, tree: _3 };
        _36 = const false;
        return;
    }

    bb16 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_36) -> [0: bb19, otherwise: bb17];
    }

    bb19 (cleanup): {
        resume;
    }
}

promoted[0] in details::<impl at src/output/details.rs:148:1: 148:20>::render_error: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "<", const ">"];
        _0 = &_1;
        return;
    }
}

promoted[1] in details::<impl at src/output/details.rs:148:1: 148:20>::render_error: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "<", const ": ", const ">"];
        _0 = &_1;
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render_xattr(_1: &details::Render<'_>, _2: &Attribute, _3: TreeParams) -> details::Row {
    debug self => _1;
    debug xattr => _2;
    debug tree => _3;
    let mut _0: output::details::Row;
    let _4: output::cell::TextCell;
    let mut _5: ansi_term::Style;
    let _6: std::string::String;
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 2];
    let _11: [core::fmt::rt::Argument<'_>; 2];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &std::string::String;
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &usize;
    let mut _16: std::option::Option<output::table::Row>;
    let mut _17: &[&str; 3];
    let mut _18: &theme::Theme;
    scope 1 {
        debug name => _4;
    }
    scope 2 {
        debug res => _6;
    }

    bb0: {
        _18 = deref_copy ((*_1).2: &theme::Theme);
        _5 = ((((*_18).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).12: ansi_term::Style);
        _17 = const _;
        _8 = _17 as &[&str] (PointerCoercion(Unsize));
        _13 = &((*_2).0: std::string::String);
        _12 = core::fmt::rt::Argument::<'_>::new_display::<String>(_13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _15 = &((*_2).1: usize);
        _14 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_15) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = [move _12, move _14];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _7 = std::fmt::Arguments::<'_>::new_v1(move _8, move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = format(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = TextCell::paint(move _5, move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _16 = Option::<table::Row>::None;
        _0 = details::Row { cells: move _16, name: move _4, tree: _3 };
        return;
    }
}

promoted[0] in details::<impl at src/output/details.rs:148:1: 148:20>::render_xattr: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const " (len ", const ")"];
        _0 = &_1;
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::render_file(_1: &details::Render<'_>, _2: table::Row, _3: TextCell, _4: TreeParams) -> details::Row {
    debug self => _1;
    debug cells => _2;
    debug name => _3;
    debug tree => _4;
    let mut _0: output::details::Row;
    let mut _5: std::option::Option<output::table::Row>;

    bb0: {
        _5 = Option::<table::Row>::Some(move _2);
        _0 = details::Row { cells: move _5, name: move _3, tree: _4 };
        return;
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::iterate_with_table(_1: &details::Render<'_>, _2: Table<'_>, _3: Vec<details::Row>) -> TableIter<'_> {
    debug self => _1;
    debug table => _2;
    debug rows => _3;
    let mut _0: output::details::TableIter<'_>;
    let mut _4: output::tree::TreeTrunk;
    let mut _5: usize;
    let _6: &output::table::TableWidths;
    let mut _7: &output::table::Table<'_>;
    let mut _8: output::table::Table<'_>;
    let mut _9: std::vec::IntoIter<output::details::Row>;
    let mut _10: std::vec::Vec<output::details::Row>;
    let mut _11: ansi_term::Style;
    let mut _12: &theme::Theme;
    let mut _13: bool;
    let mut _14: bool;

    bb0: {
        _14 = const false;
        _13 = const false;
        _14 = const true;
        _13 = const true;
        _4 = <TreeTrunk as Default>::default() -> [return: bb1, unwind: bb10];
    }

    bb1: {
        _7 = &_2;
        _6 = Table::<'_>::widths(move _7) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _5 = TableWidths::total(_6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _14 = const false;
        _8 = move _2;
        _13 = const false;
        _10 = move _3;
        _9 = <Vec<details::Row> as IntoIterator>::into_iter(move _10) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _12 = deref_copy ((*_1).2: &theme::Theme);
        _11 = (((*_12).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        _0 = TableIter::<'_> { inner: move _9, table: move _8, total_width: move _5, tree_style: move _11, tree_trunk: move _4 };
        return;
    }

    bb5 (cleanup): {
        drop(_8) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        switchInt(_14) -> [0: bb8, otherwise: bb11];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_13) -> [0: bb7, otherwise: bb9];
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }
}

fn details::<impl at src/output/details.rs:148:1: 148:20>::iterate(_1: &details::Render<'_>, _2: Vec<details::Row>) -> details::Iter {
    debug self => _1;
    debug rows => _2;
    let mut _0: output::details::Iter;
    let mut _3: output::tree::TreeTrunk;
    let mut _4: std::vec::IntoIter<output::details::Row>;
    let mut _5: std::vec::Vec<output::details::Row>;
    let mut _6: ansi_term::Style;
    let mut _7: &theme::Theme;
    let mut _8: bool;

    bb0: {
        _8 = const false;
        _8 = const true;
        _3 = <TreeTrunk as Default>::default() -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _8 = const false;
        _5 = move _2;
        _4 = <Vec<details::Row> as IntoIterator>::into_iter(move _5) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _7 = deref_copy ((*_1).2: &theme::Theme);
        _6 = (((*_7).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        _0 = details::Iter { tree_trunk: move _3, tree_style: move _6, inner: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        switchInt(_8) -> [0: bb4, otherwise: bb5];
    }
}

fn details::<impl at src/output/details.rs:421:1: 421:36>::next(_1: &mut TableIter<'_>) -> Option<TextCell> {
    debug self => _1;
    let mut _0: std::option::Option<output::cell::TextCell>;
    let mut _2: std::option::Option<output::details::Row>;
    let mut _3: &mut std::vec::IntoIter<output::details::Row>;
    let mut _4: {closure@src/output/details.rs:425:31: 425:36};
    let mut _5: &mut &mut output::details::TableIter<'_>;

    bb0: {
        _3 = &mut ((*_1).0: std::vec::IntoIter<output::details::Row>);
        _2 = <std::vec::IntoIter<details::Row> as Iterator>::next(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _1;
        _4 = {closure@src/output/details.rs:425:31: 425:36} { self: move _5 };
        _0 = Option::<details::Row>::map::<TextCell, {closure@src/output/details.rs:425:31: 425:36}>(move _2, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn details::<impl at src/output/details.rs:421:1: 421:36>::next::{closure#0}(_1: {closure@src/output/details.rs:425:31: 425:36}, _2: details::Row) -> TextCell {
    debug row => _2;
    debug self => (*(_1.0: &mut &mut output::details::TableIter<'_>));
    let mut _0: output::cell::TextCell;
    let mut _3: output::cell::TextCell;
    let mut _4: isize;
    let mut _6: &output::table::Table<'_>;
    let mut _7: output::cell::TextCell;
    let _8: ();
    let mut _9: &mut output::cell::TextCell;
    let mut _10: usize;
    let mut _11: std::slice::Iter<'_, output::tree::TreePart>;
    let mut _12: &[output::tree::TreePart];
    let mut _13: &mut output::tree::TreeTrunk;
    let mut _14: output::tree::TreeParams;
    let mut _16: std::option::Option<&output::tree::TreePart>;
    let mut _17: &mut std::slice::Iter<'_, output::tree::TreePart>;
    let mut _18: isize;
    let _20: ();
    let mut _21: &mut output::cell::TextCell;
    let mut _22: ansi_term::ANSIGenericString<'_, str>;
    let mut _23: ansi_term::Style;
    let mut _24: &str;
    let mut _25: output::tree::TreePart;
    let mut _26: bool;
    let mut _27: &output::tree::TreeParams;
    let _28: ();
    let mut _29: &mut output::cell::TextCell;
    let _30: ();
    let mut _31: &mut output::cell::TextCell;
    let mut _32: output::cell::TextCell;
    let mut _33: &mut &mut output::details::TableIter<'_>;
    let mut _34: &mut output::details::TableIter<'_>;
    let mut _35: &mut &mut output::details::TableIter<'_>;
    let mut _36: &mut output::details::TableIter<'_>;
    let mut _37: &mut &mut output::details::TableIter<'_>;
    let mut _38: &mut output::details::TableIter<'_>;
    let mut _39: &mut &mut output::details::TableIter<'_>;
    let mut _40: &mut output::details::TableIter<'_>;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: isize;
    let mut _44: isize;
    scope 1 {
        debug cell => _3;
        let mut _15: std::slice::Iter<'_, output::tree::TreePart>;
        scope 4 {
            debug iter => _15;
            let _19: &output::tree::TreePart;
            scope 5 {
                debug tree_part => _19;
            }
        }
    }
    scope 2 {
        debug cells => _5;
        let _5: output::table::Row;
    }
    scope 3 {
        debug cell => _7;
    }

    bb0: {
        _41 = const false;
        _42 = const false;
        _42 = const true;
        _41 = const true;
        _4 = discriminant((_2.0: std::option::Option<output::table::Row>));
        switchInt(move _4) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _41 = const false;
        _5 = move (((_2.0: std::option::Option<output::table::Row>) as Some).0: output::table::Row);
        _33 = deref_copy (_1.0: &mut &mut output::details::TableIter<'_>);
        _34 = deref_copy (*_33);
        _6 = &((*_34).1: output::table::Table<'_>);
        _3 = Table::<'_>::render(move _6, move _5) -> [return: bb30, unwind: bb29];
    }

    bb2: {
        _7 = <TextCell as Default>::default() -> [return: bb3, unwind: bb29];
    }

    bb3: {
        _9 = &mut _7;
        _35 = deref_copy (_1.0: &mut &mut output::details::TableIter<'_>);
        _36 = deref_copy (*_35);
        _10 = ((*_36).2: usize);
        _8 = TextCell::add_spaces(move _9, move _10) -> [return: bb4, unwind: bb20];
    }

    bb4: {
        _3 = move _7;
        goto -> bb5;
    }

    bb5: {
        _37 = deref_copy (_1.0: &mut &mut output::details::TableIter<'_>);
        _38 = deref_copy (*_37);
        _13 = &mut ((*_38).4: output::tree::TreeTrunk);
        _14 = (_2.2: output::tree::TreeParams);
        _12 = TreeTrunk::new_row(move _13, move _14) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _11 = <&[TreePart] as IntoIterator>::into_iter(move _12) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = move _11;
        goto -> bb8;
    }

    bb8: {
        _17 = &mut _15;
        _16 = <std::slice::Iter<'_, TreePart> as Iterator>::next(_17) -> [return: bb9, unwind: bb19];
    }

    bb9: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _19 = ((_16 as Some).0: &output::tree::TreePart);
        _21 = &mut _3;
        _39 = deref_copy (_1.0: &mut &mut output::details::TableIter<'_>);
        _40 = deref_copy (*_39);
        _23 = ((*_40).3: ansi_term::Style);
        _25 = (*_19);
        _24 = TreePart::ascii_art(move _25) -> [return: bb13, unwind: bb19];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _27 = &(_2.2: output::tree::TreeParams);
        _26 = TreeParams::is_at_root(move _27) -> [return: bb15, unwind: bb19];
    }

    bb13: {
        _22 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _23, move _24) -> [return: bb14, unwind: bb19];
    }

    bb14: {
        _20 = TextCell::push(move _21, move _22, const 4_usize) -> [return: bb31, unwind: bb19];
    }

    bb15: {
        switchInt(move _26) -> [0: bb16, otherwise: bb17];
    }

    bb16: {
        _29 = &mut _3;
        _28 = TextCell::add_spaces(move _29, const 1_usize) -> [return: bb32, unwind: bb19];
    }

    bb17: {
        _31 = &mut _3;
        _42 = const false;
        _32 = move (_2.1: output::cell::TextCell);
        _30 = TextCell::append(move _31, move _32) -> [return: bb18, unwind: bb19];
    }

    bb18: {
        _0 = move _3;
        _43 = discriminant((_2.0: std::option::Option<output::table::Row>));
        switchInt(move _43) -> [1: bb23, otherwise: bb22];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop(_7) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }

    bb22: {
        return;
    }

    bb23: {
        switchInt(_41) -> [0: bb22, otherwise: bb24];
    }

    bb24: {
        drop((((_2.0: std::option::Option<output::table::Row>) as Some).0: output::table::Row)) -> [return: bb22, unwind continue];
    }

    bb25 (cleanup): {
        switchInt(_42) -> [0: bb21, otherwise: bb26];
    }

    bb26 (cleanup): {
        drop((_2.1: output::cell::TextCell)) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        switchInt(_41) -> [0: bb25, otherwise: bb28];
    }

    bb28 (cleanup): {
        drop((((_2.0: std::option::Option<output::table::Row>) as Some).0: output::table::Row)) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        _44 = discriminant((_2.0: std::option::Option<output::table::Row>));
        switchInt(move _44) -> [1: bb27, otherwise: bb25];
    }

    bb30: {
        goto -> bb5;
    }

    bb31: {
        goto -> bb8;
    }

    bb32: {
        goto -> bb17;
    }
}

fn details::<impl at src/output/details.rs:459:1: 459:23>::next(_1: &mut details::Iter) -> Option<TextCell> {
    debug self => _1;
    let mut _0: std::option::Option<output::cell::TextCell>;
    let mut _2: std::option::Option<output::details::Row>;
    let mut _3: &mut std::vec::IntoIter<output::details::Row>;
    let mut _4: {closure@src/output/details.rs:463:31: 463:36};
    let mut _5: &mut &mut output::details::Iter;

    bb0: {
        _3 = &mut ((*_1).2: std::vec::IntoIter<output::details::Row>);
        _2 = <std::vec::IntoIter<details::Row> as Iterator>::next(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _1;
        _4 = {closure@src/output/details.rs:463:31: 463:36} { self: move _5 };
        _0 = Option::<details::Row>::map::<TextCell, {closure@src/output/details.rs:463:31: 463:36}>(move _2, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn details::<impl at src/output/details.rs:459:1: 459:23>::next::{closure#0}(_1: {closure@src/output/details.rs:463:31: 463:36}, _2: details::Row) -> TextCell {
    debug row => _2;
    debug self => (*(_1.0: &mut &mut output::details::Iter));
    let mut _0: output::cell::TextCell;
    let mut _3: output::cell::TextCell;
    let mut _4: std::slice::Iter<'_, output::tree::TreePart>;
    let mut _5: &[output::tree::TreePart];
    let mut _6: &mut output::tree::TreeTrunk;
    let mut _7: output::tree::TreeParams;
    let mut _9: std::option::Option<&output::tree::TreePart>;
    let mut _10: &mut std::slice::Iter<'_, output::tree::TreePart>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &mut output::cell::TextCell;
    let mut _15: ansi_term::ANSIGenericString<'_, str>;
    let mut _16: ansi_term::Style;
    let mut _17: &str;
    let mut _18: output::tree::TreePart;
    let mut _19: bool;
    let mut _20: &output::tree::TreeParams;
    let _21: ();
    let mut _22: &mut output::cell::TextCell;
    let _23: ();
    let mut _24: &mut output::cell::TextCell;
    let mut _25: output::cell::TextCell;
    let mut _26: &mut &mut output::details::Iter;
    let mut _27: &mut output::details::Iter;
    let mut _28: &mut &mut output::details::Iter;
    let mut _29: &mut output::details::Iter;
    let mut _30: bool;
    scope 1 {
        debug cell => _3;
        let mut _8: std::slice::Iter<'_, output::tree::TreePart>;
        scope 2 {
            debug iter => _8;
            let _12: &output::tree::TreePart;
            scope 3 {
                debug tree_part => _12;
            }
        }
    }

    bb0: {
        _30 = const false;
        _30 = const true;
        _3 = <TextCell as Default>::default() -> [return: bb1, unwind: bb20];
    }

    bb1: {
        _26 = deref_copy (_1.0: &mut &mut output::details::Iter);
        _27 = deref_copy (*_26);
        _6 = &mut ((*_27).0: output::tree::TreeTrunk);
        _7 = (_2.2: output::tree::TreeParams);
        _5 = TreeTrunk::new_row(move _6, move _7) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _4 = <&[TreePart] as IntoIterator>::into_iter(move _5) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _8 = move _4;
        goto -> bb4;
    }

    bb4: {
        _10 = &mut _8;
        _9 = <std::slice::Iter<'_, TreePart> as Iterator>::next(_10) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _12 = ((_9 as Some).0: &output::tree::TreePart);
        _14 = &mut _3;
        _28 = deref_copy (_1.0: &mut &mut output::details::Iter);
        _29 = deref_copy (*_28);
        _16 = ((*_29).1: ansi_term::Style);
        _18 = (*_12);
        _17 = TreePart::ascii_art(move _18) -> [return: bb9, unwind: bb15];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _20 = &(_2.2: output::tree::TreeParams);
        _19 = TreeParams::is_at_root(move _20) -> [return: bb11, unwind: bb15];
    }

    bb9: {
        _15 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _16, move _17) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _13 = TextCell::push(move _14, move _15, const 4_usize) -> [return: bb21, unwind: bb15];
    }

    bb11: {
        switchInt(move _19) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        _22 = &mut _3;
        _21 = TextCell::add_spaces(move _22, const 1_usize) -> [return: bb22, unwind: bb15];
    }

    bb13: {
        _24 = &mut _3;
        _30 = const false;
        _25 = move (_2.1: output::cell::TextCell);
        _23 = TextCell::append(move _24, move _25) -> [return: bb14, unwind: bb15];
    }

    bb14: {
        _0 = move _3;
        drop((_2.0: std::option::Option<output::table::Row>)) -> [return: bb17, unwind continue];
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        switchInt(_30) -> [0: bb16, otherwise: bb19];
    }

    bb19 (cleanup): {
        drop((_2.1: output::cell::TextCell)) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop((_2.0: std::option::Option<output::table::Row>)) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb21: {
        goto -> bb4;
    }

    bb22: {
        goto -> bb13;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:14:10: 14:15>::fmt(_1: &output::file_name::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::file_name::Classify;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&output::file_name::ShowIcons;
    let _10: &output::file_name::ShowIcons;

    bb0: {
        _3 = const "Options";
        _4 = const "classify";
        _6 = &((*_1).0: output::file_name::Classify);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "show_icons";
        _10 = &((*_1).1: output::file_name::ShowIcons);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:14:23: 14:28>::clone(_1: &output::file_name::Options) -> output::file_name::Options {
    debug self => _1;
    let mut _0: output::file_name::Options;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:24:1: 24:13>::for_file(_1: output::file_name::Options, _2: &file::File<'_>, _3: &C) -> FileName<'_, '_, C> {
    debug self => _1;
    debug file => _2;
    debug colours => _3;
    let mut _0: output::file_name::FileName<'_, '_, C>;
    let mut _4: output::file_name::LinkStyle;
    let mut _5: std::option::Option<fs::file::FileTarget<'_>>;
    let mut _6: bool;
    let mut _7: fs::file::FileTarget<'_>;

    bb0: {
        _4 = LinkStyle::JustFilenames;
        _6 = file::File::<'_>::is_link(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _7 = file::File::<'_>::link_target(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Option::<FileTarget<'_>>::Some(move _7);
        goto -> bb5;
    }

    bb4: {
        _5 = Option::<FileTarget<'_>>::None;
        goto -> bb5;
    }

    bb5: {
        _0 = FileName::<'_, '_, C> { file: _2, colours: _3, target: move _5, link_style: move _4, options: _1 };
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:42:10: 42:19>::eq(_1: &LinkStyle, _2: &LinkStyle) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:42:21: 42:26>::fmt(_1: &LinkStyle, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "FullLinkPaths";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "JustFilenames";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:42:34: 42:39>::clone(_1: &LinkStyle) -> LinkStyle {
    debug self => _1;
    let mut _0: output::file_name::LinkStyle;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:57:10: 57:19>::eq(_1: &Classify, _2: &Classify) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:57:21: 57:26>::fmt(_1: &Classify, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "AddFileIndicators";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "JustFilenames";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:57:34: 57:39>::clone(_1: &Classify) -> Classify {
    debug self => _1;
    let mut _0: output::file_name::Classify;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:68:1: 68:26>::default() -> Classify {
    let mut _0: output::file_name::Classify;

    bb0: {
        _0 = Classify::JustFilenames;
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:76:10: 76:19>::eq(_1: &ShowIcons, _2: &ShowIcons) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&output::file_name::ShowIcons, &output::file_name::ShowIcons);
    let mut _7: isize;
    let mut _8: isize;
    let mut _11: u32;
    let mut _12: u32;
    let mut _13: &output::file_name::ShowIcons;
    let mut _14: &output::file_name::ShowIcons;
    let mut _15: &output::file_name::ShowIcons;
    let mut _16: &output::file_name::ShowIcons;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _9: &u32;
            let _10: &u32;
            scope 3 {
                debug __self_0 => _9;
                debug __arg1_0 => _10;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _13 = deref_copy (_6.0: &output::file_name::ShowIcons);
        _8 = discriminant((*_13));
        switchInt(move _8) -> [1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = const false;
        goto -> bb6;
    }

    bb3: {
        _0 = const true;
        goto -> bb6;
    }

    bb4: {
        _14 = deref_copy (_6.1: &output::file_name::ShowIcons);
        _7 = discriminant((*_14));
        switchInt(move _7) -> [1: bb5, otherwise: bb3];
    }

    bb5: {
        _15 = deref_copy (_6.0: &output::file_name::ShowIcons);
        _9 = &(((*_15) as On).0: u32);
        _16 = deref_copy (_6.1: &output::file_name::ShowIcons);
        _10 = &(((*_16) as On).0: u32);
        _11 = (*_9);
        _12 = (*_10);
        _0 = Eq(move _11, move _12);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:76:21: 76:26>::fmt(_1: &ShowIcons, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &u32;
    let _6: &str;
    let mut _7: &dyn std::fmt::Debug;
    let _8: &&u32;
    scope 1 {
        debug __self_0 => _5;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as On).0: u32);
        _6 = const "On";
        _8 = &_5;
        _7 = _8 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _6, move _7) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "Off";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:76:34: 76:39>::clone(_1: &ShowIcons) -> ShowIcons {
    debug self => _1;
    let mut _0: output::file_name::ShowIcons;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:107:1: 107:40>::with_link_paths(_1: FileName<'_, '_, C>) -> FileName<'_, '_, C> {
    debug self => _1;
    let mut _0: output::file_name::FileName<'_, '_, C>;
    let mut _2: output::file_name::LinkStyle;

    bb0: {
        _2 = LinkStyle::FullLinkPaths;
        (_1.3: output::file_name::LinkStyle) = move _2;
        _0 = move _1;
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:117:1: 117:49>::paint(_1: &FileName<'_, '_, C>) -> TextCellContents {
    debug self => _1;
    let mut _0: output::cell::TextCellContents;
    let mut _2: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let _3: ();
    let mut _4: isize;
    let mut _7: ansi_term::Style;
    let mut _9: &char;
    let _10: char;
    let _11: ();
    let mut _12: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _13: ansi_term::ANSIGenericString<'_, str>;
    let mut _14: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _15: ansi_term::ANSIGenericString<'_, str>;
    let mut _16: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _17: ansi_term::ANSIGenericString<'_, str>;
    let mut _18: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _19: ansi_term::ANSIGenericString<'_, str>;
    let mut _20: std::string::String;
    let mut _21: bool;
    let mut _22: &std::option::Option<&fs::dir::Dir>;
    let mut _23: std::option::Option<&std::path::Path>;
    let _24: &std::path::Path;
    let mut _25: &std::path::PathBuf;
    let mut _26: isize;
    let _28: ();
    let mut _29: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _30: bool;
    let mut _31: &std::string::String;
    let mut _32: std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
    let mut _33: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _35: std::option::Option<ansi_term::ANSIGenericString<'_, str>>;
    let mut _36: &mut std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
    let mut _37: isize;
    let _39: ();
    let mut _40: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _41: (output::file_name::LinkStyle, std::option::Option<&fs::file::FileTarget<'_>>);
    let mut _42: output::file_name::LinkStyle;
    let mut _43: std::option::Option<&fs::file::FileTarget<'_>>;
    let mut _44: &std::option::Option<fs::file::FileTarget<'_>>;
    let mut _45: isize;
    let mut _46: isize;
    let mut _48: isize;
    let _50: ();
    let mut _51: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _52: ansi_term::ANSIGenericString<'_, str>;
    let mut _53: ansi_term::Style;
    let _54: ();
    let mut _55: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _56: ansi_term::ANSIGenericString<'_, str>;
    let mut _57: ansi_term::Style;
    let _58: ();
    let mut _59: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _60: ansi_term::ANSIGenericString<'_, str>;
    let mut _61: ansi_term::Style;
    let mut _62: std::option::Option<&std::path::Path>;
    let _63: &std::path::Path;
    let mut _64: &std::path::PathBuf;
    let mut _65: isize;
    let _67: ();
    let mut _68: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _69: bool;
    let mut _70: &std::string::String;
    let mut _72: output::file_name::Classify;
    let mut _73: output::file_name::ShowIcons;
    let mut _75: &fs::file::File<'_>;
    let mut _76: std::option::Option<fs::file::FileTarget<'_>>;
    let mut _77: output::file_name::LinkStyle;
    let mut _78: std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
    let mut _79: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _80: &output::file_name::FileName<'_, '_, C>;
    let mut _82: std::option::Option<ansi_term::ANSIGenericString<'_, str>>;
    let mut _83: &mut std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
    let mut _84: isize;
    let _86: ();
    let mut _87: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _88: isize;
    let mut _89: std::option::Option<&str>;
    let mut _90: &fs::file::File<'_>;
    let mut _91: isize;
    let _93: ();
    let mut _94: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _95: ansi_term::ANSIGenericString<'_, str>;
    let mut _96: ansi_term::Style;
    let _98: ();
    let mut _99: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _100: ansi_term::ANSIGenericString<'_, str>;
    let mut _101: ansi_term::Style;
    let _102: ();
    let mut _103: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _104: ansi_term::ANSIGenericString<'_, str>;
    let mut _105: ansi_term::Style;
    let _106: ();
    let mut _107: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _108: ansi_term::ANSIGenericString<'_, str>;
    let mut _109: ansi_term::Style;
    let _110: ();
    let mut _111: std::string::String;
    let mut _112: &std::path::Display<'_>;
    let _113: std::path::Display<'_>;
    let _114: &std::path::Path;
    let mut _115: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _116: ansi_term::Style;
    let mut _117: ansi_term::Style;
    let mut _118: isize;
    let mut _119: std::option::Option<&str>;
    let mut _120: isize;
    let _122: ();
    let mut _123: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _124: ansi_term::ANSIGenericString<'_, str>;
    let mut _125: ansi_term::Style;
    let mut _126: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _127: &fs::file::File<'_>;
    let mut _128: &fs::file::File<'_>;
    let mut _129: &fs::file::File<'_>;
    let mut _130: &fs::file::File<'_>;
    let mut _131: &C;
    let mut _132: std::boxed::Box<fs::file::File<'_>>;
    let mut _133: std::boxed::Box<fs::file::File<'_>>;
    let mut _134: std::boxed::Box<fs::file::File<'_>>;
    let mut _135: &C;
    let mut _136: std::boxed::Box<fs::file::File<'_>>;
    let mut _137: &C;
    let mut _138: &C;
    let mut _139: &C;
    let mut _140: &fs::file::File<'_>;
    let mut _141: bool;
    let mut _142: bool;
    let mut _143: *const fs::file::File<'_>;
    let mut _144: *const fs::file::File<'_>;
    let mut _145: *const fs::file::File<'_>;
    let mut _146: *const fs::file::File<'_>;
    scope 1 {
        debug bits => _2;
        let mut _34: std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
        scope 2 {
            debug spaces_count => _5;
            let _5: u32;
            let _6: ansi_term::Style;
            scope 3 {
                debug style => _6;
                let _8: std::string::String;
                scope 4 {
                    debug file_icon => _8;
                    scope 5 {
                        debug n => _5;
                    }
                }
            }
        }
        scope 6 {
            debug parent => _27;
            let _27: &std::path::Path;
        }
        scope 7 {
            debug iter => _34;
            let _38: ansi_term::ANSIGenericString<'_, str>;
            scope 8 {
                debug bit => _38;
            }
        }
        scope 9 {
            debug target => _47;
            let _47: &fs::file::FileTarget<'_>;
            let _49: &std::boxed::Box<fs::file::File<'_>>;
            let _97: &std::path::PathBuf;
            scope 10 {
                debug target => _49;
                let _71: output::file_name::Options;
                scope 11 {
                    debug parent => _66;
                    let _66: &std::path::Path;
                }
                scope 12 {
                    debug target_options => _71;
                    let _74: output::file_name::FileName<'_, '_, C>;
                    scope 13 {
                        debug target_name => _74;
                        let mut _81: std::vec::IntoIter<ansi_term::ANSIGenericString<'_, str>>;
                        scope 14 {
                            debug iter => _81;
                            let _85: ansi_term::ANSIGenericString<'_, str>;
                            scope 15 {
                                debug bit => _85;
                            }
                        }
                        scope 16 {
                            scope 17 {
                                debug class => _92;
                                let _92: &str;
                            }
                        }
                    }
                }
            }
            scope 18 {
                debug broken_path => _97;
            }
        }
        scope 19 {
            scope 20 {
                debug class => _121;
                let _121: &str;
            }
        }
    }

    bb0: {
        _142 = const false;
        _141 = const false;
        _142 = const true;
        _2 = Vec::<ANSIGenericString<'_, str>>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant((((*_1).4: output::file_name::Options).1: output::file_name::ShowIcons));
        switchInt(move _4) -> [1: bb2, otherwise: bb16];
    }

    bb2: {
        _5 = (((((*_1).4: output::file_name::Options).1: output::file_name::ShowIcons) as On).0: u32);
        _7 = FileName::<'_, '_, C>::style(_1) -> [return: bb3, unwind: bb96];
    }

    bb3: {
        _6 = iconify_style(move _7) -> [return: bb4, unwind: bb96];
    }

    bb4: {
        _127 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _10 = icon_for_file(_127) -> [return: bb5, unwind: bb96];
    }

    bb5: {
        _9 = &_10;
        _8 = <char as ToString>::to_string(move _9) -> [return: bb6, unwind: bb96];
    }

    bb6: {
        _12 = &mut _2;
        _13 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_6, move _8) -> [return: bb7, unwind: bb96];
    }

    bb7: {
        _11 = Vec::<ANSIGenericString<'_, str>>::push(move _12, move _13) -> [return: bb8, unwind: bb96];
    }

    bb8: {
        switchInt(_5) -> [1: bb10, 2: bb12, otherwise: bb9];
    }

    bb9: {
        _18 = &mut _2;
        _20 = spaces(_5) -> [return: bb14, unwind: bb96];
    }

    bb10: {
        _14 = &mut _2;
        _15 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(_6, const " ") -> [return: bb11, unwind: bb96];
    }

    bb11: {
        _3 = Vec::<ANSIGenericString<'_, str>>::push(move _14, move _15) -> [return: bb97, unwind: bb96];
    }

    bb12: {
        _16 = &mut _2;
        _17 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(_6, const "  ") -> [return: bb13, unwind: bb96];
    }

    bb13: {
        _3 = Vec::<ANSIGenericString<'_, str>>::push(move _16, move _17) -> [return: bb98, unwind: bb96];
    }

    bb14: {
        _19 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_6, move _20) -> [return: bb15, unwind: bb96];
    }

    bb15: {
        _3 = Vec::<ANSIGenericString<'_, str>>::push(move _18, move _19) -> [return: bb99, unwind: bb96];
    }

    bb16: {
        _128 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _22 = &((*_128).4: std::option::Option<&fs::dir::Dir>);
        _21 = Option::<&Dir>::is_none(move _22) -> [return: bb17, unwind: bb96];
    }

    bb17: {
        switchInt(move _21) -> [0: bb22, otherwise: bb18];
    }

    bb18: {
        _129 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _25 = &((*_129).2: std::path::PathBuf);
        _24 = <PathBuf as Deref>::deref(move _25) -> [return: bb19, unwind: bb96];
    }

    bb19: {
        _23 = Path::parent(_24) -> [return: bb20, unwind: bb96];
    }

    bb20: {
        _26 = discriminant(_23);
        switchInt(move _26) -> [1: bb21, otherwise: bb22];
    }

    bb21: {
        _27 = ((_23 as Some).0: &std::path::Path);
        _29 = &mut _2;
        _28 = FileName::<'_, '_, C>::add_parent_bits(_1, _29, _27) -> [return: bb100, unwind: bb96];
    }

    bb22: {
        _130 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _31 = &((*_130).0: std::string::String);
        _30 = String::is_empty(move _31) -> [return: bb23, unwind: bb96];
    }

    bb23: {
        switchInt(move _30) -> [0: bb24, otherwise: bb32];
    }

    bb24: {
        _33 = FileName::<'_, '_, C>::coloured_file_name::<'_>(_1) -> [return: bb25, unwind: bb96];
    }

    bb25: {
        _32 = <Vec<ANSIGenericString<'_, str>> as IntoIterator>::into_iter(move _33) -> [return: bb26, unwind: bb96];
    }

    bb26: {
        _34 = move _32;
        goto -> bb27;
    }

    bb27: {
        _36 = &mut _34;
        _35 = <std::vec::IntoIter<ANSIGenericString<'_, str>> as Iterator>::next(_36) -> [return: bb28, unwind: bb91];
    }

    bb28: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb31, 1: bb29, otherwise: bb30];
    }

    bb29: {
        _38 = move ((_35 as Some).0: ansi_term::ANSIGenericString<'_, str>);
        _40 = &mut _2;
        _39 = Vec::<ANSIGenericString<'_, str>>::push(move _40, move _38) -> [return: bb101, unwind: bb91];
    }

    bb30: {
        unreachable;
    }

    bb31: {
        drop(_34) -> [return: bb32, unwind: bb96];
    }

    bb32: {
        _42 = ((*_1).3: output::file_name::LinkStyle);
        _44 = &((*_1).2: std::option::Option<fs::file::FileTarget<'_>>);
        _43 = Option::<FileTarget<'_>>::as_ref(move _44) -> [return: bb33, unwind: bb96];
    }

    bb33: {
        _41 = (move _42, move _43);
        _46 = discriminant((_41.0: output::file_name::LinkStyle));
        switchInt(move _46) -> [1: bb34, otherwise: bb81];
    }

    bb34: {
        _45 = discriminant((_41.1: std::option::Option<&fs::file::FileTarget<'_>>));
        switchInt(move _45) -> [1: bb35, otherwise: bb81];
    }

    bb35: {
        _47 = (((_41.1: std::option::Option<&fs::file::FileTarget<'_>>) as Some).0: &fs::file::FileTarget<'_>);
        _48 = discriminant((*_47));
        switchInt(move _48) -> [0: bb36, 1: bb65, 2: bb87, otherwise: bb30];
    }

    bb36: {
        _49 = &(((*_47) as Ok).0: std::boxed::Box<fs::file::File<'_>>);
        _51 = &mut _2;
        _53 = <Style as Default>::default() -> [return: bb37, unwind: bb96];
    }

    bb37: {
        _52 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _53, const " ") -> [return: bb38, unwind: bb96];
    }

    bb38: {
        _50 = Vec::<ANSIGenericString<'_, str>>::push(move _51, move _52) -> [return: bb39, unwind: bb96];
    }

    bb39: {
        _55 = &mut _2;
        _131 = deref_copy ((*_1).1: &C);
        _57 = <C as output::file_name::Colours>::normal_arrow(_131) -> [return: bb40, unwind: bb96];
    }

    bb40: {
        _56 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _57, const "->") -> [return: bb41, unwind: bb96];
    }

    bb41: {
        _54 = Vec::<ANSIGenericString<'_, str>>::push(move _55, move _56) -> [return: bb42, unwind: bb96];
    }

    bb42: {
        _59 = &mut _2;
        _61 = <Style as Default>::default() -> [return: bb43, unwind: bb96];
    }

    bb43: {
        _60 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _61, const " ") -> [return: bb44, unwind: bb96];
    }

    bb44: {
        _58 = Vec::<ANSIGenericString<'_, str>>::push(move _59, move _60) -> [return: bb45, unwind: bb96];
    }

    bb45: {
        _132 = deref_copy (*_49);
        _143 = (((_132.0: std::ptr::Unique<fs::file::File<'_>>).0: std::ptr::NonNull<fs::file::File<'_>>).0: *const fs::file::File<'_>);
        _64 = &((*_143).2: std::path::PathBuf);
        _63 = <PathBuf as Deref>::deref(move _64) -> [return: bb46, unwind: bb96];
    }

    bb46: {
        _62 = Path::parent(_63) -> [return: bb47, unwind: bb96];
    }

    bb47: {
        _65 = discriminant(_62);
        switchInt(move _65) -> [1: bb48, otherwise: bb49];
    }

    bb48: {
        _66 = ((_62 as Some).0: &std::path::Path);
        _68 = &mut _2;
        _67 = FileName::<'_, '_, C>::add_parent_bits(_1, _68, _66) -> [return: bb102, unwind: bb96];
    }

    bb49: {
        _133 = deref_copy (*_49);
        _144 = (((_133.0: std::ptr::Unique<fs::file::File<'_>>).0: std::ptr::NonNull<fs::file::File<'_>>).0: *const fs::file::File<'_>);
        _70 = &((*_144).0: std::string::String);
        _69 = String::is_empty(move _70) -> [return: bb50, unwind: bb96];
    }

    bb50: {
        switchInt(move _69) -> [0: bb51, otherwise: bb87];
    }

    bb51: {
        _72 = Classify::JustFilenames;
        _73 = ShowIcons::Off;
        _71 = output::file_name::Options { classify: move _72, show_icons: move _73 };
        _134 = deref_copy (*_49);
        _145 = (((_134.0: std::ptr::Unique<fs::file::File<'_>>).0: std::ptr::NonNull<fs::file::File<'_>>).0: *const fs::file::File<'_>);
        _75 = &(*_145);
        _135 = deref_copy ((*_1).1: &C);
        _76 = Option::<FileTarget<'_>>::None;
        _77 = LinkStyle::FullLinkPaths;
        _74 = FileName::<'_, '_, C> { file: move _75, colours: _135, target: move _76, link_style: move _77, options: _71 };
        _80 = &_74;
        _79 = FileName::<'_, '_, C>::coloured_file_name::<'_>(move _80) -> [return: bb52, unwind: bb90];
    }

    bb52: {
        _78 = <Vec<ANSIGenericString<'_, str>> as IntoIterator>::into_iter(move _79) -> [return: bb53, unwind: bb90];
    }

    bb53: {
        _81 = move _78;
        goto -> bb54;
    }

    bb54: {
        _83 = &mut _81;
        _82 = <std::vec::IntoIter<ANSIGenericString<'_, str>> as Iterator>::next(_83) -> [return: bb55, unwind: bb89];
    }

    bb55: {
        _84 = discriminant(_82);
        switchInt(move _84) -> [0: bb57, 1: bb56, otherwise: bb30];
    }

    bb56: {
        _85 = move ((_82 as Some).0: ansi_term::ANSIGenericString<'_, str>);
        _87 = &mut _2;
        _86 = Vec::<ANSIGenericString<'_, str>>::push(move _87, move _85) -> [return: bb103, unwind: bb89];
    }

    bb57: {
        drop(_81) -> [return: bb58, unwind: bb90];
    }

    bb58: {
        _88 = discriminant((((*_1).4: output::file_name::Options).0: output::file_name::Classify));
        switchInt(move _88) -> [1: bb59, otherwise: bb64];
    }

    bb59: {
        _136 = deref_copy (*_49);
        _146 = (((_136.0: std::ptr::Unique<fs::file::File<'_>>).0: std::ptr::NonNull<fs::file::File<'_>>).0: *const fs::file::File<'_>);
        _90 = &(*_146);
        _89 = FileName::<'_, '_, C>::classify_char(_1, move _90) -> [return: bb60, unwind: bb90];
    }

    bb60: {
        _91 = discriminant(_89);
        switchInt(move _91) -> [1: bb61, otherwise: bb64];
    }

    bb61: {
        _92 = ((_89 as Some).0: &str);
        _94 = &mut _2;
        _96 = <Style as Default>::default() -> [return: bb62, unwind: bb90];
    }

    bb62: {
        _95 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _96, _92) -> [return: bb63, unwind: bb90];
    }

    bb63: {
        _93 = Vec::<ANSIGenericString<'_, str>>::push(move _94, move _95) -> [return: bb104, unwind: bb90];
    }

    bb64: {
        drop(_74) -> [return: bb87, unwind: bb96];
    }

    bb65: {
        _97 = &(((*_47) as Broken).0: std::path::PathBuf);
        _99 = &mut _2;
        _101 = <Style as Default>::default() -> [return: bb66, unwind: bb96];
    }

    bb66: {
        _100 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _101, const " ") -> [return: bb67, unwind: bb96];
    }

    bb67: {
        _98 = Vec::<ANSIGenericString<'_, str>>::push(move _99, move _100) -> [return: bb68, unwind: bb96];
    }

    bb68: {
        _103 = &mut _2;
        _137 = deref_copy ((*_1).1: &C);
        _105 = <C as output::file_name::Colours>::broken_symlink(_137) -> [return: bb69, unwind: bb96];
    }

    bb69: {
        _104 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _105, const "->") -> [return: bb70, unwind: bb96];
    }

    bb70: {
        _102 = Vec::<ANSIGenericString<'_, str>>::push(move _103, move _104) -> [return: bb71, unwind: bb96];
    }

    bb71: {
        _107 = &mut _2;
        _109 = <Style as Default>::default() -> [return: bb72, unwind: bb96];
    }

    bb72: {
        _108 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _109, const " ") -> [return: bb73, unwind: bb96];
    }

    bb73: {
        _106 = Vec::<ANSIGenericString<'_, str>>::push(move _107, move _108) -> [return: bb74, unwind: bb96];
    }

    bb74: {
        _114 = <PathBuf as Deref>::deref(_97) -> [return: bb75, unwind: bb96];
    }

    bb75: {
        _113 = Path::display(_114) -> [return: bb76, unwind: bb96];
    }

    bb76: {
        _112 = &_113;
        _111 = <std::path::Display<'_> as ToString>::to_string(move _112) -> [return: bb77, unwind: bb96];
    }

    bb77: {
        _141 = const true;
        _115 = &mut _2;
        _138 = deref_copy ((*_1).1: &C);
        _116 = <C as output::file_name::Colours>::broken_filename(_138) -> [return: bb78, unwind: bb94];
    }

    bb78: {
        _139 = deref_copy ((*_1).1: &C);
        _117 = <C as output::file_name::Colours>::broken_control_char(_139) -> [return: bb79, unwind: bb94];
    }

    bb79: {
        _141 = const false;
        _110 = escape(move _111, _115, move _116, move _117) -> [return: bb80, unwind: bb94];
    }

    bb80: {
        _141 = const false;
        goto -> bb87;
    }

    bb81: {
        _118 = discriminant((((*_1).4: output::file_name::Options).0: output::file_name::Classify));
        switchInt(move _118) -> [1: bb82, otherwise: bb87];
    }

    bb82: {
        _140 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _119 = FileName::<'_, '_, C>::classify_char(_1, _140) -> [return: bb83, unwind: bb96];
    }

    bb83: {
        _120 = discriminant(_119);
        switchInt(move _120) -> [1: bb84, otherwise: bb87];
    }

    bb84: {
        _121 = ((_119 as Some).0: &str);
        _123 = &mut _2;
        _125 = <Style as Default>::default() -> [return: bb85, unwind: bb96];
    }

    bb85: {
        _124 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _125, _121) -> [return: bb86, unwind: bb96];
    }

    bb86: {
        _122 = Vec::<ANSIGenericString<'_, str>>::push(move _123, move _124) -> [return: bb105, unwind: bb96];
    }

    bb87: {
        _142 = const false;
        _126 = move _2;
        _0 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _126) -> [return: bb88, unwind: bb96];
    }

    bb88: {
        _142 = const false;
        return;
    }

    bb89 (cleanup): {
        drop(_81) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        drop(_74) -> [return: bb96, unwind terminate(cleanup)];
    }

    bb91 (cleanup): {
        drop(_34) -> [return: bb96, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        resume;
    }

    bb93 (cleanup): {
        drop(_111) -> [return: bb96, unwind terminate(cleanup)];
    }

    bb94 (cleanup): {
        switchInt(_141) -> [0: bb96, otherwise: bb93];
    }

    bb95 (cleanup): {
        drop(_2) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb96 (cleanup): {
        switchInt(_142) -> [0: bb92, otherwise: bb95];
    }

    bb97: {
        goto -> bb16;
    }

    bb98: {
        goto -> bb16;
    }

    bb99: {
        goto -> bb16;
    }

    bb100: {
        goto -> bb22;
    }

    bb101: {
        goto -> bb27;
    }

    bb102: {
        goto -> bb49;
    }

    bb103: {
        goto -> bb54;
    }

    bb104: {
        goto -> bb64;
    }

    bb105: {
        goto -> bb87;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:117:1: 117:49>::add_parent_bits(_1: &FileName<'_, '_, C>, _2: &mut Vec<ANSIGenericString<'_, str>>, _3: &Path) -> () {
    debug self => _1;
    debug bits => _2;
    debug parent => _3;
    let mut _0: ();
    let _4: usize;
    let mut _5: std::path::Components<'_>;
    let mut _6: bool;
    let _7: ();
    let mut _8: ansi_term::ANSIGenericString<'_, str>;
    let mut _9: ansi_term::Style;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::string::String;
    let mut _13: &std::borrow::Cow<'_, str>;
    let _14: std::borrow::Cow<'_, str>;
    let mut _15: ansi_term::Style;
    let mut _16: ansi_term::Style;
    let _17: ();
    let mut _18: ansi_term::ANSIGenericString<'_, str>;
    let mut _19: ansi_term::Style;
    let mut _20: &C;
    let mut _21: &C;
    let mut _22: &C;
    let mut _23: &C;
    let mut _24: bool;
    scope 1 {
        debug coconut => _4;
    }

    bb0: {
        _24 = const false;
        _5 = Path::components(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Components<'_> as Iterator>::count(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [1: bb3, otherwise: bb8];
    }

    bb3: {
        _6 = Path::has_root(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _6) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _20 = deref_copy ((*_1).1: &C);
        _9 = <C as output::file_name::Colours>::symlink_path(_20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "/") -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = Vec::<ANSIGenericString<'_, str>>::push(_2, move _8) -> [return: bb18, unwind continue];
    }

    bb8: {
        _10 = Ge(_4, const 1_usize);
        switchInt(move _10) -> [0: bb18, otherwise: bb9];
    }

    bb9: {
        _14 = Path::to_string_lossy(_3) -> [return: bb10, unwind continue];
    }

    bb10: {
        _13 = &_14;
        _12 = <Cow<'_, str> as ToString>::to_string(move _13) -> [return: bb11, unwind: bb19];
    }

    bb11: {
        _24 = const true;
        _21 = deref_copy ((*_1).1: &C);
        _15 = <C as output::file_name::Colours>::symlink_path(_21) -> [return: bb12, unwind: bb22];
    }

    bb12: {
        _22 = deref_copy ((*_1).1: &C);
        _16 = <C as output::file_name::Colours>::control_char(_22) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _24 = const false;
        _11 = escape(move _12, _2, move _15, move _16) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _24 = const false;
        drop(_14) -> [return: bb15, unwind continue];
    }

    bb15: {
        _23 = deref_copy ((*_1).1: &C);
        _19 = <C as output::file_name::Colours>::symlink_path(_23) -> [return: bb16, unwind continue];
    }

    bb16: {
        _18 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _19, const "/") -> [return: bb17, unwind continue];
    }

    bb17: {
        _17 = Vec::<ANSIGenericString<'_, str>>::push(_2, move _18) -> [return: bb18, unwind continue];
    }

    bb18: {
        return;
    }

    bb19 (cleanup): {
        drop(_14) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21 (cleanup): {
        drop(_12) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        switchInt(_24) -> [0: bb19, otherwise: bb21];
    }
}

fn output::file_name::<impl at src/output/file_name.rs:117:1: 117:49>::classify_char(_1: &FileName<'_, '_, C>, _2: &file::File<'_>) -> Option<&str> {
    debug self => _1;
    debug file => _2;
    let mut _0: std::option::Option<&str>;
    let mut _3: bool;
    let _4: &str;
    let mut _5: bool;
    let _6: &str;
    let mut _7: bool;
    let _8: &str;
    let mut _9: bool;
    let _10: &str;
    let mut _11: bool;
    let _12: &str;

    bb0: {
        _3 = file::File::<'_>::is_executable_file(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _4 = const "*";
        _0 = Option::<&str>::Some(_4);
        goto -> bb16;
    }

    bb3: {
        _5 = file::File::<'_>::is_directory(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _6 = const "/";
        _0 = Option::<&str>::Some(_6);
        goto -> bb16;
    }

    bb6: {
        _7 = file::File::<'_>::is_pipe(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _7) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _8 = const "|";
        _0 = Option::<&str>::Some(_8);
        goto -> bb16;
    }

    bb9: {
        _9 = file::File::<'_>::is_link(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _9) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _10 = const "@";
        _0 = Option::<&str>::Some(_10);
        goto -> bb16;
    }

    bb12: {
        _11 = file::File::<'_>::is_socket(_2) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _11) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _12 = const "=";
        _0 = Option::<&str>::Some(_12);
        goto -> bb16;
    }

    bb15: {
        _0 = Option::<&str>::None;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn output::file_name::<impl at src/output/file_name.rs:117:1: 117:49>::coloured_file_name(_1: &FileName<'_, '_, C>) -> Vec<ANSIGenericString<'_, str>> {
    debug self => _1;
    let mut _0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let _2: ansi_term::Style;
    let _4: ();
    let mut _5: std::string::String;
    let mut _6: &std::string::String;
    let mut _7: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _8: ansi_term::Style;
    let mut _9: &fs::file::File<'_>;
    let mut _10: &C;
    let mut _11: bool;
    scope 1 {
        debug file_style => _2;
        let mut _3: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
        scope 2 {
            debug bits => _3;
        }
    }

    bb0: {
        _11 = const false;
        _2 = FileName::<'_, '_, C>::style(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Vec::<ANSIGenericString<'_, str>>::new() -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _6 = &((*_9).0: std::string::String);
        _5 = <String as Clone>::clone(move _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _11 = const true;
        _7 = &mut _3;
        _10 = deref_copy ((*_1).1: &C);
        _8 = <C as output::file_name::Colours>::control_char(_10) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _11 = const false;
        _4 = escape(move _5, _7, _2, move _8) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _11 = const false;
        _0 = move _3;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        switchInt(_11) -> [0: bb6, otherwise: bb8];
    }
}

fn output::file_name::<impl at src/output/file_name.rs:117:1: 117:49>::style(_1: &FileName<'_, '_, C>) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;
    let mut _2: isize;
    let mut _3: isize;
    let mut _5: bool;
    let _6: &fs::file::File<'_>;
    let _7: &&fs::file::File<'_>;
    let mut _8: bool;
    let _9: &fs::file::File<'_>;
    let _10: &&fs::file::File<'_>;
    let mut _11: bool;
    let _12: &fs::file::File<'_>;
    let _13: &&fs::file::File<'_>;
    let mut _14: bool;
    let _15: &fs::file::File<'_>;
    let _16: &&fs::file::File<'_>;
    let mut _17: bool;
    let _18: &fs::file::File<'_>;
    let _19: &&fs::file::File<'_>;
    let mut _20: bool;
    let _21: &fs::file::File<'_>;
    let _22: &&fs::file::File<'_>;
    let mut _23: bool;
    let _24: &fs::file::File<'_>;
    let _25: &&fs::file::File<'_>;
    let mut _26: bool;
    let _27: &fs::file::File<'_>;
    let _28: &&fs::file::File<'_>;
    let mut _29: bool;
    let mut _30: &C;
    let mut _31: &fs::file::File<'_>;
    let mut _32: &C;
    let mut _33: &fs::file::File<'_>;
    let mut _34: &C;
    let mut _35: &fs::file::File<'_>;
    let mut _36: &C;
    let mut _37: &fs::file::File<'_>;
    let mut _38: &C;
    let mut _39: &fs::file::File<'_>;
    let mut _40: &C;
    let mut _41: &fs::file::File<'_>;
    let mut _42: &C;
    let mut _43: &fs::file::File<'_>;
    let mut _44: &C;
    let mut _45: &fs::file::File<'_>;
    let mut _46: &C;
    let mut _47: &fs::file::File<'_>;
    let mut _48: &C;
    scope 1 {
        scope 2 {
            debug target => _4;
            let _4: &fs::file::FileTarget<'_>;
        }
    }
    scope 3 {
        debug f => _6;
        debug f => _7;
    }
    scope 4 {
        debug f => _9;
        debug f => _10;
    }
    scope 5 {
        debug f => _12;
        debug f => _13;
    }
    scope 6 {
        debug f => _15;
        debug f => _16;
    }
    scope 7 {
        debug f => _18;
        debug f => _19;
    }
    scope 8 {
        debug f => _21;
        debug f => _22;
    }
    scope 9 {
        debug f => _24;
        debug f => _25;
    }
    scope 10 {
        debug f => _27;
        debug f => _28;
    }

    bb0: {
        _2 = discriminant(((*_1).3: output::file_name::LinkStyle));
        switchInt(move _2) -> [0: bb1, otherwise: bb5];
    }

    bb1: {
        _3 = discriminant(((*_1).2: std::option::Option<fs::file::FileTarget<'_>>));
        switchInt(move _3) -> [1: bb2, otherwise: bb5];
    }

    bb2: {
        _4 = &((((*_1).2: std::option::Option<fs::file::FileTarget<'_>>) as Some).0: fs::file::FileTarget<'_>);
        _5 = FileTarget::<'_>::is_broken(_4) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _30 = deref_copy ((*_1).1: &C);
        _0 = <C as output::file_name::Colours>::broken_symlink(_30) -> [return: bb30, unwind continue];
    }

    bb5: {
        _7 = &((*_1).0: &fs::file::File<'_>);
        _31 = deref_copy (*_7);
        _8 = file::File::<'_>::is_directory(_31) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _8) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _6 = ((*_1).0: &fs::file::File<'_>);
        _32 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::directory(_32) -> [return: bb30, unwind continue];
    }

    bb8: {
        _10 = &((*_1).0: &fs::file::File<'_>);
        _33 = deref_copy (*_10);
        _11 = file::File::<'_>::is_executable_file(_33) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _11) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _9 = ((*_1).0: &fs::file::File<'_>);
        _34 = deref_copy ((*_1).1: &C);
        _0 = <C as output::file_name::Colours>::executable_file(_34) -> [return: bb30, unwind continue];
    }

    bb11: {
        _13 = &((*_1).0: &fs::file::File<'_>);
        _35 = deref_copy (*_13);
        _14 = file::File::<'_>::is_link(_35) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _14) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _12 = ((*_1).0: &fs::file::File<'_>);
        _36 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::symlink(_36) -> [return: bb30, unwind continue];
    }

    bb14: {
        _16 = &((*_1).0: &fs::file::File<'_>);
        _37 = deref_copy (*_16);
        _17 = file::File::<'_>::is_pipe(_37) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _17) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _15 = ((*_1).0: &fs::file::File<'_>);
        _38 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::pipe(_38) -> [return: bb30, unwind continue];
    }

    bb17: {
        _19 = &((*_1).0: &fs::file::File<'_>);
        _39 = deref_copy (*_19);
        _20 = file::File::<'_>::is_block_device(_39) -> [return: bb18, unwind continue];
    }

    bb18: {
        switchInt(move _20) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _18 = ((*_1).0: &fs::file::File<'_>);
        _40 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::block_device(_40) -> [return: bb30, unwind continue];
    }

    bb20: {
        _22 = &((*_1).0: &fs::file::File<'_>);
        _41 = deref_copy (*_22);
        _23 = file::File::<'_>::is_char_device(_41) -> [return: bb21, unwind continue];
    }

    bb21: {
        switchInt(move _23) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _21 = ((*_1).0: &fs::file::File<'_>);
        _42 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::char_device(_42) -> [return: bb30, unwind continue];
    }

    bb23: {
        _25 = &((*_1).0: &fs::file::File<'_>);
        _43 = deref_copy (*_25);
        _26 = file::File::<'_>::is_socket(_43) -> [return: bb24, unwind continue];
    }

    bb24: {
        switchInt(move _26) -> [0: bb26, otherwise: bb25];
    }

    bb25: {
        _24 = ((*_1).0: &fs::file::File<'_>);
        _44 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::socket(_44) -> [return: bb30, unwind continue];
    }

    bb26: {
        _28 = &((*_1).0: &fs::file::File<'_>);
        _45 = deref_copy (*_28);
        _29 = file::File::<'_>::is_file(_45) -> [return: bb27, unwind continue];
    }

    bb27: {
        switchInt(move _29) -> [0: bb29, otherwise: bb28];
    }

    bb28: {
        _46 = deref_copy ((*_1).1: &C);
        _47 = deref_copy ((*_1).0: &fs::file::File<'_>);
        _0 = <C as output::file_name::Colours>::colour_file(_46, _47) -> [return: bb30, unwind continue];
    }

    bb29: {
        _27 = ((*_1).0: &fs::file::File<'_>);
        _48 = deref_copy ((*_1).1: &C);
        _0 = <C as render::filetype::Colours>::special(_48) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }
}

fn spaces(_1: u32) -> String {
    debug width => _1;
    let mut _0: std::string::String;
    let mut _2: std::iter::Map<std::ops::Range<u32>, {closure@src/output/file_name.rs:351:34: 351:37}>;
    let mut _3: std::ops::Range<u32>;
    let mut _4: std::ops::Range<u32>;

    bb0: {
        _4 = std::ops::Range::<u32> { start: const 0_u32, end: _1 };
        _3 = <std::ops::Range<u32> as IntoIterator>::into_iter(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::ops::Range<u32> as Iterator>::map::<char, {closure@src/output/file_name.rs:351:34: 351:37}>(move _3, const ZeroSized: {closure@src/output/file_name.rs:351:34: 351:37}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Map<std::ops::Range<u32>, {closure@src/output/file_name.rs:351:34: 351:37}> as Iterator>::collect::<String>(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn spaces::{closure#0}(_1: &mut {closure@src/output/file_name.rs:351:34: 351:37}, _2: u32) -> char {
    let mut _0: char;

    bb0: {
        _0 = const ' ';
        return;
    }
}

fn grid::<impl at src/output/grid.rs:11:10: 11:19>::eq(_1: &grid::Options, _2: &grid::Options) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;

    bb0: {
        _3 = ((*_1).0: bool);
        _4 = ((*_2).0: bool);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn grid::<impl at src/output/grid.rs:11:21: 11:26>::fmt(_1: &grid::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&bool;
    let _7: &bool;

    bb0: {
        _3 = const "Options";
        _4 = const "across";
        _7 = &((*_1).0: bool);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn grid::<impl at src/output/grid.rs:11:34: 11:39>::clone(_1: &grid::Options) -> grid::Options {
    debug self => _1;
    let mut _0: output::grid::Options;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn grid::<impl at src/output/grid.rs:16:1: 16:13>::direction(_1: grid::Options) -> term_grid::Direction {
    debug self => _1;
    let mut _0: term_grid::Direction;
    let mut _2: bool;

    bb0: {
        _2 = (_1.0: bool);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = LeftToRight;
        goto -> bb3;
    }

    bb2: {
        _0 = TopToBottom;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn grid::<impl at src/output/grid.rs:33:1: 33:20>::render(_1: grid::Render<'_>, _2: &mut W) -> Result<(), std::io::Error> {
    debug self => _1;
    debug w => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: term_grid::Grid;
    let mut _4: term_grid::GridOptions;
    let mut _5: term_grid::Direction;
    let mut _6: output::grid::Options;
    let mut _7: term_grid::Filling;
    let _8: ();
    let mut _9: &mut term_grid::Grid;
    let mut _10: usize;
    let mut _11: &std::vec::Vec<fs::file::File<'_>>;
    let _12: ();
    let mut _13: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _14: std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _15: &std::vec::Vec<fs::file::File<'_>>;
    let mut _17: std::option::Option<&fs::file::File<'_>>;
    let mut _18: &mut std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _19: isize;
    let mut _22: &output::file_name::FileName<'_, '_, theme::Theme>;
    let _23: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _24: output::file_name::Options;
    let _25: ();
    let mut _26: &mut term_grid::Grid;
    let mut _27: term_grid::Cell;
    let mut _28: std::string::String;
    let mut _29: &ansi_term::ANSIGenericStrings<'_, str>;
    let _30: ansi_term::ANSIGenericStrings<'_, str>;
    let mut _31: &output::cell::TextCellContents;
    let mut _32: usize;
    let mut _33: &usize;
    let mut _34: &output::cell::DisplayWidth;
    let _35: output::cell::DisplayWidth;
    let mut _36: &output::cell::TextCellContents;
    let mut _37: std::option::Option<term_grid::Display<'_>>;
    let mut _38: &term_grid::Grid;
    let mut _39: usize;
    let mut _40: isize;
    let mut _42: std::fmt::Arguments<'_>;
    let mut _43: &[&str];
    let mut _44: &[core::fmt::rt::Argument<'_>];
    let _45: &[core::fmt::rt::Argument<'_>; 1];
    let _46: [core::fmt::rt::Argument<'_>; 1];
    let mut _47: core::fmt::rt::Argument<'_>;
    let _48: &term_grid::Display<'_>;
    let mut _49: std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _50: &std::vec::Vec<fs::file::File<'_>>;
    let mut _52: std::option::Option<&fs::file::File<'_>>;
    let mut _53: &mut std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _54: isize;
    let mut _57: &output::file_name::FileName<'_, '_, theme::Theme>;
    let _58: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _59: output::file_name::Options;
    let mut _60: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _61: std::result::Result<(), std::io::Error>;
    let mut _62: std::fmt::Arguments<'_>;
    let mut _63: &[&str];
    let mut _64: &[core::fmt::rt::Argument<'_>];
    let _65: &[core::fmt::rt::Argument<'_>; 1];
    let _66: [core::fmt::rt::Argument<'_>; 1];
    let mut _67: core::fmt::rt::Argument<'_>;
    let _68: &ansi_term::ANSIGenericStrings<'_, str>;
    let _69: ansi_term::ANSIGenericStrings<'_, str>;
    let mut _70: &output::cell::TextCellContents;
    let mut _71: isize;
    let mut _75: &output::grid::Options;
    let mut _76: &fs::filter::FileFilter;
    let mut _77: &output::file_name::Options;
    let mut _78: &theme::Theme;
    let mut _79: &output::file_name::Options;
    let mut _80: &theme::Theme;
    let mut _81: bool;
    let mut _82: isize;
    let mut _83: isize;
    scope 1 {
        debug grid => _3;
        let mut _16: std::slice::Iter<'_, fs::file::File<'_>>;
        let mut _51: std::slice::Iter<'_, fs::file::File<'_>>;
        scope 2 {
            debug iter => _16;
            let _20: &fs::file::File<'_>;
            scope 3 {
                debug file => _20;
                let _21: output::cell::TextCellContents;
                scope 4 {
                    debug filename => _21;
                }
            }
        }
        scope 5 {
            debug display => _41;
            let _41: term_grid::Display<'_>;
            let mut _74: &[&str; 1];
        }
        scope 6 {
            debug iter => _51;
            let _55: &fs::file::File<'_>;
            scope 7 {
                debug file => _55;
                let _56: output::cell::TextCellContents;
                scope 8 {
                    debug name_cell => _56;
                    let _72: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let mut _73: &[&str; 2];
                    scope 9 {
                        debug residual => _72;
                        scope 10 {
                        }
                    }
                    scope 11 {
                        debug val => const ();
                        scope 12 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _81 = const false;
        _75 = deref_copy (_1.3: &output::grid::Options);
        _6 = (*_75);
        _5 = grid::Options::direction(move _6) -> [return: bb1, unwind: bb56];
    }

    bb1: {
        _7 = Spaces(const 2_usize);
        _4 = GridOptions { direction: move _5, filling: move _7 };
        _3 = Grid::new(move _4) -> [return: bb2, unwind: bb56];
    }

    bb2: {
        _9 = &mut _3;
        _11 = &(_1.0: std::vec::Vec<fs::file::File<'_>>);
        _10 = Vec::<file::File<'_>>::len(move _11) -> [return: bb3, unwind: bb55];
    }

    bb3: {
        _8 = Grid::reserve(move _9, move _10) -> [return: bb4, unwind: bb55];
    }

    bb4: {
        _76 = deref_copy (_1.5: &fs::filter::FileFilter);
        _13 = &mut (_1.0: std::vec::Vec<fs::file::File<'_>>);
        _12 = FileFilter::sort_files::<'_, file::File<'_>>(_76, _13) -> [return: bb5, unwind: bb55];
    }

    bb5: {
        _15 = &(_1.0: std::vec::Vec<fs::file::File<'_>>);
        _14 = <&Vec<file::File<'_>> as IntoIterator>::into_iter(move _15) -> [return: bb6, unwind: bb55];
    }

    bb6: {
        _16 = move _14;
        goto -> bb7;
    }

    bb7: {
        _18 = &mut _16;
        _17 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::next(_18) -> [return: bb8, unwind: bb55];
    }

    bb8: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _20 = ((_17 as Some).0: &fs::file::File<'_>);
        _77 = deref_copy (_1.2: &output::file_name::Options);
        _24 = (*_77);
        _78 = deref_copy (_1.1: &theme::Theme);
        _23 = output::file_name::Options::for_file::<Theme>(move _24, _20, _78) -> [return: bb12, unwind: bb55];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _38 = &_3;
        _39 = (_1.4: usize);
        _37 = Grid::fit_into_width(move _38, move _39) -> [return: bb20, unwind: bb55];
    }

    bb12: {
        _22 = &_23;
        _21 = FileName::<'_, '_, Theme>::paint(move _22) -> [return: bb13, unwind: bb54];
    }

    bb13: {
        drop(_23) -> [return: bb14, unwind: bb53];
    }

    bb14: {
        _26 = &mut _3;
        _31 = &_21;
        _30 = TextCellContents::strings(move _31) -> [return: bb15, unwind: bb53];
    }

    bb15: {
        _29 = &_30;
        _28 = <ANSIGenericStrings<'_, str> as ToString>::to_string(move _29) -> [return: bb16, unwind: bb53];
    }

    bb16: {
        _36 = &_21;
        _35 = TextCellContents::width(move _36) -> [return: bb17, unwind: bb52];
    }

    bb17: {
        _34 = &_35;
        _33 = <DisplayWidth as Deref>::deref(move _34) -> [return: bb18, unwind: bb52];
    }

    bb18: {
        _32 = (*_33);
        _27 = term_grid::Cell { contents: move _28, width: move _32 };
        _25 = Grid::add(move _26, move _27) -> [return: bb19, unwind: bb53];
    }

    bb19: {
        drop(_21) -> [return: bb7, unwind: bb55];
    }

    bb20: {
        _81 = const true;
        _40 = discriminant(_37);
        switchInt(move _40) -> [1: bb21, otherwise: bb25];
    }

    bb21: {
        _81 = const false;
        _41 = move ((_37 as Some).0: term_grid::Display<'_>);
        _74 = const _;
        _43 = _74 as &[&str] (PointerCoercion(Unsize));
        _48 = &_41;
        _47 = core::fmt::rt::Argument::<'_>::new_display::<term_grid::Display<'_>>(_48) -> [return: bb22, unwind: bb50];
    }

    bb22: {
        _46 = [move _47];
        _45 = &_46;
        _44 = _45 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _42 = std::fmt::Arguments::<'_>::new_v1(move _43, move _44) -> [return: bb23, unwind: bb50];
    }

    bb23: {
        _0 = <W as std::io::Write>::write_fmt(_2, move _42) -> [return: bb24, unwind: bb50];
    }

    bb24: {
        drop(_41) -> [return: bb42, unwind: bb51];
    }

    bb25: {
        _50 = &(_1.0: std::vec::Vec<fs::file::File<'_>>);
        _49 = <&Vec<file::File<'_>> as IntoIterator>::into_iter(move _50) -> [return: bb26, unwind: bb51];
    }

    bb26: {
        _51 = move _49;
        goto -> bb27;
    }

    bb27: {
        _53 = &mut _51;
        _52 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::next(_53) -> [return: bb28, unwind: bb51];
    }

    bb28: {
        _54 = discriminant(_52);
        switchInt(move _54) -> [0: bb30, 1: bb29, otherwise: bb10];
    }

    bb29: {
        _55 = ((_52 as Some).0: &fs::file::File<'_>);
        _79 = deref_copy (_1.2: &output::file_name::Options);
        _59 = (*_79);
        _80 = deref_copy (_1.1: &theme::Theme);
        _58 = output::file_name::Options::for_file::<Theme>(move _59, _55, _80) -> [return: bb31, unwind: bb51];
    }

    bb30: {
        _0 = Result::<(), std::io::Error>::Ok(const ());
        goto -> bb42;
    }

    bb31: {
        _57 = &_58;
        _56 = FileName::<'_, '_, Theme>::paint(move _57) -> [return: bb32, unwind: bb49];
    }

    bb32: {
        drop(_58) -> [return: bb33, unwind: bb48];
    }

    bb33: {
        _73 = const _;
        _63 = _73 as &[&str] (PointerCoercion(Unsize));
        _70 = &_56;
        _69 = TextCellContents::strings(move _70) -> [return: bb34, unwind: bb48];
    }

    bb34: {
        _68 = &_69;
        _67 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericStrings<'_, str>>(_68) -> [return: bb35, unwind: bb48];
    }

    bb35: {
        _66 = [move _67];
        _65 = &_66;
        _64 = _65 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _62 = std::fmt::Arguments::<'_>::new_v1(move _63, move _64) -> [return: bb36, unwind: bb48];
    }

    bb36: {
        _61 = <W as std::io::Write>::write_fmt(_2, move _62) -> [return: bb37, unwind: bb48];
    }

    bb37: {
        _60 = <Result<(), std::io::Error> as Try>::branch(move _61) -> [return: bb38, unwind: bb48];
    }

    bb38: {
        _71 = discriminant(_60);
        switchInt(move _71) -> [0: bb39, 1: bb40, otherwise: bb10];
    }

    bb39: {
        drop(_56) -> [return: bb27, unwind: bb51];
    }

    bb40: {
        _72 = move ((_60 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _72) -> [return: bb41, unwind: bb48];
    }

    bb41: {
        drop(_56) -> [return: bb44, unwind: bb51];
    }

    bb42: {
        drop(_3) -> [return: bb43, unwind: bb63];
    }

    bb43: {
        _82 = discriminant(_37);
        switchInt(move _82) -> [1: bb59, otherwise: bb58];
    }

    bb44: {
        drop(_3) -> [return: bb45, unwind: bb63];
    }

    bb45: {
        drop(_37) -> [return: bb46, unwind: bb56];
    }

    bb46: {
        _81 = const false;
        drop(_1) -> [return: bb47, unwind continue];
    }

    bb47: {
        return;
    }

    bb48 (cleanup): {
        drop(_56) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_58) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_41) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_3) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_28) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_21) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_23) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_3) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_1) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        resume;
    }

    bb58: {
        _81 = const false;
        drop(_1) -> [return: bb47, unwind continue];
    }

    bb59: {
        switchInt(_81) -> [0: bb58, otherwise: bb60];
    }

    bb60: {
        drop(((_37 as Some).0: term_grid::Display<'_>)) -> [return: bb58, unwind: bb56];
    }

    bb61 (cleanup): {
        switchInt(_81) -> [0: bb56, otherwise: bb62];
    }

    bb62 (cleanup): {
        drop(((_37 as Some).0: term_grid::Display<'_>)) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        _83 = discriminant(_37);
        switchInt(move _83) -> [1: bb61, otherwise: bb56];
    }
}

promoted[0] in grid::<impl at src/output/grid.rs:33:1: 33:20>::render: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in grid::<impl at src/output/grid.rs:33:1: 33:20>::render: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:21:10: 21:19>::eq(_1: &grid_details::Options, _2: &grid_details::Options) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &output::grid::Options;
    let mut _5: &output::grid::Options;
    let mut _6: bool;
    let mut _7: &output::details::Options;
    let mut _8: &output::details::Options;
    let mut _9: &output::grid_details::RowThreshold;
    let mut _10: &output::grid_details::RowThreshold;

    bb0: {
        _4 = &((*_1).0: output::grid::Options);
        _5 = &((*_2).0: output::grid::Options);
        _3 = <grid::Options as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: output::details::Options);
        _8 = &((*_2).1: output::details::Options);
        _6 = <details::Options as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = &((*_1).2: output::grid_details::RowThreshold);
        _10 = &((*_2).2: output::grid_details::RowThreshold);
        _0 = <RowThreshold as PartialEq>::eq(move _9, move _10) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = const false;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:21:21: 21:26>::fmt(_1: &grid_details::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::grid::Options;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &output::details::Options;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&output::grid_details::RowThreshold;
    let _13: &output::grid_details::RowThreshold;

    bb0: {
        _3 = const "Options";
        _4 = const "grid";
        _6 = &((*_1).0: output::grid::Options);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "details";
        _9 = &((*_1).1: output::details::Options);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "row_threshold";
        _13 = &((*_1).2: output::grid_details::RowThreshold);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:28:1: 28:13>::to_details_options(_1: &grid_details::Options) -> &details::Options {
    debug self => _1;
    let mut _0: &output::details::Options;

    bb0: {
        _0 = &((*_1).1: output::details::Options);
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:42:10: 42:19>::eq(_1: &RowThreshold, _2: &RowThreshold) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&output::grid_details::RowThreshold, &output::grid_details::RowThreshold);
    let mut _7: isize;
    let mut _8: isize;
    let mut _11: usize;
    let mut _12: usize;
    let mut _13: &output::grid_details::RowThreshold;
    let mut _14: &output::grid_details::RowThreshold;
    let mut _15: &output::grid_details::RowThreshold;
    let mut _16: &output::grid_details::RowThreshold;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _9: &usize;
            let _10: &usize;
            scope 3 {
                debug __self_0 => _9;
                debug __arg1_0 => _10;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _13 = deref_copy (_6.0: &output::grid_details::RowThreshold);
        _8 = discriminant((*_13));
        switchInt(move _8) -> [0: bb3, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb6;
    }

    bb3: {
        _14 = deref_copy (_6.1: &output::grid_details::RowThreshold);
        _7 = discriminant((*_14));
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb6;
    }

    bb5: {
        _15 = deref_copy (_6.0: &output::grid_details::RowThreshold);
        _9 = &(((*_15) as MinimumRows).0: usize);
        _16 = deref_copy (_6.1: &output::grid_details::RowThreshold);
        _10 = &(((*_16) as MinimumRows).0: usize);
        _11 = (*_9);
        _12 = (*_10);
        _0 = Eq(move _11, move _12);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:42:21: 42:26>::fmt(_1: &RowThreshold, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &usize;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&usize;
    let _8: &str;
    scope 1 {
        debug __self_0 => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "AlwaysGrid";
        _0 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as MinimumRows).0: usize);
        _5 = const "MinimumRows";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:42:34: 42:39>::clone(_1: &RowThreshold) -> RowThreshold {
    debug self => _1;
    let mut _0: output::grid_details::RowThreshold;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::details_for_column(_1: &grid_details::Render<'_>) -> details::Render<'_> {
    debug self => _1;
    let mut _0: output::details::Render<'_>;
    let mut _2: std::option::Option<&fs::dir::Dir>;
    let mut _3: std::vec::Vec<fs::file::File<'_>>;
    let mut _4: std::option::Option<fs::dir_action::RecurseOptions>;
    let mut _5: bool;
    let mut _6: std::option::Option<&fs::feature::git::GitCache>;
    let mut _7: &theme::Theme;
    let mut _8: &output::file_name::Options;
    let mut _9: &output::details::Options;
    let mut _10: &fs::filter::FileFilter;

    bb0: {
        _2 = ((*_1).0: std::option::Option<&fs::dir::Dir>);
        _3 = Vec::<file::File<'_>>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = deref_copy ((*_1).2: &theme::Theme);
        _8 = deref_copy ((*_1).3: &output::file_name::Options);
        _9 = deref_copy ((*_1).5: &output::details::Options);
        _4 = Option::<RecurseOptions>::None;
        _10 = deref_copy ((*_1).6: &fs::filter::FileFilter);
        _5 = ((*_1).8: bool);
        _6 = ((*_1).9: std::option::Option<&fs::feature::git::GitCache>);
        _0 = details::Render::<'_> { dir: move _2, files: move _3, theme: _7, file_style: _8, opts: _9, recurse: move _4, filter: _10, git_ignoring: move _5, git: move _6 };
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::give_up(_1: grid_details::Render<'_>) -> details::Render<'_> {
    debug self => _1;
    let mut _0: output::details::Render<'_>;
    let mut _2: std::option::Option<&fs::dir::Dir>;
    let mut _3: std::vec::Vec<fs::file::File<'_>>;
    let mut _4: std::option::Option<fs::dir_action::RecurseOptions>;
    let mut _5: bool;
    let mut _6: std::option::Option<&fs::feature::git::GitCache>;
    let mut _7: &theme::Theme;
    let mut _8: &output::file_name::Options;
    let mut _9: &output::details::Options;
    let mut _10: &fs::filter::FileFilter;

    bb0: {
        _2 = (_1.0: std::option::Option<&fs::dir::Dir>);
        _3 = move (_1.1: std::vec::Vec<fs::file::File<'_>>);
        _7 = deref_copy (_1.2: &theme::Theme);
        _8 = deref_copy (_1.3: &output::file_name::Options);
        _9 = deref_copy (_1.5: &output::details::Options);
        _4 = Option::<RecurseOptions>::None;
        _10 = deref_copy (_1.6: &fs::filter::FileFilter);
        _5 = (_1.8: bool);
        _6 = (_1.9: std::option::Option<&fs::feature::git::GitCache>);
        _0 = details::Render::<'_> { dir: move _2, files: move _3, theme: _7, file_style: _8, opts: _9, recurse: move _4, filter: _10, git_ignoring: move _5, git: move _6 };
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::render(_1: grid_details::Render<'_>, _2: &mut W) -> Result<(), std::io::Error> {
    debug self => _1;
    debug w => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::option::Option<(term_grid::Grid, usize)>;
    let mut _4: &mut output::grid_details::Render<'_>;
    let mut _5: isize;
    let mut _8: std::fmt::Arguments<'_>;
    let mut _9: &[&str];
    let mut _10: &[core::fmt::rt::Argument<'_>];
    let _11: &[core::fmt::rt::Argument<'_>; 1];
    let _12: [core::fmt::rt::Argument<'_>; 1];
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &term_grid::Display<'_>;
    let _15: term_grid::Display<'_>;
    let mut _16: &term_grid::Grid;
    let mut _17: output::details::Render<'_>;
    let mut _18: output::grid_details::Render<'_>;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: isize;
    let mut _23: isize;
    scope 1 {
        debug grid => _6;
        debug width => _7;
        let _6: term_grid::Grid;
        let _7: usize;
        let mut _19: &[&str; 1];
    }

    bb0: {
        _21 = const false;
        _20 = const false;
        _21 = const true;
        _4 = &mut _1;
        _3 = grid_details::Render::<'_>::find_fitting_grid(move _4) -> [return: bb1, unwind: bb23];
    }

    bb1: {
        _20 = const true;
        _5 = discriminant(_3);
        switchInt(move _5) -> [1: bb2, otherwise: bb8];
    }

    bb2: {
        _20 = const false;
        _6 = move (((_3 as Some).0: (term_grid::Grid, usize)).0: term_grid::Grid);
        _7 = (((_3 as Some).0: (term_grid::Grid, usize)).1: usize);
        _19 = const _;
        _9 = _19 as &[&str] (PointerCoercion(Unsize));
        _16 = &_6;
        _15 = Grid::fit_into_columns(move _16, _7) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _14 = &_15;
        _13 = core::fmt::rt::Argument::<'_>::new_display::<term_grid::Display<'_>>(_14) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _8 = std::fmt::Arguments::<'_>::new_v1(move _9, move _10) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        _0 = <W as std::io::Write>::write_fmt(_2, move _8) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        drop(_15) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        drop(_6) -> [return: bb17, unwind: bb21];
    }

    bb8: {
        _21 = const false;
        _18 = move _1;
        _17 = grid_details::Render::<'_>::give_up(move _18) -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _0 = details::Render::<'_>::render::<W>(move _17, _2) -> [return: bb24, unwind: bb21];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_15) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        drop(_6) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        _20 = const false;
        switchInt(_21) -> [0: bb10, otherwise: bb18];
    }

    bb15: {
        switchInt(_20) -> [0: bb14, otherwise: bb16];
    }

    bb16: {
        drop((((_3 as Some).0: (term_grid::Grid, usize)).0: term_grid::Grid)) -> [return: bb14, unwind: bb23];
    }

    bb17: {
        _22 = discriminant(_3);
        switchInt(move _22) -> [1: bb15, otherwise: bb14];
    }

    bb18: {
        drop(_1) -> [return: bb10, unwind continue];
    }

    bb19 (cleanup): {
        switchInt(_20) -> [0: bb23, otherwise: bb20];
    }

    bb20 (cleanup): {
        drop((((_3 as Some).0: (term_grid::Grid, usize)).0: term_grid::Grid)) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        _23 = discriminant(_3);
        switchInt(move _23) -> [1: bb19, otherwise: bb23];
    }

    bb22 (cleanup): {
        drop(_1) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_21) -> [0: bb13, otherwise: bb22];
    }

    bb24: {
        goto -> bb17;
    }
}

promoted[0] in grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::render: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::find_fitting_grid(_1: &mut grid_details::Render<'_>) -> Option<(Grid, usize)> {
    debug self => _1;
    let mut _0: std::option::Option<(term_grid::Grid, usize)>;
    let _2: &output::table::Options;
    let mut _3: std::option::Option<&output::table::Options>;
    let mut _4: &std::option::Option<output::table::Options>;
    let _5: &str;
    let mut _7: &output::grid_details::Render<'_>;
    let mut _9: (output::table::Table<'_>, std::vec::Vec<output::details::Row>);
    let mut _10: &mut output::grid_details::Render<'_>;
    let _11: &output::details::Render<'_>;
    let mut _13: std::iter::Map<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/output/grid_details.rs:153:29: 153:35}>;
    let mut _14: std::slice::Iter<'_, fs::file::File<'_>>;
    let _15: &[fs::file::File<'_>];
    let mut _16: &std::vec::Vec<fs::file::File<'_>>;
    let mut _17: {closure@src/output/grid_details.rs:153:29: 153:35};
    let mut _18: &output::table::Table<'_>;
    let mut _20: std::iter::Map<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/output/grid_details.rs:157:35: 157:41}>;
    let mut _21: std::slice::Iter<'_, fs::file::File<'_>>;
    let _22: &[fs::file::File<'_>];
    let mut _23: &std::vec::Vec<fs::file::File<'_>>;
    let mut _24: {closure@src/output/grid_details.rs:157:35: 157:41};
    let mut _25: &&mut output::grid_details::Render<'_>;
    let mut _27: &mut output::grid_details::Render<'_>;
    let _28: &[output::cell::TextCell];
    let _29: &std::vec::Vec<output::cell::TextCell>;
    let mut _30: std::vec::Vec<output::table::Row>;
    let mut _31: &std::vec::Vec<output::table::Row>;
    let _32: &output::details::Render<'_>;
    let mut _33: usize;
    let mut _34: &std::vec::Vec<output::cell::TextCell>;
    let mut _35: (term_grid::Grid, usize);
    let mut _36: term_grid::Grid;
    let mut _37: std::ops::Range<usize>;
    let mut _38: std::ops::Range<usize>;
    let mut _40: std::option::Option<usize>;
    let mut _41: &mut std::ops::Range<usize>;
    let mut _42: isize;
    let mut _45: &mut output::grid_details::Render<'_>;
    let _46: &[output::cell::TextCell];
    let _47: &std::vec::Vec<output::cell::TextCell>;
    let mut _48: std::vec::Vec<output::table::Row>;
    let mut _49: &std::vec::Vec<output::table::Row>;
    let _50: &output::details::Render<'_>;
    let mut _53: &term_grid::Grid;
    let mut _54: usize;
    let mut _55: &term_grid::Display<'_>;
    let mut _56: usize;
    let mut _57: term_grid::Grid;
    let mut _58: bool;
    let mut _59: usize;
    let mut _60: &std::vec::Vec<output::cell::TextCell>;
    let mut _62: (usize, bool);
    let mut _63: isize;
    let mut _65: bool;
    let mut _66: usize;
    let mut _67: &term_grid::Display<'_>;
    let _68: term_grid::Display<'_>;
    let mut _69: &term_grid::Grid;
    let mut _70: usize;
    let mut _71: (term_grid::Grid, usize);
    let mut _72: term_grid::Grid;
    let mut _73: usize;
    let mut _74: &output::details::Options;
    let mut _75: bool;
    let mut _76: bool;
    scope 1 {
        debug options => _2;
        let _6: output::details::Render<'_>;
        scope 2 {
            debug drender => _6;
            let _8: output::table::Table<'_>;
            scope 3 {
                debug first_table => _8;
                let _12: std::vec::Vec<output::table::Row>;
                scope 4 {
                    debug rows => _12;
                    let _19: std::vec::Vec<output::cell::TextCell>;
                    scope 5 {
                        debug file_names => _19;
                        let mut _26: term_grid::Grid;
                        scope 6 {
                            debug last_working_grid => _26;
                            let mut _39: std::ops::Range<usize>;
                            scope 7 {
                                debug iter => _39;
                                let _43: usize;
                                scope 8 {
                                    debug column_count => _43;
                                    let _44: term_grid::Grid;
                                    scope 9 {
                                        debug grid => _44;
                                        let _51: bool;
                                        let _52: term_grid::Display<'_>;
                                        scope 10 {
                                            debug the_grid_fits => _51;
                                            let _61: usize;
                                            scope 12 {
                                                debug last_column_count => _61;
                                                scope 13 {
                                                    debug thresh => _64;
                                                    let _64: usize;
                                                }
                                            }
                                        }
                                        scope 11 {
                                            debug d => _52;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _76 = const false;
        _75 = const false;
        _74 = deref_copy ((*_1).5: &output::details::Options);
        _4 = &((*_74).0: std::option::Option<output::table::Options>);
        _3 = Option::<table::Options>::as_ref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "Details table options not given!";
        _2 = Option::<&table::Options>::expect(move _3, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &(*_1);
        _6 = grid_details::Render::<'_>::details_for_column(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = _1;
        _11 = &_6;
        _9 = grid_details::Render::<'_>::make_table(move _10, _2, _11) -> [return: bb4, unwind: bb67];
    }

    bb4: {
        _8 = move (_9.0: output::table::Table<'_>);
        drop((_9.1: std::vec::Vec<output::details::Row>)) -> [return: bb69, unwind: bb66];
    }

    bb5: {
        _14 = core::slice::<impl [file::File<'_>]>::iter(_15) -> [return: bb6, unwind: bb66];
    }

    bb6: {
        _18 = &_8;
        _17 = {closure@src/output/grid_details.rs:153:29: 153:35} { first_table: move _18 };
        _13 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::map::<table::Row, {closure@src/output/grid_details.rs:153:29: 153:35}>(move _14, move _17) -> [return: bb7, unwind: bb66];
    }

    bb7: {
        _12 = <Map<std::slice::Iter<'_, file::File<'_>>, {closure@src/output/grid_details.rs:153:29: 153:35}> as Iterator>::collect::<Vec<table::Row>>(move _13) -> [return: bb8, unwind: bb66];
    }

    bb8: {
        _23 = &((*_1).1: std::vec::Vec<fs::file::File<'_>>);
        _22 = <Vec<file::File<'_>> as Deref>::deref(move _23) -> [return: bb9, unwind: bb65];
    }

    bb9: {
        _21 = core::slice::<impl [file::File<'_>]>::iter(_22) -> [return: bb10, unwind: bb65];
    }

    bb10: {
        _25 = &_1;
        _24 = {closure@src/output/grid_details.rs:157:35: 157:41} { self: move _25 };
        _20 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::map::<TextCell, {closure@src/output/grid_details.rs:157:35: 157:41}>(move _21, move _24) -> [return: bb11, unwind: bb65];
    }

    bb11: {
        _19 = <Map<std::slice::Iter<'_, file::File<'_>>, {closure@src/output/grid_details.rs:157:35: 157:41}> as Iterator>::collect::<Vec<TextCell>>(move _20) -> [return: bb12, unwind: bb65];
    }

    bb12: {
        _27 = _1;
        _29 = &_19;
        _28 = <Vec<TextCell> as Deref>::deref(_29) -> [return: bb13, unwind: bb64];
    }

    bb13: {
        _31 = &_12;
        _30 = <Vec<table::Row> as Clone>::clone(move _31) -> [return: bb14, unwind: bb64];
    }

    bb14: {
        _32 = &_6;
        _26 = grid_details::Render::<'_>::make_grid(move _27, const 1_usize, _2, _28, move _30, _32) -> [return: bb15, unwind: bb64];
    }

    bb15: {
        _76 = const true;
        _34 = &_19;
        _33 = Vec::<TextCell>::len(move _34) -> [return: bb16, unwind: bb77];
    }

    bb16: {
        switchInt(move _33) -> [1: bb17, otherwise: bb18];
    }

    bb17: {
        _76 = const false;
        _36 = move _26;
        _35 = (move _36, const 1_usize);
        _0 = Option::<(Grid, usize)>::Some(move _35);
        goto -> bb73;
    }

    bb18: {
        _38 = std::ops::Range::<usize> { start: const 2_usize, end: const 100_usize };
        _37 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _38) -> [return: bb19, unwind: bb77];
    }

    bb19: {
        _39 = move _37;
        goto -> bb20;
    }

    bb20: {
        _41 = &mut _39;
        _40 = <std::ops::Range<usize> as Iterator>::next(_41) -> [return: bb21, unwind: bb77];
    }

    bb21: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb24, 1: bb22, otherwise: bb23];
    }

    bb22: {
        _43 = ((_40 as Some).0: usize);
        _45 = _1;
        _47 = &_19;
        _46 = <Vec<TextCell> as Deref>::deref(_47) -> [return: bb25, unwind: bb77];
    }

    bb23: {
        unreachable;
    }

    bb24: {
        _0 = Option::<(Grid, usize)>::None;
        drop(_26) -> [return: bb51, unwind: bb64];
    }

    bb25: {
        _49 = &_12;
        _48 = <Vec<table::Row> as Clone>::clone(move _49) -> [return: bb26, unwind: bb77];
    }

    bb26: {
        _50 = &_6;
        _44 = grid_details::Render::<'_>::make_grid(move _45, _43, _2, _46, move _48, _50) -> [return: bb27, unwind: bb77];
    }

    bb27: {
        _75 = const true;
        _53 = &_44;
        _52 = Grid::fit_into_columns(move _53, _43) -> [return: bb28, unwind: bb75];
    }

    bb28: {
        _55 = &_52;
        _54 = term_grid::Display::<'_>::width(move _55) -> [return: bb29, unwind: bb63];
    }

    bb29: {
        _56 = ((*_1).10: usize);
        _51 = Le(move _54, move _56);
        drop(_52) -> [return: bb30, unwind: bb75];
    }

    bb30: {
        switchInt(_51) -> [0: bb34, otherwise: bb31];
    }

    bb31: {
        _75 = const false;
        _57 = move _44;
        drop(_26) -> [return: bb32, unwind: bb33];
    }

    bb32: {
        _76 = const true;
        _26 = move _57;
        goto -> bb34;
    }

    bb33 (cleanup): {
        _76 = const true;
        _26 = move _57;
        goto -> bb75;
    }

    bb34: {
        switchInt(_51) -> [0: bb37, otherwise: bb35];
    }

    bb35: {
        _60 = &_19;
        _59 = Vec::<TextCell>::len(move _60) -> [return: bb36, unwind: bb75];
    }

    bb36: {
        _58 = Eq(_43, move _59);
        switchInt(move _58) -> [0: bb49, otherwise: bb37];
    }

    bb37: {
        switchInt(_51) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _61 = _43;
        goto -> bb41;
    }

    bb39: {
        _62 = CheckedSub(_43, const 1_usize);
        assert(!move (_62.1: bool), "attempt to compute `{} - {}`, which would overflow", _43, const 1_usize) -> [success: bb40, unwind: bb75];
    }

    bb40: {
        _61 = move (_62.0: usize);
        goto -> bb41;
    }

    bb41: {
        _63 = discriminant(((*_1).7: output::grid_details::RowThreshold));
        switchInt(move _63) -> [0: bb42, otherwise: bb48];
    }

    bb42: {
        _64 = ((((*_1).7: output::grid_details::RowThreshold) as MinimumRows).0: usize);
        _69 = &_26;
        _70 = _61;
        _68 = Grid::fit_into_columns(move _69, move _70) -> [return: bb43, unwind: bb75];
    }

    bb43: {
        _67 = &_68;
        _66 = term_grid::Display::<'_>::row_count(move _67) -> [return: bb44, unwind: bb62];
    }

    bb44: {
        _65 = Lt(move _66, _64);
        switchInt(move _65) -> [0: bb47, otherwise: bb45];
    }

    bb45: {
        drop(_68) -> [return: bb46, unwind: bb75];
    }

    bb46: {
        _0 = Option::<(Grid, usize)>::None;
        goto -> bb55;
    }

    bb47: {
        drop(_68) -> [return: bb48, unwind: bb75];
    }

    bb48: {
        _76 = const false;
        _72 = move _26;
        _73 = _61;
        _71 = (move _72, move _73);
        _0 = Option::<(Grid, usize)>::Some(move _71);
        goto -> bb55;
    }

    bb49: {
        switchInt(_75) -> [0: bb50, otherwise: bb70];
    }

    bb50: {
        _75 = const false;
        goto -> bb20;
    }

    bb51: {
        _76 = const false;
        drop(_19) -> [return: bb52, unwind: bb65];
    }

    bb52: {
        drop(_12) -> [return: bb53, unwind: bb66];
    }

    bb53: {
        drop(_8) -> [return: bb54, unwind: bb67];
    }

    bb54: {
        drop(_6) -> [return: bb61, unwind continue];
    }

    bb55: {
        switchInt(_75) -> [0: bb56, otherwise: bb71];
    }

    bb56: {
        _75 = const false;
        goto -> bb73;
    }

    bb57: {
        _76 = const false;
        drop(_19) -> [return: bb58, unwind: bb65];
    }

    bb58: {
        drop(_12) -> [return: bb59, unwind: bb66];
    }

    bb59: {
        drop(_8) -> [return: bb60, unwind: bb67];
    }

    bb60: {
        drop(_6) -> [return: bb61, unwind continue];
    }

    bb61: {
        return;
    }

    bb62 (cleanup): {
        drop(_68) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_52) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_19) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_12) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_8) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        drop(_6) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        resume;
    }

    bb69: {
        _16 = &((*_1).1: std::vec::Vec<fs::file::File<'_>>);
        _15 = <Vec<file::File<'_>> as Deref>::deref(move _16) -> [return: bb5, unwind: bb66];
    }

    bb70: {
        drop(_44) -> [return: bb50, unwind: bb77];
    }

    bb71: {
        drop(_44) -> [return: bb56, unwind: bb77];
    }

    bb72: {
        drop(_26) -> [return: bb57, unwind: bb64];
    }

    bb73: {
        switchInt(_76) -> [0: bb57, otherwise: bb72];
    }

    bb74 (cleanup): {
        drop(_44) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        switchInt(_75) -> [0: bb77, otherwise: bb74];
    }

    bb76 (cleanup): {
        drop(_26) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        switchInt(_76) -> [0: bb64, otherwise: bb76];
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::find_fitting_grid::{closure#0}(_1: &mut {closure@src/output/grid_details.rs:153:29: 153:35}, _2: &file::File<'_>) -> table::Row {
    debug file => _2;
    debug first_table => (*((*_1).0: &output::table::Table<'_>));
    let mut _0: output::table::Row;
    let mut _3: bool;
    let mut _4: &output::table::Table<'_>;

    bb0: {
        _4 = deref_copy ((*_1).0: &output::table::Table<'_>);
        _3 = file_has_xattrs(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Table::<'_>::row_for_file(_4, _2, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::find_fitting_grid::{closure#1}(_1: &mut {closure@src/output/grid_details.rs:157:35: 157:41}, _2: &file::File<'_>) -> TextCell {
    debug file => _2;
    debug self => (*((*_1).0: &&mut output::grid_details::Render<'_>));
    let mut _0: output::cell::TextCell;
    let mut _3: output::cell::TextCellContents;
    let mut _4: &output::file_name::FileName<'_, '_, theme::Theme>;
    let _5: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _6: output::file_name::Options;
    let mut _7: &&mut output::grid_details::Render<'_>;
    let mut _8: &mut output::grid_details::Render<'_>;
    let mut _9: &output::file_name::Options;
    let mut _10: &&mut output::grid_details::Render<'_>;
    let mut _11: &mut output::grid_details::Render<'_>;
    let mut _12: &theme::Theme;

    bb0: {
        _7 = deref_copy ((*_1).0: &&mut output::grid_details::Render<'_>);
        _8 = deref_copy (*_7);
        _9 = deref_copy ((*_8).3: &output::file_name::Options);
        _6 = (*_9);
        _10 = deref_copy ((*_1).0: &&mut output::grid_details::Render<'_>);
        _11 = deref_copy (*_10);
        _12 = deref_copy ((*_11).2: &theme::Theme);
        _5 = output::file_name::Options::for_file::<Theme>(move _6, _2, _12) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_5;
        _3 = FileName::<'_, '_, Theme>::paint(move _4) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _0 = TextCellContents::promote(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_5) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::make_table(_1: &mut grid_details::Render<'_>, _2: &table::Options, _3: &details::Render<'_>) -> (Table<'_>, Vec<details::Row>) {
    debug self => _1;
    debug options => _2;
    debug drender => _3;
    let mut _0: (output::table::Table<'_>, std::vec::Vec<output::details::Row>);
    let mut _4: (std::option::Option<&fs::feature::git::GitCache>, std::option::Option<&fs::dir::Dir>);
    let mut _5: std::option::Option<&fs::feature::git::GitCache>;
    let mut _6: std::option::Option<&fs::dir::Dir>;
    let mut _7: isize;
    let mut _8: isize;
    let _9: &fs::feature::git::GitCache;
    let _10: &fs::dir::Dir;
    let mut _11: bool;
    let _12: &std::path::Path;
    let _13: &std::path::PathBuf;
    let mut _14: std::option::Option<&fs::feature::git::GitCache>;
    let _15: &fs::feature::git::GitCache;
    let mut _16: bool;
    let mut _17: &mut std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _18: std::slice::Iter<'_, fs::file::File<'_>>;
    let _19: &[fs::file::File<'_>];
    let mut _20: &std::vec::Vec<fs::file::File<'_>>;
    let mut _21: {closure@src/output/grid_details.rs:201:63: 201:66};
    let mut _22: &&fs::feature::git::GitCache;
    let mut _23: std::option::Option<&fs::feature::git::GitCache>;
    let mut _24: output::table::Table<'_>;
    let mut _25: std::option::Option<&fs::feature::git::GitCache>;
    let _26: &&theme::Theme;
    let mut _28: bool;
    let mut _30: &output::table::Table<'_>;
    let _31: ();
    let mut _32: &mut output::table::Table<'_>;
    let _33: &output::table::Row;
    let _34: ();
    let mut _35: &mut std::vec::Vec<output::details::Row>;
    let mut _36: output::details::Row;
    let mut _37: output::table::Row;
    let mut _38: output::table::Table<'_>;
    let mut _39: std::vec::Vec<output::details::Row>;
    let mut _40: &theme::Theme;
    let mut _41: &output::details::Options;
    let mut _42: bool;
    scope 1 {
        debug g => _9;
        debug d => _10;
    }
    scope 2 {
        debug g => _15;
    }
    scope 3 {
        debug table => _24;
        let mut _27: std::vec::Vec<output::details::Row>;
        scope 4 {
            debug rows => _27;
            let _29: output::table::Row;
            scope 5 {
                debug row => _29;
            }
        }
    }

    bb0: {
        _42 = const false;
        _5 = ((*_1).9: std::option::Option<&fs::feature::git::GitCache>);
        _6 = ((*_1).0: std::option::Option<&fs::dir::Dir>);
        _4 = (move _5, move _6);
        _8 = discriminant((_4.0: std::option::Option<&fs::feature::git::GitCache>));
        switchInt(move _8) -> [0: bb12, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = discriminant((_4.1: std::option::Option<&fs::dir::Dir>));
        switchInt(move _7) -> [0: bb7, 1: bb3, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _9 = (((_4.0: std::option::Option<&fs::feature::git::GitCache>) as Some).0: &fs::feature::git::GitCache);
        _10 = (((_4.1: std::option::Option<&fs::dir::Dir>) as Some).0: &fs::dir::Dir);
        _13 = &((*_10).1: std::path::PathBuf);
        _12 = <PathBuf as Deref>::deref(_13) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = GitCache::has_anything_for(_9, _12) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _11) -> [0: bb6, otherwise: bb12];
    }

    bb6: {
        _14 = Option::<&GitCache>::None;
        ((*_1).9: std::option::Option<&fs::feature::git::GitCache>) = move _14;
        goto -> bb12;
    }

    bb7: {
        _15 = (((_4.0: std::option::Option<&fs::feature::git::GitCache>) as Some).0: &fs::feature::git::GitCache);
        _20 = &((*_1).1: std::vec::Vec<fs::file::File<'_>>);
        _19 = <Vec<file::File<'_>> as Deref>::deref(move _20) -> [return: bb8, unwind continue];
    }

    bb8: {
        _18 = core::slice::<impl [file::File<'_>]>::iter(_19) -> [return: bb9, unwind continue];
    }

    bb9: {
        _17 = &mut _18;
        _22 = &_15;
        _21 = {closure@src/output/grid_details.rs:201:63: 201:66} { g: move _22 };
        _16 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::any::<{closure@src/output/grid_details.rs:201:63: 201:66}>(move _17, move _21) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _16) -> [0: bb11, otherwise: bb12];
    }

    bb11: {
        _23 = Option::<&GitCache>::None;
        ((*_1).9: std::option::Option<&fs::feature::git::GitCache>) = move _23;
        goto -> bb12;
    }

    bb12: {
        _25 = ((*_1).9: std::option::Option<&fs::feature::git::GitCache>);
        _26 = &((*_1).2: &theme::Theme);
        _40 = deref_copy (*_26);
        _24 = Table::<'_>::new(_2, move _25, _40) -> [return: bb13, unwind continue];
    }

    bb13: {
        _27 = Vec::<details::Row>::new() -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _41 = deref_copy ((*_1).5: &output::details::Options);
        _28 = ((*_41).1: bool);
        switchInt(move _28) -> [0: bb20, otherwise: bb15];
    }

    bb15: {
        _30 = &_24;
        _29 = Table::<'_>::header_row(move _30) -> [return: bb16, unwind: bb21];
    }

    bb16: {
        _42 = const true;
        _32 = &mut _24;
        _33 = &_29;
        _31 = Table::<'_>::add_widths(move _32, _33) -> [return: bb17, unwind: bb25];
    }

    bb17: {
        _35 = &mut _27;
        _42 = const false;
        _37 = move _29;
        _36 = details::Render::<'_>::render_header(_3, move _37) -> [return: bb18, unwind: bb25];
    }

    bb18: {
        _34 = Vec::<details::Row>::push(move _35, move _36) -> [return: bb19, unwind: bb25];
    }

    bb19: {
        _42 = const false;
        goto -> bb20;
    }

    bb20: {
        _38 = move _24;
        _39 = move _27;
        _0 = (move _38, move _39);
        return;
    }

    bb21 (cleanup): {
        drop(_27) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_24) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }

    bb24 (cleanup): {
        drop(_29) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        switchInt(_42) -> [0: bb21, otherwise: bb24];
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::make_table::{closure#0}(_1: &mut {closure@src/output/grid_details.rs:201:63: 201:66}, _2: &file::File<'_>) -> bool {
    debug f => _2;
    debug g => (*((*_1).0: &&fs::feature::git::GitCache));
    let mut _0: bool;
    let _3: &std::path::Path;
    let _4: &std::path::PathBuf;
    let mut _5: &&fs::feature::git::GitCache;
    let mut _6: &fs::feature::git::GitCache;

    bb0: {
        _5 = deref_copy ((*_1).0: &&fs::feature::git::GitCache);
        _6 = deref_copy (*_5);
        _4 = &((*_2).2: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = GitCache::has_anything_for(_6, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::make_grid(_1: &mut grid_details::Render<'_>, _2: usize, _3: &table::Options, _4: &[TextCell], _5: Vec<table::Row>, _6: &details::Render<'_>) -> Grid {
    debug self => _1;
    debug column_count => _2;
    debug options => _3;
    debug file_names => _4;
    debug rows => _5;
    debug drender => _6;
    let mut _0: term_grid::Grid;
    let mut _7: std::vec::Vec<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>;
    let mut _8: std::ops::Range<usize>;
    let mut _9: std::ops::Range<usize>;
    let mut _11: std::option::Option<usize>;
    let mut _12: &mut std::ops::Range<usize>;
    let mut _13: isize;
    let _14: ();
    let mut _15: &mut std::vec::Vec<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>;
    let mut _16: (output::table::Table<'_>, std::vec::Vec<output::details::Row>);
    let mut _17: &output::details::Render<'_>;
    let mut _19: &std::vec::Vec<output::table::Row>;
    let mut _20: bool;
    let mut _21: (usize, bool);
    let mut _23: usize;
    let mut _24: &std::vec::Vec<output::table::Row>;
    let mut _26: usize;
    let mut _27: std::iter::Enumerate<std::iter::Zip<std::slice::Iter<'_, output::cell::TextCell>, std::vec::IntoIter<output::table::Row>>>;
    let mut _28: std::iter::Enumerate<std::iter::Zip<std::slice::Iter<'_, output::cell::TextCell>, std::vec::IntoIter<output::table::Row>>>;
    let mut _29: std::iter::Zip<std::slice::Iter<'_, output::cell::TextCell>, std::vec::IntoIter<output::table::Row>>;
    let mut _30: std::slice::Iter<'_, output::cell::TextCell>;
    let mut _31: std::vec::IntoIter<output::table::Row>;
    let mut _32: std::vec::Vec<output::table::Row>;
    let mut _34: std::option::Option<(usize, (&output::cell::TextCell, output::table::Row))>;
    let mut _35: &mut std::iter::Enumerate<std::iter::Zip<std::slice::Iter<'_, output::cell::TextCell>, std::vec::IntoIter<output::table::Row>>>;
    let mut _36: isize;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _46: &mut (output::table::Table<'_>, std::vec::Vec<output::details::Row>);
    let mut _47: &mut std::vec::Vec<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>;
    let mut _48: usize;
    let _49: ();
    let _50: &output::table::Row;
    let mut _52: &output::details::Render<'_>;
    let mut _53: output::table::Row;
    let mut _54: output::cell::TextCell;
    let mut _55: output::tree::TreeParams;
    let mut _56: output::tree::TreeDepth;
    let _57: ();
    let mut _59: std::iter::Map<std::vec::IntoIter<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>, {closure@src/output/grid_details.rs:247:18: 247:41}>;
    let mut _60: std::vec::IntoIter<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>;
    let mut _61: std::vec::Vec<(output::table::Table<'_>, std::vec::Vec<output::details::Row>)>;
    let mut _62: {closure@src/output/grid_details.rs:247:18: 247:41};
    let mut _63: &&output::details::Render<'_>;
    let mut _65: bool;
    let mut _68: term_grid::GridOptions;
    let mut _69: term_grid::Direction;
    let mut _70: bool;
    let mut _71: std::ops::Range<usize>;
    let mut _72: std::ops::Range<usize>;
    let mut _74: std::option::Option<usize>;
    let mut _75: &mut std::ops::Range<usize>;
    let mut _76: isize;
    let mut _78: std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
    let mut _79: &std::vec::Vec<std::vec::Vec<output::cell::TextCell>>;
    let mut _81: std::option::Option<&std::vec::Vec<output::cell::TextCell>>;
    let mut _82: &mut std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
    let mut _83: isize;
    let mut _85: bool;
    let mut _86: usize;
    let mut _88: std::string::String;
    let mut _89: &ansi_term::ANSIGenericStrings<'_, str>;
    let _90: ansi_term::ANSIGenericStrings<'_, str>;
    let _91: &[ansi_term::ANSIGenericString<'_, str>];
    let _92: &output::cell::TextCellContents;
    let _93: &output::cell::TextCell;
    let mut _94: usize;
    let mut _95: &usize;
    let mut _96: &output::cell::DisplayWidth;
    let _97: &output::cell::TextCell;
    let _98: ();
    let mut _99: &mut term_grid::Grid;
    let mut _100: std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
    let mut _101: &std::vec::Vec<std::vec::Vec<output::cell::TextCell>>;
    let mut _103: std::option::Option<&std::vec::Vec<output::cell::TextCell>>;
    let mut _104: &mut std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
    let mut _105: isize;
    let mut _107: std::slice::Iter<'_, output::cell::TextCell>;
    let mut _108: std::slice::Iter<'_, output::cell::TextCell>;
    let _109: &[output::cell::TextCell];
    let mut _111: std::option::Option<&output::cell::TextCell>;
    let mut _112: &mut std::slice::Iter<'_, output::cell::TextCell>;
    let mut _113: isize;
    let mut _116: std::string::String;
    let mut _117: &ansi_term::ANSIGenericStrings<'_, str>;
    let _118: ansi_term::ANSIGenericStrings<'_, str>;
    let _119: &[ansi_term::ANSIGenericString<'_, str>];
    let _120: &output::cell::TextCellContents;
    let mut _121: usize;
    let mut _122: &usize;
    let mut _123: &output::cell::DisplayWidth;
    let _124: ();
    let mut _125: &mut term_grid::Grid;
    let mut _126: &output::details::Options;
    let mut _127: &output::grid::Options;
    let mut _128: &output::grid::Options;
    let mut _129: &output::grid::Options;
    let mut _130: bool;
    let mut _131: bool;
    let mut _132: bool;
    let mut _133: bool;
    let mut _134: bool;
    scope 1 {
        debug tables => _7;
        let mut _10: std::ops::Range<usize>;
        let mut _18: usize;
        scope 2 {
            debug iter => _10;
        }
        scope 3 {
            debug num_cells => _18;
            let _22: usize;
            scope 4 {
                debug original_height => _22;
                let _25: usize;
                scope 5 {
                    debug height => _25;
                    let mut _33: std::iter::Enumerate<std::iter::Zip<std::slice::Iter<'_, output::cell::TextCell>, std::vec::IntoIter<output::table::Row>>>;
                    let _58: std::vec::Vec<std::vec::Vec<output::cell::TextCell>>;
                    scope 6 {
                        debug iter => _33;
                        let _37: usize;
                        let _38: &output::cell::TextCell;
                        let _39: output::table::Row;
                        scope 7 {
                            debug i => _37;
                            debug file_name => _38;
                            debug row => _39;
                            let _40: usize;
                            scope 8 {
                                debug index => _40;
                                let _44: &mut output::table::Table<'_>;
                                let _45: &mut std::vec::Vec<output::details::Row>;
                                scope 9 {
                                    debug table => _44;
                                    debug rows => _45;
                                    let _51: output::details::Row;
                                    scope 10 {
                                        debug details_row => _51;
                                    }
                                }
                            }
                        }
                    }
                    scope 11 {
                        debug columns => _58;
                        let _64: term_grid::Direction;
                        scope 12 {
                            debug direction => _64;
                            let _66: term_grid::Filling;
                            scope 13 {
                                debug filling => _66;
                                let mut _67: term_grid::Grid;
                                scope 14 {
                                    debug grid => _67;
                                    let mut _73: std::ops::Range<usize>;
                                    let mut _102: std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
                                    scope 15 {
                                        debug iter => _73;
                                        let _77: usize;
                                        scope 16 {
                                            debug row => _77;
                                            let mut _80: std::slice::Iter<'_, std::vec::Vec<output::cell::TextCell>>;
                                            scope 17 {
                                                debug iter => _80;
                                                let _84: &std::vec::Vec<output::cell::TextCell>;
                                                scope 18 {
                                                    debug column => _84;
                                                    let _87: term_grid::Cell;
                                                    scope 19 {
                                                        debug cell => _87;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    scope 20 {
                                        debug iter => _102;
                                        let _106: &std::vec::Vec<output::cell::TextCell>;
                                        scope 21 {
                                            debug column => _106;
                                            let mut _110: std::slice::Iter<'_, output::cell::TextCell>;
                                            scope 22 {
                                                debug iter => _110;
                                                let _114: &output::cell::TextCell;
                                                scope 23 {
                                                    debug cell => _114;
                                                    let _115: term_grid::Cell;
                                                    scope 24 {
                                                        debug cell => _115;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _134 = const false;
        _133 = const false;
        _132 = const false;
        _131 = const false;
        _130 = const false;
        _134 = const true;
        _7 = Vec::<(Table<'_>, Vec<details::Row>)>::new() -> [return: bb1, unwind: bb94];
    }

    bb1: {
        _133 = const true;
        _9 = std::ops::Range::<usize> { start: const 0_usize, end: _2 };
        _8 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _9) -> [return: bb2, unwind: bb92];
    }

    bb2: {
        _10 = move _8;
        goto -> bb3;
    }

    bb3: {
        _12 = &mut _10;
        _11 = <std::ops::Range<usize> as Iterator>::next(_12) -> [return: bb4, unwind: bb92];
    }

    bb4: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _15 = &mut _7;
        _17 = _6;
        _16 = grid_details::Render::<'_>::make_table(_1, _3, move _17) -> [return: bb8, unwind: bb92];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _19 = &_5;
        _18 = Vec::<table::Row>::len(move _19) -> [return: bb9, unwind: bb92];
    }

    bb8: {
        _14 = Vec::<(Table<'_>, Vec<details::Row>)>::push(move _15, move _16) -> [return: bb95, unwind: bb92];
    }

    bb9: {
        _126 = deref_copy ((*_1).5: &output::details::Options);
        _20 = ((*_126).1: bool);
        switchInt(move _20) -> [0: bb12, otherwise: bb10];
    }

    bb10: {
        _21 = CheckedAdd(_18, _2);
        assert(!move (_21.1: bool), "attempt to compute `{} + {}`, which would overflow", _18, _2) -> [success: bb11, unwind: bb92];
    }

    bb11: {
        _18 = move (_21.0: usize);
        goto -> bb12;
    }

    bb12: {
        _24 = &_5;
        _23 = Vec::<table::Row>::len(move _24) -> [return: bb13, unwind: bb92];
    }

    bb13: {
        _22 = divide_rounding_up(move _23, _2) -> [return: bb14, unwind: bb92];
    }

    bb14: {
        _26 = _18;
        _25 = divide_rounding_up(move _26, _2) -> [return: bb15, unwind: bb92];
    }

    bb15: {
        _30 = core::slice::<impl [TextCell]>::iter(_4) -> [return: bb16, unwind: bb92];
    }

    bb16: {
        _134 = const false;
        _32 = move _5;
        _31 = <Vec<table::Row> as IntoIterator>::into_iter(move _32) -> [return: bb17, unwind: bb92];
    }

    bb17: {
        _29 = <std::slice::Iter<'_, TextCell> as Iterator>::zip::<std::vec::IntoIter<table::Row>>(move _30, move _31) -> [return: bb18, unwind: bb92];
    }

    bb18: {
        _28 = <Zip<std::slice::Iter<'_, TextCell>, std::vec::IntoIter<table::Row>> as Iterator>::enumerate(move _29) -> [return: bb19, unwind: bb92];
    }

    bb19: {
        _27 = <Enumerate<Zip<std::slice::Iter<'_, TextCell>, std::vec::IntoIter<table::Row>>> as IntoIterator>::into_iter(move _28) -> [return: bb20, unwind: bb92];
    }

    bb20: {
        _33 = move _27;
        goto -> bb21;
    }

    bb21: {
        _35 = &mut _33;
        _34 = <Enumerate<Zip<std::slice::Iter<'_, TextCell>, std::vec::IntoIter<table::Row>>> as Iterator>::next(_35) -> [return: bb22, unwind: bb83];
    }

    bb22: {
        _36 = discriminant(_34);
        switchInt(move _36) -> [0: bb24, 1: bb23, otherwise: bb6];
    }

    bb23: {
        _38 = ((((_34 as Some).0: (usize, (&output::cell::TextCell, output::table::Row))).1: (&output::cell::TextCell, output::table::Row)).0: &output::cell::TextCell);
        _132 = const true;
        _39 = move ((((_34 as Some).0: (usize, (&output::cell::TextCell, output::table::Row))).1: (&output::cell::TextCell, output::table::Row)).1: output::table::Row);
        _37 = (((_34 as Some).0: (usize, (&output::cell::TextCell, output::table::Row))).0: usize);
        _127 = deref_copy ((*_1).4: &output::grid::Options);
        _41 = ((*_127).0: bool);
        switchInt(move _41) -> [0: bb27, otherwise: bb25];
    }

    bb24: {
        drop(_33) -> [return: bb37, unwind: bb92];
    }

    bb25: {
        _42 = Eq(_2, const 0_usize);
        assert(!move _42, "attempt to calculate the remainder of `{}` with a divisor of zero", _37) -> [success: bb26, unwind: bb90];
    }

    bb26: {
        _40 = Rem(_37, _2);
        goto -> bb29;
    }

    bb27: {
        _43 = Eq(_22, const 0_usize);
        assert(!move _43, "attempt to divide `{}` by zero", _37) -> [success: bb28, unwind: bb90];
    }

    bb28: {
        _40 = Div(_37, _22);
        goto -> bb29;
    }

    bb29: {
        _47 = &mut _7;
        _48 = _40;
        _46 = <Vec<(Table<'_>, Vec<details::Row>)> as IndexMut<usize>>::index_mut(move _47, move _48) -> [return: bb30, unwind: bb90];
    }

    bb30: {
        _44 = &mut ((*_46).0: output::table::Table<'_>);
        _45 = &mut ((*_46).1: std::vec::Vec<output::details::Row>);
        _50 = &_39;
        _49 = Table::<'_>::add_widths(_44, _50) -> [return: bb31, unwind: bb90];
    }

    bb31: {
        _52 = _6;
        _132 = const false;
        _131 = const true;
        _53 = move _39;
        _54 = <TextCell as Clone>::clone(_38) -> [return: bb32, unwind: bb88];
    }

    bb32: {
        _130 = const true;
        _56 = TreeDepth::root() -> [return: bb33, unwind: bb86];
    }

    bb33: {
        _55 = TreeParams::new(move _56, const false) -> [return: bb34, unwind: bb86];
    }

    bb34: {
        _131 = const false;
        _130 = const false;
        _51 = details::Render::<'_>::render_file(move _52, move _53, move _54, move _55) -> [return: bb35, unwind: bb86];
    }

    bb35: {
        _130 = const false;
        _131 = const false;
        _57 = Vec::<details::Row>::push(_45, move _51) -> [return: bb36, unwind: bb90];
    }

    bb36: {
        _132 = const false;
        goto -> bb21;
    }

    bb37: {
        _133 = const false;
        _61 = move _7;
        _60 = <Vec<(Table<'_>, Vec<details::Row>)> as IntoIterator>::into_iter(move _61) -> [return: bb38, unwind: bb92];
    }

    bb38: {
        _63 = &_6;
        _62 = {closure@src/output/grid_details.rs:247:18: 247:41} { drender: move _63 };
        _59 = <std::vec::IntoIter<(Table<'_>, Vec<details::Row>)> as Iterator>::map::<Vec<TextCell>, {closure@src/output/grid_details.rs:247:18: 247:41}>(move _60, move _62) -> [return: bb39, unwind: bb92];
    }

    bb39: {
        _58 = <Map<std::vec::IntoIter<(Table<'_>, Vec<details::Row>)>, {closure@src/output/grid_details.rs:247:18: 247:41}> as Iterator>::collect::<Vec<Vec<TextCell>>>(move _59) -> [return: bb40, unwind: bb92];
    }

    bb40: {
        _128 = deref_copy ((*_1).4: &output::grid::Options);
        _65 = ((*_128).0: bool);
        switchInt(move _65) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _64 = LeftToRight;
        goto -> bb43;
    }

    bb42: {
        _64 = TopToBottom;
        goto -> bb43;
    }

    bb43: {
        _66 = Spaces(const 4_usize);
        _69 = _64;
        _68 = GridOptions { direction: move _69, filling: move _66 };
        _67 = Grid::new(move _68) -> [return: bb44, unwind: bb82];
    }

    bb44: {
        _129 = deref_copy ((*_1).4: &output::grid::Options);
        _70 = ((*_129).0: bool);
        switchInt(move _70) -> [0: bb62, otherwise: bb45];
    }

    bb45: {
        _72 = std::ops::Range::<usize> { start: const 0_usize, end: _25 };
        _71 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _72) -> [return: bb46, unwind: bb81];
    }

    bb46: {
        _73 = move _71;
        goto -> bb47;
    }

    bb47: {
        _75 = &mut _73;
        _74 = <std::ops::Range<usize> as Iterator>::next(_75) -> [return: bb48, unwind: bb81];
    }

    bb48: {
        _76 = discriminant(_74);
        switchInt(move _76) -> [0: bb77, 1: bb49, otherwise: bb6];
    }

    bb49: {
        _77 = ((_74 as Some).0: usize);
        _79 = &_58;
        _78 = <&Vec<Vec<TextCell>> as IntoIterator>::into_iter(move _79) -> [return: bb50, unwind: bb81];
    }

    bb50: {
        _80 = move _78;
        goto -> bb51;
    }

    bb51: {
        _82 = &mut _80;
        _81 = <std::slice::Iter<'_, Vec<TextCell>> as Iterator>::next(_82) -> [return: bb52, unwind: bb81];
    }

    bb52: {
        _83 = discriminant(_81);
        switchInt(move _83) -> [0: bb47, 1: bb53, otherwise: bb6];
    }

    bb53: {
        _84 = ((_81 as Some).0: &std::vec::Vec<output::cell::TextCell>);
        _86 = Vec::<TextCell>::len(_84) -> [return: bb54, unwind: bb81];
    }

    bb54: {
        _85 = Lt(_77, move _86);
        switchInt(move _85) -> [0: bb51, otherwise: bb55];
    }

    bb55: {
        _93 = <Vec<TextCell> as std::ops::Index<usize>>::index(_84, _77) -> [return: bb56, unwind: bb81];
    }

    bb56: {
        _92 = &((*_93).0: output::cell::TextCellContents);
        _91 = <TextCellContents as Deref>::deref(_92) -> [return: bb57, unwind: bb81];
    }

    bb57: {
        _90 = ANSIStrings(_91) -> [return: bb58, unwind: bb81];
    }

    bb58: {
        _89 = &_90;
        _88 = <ANSIGenericStrings<'_, str> as ToString>::to_string(move _89) -> [return: bb59, unwind: bb81];
    }

    bb59: {
        _97 = <Vec<TextCell> as std::ops::Index<usize>>::index(_84, _77) -> [return: bb60, unwind: bb80];
    }

    bb60: {
        _96 = &((*_97).1: output::cell::DisplayWidth);
        _95 = <DisplayWidth as Deref>::deref(move _96) -> [return: bb61, unwind: bb80];
    }

    bb61: {
        _94 = (*_95);
        _87 = term_grid::Cell { contents: move _88, width: move _94 };
        _99 = &mut _67;
        _98 = Grid::add(move _99, move _87) -> [return: bb96, unwind: bb81];
    }

    bb62: {
        _101 = &_58;
        _100 = <&Vec<Vec<TextCell>> as IntoIterator>::into_iter(move _101) -> [return: bb63, unwind: bb81];
    }

    bb63: {
        _102 = move _100;
        goto -> bb64;
    }

    bb64: {
        _104 = &mut _102;
        _103 = <std::slice::Iter<'_, Vec<TextCell>> as Iterator>::next(_104) -> [return: bb65, unwind: bb81];
    }

    bb65: {
        _105 = discriminant(_103);
        switchInt(move _105) -> [0: bb77, 1: bb66, otherwise: bb6];
    }

    bb66: {
        _106 = ((_103 as Some).0: &std::vec::Vec<output::cell::TextCell>);
        _109 = <Vec<TextCell> as Deref>::deref(_106) -> [return: bb67, unwind: bb81];
    }

    bb67: {
        _108 = core::slice::<impl [TextCell]>::iter(_109) -> [return: bb68, unwind: bb81];
    }

    bb68: {
        _107 = <std::slice::Iter<'_, TextCell> as IntoIterator>::into_iter(move _108) -> [return: bb69, unwind: bb81];
    }

    bb69: {
        _110 = move _107;
        goto -> bb70;
    }

    bb70: {
        _112 = &mut _110;
        _111 = <std::slice::Iter<'_, TextCell> as Iterator>::next(_112) -> [return: bb71, unwind: bb81];
    }

    bb71: {
        _113 = discriminant(_111);
        switchInt(move _113) -> [0: bb64, 1: bb72, otherwise: bb6];
    }

    bb72: {
        _114 = ((_111 as Some).0: &output::cell::TextCell);
        _120 = &((*_114).0: output::cell::TextCellContents);
        _119 = <TextCellContents as Deref>::deref(_120) -> [return: bb73, unwind: bb81];
    }

    bb73: {
        _118 = ANSIStrings(_119) -> [return: bb74, unwind: bb81];
    }

    bb74: {
        _117 = &_118;
        _116 = <ANSIGenericStrings<'_, str> as ToString>::to_string(move _117) -> [return: bb75, unwind: bb81];
    }

    bb75: {
        _123 = &((*_114).1: output::cell::DisplayWidth);
        _122 = <DisplayWidth as Deref>::deref(move _123) -> [return: bb76, unwind: bb79];
    }

    bb76: {
        _121 = (*_122);
        _115 = term_grid::Cell { contents: move _116, width: move _121 };
        _125 = &mut _67;
        _124 = Grid::add(move _125, move _115) -> [return: bb97, unwind: bb81];
    }

    bb77: {
        _0 = move _67;
        drop(_58) -> [return: bb78, unwind: bb92];
    }

    bb78: {
        _133 = const false;
        return;
    }

    bb79 (cleanup): {
        drop(_116) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb80 (cleanup): {
        drop(_88) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        drop(_67) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        drop(_58) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        drop(_33) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb84 (cleanup): {
        resume;
    }

    bb85 (cleanup): {
        drop(_54) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb86 (cleanup): {
        switchInt(_130) -> [0: bb88, otherwise: bb85];
    }

    bb87 (cleanup): {
        drop(_53) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb88 (cleanup): {
        switchInt(_131) -> [0: bb90, otherwise: bb87];
    }

    bb89 (cleanup): {
        drop(_39) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        switchInt(_132) -> [0: bb83, otherwise: bb89];
    }

    bb91 (cleanup): {
        drop(_7) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        switchInt(_133) -> [0: bb94, otherwise: bb91];
    }

    bb93 (cleanup): {
        drop(_5) -> [return: bb84, unwind terminate(cleanup)];
    }

    bb94 (cleanup): {
        switchInt(_134) -> [0: bb84, otherwise: bb93];
    }

    bb95: {
        goto -> bb3;
    }

    bb96: {
        goto -> bb51;
    }

    bb97: {
        goto -> bb70;
    }
}

fn grid_details::<impl at src/output/grid_details.rs:93:1: 93:20>::make_grid::{closure#0}(_1: &mut {closure@src/output/grid_details.rs:247:18: 247:41}, _2: (Table<'_>, Vec<details::Row>)) -> Vec<TextCell> {
    debug drender => (*((*_1).0: &&output::details::Render<'_>));
    let mut _0: std::vec::Vec<output::cell::TextCell>;
    let _3: output::table::Table<'_>;
    let _4: std::vec::Vec<output::details::Row>;
    let mut _5: output::details::TableIter<'_>;
    let mut _6: &&output::details::Render<'_>;
    let mut _7: &output::details::Render<'_>;
    scope 1 {
        debug table => _3;
        debug details_rows => _4;
    }

    bb0: {
        _3 = move (_2.0: output::table::Table<'_>);
        _4 = move (_2.1: std::vec::Vec<output::details::Row>);
        _6 = deref_copy ((*_1).0: &&output::details::Render<'_>);
        _7 = deref_copy (*_6);
        _5 = details::Render::<'_>::iterate_with_table(_7, move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <TableIter<'_> as Iterator>::collect::<Vec<TextCell>>(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn divide_rounding_up(_1: usize, _2: usize) -> usize {
    debug a => _1;
    debug b => _2;
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: bool;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: (usize, bool);
    scope 1 {
        debug result => _3;
    }

    bb0: {
        _4 = Eq(_2, const 0_usize);
        assert(!move _4, "attempt to divide `{}` by zero", _1) -> [success: bb1, unwind continue];
    }

    bb1: {
        _3 = Div(_1, _2);
        _6 = Eq(_2, const 0_usize);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = Rem(_1, _2);
        switchInt(move _5) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _7 = CheckedAdd(_3, const 1_usize);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, const 1_usize) -> [success: bb4, unwind continue];
    }

    bb4: {
        _3 = move (_7.0: usize);
        goto -> bb5;
    }

    bb5: {
        _0 = _3;
        return;
    }
}

fn file_has_xattrs(_1: &file::File<'_>) -> bool {
    debug file => _1;
    let mut _0: bool;
    let mut _2: std::result::Result<std::vec::Vec<fs::feature::xattr::Attribute>, std::io::Error>;
    let _3: &std::path::Path;
    let mut _4: &std::path::PathBuf;
    let mut _5: isize;
    let _6: std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _7: bool;
    let mut _8: &std::vec::Vec<fs::feature::xattr::Attribute>;
    let mut _9: isize;
    let mut _10: isize;
    scope 1 {
        debug attrs => _6;
    }

    bb0: {
        _4 = &((*_1).2: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Path as FileAttributes>::attributes(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = const false;
        goto -> bb11;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Ok).0: std::vec::Vec<fs::feature::xattr::Attribute>);
        _8 = &_6;
        _7 = Vec::<Attribute>::is_empty(move _8) -> [return: bb6, unwind: bb7];
    }

    bb6: {
        _0 = Not(move _7);
        drop(_6) -> [return: bb11, unwind: bb13];
    }

    bb7 (cleanup): {
        drop(_6) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9: {
        return;
    }

    bb10: {
        drop(_2) -> [return: bb9, unwind continue];
    }

    bb11: {
        _9 = discriminant(_2);
        switchInt(move _9) -> [0: bb9, otherwise: bb10];
    }

    bb12 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        _10 = discriminant(_2);
        switchInt(move _10) -> [0: bb8, otherwise: bb12];
    }
}

fn icons::<impl at src/output/icons.rs:14:16: 14:21>::clone(_1: &Icons) -> Icons {
    debug self => _1;
    let mut _0: output::icons::Icons;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn icons::<impl at src/output/icons.rs:21:1: 21:11>::value(_1: Icons) -> char {
    debug self => _1;
    let mut _0: char;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const '\u{f03d}';
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const '\u{f001}';
        goto -> bb5;
    }

    bb4: {
        _0 = const '\u{f1c5}';
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn iconify_style(_1: Style) -> Style {
    debug style => _1;
    let mut _0: ansi_term::Style;
    let mut _2: std::option::Option<ansi_term::Style>;
    let mut _3: std::option::Option<ansi_term::Colour>;
    let mut _4: std::option::Option<ansi_term::Colour>;
    let mut _5: std::option::Option<ansi_term::Colour>;

    bb0: {
        _4 = (_1.1: std::option::Option<ansi_term::Colour>);
        _5 = (_1.0: std::option::Option<ansi_term::Colour>);
        _3 = Option::<Color>::or(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<Color>::map::<Style, fn(Color) -> Style {<Style as From<Color>>::from}>(move _3, <Style as From<Color>>::from) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Option::<Style>::unwrap_or_default(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

static MAP_BY_NAME: MAP_BY_NAME = {
    let mut _0: output::icons::MAP_BY_NAME;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = MAP_BY_NAME { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn icons::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &MAP_BY_NAME) -> &HashMap<&str, char> {
    debug self => _1;
    let mut _0: &std::collections::HashMap<&str, char>;

    bb0: {
        _0 = <MAP_BY_NAME as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn icons::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> HashMap<&str, char> {
    let mut _0: std::collections::HashMap<&str, char>;
    let mut _1: std::collections::HashMap<&str, char>;
    let _2: std::option::Option<char>;
    let mut _3: &mut std::collections::HashMap<&str, char>;
    let _4: std::option::Option<char>;
    let mut _5: &mut std::collections::HashMap<&str, char>;
    let _6: &str;
    let _7: std::option::Option<char>;
    let mut _8: &mut std::collections::HashMap<&str, char>;
    let _9: &str;
    let _10: std::option::Option<char>;
    let mut _11: &mut std::collections::HashMap<&str, char>;
    let _12: &str;
    let _13: std::option::Option<char>;
    let mut _14: &mut std::collections::HashMap<&str, char>;
    let _15: &str;
    let _16: std::option::Option<char>;
    let mut _17: &mut std::collections::HashMap<&str, char>;
    let _18: &str;
    let _19: std::option::Option<char>;
    let mut _20: &mut std::collections::HashMap<&str, char>;
    let _21: &str;
    let _22: std::option::Option<char>;
    let mut _23: &mut std::collections::HashMap<&str, char>;
    let _24: &str;
    let _25: std::option::Option<char>;
    let mut _26: &mut std::collections::HashMap<&str, char>;
    let _27: &str;
    let _28: std::option::Option<char>;
    let mut _29: &mut std::collections::HashMap<&str, char>;
    let _30: &str;
    let _31: std::option::Option<char>;
    let mut _32: &mut std::collections::HashMap<&str, char>;
    let _33: &str;
    let _34: std::option::Option<char>;
    let mut _35: &mut std::collections::HashMap<&str, char>;
    let _36: &str;
    let _37: std::option::Option<char>;
    let mut _38: &mut std::collections::HashMap<&str, char>;
    let _39: &str;
    let _40: std::option::Option<char>;
    let mut _41: &mut std::collections::HashMap<&str, char>;
    let _42: &str;
    let _43: std::option::Option<char>;
    let mut _44: &mut std::collections::HashMap<&str, char>;
    let _45: &str;
    let _46: std::option::Option<char>;
    let mut _47: &mut std::collections::HashMap<&str, char>;
    let _48: &str;
    let _49: std::option::Option<char>;
    let mut _50: &mut std::collections::HashMap<&str, char>;
    let _51: &str;
    let _52: std::option::Option<char>;
    let mut _53: &mut std::collections::HashMap<&str, char>;
    let _54: &str;
    let _55: std::option::Option<char>;
    let mut _56: &mut std::collections::HashMap<&str, char>;
    let _57: &str;
    let _58: std::option::Option<char>;
    let mut _59: &mut std::collections::HashMap<&str, char>;
    let _60: &str;
    let _61: std::option::Option<char>;
    let mut _62: &mut std::collections::HashMap<&str, char>;
    let _63: &str;
    let _64: std::option::Option<char>;
    let mut _65: &mut std::collections::HashMap<&str, char>;
    let _66: &str;
    let _67: std::option::Option<char>;
    let mut _68: &mut std::collections::HashMap<&str, char>;
    let _69: &str;
    let _70: std::option::Option<char>;
    let mut _71: &mut std::collections::HashMap<&str, char>;
    let _72: &str;
    let _73: std::option::Option<char>;
    let mut _74: &mut std::collections::HashMap<&str, char>;
    let _75: &str;
    let _76: std::option::Option<char>;
    let mut _77: &mut std::collections::HashMap<&str, char>;
    let _78: &str;
    let _79: std::option::Option<char>;
    let mut _80: &mut std::collections::HashMap<&str, char>;
    let _81: &str;
    let _82: std::option::Option<char>;
    let mut _83: &mut std::collections::HashMap<&str, char>;
    let _84: &str;
    let _85: std::option::Option<char>;
    let mut _86: &mut std::collections::HashMap<&str, char>;
    let _87: &str;
    let _88: std::option::Option<char>;
    let mut _89: &mut std::collections::HashMap<&str, char>;
    let _90: &str;
    let _91: std::option::Option<char>;
    let mut _92: &mut std::collections::HashMap<&str, char>;
    let _93: &str;
    let _94: std::option::Option<char>;
    let mut _95: &mut std::collections::HashMap<&str, char>;
    let _96: &str;
    let _97: std::option::Option<char>;
    let mut _98: &mut std::collections::HashMap<&str, char>;
    let _99: &str;
    let _100: std::option::Option<char>;
    let mut _101: &mut std::collections::HashMap<&str, char>;
    let _102: &str;
    let _103: std::option::Option<char>;
    let mut _104: &mut std::collections::HashMap<&str, char>;
    let _105: &str;
    let _106: std::option::Option<char>;
    let mut _107: &mut std::collections::HashMap<&str, char>;
    let _108: &str;
    let _109: std::option::Option<char>;
    let mut _110: &mut std::collections::HashMap<&str, char>;
    let _111: &str;
    scope 1 {
        debug m => _1;
    }

    bb0: {
        _1 = HashMap::<&str, char>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &mut _1;
        _2 = HashMap::<&str, char>::insert(move _3, const ".Trash", const '\u{f1f8}') -> [return: bb2, unwind: bb39];
    }

    bb2: {
        _5 = &mut _1;
        _6 = const ".atom";
        _4 = HashMap::<&str, char>::insert(move _5, _6, const '\u{e764}') -> [return: bb3, unwind: bb39];
    }

    bb3: {
        _8 = &mut _1;
        _9 = const ".bashprofile";
        _7 = HashMap::<&str, char>::insert(move _8, _9, const '\u{e615}') -> [return: bb4, unwind: bb39];
    }

    bb4: {
        _11 = &mut _1;
        _12 = const ".bashrc";
        _10 = HashMap::<&str, char>::insert(move _11, _12, const '\u{f489}') -> [return: bb5, unwind: bb39];
    }

    bb5: {
        _14 = &mut _1;
        _15 = const ".git";
        _13 = HashMap::<&str, char>::insert(move _14, _15, const '\u{f1d3}') -> [return: bb6, unwind: bb39];
    }

    bb6: {
        _17 = &mut _1;
        _18 = const ".gitattributes";
        _16 = HashMap::<&str, char>::insert(move _17, _18, const '\u{f1d3}') -> [return: bb7, unwind: bb39];
    }

    bb7: {
        _20 = &mut _1;
        _21 = const ".gitconfig";
        _19 = HashMap::<&str, char>::insert(move _20, _21, const '\u{f1d3}') -> [return: bb8, unwind: bb39];
    }

    bb8: {
        _23 = &mut _1;
        _24 = const ".github";
        _22 = HashMap::<&str, char>::insert(move _23, _24, const '\u{f408}') -> [return: bb9, unwind: bb39];
    }

    bb9: {
        _26 = &mut _1;
        _27 = const ".gitignore";
        _25 = HashMap::<&str, char>::insert(move _26, _27, const '\u{f1d3}') -> [return: bb10, unwind: bb39];
    }

    bb10: {
        _29 = &mut _1;
        _30 = const ".gitmodules";
        _28 = HashMap::<&str, char>::insert(move _29, _30, const '\u{f1d3}') -> [return: bb11, unwind: bb39];
    }

    bb11: {
        _32 = &mut _1;
        _33 = const ".rvm";
        _31 = HashMap::<&str, char>::insert(move _32, _33, const '\u{e21e}') -> [return: bb12, unwind: bb39];
    }

    bb12: {
        _35 = &mut _1;
        _36 = const ".vimrc";
        _34 = HashMap::<&str, char>::insert(move _35, _36, const '\u{e62b}') -> [return: bb13, unwind: bb39];
    }

    bb13: {
        _38 = &mut _1;
        _39 = const ".vscode";
        _37 = HashMap::<&str, char>::insert(move _38, _39, const '\u{e70c}') -> [return: bb14, unwind: bb39];
    }

    bb14: {
        _41 = &mut _1;
        _42 = const ".zshrc";
        _40 = HashMap::<&str, char>::insert(move _41, _42, const '\u{f489}') -> [return: bb15, unwind: bb39];
    }

    bb15: {
        _44 = &mut _1;
        _45 = const "Cargo.lock";
        _43 = HashMap::<&str, char>::insert(move _44, _45, const '\u{e7a8}') -> [return: bb16, unwind: bb39];
    }

    bb16: {
        _47 = &mut _1;
        _48 = const "bin";
        _46 = HashMap::<&str, char>::insert(move _47, _48, const '\u{e5fc}') -> [return: bb17, unwind: bb39];
    }

    bb17: {
        _50 = &mut _1;
        _51 = const "config";
        _49 = HashMap::<&str, char>::insert(move _50, _51, const '\u{e5fc}') -> [return: bb18, unwind: bb39];
    }

    bb18: {
        _53 = &mut _1;
        _54 = const "docker-compose.yml";
        _52 = HashMap::<&str, char>::insert(move _53, _54, const '\u{f308}') -> [return: bb19, unwind: bb39];
    }

    bb19: {
        _56 = &mut _1;
        _57 = const "Dockerfile";
        _55 = HashMap::<&str, char>::insert(move _56, _57, const '\u{f308}') -> [return: bb20, unwind: bb39];
    }

    bb20: {
        _59 = &mut _1;
        _60 = const "ds_store";
        _58 = HashMap::<&str, char>::insert(move _59, _60, const '\u{f179}') -> [return: bb21, unwind: bb39];
    }

    bb21: {
        _62 = &mut _1;
        _63 = const "gitignore_global";
        _61 = HashMap::<&str, char>::insert(move _62, _63, const '\u{f1d3}') -> [return: bb22, unwind: bb39];
    }

    bb22: {
        _65 = &mut _1;
        _66 = const "gradle";
        _64 = HashMap::<&str, char>::insert(move _65, _66, const '\u{e70e}') -> [return: bb23, unwind: bb39];
    }

    bb23: {
        _68 = &mut _1;
        _69 = const "gruntfile.coffee";
        _67 = HashMap::<&str, char>::insert(move _68, _69, const '\u{e611}') -> [return: bb24, unwind: bb39];
    }

    bb24: {
        _71 = &mut _1;
        _72 = const "gruntfile.js";
        _70 = HashMap::<&str, char>::insert(move _71, _72, const '\u{e611}') -> [return: bb25, unwind: bb39];
    }

    bb25: {
        _74 = &mut _1;
        _75 = const "gruntfile.ls";
        _73 = HashMap::<&str, char>::insert(move _74, _75, const '\u{e611}') -> [return: bb26, unwind: bb39];
    }

    bb26: {
        _77 = &mut _1;
        _78 = const "gulpfile.coffee";
        _76 = HashMap::<&str, char>::insert(move _77, _78, const '\u{e610}') -> [return: bb27, unwind: bb39];
    }

    bb27: {
        _80 = &mut _1;
        _81 = const "gulpfile.js";
        _79 = HashMap::<&str, char>::insert(move _80, _81, const '\u{e610}') -> [return: bb28, unwind: bb39];
    }

    bb28: {
        _83 = &mut _1;
        _84 = const "gulpfile.ls";
        _82 = HashMap::<&str, char>::insert(move _83, _84, const '\u{e610}') -> [return: bb29, unwind: bb39];
    }

    bb29: {
        _86 = &mut _1;
        _87 = const "hidden";
        _85 = HashMap::<&str, char>::insert(move _86, _87, const '\u{f023}') -> [return: bb30, unwind: bb39];
    }

    bb30: {
        _89 = &mut _1;
        _90 = const "include";
        _88 = HashMap::<&str, char>::insert(move _89, _90, const '\u{e5fc}') -> [return: bb31, unwind: bb39];
    }

    bb31: {
        _92 = &mut _1;
        _93 = const "lib";
        _91 = HashMap::<&str, char>::insert(move _92, _93, const '\u{f121}') -> [return: bb32, unwind: bb39];
    }

    bb32: {
        _95 = &mut _1;
        _96 = const "localized";
        _94 = HashMap::<&str, char>::insert(move _95, _96, const '\u{f179}') -> [return: bb33, unwind: bb39];
    }

    bb33: {
        _98 = &mut _1;
        _99 = const "Makefile";
        _97 = HashMap::<&str, char>::insert(move _98, _99, const '\u{e779}') -> [return: bb34, unwind: bb39];
    }

    bb34: {
        _101 = &mut _1;
        _102 = const "node_modules";
        _100 = HashMap::<&str, char>::insert(move _101, _102, const '\u{e718}') -> [return: bb35, unwind: bb39];
    }

    bb35: {
        _104 = &mut _1;
        _105 = const "npmignore";
        _103 = HashMap::<&str, char>::insert(move _104, _105, const '\u{e71e}') -> [return: bb36, unwind: bb39];
    }

    bb36: {
        _107 = &mut _1;
        _108 = const "rubydoc";
        _106 = HashMap::<&str, char>::insert(move _107, _108, const '\u{e73b}') -> [return: bb37, unwind: bb39];
    }

    bb37: {
        _110 = &mut _1;
        _111 = const "yarn.lock";
        _109 = HashMap::<&str, char>::insert(move _110, _111, const '\u{e718}') -> [return: bb38, unwind: bb39];
    }

    bb38: {
        _0 = move _1;
        return;
    }

    bb39 (cleanup): {
        drop(_1) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        resume;
    }
}

fn icons::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &HashMap<&str, char> {
    let mut _0: &std::collections::HashMap<&str, char>;
    let _1: &lazy_static::lazy::Lazy<std::collections::HashMap<&str, char>>;

    bb0: {
        _1 = const {alloc66: &Lazy<HashMap<&str, char>>};
        _0 = Lazy::<HashMap<&str, char>>::get::<fn() -> HashMap<&'static str, char> {<MAP_BY_NAME as Deref>::deref::__static_ref_initialize}>(_1, <MAP_BY_NAME as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc66 (static: <MAP_BY_NAME as Deref>::deref::__stability::LAZY, size: 56, align: 8) {
    0x00  00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x20  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x30  00 00 00 00 __ __ __ __                          ....
}

static icons::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<HashMap<&str, char>> = {
    let mut _0: lazy_static::lazy::Lazy<std::collections::HashMap<&str, char>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn icons::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &MAP_BY_NAME) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &std::collections::HashMap<&str, char>;
    scope 1 {
    }

    bb0: {
        _2 = <MAP_BY_NAME as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn icon_for_file(_1: &file::File<'_>) -> char {
    debug file => _1;
    let mut _0: char;
    let _2: std::boxed::Box<info::filetype::FileExtensions>;
    let mut _3: std::option::Option<&char>;
    let _4: &std::collections::HashMap<&str, char>;
    let _5: &output::icons::MAP_BY_NAME;
    let _6: &str;
    let mut _7: &std::string::String;
    let mut _8: isize;
    let mut _10: bool;
    let mut _11: &str;
    let mut _12: &std::string::String;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: std::option::Option<char>;
    let mut _17: &info::filetype::FileExtensions;
    let mut _18: isize;
    let mut _20: std::option::Option<&std::string::String>;
    let mut _21: &std::option::Option<std::string::String>;
    let mut _22: isize;
    let mut _24: &str;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: bool;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: bool;
    let mut _58: bool;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: bool;
    let mut _70: bool;
    let mut _71: bool;
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: bool;
    let mut _77: bool;
    let mut _78: bool;
    let mut _79: bool;
    let mut _80: bool;
    let mut _81: bool;
    let mut _82: bool;
    let mut _83: bool;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: bool;
    let mut _98: bool;
    let mut _99: bool;
    let mut _100: bool;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: bool;
    let mut _106: bool;
    let mut _107: bool;
    let mut _108: bool;
    let mut _109: bool;
    let mut _110: bool;
    let mut _111: bool;
    let mut _112: bool;
    let mut _113: bool;
    let mut _114: bool;
    let mut _115: bool;
    let mut _116: bool;
    let mut _117: bool;
    let mut _118: bool;
    let mut _119: bool;
    let mut _120: bool;
    let mut _121: bool;
    let mut _122: bool;
    let mut _123: bool;
    let mut _124: bool;
    let mut _125: bool;
    let mut _126: bool;
    let mut _127: bool;
    let mut _128: bool;
    let mut _129: bool;
    let mut _130: bool;
    let mut _131: bool;
    let mut _132: bool;
    let mut _133: bool;
    let mut _134: bool;
    let mut _135: bool;
    let mut _136: bool;
    let mut _137: bool;
    let mut _138: bool;
    let mut _139: bool;
    let mut _140: bool;
    let mut _141: bool;
    let mut _142: bool;
    let mut _143: bool;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: bool;
    let mut _147: bool;
    let mut _148: bool;
    let mut _149: bool;
    let mut _150: bool;
    let mut _151: bool;
    let mut _152: bool;
    let mut _153: bool;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: bool;
    let mut _157: bool;
    let mut _158: bool;
    let mut _159: bool;
    let mut _160: bool;
    let mut _161: bool;
    let mut _162: bool;
    let mut _163: bool;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: bool;
    let mut _167: bool;
    let mut _168: bool;
    let mut _169: bool;
    let mut _170: bool;
    let mut _171: bool;
    let mut _172: bool;
    let mut _173: bool;
    let mut _174: bool;
    let mut _175: bool;
    let mut _176: bool;
    let mut _177: bool;
    let mut _178: bool;
    let mut _179: bool;
    let mut _180: bool;
    let mut _181: bool;
    let mut _182: bool;
    let mut _183: bool;
    let mut _184: bool;
    let mut _185: bool;
    let mut _186: bool;
    let mut _187: bool;
    let mut _188: bool;
    let mut _189: bool;
    let mut _190: bool;
    let mut _191: bool;
    let mut _192: bool;
    let mut _193: bool;
    let mut _194: bool;
    let mut _195: bool;
    let mut _196: bool;
    let mut _197: bool;
    let mut _198: bool;
    let mut _199: bool;
    let mut _200: bool;
    let mut _201: bool;
    let mut _202: bool;
    let mut _203: bool;
    let mut _204: bool;
    let mut _205: bool;
    let mut _206: bool;
    let mut _207: bool;
    let mut _208: bool;
    let mut _209: bool;
    let mut _210: bool;
    let mut _211: bool;
    let mut _212: bool;
    let mut _213: bool;
    let mut _214: bool;
    let mut _215: bool;
    let mut _216: bool;
    let mut _217: bool;
    let mut _218: bool;
    let mut _219: bool;
    let mut _220: bool;
    let mut _221: bool;
    let mut _222: bool;
    let mut _223: bool;
    let mut _224: bool;
    let mut _225: bool;
    let mut _226: bool;
    let mut _227: bool;
    let mut _228: bool;
    let mut _229: bool;
    let mut _230: bool;
    let mut _231: bool;
    let mut _232: bool;
    let mut _233: bool;
    let mut _234: bool;
    let mut _235: bool;
    let mut _236: bool;
    let mut _237: bool;
    let mut _238: bool;
    let mut _239: bool;
    let mut _240: bool;
    let mut _241: bool;
    let mut _242: bool;
    let mut _243: bool;
    let mut _244: bool;
    let mut _245: bool;
    let mut _246: bool;
    let mut _247: bool;
    let mut _248: bool;
    let mut _249: bool;
    let mut _250: *const info::filetype::FileExtensions;
    scope 1 {
        debug extensions => _2;
        scope 2 {
            debug icon => _9;
            let _9: &char;
        }
        scope 3 {
            debug icon => _19;
            let _19: char;
        }
        scope 4 {
            debug ext => _23;
            let _23: &std::string::String;
        }
    }

    bb0: {
        _2 = Box::<FileExtensions>::new(const FileExtensions) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const {alloc67: &MAP_BY_NAME};
        _4 = <MAP_BY_NAME as Deref>::deref(_5) -> [return: bb2, unwind: bb704];
    }

    bb2: {
        _7 = &((*_1).0: std::string::String);
        _6 = String::as_str(move _7) -> [return: bb3, unwind: bb704];
    }

    bb3: {
        _3 = HashMap::<&str, char>::get::<str>(_4, _6) -> [return: bb4, unwind: bb704];
    }

    bb4: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _9 = ((_3 as Some).0: &char);
        _0 = (*_9);
        goto -> bb702;
    }

    bb6: {
        _10 = file::File::<'_>::points_to_directory(_1) -> [return: bb7, unwind: bb704];
    }

    bb7: {
        switchInt(move _10) -> [0: bb19, otherwise: bb8];
    }

    bb8: {
        _12 = &((*_1).0: std::string::String);
        _11 = String::as_str(move _12) -> [return: bb9, unwind: bb704];
    }

    bb9: {
        _15 = <str as PartialEq>::eq(_11, const "bin") -> [return: bb18, unwind: bb704];
    }

    bb10: {
        _0 = const '\u{e5fc}';
        goto -> bb702;
    }

    bb11: {
        _14 = <str as PartialEq>::eq(_11, const ".git") -> [return: bb17, unwind: bb704];
    }

    bb12: {
        _0 = const '\u{f1d3}';
        goto -> bb702;
    }

    bb13: {
        _13 = <str as PartialEq>::eq(_11, const ".idea") -> [return: bb16, unwind: bb704];
    }

    bb14: {
        _0 = const '\u{e7b5}';
        goto -> bb702;
    }

    bb15: {
        _0 = const '\u{f115}';
        goto -> bb702;
    }

    bb16: {
        switchInt(move _13) -> [0: bb15, otherwise: bb14];
    }

    bb17: {
        switchInt(move _14) -> [0: bb13, otherwise: bb12];
    }

    bb18: {
        switchInt(move _15) -> [0: bb11, otherwise: bb10];
    }

    bb19: {
        _250 = (((_2.0: std::ptr::Unique<info::filetype::FileExtensions>).0: std::ptr::NonNull<info::filetype::FileExtensions>).0: *const info::filetype::FileExtensions);
        _17 = &(*_250);
        _16 = <FileExtensions as FileIcon>::icon_file(move _17, _1) -> [return: bb20, unwind: bb704];
    }

    bb20: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [1: bb21, otherwise: bb22];
    }

    bb21: {
        _19 = ((_16 as Some).0: char);
        _0 = _19;
        goto -> bb702;
    }

    bb22: {
        _21 = &((*_1).1: std::option::Option<std::string::String>);
        _20 = Option::<String>::as_ref(move _21) -> [return: bb23, unwind: bb704];
    }

    bb23: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [1: bb24, otherwise: bb701];
    }

    bb24: {
        _23 = ((_20 as Some).0: &std::string::String);
        _24 = String::as_str(_23) -> [return: bb25, unwind: bb704];
    }

    bb25: {
        _249 = <str as PartialEq>::eq(_24, const "ai") -> [return: bb700, unwind: bb704];
    }

    bb26: {
        _0 = const '\u{e7b4}';
        goto -> bb702;
    }

    bb27: {
        _248 = <str as PartialEq>::eq(_24, const "android") -> [return: bb699, unwind: bb704];
    }

    bb28: {
        _0 = const '\u{e70e}';
        goto -> bb702;
    }

    bb29: {
        _247 = <str as PartialEq>::eq(_24, const "apk") -> [return: bb698, unwind: bb704];
    }

    bb30: {
        _0 = const '\u{e70e}';
        goto -> bb702;
    }

    bb31: {
        _246 = <str as PartialEq>::eq(_24, const "apple") -> [return: bb697, unwind: bb704];
    }

    bb32: {
        _0 = const '\u{f179}';
        goto -> bb702;
    }

    bb33: {
        _245 = <str as PartialEq>::eq(_24, const "avi") -> [return: bb696, unwind: bb704];
    }

    bb34: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb35: {
        _244 = <str as PartialEq>::eq(_24, const "avro") -> [return: bb695, unwind: bb704];
    }

    bb36: {
        _0 = const '\u{e60b}';
        goto -> bb702;
    }

    bb37: {
        _243 = <str as PartialEq>::eq(_24, const "awk") -> [return: bb694, unwind: bb704];
    }

    bb38: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb39: {
        _242 = <str as PartialEq>::eq(_24, const "bash") -> [return: bb693, unwind: bb704];
    }

    bb40: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb41: {
        _241 = <str as PartialEq>::eq(_24, const "bash_history") -> [return: bb692, unwind: bb704];
    }

    bb42: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb43: {
        _240 = <str as PartialEq>::eq(_24, const "bash_profile") -> [return: bb691, unwind: bb704];
    }

    bb44: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb45: {
        _239 = <str as PartialEq>::eq(_24, const "bashrc") -> [return: bb690, unwind: bb704];
    }

    bb46: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb47: {
        _238 = <str as PartialEq>::eq(_24, const "bat") -> [return: bb689, unwind: bb704];
    }

    bb48: {
        _0 = const '\u{f17a}';
        goto -> bb702;
    }

    bb49: {
        _237 = <str as PartialEq>::eq(_24, const "bmp") -> [return: bb688, unwind: bb704];
    }

    bb50: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb51: {
        _236 = <str as PartialEq>::eq(_24, const "bz") -> [return: bb687, unwind: bb704];
    }

    bb52: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb53: {
        _235 = <str as PartialEq>::eq(_24, const "bz2") -> [return: bb686, unwind: bb704];
    }

    bb54: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb55: {
        _234 = <str as PartialEq>::eq(_24, const "c") -> [return: bb685, unwind: bb704];
    }

    bb56: {
        _0 = const '\u{e61e}';
        goto -> bb702;
    }

    bb57: {
        _233 = <str as PartialEq>::eq(_24, const "c++") -> [return: bb684, unwind: bb704];
    }

    bb58: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb59: {
        _232 = <str as PartialEq>::eq(_24, const "cab") -> [return: bb683, unwind: bb704];
    }

    bb60: {
        _0 = const '\u{e70f}';
        goto -> bb702;
    }

    bb61: {
        _231 = <str as PartialEq>::eq(_24, const "cc") -> [return: bb682, unwind: bb704];
    }

    bb62: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb63: {
        _230 = <str as PartialEq>::eq(_24, const "cfg") -> [return: bb681, unwind: bb704];
    }

    bb64: {
        _0 = const '\u{e615}';
        goto -> bb702;
    }

    bb65: {
        _229 = <str as PartialEq>::eq(_24, const "class") -> [return: bb680, unwind: bb704];
    }

    bb66: {
        _0 = const '\u{e256}';
        goto -> bb702;
    }

    bb67: {
        _228 = <str as PartialEq>::eq(_24, const "clj") -> [return: bb679, unwind: bb704];
    }

    bb68: {
        _0 = const '\u{e768}';
        goto -> bb702;
    }

    bb69: {
        _227 = <str as PartialEq>::eq(_24, const "cljs") -> [return: bb678, unwind: bb704];
    }

    bb70: {
        _0 = const '\u{e76a}';
        goto -> bb702;
    }

    bb71: {
        _226 = <str as PartialEq>::eq(_24, const "cls") -> [return: bb677, unwind: bb704];
    }

    bb72: {
        _0 = const '\u{f034}';
        goto -> bb702;
    }

    bb73: {
        _225 = <str as PartialEq>::eq(_24, const "cmd") -> [return: bb676, unwind: bb704];
    }

    bb74: {
        _0 = const '\u{e70f}';
        goto -> bb702;
    }

    bb75: {
        _224 = <str as PartialEq>::eq(_24, const "coffee") -> [return: bb675, unwind: bb704];
    }

    bb76: {
        _0 = const '\u{f0f4}';
        goto -> bb702;
    }

    bb77: {
        _223 = <str as PartialEq>::eq(_24, const "conf") -> [return: bb674, unwind: bb704];
    }

    bb78: {
        _0 = const '\u{e615}';
        goto -> bb702;
    }

    bb79: {
        _222 = <str as PartialEq>::eq(_24, const "cp") -> [return: bb673, unwind: bb704];
    }

    bb80: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb81: {
        _221 = <str as PartialEq>::eq(_24, const "cpp") -> [return: bb672, unwind: bb704];
    }

    bb82: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb83: {
        _220 = <str as PartialEq>::eq(_24, const "cs") -> [return: bb671, unwind: bb704];
    }

    bb84: {
        _0 = const '\u{f81a}';
        goto -> bb702;
    }

    bb85: {
        _219 = <str as PartialEq>::eq(_24, const "csh") -> [return: bb670, unwind: bb704];
    }

    bb86: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb87: {
        _218 = <str as PartialEq>::eq(_24, const "cshtml") -> [return: bb669, unwind: bb704];
    }

    bb88: {
        _0 = const '\u{f1fa}';
        goto -> bb702;
    }

    bb89: {
        _217 = <str as PartialEq>::eq(_24, const "csproj") -> [return: bb668, unwind: bb704];
    }

    bb90: {
        _0 = const '\u{f81a}';
        goto -> bb702;
    }

    bb91: {
        _216 = <str as PartialEq>::eq(_24, const "css") -> [return: bb667, unwind: bb704];
    }

    bb92: {
        _0 = const '\u{e749}';
        goto -> bb702;
    }

    bb93: {
        _215 = <str as PartialEq>::eq(_24, const "csv") -> [return: bb666, unwind: bb704];
    }

    bb94: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb95: {
        _214 = <str as PartialEq>::eq(_24, const "csx") -> [return: bb665, unwind: bb704];
    }

    bb96: {
        _0 = const '\u{f81a}';
        goto -> bb702;
    }

    bb97: {
        _213 = <str as PartialEq>::eq(_24, const "cxx") -> [return: bb664, unwind: bb704];
    }

    bb98: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb99: {
        _212 = <str as PartialEq>::eq(_24, const "d") -> [return: bb663, unwind: bb704];
    }

    bb100: {
        _0 = const '\u{e7af}';
        goto -> bb702;
    }

    bb101: {
        _211 = <str as PartialEq>::eq(_24, const "dart") -> [return: bb662, unwind: bb704];
    }

    bb102: {
        _0 = const '\u{e798}';
        goto -> bb702;
    }

    bb103: {
        _210 = <str as PartialEq>::eq(_24, const "db") -> [return: bb661, unwind: bb704];
    }

    bb104: {
        _0 = const '\u{f1c0}';
        goto -> bb702;
    }

    bb105: {
        _209 = <str as PartialEq>::eq(_24, const "deb") -> [return: bb660, unwind: bb704];
    }

    bb106: {
        _0 = const '\u{e77d}';
        goto -> bb702;
    }

    bb107: {
        _208 = <str as PartialEq>::eq(_24, const "diff") -> [return: bb659, unwind: bb704];
    }

    bb108: {
        _0 = const '\u{f440}';
        goto -> bb702;
    }

    bb109: {
        _207 = <str as PartialEq>::eq(_24, const "djvu") -> [return: bb658, unwind: bb704];
    }

    bb110: {
        _0 = const '\u{f02d}';
        goto -> bb702;
    }

    bb111: {
        _206 = <str as PartialEq>::eq(_24, const "dll") -> [return: bb657, unwind: bb704];
    }

    bb112: {
        _0 = const '\u{e70f}';
        goto -> bb702;
    }

    bb113: {
        _205 = <str as PartialEq>::eq(_24, const "doc") -> [return: bb656, unwind: bb704];
    }

    bb114: {
        _0 = const '\u{f1c2}';
        goto -> bb702;
    }

    bb115: {
        _204 = <str as PartialEq>::eq(_24, const "docx") -> [return: bb655, unwind: bb704];
    }

    bb116: {
        _0 = const '\u{f1c2}';
        goto -> bb702;
    }

    bb117: {
        _203 = <str as PartialEq>::eq(_24, const "ds_store") -> [return: bb654, unwind: bb704];
    }

    bb118: {
        _0 = const '\u{f179}';
        goto -> bb702;
    }

    bb119: {
        _202 = <str as PartialEq>::eq(_24, const "DS_store") -> [return: bb653, unwind: bb704];
    }

    bb120: {
        _0 = const '\u{f179}';
        goto -> bb702;
    }

    bb121: {
        _201 = <str as PartialEq>::eq(_24, const "dump") -> [return: bb652, unwind: bb704];
    }

    bb122: {
        _0 = const '\u{f1c0}';
        goto -> bb702;
    }

    bb123: {
        _200 = <str as PartialEq>::eq(_24, const "ebook") -> [return: bb651, unwind: bb704];
    }

    bb124: {
        _0 = const '\u{e28b}';
        goto -> bb702;
    }

    bb125: {
        _199 = <str as PartialEq>::eq(_24, const "editorconfig") -> [return: bb650, unwind: bb704];
    }

    bb126: {
        _0 = const '\u{e615}';
        goto -> bb702;
    }

    bb127: {
        _198 = <str as PartialEq>::eq(_24, const "ejs") -> [return: bb649, unwind: bb704];
    }

    bb128: {
        _0 = const '\u{e618}';
        goto -> bb702;
    }

    bb129: {
        _197 = <str as PartialEq>::eq(_24, const "elm") -> [return: bb648, unwind: bb704];
    }

    bb130: {
        _0 = const '\u{e62c}';
        goto -> bb702;
    }

    bb131: {
        _196 = <str as PartialEq>::eq(_24, const "env") -> [return: bb647, unwind: bb704];
    }

    bb132: {
        _0 = const '\u{f462}';
        goto -> bb702;
    }

    bb133: {
        _195 = <str as PartialEq>::eq(_24, const "eot") -> [return: bb646, unwind: bb704];
    }

    bb134: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb135: {
        _194 = <str as PartialEq>::eq(_24, const "epub") -> [return: bb645, unwind: bb704];
    }

    bb136: {
        _0 = const '\u{e28a}';
        goto -> bb702;
    }

    bb137: {
        _193 = <str as PartialEq>::eq(_24, const "erb") -> [return: bb644, unwind: bb704];
    }

    bb138: {
        _0 = const '\u{e73b}';
        goto -> bb702;
    }

    bb139: {
        _192 = <str as PartialEq>::eq(_24, const "erl") -> [return: bb643, unwind: bb704];
    }

    bb140: {
        _0 = const '\u{e7b1}';
        goto -> bb702;
    }

    bb141: {
        _191 = <str as PartialEq>::eq(_24, const "ex") -> [return: bb642, unwind: bb704];
    }

    bb142: {
        _0 = const '\u{e62d}';
        goto -> bb702;
    }

    bb143: {
        _190 = <str as PartialEq>::eq(_24, const "exe") -> [return: bb641, unwind: bb704];
    }

    bb144: {
        _0 = const '\u{f17a}';
        goto -> bb702;
    }

    bb145: {
        _189 = <str as PartialEq>::eq(_24, const "exs") -> [return: bb640, unwind: bb704];
    }

    bb146: {
        _0 = const '\u{e62d}';
        goto -> bb702;
    }

    bb147: {
        _188 = <str as PartialEq>::eq(_24, const "fish") -> [return: bb639, unwind: bb704];
    }

    bb148: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb149: {
        _187 = <str as PartialEq>::eq(_24, const "flac") -> [return: bb638, unwind: bb704];
    }

    bb150: {
        _0 = const '\u{f001}';
        goto -> bb702;
    }

    bb151: {
        _186 = <str as PartialEq>::eq(_24, const "flv") -> [return: bb637, unwind: bb704];
    }

    bb152: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb153: {
        _185 = <str as PartialEq>::eq(_24, const "font") -> [return: bb636, unwind: bb704];
    }

    bb154: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb155: {
        _184 = <str as PartialEq>::eq(_24, const "gdoc") -> [return: bb635, unwind: bb704];
    }

    bb156: {
        _0 = const '\u{f1c2}';
        goto -> bb702;
    }

    bb157: {
        _183 = <str as PartialEq>::eq(_24, const "gem") -> [return: bb634, unwind: bb704];
    }

    bb158: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb159: {
        _182 = <str as PartialEq>::eq(_24, const "gemfile") -> [return: bb633, unwind: bb704];
    }

    bb160: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb161: {
        _181 = <str as PartialEq>::eq(_24, const "gemspec") -> [return: bb632, unwind: bb704];
    }

    bb162: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb163: {
        _180 = <str as PartialEq>::eq(_24, const "gform") -> [return: bb631, unwind: bb704];
    }

    bb164: {
        _0 = const '\u{f298}';
        goto -> bb702;
    }

    bb165: {
        _179 = <str as PartialEq>::eq(_24, const "gif") -> [return: bb630, unwind: bb704];
    }

    bb166: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb167: {
        _178 = <str as PartialEq>::eq(_24, const "git") -> [return: bb629, unwind: bb704];
    }

    bb168: {
        _0 = const '\u{f1d3}';
        goto -> bb702;
    }

    bb169: {
        _177 = <str as PartialEq>::eq(_24, const "gitattributes") -> [return: bb628, unwind: bb704];
    }

    bb170: {
        _0 = const '\u{f1d3}';
        goto -> bb702;
    }

    bb171: {
        _176 = <str as PartialEq>::eq(_24, const "gitignore") -> [return: bb627, unwind: bb704];
    }

    bb172: {
        _0 = const '\u{f1d3}';
        goto -> bb702;
    }

    bb173: {
        _175 = <str as PartialEq>::eq(_24, const "gitmodules") -> [return: bb626, unwind: bb704];
    }

    bb174: {
        _0 = const '\u{f1d3}';
        goto -> bb702;
    }

    bb175: {
        _174 = <str as PartialEq>::eq(_24, const "go") -> [return: bb625, unwind: bb704];
    }

    bb176: {
        _0 = const '\u{e626}';
        goto -> bb702;
    }

    bb177: {
        _173 = <str as PartialEq>::eq(_24, const "gradle") -> [return: bb624, unwind: bb704];
    }

    bb178: {
        _0 = const '\u{e70e}';
        goto -> bb702;
    }

    bb179: {
        _172 = <str as PartialEq>::eq(_24, const "groovy") -> [return: bb623, unwind: bb704];
    }

    bb180: {
        _0 = const '\u{e775}';
        goto -> bb702;
    }

    bb181: {
        _171 = <str as PartialEq>::eq(_24, const "gsheet") -> [return: bb622, unwind: bb704];
    }

    bb182: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb183: {
        _170 = <str as PartialEq>::eq(_24, const "gslides") -> [return: bb621, unwind: bb704];
    }

    bb184: {
        _0 = const '\u{f1c4}';
        goto -> bb702;
    }

    bb185: {
        _169 = <str as PartialEq>::eq(_24, const "guardfile") -> [return: bb620, unwind: bb704];
    }

    bb186: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb187: {
        _168 = <str as PartialEq>::eq(_24, const "gz") -> [return: bb619, unwind: bb704];
    }

    bb188: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb189: {
        _167 = <str as PartialEq>::eq(_24, const "h") -> [return: bb618, unwind: bb704];
    }

    bb190: {
        _0 = const '\u{f0fd}';
        goto -> bb702;
    }

    bb191: {
        _166 = <str as PartialEq>::eq(_24, const "hbs") -> [return: bb617, unwind: bb704];
    }

    bb192: {
        _0 = const '\u{e60f}';
        goto -> bb702;
    }

    bb193: {
        _165 = <str as PartialEq>::eq(_24, const "hpp") -> [return: bb616, unwind: bb704];
    }

    bb194: {
        _0 = const '\u{f0fd}';
        goto -> bb702;
    }

    bb195: {
        _164 = <str as PartialEq>::eq(_24, const "hs") -> [return: bb615, unwind: bb704];
    }

    bb196: {
        _0 = const '\u{e777}';
        goto -> bb702;
    }

    bb197: {
        _163 = <str as PartialEq>::eq(_24, const "htm") -> [return: bb614, unwind: bb704];
    }

    bb198: {
        _0 = const '\u{f13b}';
        goto -> bb702;
    }

    bb199: {
        _162 = <str as PartialEq>::eq(_24, const "html") -> [return: bb613, unwind: bb704];
    }

    bb200: {
        _0 = const '\u{f13b}';
        goto -> bb702;
    }

    bb201: {
        _161 = <str as PartialEq>::eq(_24, const "hxx") -> [return: bb612, unwind: bb704];
    }

    bb202: {
        _0 = const '\u{f0fd}';
        goto -> bb702;
    }

    bb203: {
        _160 = <str as PartialEq>::eq(_24, const "ico") -> [return: bb611, unwind: bb704];
    }

    bb204: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb205: {
        _159 = <str as PartialEq>::eq(_24, const "image") -> [return: bb610, unwind: bb704];
    }

    bb206: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb207: {
        _158 = <str as PartialEq>::eq(_24, const "iml") -> [return: bb609, unwind: bb704];
    }

    bb208: {
        _0 = const '\u{e7b5}';
        goto -> bb702;
    }

    bb209: {
        _157 = <str as PartialEq>::eq(_24, const "ini") -> [return: bb608, unwind: bb704];
    }

    bb210: {
        _0 = const '\u{f17a}';
        goto -> bb702;
    }

    bb211: {
        _156 = <str as PartialEq>::eq(_24, const "ipynb") -> [return: bb607, unwind: bb704];
    }

    bb212: {
        _0 = const '\u{e606}';
        goto -> bb702;
    }

    bb213: {
        _155 = <str as PartialEq>::eq(_24, const "iso") -> [return: bb606, unwind: bb704];
    }

    bb214: {
        _0 = const '\u{e271}';
        goto -> bb702;
    }

    bb215: {
        _154 = <str as PartialEq>::eq(_24, const "jad") -> [return: bb605, unwind: bb704];
    }

    bb216: {
        _0 = const '\u{e256}';
        goto -> bb702;
    }

    bb217: {
        _153 = <str as PartialEq>::eq(_24, const "jar") -> [return: bb604, unwind: bb704];
    }

    bb218: {
        _0 = const '\u{e204}';
        goto -> bb702;
    }

    bb219: {
        _152 = <str as PartialEq>::eq(_24, const "java") -> [return: bb603, unwind: bb704];
    }

    bb220: {
        _0 = const '\u{e204}';
        goto -> bb702;
    }

    bb221: {
        _151 = <str as PartialEq>::eq(_24, const "jpeg") -> [return: bb602, unwind: bb704];
    }

    bb222: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb223: {
        _150 = <str as PartialEq>::eq(_24, const "jpg") -> [return: bb601, unwind: bb704];
    }

    bb224: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb225: {
        _149 = <str as PartialEq>::eq(_24, const "js") -> [return: bb600, unwind: bb704];
    }

    bb226: {
        _0 = const '\u{e74e}';
        goto -> bb702;
    }

    bb227: {
        _148 = <str as PartialEq>::eq(_24, const "json") -> [return: bb599, unwind: bb704];
    }

    bb228: {
        _0 = const '\u{e60b}';
        goto -> bb702;
    }

    bb229: {
        _147 = <str as PartialEq>::eq(_24, const "jsx") -> [return: bb598, unwind: bb704];
    }

    bb230: {
        _0 = const '\u{e7ba}';
        goto -> bb702;
    }

    bb231: {
        _146 = <str as PartialEq>::eq(_24, const "ksh") -> [return: bb597, unwind: bb704];
    }

    bb232: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb233: {
        _145 = <str as PartialEq>::eq(_24, const "latex") -> [return: bb596, unwind: bb704];
    }

    bb234: {
        _0 = const '\u{f034}';
        goto -> bb702;
    }

    bb235: {
        _144 = <str as PartialEq>::eq(_24, const "less") -> [return: bb595, unwind: bb704];
    }

    bb236: {
        _0 = const '\u{e758}';
        goto -> bb702;
    }

    bb237: {
        _143 = <str as PartialEq>::eq(_24, const "lhs") -> [return: bb594, unwind: bb704];
    }

    bb238: {
        _0 = const '\u{e777}';
        goto -> bb702;
    }

    bb239: {
        _142 = <str as PartialEq>::eq(_24, const "license") -> [return: bb593, unwind: bb704];
    }

    bb240: {
        _0 = const '\u{f718}';
        goto -> bb702;
    }

    bb241: {
        _141 = <str as PartialEq>::eq(_24, const "localized") -> [return: bb592, unwind: bb704];
    }

    bb242: {
        _0 = const '\u{f179}';
        goto -> bb702;
    }

    bb243: {
        _140 = <str as PartialEq>::eq(_24, const "lock") -> [return: bb591, unwind: bb704];
    }

    bb244: {
        _0 = const '\u{f023}';
        goto -> bb702;
    }

    bb245: {
        _139 = <str as PartialEq>::eq(_24, const "log") -> [return: bb590, unwind: bb704];
    }

    bb246: {
        _0 = const '\u{f18d}';
        goto -> bb702;
    }

    bb247: {
        _138 = <str as PartialEq>::eq(_24, const "lua") -> [return: bb589, unwind: bb704];
    }

    bb248: {
        _0 = const '\u{e620}';
        goto -> bb702;
    }

    bb249: {
        _137 = <str as PartialEq>::eq(_24, const "lz") -> [return: bb588, unwind: bb704];
    }

    bb250: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb251: {
        _136 = <str as PartialEq>::eq(_24, const "lzh") -> [return: bb587, unwind: bb704];
    }

    bb252: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb253: {
        _135 = <str as PartialEq>::eq(_24, const "lzma") -> [return: bb586, unwind: bb704];
    }

    bb254: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb255: {
        _134 = <str as PartialEq>::eq(_24, const "lzo") -> [return: bb585, unwind: bb704];
    }

    bb256: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb257: {
        _133 = <str as PartialEq>::eq(_24, const "m") -> [return: bb584, unwind: bb704];
    }

    bb258: {
        _0 = const '\u{e61e}';
        goto -> bb702;
    }

    bb259: {
        _132 = <str as PartialEq>::eq(_24, const "mm") -> [return: bb583, unwind: bb704];
    }

    bb260: {
        _0 = const '\u{e61d}';
        goto -> bb702;
    }

    bb261: {
        _131 = <str as PartialEq>::eq(_24, const "m4a") -> [return: bb582, unwind: bb704];
    }

    bb262: {
        _0 = const '\u{f001}';
        goto -> bb702;
    }

    bb263: {
        _130 = <str as PartialEq>::eq(_24, const "markdown") -> [return: bb581, unwind: bb704];
    }

    bb264: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb265: {
        _129 = <str as PartialEq>::eq(_24, const "md") -> [return: bb580, unwind: bb704];
    }

    bb266: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb267: {
        _128 = <str as PartialEq>::eq(_24, const "mjs") -> [return: bb579, unwind: bb704];
    }

    bb268: {
        _0 = const '\u{e74e}';
        goto -> bb702;
    }

    bb269: {
        _127 = <str as PartialEq>::eq(_24, const "mkd") -> [return: bb578, unwind: bb704];
    }

    bb270: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb271: {
        _126 = <str as PartialEq>::eq(_24, const "mkv") -> [return: bb577, unwind: bb704];
    }

    bb272: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb273: {
        _125 = <str as PartialEq>::eq(_24, const "mobi") -> [return: bb576, unwind: bb704];
    }

    bb274: {
        _0 = const '\u{e28b}';
        goto -> bb702;
    }

    bb275: {
        _124 = <str as PartialEq>::eq(_24, const "mov") -> [return: bb575, unwind: bb704];
    }

    bb276: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb277: {
        _123 = <str as PartialEq>::eq(_24, const "mp3") -> [return: bb574, unwind: bb704];
    }

    bb278: {
        _0 = const '\u{f001}';
        goto -> bb702;
    }

    bb279: {
        _122 = <str as PartialEq>::eq(_24, const "mp4") -> [return: bb573, unwind: bb704];
    }

    bb280: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb281: {
        _121 = <str as PartialEq>::eq(_24, const "msi") -> [return: bb572, unwind: bb704];
    }

    bb282: {
        _0 = const '\u{e70f}';
        goto -> bb702;
    }

    bb283: {
        _120 = <str as PartialEq>::eq(_24, const "mustache") -> [return: bb571, unwind: bb704];
    }

    bb284: {
        _0 = const '\u{e60f}';
        goto -> bb702;
    }

    bb285: {
        _119 = <str as PartialEq>::eq(_24, const "nix") -> [return: bb570, unwind: bb704];
    }

    bb286: {
        _0 = const '\u{f313}';
        goto -> bb702;
    }

    bb287: {
        _118 = <str as PartialEq>::eq(_24, const "node") -> [return: bb569, unwind: bb704];
    }

    bb288: {
        _0 = const '\u{f898}';
        goto -> bb702;
    }

    bb289: {
        _117 = <str as PartialEq>::eq(_24, const "npmignore") -> [return: bb568, unwind: bb704];
    }

    bb290: {
        _0 = const '\u{e71e}';
        goto -> bb702;
    }

    bb291: {
        _116 = <str as PartialEq>::eq(_24, const "odp") -> [return: bb567, unwind: bb704];
    }

    bb292: {
        _0 = const '\u{f1c4}';
        goto -> bb702;
    }

    bb293: {
        _115 = <str as PartialEq>::eq(_24, const "ods") -> [return: bb566, unwind: bb704];
    }

    bb294: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb295: {
        _114 = <str as PartialEq>::eq(_24, const "odt") -> [return: bb565, unwind: bb704];
    }

    bb296: {
        _0 = const '\u{f1c2}';
        goto -> bb702;
    }

    bb297: {
        _113 = <str as PartialEq>::eq(_24, const "ogg") -> [return: bb564, unwind: bb704];
    }

    bb298: {
        _0 = const '\u{f001}';
        goto -> bb702;
    }

    bb299: {
        _112 = <str as PartialEq>::eq(_24, const "ogv") -> [return: bb563, unwind: bb704];
    }

    bb300: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb301: {
        _111 = <str as PartialEq>::eq(_24, const "otf") -> [return: bb562, unwind: bb704];
    }

    bb302: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb303: {
        _110 = <str as PartialEq>::eq(_24, const "patch") -> [return: bb561, unwind: bb704];
    }

    bb304: {
        _0 = const '\u{f440}';
        goto -> bb702;
    }

    bb305: {
        _109 = <str as PartialEq>::eq(_24, const "pdf") -> [return: bb560, unwind: bb704];
    }

    bb306: {
        _0 = const '\u{f1c1}';
        goto -> bb702;
    }

    bb307: {
        _108 = <str as PartialEq>::eq(_24, const "php") -> [return: bb559, unwind: bb704];
    }

    bb308: {
        _0 = const '\u{e73d}';
        goto -> bb702;
    }

    bb309: {
        _107 = <str as PartialEq>::eq(_24, const "pl") -> [return: bb558, unwind: bb704];
    }

    bb310: {
        _0 = const '\u{e769}';
        goto -> bb702;
    }

    bb311: {
        _106 = <str as PartialEq>::eq(_24, const "png") -> [return: bb557, unwind: bb704];
    }

    bb312: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb313: {
        _105 = <str as PartialEq>::eq(_24, const "ppt") -> [return: bb556, unwind: bb704];
    }

    bb314: {
        _0 = const '\u{f1c4}';
        goto -> bb702;
    }

    bb315: {
        _104 = <str as PartialEq>::eq(_24, const "pptx") -> [return: bb555, unwind: bb704];
    }

    bb316: {
        _0 = const '\u{f1c4}';
        goto -> bb702;
    }

    bb317: {
        _103 = <str as PartialEq>::eq(_24, const "procfile") -> [return: bb554, unwind: bb704];
    }

    bb318: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb319: {
        _102 = <str as PartialEq>::eq(_24, const "properties") -> [return: bb553, unwind: bb704];
    }

    bb320: {
        _0 = const '\u{e60b}';
        goto -> bb702;
    }

    bb321: {
        _101 = <str as PartialEq>::eq(_24, const "ps1") -> [return: bb552, unwind: bb704];
    }

    bb322: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb323: {
        _100 = <str as PartialEq>::eq(_24, const "psd") -> [return: bb551, unwind: bb704];
    }

    bb324: {
        _0 = const '\u{e7b8}';
        goto -> bb702;
    }

    bb325: {
        _99 = <str as PartialEq>::eq(_24, const "pxm") -> [return: bb550, unwind: bb704];
    }

    bb326: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb327: {
        _98 = <str as PartialEq>::eq(_24, const "py") -> [return: bb549, unwind: bb704];
    }

    bb328: {
        _0 = const '\u{e606}';
        goto -> bb702;
    }

    bb329: {
        _97 = <str as PartialEq>::eq(_24, const "pyc") -> [return: bb548, unwind: bb704];
    }

    bb330: {
        _0 = const '\u{e606}';
        goto -> bb702;
    }

    bb331: {
        _96 = <str as PartialEq>::eq(_24, const "r") -> [return: bb547, unwind: bb704];
    }

    bb332: {
        _0 = const '\u{f25d}';
        goto -> bb702;
    }

    bb333: {
        _95 = <str as PartialEq>::eq(_24, const "rakefile") -> [return: bb546, unwind: bb704];
    }

    bb334: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb335: {
        _94 = <str as PartialEq>::eq(_24, const "rar") -> [return: bb545, unwind: bb704];
    }

    bb336: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb337: {
        _93 = <str as PartialEq>::eq(_24, const "razor") -> [return: bb544, unwind: bb704];
    }

    bb338: {
        _0 = const '\u{f1fa}';
        goto -> bb702;
    }

    bb339: {
        _92 = <str as PartialEq>::eq(_24, const "rb") -> [return: bb543, unwind: bb704];
    }

    bb340: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb341: {
        _91 = <str as PartialEq>::eq(_24, const "rdata") -> [return: bb542, unwind: bb704];
    }

    bb342: {
        _0 = const '\u{f25d}';
        goto -> bb702;
    }

    bb343: {
        _90 = <str as PartialEq>::eq(_24, const "rdb") -> [return: bb541, unwind: bb704];
    }

    bb344: {
        _0 = const '\u{e76d}';
        goto -> bb702;
    }

    bb345: {
        _89 = <str as PartialEq>::eq(_24, const "rdoc") -> [return: bb540, unwind: bb704];
    }

    bb346: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb347: {
        _88 = <str as PartialEq>::eq(_24, const "rds") -> [return: bb539, unwind: bb704];
    }

    bb348: {
        _0 = const '\u{f25d}';
        goto -> bb702;
    }

    bb349: {
        _87 = <str as PartialEq>::eq(_24, const "readme") -> [return: bb538, unwind: bb704];
    }

    bb350: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb351: {
        _86 = <str as PartialEq>::eq(_24, const "rlib") -> [return: bb537, unwind: bb704];
    }

    bb352: {
        _0 = const '\u{e7a8}';
        goto -> bb702;
    }

    bb353: {
        _85 = <str as PartialEq>::eq(_24, const "rmd") -> [return: bb536, unwind: bb704];
    }

    bb354: {
        _0 = const '\u{f48a}';
        goto -> bb702;
    }

    bb355: {
        _84 = <str as PartialEq>::eq(_24, const "rpm") -> [return: bb535, unwind: bb704];
    }

    bb356: {
        _0 = const '\u{e7bb}';
        goto -> bb702;
    }

    bb357: {
        _83 = <str as PartialEq>::eq(_24, const "rs") -> [return: bb534, unwind: bb704];
    }

    bb358: {
        _0 = const '\u{e7a8}';
        goto -> bb702;
    }

    bb359: {
        _82 = <str as PartialEq>::eq(_24, const "rspec") -> [return: bb533, unwind: bb704];
    }

    bb360: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb361: {
        _81 = <str as PartialEq>::eq(_24, const "rspec_parallel") -> [return: bb532, unwind: bb704];
    }

    bb362: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb363: {
        _80 = <str as PartialEq>::eq(_24, const "rspec_status") -> [return: bb531, unwind: bb704];
    }

    bb364: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb365: {
        _79 = <str as PartialEq>::eq(_24, const "rss") -> [return: bb530, unwind: bb704];
    }

    bb366: {
        _0 = const '\u{f09e}';
        goto -> bb702;
    }

    bb367: {
        _78 = <str as PartialEq>::eq(_24, const "rtf") -> [return: bb529, unwind: bb704];
    }

    bb368: {
        _0 = const '\u{f718}';
        goto -> bb702;
    }

    bb369: {
        _77 = <str as PartialEq>::eq(_24, const "ru") -> [return: bb528, unwind: bb704];
    }

    bb370: {
        _0 = const '\u{e21e}';
        goto -> bb702;
    }

    bb371: {
        _76 = <str as PartialEq>::eq(_24, const "rubydoc") -> [return: bb527, unwind: bb704];
    }

    bb372: {
        _0 = const '\u{e73b}';
        goto -> bb702;
    }

    bb373: {
        _75 = <str as PartialEq>::eq(_24, const "sass") -> [return: bb526, unwind: bb704];
    }

    bb374: {
        _0 = const '\u{e603}';
        goto -> bb702;
    }

    bb375: {
        _74 = <str as PartialEq>::eq(_24, const "scala") -> [return: bb525, unwind: bb704];
    }

    bb376: {
        _0 = const '\u{e737}';
        goto -> bb702;
    }

    bb377: {
        _73 = <str as PartialEq>::eq(_24, const "scss") -> [return: bb524, unwind: bb704];
    }

    bb378: {
        _0 = const '\u{e749}';
        goto -> bb702;
    }

    bb379: {
        _72 = <str as PartialEq>::eq(_24, const "sh") -> [return: bb523, unwind: bb704];
    }

    bb380: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb381: {
        _71 = <str as PartialEq>::eq(_24, const "shell") -> [return: bb522, unwind: bb704];
    }

    bb382: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb383: {
        _70 = <str as PartialEq>::eq(_24, const "slim") -> [return: bb521, unwind: bb704];
    }

    bb384: {
        _0 = const '\u{e73b}';
        goto -> bb702;
    }

    bb385: {
        _69 = <str as PartialEq>::eq(_24, const "sln") -> [return: bb520, unwind: bb704];
    }

    bb386: {
        _0 = const '\u{e70c}';
        goto -> bb702;
    }

    bb387: {
        _68 = <str as PartialEq>::eq(_24, const "so") -> [return: bb519, unwind: bb704];
    }

    bb388: {
        _0 = const '\u{f17c}';
        goto -> bb702;
    }

    bb389: {
        _67 = <str as PartialEq>::eq(_24, const "sql") -> [return: bb518, unwind: bb704];
    }

    bb390: {
        _0 = const '\u{f1c0}';
        goto -> bb702;
    }

    bb391: {
        _66 = <str as PartialEq>::eq(_24, const "sqlite3") -> [return: bb517, unwind: bb704];
    }

    bb392: {
        _0 = const '\u{e7c4}';
        goto -> bb702;
    }

    bb393: {
        _65 = <str as PartialEq>::eq(_24, const "styl") -> [return: bb516, unwind: bb704];
    }

    bb394: {
        _0 = const '\u{e600}';
        goto -> bb702;
    }

    bb395: {
        _64 = <str as PartialEq>::eq(_24, const "stylus") -> [return: bb515, unwind: bb704];
    }

    bb396: {
        _0 = const '\u{e600}';
        goto -> bb702;
    }

    bb397: {
        _63 = <str as PartialEq>::eq(_24, const "svg") -> [return: bb514, unwind: bb704];
    }

    bb398: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb399: {
        _62 = <str as PartialEq>::eq(_24, const "swift") -> [return: bb513, unwind: bb704];
    }

    bb400: {
        _0 = const '\u{e755}';
        goto -> bb702;
    }

    bb401: {
        _61 = <str as PartialEq>::eq(_24, const "tar") -> [return: bb512, unwind: bb704];
    }

    bb402: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb403: {
        _60 = <str as PartialEq>::eq(_24, const "taz") -> [return: bb511, unwind: bb704];
    }

    bb404: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb405: {
        _59 = <str as PartialEq>::eq(_24, const "tbz") -> [return: bb510, unwind: bb704];
    }

    bb406: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb407: {
        _58 = <str as PartialEq>::eq(_24, const "tbz2") -> [return: bb509, unwind: bb704];
    }

    bb408: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb409: {
        _57 = <str as PartialEq>::eq(_24, const "tex") -> [return: bb508, unwind: bb704];
    }

    bb410: {
        _0 = const '\u{f034}';
        goto -> bb702;
    }

    bb411: {
        _56 = <str as PartialEq>::eq(_24, const "tiff") -> [return: bb507, unwind: bb704];
    }

    bb412: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb413: {
        _55 = <str as PartialEq>::eq(_24, const "toml") -> [return: bb506, unwind: bb704];
    }

    bb414: {
        _0 = const '\u{e615}';
        goto -> bb702;
    }

    bb415: {
        _54 = <str as PartialEq>::eq(_24, const "ts") -> [return: bb505, unwind: bb704];
    }

    bb416: {
        _0 = const '\u{e628}';
        goto -> bb702;
    }

    bb417: {
        _53 = <str as PartialEq>::eq(_24, const "tsv") -> [return: bb504, unwind: bb704];
    }

    bb418: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb419: {
        _52 = <str as PartialEq>::eq(_24, const "tsx") -> [return: bb503, unwind: bb704];
    }

    bb420: {
        _0 = const '\u{e7ba}';
        goto -> bb702;
    }

    bb421: {
        _51 = <str as PartialEq>::eq(_24, const "ttf") -> [return: bb502, unwind: bb704];
    }

    bb422: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb423: {
        _50 = <str as PartialEq>::eq(_24, const "twig") -> [return: bb501, unwind: bb704];
    }

    bb424: {
        _0 = const '\u{e61c}';
        goto -> bb702;
    }

    bb425: {
        _49 = <str as PartialEq>::eq(_24, const "txt") -> [return: bb500, unwind: bb704];
    }

    bb426: {
        _0 = const '\u{f15c}';
        goto -> bb702;
    }

    bb427: {
        _48 = <str as PartialEq>::eq(_24, const "tz") -> [return: bb499, unwind: bb704];
    }

    bb428: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb429: {
        _47 = <str as PartialEq>::eq(_24, const "tzo") -> [return: bb498, unwind: bb704];
    }

    bb430: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb431: {
        _46 = <str as PartialEq>::eq(_24, const "video") -> [return: bb497, unwind: bb704];
    }

    bb432: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb433: {
        _45 = <str as PartialEq>::eq(_24, const "vim") -> [return: bb496, unwind: bb704];
    }

    bb434: {
        _0 = const '\u{e62b}';
        goto -> bb702;
    }

    bb435: {
        _44 = <str as PartialEq>::eq(_24, const "vue") -> [return: bb495, unwind: bb704];
    }

    bb436: {
        _0 = const '';
        goto -> bb702;
    }

    bb437: {
        _43 = <str as PartialEq>::eq(_24, const "war") -> [return: bb494, unwind: bb704];
    }

    bb438: {
        _0 = const '\u{e256}';
        goto -> bb702;
    }

    bb439: {
        _42 = <str as PartialEq>::eq(_24, const "wav") -> [return: bb493, unwind: bb704];
    }

    bb440: {
        _0 = const '\u{f001}';
        goto -> bb702;
    }

    bb441: {
        _41 = <str as PartialEq>::eq(_24, const "webm") -> [return: bb492, unwind: bb704];
    }

    bb442: {
        _0 = const '\u{f03d}';
        goto -> bb702;
    }

    bb443: {
        _40 = <str as PartialEq>::eq(_24, const "webp") -> [return: bb491, unwind: bb704];
    }

    bb444: {
        _0 = const '\u{f1c5}';
        goto -> bb702;
    }

    bb445: {
        _39 = <str as PartialEq>::eq(_24, const "windows") -> [return: bb490, unwind: bb704];
    }

    bb446: {
        _0 = const '\u{f17a}';
        goto -> bb702;
    }

    bb447: {
        _38 = <str as PartialEq>::eq(_24, const "woff") -> [return: bb489, unwind: bb704];
    }

    bb448: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb449: {
        _37 = <str as PartialEq>::eq(_24, const "woff2") -> [return: bb488, unwind: bb704];
    }

    bb450: {
        _0 = const '\u{f031}';
        goto -> bb702;
    }

    bb451: {
        _36 = <str as PartialEq>::eq(_24, const "xhtml") -> [return: bb487, unwind: bb704];
    }

    bb452: {
        _0 = const '\u{f13b}';
        goto -> bb702;
    }

    bb453: {
        _35 = <str as PartialEq>::eq(_24, const "xls") -> [return: bb486, unwind: bb704];
    }

    bb454: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb455: {
        _34 = <str as PartialEq>::eq(_24, const "xlsx") -> [return: bb485, unwind: bb704];
    }

    bb456: {
        _0 = const '\u{f1c3}';
        goto -> bb702;
    }

    bb457: {
        _33 = <str as PartialEq>::eq(_24, const "xml") -> [return: bb484, unwind: bb704];
    }

    bb458: {
        _0 = const '';
        goto -> bb702;
    }

    bb459: {
        _32 = <str as PartialEq>::eq(_24, const "xul") -> [return: bb483, unwind: bb704];
    }

    bb460: {
        _0 = const '';
        goto -> bb702;
    }

    bb461: {
        _31 = <str as PartialEq>::eq(_24, const "xz") -> [return: bb482, unwind: bb704];
    }

    bb462: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb463: {
        _30 = <str as PartialEq>::eq(_24, const "yaml") -> [return: bb481, unwind: bb704];
    }

    bb464: {
        _0 = const '\u{f481}';
        goto -> bb702;
    }

    bb465: {
        _29 = <str as PartialEq>::eq(_24, const "yml") -> [return: bb480, unwind: bb704];
    }

    bb466: {
        _0 = const '\u{f481}';
        goto -> bb702;
    }

    bb467: {
        _28 = <str as PartialEq>::eq(_24, const "zip") -> [return: bb479, unwind: bb704];
    }

    bb468: {
        _0 = const '\u{f410}';
        goto -> bb702;
    }

    bb469: {
        _27 = <str as PartialEq>::eq(_24, const "zsh") -> [return: bb478, unwind: bb704];
    }

    bb470: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb471: {
        _26 = <str as PartialEq>::eq(_24, const "zsh-theme") -> [return: bb477, unwind: bb704];
    }

    bb472: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb473: {
        _25 = <str as PartialEq>::eq(_24, const "zshrc") -> [return: bb476, unwind: bb704];
    }

    bb474: {
        _0 = const '\u{f489}';
        goto -> bb702;
    }

    bb475: {
        _0 = const '\u{f15b}';
        goto -> bb702;
    }

    bb476: {
        switchInt(move _25) -> [0: bb475, otherwise: bb474];
    }

    bb477: {
        switchInt(move _26) -> [0: bb473, otherwise: bb472];
    }

    bb478: {
        switchInt(move _27) -> [0: bb471, otherwise: bb470];
    }

    bb479: {
        switchInt(move _28) -> [0: bb469, otherwise: bb468];
    }

    bb480: {
        switchInt(move _29) -> [0: bb467, otherwise: bb466];
    }

    bb481: {
        switchInt(move _30) -> [0: bb465, otherwise: bb464];
    }

    bb482: {
        switchInt(move _31) -> [0: bb463, otherwise: bb462];
    }

    bb483: {
        switchInt(move _32) -> [0: bb461, otherwise: bb460];
    }

    bb484: {
        switchInt(move _33) -> [0: bb459, otherwise: bb458];
    }

    bb485: {
        switchInt(move _34) -> [0: bb457, otherwise: bb456];
    }

    bb486: {
        switchInt(move _35) -> [0: bb455, otherwise: bb454];
    }

    bb487: {
        switchInt(move _36) -> [0: bb453, otherwise: bb452];
    }

    bb488: {
        switchInt(move _37) -> [0: bb451, otherwise: bb450];
    }

    bb489: {
        switchInt(move _38) -> [0: bb449, otherwise: bb448];
    }

    bb490: {
        switchInt(move _39) -> [0: bb447, otherwise: bb446];
    }

    bb491: {
        switchInt(move _40) -> [0: bb445, otherwise: bb444];
    }

    bb492: {
        switchInt(move _41) -> [0: bb443, otherwise: bb442];
    }

    bb493: {
        switchInt(move _42) -> [0: bb441, otherwise: bb440];
    }

    bb494: {
        switchInt(move _43) -> [0: bb439, otherwise: bb438];
    }

    bb495: {
        switchInt(move _44) -> [0: bb437, otherwise: bb436];
    }

    bb496: {
        switchInt(move _45) -> [0: bb435, otherwise: bb434];
    }

    bb497: {
        switchInt(move _46) -> [0: bb433, otherwise: bb432];
    }

    bb498: {
        switchInt(move _47) -> [0: bb431, otherwise: bb430];
    }

    bb499: {
        switchInt(move _48) -> [0: bb429, otherwise: bb428];
    }

    bb500: {
        switchInt(move _49) -> [0: bb427, otherwise: bb426];
    }

    bb501: {
        switchInt(move _50) -> [0: bb425, otherwise: bb424];
    }

    bb502: {
        switchInt(move _51) -> [0: bb423, otherwise: bb422];
    }

    bb503: {
        switchInt(move _52) -> [0: bb421, otherwise: bb420];
    }

    bb504: {
        switchInt(move _53) -> [0: bb419, otherwise: bb418];
    }

    bb505: {
        switchInt(move _54) -> [0: bb417, otherwise: bb416];
    }

    bb506: {
        switchInt(move _55) -> [0: bb415, otherwise: bb414];
    }

    bb507: {
        switchInt(move _56) -> [0: bb413, otherwise: bb412];
    }

    bb508: {
        switchInt(move _57) -> [0: bb411, otherwise: bb410];
    }

    bb509: {
        switchInt(move _58) -> [0: bb409, otherwise: bb408];
    }

    bb510: {
        switchInt(move _59) -> [0: bb407, otherwise: bb406];
    }

    bb511: {
        switchInt(move _60) -> [0: bb405, otherwise: bb404];
    }

    bb512: {
        switchInt(move _61) -> [0: bb403, otherwise: bb402];
    }

    bb513: {
        switchInt(move _62) -> [0: bb401, otherwise: bb400];
    }

    bb514: {
        switchInt(move _63) -> [0: bb399, otherwise: bb398];
    }

    bb515: {
        switchInt(move _64) -> [0: bb397, otherwise: bb396];
    }

    bb516: {
        switchInt(move _65) -> [0: bb395, otherwise: bb394];
    }

    bb517: {
        switchInt(move _66) -> [0: bb393, otherwise: bb392];
    }

    bb518: {
        switchInt(move _67) -> [0: bb391, otherwise: bb390];
    }

    bb519: {
        switchInt(move _68) -> [0: bb389, otherwise: bb388];
    }

    bb520: {
        switchInt(move _69) -> [0: bb387, otherwise: bb386];
    }

    bb521: {
        switchInt(move _70) -> [0: bb385, otherwise: bb384];
    }

    bb522: {
        switchInt(move _71) -> [0: bb383, otherwise: bb382];
    }

    bb523: {
        switchInt(move _72) -> [0: bb381, otherwise: bb380];
    }

    bb524: {
        switchInt(move _73) -> [0: bb379, otherwise: bb378];
    }

    bb525: {
        switchInt(move _74) -> [0: bb377, otherwise: bb376];
    }

    bb526: {
        switchInt(move _75) -> [0: bb375, otherwise: bb374];
    }

    bb527: {
        switchInt(move _76) -> [0: bb373, otherwise: bb372];
    }

    bb528: {
        switchInt(move _77) -> [0: bb371, otherwise: bb370];
    }

    bb529: {
        switchInt(move _78) -> [0: bb369, otherwise: bb368];
    }

    bb530: {
        switchInt(move _79) -> [0: bb367, otherwise: bb366];
    }

    bb531: {
        switchInt(move _80) -> [0: bb365, otherwise: bb364];
    }

    bb532: {
        switchInt(move _81) -> [0: bb363, otherwise: bb362];
    }

    bb533: {
        switchInt(move _82) -> [0: bb361, otherwise: bb360];
    }

    bb534: {
        switchInt(move _83) -> [0: bb359, otherwise: bb358];
    }

    bb535: {
        switchInt(move _84) -> [0: bb357, otherwise: bb356];
    }

    bb536: {
        switchInt(move _85) -> [0: bb355, otherwise: bb354];
    }

    bb537: {
        switchInt(move _86) -> [0: bb353, otherwise: bb352];
    }

    bb538: {
        switchInt(move _87) -> [0: bb351, otherwise: bb350];
    }

    bb539: {
        switchInt(move _88) -> [0: bb349, otherwise: bb348];
    }

    bb540: {
        switchInt(move _89) -> [0: bb347, otherwise: bb346];
    }

    bb541: {
        switchInt(move _90) -> [0: bb345, otherwise: bb344];
    }

    bb542: {
        switchInt(move _91) -> [0: bb343, otherwise: bb342];
    }

    bb543: {
        switchInt(move _92) -> [0: bb341, otherwise: bb340];
    }

    bb544: {
        switchInt(move _93) -> [0: bb339, otherwise: bb338];
    }

    bb545: {
        switchInt(move _94) -> [0: bb337, otherwise: bb336];
    }

    bb546: {
        switchInt(move _95) -> [0: bb335, otherwise: bb334];
    }

    bb547: {
        switchInt(move _96) -> [0: bb333, otherwise: bb332];
    }

    bb548: {
        switchInt(move _97) -> [0: bb331, otherwise: bb330];
    }

    bb549: {
        switchInt(move _98) -> [0: bb329, otherwise: bb328];
    }

    bb550: {
        switchInt(move _99) -> [0: bb327, otherwise: bb326];
    }

    bb551: {
        switchInt(move _100) -> [0: bb325, otherwise: bb324];
    }

    bb552: {
        switchInt(move _101) -> [0: bb323, otherwise: bb322];
    }

    bb553: {
        switchInt(move _102) -> [0: bb321, otherwise: bb320];
    }

    bb554: {
        switchInt(move _103) -> [0: bb319, otherwise: bb318];
    }

    bb555: {
        switchInt(move _104) -> [0: bb317, otherwise: bb316];
    }

    bb556: {
        switchInt(move _105) -> [0: bb315, otherwise: bb314];
    }

    bb557: {
        switchInt(move _106) -> [0: bb313, otherwise: bb312];
    }

    bb558: {
        switchInt(move _107) -> [0: bb311, otherwise: bb310];
    }

    bb559: {
        switchInt(move _108) -> [0: bb309, otherwise: bb308];
    }

    bb560: {
        switchInt(move _109) -> [0: bb307, otherwise: bb306];
    }

    bb561: {
        switchInt(move _110) -> [0: bb305, otherwise: bb304];
    }

    bb562: {
        switchInt(move _111) -> [0: bb303, otherwise: bb302];
    }

    bb563: {
        switchInt(move _112) -> [0: bb301, otherwise: bb300];
    }

    bb564: {
        switchInt(move _113) -> [0: bb299, otherwise: bb298];
    }

    bb565: {
        switchInt(move _114) -> [0: bb297, otherwise: bb296];
    }

    bb566: {
        switchInt(move _115) -> [0: bb295, otherwise: bb294];
    }

    bb567: {
        switchInt(move _116) -> [0: bb293, otherwise: bb292];
    }

    bb568: {
        switchInt(move _117) -> [0: bb291, otherwise: bb290];
    }

    bb569: {
        switchInt(move _118) -> [0: bb289, otherwise: bb288];
    }

    bb570: {
        switchInt(move _119) -> [0: bb287, otherwise: bb286];
    }

    bb571: {
        switchInt(move _120) -> [0: bb285, otherwise: bb284];
    }

    bb572: {
        switchInt(move _121) -> [0: bb283, otherwise: bb282];
    }

    bb573: {
        switchInt(move _122) -> [0: bb281, otherwise: bb280];
    }

    bb574: {
        switchInt(move _123) -> [0: bb279, otherwise: bb278];
    }

    bb575: {
        switchInt(move _124) -> [0: bb277, otherwise: bb276];
    }

    bb576: {
        switchInt(move _125) -> [0: bb275, otherwise: bb274];
    }

    bb577: {
        switchInt(move _126) -> [0: bb273, otherwise: bb272];
    }

    bb578: {
        switchInt(move _127) -> [0: bb271, otherwise: bb270];
    }

    bb579: {
        switchInt(move _128) -> [0: bb269, otherwise: bb268];
    }

    bb580: {
        switchInt(move _129) -> [0: bb267, otherwise: bb266];
    }

    bb581: {
        switchInt(move _130) -> [0: bb265, otherwise: bb264];
    }

    bb582: {
        switchInt(move _131) -> [0: bb263, otherwise: bb262];
    }

    bb583: {
        switchInt(move _132) -> [0: bb261, otherwise: bb260];
    }

    bb584: {
        switchInt(move _133) -> [0: bb259, otherwise: bb258];
    }

    bb585: {
        switchInt(move _134) -> [0: bb257, otherwise: bb256];
    }

    bb586: {
        switchInt(move _135) -> [0: bb255, otherwise: bb254];
    }

    bb587: {
        switchInt(move _136) -> [0: bb253, otherwise: bb252];
    }

    bb588: {
        switchInt(move _137) -> [0: bb251, otherwise: bb250];
    }

    bb589: {
        switchInt(move _138) -> [0: bb249, otherwise: bb248];
    }

    bb590: {
        switchInt(move _139) -> [0: bb247, otherwise: bb246];
    }

    bb591: {
        switchInt(move _140) -> [0: bb245, otherwise: bb244];
    }

    bb592: {
        switchInt(move _141) -> [0: bb243, otherwise: bb242];
    }

    bb593: {
        switchInt(move _142) -> [0: bb241, otherwise: bb240];
    }

    bb594: {
        switchInt(move _143) -> [0: bb239, otherwise: bb238];
    }

    bb595: {
        switchInt(move _144) -> [0: bb237, otherwise: bb236];
    }

    bb596: {
        switchInt(move _145) -> [0: bb235, otherwise: bb234];
    }

    bb597: {
        switchInt(move _146) -> [0: bb233, otherwise: bb232];
    }

    bb598: {
        switchInt(move _147) -> [0: bb231, otherwise: bb230];
    }

    bb599: {
        switchInt(move _148) -> [0: bb229, otherwise: bb228];
    }

    bb600: {
        switchInt(move _149) -> [0: bb227, otherwise: bb226];
    }

    bb601: {
        switchInt(move _150) -> [0: bb225, otherwise: bb224];
    }

    bb602: {
        switchInt(move _151) -> [0: bb223, otherwise: bb222];
    }

    bb603: {
        switchInt(move _152) -> [0: bb221, otherwise: bb220];
    }

    bb604: {
        switchInt(move _153) -> [0: bb219, otherwise: bb218];
    }

    bb605: {
        switchInt(move _154) -> [0: bb217, otherwise: bb216];
    }

    bb606: {
        switchInt(move _155) -> [0: bb215, otherwise: bb214];
    }

    bb607: {
        switchInt(move _156) -> [0: bb213, otherwise: bb212];
    }

    bb608: {
        switchInt(move _157) -> [0: bb211, otherwise: bb210];
    }

    bb609: {
        switchInt(move _158) -> [0: bb209, otherwise: bb208];
    }

    bb610: {
        switchInt(move _159) -> [0: bb207, otherwise: bb206];
    }

    bb611: {
        switchInt(move _160) -> [0: bb205, otherwise: bb204];
    }

    bb612: {
        switchInt(move _161) -> [0: bb203, otherwise: bb202];
    }

    bb613: {
        switchInt(move _162) -> [0: bb201, otherwise: bb200];
    }

    bb614: {
        switchInt(move _163) -> [0: bb199, otherwise: bb198];
    }

    bb615: {
        switchInt(move _164) -> [0: bb197, otherwise: bb196];
    }

    bb616: {
        switchInt(move _165) -> [0: bb195, otherwise: bb194];
    }

    bb617: {
        switchInt(move _166) -> [0: bb193, otherwise: bb192];
    }

    bb618: {
        switchInt(move _167) -> [0: bb191, otherwise: bb190];
    }

    bb619: {
        switchInt(move _168) -> [0: bb189, otherwise: bb188];
    }

    bb620: {
        switchInt(move _169) -> [0: bb187, otherwise: bb186];
    }

    bb621: {
        switchInt(move _170) -> [0: bb185, otherwise: bb184];
    }

    bb622: {
        switchInt(move _171) -> [0: bb183, otherwise: bb182];
    }

    bb623: {
        switchInt(move _172) -> [0: bb181, otherwise: bb180];
    }

    bb624: {
        switchInt(move _173) -> [0: bb179, otherwise: bb178];
    }

    bb625: {
        switchInt(move _174) -> [0: bb177, otherwise: bb176];
    }

    bb626: {
        switchInt(move _175) -> [0: bb175, otherwise: bb174];
    }

    bb627: {
        switchInt(move _176) -> [0: bb173, otherwise: bb172];
    }

    bb628: {
        switchInt(move _177) -> [0: bb171, otherwise: bb170];
    }

    bb629: {
        switchInt(move _178) -> [0: bb169, otherwise: bb168];
    }

    bb630: {
        switchInt(move _179) -> [0: bb167, otherwise: bb166];
    }

    bb631: {
        switchInt(move _180) -> [0: bb165, otherwise: bb164];
    }

    bb632: {
        switchInt(move _181) -> [0: bb163, otherwise: bb162];
    }

    bb633: {
        switchInt(move _182) -> [0: bb161, otherwise: bb160];
    }

    bb634: {
        switchInt(move _183) -> [0: bb159, otherwise: bb158];
    }

    bb635: {
        switchInt(move _184) -> [0: bb157, otherwise: bb156];
    }

    bb636: {
        switchInt(move _185) -> [0: bb155, otherwise: bb154];
    }

    bb637: {
        switchInt(move _186) -> [0: bb153, otherwise: bb152];
    }

    bb638: {
        switchInt(move _187) -> [0: bb151, otherwise: bb150];
    }

    bb639: {
        switchInt(move _188) -> [0: bb149, otherwise: bb148];
    }

    bb640: {
        switchInt(move _189) -> [0: bb147, otherwise: bb146];
    }

    bb641: {
        switchInt(move _190) -> [0: bb145, otherwise: bb144];
    }

    bb642: {
        switchInt(move _191) -> [0: bb143, otherwise: bb142];
    }

    bb643: {
        switchInt(move _192) -> [0: bb141, otherwise: bb140];
    }

    bb644: {
        switchInt(move _193) -> [0: bb139, otherwise: bb138];
    }

    bb645: {
        switchInt(move _194) -> [0: bb137, otherwise: bb136];
    }

    bb646: {
        switchInt(move _195) -> [0: bb135, otherwise: bb134];
    }

    bb647: {
        switchInt(move _196) -> [0: bb133, otherwise: bb132];
    }

    bb648: {
        switchInt(move _197) -> [0: bb131, otherwise: bb130];
    }

    bb649: {
        switchInt(move _198) -> [0: bb129, otherwise: bb128];
    }

    bb650: {
        switchInt(move _199) -> [0: bb127, otherwise: bb126];
    }

    bb651: {
        switchInt(move _200) -> [0: bb125, otherwise: bb124];
    }

    bb652: {
        switchInt(move _201) -> [0: bb123, otherwise: bb122];
    }

    bb653: {
        switchInt(move _202) -> [0: bb121, otherwise: bb120];
    }

    bb654: {
        switchInt(move _203) -> [0: bb119, otherwise: bb118];
    }

    bb655: {
        switchInt(move _204) -> [0: bb117, otherwise: bb116];
    }

    bb656: {
        switchInt(move _205) -> [0: bb115, otherwise: bb114];
    }

    bb657: {
        switchInt(move _206) -> [0: bb113, otherwise: bb112];
    }

    bb658: {
        switchInt(move _207) -> [0: bb111, otherwise: bb110];
    }

    bb659: {
        switchInt(move _208) -> [0: bb109, otherwise: bb108];
    }

    bb660: {
        switchInt(move _209) -> [0: bb107, otherwise: bb106];
    }

    bb661: {
        switchInt(move _210) -> [0: bb105, otherwise: bb104];
    }

    bb662: {
        switchInt(move _211) -> [0: bb103, otherwise: bb102];
    }

    bb663: {
        switchInt(move _212) -> [0: bb101, otherwise: bb100];
    }

    bb664: {
        switchInt(move _213) -> [0: bb99, otherwise: bb98];
    }

    bb665: {
        switchInt(move _214) -> [0: bb97, otherwise: bb96];
    }

    bb666: {
        switchInt(move _215) -> [0: bb95, otherwise: bb94];
    }

    bb667: {
        switchInt(move _216) -> [0: bb93, otherwise: bb92];
    }

    bb668: {
        switchInt(move _217) -> [0: bb91, otherwise: bb90];
    }

    bb669: {
        switchInt(move _218) -> [0: bb89, otherwise: bb88];
    }

    bb670: {
        switchInt(move _219) -> [0: bb87, otherwise: bb86];
    }

    bb671: {
        switchInt(move _220) -> [0: bb85, otherwise: bb84];
    }

    bb672: {
        switchInt(move _221) -> [0: bb83, otherwise: bb82];
    }

    bb673: {
        switchInt(move _222) -> [0: bb81, otherwise: bb80];
    }

    bb674: {
        switchInt(move _223) -> [0: bb79, otherwise: bb78];
    }

    bb675: {
        switchInt(move _224) -> [0: bb77, otherwise: bb76];
    }

    bb676: {
        switchInt(move _225) -> [0: bb75, otherwise: bb74];
    }

    bb677: {
        switchInt(move _226) -> [0: bb73, otherwise: bb72];
    }

    bb678: {
        switchInt(move _227) -> [0: bb71, otherwise: bb70];
    }

    bb679: {
        switchInt(move _228) -> [0: bb69, otherwise: bb68];
    }

    bb680: {
        switchInt(move _229) -> [0: bb67, otherwise: bb66];
    }

    bb681: {
        switchInt(move _230) -> [0: bb65, otherwise: bb64];
    }

    bb682: {
        switchInt(move _231) -> [0: bb63, otherwise: bb62];
    }

    bb683: {
        switchInt(move _232) -> [0: bb61, otherwise: bb60];
    }

    bb684: {
        switchInt(move _233) -> [0: bb59, otherwise: bb58];
    }

    bb685: {
        switchInt(move _234) -> [0: bb57, otherwise: bb56];
    }

    bb686: {
        switchInt(move _235) -> [0: bb55, otherwise: bb54];
    }

    bb687: {
        switchInt(move _236) -> [0: bb53, otherwise: bb52];
    }

    bb688: {
        switchInt(move _237) -> [0: bb51, otherwise: bb50];
    }

    bb689: {
        switchInt(move _238) -> [0: bb49, otherwise: bb48];
    }

    bb690: {
        switchInt(move _239) -> [0: bb47, otherwise: bb46];
    }

    bb691: {
        switchInt(move _240) -> [0: bb45, otherwise: bb44];
    }

    bb692: {
        switchInt(move _241) -> [0: bb43, otherwise: bb42];
    }

    bb693: {
        switchInt(move _242) -> [0: bb41, otherwise: bb40];
    }

    bb694: {
        switchInt(move _243) -> [0: bb39, otherwise: bb38];
    }

    bb695: {
        switchInt(move _244) -> [0: bb37, otherwise: bb36];
    }

    bb696: {
        switchInt(move _245) -> [0: bb35, otherwise: bb34];
    }

    bb697: {
        switchInt(move _246) -> [0: bb33, otherwise: bb32];
    }

    bb698: {
        switchInt(move _247) -> [0: bb31, otherwise: bb30];
    }

    bb699: {
        switchInt(move _248) -> [0: bb29, otherwise: bb28];
    }

    bb700: {
        switchInt(move _249) -> [0: bb27, otherwise: bb26];
    }

    bb701: {
        _0 = const '\u{f016}';
        goto -> bb702;
    }

    bb702: {
        drop(_2) -> [return: bb703, unwind continue];
    }

    bb703: {
        return;
    }

    bb704 (cleanup): {
        drop(_2) -> [return: bb705, unwind terminate(cleanup)];
    }

    bb705 (cleanup): {
        resume;
    }
}

alloc67 (static: MAP_BY_NAME, size: 0, align: 1) {}

fn lines::<impl at src/output/lines.rs:20:1: 20:20>::render(_1: lines::Render<'_>, _2: &mut W) -> Result<(), std::io::Error> {
    debug self => _1;
    debug w => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: ();
    let mut _4: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _5: std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _6: &std::vec::Vec<fs::file::File<'_>>;
    let mut _7: std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _8: std::option::Option<&fs::file::File<'_>>;
    let mut _9: &mut std::slice::Iter<'_, fs::file::File<'_>>;
    let mut _10: isize;
    let mut _13: &output::lines::Render<'_>;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _15: std::result::Result<(), std::io::Error>;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &ansi_term::ANSIGenericStrings<'_, str>;
    let _23: ansi_term::ANSIGenericStrings<'_, str>;
    let _24: &[ansi_term::ANSIGenericString<'_, str>];
    let _25: &output::cell::TextCellContents;
    let mut _26: isize;
    let mut _29: &fs::filter::FileFilter;
    scope 1 {
        debug iter => _7;
        let _11: &fs::file::File<'_>;
        scope 2 {
            debug file => _11;
            let _12: output::cell::TextCellContents;
            scope 3 {
                debug name_cell => _12;
                let _27: std::result::Result<std::convert::Infallible, std::io::Error>;
                let mut _28: &[&str; 2];
                scope 4 {
                    debug residual => _27;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => const ();
                    scope 7 {
                    }
                }
            }
        }
    }

    bb0: {
        _29 = deref_copy (_1.3: &fs::filter::FileFilter);
        _4 = &mut (_1.0: std::vec::Vec<fs::file::File<'_>>);
        _3 = FileFilter::sort_files::<'_, file::File<'_>>(_29, _4) -> [return: bb1, unwind: bb21];
    }

    bb1: {
        _6 = &(_1.0: std::vec::Vec<fs::file::File<'_>>);
        _5 = <&Vec<file::File<'_>> as IntoIterator>::into_iter(move _6) -> [return: bb2, unwind: bb21];
    }

    bb2: {
        _7 = move _5;
        goto -> bb3;
    }

    bb3: {
        _9 = &mut _7;
        _8 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::next(_9) -> [return: bb4, unwind: bb21];
    }

    bb4: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _11 = ((_8 as Some).0: &fs::file::File<'_>);
        _13 = &_1;
        _12 = lines::Render::<'_>::render_file(move _13, _11) -> [return: bb8, unwind: bb21];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = Result::<(), std::io::Error>::Ok(const ());
        drop(_1) -> [return: bb19, unwind continue];
    }

    bb8: {
        _28 = const _;
        _17 = _28 as &[&str] (PointerCoercion(Unsize));
        _25 = &_12;
        _24 = <TextCellContents as Deref>::deref(_25) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _23 = ANSIStrings(_24) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericStrings<'_, str>>(_22) -> [return: bb11, unwind: bb20];
    }

    bb11: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = std::fmt::Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        _15 = <W as std::io::Write>::write_fmt(_2, move _16) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _14 = <Result<(), std::io::Error> as Try>::branch(move _15) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _26 = discriminant(_14);
        switchInt(move _26) -> [0: bb15, 1: bb16, otherwise: bb6];
    }

    bb15: {
        drop(_12) -> [return: bb3, unwind: bb21];
    }

    bb16: {
        _27 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _27) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        drop(_12) -> [return: bb18, unwind: bb21];
    }

    bb18: {
        drop(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_12) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_1) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }
}

promoted[0] in lines::<impl at src/output/lines.rs:20:1: 20:20>::render: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn lines::<impl at src/output/lines.rs:20:1: 20:20>::render_file(_1: &lines::Render<'_>, _2: &file::File<'_>) -> TextCellContents {
    debug self => _1;
    debug file => _2;
    let mut _0: output::cell::TextCellContents;
    let mut _3: &output::file_name::FileName<'_, '_, theme::Theme>;
    let _4: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _5: output::file_name::FileName<'_, '_, theme::Theme>;
    let mut _6: output::file_name::Options;
    let mut _7: &output::file_name::Options;
    let mut _8: &theme::Theme;

    bb0: {
        _7 = deref_copy ((*_1).2: &output::file_name::Options);
        _6 = (*_7);
        _8 = deref_copy ((*_1).1: &theme::Theme);
        _5 = output::file_name::Options::for_file::<Theme>(move _6, _2, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = FileName::<'_, '_, Theme>::with_link_paths(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &_4;
        _0 = FileName::<'_, '_, Theme>::paint(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn blocks::<impl at src/output/render/blocks.rs:7:1: 7:15>::render(_1: &Blocks, _2: &C) -> TextCell {
    debug self => _1;
    debug colours => _2;
    let mut _0: output::cell::TextCell;
    let mut _3: isize;
    let _4: &u64;
    let mut _5: ansi_term::Style;
    let mut _6: std::string::String;
    let mut _7: ansi_term::Style;
    scope 1 {
        debug blk => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = <C as blocks::Colours>::no_blocks(_2) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Some).0: u64);
        _5 = <C as blocks::Colours>::block_count(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = <u64 as ToString>::to_string(_4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = TextCell::paint(move _5, move _6) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = TextCell::blank(move _7) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn render::filetype::<impl at src/output/render/filetype.rs:6:1: 6:13>::render(_1: Type, _2: &C) -> ANSIGenericString<'_, str> {
    debug self => _1;
    debug colours => _2;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _3: isize;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb5, 1: bb3, 2: bb9, 3: bb7, 4: bb15, 5: bb13, 6: bb11, 7: bb1, otherwise: bb2];
    }

    bb1: {
        _11 = <C as render::filetype::Colours>::special(_2) -> [return: bb17, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = <C as render::filetype::Colours>::normal(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _4, const ".") -> [return: bb18, unwind continue];
    }

    bb5: {
        _5 = <C as render::filetype::Colours>::directory(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _5, const "d") -> [return: bb18, unwind continue];
    }

    bb7: {
        _6 = <C as render::filetype::Colours>::pipe(_2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _6, const "|") -> [return: bb18, unwind continue];
    }

    bb9: {
        _7 = <C as render::filetype::Colours>::symlink(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _7, const "l") -> [return: bb18, unwind continue];
    }

    bb11: {
        _8 = <C as render::filetype::Colours>::block_device(_2) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _8, const "b") -> [return: bb18, unwind continue];
    }

    bb13: {
        _9 = <C as render::filetype::Colours>::char_device(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "c") -> [return: bb18, unwind continue];
    }

    bb15: {
        _10 = <C as render::filetype::Colours>::socket(_2) -> [return: bb16, unwind continue];
    }

    bb16: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _10, const "s") -> [return: bb18, unwind continue];
    }

    bb17: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _11, const "?") -> [return: bb18, unwind continue];
    }

    bb18: {
        return;
    }
}

fn render::git::<impl at src/output/render/git.rs:7:1: 7:12>::render(_1: fields::Git, _2: &dyn render::git::Colours) -> TextCell {
    debug self => _1;
    debug colours => _2;
    let mut _0: output::cell::TextCell;
    let mut _3: output::cell::DisplayWidth;
    let mut _4: output::cell::TextCellContents;
    let mut _5: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _6: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _7: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: *mut u8;
    let mut _11: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _12: ansi_term::ANSIGenericString<'_, str>;
    let mut _13: fs::fields::GitStatus;
    let mut _14: ansi_term::ANSIGenericString<'_, str>;
    let mut _15: fs::fields::GitStatus;
    let mut _16: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _17: ();
    let mut _18: *const [ansi_term::ANSIGenericString<'_, str>; 2];
    let mut _19: *const ();
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    scope 1 {
    }

    bb0: {
        _3 = <DisplayWidth as From<usize>>::from(const 2_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _9 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _10 = alloc::alloc::exchange_malloc(move _8, move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = ShallowInitBox(move _10, [ansi_term::ANSIGenericString<'_, str>; 2]);
        _13 = (_1.0: fs::fields::GitStatus);
        _12 = render::git::<impl GitStatus>::render(move _13, _2) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _15 = (_1.1: fs::fields::GitStatus);
        _14 = render::git::<impl GitStatus>::render(move _15, _2) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _18 = (((_11.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 2]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 2]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 2]);
        _19 = _18 as *const () (PtrToPtr);
        _20 = _19 as usize (Transmute);
        _21 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _22 = Sub(_21, const 1_usize);
        _23 = BitAnd(_20, _22);
        _24 = Eq(_23, const 0_usize);
        assert(_24, "misaligned pointer dereference: address must be a multiple of {} but is {}", _21, _20) -> [success: bb10, unwind unreachable];
    }

    bb5: {
        _4 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = TextCell { contents: move _4, width: move _3 };
        return;
    }

    bb7 (cleanup): {
        drop(_12) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9 (cleanup): {
        _16 = &mut _11;
        _17 = <Box<[ANSIGenericString<'_, str>; 2]> as Drop>::drop(move _16) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb10: {
        (*_18) = [move _12, move _14];
        _7 = move _11;
        _6 = move _7 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _5 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _6) -> [return: bb5, unwind continue];
    }
}

fn render::git::<impl at src/output/render/git.rs:20:1: 20:18>::render(_1: GitStatus, _2: &dyn render::git::Colours) -> ANSIGenericString<'_, str> {
    debug self => _1;
    debug colours => _2;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _3: isize;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb3, 1: bb5, 2: bb7, 3: bb9, 4: bb11, 5: bb13, 6: bb15, 7: bb1, otherwise: bb2];
    }

    bb1: {
        _11 = <dyn render::git::Colours as render::git::Colours>::conflicted(_2) -> [return: bb17, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = <dyn render::git::Colours as render::git::Colours>::not_modified(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _4, const "-") -> [return: bb18, unwind continue];
    }

    bb5: {
        _5 = <dyn render::git::Colours as render::git::Colours>::new(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _5, const "N") -> [return: bb18, unwind continue];
    }

    bb7: {
        _6 = <dyn render::git::Colours as render::git::Colours>::modified(_2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _6, const "M") -> [return: bb18, unwind continue];
    }

    bb9: {
        _7 = <dyn render::git::Colours as render::git::Colours>::deleted(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _7, const "D") -> [return: bb18, unwind continue];
    }

    bb11: {
        _8 = <dyn render::git::Colours as render::git::Colours>::renamed(_2) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _8, const "R") -> [return: bb18, unwind continue];
    }

    bb13: {
        _9 = <dyn render::git::Colours as render::git::Colours>::type_change(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "T") -> [return: bb18, unwind continue];
    }

    bb15: {
        _10 = <dyn render::git::Colours as render::git::Colours>::ignored(_2) -> [return: bb16, unwind continue];
    }

    bb16: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _10, const "I") -> [return: bb18, unwind continue];
    }

    bb17: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _11, const "U") -> [return: bb18, unwind continue];
    }

    bb18: {
        return;
    }
}

fn groups::<impl at src/output/render/groups.rs:9:1: 9:14>::render(_1: fields::Group, _2: &C, _3: &U, _4: UserFormat) -> TextCell {
    debug self => _1;
    debug colours => _2;
    debug users => _3;
    debug format => _4;
    let mut _0: output::cell::TextCell;
    let mut _5: ansi_term::Style;
    let mut _7: std::option::Option<std::sync::Arc<users::Group>>;
    let mut _8: u32;
    let mut _9: isize;
    let _11: &users::Group;
    let mut _12: &std::sync::Arc<users::Group>;
    let mut _13: ansi_term::Style;
    let mut _14: std::string::String;
    let mut _15: &u32;
    let mut _17: std::option::Option<std::sync::Arc<users::User>>;
    let mut _18: isize;
    let mut _20: bool;
    let mut _21: u32;
    let _22: &users::User;
    let mut _23: &std::sync::Arc<users::User>;
    let mut _24: u32;
    let mut _25: &users::Group;
    let mut _26: bool;
    let mut _27: &mut std::slice::Iter<'_, std::ffi::OsString>;
    let mut _28: std::slice::Iter<'_, std::ffi::OsString>;
    let _29: &[std::ffi::OsString];
    let mut _30: &users::Group;
    let mut _31: {closure@src/output/render/groups.rs:24:43: 24:46};
    let mut _32: &std::sync::Arc<users::User>;
    let mut _33: ansi_term::Style;
    let mut _35: isize;
    let mut _36: std::borrow::Cow<'_, str>;
    let _37: &std::ffi::OsStr;
    let mut _38: &users::Group;
    let mut _39: &u32;
    let _40: u32;
    let mut _41: &users::Group;
    let mut _42: ansi_term::Style;
    let mut _43: std::string::String;
    let mut _44: bool;
    let mut _45: isize;
    scope 1 {
        debug style => _5;
        let _6: users::Group;
        let _10: std::sync::Arc<users::Group>;
        scope 2 {
            debug group => _6;
            let _16: u32;
            scope 4 {
                debug current_uid => _16;
                let _34: std::string::String;
                scope 5 {
                    debug current_user => _19;
                    let _19: std::sync::Arc<users::User>;
                }
                scope 6 {
                    debug group_name => _34;
                }
            }
        }
        scope 3 {
            debug g => _10;
        }
    }

    bb0: {
        _44 = const false;
        _5 = <C as groups::Colours>::not_yours(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = (_1.0: u32);
        _7 = <U as Groups>::get_group_by_gid(_3, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _13 = _5;
        _15 = &(_1.0: u32);
        _14 = <u32 as ToString>::to_string(move _15) -> [return: bb9, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = move ((_7 as Some).0: std::sync::Arc<users::Group>);
        _12 = &_10;
        _11 = <Arc<users::Group> as Deref>::deref(move _12) -> [return: bb6, unwind: bb33];
    }

    bb6: {
        _6 = <users::Group as Clone>::clone(_11) -> [return: bb7, unwind: bb33];
    }

    bb7: {
        drop(_10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _16 = <U as users::Users>::get_current_uid(_3) -> [return: bb10, unwind: bb32];
    }

    bb9: {
        _0 = TextCell::paint(move _13, move _14) -> [return: bb30, unwind continue];
    }

    bb10: {
        _17 = <U as users::Users>::get_user_by_uid(_3, _16) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _44 = const true;
        _18 = discriminant(_17);
        switchInt(move _18) -> [1: bb12, otherwise: bb38];
    }

    bb12: {
        _44 = const false;
        _19 = move ((_17 as Some).0: std::sync::Arc<users::User>);
        _23 = &_19;
        _22 = <Arc<users::User> as Deref>::deref(move _23) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _21 = users::User::primary_group_id(_22) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _25 = &_6;
        _24 = users::Group::gid(move _25) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _20 = Eq(move _21, move _24);
        switchInt(move _20) -> [0: bb16, otherwise: bb20];
    }

    bb16: {
        _30 = &_6;
        _29 = <users::Group as GroupExt>::members(move _30) -> [return: bb17, unwind: bb31];
    }

    bb17: {
        _28 = core::slice::<impl [OsString]>::iter(_29) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        _27 = &mut _28;
        _32 = &_19;
        _31 = {closure@src/output/render/groups.rs:24:43: 24:46} { current_user: move _32 };
        _26 = <std::slice::Iter<'_, OsString> as Iterator>::any::<{closure@src/output/render/groups.rs:24:43: 24:46}>(move _27, move _31) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        switchInt(move _26) -> [0: bb22, otherwise: bb20];
    }

    bb20: {
        _33 = <C as groups::Colours>::yours(_2) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        _5 = move _33;
        goto -> bb22;
    }

    bb22: {
        drop(_19) -> [return: bb38, unwind: bb32];
    }

    bb23: {
        _41 = &_6;
        _40 = users::Group::gid(move _41) -> [return: bb27, unwind: bb32];
    }

    bb24: {
        _38 = &_6;
        _37 = users::Group::name(move _38) -> [return: bb25, unwind: bb32];
    }

    bb25: {
        _36 = OsStr::to_string_lossy(_37) -> [return: bb26, unwind: bb32];
    }

    bb26: {
        _34 = <Cow<'_, str> as Into<String>>::into(move _36) -> [return: bb39, unwind: bb32];
    }

    bb27: {
        _39 = &_40;
        _34 = <u32 as ToString>::to_string(move _39) -> [return: bb40, unwind: bb32];
    }

    bb28: {
        _42 = _5;
        _43 = move _34;
        _0 = TextCell::paint(move _42, move _43) -> [return: bb29, unwind: bb32];
    }

    bb29: {
        drop(_6) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_19) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_6) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_10) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        resume;
    }

    bb35: {
        _44 = const false;
        _35 = discriminant(_4);
        switchInt(move _35) -> [0: bb23, 1: bb24, otherwise: bb4];
    }

    bb36: {
        switchInt(_44) -> [0: bb35, otherwise: bb37];
    }

    bb37: {
        drop(((_17 as Some).0: std::sync::Arc<users::User>)) -> [return: bb35, unwind: bb32];
    }

    bb38: {
        _45 = discriminant(_17);
        switchInt(move _45) -> [1: bb36, otherwise: bb35];
    }

    bb39: {
        goto -> bb28;
    }

    bb40: {
        goto -> bb28;
    }
}

fn groups::<impl at src/output/render/groups.rs:9:1: 9:14>::render::{closure#0}(_1: &mut {closure@src/output/render/groups.rs:24:43: 24:46}, _2: &OsString) -> bool {
    debug u => _2;
    debug current_user => (*((*_1).0: &std::sync::Arc<users::User>));
    let mut _0: bool;
    let mut _3: &&std::ffi::OsString;
    let mut _4: &&std::ffi::OsStr;
    let _5: &std::ffi::OsStr;
    let _6: &users::User;
    let mut _7: &std::sync::Arc<users::User>;

    bb0: {
        _3 = &_2;
        _7 = deref_copy ((*_1).0: &std::sync::Arc<users::User>);
        _6 = <Arc<users::User> as Deref>::deref(_7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = users::User::name(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = &_5;
        _0 = <&OsString as PartialEq<&OsStr>>::eq(move _3, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn inode::<impl at src/output/render/inode.rs:7:1: 7:14>::render(_1: Inode, _2: Style) -> TextCell {
    debug self => _1;
    debug style => _2;
    let mut _0: output::cell::TextCell;
    let mut _3: std::string::String;
    let mut _4: &u64;

    bb0: {
        _4 = &(_1.0: u64);
        _3 = <u64 as ToString>::to_string(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = TextCell::paint(_2, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn links::<impl at src/output/render/links.rs:8:1: 8:14>::render(_1: &fields::Links, _2: &C, _3: &Numeric) -> TextCell {
    debug self => _1;
    debug colours => _2;
    debug numeric => _3;
    let mut _0: output::cell::TextCell;
    let _4: ansi_term::Style;
    let mut _5: bool;
    let mut _6: ansi_term::Style;
    let mut _7: std::string::String;
    let mut _8: u64;
    scope 1 {
        debug style => _4;
    }

    bb0: {
        _5 = ((*_1).1: bool);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = <C as links::Colours>::multi_link_file(_2) -> [return: bb3, unwind continue];
    }

    bb2: {
        _4 = <C as links::Colours>::normal(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = _4;
        _8 = ((*_1).0: u64);
        _7 = Numeric::format_int::<u64>(_3, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = TextCell::paint(move _6, move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn permissions::<impl at src/output/render/permissions.rs:8:1: 8:24>::render(_1: &PermissionsPlus, _2: &C) -> TextCell {
    debug self => _1;
    debug colours => _2;
    let mut _0: output::cell::TextCell;
    let mut _3: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _4: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _5: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _10: ansi_term::ANSIGenericString<'_, str>;
    let mut _11: fs::fields::Type;
    let _12: ();
    let mut _13: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _14: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _15: &fs::fields::Permissions;
    let mut _16: bool;
    let mut _17: fs::fields::Type;
    let mut _18: bool;
    let _19: ();
    let mut _20: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _21: ansi_term::ANSIGenericString<'_, str>;
    let mut _22: ansi_term::Style;
    let mut _23: output::cell::DisplayWidth;
    let mut _24: usize;
    let mut _25: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _26: output::cell::TextCellContents;
    let mut _27: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _28: bool;
    let mut _29: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _30: ();
    let mut _31: *const [ansi_term::ANSIGenericString<'_, str>; 1];
    let mut _32: *const ();
    let mut _33: usize;
    let mut _34: usize;
    let mut _35: usize;
    let mut _36: usize;
    let mut _37: bool;
    scope 1 {
        debug chars => _3;
    }
    scope 2 {
    }

    bb0: {
        _28 = const false;
        _6 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _7 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [ansi_term::ANSIGenericString<'_, str>; 1]);
        _11 = ((*_1).0: fs::fields::Type);
        _10 = render::filetype::<impl Type>::render::<C>(move _11, _2) -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _31 = (((_9.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 1]);
        _32 = _31 as *const () (PtrToPtr);
        _33 = _32 as usize (Transmute);
        _34 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _35 = Sub(_34, const 1_usize);
        _36 = BitAnd(_33, _35);
        _37 = Eq(_36, const 0_usize);
        assert(_37, "misaligned pointer dereference: address must be a multiple of {} but is {}", _34, _33) -> [success: bb18, unwind unreachable];
    }

    bb3: {
        _28 = const true;
        _13 = &mut _3;
        _15 = &((*_1).1: fs::fields::Permissions);
        _17 = ((*_1).0: fs::fields::Type);
        _16 = Type::is_regular_file(move _17) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _14 = permissions::<impl fields::Permissions>::render::<C>(move _15, _2, move _16) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _12 = <Vec<ANSIGenericString<'_, str>> as Extend<ANSIGenericString<'_, str>>>::extend::<Vec<ANSIGenericString<'_, str>>>(move _13, move _14) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _18 = ((*_1).2: bool);
        switchInt(move _18) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _20 = &mut _3;
        _22 = <C as permissions::Colours>::attribute(_2) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _21 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _22, const "@") -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _19 = Vec::<ANSIGenericString<'_, str>>::push(move _20, move _21) -> [return: bb19, unwind: bb16];
    }

    bb10: {
        _25 = &_3;
        _24 = Vec::<ANSIGenericString<'_, str>>::len(move _25) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        _23 = <DisplayWidth as From<usize>>::from(move _24) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        _28 = const false;
        _27 = move _3;
        _26 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _27) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        _0 = TextCell { contents: move _26, width: move _23 };
        _28 = const false;
        return;
    }

    bb14 (cleanup): {
        resume;
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        switchInt(_28) -> [0: bb14, otherwise: bb15];
    }

    bb17 (cleanup): {
        _29 = &mut _9;
        _30 = <Box<[ANSIGenericString<'_, str>; 1]> as Drop>::drop(move _29) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb18: {
        (*_31) = [move _10];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _3 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb3, unwind continue];
    }

    bb19: {
        goto -> bb10;
    }

    bb20 (cleanup): {
        goto -> bb14;
    }
}

fn permissions::<impl at src/output/render/permissions.rs:28:1: 28:20>::render(_1: &fields::Permissions, _2: &C, _3: bool) -> Vec<ANSIGenericString<'_, str>> {
    debug self => _1;
    debug colours => _2;
    debug is_regular_file => _3;
    let mut _0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let _4: {closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _5: &&C;
    let mut _6: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _7: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 9]>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: *mut u8;
    let mut _11: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 9]>;
    let mut _12: ansi_term::ANSIGenericString<'_, str>;
    let mut _13: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _14: (bool, &str, ansi_term::Style);
    let mut _15: bool;
    let mut _16: ansi_term::Style;
    let mut _17: &C;
    let mut _18: ansi_term::ANSIGenericString<'_, str>;
    let mut _19: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _20: (bool, &str, ansi_term::Style);
    let mut _21: bool;
    let mut _22: ansi_term::Style;
    let mut _23: &C;
    let mut _24: ansi_term::ANSIGenericString<'_, str>;
    let mut _25: &C;
    let mut _26: ansi_term::ANSIGenericString<'_, str>;
    let mut _27: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _28: (bool, &str, ansi_term::Style);
    let mut _29: bool;
    let mut _30: ansi_term::Style;
    let mut _31: &C;
    let mut _32: ansi_term::ANSIGenericString<'_, str>;
    let mut _33: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _34: (bool, &str, ansi_term::Style);
    let mut _35: bool;
    let mut _36: ansi_term::Style;
    let mut _37: &C;
    let mut _38: ansi_term::ANSIGenericString<'_, str>;
    let mut _39: &C;
    let mut _40: ansi_term::ANSIGenericString<'_, str>;
    let mut _41: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _42: (bool, &str, ansi_term::Style);
    let mut _43: bool;
    let mut _44: ansi_term::Style;
    let mut _45: &C;
    let mut _46: ansi_term::ANSIGenericString<'_, str>;
    let mut _47: &{closure@src/output/render/permissions.rs:31:19: 31:57};
    let mut _48: (bool, &str, ansi_term::Style);
    let mut _49: bool;
    let mut _50: ansi_term::Style;
    let mut _51: &C;
    let mut _52: ansi_term::ANSIGenericString<'_, str>;
    let mut _53: &C;
    let mut _54: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 9]>;
    let mut _55: ();
    let mut _56: *const [ansi_term::ANSIGenericString<'_, str>; 9];
    scope 1 {
        debug bit => _4;
        let mut _57: *const ();
        let mut _58: usize;
        let mut _59: usize;
        let mut _60: usize;
        let mut _61: usize;
        let mut _62: bool;
        scope 2 {
        }
    }

    bb0: {
        _5 = &_2;
        _4 = {closure@src/output/render/permissions.rs:31:19: 31:57} { colours: move _5 };
        _8 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 9]);
        _9 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 9]);
        _10 = alloc::alloc::exchange_malloc(move _8, move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = ShallowInitBox(move _10, [ansi_term::ANSIGenericString<'_, str>; 9]);
        _13 = &_4;
        _15 = ((*_1).0: bool);
        _17 = _2;
        _16 = <C as permissions::Colours>::user_read(move _17) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        _14 = (move _15, const "r", move _16);
        _12 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _13, move _14) -> [return: bb3, unwind: bb27];
    }

    bb3: {
        _19 = &_4;
        _21 = ((*_1).1: bool);
        _23 = _2;
        _22 = <C as permissions::Colours>::user_write(move _23) -> [return: bb4, unwind: bb25];
    }

    bb4: {
        _20 = (move _21, const "w", move _22);
        _18 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _19, move _20) -> [return: bb5, unwind: bb25];
    }

    bb5: {
        _25 = _2;
        _24 = permissions::<impl fields::Permissions>::user_execute_bit::<C>(_1, move _25, _3) -> [return: bb6, unwind: bb24];
    }

    bb6: {
        _27 = &_4;
        _29 = ((*_1).3: bool);
        _31 = _2;
        _30 = <C as permissions::Colours>::group_read(move _31) -> [return: bb7, unwind: bb23];
    }

    bb7: {
        _28 = (move _29, const "r", move _30);
        _26 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _27, move _28) -> [return: bb8, unwind: bb23];
    }

    bb8: {
        _33 = &_4;
        _35 = ((*_1).4: bool);
        _37 = _2;
        _36 = <C as permissions::Colours>::group_write(move _37) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _34 = (move _35, const "w", move _36);
        _32 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _33, move _34) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        _39 = _2;
        _38 = permissions::<impl fields::Permissions>::group_execute_bit::<C>(_1, move _39) -> [return: bb11, unwind: bb21];
    }

    bb11: {
        _41 = &_4;
        _43 = ((*_1).6: bool);
        _45 = _2;
        _44 = <C as permissions::Colours>::other_read(move _45) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        _42 = (move _43, const "r", move _44);
        _40 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _41, move _42) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _47 = &_4;
        _49 = ((*_1).7: bool);
        _51 = _2;
        _50 = <C as permissions::Colours>::other_write(move _51) -> [return: bb14, unwind: bb19];
    }

    bb14: {
        _48 = (move _49, const "w", move _50);
        _46 = <{closure@src/output/render/permissions.rs:31:19: 31:57} as Fn<(bool, &str, Style)>>::call(move _47, move _48) -> [return: bb15, unwind: bb19];
    }

    bb15: {
        _53 = _2;
        _52 = permissions::<impl fields::Permissions>::other_execute_bit::<C>(_1, move _53) -> [return: bb16, unwind: bb18];
    }

    bb16: {
        _56 = (((_11.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 9]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 9]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 9]);
        _57 = _56 as *const () (PtrToPtr);
        _58 = _57 as usize (Transmute);
        _59 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 9]);
        _60 = Sub(_59, const 1_usize);
        _61 = BitAnd(_58, _60);
        _62 = Eq(_61, const 0_usize);
        assert(_62, "misaligned pointer dereference: address must be a multiple of {} but is {}", _59, _58) -> [success: bb28, unwind unreachable];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_46) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_40) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop(_38) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_32) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_26) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_24) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_18) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_12) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        _54 = &mut _11;
        _55 = <Box<[ANSIGenericString<'_, str>; 9]> as Drop>::drop(move _54) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb28: {
        (*_56) = [move _12, move _18, move _24, move _26, move _32, move _38, move _40, move _46, move _52];
        _7 = move _11;
        _6 = move _7 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _0 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _6) -> [return: bb17, unwind continue];
    }
}

fn permissions::<impl at src/output/render/permissions.rs:28:1: 28:20>::render::{closure#0}(_1: &{closure@src/output/render/permissions.rs:31:19: 31:57}, _2: bool, _3: &str, _4: Style) -> ANSIGenericString<'_, str> {
    debug bit => _2;
    debug chr => _3;
    debug style => _4;
    debug colours => (*((*_1).0: &&C));
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _5: ansi_term::Style;
    let mut _6: &&C;
    let mut _7: &C;

    bb0: {
        switchInt(_2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(_4, _3) -> [return: bb4, unwind continue];
    }

    bb2: {
        _6 = deref_copy ((*_1).0: &&C);
        _7 = deref_copy (*_6);
        _5 = <C as permissions::Colours>::dash(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _5, const "-") -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn permissions::<impl at src/output/render/permissions.rs:28:1: 28:20>::user_execute_bit(_1: &fields::Permissions, _2: &C, _3: bool) -> ANSIGenericString<'_, str> {
    debug self => _1;
    debug colours => _2;
    debug is_regular_file => _3;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _4: (bool, bool, bool);
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Style;

    bb0: {
        _5 = ((*_1).2: bool);
        _6 = ((*_1).11: bool);
        _4 = (move _5, move _6, _3);
        switchInt((_4.0: bool)) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        switchInt((_4.1: bool)) -> [0: bb6, otherwise: bb12];
    }

    bb2: {
        switchInt((_4.1: bool)) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        switchInt((_4.2: bool)) -> [0: bb8, otherwise: bb10];
    }

    bb4: {
        switchInt((_4.2: bool)) -> [0: bb14, otherwise: bb5];
    }

    bb5: {
        _12 = <C as permissions::Colours>::special_user_file(_2) -> [return: bb16, unwind continue];
    }

    bb6: {
        _7 = <C as permissions::Colours>::dash(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _7, const "-") -> [return: bb17, unwind continue];
    }

    bb8: {
        _8 = <C as permissions::Colours>::user_execute_other(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _8, const "x") -> [return: bb17, unwind continue];
    }

    bb10: {
        _9 = <C as permissions::Colours>::user_execute_file(_2) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "x") -> [return: bb17, unwind continue];
    }

    bb12: {
        _10 = <C as permissions::Colours>::special_other(_2) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _10, const "S") -> [return: bb17, unwind continue];
    }

    bb14: {
        _11 = <C as permissions::Colours>::special_other(_2) -> [return: bb15, unwind continue];
    }

    bb15: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _11, const "s") -> [return: bb17, unwind continue];
    }

    bb16: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _12, const "s") -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }
}

fn permissions::<impl at src/output/render/permissions.rs:28:1: 28:20>::group_execute_bit(_1: &fields::Permissions, _2: &C) -> ANSIGenericString<'_, str> {
    debug self => _1;
    debug colours => _2;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _3: (bool, bool);
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;

    bb0: {
        _4 = ((*_1).5: bool);
        _5 = ((*_1).10: bool);
        _3 = (move _4, move _5);
        switchInt((_3.0: bool)) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        switchInt((_3.1: bool)) -> [0: bb4, otherwise: bb8];
    }

    bb2: {
        switchInt((_3.1: bool)) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _9 = <C as permissions::Colours>::special_other(_2) -> [return: bb10, unwind continue];
    }

    bb4: {
        _6 = <C as permissions::Colours>::dash(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _6, const "-") -> [return: bb11, unwind continue];
    }

    bb6: {
        _7 = <C as permissions::Colours>::group_execute(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _7, const "x") -> [return: bb11, unwind continue];
    }

    bb8: {
        _8 = <C as permissions::Colours>::special_other(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _8, const "S") -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "s") -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn permissions::<impl at src/output/render/permissions.rs:28:1: 28:20>::other_execute_bit(_1: &fields::Permissions, _2: &C) -> ANSIGenericString<'_, str> {
    debug self => _1;
    debug colours => _2;
    let mut _0: ansi_term::ANSIGenericString<'_, str>;
    let mut _3: (bool, bool);
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;

    bb0: {
        _4 = ((*_1).8: bool);
        _5 = ((*_1).9: bool);
        _3 = (move _4, move _5);
        switchInt((_3.0: bool)) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        switchInt((_3.1: bool)) -> [0: bb4, otherwise: bb8];
    }

    bb2: {
        switchInt((_3.1: bool)) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _9 = <C as permissions::Colours>::special_other(_2) -> [return: bb10, unwind continue];
    }

    bb4: {
        _6 = <C as permissions::Colours>::dash(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _6, const "-") -> [return: bb11, unwind continue];
    }

    bb6: {
        _7 = <C as permissions::Colours>::other_execute(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _7, const "x") -> [return: bb11, unwind continue];
    }

    bb8: {
        _8 = <C as permissions::Colours>::special_other(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _8, const "T") -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _9, const "t") -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn size::<impl at src/output/render/size.rs:10:1: 10:13>::render(_1: fields::Size, _2: &C, _3: SizeFormat, _4: &Numeric) -> TextCell {
    debug self => _1;
    debug colours => _2;
    debug size_format => _3;
    debug numerics => _4;
    let mut _0: output::cell::TextCell;
    let mut _5: isize;
    let _6: u64;
    let mut _7: ansi_term::Style;
    let _8: &fs::fields::DeviceIDs;
    let mut _9: fs::fields::DeviceIDs;
    let mut _11: isize;
    let mut _12: f64;
    let mut _13: f64;
    let mut _15: number_prefix::NumberPrefix<f64>;
    let mut _16: f64;
    let mut _17: isize;
    let mut _20: ansi_term::Style;
    let mut _21: std::option::Option<number_prefix::Prefix>;
    let mut _22: std::string::String;
    let mut _25: (number_prefix::Prefix, f64);
    let mut _26: isize;
    let mut _28: ansi_term::Style;
    let mut _29: std::option::Option<number_prefix::Prefix>;
    let mut _30: std::string::String;
    let mut _35: bool;
    let mut _36: isize;
    let mut _37: f64;
    let mut _38: output::cell::DisplayWidth;
    let mut _39: output::cell::DisplayWidth;
    let _40: &str;
    let mut _41: &std::string::String;
    let mut _42: usize;
    let mut _43: output::cell::TextCellContents;
    let mut _44: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _45: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _46: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _47: usize;
    let mut _48: usize;
    let mut _49: *mut u8;
    let mut _50: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _51: ansi_term::ANSIGenericString<'_, str>;
    let mut _52: ansi_term::Style;
    let mut _53: std::option::Option<number_prefix::Prefix>;
    let mut _54: std::string::String;
    let mut _55: ansi_term::ANSIGenericString<'_, str>;
    let mut _56: ansi_term::Style;
    let mut _57: std::option::Option<number_prefix::Prefix>;
    let mut _58: bool;
    let mut _59: bool;
    let mut _60: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 2]>;
    let mut _61: ();
    let mut _62: *const [ansi_term::ANSIGenericString<'_, str>; 2];
    scope 1 {
        debug size => _6;
        let _10: number_prefix::NumberPrefix<f64>;
        let _14: std::option::Option<number_prefix::Prefix>;
        let _18: number_prefix::Prefix;
        scope 4 {
            debug result => _10;
            let _23: number_prefix::Prefix;
            let _24: f64;
            let _27: f64;
            let _31: number_prefix::Prefix;
            let _32: f64;
            scope 8 {
                debug prefix => _23;
                debug n => _24;
                let _33: &str;
                scope 11 {
                    debug symbol => _33;
                    let _34: std::string::String;
                    scope 12 {
                        debug number => _34;
                        let mut _63: *const ();
                        let mut _64: usize;
                        let mut _65: usize;
                        let mut _66: usize;
                        let mut _67: usize;
                        let mut _68: bool;
                        scope 13 {
                        }
                    }
                }
            }
            scope 9 {
                debug b => _27;
            }
            scope 10 {
                debug p => _31;
                debug n => _32;
            }
        }
        scope 5 {
            debug prefix => _14;
            let _19: std::string::String;
            scope 7 {
                debug string => _19;
            }
        }
        scope 6 {
            debug p => _18;
        }
    }
    scope 2 {
        debug s => _6;
    }
    scope 3 {
        debug ids => _8;
    }

    bb0: {
        _59 = const false;
        _58 = const false;
        _5 = discriminant(_1);
        switchInt(move _5) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &((_1 as DeviceIDs).0: fs::fields::DeviceIDs);
        _9 = (*_8);
        _0 = size::<impl DeviceIDs>::render::<C>(move _9, _2) -> [return: bb37, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _6 = ((_1 as Some).0: u64);
        _11 = discriminant(_3);
        switchInt(move _11) -> [0: bb7, 1: bb8, 2: bb6, otherwise: bb2];
    }

    bb4: {
        _7 = <C as size::Colours>::no_size(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = TextCell::blank(move _7) -> [return: bb37, unwind continue];
    }

    bb6: {
        _16 = _6 as f64 (IntToFloat);
        _15 = NumberPrefix::<f64>::binary(move _16) -> [return: bb9, unwind continue];
    }

    bb7: {
        _12 = _6 as f64 (IntToFloat);
        _10 = NumberPrefix::<f64>::decimal(move _12) -> [return: bb16, unwind continue];
    }

    bb8: {
        _13 = _6 as f64 (IntToFloat);
        _10 = NumberPrefix::<f64>::binary(move _13) -> [return: bb16, unwind continue];
    }

    bb9: {
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb11, 1: bb10, otherwise: bb2];
    }

    bb10: {
        _18 = ((_15 as Prefixed).0: number_prefix::Prefix);
        _14 = Option::<number_prefix::Prefix>::Some(_18);
        goto -> bb12;
    }

    bb11: {
        _14 = Option::<number_prefix::Prefix>::None;
        goto -> bb12;
    }

    bb12: {
        _59 = const true;
        _19 = Numeric::format_int::<u64>(_4, _6) -> [return: bb13, unwind continue];
    }

    bb13: {
        _21 = _14;
        _20 = <C as size::Colours>::size(_2, move _21) -> [return: bb14, unwind: bb44];
    }

    bb14: {
        _59 = const false;
        _22 = move _19;
        _0 = TextCell::paint(move _20, move _22) -> [return: bb15, unwind: bb44];
    }

    bb15: {
        _59 = const false;
        goto -> bb37;
    }

    bb16: {
        _26 = discriminant(_10);
        switchInt(move _26) -> [0: bb18, 1: bb17, otherwise: bb2];
    }

    bb17: {
        _31 = ((_10 as Prefixed).0: number_prefix::Prefix);
        _32 = ((_10 as Prefixed).1: f64);
        _25 = (_31, _32);
        _23 = (_25.0: number_prefix::Prefix);
        _24 = (_25.1: f64);
        _33 = number_prefix::Prefix::symbol(_23) -> [return: bb21, unwind continue];
    }

    bb18: {
        _27 = ((_10 as Standalone).0: f64);
        _29 = Option::<number_prefix::Prefix>::None;
        _28 = <C as size::Colours>::size(_2, move _29) -> [return: bb19, unwind continue];
    }

    bb19: {
        _30 = Numeric::format_int::<f64>(_4, _27) -> [return: bb20, unwind continue];
    }

    bb20: {
        _0 = TextCell::paint(move _28, move _30) -> [return: bb37, unwind continue];
    }

    bb21: {
        _35 = Lt(_24, const 10f64);
        switchInt(move _35) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _58 = const true;
        _34 = Numeric::format_float::<f64>(_4, _24, const 1_usize) -> [return: bb25, unwind continue];
    }

    bb23: {
        _37 = f64::<impl f64>::round(_24) -> [return: bb24, unwind continue];
    }

    bb24: {
        _36 = move _37 as isize (FloatToInt);
        _58 = const true;
        _34 = Numeric::format_int::<isize>(_4, move _36) -> [return: bb25, unwind continue];
    }

    bb25: {
        _41 = &_34;
        _40 = <String as Deref>::deref(move _41) -> [return: bb26, unwind: bb42];
    }

    bb26: {
        _39 = <DisplayWidth as From<&str>>::from(_40) -> [return: bb27, unwind: bb42];
    }

    bb27: {
        _42 = core::str::<impl str>::len(_33) -> [return: bb28, unwind: bb42];
    }

    bb28: {
        _38 = <DisplayWidth as Add<usize>>::add(move _39, move _42) -> [return: bb29, unwind: bb42];
    }

    bb29: {
        _47 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _48 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _49 = alloc::alloc::exchange_malloc(move _47, move _48) -> [return: bb30, unwind: bb42];
    }

    bb30: {
        _50 = ShallowInitBox(move _49, [ansi_term::ANSIGenericString<'_, str>; 2]);
        _53 = Option::<number_prefix::Prefix>::Some(_23);
        _52 = <C as size::Colours>::size(_2, move _53) -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _58 = const false;
        _54 = move _34;
        _51 = ansi_term::display::<impl Style>::paint::<'_, String, str>(move _52, move _54) -> [return: bb32, unwind: bb40];
    }

    bb32: {
        _57 = Option::<number_prefix::Prefix>::Some(_23);
        _56 = <C as size::Colours>::unit(_2, move _57) -> [return: bb33, unwind: bb38];
    }

    bb33: {
        _55 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _56, _33) -> [return: bb34, unwind: bb38];
    }

    bb34: {
        _62 = (((_50.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 2]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 2]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 2]);
        _63 = _62 as *const () (PtrToPtr);
        _64 = _63 as usize (Transmute);
        _65 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 2]);
        _66 = Sub(_65, const 1_usize);
        _67 = BitAnd(_64, _66);
        _68 = Eq(_67, const 0_usize);
        assert(_68, "misaligned pointer dereference: address must be a multiple of {} but is {}", _65, _64) -> [success: bb45, unwind unreachable];
    }

    bb35: {
        _43 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _44) -> [return: bb36, unwind: bb42];
    }

    bb36: {
        _0 = TextCell { contents: move _43, width: move _38 };
        _58 = const false;
        goto -> bb37;
    }

    bb37: {
        return;
    }

    bb38 (cleanup): {
        drop(_51) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        resume;
    }

    bb40 (cleanup): {
        _60 = &mut _50;
        _61 = <Box<[ANSIGenericString<'_, str>; 2]> as Drop>::drop(move _60) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_34) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        switchInt(_58) -> [0: bb39, otherwise: bb41];
    }

    bb43 (cleanup): {
        drop(_19) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        switchInt(_59) -> [0: bb39, otherwise: bb43];
    }

    bb45: {
        (*_62) = [move _51, move _55];
        _46 = move _50;
        _45 = move _46 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _44 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _45) -> [return: bb35, unwind: bb42];
    }

    bb46 (cleanup): {
        goto -> bb42;
    }
}

fn size::<impl at src/output/render/size.rs:62:1: 62:18>::render(_1: DeviceIDs, _2: &C) -> TextCell {
    debug self => _1;
    debug colours => _2;
    let mut _0: output::cell::TextCell;
    let _3: std::string::String;
    let mut _4: &u8;
    let mut _6: &u8;
    let mut _7: output::cell::DisplayWidth;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &std::string::String;
    let mut _12: (usize, bool);
    let mut _13: usize;
    let mut _14: &std::string::String;
    let mut _15: (usize, bool);
    let mut _16: output::cell::TextCellContents;
    let mut _17: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _18: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _19: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 3]>;
    let mut _20: usize;
    let mut _21: usize;
    let mut _22: *mut u8;
    let mut _23: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 3]>;
    let mut _24: ansi_term::ANSIGenericString<'_, str>;
    let mut _25: ansi_term::Style;
    let mut _26: std::string::String;
    let mut _27: ansi_term::ANSIGenericString<'_, str>;
    let mut _28: ansi_term::Style;
    let mut _29: ansi_term::ANSIGenericString<'_, str>;
    let mut _30: ansi_term::Style;
    let mut _31: std::string::String;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 3]>;
    let mut _35: ();
    let mut _36: *const [ansi_term::ANSIGenericString<'_, str>; 3];
    scope 1 {
        debug major => _3;
        let _5: std::string::String;
        scope 2 {
            debug minor => _5;
            let mut _37: *const ();
            let mut _38: usize;
            let mut _39: usize;
            let mut _40: usize;
            let mut _41: usize;
            let mut _42: bool;
            scope 3 {
            }
        }
    }

    bb0: {
        _33 = const false;
        _32 = const false;
        _4 = &(_1.0: u8);
        _33 = const true;
        _3 = <u8 as ToString>::to_string(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &(_1.1: u8);
        _5 = <u8 as ToString>::to_string(move _6) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _32 = const true;
        _11 = &_3;
        _10 = String::len(move _11) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _12 = CheckedAdd(_10, const 1_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _10, const 1_usize) -> [success: bb4, unwind: bb22];
    }

    bb4: {
        _9 = move (_12.0: usize);
        _14 = &_5;
        _13 = String::len(move _14) -> [return: bb5, unwind: bb22];
    }

    bb5: {
        _15 = CheckedAdd(_9, _13);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", move _9, move _13) -> [success: bb6, unwind: bb22];
    }

    bb6: {
        _8 = move (_15.0: usize);
        _7 = <DisplayWidth as From<usize>>::from(move _8) -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _20 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 3]);
        _21 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 3]);
        _22 = alloc::alloc::exchange_malloc(move _20, move _21) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _23 = ShallowInitBox(move _22, [ansi_term::ANSIGenericString<'_, str>; 3]);
        _25 = <C as size::Colours>::major(_2) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _33 = const false;
        _26 = move _3;
        _24 = ansi_term::display::<impl Style>::paint::<'_, String, str>(move _25, move _26) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _28 = <C as size::Colours>::comma(_2) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _27 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(move _28, const ",") -> [return: bb12, unwind: bb18];
    }

    bb12: {
        _30 = <C as size::Colours>::minor(_2) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _32 = const false;
        _31 = move _5;
        _29 = ansi_term::display::<impl Style>::paint::<'_, String, str>(move _30, move _31) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        _36 = (((_23.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 3]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 3]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 3]);
        _37 = _36 as *const () (PtrToPtr);
        _38 = _37 as usize (Transmute);
        _39 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 3]);
        _40 = Sub(_39, const 1_usize);
        _41 = BitAnd(_38, _40);
        _42 = Eq(_41, const 0_usize);
        assert(_42, "misaligned pointer dereference: address must be a multiple of {} but is {}", _39, _38) -> [success: bb25, unwind unreachable];
    }

    bb15: {
        _16 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _17) -> [return: bb16, unwind: bb22];
    }

    bb16: {
        _0 = TextCell { contents: move _16, width: move _7 };
        _32 = const false;
        _33 = const false;
        return;
    }

    bb17 (cleanup): {
        drop(_27) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_24) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20 (cleanup): {
        _34 = &mut _23;
        _35 = <Box<[ANSIGenericString<'_, str>; 3]> as Drop>::drop(move _34) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_5) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        switchInt(_32) -> [0: bb24, otherwise: bb21];
    }

    bb23 (cleanup): {
        drop(_3) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_33) -> [0: bb19, otherwise: bb23];
    }

    bb25: {
        (*_36) = [move _24, move _27, move _29];
        _19 = move _23;
        _18 = move _19 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _17 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _18) -> [return: bb15, unwind: bb22];
    }

    bb26 (cleanup): {
        goto -> bb22;
    }
}

fn times::<impl at src/output/render/times.rs:14:1: 14:35>::render(_1: Option<SystemTime>, _2: Style, _3: &Option<TimeZone>, _4: TimeFormat) -> TextCell {
    debug self => _1;
    debug style => _2;
    debug tz => _3;
    debug format => _4;
    let mut _0: output::cell::TextCell;
    let _5: std::string::String;
    let mut _6: isize;
    let mut _8: isize;
    let mut _10: std::string::String;
    scope 1 {
        debug datestamp => _5;
    }
    scope 2 {
        debug time => _7;
        let _7: std::time::SystemTime;
        scope 3 {
            debug tz => _9;
            let _9: &datetime::TimeZone;
        }
    }

    bb0: {
        _6 = discriminant(_1);
        switchInt(move _6) -> [1: bb1, otherwise: bb4];
    }

    bb1: {
        _7 = ((_1 as Some).0: std::time::SystemTime);
        _8 = discriminant((*_3));
        switchInt(move _8) -> [1: bb2, otherwise: bb3];
    }

    bb2: {
        _9 = &(((*_3) as Some).0: datetime::TimeZone);
        _5 = TimeFormat::format_zoned(_4, _7, _9) -> [return: bb5, unwind continue];
    }

    bb3: {
        _5 = TimeFormat::format_local(_4, _7) -> [return: bb5, unwind continue];
    }

    bb4: {
        _5 = <String as From<&str>>::from(const "-") -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = move _5;
        _0 = TextCell::paint(_2, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn users::<impl at src/output/render/users.rs:9:1: 9:13>::render(_1: fields::User, _2: &C, _3: &U, _4: UserFormat) -> TextCell {
    debug self => _1;
    debug colours => _2;
    debug users => _3;
    debug format => _4;
    let mut _0: output::cell::TextCell;
    let _5: std::string::String;
    let mut _6: (output::table::UserFormat, std::option::Option<std::sync::Arc<users::User>>);
    let mut _7: std::option::Option<std::sync::Arc<users::User>>;
    let mut _8: u32;
    let mut _9: isize;
    let mut _10: isize;
    let mut _11: isize;
    let mut _12: &u32;
    let mut _13: &u32;
    let _14: std::sync::Arc<users::User>;
    let mut _15: std::borrow::Cow<'_, str>;
    let _16: &std::ffi::OsStr;
    let _17: &users::User;
    let mut _18: &std::sync::Arc<users::User>;
    let mut _20: bool;
    let mut _21: u32;
    let mut _22: u32;
    let mut _23: ansi_term::Style;
    let mut _24: std::string::String;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: isize;
    let mut _28: isize;
    scope 1 {
        debug user_name => _5;
        let _19: ansi_term::Style;
        scope 3 {
            debug style => _19;
        }
    }
    scope 2 {
        debug user => _14;
    }

    bb0: {
        _26 = const false;
        _25 = const false;
        _8 = (_1.0: u32);
        _7 = <U as users::Users>::get_user_by_uid(_3, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _25 = const true;
        _6 = (_4, move _7);
        _11 = discriminant((_6.1: std::option::Option<std::sync::Arc<users::User>>));
        switchInt(move _11) -> [0: bb6, otherwise: bb2];
    }

    bb2: {
        _10 = discriminant((_6.0: output::table::UserFormat));
        switchInt(move _10) -> [0: bb8, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = discriminant((_6.1: std::option::Option<std::sync::Arc<users::User>>));
        switchInt(move _9) -> [1: bb5, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _25 = const false;
        _14 = move (((_6.1: std::option::Option<std::sync::Arc<users::User>>) as Some).0: std::sync::Arc<users::User>);
        _18 = &_14;
        _17 = <Arc<users::User> as Deref>::deref(move _18) -> [return: bb10, unwind: bb19];
    }

    bb6: {
        _12 = &(_1.0: u32);
        _5 = <u32 as ToString>::to_string(move _12) -> [return: bb7, unwind: bb29];
    }

    bb7: {
        _26 = const true;
        goto -> bb24;
    }

    bb8: {
        _13 = &(_1.0: u32);
        _5 = <u32 as ToString>::to_string(move _13) -> [return: bb9, unwind: bb29];
    }

    bb9: {
        _26 = const true;
        goto -> bb24;
    }

    bb10: {
        _16 = users::User::name(_17) -> [return: bb11, unwind: bb19];
    }

    bb11: {
        _15 = OsStr::to_string_lossy(_16) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _5 = <Cow<'_, str> as Into<String>>::into(move _15) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _26 = const true;
        drop(_14) -> [return: bb24, unwind: bb29];
    }

    bb14: {
        _22 = (_1.0: u32);
        _20 = Eq(move _21, move _22);
        switchInt(move _20) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _19 = <C as users::Colours>::you(_2) -> [return: bb30, unwind: bb26];
    }

    bb16: {
        _19 = <C as users::Colours>::someone_else(_2) -> [return: bb31, unwind: bb26];
    }

    bb17: {
        _23 = _19;
        _26 = const false;
        _24 = move _5;
        _0 = TextCell::paint(move _23, move _24) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _26 = const false;
        return;
    }

    bb19 (cleanup): {
        drop(_14) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21: {
        _25 = const false;
        _21 = <U as users::Users>::get_current_uid(_3) -> [return: bb14, unwind: bb26];
    }

    bb22: {
        switchInt(_25) -> [0: bb21, otherwise: bb23];
    }

    bb23: {
        drop((((_6.1: std::option::Option<std::sync::Arc<users::User>>) as Some).0: std::sync::Arc<users::User>)) -> [return: bb21, unwind: bb26];
    }

    bb24: {
        _27 = discriminant((_6.1: std::option::Option<std::sync::Arc<users::User>>));
        switchInt(move _27) -> [1: bb22, otherwise: bb21];
    }

    bb25 (cleanup): {
        drop(_5) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        switchInt(_26) -> [0: bb20, otherwise: bb25];
    }

    bb27 (cleanup): {
        switchInt(_25) -> [0: bb20, otherwise: bb28];
    }

    bb28 (cleanup): {
        drop((((_6.1: std::option::Option<std::sync::Arc<users::User>>) as Some).0: std::sync::Arc<users::User>)) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        _28 = discriminant((_6.1: std::option::Option<std::sync::Arc<users::User>>));
        switchInt(move _28) -> [1: bb27, otherwise: bb20];
    }

    bb30: {
        goto -> bb17;
    }

    bb31: {
        goto -> bb17;
    }
}

fn octal::<impl at src/output/render/octal.rs:7:1: 7:25>::bits_to_octal(_1: bool, _2: bool, _3: bool) -> u8 {
    debug r => _1;
    debug w => _2;
    debug x => _3;
    let mut _0: u8;
    let mut _4: u8;
    let mut _5: u8;
    let mut _6: u8;
    let mut _7: (u8, bool);
    let mut _8: u8;
    let mut _9: u8;
    let mut _10: (u8, bool);
    let mut _11: (u8, bool);
    let mut _12: u8;
    let mut _13: (u8, bool);

    bb0: {
        _6 = _1 as u8 (IntToInt);
        _7 = CheckedMul(_6, const 4_u8);
        assert(!move (_7.1: bool), "attempt to compute `{} * {}`, which would overflow", move _6, const 4_u8) -> [success: bb1, unwind continue];
    }

    bb1: {
        _5 = move (_7.0: u8);
        _9 = _2 as u8 (IntToInt);
        _10 = CheckedMul(_9, const 2_u8);
        assert(!move (_10.1: bool), "attempt to compute `{} * {}`, which would overflow", move _9, const 2_u8) -> [success: bb2, unwind continue];
    }

    bb2: {
        _8 = move (_10.0: u8);
        _11 = CheckedAdd(_5, _8);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", move _5, move _8) -> [success: bb3, unwind continue];
    }

    bb3: {
        _4 = move (_11.0: u8);
        _12 = _3 as u8 (IntToInt);
        _13 = CheckedAdd(_4, _12);
        assert(!move (_13.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, move _12) -> [success: bb4, unwind continue];
    }

    bb4: {
        _0 = move (_13.0: u8);
        return;
    }
}

fn octal::<impl at src/output/render/octal.rs:7:1: 7:25>::render(_1: &OctalPermissions, _2: Style) -> TextCell {
    debug self => _1;
    debug style => _2;
    let mut _0: output::cell::TextCell;
    let _3: &fs::fields::Permissions;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 4];
    let _25: [core::fmt::rt::Argument<'_>; 4];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &u8;
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &u8;
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &u8;
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &u8;
    scope 1 {
        debug perm => _3;
        let _4: u8;
        scope 2 {
            debug octal_sticky => _4;
            let _8: u8;
            scope 3 {
                debug octal_owner => _8;
                let _12: u8;
                scope 4 {
                    debug octal_group => _12;
                    let _16: u8;
                    scope 5 {
                        debug octal_other => _16;
                        let _20: std::string::String;
                        let mut _34: &[&str; 4];
                        scope 6 {
                            debug res => _20;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = &((*_1).0: fs::fields::Permissions);
        _5 = ((*_3).11: bool);
        _6 = ((*_3).10: bool);
        _7 = ((*_3).9: bool);
        _4 = octal::<impl OctalPermissions>::bits_to_octal(move _5, move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ((*_3).0: bool);
        _10 = ((*_3).1: bool);
        _11 = ((*_3).2: bool);
        _8 = octal::<impl OctalPermissions>::bits_to_octal(move _9, move _10, move _11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = ((*_3).3: bool);
        _14 = ((*_3).4: bool);
        _15 = ((*_3).5: bool);
        _12 = octal::<impl OctalPermissions>::bits_to_octal(move _13, move _14, move _15) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = ((*_3).6: bool);
        _18 = ((*_3).7: bool);
        _19 = ((*_3).8: bool);
        _16 = octal::<impl OctalPermissions>::bits_to_octal(move _17, move _18, move _19) -> [return: bb4, unwind continue];
    }

    bb4: {
        _34 = const _;
        _22 = _34 as &[&str] (PointerCoercion(Unsize));
        _27 = &_4;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<u8>(_27) -> [return: bb5, unwind continue];
    }

    bb5: {
        _29 = &_8;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<u8>(_29) -> [return: bb6, unwind continue];
    }

    bb6: {
        _31 = &_12;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<u8>(_31) -> [return: bb7, unwind continue];
    }

    bb7: {
        _33 = &_16;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<u8>(_33) -> [return: bb8, unwind continue];
    }

    bb8: {
        _25 = [move _26, move _28, move _30, move _32];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = format(move _21) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = TextCell::paint(_2, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

promoted[0] in octal::<impl at src/output/render/octal.rs:7:1: 7:25>::render: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "", const "", const "", const ""];
        _0 = &_1;
        return;
    }
}

fn table::<impl at src/output/table.rs:22:10: 22:19>::eq(_1: &table::Options, _2: &table::Options) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &output::table::SizeFormat;
    let mut _5: &output::table::SizeFormat;
    let mut _6: bool;
    let mut _7: &output::time::TimeFormat;
    let mut _8: &output::time::TimeFormat;
    let mut _9: bool;
    let mut _10: &output::table::UserFormat;
    let mut _11: &output::table::UserFormat;
    let mut _12: &output::table::Columns;
    let mut _13: &output::table::Columns;

    bb0: {
        _4 = &((*_1).0: output::table::SizeFormat);
        _5 = &((*_2).0: output::table::SizeFormat);
        _3 = <SizeFormat as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: output::time::TimeFormat);
        _8 = &((*_2).1: output::time::TimeFormat);
        _6 = <TimeFormat as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: output::table::UserFormat);
        _11 = &((*_2).2: output::table::UserFormat);
        _9 = <UserFormat as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _12 = &((*_1).3: output::table::Columns);
        _13 = &((*_2).3: output::table::Columns);
        _0 = <Columns as PartialEq>::eq(move _12, move _13) -> [return: bb8, unwind continue];
    }

    bb7: {
        _0 = const false;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn table::<impl at src/output/table.rs:22:21: 22:26>::fmt(_1: &table::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::table::SizeFormat;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &output::time::TimeFormat;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &output::table::UserFormat;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&output::table::Columns;
    let _16: &output::table::Columns;

    bb0: {
        _3 = const "Options";
        _4 = const "size_format";
        _6 = &((*_1).0: output::table::SizeFormat);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "time_format";
        _9 = &((*_1).1: output::time::TimeFormat);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "user_format";
        _12 = &((*_1).2: output::table::UserFormat);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "columns";
        _16 = &((*_1).3: output::table::Columns);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:31:10: 31:19>::eq(_1: &Columns, _2: &Columns) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &output::table::TimeTypes;
    let mut _5: &output::table::TimeTypes;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;

    bb0: {
        _4 = &((*_1).0: output::table::TimeTypes);
        _5 = &((*_2).0: output::table::TimeTypes);
        _3 = <TimeTypes as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb11, otherwise: bb2];
    }

    bb2: {
        _7 = ((*_1).1: bool);
        _8 = ((*_2).1: bool);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb11, otherwise: bb3];
    }

    bb3: {
        _10 = ((*_1).2: bool);
        _11 = ((*_2).2: bool);
        _9 = Eq(move _10, move _11);
        switchInt(move _9) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _13 = ((*_1).3: bool);
        _14 = ((*_2).3: bool);
        _12 = Eq(move _13, move _14);
        switchInt(move _12) -> [0: bb11, otherwise: bb5];
    }

    bb5: {
        _16 = ((*_1).4: bool);
        _17 = ((*_2).4: bool);
        _15 = Eq(move _16, move _17);
        switchInt(move _15) -> [0: bb11, otherwise: bb6];
    }

    bb6: {
        _19 = ((*_1).5: bool);
        _20 = ((*_2).5: bool);
        _18 = Eq(move _19, move _20);
        switchInt(move _18) -> [0: bb11, otherwise: bb7];
    }

    bb7: {
        _22 = ((*_1).6: bool);
        _23 = ((*_2).6: bool);
        _21 = Eq(move _22, move _23);
        switchInt(move _21) -> [0: bb11, otherwise: bb8];
    }

    bb8: {
        _25 = ((*_1).7: bool);
        _26 = ((*_2).7: bool);
        _24 = Eq(move _25, move _26);
        switchInt(move _24) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _28 = ((*_1).8: bool);
        _29 = ((*_2).8: bool);
        _27 = Eq(move _28, move _29);
        switchInt(move _27) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _30 = ((*_1).9: bool);
        _31 = ((*_2).9: bool);
        _0 = Eq(move _30, move _31);
        goto -> bb12;
    }

    bb11: {
        _0 = const false;
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn table::<impl at src/output/table.rs:31:21: 31:26>::fmt(_1: &Columns, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 10];
    let _5: [&dyn std::fmt::Debug; 10];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &output::table::TimeTypes;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &bool;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &bool;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &bool;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &bool;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &bool;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &bool;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &bool;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &&bool;
    let _26: &bool;
    let _27: &str;
    let mut _28: &[&str];
    let mut _29: &[&str; 10];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _29 = const _;
        _7 = &((*_1).0: output::table::TimeTypes);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: bool);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: bool);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: bool);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: bool);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: bool);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: bool);
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: bool);
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _26 = &((*_1).9: bool);
        _25 = &_26;
        _24 = _25 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _27 = const "Columns";
        _28 = _29 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _27, move _28, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in table::<impl at src/output/table.rs:31:21: 31:26>::fmt: &[&str; 10] = {
    let mut _0: &[&str; 10];
    let mut _1: [&str; 10];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;

    bb0: {
        _3 = const "inode";
        _2 = &(*_3);
        _5 = const "links";
        _4 = &(*_5);
        _7 = const "blocks";
        _6 = &(*_7);
        _9 = const "group";
        _8 = &(*_9);
        _11 = const "git";
        _10 = &(*_11);
        _13 = const "octal";
        _12 = &(*_13);
        _15 = const "permissions";
        _14 = &(*_15);
        _17 = const "filesize";
        _16 = &(*_17);
        _19 = const "user";
        _18 = &(*_19);
        _1 = [const "time_types", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _0 = &_1;
        return;
    }
}

fn table::<impl at src/output/table.rs:31:34: 31:39>::clone(_1: &Columns) -> Columns {
    debug self => _1;
    let mut _0: output::table::Columns;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:51:1: 51:13>::collect(_1: &Columns, _2: bool) -> Vec<Column> {
    debug self => _1;
    debug actually_enable_git => _2;
    let mut _0: std::vec::Vec<output::table::Column>;
    let mut _3: std::vec::Vec<output::table::Column>;
    let mut _4: bool;
    let _5: ();
    let mut _6: &mut std::vec::Vec<output::table::Column>;
    let mut _7: output::table::Column;
    let mut _8: bool;
    let _9: ();
    let mut _10: &mut std::vec::Vec<output::table::Column>;
    let mut _11: output::table::Column;
    let mut _12: bool;
    let _13: ();
    let mut _14: &mut std::vec::Vec<output::table::Column>;
    let mut _15: output::table::Column;
    let mut _16: bool;
    let _17: ();
    let mut _18: &mut std::vec::Vec<output::table::Column>;
    let mut _19: output::table::Column;
    let mut _20: bool;
    let _21: ();
    let mut _22: &mut std::vec::Vec<output::table::Column>;
    let mut _23: output::table::Column;
    let mut _24: bool;
    let _25: ();
    let mut _26: &mut std::vec::Vec<output::table::Column>;
    let mut _27: output::table::Column;
    let mut _28: bool;
    let _29: ();
    let mut _30: &mut std::vec::Vec<output::table::Column>;
    let mut _31: output::table::Column;
    let mut _32: bool;
    let _33: ();
    let mut _34: &mut std::vec::Vec<output::table::Column>;
    let mut _35: output::table::Column;
    let mut _36: bool;
    let _37: ();
    let mut _38: &mut std::vec::Vec<output::table::Column>;
    let mut _39: output::table::Column;
    let mut _40: output::table::TimeType;
    let mut _41: bool;
    let _42: ();
    let mut _43: &mut std::vec::Vec<output::table::Column>;
    let mut _44: output::table::Column;
    let mut _45: output::table::TimeType;
    let mut _46: bool;
    let _47: ();
    let mut _48: &mut std::vec::Vec<output::table::Column>;
    let mut _49: output::table::Column;
    let mut _50: output::table::TimeType;
    let mut _51: bool;
    let _52: ();
    let mut _53: &mut std::vec::Vec<output::table::Column>;
    let mut _54: output::table::Column;
    let mut _55: output::table::TimeType;
    let mut _56: bool;
    let _57: ();
    let mut _58: &mut std::vec::Vec<output::table::Column>;
    let mut _59: output::table::Column;
    scope 1 {
        debug columns => _3;
    }

    bb0: {
        _3 = Vec::<Column>::with_capacity(const 4_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ((*_1).1: bool);
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &mut _3;
        _7 = Column::Inode;
        _5 = Vec::<Column>::push(move _6, move _7) -> [return: bb31, unwind: bb29];
    }

    bb3: {
        _8 = ((*_1).6: bool);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _10 = &mut _3;
        _11 = Column::Octal;
        _9 = Vec::<Column>::push(move _10, move _11) -> [return: bb32, unwind: bb29];
    }

    bb5: {
        _12 = ((*_1).7: bool);
        switchInt(move _12) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _14 = &mut _3;
        _15 = Column::Permissions;
        _13 = Vec::<Column>::push(move _14, move _15) -> [return: bb33, unwind: bb29];
    }

    bb7: {
        _16 = ((*_1).2: bool);
        switchInt(move _16) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _18 = &mut _3;
        _19 = Column::HardLinks;
        _17 = Vec::<Column>::push(move _18, move _19) -> [return: bb34, unwind: bb29];
    }

    bb9: {
        _20 = ((*_1).8: bool);
        switchInt(move _20) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _22 = &mut _3;
        _23 = Column::FileSize;
        _21 = Vec::<Column>::push(move _22, move _23) -> [return: bb35, unwind: bb29];
    }

    bb11: {
        _24 = ((*_1).3: bool);
        switchInt(move _24) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _26 = &mut _3;
        _27 = Column::Blocks;
        _25 = Vec::<Column>::push(move _26, move _27) -> [return: bb36, unwind: bb29];
    }

    bb13: {
        _28 = ((*_1).9: bool);
        switchInt(move _28) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _30 = &mut _3;
        _31 = Column::User;
        _29 = Vec::<Column>::push(move _30, move _31) -> [return: bb37, unwind: bb29];
    }

    bb15: {
        _32 = ((*_1).4: bool);
        switchInt(move _32) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _34 = &mut _3;
        _35 = Column::Group;
        _33 = Vec::<Column>::push(move _34, move _35) -> [return: bb38, unwind: bb29];
    }

    bb17: {
        _36 = (((*_1).0: output::table::TimeTypes).0: bool);
        switchInt(move _36) -> [0: bb19, otherwise: bb18];
    }

    bb18: {
        _38 = &mut _3;
        _40 = table::TimeType::Modified;
        _39 = Column::Timestamp(move _40);
        _37 = Vec::<Column>::push(move _38, move _39) -> [return: bb39, unwind: bb29];
    }

    bb19: {
        _41 = (((*_1).0: output::table::TimeTypes).1: bool);
        switchInt(move _41) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _43 = &mut _3;
        _45 = table::TimeType::Changed;
        _44 = Column::Timestamp(move _45);
        _42 = Vec::<Column>::push(move _43, move _44) -> [return: bb40, unwind: bb29];
    }

    bb21: {
        _46 = (((*_1).0: output::table::TimeTypes).3: bool);
        switchInt(move _46) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _48 = &mut _3;
        _50 = table::TimeType::Created;
        _49 = Column::Timestamp(move _50);
        _47 = Vec::<Column>::push(move _48, move _49) -> [return: bb41, unwind: bb29];
    }

    bb23: {
        _51 = (((*_1).0: output::table::TimeTypes).2: bool);
        switchInt(move _51) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _53 = &mut _3;
        _55 = table::TimeType::Accessed;
        _54 = Column::Timestamp(move _55);
        _52 = Vec::<Column>::push(move _53, move _54) -> [return: bb42, unwind: bb29];
    }

    bb25: {
        _56 = ((*_1).5: bool);
        switchInt(move _56) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        switchInt(_2) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _58 = &mut _3;
        _59 = Column::GitStatus;
        _57 = Vec::<Column>::push(move _58, move _59) -> [return: bb43, unwind: bb29];
    }

    bb28: {
        _0 = move _3;
        return;
    }

    bb29 (cleanup): {
        drop(_3) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }

    bb31: {
        goto -> bb3;
    }

    bb32: {
        goto -> bb5;
    }

    bb33: {
        goto -> bb7;
    }

    bb34: {
        goto -> bb9;
    }

    bb35: {
        goto -> bb11;
    }

    bb36: {
        goto -> bb13;
    }

    bb37: {
        goto -> bb15;
    }

    bb38: {
        goto -> bb17;
    }

    bb39: {
        goto -> bb19;
    }

    bb40: {
        goto -> bb21;
    }

    bb41: {
        goto -> bb23;
    }

    bb42: {
        goto -> bb25;
    }

    bb43: {
        goto -> bb28;
    }
}

fn table::<impl at src/output/table.rs:113:10: 113:15>::fmt(_1: &Column, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &output::table::TimeType;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&output::table::TimeType;
    let _10: &str;
    let _11: &str;
    let _12: &str;
    let _13: &str;
    let _14: &str;
    let _15: &str;
    let _16: &str;
    scope 1 {
        debug __self_0 => _6;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 9: bb1, otherwise: bb2];
    }

    bb1: {
        _16 = const "Octal";
        _0 = Formatter::<'_>::write_str(_2, _16) -> [return: bb12, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "Permissions";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb12, unwind continue];
    }

    bb4: {
        _5 = const "FileSize";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb12, unwind continue];
    }

    bb5: {
        _6 = &(((*_1) as Timestamp).0: output::table::TimeType);
        _7 = const "Timestamp";
        _9 = &_6;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _7, move _8) -> [return: bb12, unwind continue];
    }

    bb6: {
        _10 = const "Blocks";
        _0 = Formatter::<'_>::write_str(_2, _10) -> [return: bb12, unwind continue];
    }

    bb7: {
        _11 = const "User";
        _0 = Formatter::<'_>::write_str(_2, _11) -> [return: bb12, unwind continue];
    }

    bb8: {
        _12 = const "Group";
        _0 = Formatter::<'_>::write_str(_2, _12) -> [return: bb12, unwind continue];
    }

    bb9: {
        _13 = const "HardLinks";
        _0 = Formatter::<'_>::write_str(_2, _13) -> [return: bb12, unwind continue];
    }

    bb10: {
        _14 = const "Inode";
        _0 = Formatter::<'_>::write_str(_2, _14) -> [return: bb12, unwind continue];
    }

    bb11: {
        _15 = const "GitStatus";
        _0 = Formatter::<'_>::write_str(_2, _15) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn table::<impl at src/output/table.rs:113:23: 113:28>::clone(_1: &Column) -> Column {
    debug self => _1;
    let mut _0: output::table::Column;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:129:16: 129:21>::clone(_1: &table::Alignment) -> table::Alignment {
    debug self => _1;
    let mut _0: output::table::Alignment;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:135:1: 135:12>::alignment(_1: Column) -> table::Alignment {
    debug self => _1;
    let mut _0: output::table::Alignment;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb2, 3: bb2, 6: bb2, 7: bb2, 8: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = table::Alignment::Left;
        goto -> bb3;
    }

    bb2: {
        _0 = table::Alignment::Right;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn table::<impl at src/output/table.rs:135:1: 135:12>::header(_1: Column) -> &str {
    debug self => _1;
    let mut _0: &str;
    let mut _2: isize;
    let _3: output::table::TimeType;
    scope 1 {
        debug t => _3;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb9, 7: bb10, 8: bb11, 9: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const "Octal";
        goto -> bb12;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const "Permissions";
        goto -> bb12;
    }

    bb4: {
        _0 = const "Size";
        goto -> bb12;
    }

    bb5: {
        _3 = ((_1 as Timestamp).0: output::table::TimeType);
        _0 = table::TimeType::header(_3) -> [return: bb12, unwind continue];
    }

    bb6: {
        _0 = const "Blocks";
        goto -> bb12;
    }

    bb7: {
        _0 = const "User";
        goto -> bb12;
    }

    bb8: {
        _0 = const "Group";
        goto -> bb12;
    }

    bb9: {
        _0 = const "Links";
        goto -> bb12;
    }

    bb10: {
        _0 = const "inode";
        goto -> bb12;
    }

    bb11: {
        _0 = const "Git";
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn table::<impl at src/output/table.rs:169:10: 169:19>::eq(_1: &SizeFormat, _2: &SizeFormat) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn table::<impl at src/output/table.rs:169:21: 169:26>::fmt(_1: &SizeFormat, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "JustBytes";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "DecimalBytes";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "BinaryBytes";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn table::<impl at src/output/table.rs:169:34: 169:39>::clone(_1: &SizeFormat) -> SizeFormat {
    debug self => _1;
    let mut _0: output::table::SizeFormat;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:185:10: 185:19>::eq(_1: &UserFormat, _2: &UserFormat) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn table::<impl at src/output/table.rs:185:21: 185:26>::fmt(_1: &UserFormat, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "Name";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Numeric";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn table::<impl at src/output/table.rs:185:34: 185:39>::clone(_1: &UserFormat) -> UserFormat {
    debug self => _1;
    let mut _0: output::table::UserFormat;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:193:1: 193:28>::default() -> SizeFormat {
    let mut _0: output::table::SizeFormat;

    bb0: {
        _0 = SizeFormat::DecimalBytes;
        return;
    }
}

fn table::<impl at src/output/table.rs:202:10: 202:19>::eq(_1: &table::TimeType, _2: &table::TimeType) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn table::<impl at src/output/table.rs:202:21: 202:26>::fmt(_1: &table::TimeType, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Created";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Modified";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Changed";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Accessed";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn table::<impl at src/output/table.rs:202:34: 202:39>::clone(_1: &table::TimeType) -> table::TimeType {
    debug self => _1;
    let mut _0: output::table::TimeType;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:218:1: 218:14>::header(_1: table::TimeType) -> &str {
    debug self => _1;
    let mut _0: &str;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const "Date Created";
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const "Date Modified";
        goto -> bb6;
    }

    bb4: {
        _0 = const "Date Changed";
        goto -> bb6;
    }

    bb5: {
        _0 = const "Date Accessed";
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn table::<impl at src/output/table.rs:237:10: 237:19>::eq(_1: &TimeTypes, _2: &TimeTypes) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;

    bb0: {
        _4 = ((*_1).0: bool);
        _5 = ((*_2).0: bool);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _7 = ((*_1).1: bool);
        _8 = ((*_2).1: bool);
        _6 = Eq(move _7, move _8);
        switchInt(move _6) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _10 = ((*_1).2: bool);
        _11 = ((*_2).2: bool);
        _9 = Eq(move _10, move _11);
        switchInt(move _9) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _12 = ((*_1).3: bool);
        _13 = ((*_2).3: bool);
        _0 = Eq(move _12, move _13);
        goto -> bb5;
    }

    bb4: {
        _0 = const false;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn table::<impl at src/output/table.rs:237:21: 237:26>::fmt(_1: &TimeTypes, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &bool;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &bool;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&bool;
    let _16: &bool;

    bb0: {
        _3 = const "TimeTypes";
        _4 = const "modified";
        _6 = &((*_1).0: bool);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "changed";
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "accessed";
        _12 = &((*_1).2: bool);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "created";
        _16 = &((*_1).3: bool);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:237:34: 237:39>::clone(_1: &TimeTypes) -> TimeTypes {
    debug self => _1;
    let mut _0: output::table::TimeTypes;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn table::<impl at src/output/table.rs:246:1: 246:27>::default() -> TimeTypes {
    let mut _0: output::table::TimeTypes;

    bb0: {
        _0 = TimeTypes { modified: const true, changed: const false, accessed: const false, created: const false };
        return;
    }
}

fn table::<impl at src/output/table.rs:278:1: 278:17>::lock_users(_1: &Environment) -> MutexGuard<'_, UsersCache> {
    debug self => _1;
    let mut _0: std::sync::MutexGuard<'_, users::UsersCache>;
    let mut _2: std::result::Result<std::sync::MutexGuard<'_, users::UsersCache>, std::sync::PoisonError<std::sync::MutexGuard<'_, users::UsersCache>>>;
    let mut _3: &std::sync::Mutex<users::UsersCache>;

    bb0: {
        _3 = &((*_1).2: std::sync::Mutex<users::UsersCache>);
        _2 = Mutex::<UsersCache>::lock(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<MutexGuard<'_, UsersCache>, PoisonError<MutexGuard<'_, UsersCache>>>::unwrap(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn table::<impl at src/output/table.rs:278:1: 278:17>::load_all() -> Environment {
    let mut _0: output::table::Environment;
    let _1: std::option::Option<datetime::TimeZone>;
    let mut _2: std::result::Result<datetime::TimeZone, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: isize;
    let _4: datetime::TimeZone;
    let _5: &std::boxed::Box<dyn std::error::Error>;
    let _6: ();
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 1];
    let _11: [core::fmt::rt::Argument<'_>; 1];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &&std::boxed::Box<dyn std::error::Error>;
    let mut _15: std::result::Result<locale::Numeric, std::io::Error>;
    let mut _17: users::UsersCache;
    let mut _18: std::option::Option<datetime::TimeZone>;
    let mut _19: locale::Numeric;
    let mut _21: isize;
    let mut _22: isize;
    scope 1 {
        debug tz => _1;
        let _14: locale::Numeric;
        scope 4 {
            debug numeric => _14;
            let _16: std::sync::Mutex<users::UsersCache>;
            scope 5 {
                debug users => _16;
            }
        }
    }
    scope 2 {
        debug t => _4;
    }
    scope 3 {
        debug e => _5;
        let mut _20: &[&str; 2];
    }

    bb0: {
        _2 = determine_time_zone() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = &((_2 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _20 = const _;
        _8 = _20 as &[&str] (PointerCoercion(Unsize));
        _13 = &_5;
        _12 = core::fmt::rt::Argument::<'_>::new_display::<&Box<dyn std::error::Error>>(_13) -> [return: bb5, unwind: bb19];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _4 = move ((_2 as Ok).0: datetime::TimeZone);
        _1 = Option::<TimeZone>::Some(move _4);
        goto -> bb17;
    }

    bb5: {
        _11 = [move _12];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _7 = std::fmt::Arguments::<'_>::new_v1(move _8, move _9) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _6 = _print(move _7) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _1 = Option::<TimeZone>::None;
        goto -> bb17;
    }

    bb8: {
        _14 = Result::<Numeric, std::io::Error>::unwrap_or_else::<{closure@src/output/table.rs:295:46: 295:49}>(move _15, const ZeroSized: {closure@src/output/table.rs:295:46: 295:49}) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _17 = UsersCache::new() -> [return: bb10, unwind: bb12];
    }

    bb10: {
        _16 = Mutex::<UsersCache>::new(move _17) -> [return: bb11, unwind: bb12];
    }

    bb11: {
        _18 = move _1;
        _19 = move _14;
        _0 = Environment { numeric: move _19, tz: move _18, users: move _16 };
        return;
    }

    bb12 (cleanup): {
        drop(_14) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_1) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        _15 = Numeric::load_user_locale() -> [return: bb8, unwind: bb13];
    }

    bb16: {
        drop(_2) -> [return: bb15, unwind: bb13];
    }

    bb17: {
        _21 = discriminant(_2);
        switchInt(move _21) -> [0: bb15, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        _22 = discriminant(_2);
        switchInt(move _22) -> [0: bb14, otherwise: bb18];
    }
}

promoted[0] in table::<impl at src/output/table.rs:278:1: 278:17>::load_all: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Unable to determine time zone: ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn table::<impl at src/output/table.rs:278:1: 278:17>::load_all::{closure#0}(_1: {closure@src/output/table.rs:295:46: 295:49}, _2: std::io::Error) -> Numeric {
    let mut _0: locale::Numeric;

    bb0: {
        _0 = Numeric::english() -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn determine_time_zone() -> Result<TimeZone, Box<dyn std::error::Error>> {
    let mut _0: std::result::Result<datetime::TimeZone, std::boxed::Box<dyn std::error::Error>>;
    let mut _1: std::result::Result<std::string::String, std::env::VarError>;
    let mut _2: isize;
    let mut _4: std::string::String;
    let mut _5: bool;
    let _6: &str;
    let mut _7: &std::string::String;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &std::string::String;
    let _16: std::string::String;
    let mut _17: bool;
    let _18: &str;
    let mut _19: &std::string::String;
    let _20: &str;
    let mut _21: &std::string::String;
    let _22: &str;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: isize;
    let mut _27: isize;
    scope 1 {
        debug file => _3;
        let _3: std::string::String;
        let _8: std::string::String;
        let mut _23: &[&str; 1];
        scope 2 {
            debug res => _8;
        }
    }

    bb0: {
        _24 = const false;
        _25 = const false;
        _25 = const true;
        _1 = var::<&str>(const "TZ") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, otherwise: bb19];
    }

    bb2: {
        _25 = const false;
        _24 = const true;
        _3 = move ((_1 as Ok).0: std::string::String);
        _7 = &_3;
        _6 = <String as Deref>::deref(move _7) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _5 = core::str::<impl str>::starts_with::<'_, &str>(_6, const "/") -> [return: bb4, unwind: bb31];
    }

    bb4: {
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _24 = const false;
        _4 = move _3;
        goto -> bb17;
    }

    bb6: {
        _23 = const _;
        _10 = _23 as &[&str] (PointerCoercion(Unsize));
        _19 = &_3;
        _18 = <String as Deref>::deref(move _19) -> [return: bb7, unwind: bb31];
    }

    bb7: {
        _17 = core::str::<impl str>::starts_with::<'_, &str>(_18, const ":") -> [return: bb8, unwind: bb31];
    }

    bb8: {
        switchInt(move _17) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _21 = &_3;
        _20 = <String as Deref>::deref(move _21) -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _22 = const "";
        _16 = str::<impl str>::replacen::<'_, &str>(_20, const ":", _22, const 1_usize) -> [return: bb36, unwind: bb31];
    }

    bb11: {
        _24 = const false;
        _16 = move _3;
        goto -> bb12;
    }

    bb12: {
        _15 = &_16;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<String>(_15) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = std::fmt::Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _8 = format(move _9) -> [return: bb15, unwind: bb22];
    }

    bb15: {
        drop(_16) -> [return: bb16, unwind: bb21];
    }

    bb16: {
        _4 = move _8;
        goto -> bb17;
    }

    bb17: {
        _0 = <TimeZone as CompiledData>::from_file::<String>(move _4) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        switchInt(_24) -> [0: bb20, otherwise: bb24];
    }

    bb19: {
        _0 = <TimeZone as CompiledData>::from_file::<&str>(const "/etc/localtime") -> [return: bb37, unwind: bb35];
    }

    bb20: {
        _24 = const false;
        goto -> bb29;
    }

    bb21 (cleanup): {
        drop(_8) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_16) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }

    bb24: {
        drop(_3) -> [return: bb20, unwind: bb35];
    }

    bb25: {
        _25 = const false;
        return;
    }

    bb26: {
        switchInt(_25) -> [0: bb25, otherwise: bb27];
    }

    bb27: {
        drop(((_1 as Ok).0: std::string::String)) -> [return: bb25, unwind continue];
    }

    bb28: {
        drop(_1) -> [return: bb25, unwind continue];
    }

    bb29: {
        _26 = discriminant(_1);
        switchInt(move _26) -> [0: bb26, otherwise: bb28];
    }

    bb30 (cleanup): {
        drop(_3) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        switchInt(_24) -> [0: bb35, otherwise: bb30];
    }

    bb32 (cleanup): {
        switchInt(_25) -> [0: bb23, otherwise: bb33];
    }

    bb33 (cleanup): {
        drop(((_1 as Ok).0: std::string::String)) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_1) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        _27 = discriminant(_1);
        switchInt(move _27) -> [0: bb32, otherwise: bb34];
    }

    bb36: {
        goto -> bb12;
    }

    bb37: {
        goto -> bb29;
    }
}

promoted[0] in determine_time_zone: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "/usr/share/zoneinfo/"];
        _0 = &_1;
        return;
    }
}

static ENVIRONMENT: ENVIRONMENT = {
    let mut _0: output::table::ENVIRONMENT;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = ENVIRONMENT { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn table::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &ENVIRONMENT) -> &Environment {
    debug self => _1;
    let mut _0: &output::table::Environment;

    bb0: {
        _0 = <ENVIRONMENT as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> Environment {
    let mut _0: output::table::Environment;

    bb0: {
        _0 = Environment::load_all() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &Environment {
    let mut _0: &output::table::Environment;
    let _1: &lazy_static::lazy::Lazy<output::table::Environment>;

    bb0: {
        _1 = const {alloc68: &Lazy<Environment>};
        _0 = Lazy::<Environment>::get::<fn() -> Environment {<ENVIRONMENT as Deref>::deref::__static_ref_initialize}>(_1, <ENVIRONMENT as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc68 (static: <ENVIRONMENT as Deref>::deref::__stability::LAZY, size: 336, align: 8) {
    0x000  03 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x010  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x020  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x030  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x040  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x050  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x060  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x070  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x080  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x090  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0a0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0b0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0c0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0d0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0e0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x0f0  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x100  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x110  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x120  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x130  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x140  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static table::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<Environment> = {
    let mut _0: lazy_static::lazy::Lazy<output::table::Environment>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn table::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &ENVIRONMENT) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &output::table::Environment;
    scope 1 {
    }

    bb0: {
        _2 = <ENVIRONMENT as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:339:10: 339:15>::clone(_1: &table::Row) -> table::Row {
    debug self => _1;
    let mut _0: output::table::Row;
    let mut _2: std::vec::Vec<output::cell::TextCell>;
    let _3: &std::vec::Vec<output::cell::TextCell>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<output::cell::TextCell>);
        _2 = <Vec<TextCell> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = table::Row { cells: move _2 };
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::new(_1: &table::Options, _2: Option<&GitCache>, _3: &Theme) -> Table<'_> {
    debug options => _1;
    debug git => _2;
    debug theme => _3;
    let mut _0: output::table::Table<'_>;
    let _4: std::vec::Vec<output::table::Column>;
    let mut _5: &output::table::Columns;
    let mut _6: bool;
    let mut _7: &std::option::Option<&fs::feature::git::GitCache>;
    let mut _9: usize;
    let mut _10: &std::vec::Vec<output::table::Column>;
    let _11: &output::table::Environment;
    let _12: &output::table::ENVIRONMENT;
    let mut _13: output::table::TableWidths;
    let mut _14: std::vec::Vec<output::table::Column>;
    let mut _15: std::option::Option<&fs::feature::git::GitCache>;
    let mut _16: output::time::TimeFormat;
    let mut _17: output::table::SizeFormat;
    let mut _18: output::table::UserFormat;
    scope 1 {
        debug columns => _4;
        let _8: output::table::TableWidths;
        scope 2 {
            debug widths => _8;
            scope 3 {
                debug env => _11;
            }
        }
    }

    bb0: {
        _5 = &((*_1).3: output::table::Columns);
        _7 = &_2;
        _6 = Option::<&GitCache>::is_some(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Columns::collect(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &_4;
        _9 = Vec::<Column>::len(move _10) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _8 = TableWidths::zero(move _9) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _12 = const {alloc69: &ENVIRONMENT};
        _11 = <ENVIRONMENT as Deref>::deref(_12) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _13 = move _8;
        _14 = move _4;
        _15 = _2;
        _16 = ((*_1).1: output::time::TimeFormat);
        _17 = ((*_1).0: output::table::SizeFormat);
        _18 = ((*_1).2: output::table::UserFormat);
        _0 = Table::<'_> { columns: move _14, theme: _3, env: _11, widths: move _13, time_format: move _16, size_format: move _17, user_format: move _18, git: move _15 };
        return;
    }

    bb6 (cleanup): {
        drop(_8) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

alloc69 (static: ENVIRONMENT, size: 0, align: 1) {}

fn table::<impl at src/output/table.rs:344:1: 344:23>::widths(_1: &Table<'_>) -> &TableWidths {
    debug self => _1;
    let mut _0: &output::table::TableWidths;

    bb0: {
        _0 = &((*_1).3: output::table::TableWidths);
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::header_row(_1: &Table<'_>) -> table::Row {
    debug self => _1;
    let mut _0: output::table::Row;
    let _2: std::vec::Vec<output::cell::TextCell>;
    let mut _3: std::iter::Map<std::slice::Iter<'_, output::table::Column>, {closure@src/output/table.rs:368:30: 368:33}>;
    let mut _4: std::slice::Iter<'_, output::table::Column>;
    let _5: &[output::table::Column];
    let mut _6: &std::vec::Vec<output::table::Column>;
    let mut _7: {closure@src/output/table.rs:368:30: 368:33};
    let mut _8: &&output::table::Table<'_>;
    scope 1 {
        debug cells => _2;
    }

    bb0: {
        _6 = &((*_1).0: std::vec::Vec<output::table::Column>);
        _5 = <Vec<Column> as Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [Column]>::iter(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &_1;
        _7 = {closure@src/output/table.rs:368:30: 368:33} { self: move _8 };
        _3 = <std::slice::Iter<'_, Column> as Iterator>::map::<TextCell, {closure@src/output/table.rs:368:30: 368:33}>(move _4, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <Map<std::slice::Iter<'_, Column>, {closure@src/output/table.rs:368:30: 368:33}> as Iterator>::collect::<Vec<TextCell>>(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = table::Row { cells: move _2 };
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::header_row::{closure#0}(_1: &mut {closure@src/output/table.rs:368:30: 368:33}, _2: &Column) -> TextCell {
    debug c => _2;
    debug self => (*((*_1).0: &&output::table::Table<'_>));
    let mut _0: output::cell::TextCell;
    let mut _3: ansi_term::Style;
    let mut _4: &str;
    let mut _5: output::table::Column;
    let mut _6: &&output::table::Table<'_>;
    let mut _7: &output::table::Table<'_>;
    let mut _8: &theme::Theme;

    bb0: {
        _6 = deref_copy ((*_1).0: &&output::table::Table<'_>);
        _7 = deref_copy (*_6);
        _8 = deref_copy ((*_7).1: &theme::Theme);
        _3 = (((*_8).0: theme::ui_styles::UiStyles).11: ansi_term::Style);
        _5 = (*_2);
        _4 = Column::header(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = TextCell::paint_str(move _3, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::row_for_file(_1: &Table<'_>, _2: &file::File<'_>, _3: bool) -> table::Row {
    debug self => _1;
    debug file => _2;
    debug xattrs => _3;
    let mut _0: output::table::Row;
    let _4: std::vec::Vec<output::cell::TextCell>;
    let mut _5: std::iter::Map<std::slice::Iter<'_, output::table::Column>, {closure@src/output/table.rs:376:30: 376:33}>;
    let mut _6: std::slice::Iter<'_, output::table::Column>;
    let _7: &[output::table::Column];
    let mut _8: &std::vec::Vec<output::table::Column>;
    let mut _9: {closure@src/output/table.rs:376:30: 376:33};
    let mut _10: &&output::table::Table<'_>;
    let mut _11: &&fs::file::File<'_>;
    let mut _12: &bool;
    scope 1 {
        debug cells => _4;
    }

    bb0: {
        _8 = &((*_1).0: std::vec::Vec<output::table::Column>);
        _7 = <Vec<Column> as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = core::slice::<impl [Column]>::iter(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &_1;
        _11 = &_2;
        _12 = &_3;
        _9 = {closure@src/output/table.rs:376:30: 376:33} { self: move _10, file: move _11, xattrs: move _12 };
        _5 = <std::slice::Iter<'_, Column> as Iterator>::map::<TextCell, {closure@src/output/table.rs:376:30: 376:33}>(move _6, move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Map<std::slice::Iter<'_, Column>, {closure@src/output/table.rs:376:30: 376:33}> as Iterator>::collect::<Vec<TextCell>>(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = table::Row { cells: move _4 };
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::row_for_file::{closure#0}(_1: &mut {closure@src/output/table.rs:376:30: 376:33}, _2: &Column) -> TextCell {
    debug c => _2;
    debug self => (*((*_1).0: &&output::table::Table<'_>));
    debug file => (*((*_1).1: &&fs::file::File<'_>));
    debug xattrs => (*((*_1).2: &bool));
    let mut _0: output::cell::TextCell;
    let mut _3: output::table::Column;
    let mut _4: bool;
    let mut _5: &&output::table::Table<'_>;
    let mut _6: &output::table::Table<'_>;
    let mut _7: &&fs::file::File<'_>;
    let mut _8: &fs::file::File<'_>;
    let mut _9: &bool;

    bb0: {
        _5 = deref_copy ((*_1).0: &&output::table::Table<'_>);
        _6 = deref_copy (*_5);
        _7 = deref_copy ((*_1).1: &&fs::file::File<'_>);
        _8 = deref_copy (*_7);
        _3 = (*_2);
        _9 = deref_copy ((*_1).2: &bool);
        _4 = (*_9);
        _0 = Table::<'_>::display(_6, _8, move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::add_widths(_1: &mut Table<'_>, _2: &table::Row) -> () {
    debug self => _1;
    debug row => _2;
    let mut _0: ();
    let mut _3: &mut output::table::TableWidths;

    bb0: {
        _3 = &mut ((*_1).3: output::table::TableWidths);
        _0 = TableWidths::add_widths(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::permissions_plus(_1: &Table<'_>, _2: &file::File<'_>, _3: bool) -> PermissionsPlus {
    debug self => _1;
    debug file => _2;
    debug xattrs => _3;
    let mut _0: fs::fields::PermissionsPlus;
    let mut _4: fs::fields::Type;
    let mut _5: fs::fields::Permissions;

    bb0: {
        _4 = file::File::<'_>::type_char(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = file::File::<'_>::permissions(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = PermissionsPlus { file_type: move _4, permissions: move _5, xattrs: _3 };
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::octal_permissions(_1: &Table<'_>, _2: &file::File<'_>) -> OctalPermissions {
    debug self => _1;
    debug file => _2;
    let mut _0: fs::fields::OctalPermissions;
    let mut _3: fs::fields::Permissions;

    bb0: {
        _3 = file::File::<'_>::permissions(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = OctalPermissions { permissions: move _3 };
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::display(_1: &Table<'_>, _2: &file::File<'_>, _3: Column, _4: bool) -> TextCell {
    debug self => _1;
    debug file => _2;
    debug column => _3;
    debug xattrs => _4;
    let mut _0: output::cell::TextCell;
    let mut _5: isize;
    let mut _6: isize;
    let mut _7: &fs::fields::PermissionsPlus;
    let _8: fs::fields::PermissionsPlus;
    let mut _9: fs::fields::Size;
    let mut _10: output::table::SizeFormat;
    let _11: &locale::Numeric;
    let mut _12: &fs::fields::Links;
    let _13: fs::fields::Links;
    let _14: &locale::Numeric;
    let mut _15: fs::fields::Inode;
    let mut _16: ansi_term::Style;
    let mut _17: &fs::fields::Blocks;
    let _18: fs::fields::Blocks;
    let mut _19: fs::fields::User;
    let _20: &users::UsersCache;
    let mut _21: &std::sync::MutexGuard<'_, users::UsersCache>;
    let _22: std::sync::MutexGuard<'_, users::UsersCache>;
    let mut _23: output::table::UserFormat;
    let mut _24: fs::fields::Group;
    let _25: &users::UsersCache;
    let mut _26: &std::sync::MutexGuard<'_, users::UsersCache>;
    let _27: std::sync::MutexGuard<'_, users::UsersCache>;
    let mut _28: output::table::UserFormat;
    let mut _29: fs::fields::Git;
    let mut _30: &dyn output::render::git::Colours;
    let mut _31: &fs::fields::OctalPermissions;
    let _32: fs::fields::OctalPermissions;
    let mut _33: ansi_term::Style;
    let mut _34: std::option::Option<std::time::SystemTime>;
    let mut _35: ansi_term::Style;
    let _36: &std::option::Option<datetime::TimeZone>;
    let mut _37: output::time::TimeFormat;
    let mut _38: std::option::Option<std::time::SystemTime>;
    let mut _39: ansi_term::Style;
    let _40: &std::option::Option<datetime::TimeZone>;
    let mut _41: output::time::TimeFormat;
    let mut _42: std::option::Option<std::time::SystemTime>;
    let mut _43: ansi_term::Style;
    let _44: &std::option::Option<datetime::TimeZone>;
    let mut _45: output::time::TimeFormat;
    let mut _46: std::option::Option<std::time::SystemTime>;
    let mut _47: ansi_term::Style;
    let _48: &std::option::Option<datetime::TimeZone>;
    let mut _49: output::time::TimeFormat;
    let mut _50: &theme::Theme;
    let mut _51: &theme::Theme;
    let mut _52: &output::table::Environment;
    let mut _53: &theme::Theme;
    let mut _54: &output::table::Environment;
    let mut _55: &theme::Theme;
    let mut _56: &theme::Theme;
    let mut _57: &theme::Theme;
    let mut _58: &output::table::Environment;
    let mut _59: &theme::Theme;
    let mut _60: &output::table::Environment;
    let mut _61: &theme::Theme;
    let mut _62: &theme::Theme;
    let mut _63: &theme::Theme;
    let mut _64: &output::table::Environment;
    let mut _65: &theme::Theme;
    let mut _66: &output::table::Environment;
    let mut _67: &theme::Theme;
    let mut _68: &output::table::Environment;
    let mut _69: &theme::Theme;
    let mut _70: &output::table::Environment;

    bb0: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb6, 2: bb1, 3: bb12, 4: bb14, 5: bb19, 6: bb8, 7: bb10, 8: bb24, 9: bb26, otherwise: bb3];
    }

    bb1: {
        _5 = discriminant(((_3 as Timestamp).0: output::table::TimeType));
        switchInt(move _5) -> [0: bb28, 1: bb30, 2: bb2, 3: bb32, otherwise: bb3];
    }

    bb2: {
        _46 = file::File::<'_>::accessed_time(_2) -> [return: bb34, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _8 = Table::<'_>::permissions_plus(_1, _2, _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = &_8;
        _50 = deref_copy ((*_1).1: &theme::Theme);
        _0 = permissions::<impl PermissionsPlus>::render::<Theme>(move _7, _50) -> [return: bb35, unwind continue];
    }

    bb6: {
        _9 = file::File::<'_>::size(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _51 = deref_copy ((*_1).1: &theme::Theme);
        _10 = ((*_1).5: output::table::SizeFormat);
        _52 = deref_copy ((*_1).2: &output::table::Environment);
        _11 = &((*_52).0: locale::Numeric);
        _0 = size::<impl fields::Size>::render::<Theme>(move _9, _51, move _10, _11) -> [return: bb35, unwind continue];
    }

    bb8: {
        _13 = file::File::<'_>::links(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = &_13;
        _53 = deref_copy ((*_1).1: &theme::Theme);
        _54 = deref_copy ((*_1).2: &output::table::Environment);
        _14 = &((*_54).0: locale::Numeric);
        _0 = links::<impl fields::Links>::render::<Theme>(move _12, _53, _14) -> [return: bb35, unwind continue];
    }

    bb10: {
        _15 = file::File::<'_>::inode(_2) -> [return: bb11, unwind continue];
    }

    bb11: {
        _55 = deref_copy ((*_1).1: &theme::Theme);
        _16 = (((*_55).0: theme::ui_styles::UiStyles).9: ansi_term::Style);
        _0 = inode::<impl Inode>::render(move _15, move _16) -> [return: bb35, unwind continue];
    }

    bb12: {
        _18 = file::File::<'_>::blocks(_2) -> [return: bb13, unwind continue];
    }

    bb13: {
        _17 = &_18;
        _56 = deref_copy ((*_1).1: &theme::Theme);
        _0 = blocks::<impl Blocks>::render::<Theme>(move _17, _56) -> [return: bb35, unwind continue];
    }

    bb14: {
        _19 = file::File::<'_>::user(_2) -> [return: bb15, unwind continue];
    }

    bb15: {
        _57 = deref_copy ((*_1).1: &theme::Theme);
        _58 = deref_copy ((*_1).2: &output::table::Environment);
        _22 = Environment::lock_users(_58) -> [return: bb16, unwind continue];
    }

    bb16: {
        _21 = &_22;
        _20 = <MutexGuard<'_, UsersCache> as Deref>::deref(move _21) -> [return: bb17, unwind: bb37];
    }

    bb17: {
        _23 = ((*_1).6: output::table::UserFormat);
        _0 = users::<impl fields::User>::render::<Theme, UsersCache>(move _19, _57, _20, move _23) -> [return: bb18, unwind: bb37];
    }

    bb18: {
        drop(_22) -> [return: bb35, unwind continue];
    }

    bb19: {
        _24 = file::File::<'_>::group(_2) -> [return: bb20, unwind continue];
    }

    bb20: {
        _59 = deref_copy ((*_1).1: &theme::Theme);
        _60 = deref_copy ((*_1).2: &output::table::Environment);
        _27 = Environment::lock_users(_60) -> [return: bb21, unwind continue];
    }

    bb21: {
        _26 = &_27;
        _25 = <MutexGuard<'_, UsersCache> as Deref>::deref(move _26) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        _28 = ((*_1).6: output::table::UserFormat);
        _0 = groups::<impl fields::Group>::render::<Theme, UsersCache>(move _24, _59, _25, move _28) -> [return: bb23, unwind: bb36];
    }

    bb23: {
        drop(_27) -> [return: bb35, unwind continue];
    }

    bb24: {
        _29 = Table::<'_>::git_status(_1, _2) -> [return: bb25, unwind continue];
    }

    bb25: {
        _61 = deref_copy ((*_1).1: &theme::Theme);
        _30 = _61 as &dyn output::render::git::Colours (PointerCoercion(Unsize));
        _0 = render::git::<impl fields::Git>::render(move _29, move _30) -> [return: bb35, unwind continue];
    }

    bb26: {
        _32 = Table::<'_>::octal_permissions(_1, _2) -> [return: bb27, unwind continue];
    }

    bb27: {
        _31 = &_32;
        _62 = deref_copy ((*_1).1: &theme::Theme);
        _33 = (((*_62).0: theme::ui_styles::UiStyles).12: ansi_term::Style);
        _0 = octal::<impl OctalPermissions>::render(move _31, move _33) -> [return: bb35, unwind continue];
    }

    bb28: {
        _34 = file::File::<'_>::modified_time(_2) -> [return: bb29, unwind continue];
    }

    bb29: {
        _63 = deref_copy ((*_1).1: &theme::Theme);
        _35 = (((*_63).0: theme::ui_styles::UiStyles).8: ansi_term::Style);
        _64 = deref_copy ((*_1).2: &output::table::Environment);
        _36 = &((*_64).1: std::option::Option<datetime::TimeZone>);
        _37 = ((*_1).4: output::time::TimeFormat);
        _0 = <Option<SystemTime> as times::Render>::render(move _34, move _35, _36, move _37) -> [return: bb35, unwind continue];
    }

    bb30: {
        _38 = file::File::<'_>::changed_time(_2) -> [return: bb31, unwind continue];
    }

    bb31: {
        _65 = deref_copy ((*_1).1: &theme::Theme);
        _39 = (((*_65).0: theme::ui_styles::UiStyles).8: ansi_term::Style);
        _66 = deref_copy ((*_1).2: &output::table::Environment);
        _40 = &((*_66).1: std::option::Option<datetime::TimeZone>);
        _41 = ((*_1).4: output::time::TimeFormat);
        _0 = <Option<SystemTime> as times::Render>::render(move _38, move _39, _40, move _41) -> [return: bb35, unwind continue];
    }

    bb32: {
        _42 = file::File::<'_>::created_time(_2) -> [return: bb33, unwind continue];
    }

    bb33: {
        _67 = deref_copy ((*_1).1: &theme::Theme);
        _43 = (((*_67).0: theme::ui_styles::UiStyles).8: ansi_term::Style);
        _68 = deref_copy ((*_1).2: &output::table::Environment);
        _44 = &((*_68).1: std::option::Option<datetime::TimeZone>);
        _45 = ((*_1).4: output::time::TimeFormat);
        _0 = <Option<SystemTime> as times::Render>::render(move _42, move _43, _44, move _45) -> [return: bb35, unwind continue];
    }

    bb34: {
        _69 = deref_copy ((*_1).1: &theme::Theme);
        _47 = (((*_69).0: theme::ui_styles::UiStyles).8: ansi_term::Style);
        _70 = deref_copy ((*_1).2: &output::table::Environment);
        _48 = &((*_70).1: std::option::Option<datetime::TimeZone>);
        _49 = ((*_1).4: output::time::TimeFormat);
        _0 = <Option<SystemTime> as times::Render>::render(move _46, move _47, _48, move _49) -> [return: bb35, unwind continue];
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_27) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_22) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        resume;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::git_status(_1: &Table<'_>, _2: &file::File<'_>) -> fields::Git {
    debug self => _1;
    debug file => _2;
    let mut _0: fs::fields::Git;
    let _3: log::Level;
    let mut _4: bool;
    let mut _5: &log::Level;
    let mut _6: bool;
    let mut _7: &log::Level;
    let mut _8: &log::LevelFilter;
    let _9: log::LevelFilter;
    let _10: ();
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 1];
    let _15: [core::fmt::rt::Argument<'_>; 1];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &std::path::PathBuf;
    let mut _18: log::Level;
    let mut _19: std::option::Option<fs::fields::Git>;
    let mut _20: std::option::Option<&fs::feature::git::GitCache>;
    let mut _21: {closure@src/output/table.rs:449:18: 449:21};
    let mut _22: &&fs::file::File<'_>;
    scope 1 {
        debug lvl => _3;
        let mut _23: &(&str, &str, &str, u32);
        let mut _24: &[&str; 1];
        let mut _25: &log::LevelFilter;
    }

    bb0: {
        _3 = log::Level::Debug;
        _5 = &_3;
        _25 = const _;
        _4 = <Level as PartialOrd<LevelFilter>>::le(move _5, _25) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _7 = &_3;
        _9 = max_level() -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = &_9;
        _6 = <Level as PartialOrd<LevelFilter>>::le(move _7, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _6) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _24 = const _;
        _12 = _24 as &[&str] (PointerCoercion(Unsize));
        _17 = &((*_2).2: std::path::PathBuf);
        _16 = core::fmt::rt::Argument::<'_>::new_debug::<PathBuf>(_17) -> [return: bb6, unwind continue];
    }

    bb6: {
        _15 = [move _16];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _11 = std::fmt::Arguments::<'_>::new_v1(move _12, move _13) -> [return: bb7, unwind continue];
    }

    bb7: {
        _18 = _3;
        _23 = const _;
        _10 = __private_api_log(move _11, move _18, _23) -> [return: bb8, unwind continue];
    }

    bb8: {
        _20 = ((*_1).7: std::option::Option<&fs::feature::git::GitCache>);
        _22 = &_2;
        _21 = {closure@src/output/table.rs:449:18: 449:21} { file: move _22 };
        _19 = Option::<&GitCache>::map::<fields::Git, {closure@src/output/table.rs:449:18: 449:21}>(move _20, move _21) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = Option::<fields::Git>::unwrap_or_default(move _19) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

promoted[0] in table::<impl at src/output/table.rs:344:1: 344:23>::git_status: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::output::table";
        _2 = &(*_3);
        _1 = (move _2, const "exa::output::table", const "src/output/table.rs", const 446_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in table::<impl at src/output/table.rs:344:1: 344:23>::git_status: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Getting Git status for file "];
        _0 = &_1;
        return;
    }
}

promoted[2] in table::<impl at src/output/table.rs:344:1: 344:23>::git_status: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::git_status::{closure#0}(_1: {closure@src/output/table.rs:449:18: 449:21}, _2: &GitCache) -> fields::Git {
    debug g => _2;
    debug file => (*(_1.0: &&fs::file::File<'_>));
    let mut _0: fs::fields::Git;
    let _3: &std::path::Path;
    let _4: &std::path::PathBuf;
    let mut _5: bool;
    let mut _6: &&fs::file::File<'_>;
    let mut _7: &fs::file::File<'_>;
    let mut _8: &&fs::file::File<'_>;
    let mut _9: &fs::file::File<'_>;

    bb0: {
        _6 = deref_copy (_1.0: &&fs::file::File<'_>);
        _7 = deref_copy (*_6);
        _4 = &((*_7).2: std::path::PathBuf);
        _3 = <PathBuf as Deref>::deref(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = deref_copy (_1.0: &&fs::file::File<'_>);
        _9 = deref_copy (*_8);
        _5 = file::File::<'_>::is_directory(_9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = GitCache::get(_2, _3, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn table::<impl at src/output/table.rs:344:1: 344:23>::render(_1: &Table<'_>, _2: table::Row) -> TextCell {
    debug self => _1;
    debug row => _2;
    let mut _0: output::cell::TextCell;
    let mut _3: output::cell::TextCell;
    let mut _5: std::iter::Zip<std::vec::IntoIter<output::cell::TextCell>, std::slice::Iter<'_, usize>>;
    let mut _6: std::vec::IntoIter<output::cell::TextCell>;
    let mut _7: std::vec::Vec<output::cell::TextCell>;
    let mut _8: std::slice::Iter<'_, usize>;
    let _9: &[usize];
    let mut _10: &output::table::TableWidths;
    let mut _11: std::iter::Enumerate<std::iter::Zip<std::vec::IntoIter<output::cell::TextCell>, std::slice::Iter<'_, usize>>>;
    let mut _13: std::option::Option<(usize, (output::cell::TextCell, &usize))>;
    let mut _14: &mut std::iter::Enumerate<std::iter::Zip<std::vec::IntoIter<output::cell::TextCell>, std::slice::Iter<'_, usize>>>;
    let mut _15: isize;
    let mut _20: usize;
    let mut _21: &usize;
    let mut _22: &output::cell::DisplayWidth;
    let mut _23: output::table::Alignment;
    let mut _24: output::table::Column;
    let mut _25: &output::table::Column;
    let mut _26: &std::vec::Vec<output::table::Column>;
    let mut _27: isize;
    let _28: ();
    let mut _29: &mut output::cell::TextCell;
    let mut _30: output::cell::TextCell;
    let _31: ();
    let mut _32: &mut output::cell::TextCell;
    let _33: ();
    let mut _34: &mut output::cell::TextCell;
    let _35: ();
    let mut _36: &mut output::cell::TextCell;
    let mut _37: output::cell::TextCell;
    let _38: ();
    let mut _39: &mut output::cell::TextCell;
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    scope 1 {
        debug cell => _3;
        let _4: std::iter::Enumerate<std::iter::Zip<std::vec::IntoIter<output::cell::TextCell>, std::slice::Iter<'_, usize>>>;
        scope 2 {
            debug iter => _4;
            let mut _12: std::iter::Enumerate<std::iter::Zip<std::vec::IntoIter<output::cell::TextCell>, std::slice::Iter<'_, usize>>>;
            scope 3 {
                debug iter => _12;
                let _16: usize;
                let _17: output::cell::TextCell;
                let _18: &usize;
                scope 4 {
                    debug n => _16;
                    debug this_cell => _17;
                    debug width => _18;
                    let _19: usize;
                    scope 5 {
                        debug padding => _19;
                    }
                }
            }
        }
    }

    bb0: {
        _41 = const false;
        _40 = const false;
        _42 = const false;
        _42 = const true;
        _3 = <TextCell as Default>::default() -> [return: bb1, unwind: bb32];
    }

    bb1: {
        _42 = const false;
        _7 = move (_2.0: std::vec::Vec<output::cell::TextCell>);
        _6 = <Vec<TextCell> as IntoIterator>::into_iter(move _7) -> [return: bb2, unwind: bb25];
    }

    bb2: {
        _41 = const true;
        _10 = &((*_1).3: output::table::TableWidths);
        _9 = <TableWidths as Deref>::deref(move _10) -> [return: bb3, unwind: bb30];
    }

    bb3: {
        _8 = core::slice::<impl [usize]>::iter(_9) -> [return: bb4, unwind: bb30];
    }

    bb4: {
        _41 = const false;
        _5 = <std::vec::IntoIter<TextCell> as Iterator>::zip::<std::slice::Iter<'_, usize>>(move _6, move _8) -> [return: bb5, unwind: bb30];
    }

    bb5: {
        _41 = const false;
        _4 = <Zip<std::vec::IntoIter<TextCell>, std::slice::Iter<'_, usize>> as Iterator>::enumerate(move _5) -> [return: bb6, unwind: bb25];
    }

    bb6: {
        _11 = <Enumerate<Zip<std::vec::IntoIter<TextCell>, std::slice::Iter<'_, usize>>> as IntoIterator>::into_iter(move _4) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _12 = move _11;
        goto -> bb8;
    }

    bb8: {
        _14 = &mut _12;
        _13 = <Enumerate<Zip<std::vec::IntoIter<TextCell>, std::slice::Iter<'_, usize>>> as Iterator>::next(_14) -> [return: bb9, unwind: bb24];
    }

    bb9: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _40 = const true;
        _17 = move ((((_13 as Some).0: (usize, (output::cell::TextCell, &usize))).1: (output::cell::TextCell, &usize)).0: output::cell::TextCell);
        _18 = ((((_13 as Some).0: (usize, (output::cell::TextCell, &usize))).1: (output::cell::TextCell, &usize)).1: &usize);
        _16 = (((_13 as Some).0: (usize, (output::cell::TextCell, &usize))).0: usize);
        _22 = &(_17.1: output::cell::DisplayWidth);
        _21 = <DisplayWidth as Deref>::deref(move _22) -> [return: bb13, unwind: bb28];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        drop(_12) -> [return: bb23, unwind: bb25];
    }

    bb13: {
        _20 = (*_21);
        _19 = <&usize as Sub<usize>>::sub(_18, move _20) -> [return: bb14, unwind: bb28];
    }

    bb14: {
        _26 = &((*_1).0: std::vec::Vec<output::table::Column>);
        _25 = <Vec<Column> as std::ops::Index<usize>>::index(move _26, _16) -> [return: bb15, unwind: bb28];
    }

    bb15: {
        _24 = (*_25);
        _23 = Column::alignment(move _24) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _27 = discriminant(_23);
        switchInt(move _27) -> [0: bb18, 1: bb17, otherwise: bb11];
    }

    bb17: {
        _34 = &mut _3;
        _33 = TextCell::add_spaces(move _34, _19) -> [return: bb20, unwind: bb28];
    }

    bb18: {
        _29 = &mut _3;
        _40 = const false;
        _30 = move _17;
        _28 = TextCell::append(move _29, move _30) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _32 = &mut _3;
        _31 = TextCell::add_spaces(move _32, _19) -> [return: bb33, unwind: bb28];
    }

    bb20: {
        _36 = &mut _3;
        _40 = const false;
        _37 = move _17;
        _35 = TextCell::append(move _36, move _37) -> [return: bb34, unwind: bb28];
    }

    bb21: {
        _39 = &mut _3;
        _38 = TextCell::add_spaces(move _39, const 1_usize) -> [return: bb22, unwind: bb28];
    }

    bb22: {
        _40 = const false;
        goto -> bb8;
    }

    bb23: {
        _0 = move _3;
        return;
    }

    bb24 (cleanup): {
        drop(_12) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_3) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        drop(_17) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_40) -> [0: bb24, otherwise: bb27];
    }

    bb29 (cleanup): {
        drop(_6) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_41) -> [0: bb25, otherwise: bb29];
    }

    bb31 (cleanup): {
        drop((_2.0: std::vec::Vec<output::cell::TextCell>)) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        switchInt(_42) -> [0: bb26, otherwise: bb31];
    }

    bb33: {
        goto -> bb21;
    }

    bb34: {
        goto -> bb21;
    }
}

fn table::<impl at src/output/table.rs:484:1: 484:27>::deref(_1: &TableWidths) -> &[usize] {
    debug self => _1;
    let mut _0: &[usize];
    let _2: &std::vec::Vec<usize>;

    bb0: {
        _2 = &((*_1).0: std::vec::Vec<usize>);
        _0 = <Vec<usize> as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn table::<impl at src/output/table.rs:492:1: 492:17>::zero(_1: usize) -> TableWidths {
    debug count => _1;
    let mut _0: output::table::TableWidths;
    let mut _2: std::vec::Vec<usize>;

    bb0: {
        _2 = from_elem::<usize>(const 0_usize, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = TableWidths(move _2);
        return;
    }
}

fn table::<impl at src/output/table.rs:492:1: 492:17>::add_widths(_1: &mut TableWidths, _2: &table::Row) -> () {
    debug self => _1;
    debug row => _2;
    let mut _0: ();
    let mut _3: std::iter::Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, output::cell::TextCell>>;
    let mut _4: std::iter::Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, output::cell::TextCell>>;
    let mut _5: std::slice::IterMut<'_, usize>;
    let mut _6: &mut [usize];
    let mut _7: &mut std::vec::Vec<usize>;
    let mut _8: std::slice::Iter<'_, output::cell::TextCell>;
    let _9: &[output::cell::TextCell];
    let mut _10: &std::vec::Vec<output::cell::TextCell>;
    let mut _11: std::iter::Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, output::cell::TextCell>>;
    let mut _12: std::option::Option<(&mut usize, &output::cell::TextCell)>;
    let mut _13: &mut std::iter::Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, output::cell::TextCell>>;
    let mut _14: isize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: &usize;
    let mut _21: &output::cell::DisplayWidth;
    scope 1 {
        debug iter => _11;
        let _15: &mut usize;
        let _16: &output::cell::TextCell;
        scope 2 {
            debug old_width => _15;
            debug cell => _16;
        }
    }

    bb0: {
        _7 = &mut ((*_1).0: std::vec::Vec<usize>);
        _6 = <Vec<usize> as DerefMut>::deref_mut(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = core::slice::<impl [usize]>::iter_mut(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &((*_2).0: std::vec::Vec<output::cell::TextCell>);
        _9 = <Vec<TextCell> as Deref>::deref(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = core::slice::<impl [TextCell]>::iter(_9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::slice::IterMut<'_, usize> as Iterator>::zip::<std::slice::Iter<'_, TextCell>>(move _5, move _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, TextCell>> as IntoIterator>::into_iter(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = move _3;
        goto -> bb7;
    }

    bb7: {
        _13 = &mut _11;
        _12 = <Zip<std::slice::IterMut<'_, usize>, std::slice::Iter<'_, TextCell>> as Iterator>::next(_13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _15 = move (((_12 as Some).0: (&mut usize, &output::cell::TextCell)).0: &mut usize);
        _16 = (((_12 as Some).0: (&mut usize, &output::cell::TextCell)).1: &output::cell::TextCell);
        _18 = (*_15);
        _21 = &((*_16).1: output::cell::DisplayWidth);
        _20 = <DisplayWidth as Deref>::deref(move _21) -> [return: bb12, unwind continue];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        return;
    }

    bb12: {
        _19 = (*_20);
        _17 = std::cmp::max::<usize>(move _18, move _19) -> [return: bb13, unwind continue];
    }

    bb13: {
        (*_15) = move _17;
        goto -> bb7;
    }
}

fn table::<impl at src/output/table.rs:492:1: 492:17>::total(_1: &TableWidths) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: usize;
    let mut _3: &std::vec::Vec<usize>;
    let mut _4: usize;
    let mut _5: std::slice::Iter<'_, usize>;
    let _6: &[usize];
    let mut _7: &std::vec::Vec<usize>;
    let mut _8: (usize, bool);

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<usize>);
        _2 = Vec::<usize>::len(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &((*_1).0: std::vec::Vec<usize>);
        _6 = <Vec<usize> as Deref>::deref(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = core::slice::<impl [usize]>::iter(_6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::slice::Iter<'_, usize> as Iterator>::sum::<usize>(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = CheckedAdd(_2, _4);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _2, move _4) -> [success: bb5, unwind continue];
    }

    bb5: {
        _0 = move (_8.0: usize);
        return;
    }
}

fn output::time::<impl at src/output/time.rs:28:10: 28:19>::eq(_1: &TimeFormat, _2: &TimeFormat) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn output::time::<impl at src/output/time.rs:28:21: 28:26>::fmt(_1: &TimeFormat, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "FullISO";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "DefaultFormat";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "ISOFormat";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "LongISO";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn output::time::<impl at src/output/time.rs:28:34: 28:39>::clone(_1: &TimeFormat) -> TimeFormat {
    debug self => _1;
    let mut _0: output::time::TimeFormat;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::time::<impl at src/output/time.rs:54:1: 54:16>::format_local(_1: TimeFormat, _2: SystemTime) -> String {
    debug self => _1;
    debug time => _2;
    let mut _0: std::string::String;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = full_local(_2) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = default_local(_2) -> [return: bb6, unwind continue];
    }

    bb4: {
        _0 = iso_local(_2) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = long_local(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn output::time::<impl at src/output/time.rs:54:1: 54:16>::format_zoned(_1: TimeFormat, _2: SystemTime, _3: &TimeZone) -> String {
    debug self => _1;
    debug time => _2;
    debug zone => _3;
    let mut _0: std::string::String;
    let mut _4: isize;

    bb0: {
        _4 = discriminant(_1);
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = full_zoned(_2, _3) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = default_zoned(_2, _3) -> [return: bb6, unwind continue];
    }

    bb4: {
        _0 = iso_zoned(_2, _3) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = long_zoned(_2, _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn default_local(_1: SystemTime) -> String {
    debug time => _1;
    let mut _0: std::string::String;
    let _2: datetime::LocalDateTime;
    let mut _3: i64;
    let _5: &datetime::LocalDateTime;
    let _6: &datetime::LocalDateTime;
    let _7: &locale::Time;
    let _8: &output::time::LOCALE;
    scope 1 {
        debug date => _2;
        let _4: &datetime::fmt::DateFormat<'_>;
        scope 2 {
            debug date_format => _4;
        }
    }

    bb0: {
        _3 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = LocalDateTime::at(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_2;
        _4 = get_dateformat(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &_2;
        _8 = const {alloc70: &LOCALE};
        _7 = <LOCALE as Deref>::deref(_8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = DateFormat::<'_>::format::<LocalDateTime>(_4, _6, _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

alloc70 (static: LOCALE, size: 0, align: 1) {}

fn default_zoned(_1: SystemTime, _2: &TimeZone) -> String {
    debug time => _1;
    debug zone => _2;
    let mut _0: std::string::String;
    let _3: datetime::LocalDateTime;
    let mut _4: datetime::LocalDateTime;
    let mut _5: i64;
    let _7: &datetime::LocalDateTime;
    let _8: &datetime::LocalDateTime;
    let _9: &locale::Time;
    let _10: &output::time::LOCALE;
    scope 1 {
        debug date => _3;
        let _6: &datetime::fmt::DateFormat<'_>;
        scope 2 {
            debug date_format => _6;
        }
    }

    bb0: {
        _5 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = LocalDateTime::at(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = TimeZone::to_zoned(_2, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &_3;
        _6 = get_dateformat(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = &_3;
        _10 = const {alloc70: &LOCALE};
        _9 = <LOCALE as Deref>::deref(_10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = DateFormat::<'_>::format::<LocalDateTime>(_6, _8, _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

alloc70 (static: LOCALE, size: 0, align: 1) {}

fn get_dateformat(_1: &LocalDateTime) -> &DateFormat<'_> {
    debug date => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _2: &datetime::fmt::DateFormat<'_>;
    let mut _3: (bool, usize);
    let mut _4: bool;
    let _5: &&datetime::LocalDateTime;
    let mut _6: usize;
    let mut _7: &usize;
    let _8: &output::time::MAXIMUM_MONTH_WIDTH;
    let _9: &datetime::fmt::DateFormat<'_>;
    let _10: &output::time::FOUR_WIDE_DATE_TIME;
    let _11: &datetime::fmt::DateFormat<'_>;
    let _12: &output::time::FIVE_WIDE_DATE_TIME;
    let _13: &datetime::fmt::DateFormat<'_>;
    let _14: &output::time::OTHER_WIDE_DATE_TIME;
    let _15: &datetime::fmt::DateFormat<'_>;
    let _16: &output::time::FOUR_WIDE_DATE_YEAR;
    let _17: &datetime::fmt::DateFormat<'_>;
    let _18: &output::time::FIVE_WIDE_DATE_YEAR;
    let _19: &datetime::fmt::DateFormat<'_>;
    let _20: &output::time::OTHER_WIDE_DATE_YEAR;
    let mut _21: &datetime::LocalDateTime;

    bb0: {
        _5 = &_1;
        _21 = deref_copy (*_5);
        _4 = is_recent(_21) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = const {alloc71: &MAXIMUM_MONTH_WIDTH};
        _7 = <MAXIMUM_MONTH_WIDTH as Deref>::deref(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = (*_7);
        _3 = (move _4, move _6);
        switchInt((_3.0: bool)) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        switchInt((_3.1: usize)) -> [4: bb6, 5: bb8, otherwise: bb10];
    }

    bb4: {
        switchInt((_3.1: usize)) -> [4: bb12, 5: bb14, otherwise: bb5];
    }

    bb5: {
        _20 = const {alloc77: &OTHER_WIDE_DATE_YEAR};
        _19 = <OTHER_WIDE_DATE_YEAR as Deref>::deref(_20) -> [return: bb16, unwind continue];
    }

    bb6: {
        _10 = const {alloc72: &FOUR_WIDE_DATE_TIME};
        _9 = <FOUR_WIDE_DATE_TIME as Deref>::deref(_10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _2 = _9;
        goto -> bb17;
    }

    bb8: {
        _12 = const {alloc73: &FIVE_WIDE_DATE_TIME};
        _11 = <FIVE_WIDE_DATE_TIME as Deref>::deref(_12) -> [return: bb9, unwind continue];
    }

    bb9: {
        _2 = _11;
        goto -> bb17;
    }

    bb10: {
        _14 = const {alloc74: &OTHER_WIDE_DATE_TIME};
        _13 = <OTHER_WIDE_DATE_TIME as Deref>::deref(_14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _2 = _13;
        goto -> bb17;
    }

    bb12: {
        _16 = const {alloc75: &FOUR_WIDE_DATE_YEAR};
        _15 = <FOUR_WIDE_DATE_YEAR as Deref>::deref(_16) -> [return: bb13, unwind continue];
    }

    bb13: {
        _2 = _15;
        goto -> bb17;
    }

    bb14: {
        _18 = const {alloc76: &FIVE_WIDE_DATE_YEAR};
        _17 = <FIVE_WIDE_DATE_YEAR as Deref>::deref(_18) -> [return: bb15, unwind continue];
    }

    bb15: {
        _2 = _17;
        goto -> bb17;
    }

    bb16: {
        _2 = _19;
        goto -> bb17;
    }

    bb17: {
        _0 = _2;
        return;
    }
}

alloc77 (static: OTHER_WIDE_DATE_YEAR, size: 0, align: 1) {}

alloc76 (static: FIVE_WIDE_DATE_YEAR, size: 0, align: 1) {}

alloc75 (static: FOUR_WIDE_DATE_YEAR, size: 0, align: 1) {}

alloc74 (static: OTHER_WIDE_DATE_TIME, size: 0, align: 1) {}

alloc73 (static: FIVE_WIDE_DATE_TIME, size: 0, align: 1) {}

alloc72 (static: FOUR_WIDE_DATE_TIME, size: 0, align: 1) {}

alloc71 (static: MAXIMUM_MONTH_WIDTH, size: 0, align: 1) {}

fn long_local(_1: SystemTime) -> String {
    debug time => _1;
    let mut _0: std::string::String;
    let _2: datetime::LocalDateTime;
    let mut _3: i64;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 5];
    let _8: [core::fmt::rt::Argument<'_>; 5];
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &i64;
    let _11: i64;
    let mut _12: &datetime::LocalDateTime;
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &usize;
    let _15: usize;
    let _16: datetime::Month;
    let mut _17: &datetime::LocalDateTime;
    let mut _18: isize;
    let mut _19: u8;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: core::fmt::rt::Argument<'_>;
    let _24: &i8;
    let _25: i8;
    let mut _26: &datetime::LocalDateTime;
    let mut _27: core::fmt::rt::Argument<'_>;
    let _28: &i8;
    let _29: i8;
    let mut _30: &datetime::LocalDateTime;
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &i8;
    let _33: i8;
    let mut _34: &datetime::LocalDateTime;
    let mut _35: &[core::fmt::rt::Placeholder];
    let _36: &[core::fmt::rt::Placeholder; 5];
    let _37: [core::fmt::rt::Placeholder; 5];
    let mut _38: core::fmt::rt::Placeholder;
    let mut _39: core::fmt::rt::Alignment;
    let mut _40: core::fmt::rt::Count;
    let mut _41: core::fmt::rt::Count;
    let mut _42: core::fmt::rt::Placeholder;
    let mut _43: core::fmt::rt::Alignment;
    let mut _44: core::fmt::rt::Count;
    let mut _45: core::fmt::rt::Count;
    let mut _46: core::fmt::rt::Placeholder;
    let mut _47: core::fmt::rt::Alignment;
    let mut _48: core::fmt::rt::Count;
    let mut _49: core::fmt::rt::Count;
    let mut _50: core::fmt::rt::Placeholder;
    let mut _51: core::fmt::rt::Alignment;
    let mut _52: core::fmt::rt::Count;
    let mut _53: core::fmt::rt::Count;
    let mut _54: core::fmt::rt::Placeholder;
    let mut _55: core::fmt::rt::Alignment;
    let mut _56: core::fmt::rt::Count;
    let mut _57: core::fmt::rt::Count;
    let mut _58: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug date => _2;
        let mut _59: &[&str; 5];
        scope 2 {
            debug res => _0;
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = LocalDateTime::at(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _59 = const _;
        _5 = _59 as &[&str] (PointerCoercion(Unsize));
        _12 = &_2;
        _11 = <LocalDateTime as DatePiece>::year(move _12) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _17 = &_2;
        _16 = <LocalDateTime as DatePiece>::month(move _17) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = discriminant(_16);
        _19 = _18 as u8 (IntToInt);
        _20 = Ge(_19, const 1_u8);
        _21 = Le(_19, const 12_u8);
        _22 = BitAnd(move _20, move _21);
        assume(move _22);
        _15 = move _18 as usize (IntToInt);
        _14 = &_15;
        _13 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _26 = &_2;
        _25 = <LocalDateTime as DatePiece>::day(move _26) -> [return: bb7, unwind continue];
    }

    bb7: {
        _24 = &_25;
        _23 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_24) -> [return: bb8, unwind continue];
    }

    bb8: {
        _30 = &_2;
        _29 = <LocalDateTime as TimePiece>::hour(move _30) -> [return: bb9, unwind continue];
    }

    bb9: {
        _28 = &_29;
        _27 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_28) -> [return: bb10, unwind continue];
    }

    bb10: {
        _34 = &_2;
        _33 = <LocalDateTime as TimePiece>::minute(move _34) -> [return: bb11, unwind continue];
    }

    bb11: {
        _32 = &_33;
        _31 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_32) -> [return: bb12, unwind continue];
    }

    bb12: {
        _8 = [move _9, move _13, move _23, move _27, move _31];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = core::fmt::rt::Alignment::Unknown;
        _40 = core::fmt::rt::Count::Implied;
        _41 = core::fmt::rt::Count::Is(const 4_usize);
        _38 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _39, const 8_u32, move _40, move _41) -> [return: bb13, unwind continue];
    }

    bb13: {
        _43 = core::fmt::rt::Alignment::Unknown;
        _44 = core::fmt::rt::Count::Implied;
        _45 = core::fmt::rt::Count::Is(const 2_usize);
        _42 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _43, const 8_u32, move _44, move _45) -> [return: bb14, unwind continue];
    }

    bb14: {
        _47 = core::fmt::rt::Alignment::Unknown;
        _48 = core::fmt::rt::Count::Implied;
        _49 = core::fmt::rt::Count::Is(const 2_usize);
        _46 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _47, const 8_u32, move _48, move _49) -> [return: bb15, unwind continue];
    }

    bb15: {
        _51 = core::fmt::rt::Alignment::Unknown;
        _52 = core::fmt::rt::Count::Implied;
        _53 = core::fmt::rt::Count::Is(const 2_usize);
        _50 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _51, const 8_u32, move _52, move _53) -> [return: bb16, unwind continue];
    }

    bb16: {
        _55 = core::fmt::rt::Alignment::Unknown;
        _56 = core::fmt::rt::Count::Implied;
        _57 = core::fmt::rt::Count::Is(const 2_usize);
        _54 = core::fmt::rt::Placeholder::new(const 4_usize, const ' ', move _55, const 8_u32, move _56, move _57) -> [return: bb17, unwind continue];
    }

    bb17: {
        _37 = [move _38, move _42, move _46, move _50, move _54];
        _36 = &_37;
        _35 = _36 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _58 = core::fmt::rt::UnsafeArg::new() -> [return: bb18, unwind continue];
    }

    bb18: {
        _4 = std::fmt::Arguments::<'_>::new_v1_formatted(move _5, move _6, move _35, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb19, unwind continue];
    }

    bb19: {
        _0 = format(move _4) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }
}

promoted[0] in long_local: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "", const "-", const "-", const " ", const ":"];
        _0 = &_1;
        return;
    }
}

fn long_zoned(_1: SystemTime, _2: &TimeZone) -> String {
    debug time => _1;
    debug zone => _2;
    let mut _0: std::string::String;
    let _3: datetime::LocalDateTime;
    let mut _4: datetime::LocalDateTime;
    let mut _5: i64;
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 5];
    let _10: [core::fmt::rt::Argument<'_>; 5];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &i64;
    let _13: i64;
    let mut _14: &datetime::LocalDateTime;
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &usize;
    let _17: usize;
    let _18: datetime::Month;
    let mut _19: &datetime::LocalDateTime;
    let mut _20: isize;
    let mut _21: u8;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &i8;
    let _27: i8;
    let mut _28: &datetime::LocalDateTime;
    let mut _29: core::fmt::rt::Argument<'_>;
    let _30: &i8;
    let _31: i8;
    let mut _32: &datetime::LocalDateTime;
    let mut _33: core::fmt::rt::Argument<'_>;
    let _34: &i8;
    let _35: i8;
    let mut _36: &datetime::LocalDateTime;
    let mut _37: &[core::fmt::rt::Placeholder];
    let _38: &[core::fmt::rt::Placeholder; 5];
    let _39: [core::fmt::rt::Placeholder; 5];
    let mut _40: core::fmt::rt::Placeholder;
    let mut _41: core::fmt::rt::Alignment;
    let mut _42: core::fmt::rt::Count;
    let mut _43: core::fmt::rt::Count;
    let mut _44: core::fmt::rt::Placeholder;
    let mut _45: core::fmt::rt::Alignment;
    let mut _46: core::fmt::rt::Count;
    let mut _47: core::fmt::rt::Count;
    let mut _48: core::fmt::rt::Placeholder;
    let mut _49: core::fmt::rt::Alignment;
    let mut _50: core::fmt::rt::Count;
    let mut _51: core::fmt::rt::Count;
    let mut _52: core::fmt::rt::Placeholder;
    let mut _53: core::fmt::rt::Alignment;
    let mut _54: core::fmt::rt::Count;
    let mut _55: core::fmt::rt::Count;
    let mut _56: core::fmt::rt::Placeholder;
    let mut _57: core::fmt::rt::Alignment;
    let mut _58: core::fmt::rt::Count;
    let mut _59: core::fmt::rt::Count;
    let mut _60: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug date => _3;
        let mut _61: &[&str; 5];
        scope 2 {
            debug res => _0;
        }
        scope 3 {
        }
    }

    bb0: {
        _5 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = LocalDateTime::at(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = TimeZone::to_zoned(_2, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _61 = const _;
        _7 = _61 as &[&str] (PointerCoercion(Unsize));
        _14 = &_3;
        _13 = <LocalDateTime as DatePiece>::year(move _14) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = &_13;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_12) -> [return: bb5, unwind continue];
    }

    bb5: {
        _19 = &_3;
        _18 = <LocalDateTime as DatePiece>::month(move _19) -> [return: bb6, unwind continue];
    }

    bb6: {
        _20 = discriminant(_18);
        _21 = _20 as u8 (IntToInt);
        _22 = Ge(_21, const 1_u8);
        _23 = Le(_21, const 12_u8);
        _24 = BitAnd(move _22, move _23);
        assume(move _24);
        _17 = move _20 as usize (IntToInt);
        _16 = &_17;
        _15 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_16) -> [return: bb7, unwind continue];
    }

    bb7: {
        _28 = &_3;
        _27 = <LocalDateTime as DatePiece>::day(move _28) -> [return: bb8, unwind continue];
    }

    bb8: {
        _26 = &_27;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_26) -> [return: bb9, unwind continue];
    }

    bb9: {
        _32 = &_3;
        _31 = <LocalDateTime as TimePiece>::hour(move _32) -> [return: bb10, unwind continue];
    }

    bb10: {
        _30 = &_31;
        _29 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_30) -> [return: bb11, unwind continue];
    }

    bb11: {
        _36 = &_3;
        _35 = <LocalDateTime as TimePiece>::minute(move _36) -> [return: bb12, unwind continue];
    }

    bb12: {
        _34 = &_35;
        _33 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_34) -> [return: bb13, unwind continue];
    }

    bb13: {
        _10 = [move _11, move _15, move _25, move _29, move _33];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _41 = core::fmt::rt::Alignment::Unknown;
        _42 = core::fmt::rt::Count::Implied;
        _43 = core::fmt::rt::Count::Is(const 4_usize);
        _40 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _41, const 8_u32, move _42, move _43) -> [return: bb14, unwind continue];
    }

    bb14: {
        _45 = core::fmt::rt::Alignment::Unknown;
        _46 = core::fmt::rt::Count::Implied;
        _47 = core::fmt::rt::Count::Is(const 2_usize);
        _44 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _45, const 8_u32, move _46, move _47) -> [return: bb15, unwind continue];
    }

    bb15: {
        _49 = core::fmt::rt::Alignment::Unknown;
        _50 = core::fmt::rt::Count::Implied;
        _51 = core::fmt::rt::Count::Is(const 2_usize);
        _48 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _49, const 8_u32, move _50, move _51) -> [return: bb16, unwind continue];
    }

    bb16: {
        _53 = core::fmt::rt::Alignment::Unknown;
        _54 = core::fmt::rt::Count::Implied;
        _55 = core::fmt::rt::Count::Is(const 2_usize);
        _52 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _53, const 8_u32, move _54, move _55) -> [return: bb17, unwind continue];
    }

    bb17: {
        _57 = core::fmt::rt::Alignment::Unknown;
        _58 = core::fmt::rt::Count::Implied;
        _59 = core::fmt::rt::Count::Is(const 2_usize);
        _56 = core::fmt::rt::Placeholder::new(const 4_usize, const ' ', move _57, const 8_u32, move _58, move _59) -> [return: bb18, unwind continue];
    }

    bb18: {
        _39 = [move _40, move _44, move _48, move _52, move _56];
        _38 = &_39;
        _37 = _38 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _60 = core::fmt::rt::UnsafeArg::new() -> [return: bb19, unwind continue];
    }

    bb19: {
        _6 = std::fmt::Arguments::<'_>::new_v1_formatted(move _7, move _8, move _37, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb20, unwind continue];
    }

    bb20: {
        _0 = format(move _6) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }
}

promoted[0] in long_zoned: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "", const "-", const "-", const " ", const ":"];
        _0 = &_1;
        return;
    }
}

fn full_local(_1: SystemTime) -> String {
    debug time => _1;
    let mut _0: std::string::String;
    let _2: datetime::LocalDateTime;
    let mut _3: i64;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 7];
    let _8: [core::fmt::rt::Argument<'_>; 7];
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &i64;
    let _11: i64;
    let mut _12: &datetime::LocalDateTime;
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &usize;
    let _15: usize;
    let _16: datetime::Month;
    let mut _17: &datetime::LocalDateTime;
    let mut _18: isize;
    let mut _19: u8;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: core::fmt::rt::Argument<'_>;
    let _24: &i8;
    let _25: i8;
    let mut _26: &datetime::LocalDateTime;
    let mut _27: core::fmt::rt::Argument<'_>;
    let _28: &i8;
    let _29: i8;
    let mut _30: &datetime::LocalDateTime;
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &i8;
    let _33: i8;
    let mut _34: &datetime::LocalDateTime;
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &i8;
    let _37: i8;
    let mut _38: &datetime::LocalDateTime;
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &u32;
    let _41: u32;
    let mut _42: &[core::fmt::rt::Placeholder];
    let _43: &[core::fmt::rt::Placeholder; 7];
    let _44: [core::fmt::rt::Placeholder; 7];
    let mut _45: core::fmt::rt::Placeholder;
    let mut _46: core::fmt::rt::Alignment;
    let mut _47: core::fmt::rt::Count;
    let mut _48: core::fmt::rt::Count;
    let mut _49: core::fmt::rt::Placeholder;
    let mut _50: core::fmt::rt::Alignment;
    let mut _51: core::fmt::rt::Count;
    let mut _52: core::fmt::rt::Count;
    let mut _53: core::fmt::rt::Placeholder;
    let mut _54: core::fmt::rt::Alignment;
    let mut _55: core::fmt::rt::Count;
    let mut _56: core::fmt::rt::Count;
    let mut _57: core::fmt::rt::Placeholder;
    let mut _58: core::fmt::rt::Alignment;
    let mut _59: core::fmt::rt::Count;
    let mut _60: core::fmt::rt::Count;
    let mut _61: core::fmt::rt::Placeholder;
    let mut _62: core::fmt::rt::Alignment;
    let mut _63: core::fmt::rt::Count;
    let mut _64: core::fmt::rt::Count;
    let mut _65: core::fmt::rt::Placeholder;
    let mut _66: core::fmt::rt::Alignment;
    let mut _67: core::fmt::rt::Count;
    let mut _68: core::fmt::rt::Count;
    let mut _69: core::fmt::rt::Placeholder;
    let mut _70: core::fmt::rt::Alignment;
    let mut _71: core::fmt::rt::Count;
    let mut _72: core::fmt::rt::Count;
    let mut _73: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug date => _2;
        let mut _74: &[&str; 7];
        scope 2 {
            debug res => _0;
        }
        scope 3 {
        }
    }

    bb0: {
        _3 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = LocalDateTime::at(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _74 = const _;
        _5 = _74 as &[&str] (PointerCoercion(Unsize));
        _12 = &_2;
        _11 = <LocalDateTime as DatePiece>::year(move _12) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _17 = &_2;
        _16 = <LocalDateTime as DatePiece>::month(move _17) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = discriminant(_16);
        _19 = _18 as u8 (IntToInt);
        _20 = Ge(_19, const 1_u8);
        _21 = Le(_19, const 12_u8);
        _22 = BitAnd(move _20, move _21);
        assume(move _22);
        _15 = move _18 as usize (IntToInt);
        _14 = &_15;
        _13 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _26 = &_2;
        _25 = <LocalDateTime as DatePiece>::day(move _26) -> [return: bb7, unwind continue];
    }

    bb7: {
        _24 = &_25;
        _23 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_24) -> [return: bb8, unwind continue];
    }

    bb8: {
        _30 = &_2;
        _29 = <LocalDateTime as TimePiece>::hour(move _30) -> [return: bb9, unwind continue];
    }

    bb9: {
        _28 = &_29;
        _27 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_28) -> [return: bb10, unwind continue];
    }

    bb10: {
        _34 = &_2;
        _33 = <LocalDateTime as TimePiece>::minute(move _34) -> [return: bb11, unwind continue];
    }

    bb11: {
        _32 = &_33;
        _31 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_32) -> [return: bb12, unwind continue];
    }

    bb12: {
        _38 = &_2;
        _37 = <LocalDateTime as TimePiece>::second(move _38) -> [return: bb13, unwind continue];
    }

    bb13: {
        _36 = &_37;
        _35 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_36) -> [return: bb14, unwind continue];
    }

    bb14: {
        _41 = systemtime_nanos(_1) -> [return: bb15, unwind continue];
    }

    bb15: {
        _40 = &_41;
        _39 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_40) -> [return: bb16, unwind continue];
    }

    bb16: {
        _8 = [move _9, move _13, move _23, move _27, move _31, move _35, move _39];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _46 = core::fmt::rt::Alignment::Unknown;
        _47 = core::fmt::rt::Count::Implied;
        _48 = core::fmt::rt::Count::Is(const 4_usize);
        _45 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _46, const 8_u32, move _47, move _48) -> [return: bb17, unwind continue];
    }

    bb17: {
        _50 = core::fmt::rt::Alignment::Unknown;
        _51 = core::fmt::rt::Count::Implied;
        _52 = core::fmt::rt::Count::Is(const 2_usize);
        _49 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _50, const 8_u32, move _51, move _52) -> [return: bb18, unwind continue];
    }

    bb18: {
        _54 = core::fmt::rt::Alignment::Unknown;
        _55 = core::fmt::rt::Count::Implied;
        _56 = core::fmt::rt::Count::Is(const 2_usize);
        _53 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _54, const 8_u32, move _55, move _56) -> [return: bb19, unwind continue];
    }

    bb19: {
        _58 = core::fmt::rt::Alignment::Unknown;
        _59 = core::fmt::rt::Count::Implied;
        _60 = core::fmt::rt::Count::Is(const 2_usize);
        _57 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _58, const 8_u32, move _59, move _60) -> [return: bb20, unwind continue];
    }

    bb20: {
        _62 = core::fmt::rt::Alignment::Unknown;
        _63 = core::fmt::rt::Count::Implied;
        _64 = core::fmt::rt::Count::Is(const 2_usize);
        _61 = core::fmt::rt::Placeholder::new(const 4_usize, const ' ', move _62, const 8_u32, move _63, move _64) -> [return: bb21, unwind continue];
    }

    bb21: {
        _66 = core::fmt::rt::Alignment::Unknown;
        _67 = core::fmt::rt::Count::Implied;
        _68 = core::fmt::rt::Count::Is(const 2_usize);
        _65 = core::fmt::rt::Placeholder::new(const 5_usize, const ' ', move _66, const 8_u32, move _67, move _68) -> [return: bb22, unwind continue];
    }

    bb22: {
        _70 = core::fmt::rt::Alignment::Unknown;
        _71 = core::fmt::rt::Count::Implied;
        _72 = core::fmt::rt::Count::Is(const 9_usize);
        _69 = core::fmt::rt::Placeholder::new(const 6_usize, const ' ', move _70, const 8_u32, move _71, move _72) -> [return: bb23, unwind continue];
    }

    bb23: {
        _44 = [move _45, move _49, move _53, move _57, move _61, move _65, move _69];
        _43 = &_44;
        _42 = _43 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _73 = core::fmt::rt::UnsafeArg::new() -> [return: bb24, unwind continue];
    }

    bb24: {
        _4 = std::fmt::Arguments::<'_>::new_v1_formatted(move _5, move _6, move _42, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb25, unwind continue];
    }

    bb25: {
        _0 = format(move _4) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }
}

promoted[0] in full_local: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];

    bb0: {
        _1 = [const "", const "-", const "-", const " ", const ":", const ":", const "."];
        _0 = &_1;
        return;
    }
}

fn full_zoned(_1: SystemTime, _2: &TimeZone) -> String {
    debug time => _1;
    debug zone => _2;
    let mut _0: std::string::String;
    let _3: datetime::LocalDateTime;
    let mut _4: i64;
    let mut _7: std::result::Result<datetime::Offset, datetime::cal::offset::Error>;
    let mut _8: i32;
    let mut _9: i64;
    let _10: &str;
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 9];
    let _15: [core::fmt::rt::Argument<'_>; 9];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &i64;
    let _18: i64;
    let mut _19: &datetime::LocalDateTime;
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &usize;
    let _22: usize;
    let _23: datetime::Month;
    let mut _24: &datetime::LocalDateTime;
    let mut _25: isize;
    let mut _26: u8;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &i8;
    let _32: i8;
    let mut _33: &datetime::LocalDateTime;
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &i8;
    let _36: i8;
    let mut _37: &datetime::LocalDateTime;
    let mut _38: core::fmt::rt::Argument<'_>;
    let _39: &i8;
    let _40: i8;
    let mut _41: &datetime::LocalDateTime;
    let mut _42: core::fmt::rt::Argument<'_>;
    let _43: &i8;
    let _44: i8;
    let mut _45: &datetime::LocalDateTime;
    let mut _46: core::fmt::rt::Argument<'_>;
    let _47: &u32;
    let _48: u32;
    let mut _49: core::fmt::rt::Argument<'_>;
    let _50: &i8;
    let _51: i8;
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &i8;
    let _54: i8;
    let mut _55: i8;
    let mut _56: &[core::fmt::rt::Placeholder];
    let _57: &[core::fmt::rt::Placeholder; 9];
    let _58: [core::fmt::rt::Placeholder; 9];
    let mut _59: core::fmt::rt::Placeholder;
    let mut _60: core::fmt::rt::Alignment;
    let mut _61: core::fmt::rt::Count;
    let mut _62: core::fmt::rt::Count;
    let mut _63: core::fmt::rt::Placeholder;
    let mut _64: core::fmt::rt::Alignment;
    let mut _65: core::fmt::rt::Count;
    let mut _66: core::fmt::rt::Count;
    let mut _67: core::fmt::rt::Placeholder;
    let mut _68: core::fmt::rt::Alignment;
    let mut _69: core::fmt::rt::Count;
    let mut _70: core::fmt::rt::Count;
    let mut _71: core::fmt::rt::Placeholder;
    let mut _72: core::fmt::rt::Alignment;
    let mut _73: core::fmt::rt::Count;
    let mut _74: core::fmt::rt::Count;
    let mut _75: core::fmt::rt::Placeholder;
    let mut _76: core::fmt::rt::Alignment;
    let mut _77: core::fmt::rt::Count;
    let mut _78: core::fmt::rt::Count;
    let mut _79: core::fmt::rt::Placeholder;
    let mut _80: core::fmt::rt::Alignment;
    let mut _81: core::fmt::rt::Count;
    let mut _82: core::fmt::rt::Count;
    let mut _83: core::fmt::rt::Placeholder;
    let mut _84: core::fmt::rt::Alignment;
    let mut _85: core::fmt::rt::Count;
    let mut _86: core::fmt::rt::Count;
    let mut _87: core::fmt::rt::Placeholder;
    let mut _88: core::fmt::rt::Alignment;
    let mut _89: core::fmt::rt::Count;
    let mut _90: core::fmt::rt::Count;
    let mut _91: core::fmt::rt::Placeholder;
    let mut _92: core::fmt::rt::Alignment;
    let mut _93: core::fmt::rt::Count;
    let mut _94: core::fmt::rt::Count;
    let mut _95: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug local => _3;
        let _5: datetime::LocalDateTime;
        scope 2 {
            debug date => _5;
            let _6: datetime::Offset;
            scope 3 {
                debug offset => _6;
                let mut _96: &[&str; 9];
                scope 4 {
                    debug res => _0;
                }
                scope 5 {
                }
            }
        }
    }

    bb0: {
        _4 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = LocalDateTime::at(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = TimeZone::to_zoned(_2, _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = TimeZone::offset(_2, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = move _9 as i32 (IntToInt);
        _7 = Offset::of_seconds(move _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = const "Offset out of range";
        _6 = Result::<Offset, datetime::cal::offset::Error>::expect(move _7, _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _96 = const _;
        _12 = _96 as &[&str] (PointerCoercion(Unsize));
        _19 = &_5;
        _18 = <LocalDateTime as DatePiece>::year(move _19) -> [return: bb7, unwind continue];
    }

    bb7: {
        _17 = &_18;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_17) -> [return: bb8, unwind continue];
    }

    bb8: {
        _24 = &_5;
        _23 = <LocalDateTime as DatePiece>::month(move _24) -> [return: bb9, unwind continue];
    }

    bb9: {
        _25 = discriminant(_23);
        _26 = _25 as u8 (IntToInt);
        _27 = Ge(_26, const 1_u8);
        _28 = Le(_26, const 12_u8);
        _29 = BitAnd(move _27, move _28);
        assume(move _29);
        _22 = move _25 as usize (IntToInt);
        _21 = &_22;
        _20 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_21) -> [return: bb10, unwind continue];
    }

    bb10: {
        _33 = &_5;
        _32 = <LocalDateTime as DatePiece>::day(move _33) -> [return: bb11, unwind continue];
    }

    bb11: {
        _31 = &_32;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_31) -> [return: bb12, unwind continue];
    }

    bb12: {
        _37 = &_5;
        _36 = <LocalDateTime as TimePiece>::hour(move _37) -> [return: bb13, unwind continue];
    }

    bb13: {
        _35 = &_36;
        _34 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_35) -> [return: bb14, unwind continue];
    }

    bb14: {
        _41 = &_5;
        _40 = <LocalDateTime as TimePiece>::minute(move _41) -> [return: bb15, unwind continue];
    }

    bb15: {
        _39 = &_40;
        _38 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_39) -> [return: bb16, unwind continue];
    }

    bb16: {
        _45 = &_5;
        _44 = <LocalDateTime as TimePiece>::second(move _45) -> [return: bb17, unwind continue];
    }

    bb17: {
        _43 = &_44;
        _42 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_43) -> [return: bb18, unwind continue];
    }

    bb18: {
        _48 = systemtime_nanos(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        _47 = &_48;
        _46 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_47) -> [return: bb20, unwind continue];
    }

    bb20: {
        _51 = Offset::hours(_6) -> [return: bb21, unwind continue];
    }

    bb21: {
        _50 = &_51;
        _49 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_50) -> [return: bb22, unwind continue];
    }

    bb22: {
        _55 = Offset::minutes(_6) -> [return: bb23, unwind continue];
    }

    bb23: {
        _54 = core::num::<impl i8>::abs(move _55) -> [return: bb24, unwind continue];
    }

    bb24: {
        _53 = &_54;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_53) -> [return: bb25, unwind continue];
    }

    bb25: {
        _15 = [move _16, move _20, move _30, move _34, move _38, move _42, move _46, move _49, move _52];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _60 = core::fmt::rt::Alignment::Unknown;
        _61 = core::fmt::rt::Count::Implied;
        _62 = core::fmt::rt::Count::Is(const 4_usize);
        _59 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _60, const 8_u32, move _61, move _62) -> [return: bb26, unwind continue];
    }

    bb26: {
        _64 = core::fmt::rt::Alignment::Unknown;
        _65 = core::fmt::rt::Count::Implied;
        _66 = core::fmt::rt::Count::Is(const 2_usize);
        _63 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _64, const 8_u32, move _65, move _66) -> [return: bb27, unwind continue];
    }

    bb27: {
        _68 = core::fmt::rt::Alignment::Unknown;
        _69 = core::fmt::rt::Count::Implied;
        _70 = core::fmt::rt::Count::Is(const 2_usize);
        _67 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _68, const 8_u32, move _69, move _70) -> [return: bb28, unwind continue];
    }

    bb28: {
        _72 = core::fmt::rt::Alignment::Unknown;
        _73 = core::fmt::rt::Count::Implied;
        _74 = core::fmt::rt::Count::Is(const 2_usize);
        _71 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _72, const 8_u32, move _73, move _74) -> [return: bb29, unwind continue];
    }

    bb29: {
        _76 = core::fmt::rt::Alignment::Unknown;
        _77 = core::fmt::rt::Count::Implied;
        _78 = core::fmt::rt::Count::Is(const 2_usize);
        _75 = core::fmt::rt::Placeholder::new(const 4_usize, const ' ', move _76, const 8_u32, move _77, move _78) -> [return: bb30, unwind continue];
    }

    bb30: {
        _80 = core::fmt::rt::Alignment::Unknown;
        _81 = core::fmt::rt::Count::Implied;
        _82 = core::fmt::rt::Count::Is(const 2_usize);
        _79 = core::fmt::rt::Placeholder::new(const 5_usize, const ' ', move _80, const 8_u32, move _81, move _82) -> [return: bb31, unwind continue];
    }

    bb31: {
        _84 = core::fmt::rt::Alignment::Unknown;
        _85 = core::fmt::rt::Count::Implied;
        _86 = core::fmt::rt::Count::Is(const 9_usize);
        _83 = core::fmt::rt::Placeholder::new(const 6_usize, const ' ', move _84, const 8_u32, move _85, move _86) -> [return: bb32, unwind continue];
    }

    bb32: {
        _88 = core::fmt::rt::Alignment::Unknown;
        _89 = core::fmt::rt::Count::Implied;
        _90 = core::fmt::rt::Count::Is(const 3_usize);
        _87 = core::fmt::rt::Placeholder::new(const 7_usize, const ' ', move _88, const 9_u32, move _89, move _90) -> [return: bb33, unwind continue];
    }

    bb33: {
        _92 = core::fmt::rt::Alignment::Unknown;
        _93 = core::fmt::rt::Count::Implied;
        _94 = core::fmt::rt::Count::Is(const 2_usize);
        _91 = core::fmt::rt::Placeholder::new(const 8_usize, const ' ', move _92, const 8_u32, move _93, move _94) -> [return: bb34, unwind continue];
    }

    bb34: {
        _58 = [move _59, move _63, move _67, move _71, move _75, move _79, move _83, move _87, move _91];
        _57 = &_58;
        _56 = _57 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _95 = core::fmt::rt::UnsafeArg::new() -> [return: bb35, unwind continue];
    }

    bb35: {
        _11 = std::fmt::Arguments::<'_>::new_v1_formatted(move _12, move _13, move _56, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb36, unwind continue];
    }

    bb36: {
        _0 = format(move _11) -> [return: bb37, unwind continue];
    }

    bb37: {
        return;
    }
}

promoted[0] in full_zoned: &[&str; 9] = {
    let mut _0: &[&str; 9];
    let mut _1: [&str; 9];

    bb0: {
        _1 = [const "", const "-", const "-", const " ", const ":", const ":", const ".", const " ", const ""];
        _0 = &_1;
        return;
    }
}

fn iso_local(_1: SystemTime) -> String {
    debug time => _1;
    let mut _0: std::string::String;
    let _2: datetime::LocalDateTime;
    let mut _3: i64;
    let mut _4: bool;
    let _5: &datetime::LocalDateTime;
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 4];
    let _11: [core::fmt::rt::Argument<'_>; 4];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &usize;
    let _14: usize;
    let _15: datetime::Month;
    let mut _16: &datetime::LocalDateTime;
    let mut _17: isize;
    let mut _18: u8;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &i8;
    let _24: i8;
    let mut _25: &datetime::LocalDateTime;
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &i8;
    let _28: i8;
    let mut _29: &datetime::LocalDateTime;
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &i8;
    let _32: i8;
    let mut _33: &datetime::LocalDateTime;
    let mut _34: &[core::fmt::rt::Placeholder];
    let _35: &[core::fmt::rt::Placeholder; 4];
    let _36: [core::fmt::rt::Placeholder; 4];
    let mut _37: core::fmt::rt::Placeholder;
    let mut _38: core::fmt::rt::Alignment;
    let mut _39: core::fmt::rt::Count;
    let mut _40: core::fmt::rt::Count;
    let mut _41: core::fmt::rt::Placeholder;
    let mut _42: core::fmt::rt::Alignment;
    let mut _43: core::fmt::rt::Count;
    let mut _44: core::fmt::rt::Count;
    let mut _45: core::fmt::rt::Placeholder;
    let mut _46: core::fmt::rt::Alignment;
    let mut _47: core::fmt::rt::Count;
    let mut _48: core::fmt::rt::Count;
    let mut _49: core::fmt::rt::Placeholder;
    let mut _50: core::fmt::rt::Alignment;
    let mut _51: core::fmt::rt::Count;
    let mut _52: core::fmt::rt::Count;
    let mut _53: core::fmt::rt::UnsafeArg;
    let mut _55: std::fmt::Arguments<'_>;
    let mut _56: &[&str];
    let mut _57: &[core::fmt::rt::Argument<'_>];
    let _58: &[core::fmt::rt::Argument<'_>; 3];
    let _59: [core::fmt::rt::Argument<'_>; 3];
    let mut _60: core::fmt::rt::Argument<'_>;
    let _61: &i64;
    let _62: i64;
    let mut _63: &datetime::LocalDateTime;
    let mut _64: core::fmt::rt::Argument<'_>;
    let _65: &usize;
    let _66: usize;
    let _67: datetime::Month;
    let mut _68: &datetime::LocalDateTime;
    let mut _69: isize;
    let mut _70: u8;
    let mut _71: bool;
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: core::fmt::rt::Argument<'_>;
    let _75: &i8;
    let _76: i8;
    let mut _77: &datetime::LocalDateTime;
    let mut _78: &[core::fmt::rt::Placeholder];
    let _79: &[core::fmt::rt::Placeholder; 3];
    let _80: [core::fmt::rt::Placeholder; 3];
    let mut _81: core::fmt::rt::Placeholder;
    let mut _82: core::fmt::rt::Alignment;
    let mut _83: core::fmt::rt::Count;
    let mut _84: core::fmt::rt::Count;
    let mut _85: core::fmt::rt::Placeholder;
    let mut _86: core::fmt::rt::Alignment;
    let mut _87: core::fmt::rt::Count;
    let mut _88: core::fmt::rt::Count;
    let mut _89: core::fmt::rt::Placeholder;
    let mut _90: core::fmt::rt::Alignment;
    let mut _91: core::fmt::rt::Count;
    let mut _92: core::fmt::rt::Count;
    let mut _93: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug date => _2;
        let _6: std::string::String;
        let _54: std::string::String;
        let mut _94: &[&str; 4];
        let mut _95: &[&str; 3];
        scope 2 {
            debug res => _6;
        }
        scope 3 {
        }
        scope 4 {
            debug res => _54;
        }
        scope 5 {
        }
    }

    bb0: {
        _3 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = LocalDateTime::at(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_2;
        _4 = is_recent(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb20, otherwise: bb4];
    }

    bb4: {
        _94 = const _;
        _8 = _94 as &[&str] (PointerCoercion(Unsize));
        _16 = &_2;
        _15 = <LocalDateTime as DatePiece>::month(move _16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = discriminant(_15);
        _18 = _17 as u8 (IntToInt);
        _19 = Ge(_18, const 1_u8);
        _20 = Le(_18, const 12_u8);
        _21 = BitAnd(move _19, move _20);
        assume(move _21);
        _14 = move _17 as usize (IntToInt);
        _13 = &_14;
        _12 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _25 = &_2;
        _24 = <LocalDateTime as DatePiece>::day(move _25) -> [return: bb7, unwind continue];
    }

    bb7: {
        _23 = &_24;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_23) -> [return: bb8, unwind continue];
    }

    bb8: {
        _29 = &_2;
        _28 = <LocalDateTime as TimePiece>::hour(move _29) -> [return: bb9, unwind continue];
    }

    bb9: {
        _27 = &_28;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_27) -> [return: bb10, unwind continue];
    }

    bb10: {
        _33 = &_2;
        _32 = <LocalDateTime as TimePiece>::minute(move _33) -> [return: bb11, unwind continue];
    }

    bb11: {
        _31 = &_32;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_31) -> [return: bb12, unwind continue];
    }

    bb12: {
        _11 = [move _12, move _22, move _26, move _30];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _38 = core::fmt::rt::Alignment::Unknown;
        _39 = core::fmt::rt::Count::Implied;
        _40 = core::fmt::rt::Count::Is(const 2_usize);
        _37 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _38, const 8_u32, move _39, move _40) -> [return: bb13, unwind continue];
    }

    bb13: {
        _42 = core::fmt::rt::Alignment::Unknown;
        _43 = core::fmt::rt::Count::Implied;
        _44 = core::fmt::rt::Count::Is(const 2_usize);
        _41 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _42, const 8_u32, move _43, move _44) -> [return: bb14, unwind continue];
    }

    bb14: {
        _46 = core::fmt::rt::Alignment::Unknown;
        _47 = core::fmt::rt::Count::Implied;
        _48 = core::fmt::rt::Count::Is(const 2_usize);
        _45 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _46, const 8_u32, move _47, move _48) -> [return: bb15, unwind continue];
    }

    bb15: {
        _50 = core::fmt::rt::Alignment::Unknown;
        _51 = core::fmt::rt::Count::Implied;
        _52 = core::fmt::rt::Count::Is(const 2_usize);
        _49 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _50, const 8_u32, move _51, move _52) -> [return: bb16, unwind continue];
    }

    bb16: {
        _36 = [move _37, move _41, move _45, move _49];
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _53 = core::fmt::rt::UnsafeArg::new() -> [return: bb17, unwind continue];
    }

    bb17: {
        _7 = std::fmt::Arguments::<'_>::new_v1_formatted(move _8, move _9, move _34, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb18, unwind continue];
    }

    bb18: {
        _6 = format(move _7) -> [return: bb19, unwind continue];
    }

    bb19: {
        _0 = move _6;
        goto -> bb33;
    }

    bb20: {
        _95 = const _;
        _56 = _95 as &[&str] (PointerCoercion(Unsize));
        _63 = &_2;
        _62 = <LocalDateTime as DatePiece>::year(move _63) -> [return: bb21, unwind continue];
    }

    bb21: {
        _61 = &_62;
        _60 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_61) -> [return: bb22, unwind continue];
    }

    bb22: {
        _68 = &_2;
        _67 = <LocalDateTime as DatePiece>::month(move _68) -> [return: bb23, unwind continue];
    }

    bb23: {
        _69 = discriminant(_67);
        _70 = _69 as u8 (IntToInt);
        _71 = Ge(_70, const 1_u8);
        _72 = Le(_70, const 12_u8);
        _73 = BitAnd(move _71, move _72);
        assume(move _73);
        _66 = move _69 as usize (IntToInt);
        _65 = &_66;
        _64 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_65) -> [return: bb24, unwind continue];
    }

    bb24: {
        _77 = &_2;
        _76 = <LocalDateTime as DatePiece>::day(move _77) -> [return: bb25, unwind continue];
    }

    bb25: {
        _75 = &_76;
        _74 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_75) -> [return: bb26, unwind continue];
    }

    bb26: {
        _59 = [move _60, move _64, move _74];
        _58 = &_59;
        _57 = _58 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _82 = core::fmt::rt::Alignment::Unknown;
        _83 = core::fmt::rt::Count::Implied;
        _84 = core::fmt::rt::Count::Is(const 4_usize);
        _81 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _82, const 8_u32, move _83, move _84) -> [return: bb27, unwind continue];
    }

    bb27: {
        _86 = core::fmt::rt::Alignment::Unknown;
        _87 = core::fmt::rt::Count::Implied;
        _88 = core::fmt::rt::Count::Is(const 2_usize);
        _85 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _86, const 8_u32, move _87, move _88) -> [return: bb28, unwind continue];
    }

    bb28: {
        _90 = core::fmt::rt::Alignment::Unknown;
        _91 = core::fmt::rt::Count::Implied;
        _92 = core::fmt::rt::Count::Is(const 2_usize);
        _89 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _90, const 8_u32, move _91, move _92) -> [return: bb29, unwind continue];
    }

    bb29: {
        _80 = [move _81, move _85, move _89];
        _79 = &_80;
        _78 = _79 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _93 = core::fmt::rt::UnsafeArg::new() -> [return: bb30, unwind continue];
    }

    bb30: {
        _55 = std::fmt::Arguments::<'_>::new_v1_formatted(move _56, move _57, move _78, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb31, unwind continue];
    }

    bb31: {
        _54 = format(move _55) -> [return: bb32, unwind continue];
    }

    bb32: {
        _0 = move _54;
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

promoted[0] in iso_local: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "", const "-", const " ", const ":"];
        _0 = &_1;
        return;
    }
}

promoted[1] in iso_local: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const "-", const "-"];
        _0 = &_1;
        return;
    }
}

fn iso_zoned(_1: SystemTime, _2: &TimeZone) -> String {
    debug time => _1;
    debug zone => _2;
    let mut _0: std::string::String;
    let _3: datetime::LocalDateTime;
    let mut _4: datetime::LocalDateTime;
    let mut _5: i64;
    let mut _6: bool;
    let _7: &datetime::LocalDateTime;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 4];
    let _13: [core::fmt::rt::Argument<'_>; 4];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &usize;
    let _16: usize;
    let _17: datetime::Month;
    let mut _18: &datetime::LocalDateTime;
    let mut _19: isize;
    let mut _20: u8;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &i8;
    let _26: i8;
    let mut _27: &datetime::LocalDateTime;
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &i8;
    let _30: i8;
    let mut _31: &datetime::LocalDateTime;
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &i8;
    let _34: i8;
    let mut _35: &datetime::LocalDateTime;
    let mut _36: &[core::fmt::rt::Placeholder];
    let _37: &[core::fmt::rt::Placeholder; 4];
    let _38: [core::fmt::rt::Placeholder; 4];
    let mut _39: core::fmt::rt::Placeholder;
    let mut _40: core::fmt::rt::Alignment;
    let mut _41: core::fmt::rt::Count;
    let mut _42: core::fmt::rt::Count;
    let mut _43: core::fmt::rt::Placeholder;
    let mut _44: core::fmt::rt::Alignment;
    let mut _45: core::fmt::rt::Count;
    let mut _46: core::fmt::rt::Count;
    let mut _47: core::fmt::rt::Placeholder;
    let mut _48: core::fmt::rt::Alignment;
    let mut _49: core::fmt::rt::Count;
    let mut _50: core::fmt::rt::Count;
    let mut _51: core::fmt::rt::Placeholder;
    let mut _52: core::fmt::rt::Alignment;
    let mut _53: core::fmt::rt::Count;
    let mut _54: core::fmt::rt::Count;
    let mut _55: core::fmt::rt::UnsafeArg;
    let mut _57: std::fmt::Arguments<'_>;
    let mut _58: &[&str];
    let mut _59: &[core::fmt::rt::Argument<'_>];
    let _60: &[core::fmt::rt::Argument<'_>; 3];
    let _61: [core::fmt::rt::Argument<'_>; 3];
    let mut _62: core::fmt::rt::Argument<'_>;
    let _63: &i64;
    let _64: i64;
    let mut _65: &datetime::LocalDateTime;
    let mut _66: core::fmt::rt::Argument<'_>;
    let _67: &usize;
    let _68: usize;
    let _69: datetime::Month;
    let mut _70: &datetime::LocalDateTime;
    let mut _71: isize;
    let mut _72: u8;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: core::fmt::rt::Argument<'_>;
    let _77: &i8;
    let _78: i8;
    let mut _79: &datetime::LocalDateTime;
    let mut _80: &[core::fmt::rt::Placeholder];
    let _81: &[core::fmt::rt::Placeholder; 3];
    let _82: [core::fmt::rt::Placeholder; 3];
    let mut _83: core::fmt::rt::Placeholder;
    let mut _84: core::fmt::rt::Alignment;
    let mut _85: core::fmt::rt::Count;
    let mut _86: core::fmt::rt::Count;
    let mut _87: core::fmt::rt::Placeholder;
    let mut _88: core::fmt::rt::Alignment;
    let mut _89: core::fmt::rt::Count;
    let mut _90: core::fmt::rt::Count;
    let mut _91: core::fmt::rt::Placeholder;
    let mut _92: core::fmt::rt::Alignment;
    let mut _93: core::fmt::rt::Count;
    let mut _94: core::fmt::rt::Count;
    let mut _95: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug date => _3;
        let _8: std::string::String;
        let _56: std::string::String;
        let mut _96: &[&str; 4];
        let mut _97: &[&str; 3];
        scope 2 {
            debug res => _8;
        }
        scope 3 {
        }
        scope 4 {
            debug res => _56;
        }
        scope 5 {
        }
    }

    bb0: {
        _5 = systemtime_epoch(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = LocalDateTime::at(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = TimeZone::to_zoned(_2, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &_3;
        _6 = is_recent(_7) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _6) -> [0: bb21, otherwise: bb5];
    }

    bb5: {
        _96 = const _;
        _10 = _96 as &[&str] (PointerCoercion(Unsize));
        _18 = &_3;
        _17 = <LocalDateTime as DatePiece>::month(move _18) -> [return: bb6, unwind continue];
    }

    bb6: {
        _19 = discriminant(_17);
        _20 = _19 as u8 (IntToInt);
        _21 = Ge(_20, const 1_u8);
        _22 = Le(_20, const 12_u8);
        _23 = BitAnd(move _21, move _22);
        assume(move _23);
        _16 = move _19 as usize (IntToInt);
        _15 = &_16;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _27 = &_3;
        _26 = <LocalDateTime as DatePiece>::day(move _27) -> [return: bb8, unwind continue];
    }

    bb8: {
        _25 = &_26;
        _24 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_25) -> [return: bb9, unwind continue];
    }

    bb9: {
        _31 = &_3;
        _30 = <LocalDateTime as TimePiece>::hour(move _31) -> [return: bb10, unwind continue];
    }

    bb10: {
        _29 = &_30;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_29) -> [return: bb11, unwind continue];
    }

    bb11: {
        _35 = &_3;
        _34 = <LocalDateTime as TimePiece>::minute(move _35) -> [return: bb12, unwind continue];
    }

    bb12: {
        _33 = &_34;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_33) -> [return: bb13, unwind continue];
    }

    bb13: {
        _13 = [move _14, move _24, move _28, move _32];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _40 = core::fmt::rt::Alignment::Unknown;
        _41 = core::fmt::rt::Count::Implied;
        _42 = core::fmt::rt::Count::Is(const 2_usize);
        _39 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _40, const 8_u32, move _41, move _42) -> [return: bb14, unwind continue];
    }

    bb14: {
        _44 = core::fmt::rt::Alignment::Unknown;
        _45 = core::fmt::rt::Count::Implied;
        _46 = core::fmt::rt::Count::Is(const 2_usize);
        _43 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _44, const 8_u32, move _45, move _46) -> [return: bb15, unwind continue];
    }

    bb15: {
        _48 = core::fmt::rt::Alignment::Unknown;
        _49 = core::fmt::rt::Count::Implied;
        _50 = core::fmt::rt::Count::Is(const 2_usize);
        _47 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _48, const 8_u32, move _49, move _50) -> [return: bb16, unwind continue];
    }

    bb16: {
        _52 = core::fmt::rt::Alignment::Unknown;
        _53 = core::fmt::rt::Count::Implied;
        _54 = core::fmt::rt::Count::Is(const 2_usize);
        _51 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _52, const 8_u32, move _53, move _54) -> [return: bb17, unwind continue];
    }

    bb17: {
        _38 = [move _39, move _43, move _47, move _51];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _55 = core::fmt::rt::UnsafeArg::new() -> [return: bb18, unwind continue];
    }

    bb18: {
        _9 = std::fmt::Arguments::<'_>::new_v1_formatted(move _10, move _11, move _36, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb19, unwind continue];
    }

    bb19: {
        _8 = format(move _9) -> [return: bb20, unwind continue];
    }

    bb20: {
        _0 = move _8;
        goto -> bb34;
    }

    bb21: {
        _97 = const _;
        _58 = _97 as &[&str] (PointerCoercion(Unsize));
        _65 = &_3;
        _64 = <LocalDateTime as DatePiece>::year(move _65) -> [return: bb22, unwind continue];
    }

    bb22: {
        _63 = &_64;
        _62 = core::fmt::rt::Argument::<'_>::new_display::<i64>(_63) -> [return: bb23, unwind continue];
    }

    bb23: {
        _70 = &_3;
        _69 = <LocalDateTime as DatePiece>::month(move _70) -> [return: bb24, unwind continue];
    }

    bb24: {
        _71 = discriminant(_69);
        _72 = _71 as u8 (IntToInt);
        _73 = Ge(_72, const 1_u8);
        _74 = Le(_72, const 12_u8);
        _75 = BitAnd(move _73, move _74);
        assume(move _75);
        _68 = move _71 as usize (IntToInt);
        _67 = &_68;
        _66 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_67) -> [return: bb25, unwind continue];
    }

    bb25: {
        _79 = &_3;
        _78 = <LocalDateTime as DatePiece>::day(move _79) -> [return: bb26, unwind continue];
    }

    bb26: {
        _77 = &_78;
        _76 = core::fmt::rt::Argument::<'_>::new_display::<i8>(_77) -> [return: bb27, unwind continue];
    }

    bb27: {
        _61 = [move _62, move _66, move _76];
        _60 = &_61;
        _59 = _60 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _84 = core::fmt::rt::Alignment::Unknown;
        _85 = core::fmt::rt::Count::Implied;
        _86 = core::fmt::rt::Count::Is(const 4_usize);
        _83 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _84, const 8_u32, move _85, move _86) -> [return: bb28, unwind continue];
    }

    bb28: {
        _88 = core::fmt::rt::Alignment::Unknown;
        _89 = core::fmt::rt::Count::Implied;
        _90 = core::fmt::rt::Count::Is(const 2_usize);
        _87 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _88, const 8_u32, move _89, move _90) -> [return: bb29, unwind continue];
    }

    bb29: {
        _92 = core::fmt::rt::Alignment::Unknown;
        _93 = core::fmt::rt::Count::Implied;
        _94 = core::fmt::rt::Count::Is(const 2_usize);
        _91 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _92, const 8_u32, move _93, move _94) -> [return: bb30, unwind continue];
    }

    bb30: {
        _82 = [move _83, move _87, move _91];
        _81 = &_82;
        _80 = _81 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _95 = core::fmt::rt::UnsafeArg::new() -> [return: bb31, unwind continue];
    }

    bb31: {
        _57 = std::fmt::Arguments::<'_>::new_v1_formatted(move _58, move _59, move _80, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb32, unwind continue];
    }

    bb32: {
        _56 = format(move _57) -> [return: bb33, unwind continue];
    }

    bb33: {
        _0 = move _56;
        goto -> bb34;
    }

    bb34: {
        return;
    }
}

promoted[0] in iso_zoned: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "", const "-", const " ", const ":"];
        _0 = &_1;
        return;
    }
}

promoted[1] in iso_zoned: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const "-", const "-"];
        _0 = &_1;
        return;
    }
}

fn systemtime_epoch(_1: SystemTime) -> i64 {
    debug time => _1;
    let mut _0: i64;
    let mut _2: std::result::Result<i64, std::time::SystemTimeError>;
    let mut _3: std::result::Result<std::time::Duration, std::time::SystemTimeError>;
    let mut _4: &std::time::SystemTime;

    bb0: {
        _4 = &_1;
        _3 = SystemTime::duration_since(move _4, const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Result::<std::time::Duration, SystemTimeError>::map::<i64, {closure@src/output/time.rs:170:14: 170:17}>(move _3, const ZeroSized: {closure@src/output/time.rs:170:14: 170:17}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Result::<i64, SystemTimeError>::unwrap_or_else::<{closure@src/output/time.rs:171:25: 171:28}>(move _2, const ZeroSized: {closure@src/output/time.rs:171:25: 171:28}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn systemtime_epoch::{closure#0}(_1: {closure@src/output/time.rs:170:14: 170:17}, _2: std::time::Duration) -> i64 {
    debug t => _2;
    let mut _0: i64;
    let mut _3: u64;
    let mut _4: &std::time::Duration;

    bb0: {
        _4 = &_2;
        _3 = std::time::Duration::as_secs(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = move _3 as i64 (IntToInt);
        return;
    }
}

fn systemtime_epoch::{closure#1}(_1: {closure@src/output/time.rs:171:25: 171:28}, _2: SystemTimeError) -> i64 {
    debug e => _2;
    let mut _0: i64;
    let _3: std::time::Duration;
    let mut _4: &std::time::SystemTimeError;
    let mut _6: &std::time::Duration;
    let mut _7: bool;
    let mut _8: u32;
    let mut _9: &std::time::Duration;
    let mut _10: (u64, bool);
    let mut _11: i64;
    let mut _12: u64;
    let mut _13: bool;
    scope 1 {
        debug diff => _3;
        let mut _5: u64;
        scope 2 {
            debug secs => _5;
        }
    }

    bb0: {
        _4 = &_2;
        _3 = SystemTimeError::duration(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_3;
        _5 = std::time::Duration::as_secs(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &_3;
        _8 = std::time::Duration::subsec_nanos(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = Gt(move _8, const 0_u32);
        switchInt(move _7) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _10 = CheckedAdd(_5, const 1_u64);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, const 1_u64) -> [success: bb5, unwind continue];
    }

    bb5: {
        _5 = move (_10.0: u64);
        goto -> bb6;
    }

    bb6: {
        _12 = _5;
        _11 = move _12 as i64 (IntToInt);
        _13 = Eq(_11, const i64::MIN);
        assert(!move _13, "attempt to negate `{}`, which would overflow", _11) -> [success: bb7, unwind continue];
    }

    bb7: {
        _0 = Neg(move _11);
        return;
    }
}

fn systemtime_nanos(_1: SystemTime) -> u32 {
    debug time => _1;
    let mut _0: u32;
    let mut _2: std::result::Result<u32, std::time::SystemTimeError>;
    let mut _3: std::result::Result<std::time::Duration, std::time::SystemTimeError>;
    let mut _4: &std::time::SystemTime;

    bb0: {
        _4 = &_1;
        _3 = SystemTime::duration_since(move _4, const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Result::<std::time::Duration, SystemTimeError>::map::<u32, {closure@src/output/time.rs:183:14: 183:17}>(move _3, const ZeroSized: {closure@src/output/time.rs:183:14: 183:17}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Result::<u32, SystemTimeError>::unwrap_or_else::<{closure@src/output/time.rs:184:25: 184:28}>(move _2, const ZeroSized: {closure@src/output/time.rs:184:25: 184:28}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn systemtime_nanos::{closure#0}(_1: {closure@src/output/time.rs:183:14: 183:17}, _2: std::time::Duration) -> u32 {
    debug t => _2;
    let mut _0: u32;
    let mut _3: &std::time::Duration;

    bb0: {
        _3 = &_2;
        _0 = std::time::Duration::subsec_nanos(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn systemtime_nanos::{closure#1}(_1: {closure@src/output/time.rs:184:25: 184:28}, _2: SystemTimeError) -> u32 {
    debug e => _2;
    let mut _0: u32;
    let _3: u32;
    let mut _4: &std::time::Duration;
    let _5: std::time::Duration;
    let mut _6: &std::time::SystemTimeError;
    let mut _7: bool;
    let mut _8: (u32, bool);
    scope 1 {
        debug nanos => _3;
    }

    bb0: {
        _6 = &_2;
        _5 = SystemTimeError::duration(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_5;
        _3 = std::time::Duration::subsec_nanos(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Gt(_3, const 0_u32);
        switchInt(move _7) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _8 = CheckedSub(const 1000000000_u32, _3);
        assert(!move (_8.1: bool), "attempt to compute `{} - {}`, which would overflow", const 1000000000_u32, _3) -> [success: bb4, unwind continue];
    }

    bb4: {
        _0 = move (_8.0: u32);
        goto -> bb6;
    }

    bb5: {
        _0 = _3;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn is_recent(_1: &LocalDateTime) -> bool {
    debug date => _1;
    let mut _0: bool;
    let mut _2: i64;
    let mut _3: i64;
    let mut _4: &i64;
    let _5: &output::time::CURRENT_YEAR;

    bb0: {
        _2 = <LocalDateTime as DatePiece>::year(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const {alloc90: &CURRENT_YEAR};
        _4 = <CURRENT_YEAR as Deref>::deref(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = (*_4);
        _0 = Eq(move _2, move _3);
        return;
    }
}

alloc90 (static: CURRENT_YEAR, size: 0, align: 1) {}

static CURRENT_YEAR: CURRENT_YEAR = {
    let mut _0: output::time::CURRENT_YEAR;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = CURRENT_YEAR { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &CURRENT_YEAR) -> &i64 {
    debug self => _1;
    let mut _0: &i64;

    bb0: {
        _0 = <CURRENT_YEAR as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> i64 {
    let mut _0: i64;
    let mut _1: &datetime::LocalDateTime;
    let _2: datetime::LocalDateTime;

    bb0: {
        _2 = LocalDateTime::now() -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = &_2;
        _0 = <LocalDateTime as DatePiece>::year(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &i64 {
    let mut _0: &i64;
    let _1: &lazy_static::lazy::Lazy<i64>;

    bb0: {
        _1 = const {alloc91: &Lazy<i64>};
        _0 = Lazy::<i64>::get::<fn() -> i64 {<CURRENT_YEAR as Deref>::deref::__static_ref_initialize}>(_1, <CURRENT_YEAR as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc91 (static: <CURRENT_YEAR as Deref>::deref::__stability::LAZY, size: 24, align: 8) {
    0x00  00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  00 00 00 00 __ __ __ __                          ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<i64> = {
    let mut _0: lazy_static::lazy::Lazy<i64>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &CURRENT_YEAR) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &i64;
    scope 1 {
    }

    bb0: {
        _2 = <CURRENT_YEAR as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static LOCALE: LOCALE = {
    let mut _0: output::time::LOCALE;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = LOCALE { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &LOCALE) -> &locale::Time {
    debug self => _1;
    let mut _0: &locale::Time;

    bb0: {
        _0 = <LOCALE as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> locale::Time {
    let mut _0: locale::Time;
    let mut _1: std::result::Result<locale::Time, std::io::Error>;

    bb0: {
        _1 = locale::Time::load_user_locale() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<locale::Time, std::io::Error>::unwrap_or_else::<{closure@src/output/time.rs:205:32: 205:35}>(move _1, const ZeroSized: {closure@src/output/time.rs:205:32: 205:35}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize::{closure#0}(_1: {closure@src/output/time.rs:205:32: 205:35}, _2: std::io::Error) -> locale::Time {
    let mut _0: locale::Time;

    bb0: {
        _0 = locale::Time::english() -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &locale::Time {
    let mut _0: &locale::Time;
    let _1: &lazy_static::lazy::Lazy<locale::Time>;

    bb0: {
        _1 = const {alloc92: &Lazy<locale::Time>};
        _0 = Lazy::<locale::Time>::get::<fn() -> locale::Time {<LOCALE as Deref>::deref::__static_ref_initialize}>(_1, <LOCALE as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc92 (static: <LOCALE as Deref>::deref::__stability::LAZY, size: 104, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x20  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x30  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x40  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x50  __ __ __ __ __ __ __ __ __ __ __ __ __ __ __ __  
    0x60  00 00 00 00 __ __ __ __                          ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<locale::Time> = {
    let mut _0: lazy_static::lazy::Lazy<locale::Time>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &LOCALE) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &locale::Time;
    scope 1 {
    }

    bb0: {
        _2 = <LOCALE as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static MAXIMUM_MONTH_WIDTH: MAXIMUM_MONTH_WIDTH = {
    let mut _0: output::time::MAXIMUM_MONTH_WIDTH;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = MAXIMUM_MONTH_WIDTH { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &MAXIMUM_MONTH_WIDTH) -> &usize {
    debug self => _1;
    let mut _0: &usize;

    bb0: {
        _0 = <MAXIMUM_MONTH_WIDTH as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> usize {
    let mut _0: usize;
    let mut _1: usize;
    let mut _2: std::ops::Range<usize>;
    let mut _3: std::ops::Range<usize>;
    let mut _5: std::option::Option<usize>;
    let mut _6: &mut std::ops::Range<usize>;
    let mut _7: isize;
    let _10: &str;
    let mut _11: &std::string::String;
    let _12: std::string::String;
    let _13: &locale::Time;
    let _14: &output::time::LOCALE;
    let mut _15: usize;
    let mut _16: usize;
    scope 1 {
        debug maximum_month_width => _1;
        let mut _4: std::ops::Range<usize>;
        scope 2 {
            debug iter => _4;
            let _8: usize;
            scope 3 {
                debug i => _8;
                let _9: usize;
                scope 4 {
                    debug current_month_width => _9;
                }
            }
        }
    }

    bb0: {
        _1 = const 0_usize;
        _3 = std::ops::Range::<usize> { start: const 0_usize, end: const 11_usize };
        _2 = <std::ops::Range<usize> as IntoIterator>::into_iter(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = move _2;
        goto -> bb2;
    }

    bb2: {
        _6 = &mut _4;
        _5 = <std::ops::Range<usize> as Iterator>::next(_6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _8 = ((_5 as Some).0: usize);
        _14 = const {alloc70: &LOCALE};
        _13 = <LOCALE as Deref>::deref(_14) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = _1;
        return;
    }

    bb7: {
        _12 = locale::Time::short_month_name(_13, _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = &_12;
        _10 = <String as Deref>::deref(move _11) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _9 = <str as UnicodeWidthStr>::width(_10) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_12) -> [return: bb11, unwind continue];
    }

    bb11: {
        _16 = _1;
        _15 = std::cmp::max::<usize>(move _16, _9) -> [return: bb12, unwind continue];
    }

    bb12: {
        _1 = move _15;
        goto -> bb2;
    }

    bb13 (cleanup): {
        drop(_12) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

alloc70 (static: LOCALE, size: 0, align: 1) {}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &usize {
    let mut _0: &usize;
    let _1: &lazy_static::lazy::Lazy<usize>;

    bb0: {
        _1 = const {alloc93: &Lazy<usize>};
        _0 = Lazy::<usize>::get::<fn() -> usize {<MAXIMUM_MONTH_WIDTH as Deref>::deref::__static_ref_initialize}>(_1, <MAXIMUM_MONTH_WIDTH as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc93 (static: <MAXIMUM_MONTH_WIDTH as Deref>::deref::__stability::LAZY, size: 24, align: 8) {
    0x00  00 00 00 00 00 00 00 00 __ __ __ __ __ __ __ __  ........
    0x10  00 00 00 00 __ __ __ __                          ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<usize> = {
    let mut _0: lazy_static::lazy::Lazy<usize>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &MAXIMUM_MONTH_WIDTH) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &usize;
    scope 1 {
    }

    bb0: {
        _2 = <MAXIMUM_MONTH_WIDTH as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static FOUR_WIDE_DATE_TIME: FOUR_WIDE_DATE_TIME = {
    let mut _0: output::time::FOUR_WIDE_DATE_TIME;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = FOUR_WIDE_DATE_TIME { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &FOUR_WIDE_DATE_TIME) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <FOUR_WIDE_DATE_TIME as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {4<:M} {02>:h}:{02>:m}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc94: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<FOUR_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize}>(_1, <FOUR_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc94 (static: <FOUR_WIDE_DATE_TIME as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &FOUR_WIDE_DATE_TIME) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <FOUR_WIDE_DATE_TIME as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static FIVE_WIDE_DATE_TIME: FIVE_WIDE_DATE_TIME = {
    let mut _0: output::time::FIVE_WIDE_DATE_TIME;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = FIVE_WIDE_DATE_TIME { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &FIVE_WIDE_DATE_TIME) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <FIVE_WIDE_DATE_TIME as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {5<:M} {02>:h}:{02>:m}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc95: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<FIVE_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize}>(_1, <FIVE_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc95 (static: <FIVE_WIDE_DATE_TIME as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &FIVE_WIDE_DATE_TIME) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <FIVE_WIDE_DATE_TIME as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static OTHER_WIDE_DATE_TIME: OTHER_WIDE_DATE_TIME = {
    let mut _0: output::time::OTHER_WIDE_DATE_TIME;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = OTHER_WIDE_DATE_TIME { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &OTHER_WIDE_DATE_TIME) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <OTHER_WIDE_DATE_TIME as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {:M} {02>:h}:{02>:m}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc96: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<OTHER_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize}>(_1, <OTHER_WIDE_DATE_TIME as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc96 (static: <OTHER_WIDE_DATE_TIME as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &OTHER_WIDE_DATE_TIME) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <OTHER_WIDE_DATE_TIME as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static FOUR_WIDE_DATE_YEAR: FOUR_WIDE_DATE_YEAR = {
    let mut _0: output::time::FOUR_WIDE_DATE_YEAR;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = FOUR_WIDE_DATE_YEAR { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &FOUR_WIDE_DATE_YEAR) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <FOUR_WIDE_DATE_YEAR as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {4<:M} {5>:Y}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc97: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<FOUR_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize}>(_1, <FOUR_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc97 (static: <FOUR_WIDE_DATE_YEAR as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &FOUR_WIDE_DATE_YEAR) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <FOUR_WIDE_DATE_YEAR as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static FIVE_WIDE_DATE_YEAR: FIVE_WIDE_DATE_YEAR = {
    let mut _0: output::time::FIVE_WIDE_DATE_YEAR;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = FIVE_WIDE_DATE_YEAR { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &FIVE_WIDE_DATE_YEAR) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <FIVE_WIDE_DATE_YEAR as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {5<:M} {5>:Y}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc98: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<FIVE_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize}>(_1, <FIVE_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc98 (static: <FIVE_WIDE_DATE_YEAR as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &FIVE_WIDE_DATE_YEAR) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <FIVE_WIDE_DATE_YEAR as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static OTHER_WIDE_DATE_YEAR: OTHER_WIDE_DATE_YEAR = {
    let mut _0: output::time::OTHER_WIDE_DATE_YEAR;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = OTHER_WIDE_DATE_YEAR { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &OTHER_WIDE_DATE_YEAR) -> &DateFormat<'_> {
    debug self => _1;
    let mut _0: &datetime::fmt::DateFormat<'_>;

    bb0: {
        _0 = <OTHER_WIDE_DATE_YEAR as Deref>::deref::__stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__static_ref_initialize() -> DateFormat<'_> {
    let mut _0: datetime::fmt::DateFormat<'_>;
    let mut _1: std::result::Result<datetime::fmt::DateFormat<'_>, datetime::fmt::FormatError>;
    let _2: &str;

    bb0: {
        _2 = const "{2>:D} {:M} {5>:Y}";
        _1 = DateFormat::<'_>::parse(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<DateFormat<'_>, FormatError>::unwrap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability() -> &DateFormat<'_> {
    let mut _0: &datetime::fmt::DateFormat<'_>;
    let _1: &lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _1 = const {alloc99: &Lazy<DateFormat<'_>>};
        _0 = Lazy::<DateFormat<'_>>::get::<fn() -> DateFormat<'static> {<OTHER_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize}>(_1, <OTHER_WIDE_DATE_YEAR as Deref>::deref::__static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc99 (static: <OTHER_WIDE_DATE_YEAR as Deref>::deref::__stability::LAZY, size: 32, align: 8) {
    0x00  00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __  ........
    0x10  __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __  ....
}

static output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref::__stability::LAZY: Lazy<DateFormat<'_>> = {
    let mut _0: lazy_static::lazy::Lazy<datetime::fmt::DateFormat<'_>>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn output::time::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &OTHER_WIDE_DATE_YEAR) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &datetime::fmt::DateFormat<'_>;
    scope 1 {
    }

    bb0: {
        _2 = <OTHER_WIDE_DATE_YEAR as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:20:10: 20:19>::eq(_1: &TextCell, _2: &TextCell) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &output::cell::TextCellContents;
    let mut _5: &output::cell::TextCellContents;
    let mut _6: &output::cell::DisplayWidth;
    let mut _7: &output::cell::DisplayWidth;

    bb0: {
        _4 = &((*_1).0: output::cell::TextCellContents);
        _5 = &((*_2).0: output::cell::TextCellContents);
        _3 = <TextCellContents as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: output::cell::DisplayWidth);
        _7 = &((*_2).1: output::cell::DisplayWidth);
        _0 = <DisplayWidth as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:20:21: 20:26>::fmt(_1: &TextCell, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::cell::TextCellContents;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&output::cell::DisplayWidth;
    let _10: &output::cell::DisplayWidth;

    bb0: {
        _3 = const "TextCell";
        _4 = const "contents";
        _6 = &((*_1).0: output::cell::TextCellContents);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "width";
        _10 = &((*_1).1: output::cell::DisplayWidth);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:20:28: 20:33>::clone(_1: &TextCell) -> TextCell {
    debug self => _1;
    let mut _0: output::cell::TextCell;
    let mut _2: output::cell::TextCellContents;
    let _3: &output::cell::TextCellContents;
    let mut _4: output::cell::DisplayWidth;
    let _5: &output::cell::DisplayWidth;

    bb0: {
        _3 = &((*_1).0: output::cell::TextCellContents);
        _2 = <TextCellContents as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: output::cell::DisplayWidth);
        _4 = <DisplayWidth as Clone>::clone(_5) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = TextCell { contents: move _2, width: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn output::cell::<impl at src/output/cell.rs:20:35: 20:42>::default() -> TextCell {
    let mut _0: output::cell::TextCell;
    let mut _1: output::cell::TextCellContents;
    let mut _2: output::cell::DisplayWidth;

    bb0: {
        _1 = <TextCellContents as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <DisplayWidth as Default>::default() -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = TextCell { contents: move _1, width: move _2 };
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn output::cell::<impl at src/output/cell.rs:30:1: 30:24>::deref(_1: &TextCell) -> &TextCellContents {
    debug self => _1;
    let mut _0: &output::cell::TextCellContents;

    bb0: {
        _0 = &((*_1).0: output::cell::TextCellContents);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::paint(_1: Style, _2: String) -> TextCell {
    debug style => _1;
    debug text => _2;
    let mut _0: output::cell::TextCell;
    let _3: output::cell::DisplayWidth;
    let _4: &str;
    let mut _5: &std::string::String;
    let mut _6: output::cell::TextCellContents;
    let mut _7: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _8: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _9: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _10: usize;
    let mut _11: usize;
    let mut _12: *mut u8;
    let mut _13: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _14: ansi_term::ANSIGenericString<'_, str>;
    let mut _15: std::string::String;
    let mut _16: bool;
    let mut _17: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _18: ();
    let mut _19: *const [ansi_term::ANSIGenericString<'_, str>; 1];
    scope 1 {
        debug width => _3;
        let mut _20: *const ();
        let mut _21: usize;
        let mut _22: usize;
        let mut _23: usize;
        let mut _24: usize;
        let mut _25: bool;
        scope 2 {
        }
    }

    bb0: {
        _16 = const false;
        _16 = const true;
        _5 = &_2;
        _4 = <String as Deref>::deref(move _5) -> [return: bb1, unwind: bb10];
    }

    bb1: {
        _3 = <DisplayWidth as From<&str>>::from(_4) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _10 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _11 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _12 = alloc::alloc::exchange_malloc(move _10, move _11) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _13 = ShallowInitBox(move _12, [ansi_term::ANSIGenericString<'_, str>; 1]);
        _16 = const false;
        _15 = move _2;
        _14 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_1, move _15) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _19 = (((_13.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 1]);
        _20 = _19 as *const () (PtrToPtr);
        _21 = _20 as usize (Transmute);
        _22 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _23 = Sub(_22, const 1_usize);
        _24 = BitAnd(_21, _23);
        _25 = Eq(_24, const 0_usize);
        assert(_25, "misaligned pointer dereference: address must be a multiple of {} but is {}", _22, _21) -> [success: bb11, unwind unreachable];
    }

    bb5: {
        _6 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _7) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _0 = TextCell { contents: move _6, width: _3 };
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        _17 = &mut _13;
        _18 = <Box<[ANSIGenericString<'_, str>; 1]> as Drop>::drop(move _17) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_16) -> [0: bb7, otherwise: bb9];
    }

    bb11: {
        (*_19) = [move _14];
        _9 = move _13;
        _8 = move _9 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _7 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _8) -> [return: bb5, unwind: bb10];
    }

    bb12 (cleanup): {
        goto -> bb10;
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::paint_str(_1: Style, _2: &str) -> TextCell {
    debug style => _1;
    debug text => _2;
    let mut _0: output::cell::TextCell;
    let _3: output::cell::DisplayWidth;
    let mut _4: output::cell::TextCellContents;
    let mut _5: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _6: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _7: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: *mut u8;
    let mut _11: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _12: ansi_term::ANSIGenericString<'_, str>;
    let mut _13: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _14: ();
    let mut _15: *const [ansi_term::ANSIGenericString<'_, str>; 1];
    scope 1 {
        debug width => _3;
        let mut _16: *const ();
        let mut _17: usize;
        let mut _18: usize;
        let mut _19: usize;
        let mut _20: usize;
        let mut _21: bool;
        scope 2 {
        }
    }

    bb0: {
        _3 = <DisplayWidth as From<&str>>::from(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _9 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _10 = alloc::alloc::exchange_malloc(move _8, move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = ShallowInitBox(move _10, [ansi_term::ANSIGenericString<'_, str>; 1]);
        _12 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(_1, _2) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _15 = (((_11.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 1]);
        _16 = _15 as *const () (PtrToPtr);
        _17 = _16 as usize (Transmute);
        _18 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _19 = Sub(_18, const 1_usize);
        _20 = BitAnd(_17, _19);
        _21 = Eq(_20, const 0_usize);
        assert(_21, "misaligned pointer dereference: address must be a multiple of {} but is {}", _18, _17) -> [success: bb8, unwind unreachable];
    }

    bb4: {
        _4 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = TextCell { contents: move _4, width: _3 };
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        _13 = &mut _11;
        _14 = <Box<[ANSIGenericString<'_, str>; 1]> as Drop>::drop(move _13) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb8: {
        (*_15) = [move _12];
        _7 = move _11;
        _6 = move _7 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _5 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _6) -> [return: bb4, unwind continue];
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::blank(_1: Style) -> TextCell {
    debug style => _1;
    let mut _0: output::cell::TextCell;
    let mut _2: output::cell::TextCellContents;
    let mut _3: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _4: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]>;
    let mut _5: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: *mut u8;
    let mut _9: std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _10: ansi_term::ANSIGenericString<'_, str>;
    let mut _11: output::cell::DisplayWidth;
    let mut _12: &mut std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>; 1]>;
    let mut _13: ();
    let mut _14: *const [ansi_term::ANSIGenericString<'_, str>; 1];
    let mut _15: *const ();
    let mut _16: usize;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: bool;
    scope 1 {
    }

    bb0: {
        _6 = SizeOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _7 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _8 = alloc::alloc::exchange_malloc(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ShallowInitBox(move _8, [ansi_term::ANSIGenericString<'_, str>; 1]);
        _10 = ansi_term::display::<impl Style>::paint::<'_, &str, str>(_1, const "-") -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _14 = (((_9.0: std::ptr::Unique<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: std::ptr::NonNull<[ansi_term::ANSIGenericString<'_, str>; 1]>).0: *const [ansi_term::ANSIGenericString<'_, str>; 1]);
        _15 = _14 as *const () (PtrToPtr);
        _16 = _15 as usize (Transmute);
        _17 = AlignOf([ansi_term::ANSIGenericString<'_, str>; 1]);
        _18 = Sub(_17, const 1_usize);
        _19 = BitAnd(_16, _18);
        _20 = Eq(_19, const 0_usize);
        assert(_20, "misaligned pointer dereference: address must be a multiple of {} but is {}", _17, _16) -> [success: bb9, unwind unreachable];
    }

    bb3: {
        _2 = <Vec<ANSIGenericString<'_, str>> as Into<TextCellContents>>::into(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = <DisplayWidth as From<usize>>::from(const 1_usize) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = TextCell { contents: move _2, width: move _11 };
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        _12 = &mut _9;
        _13 = <Box<[ANSIGenericString<'_, str>; 1]> as Drop>::drop(move _12) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb9: {
        (*_14) = [move _10];
        _5 = move _9;
        _4 = move _5 as std::boxed::Box<[ansi_term::ANSIGenericString<'_, str>]> (PointerCoercion(Unsize));
        _3 = slice::<impl [ANSIGenericString<'_, str>]>::into_vec::<std::alloc::Global>(move _4) -> [return: bb3, unwind continue];
    }

    bb10 (cleanup): {
        goto -> bb7;
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::add_spaces(_1: &mut TextCell, _2: usize) -> () {
    debug self => _1;
    debug count => _2;
    let mut _0: ();
    let mut _3: &mut usize;
    let mut _4: &mut output::cell::DisplayWidth;
    let mut _5: (usize, bool);
    let _6: std::string::String;
    let mut _7: std::iter::Take<std::iter::Repeat<char>>;
    let mut _8: std::iter::Repeat<char>;
    let _9: ();
    let mut _10: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _11: ansi_term::ANSIGenericString<'_, str>;
    let mut _12: ansi_term::Style;
    let mut _13: std::string::String;
    let mut _14: bool;
    scope 1 {
        debug spaces => _6;
    }

    bb0: {
        _14 = const false;
        _4 = &mut ((*_1).1: output::cell::DisplayWidth);
        _3 = <DisplayWidth as DerefMut>::deref_mut(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = CheckedAdd((*_3), _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_3), _2) -> [success: bb2, unwind continue];
    }

    bb2: {
        (*_3) = move (_5.0: usize);
        _8 = std::iter::repeat::<char>(const ' ') -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = <std::iter::Repeat<char> as Iterator>::take(move _8, _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _14 = const true;
        _6 = <std::iter::Take<std::iter::Repeat<char>> as Iterator>::collect::<String>(move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = &mut (((*_1).0: output::cell::TextCellContents).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _12 = <Style as Default>::default() -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _14 = const false;
        _13 = move _6;
        _11 = ansi_term::display::<impl Style>::paint::<'_, String, str>(move _12, move _13) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _9 = Vec::<ANSIGenericString<'_, str>>::push(move _10, move _11) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _14 = const false;
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_6) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        switchInt(_14) -> [0: bb9, otherwise: bb10];
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::push(_1: &mut TextCell, _2: ANSIGenericString<'_, str>, _3: usize) -> () {
    debug self => _1;
    debug string => _2;
    debug extra_width => _3;
    let mut _0: ();
    let _4: ();
    let mut _5: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _6: &mut usize;
    let mut _7: &mut output::cell::DisplayWidth;
    let mut _8: (usize, bool);

    bb0: {
        _5 = &mut (((*_1).0: output::cell::TextCellContents).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _4 = Vec::<ANSIGenericString<'_, str>>::push(move _5, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &mut ((*_1).1: output::cell::DisplayWidth);
        _6 = <DisplayWidth as DerefMut>::deref_mut(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = CheckedAdd((*_6), _3);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_6), _3) -> [success: bb3, unwind continue];
    }

    bb3: {
        (*_6) = move (_8.0: usize);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:38:1: 38:14>::append(_1: &mut TextCell, _2: TextCell) -> () {
    debug self => _1;
    debug other => _2;
    let mut _0: ();
    let mut _3: usize;
    let mut _4: &usize;
    let mut _5: &output::cell::DisplayWidth;
    let mut _6: &mut usize;
    let mut _7: &mut output::cell::DisplayWidth;
    let mut _8: (usize, bool);
    let _9: ();
    let mut _10: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _11: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _12: bool;

    bb0: {
        _12 = const false;
        _12 = const true;
        _5 = &(_2.1: output::cell::DisplayWidth);
        _4 = <DisplayWidth as Deref>::deref(move _5) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _3 = (*_4);
        _7 = &mut ((*_1).1: output::cell::DisplayWidth);
        _6 = <DisplayWidth as DerefMut>::deref_mut(move _7) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _8 = CheckedAdd((*_6), _3);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_6), move _3) -> [success: bb3, unwind: bb7];
    }

    bb3: {
        (*_6) = move (_8.0: usize);
        _10 = &mut (((*_1).0: output::cell::TextCellContents).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _12 = const false;
        _11 = move ((_2.0: output::cell::TextCellContents).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _9 = <Vec<ANSIGenericString<'_, str>> as Extend<ANSIGenericString<'_, str>>>::extend::<Vec<ANSIGenericString<'_, str>>>(move _10, move _11) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        resume;
    }

    bb6 (cleanup): {
        drop(((_2.0: output::cell::TextCellContents).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>)) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        switchInt(_12) -> [0: bb5, otherwise: bb6];
    }
}

fn output::cell::<impl at src/output/cell.rs:135:10: 135:19>::eq(_1: &TextCellContents, _2: &TextCellContents) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _4: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _4 = &((*_2).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _0 = <Vec<ANSIGenericString<'_, str>> as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:135:21: 135:26>::fmt(_1: &TextCellContents, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let _6: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _3 = const "TextCellContents";
        _6 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:135:28: 135:33>::clone(_1: &TextCellContents) -> TextCellContents {
    debug self => _1;
    let mut _0: output::cell::TextCellContents;
    let mut _2: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let _3: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _2 = <Vec<ANSIGenericString<'_, str>> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = TextCellContents(move _2);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:135:35: 135:42>::default() -> TextCellContents {
    let mut _0: output::cell::TextCellContents;
    let mut _1: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _1 = <Vec<ANSIGenericString<'_, str>> as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = TextCellContents(move _1);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:138:1: 138:57>::from(_1: Vec<ANSIGenericString<'_, str>>) -> TextCellContents {
    debug strings => _1;
    let mut _0: output::cell::TextCellContents;

    bb0: {
        _0 = TextCellContents(move _1);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:144:1: 144:32>::deref(_1: &TextCellContents) -> &[ANSIGenericString<'_, str>] {
    debug self => _1;
    let mut _0: &[ansi_term::ANSIGenericString<'_, str>];
    let mut _2: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _2 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _0 = <Vec<ANSIGenericString<'_, str>> as Deref>::deref(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:156:1: 156:22>::strings(_1: &TextCellContents) -> ANSIGenericStrings<'_, str> {
    debug self => _1;
    let mut _0: ansi_term::ANSIGenericStrings<'_, str>;
    let _2: &[ansi_term::ANSIGenericString<'_, str>];
    let _3: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _2 = <Vec<ANSIGenericString<'_, str>> as Deref>::deref(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ANSIStrings(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:156:1: 156:22>::width(_1: &TextCellContents) -> DisplayWidth {
    debug self => _1;
    let mut _0: output::cell::DisplayWidth;
    let mut _2: std::iter::Map<std::slice::Iter<'_, ansi_term::ANSIGenericString<'_, str>>, {closure@src/output/cell.rs:168:18: 168:25}>;
    let mut _3: std::slice::Iter<'_, ansi_term::ANSIGenericString<'_, str>>;
    let _4: &[ansi_term::ANSIGenericString<'_, str>];
    let mut _5: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;

    bb0: {
        _5 = &((*_1).0: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>);
        _4 = <Vec<ANSIGenericString<'_, str>> as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = core::slice::<impl [ANSIGenericString<'_, str>]>::iter(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <std::slice::Iter<'_, ANSIGenericString<'_, str>> as Iterator>::map::<DisplayWidth, {closure@src/output/cell.rs:168:18: 168:25}>(move _3, const ZeroSized: {closure@src/output/cell.rs:168:18: 168:25}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <Map<std::slice::Iter<'_, ANSIGenericString<'_, str>>, {closure@src/output/cell.rs:168:18: 168:25}> as Iterator>::sum::<DisplayWidth>(move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:156:1: 156:22>::width::{closure#0}(_1: &mut {closure@src/output/cell.rs:168:18: 168:25}, _2: &ANSIGenericString<'_, str>) -> DisplayWidth {
    debug anstr => _2;
    let mut _0: output::cell::DisplayWidth;
    let _3: &str;

    bb0: {
        _3 = <ANSIGenericString<'_, str> as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <DisplayWidth as From<&str>>::from(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:156:1: 156:22>::promote(_1: TextCellContents) -> TextCell {
    debug self => _1;
    let mut _0: output::cell::TextCell;
    let mut _2: output::cell::DisplayWidth;
    let mut _3: &output::cell::TextCellContents;
    let mut _4: output::cell::TextCellContents;

    bb0: {
        _3 = &_1;
        _2 = TextCellContents::width(move _3) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _4 = move _1;
        _0 = TextCell { contents: move _4, width: move _2 };
        return;
    }

    bb2 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn output::cell::<impl at src/output/cell.rs:196:10: 196:19>::eq(_1: &DisplayWidth, _2: &DisplayWidth) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: usize;
    let mut _4: usize;

    bb0: {
        _3 = ((*_1).0: usize);
        _4 = ((*_2).0: usize);
        _0 = Eq(move _3, move _4);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:196:21: 196:26>::fmt(_1: &DisplayWidth, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&usize;
    let _6: &usize;

    bb0: {
        _3 = const "DisplayWidth";
        _6 = &((*_1).0: usize);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:196:28: 196:33>::clone(_1: &DisplayWidth) -> DisplayWidth {
    debug self => _1;
    let mut _0: output::cell::DisplayWidth;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:196:41: 196:48>::default() -> DisplayWidth {
    let mut _0: output::cell::DisplayWidth;
    let mut _1: usize;

    bb0: {
        _1 = <usize as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = DisplayWidth(move _1);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:199:1: 199:40>::from(_1: &str) -> DisplayWidth {
    debug input => _1;
    let mut _0: output::cell::DisplayWidth;
    let mut _2: usize;

    bb0: {
        _2 = <str as UnicodeWidthStr>::width(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = DisplayWidth(move _2);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:205:1: 205:34>::from(_1: usize) -> DisplayWidth {
    debug width => _1;
    let mut _0: output::cell::DisplayWidth;

    bb0: {
        _0 = DisplayWidth(_1);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:211:1: 211:28>::deref(_1: &DisplayWidth) -> &usize {
    debug self => _1;
    let mut _0: &usize;

    bb0: {
        _0 = &((*_1).0: usize);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:219:1: 219:31>::deref_mut(_1: &mut DisplayWidth) -> &mut usize {
    debug self => _1;
    let mut _0: &mut usize;

    bb0: {
        _0 = &mut ((*_1).0: usize);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:225:1: 225:26>::add(_1: DisplayWidth, _2: DisplayWidth) -> DisplayWidth {
    debug self => _1;
    debug rhs => _2;
    let mut _0: output::cell::DisplayWidth;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: (usize, bool);

    bb0: {
        _4 = (_1.0: usize);
        _5 = (_2.0: usize);
        _6 = CheckedAdd(_4, _5);
        assert(!move (_6.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, move _5) -> [success: bb1, unwind continue];
    }

    bb1: {
        _3 = move (_6.0: usize);
        _0 = DisplayWidth(move _3);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:233:1: 233:33>::add(_1: DisplayWidth, _2: usize) -> DisplayWidth {
    debug self => _1;
    debug rhs => _2;
    let mut _0: output::cell::DisplayWidth;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: (usize, bool);

    bb0: {
        _4 = (_1.0: usize);
        _5 = CheckedAdd(_4, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, _2) -> [success: bb1, unwind continue];
    }

    bb1: {
        _3 = move (_5.0: usize);
        _0 = DisplayWidth(move _3);
        return;
    }
}

fn output::cell::<impl at src/output/cell.rs:241:1: 241:26>::sum(_1: I) -> DisplayWidth {
    debug iter => _1;
    let mut _0: output::cell::DisplayWidth;
    let mut _2: output::cell::DisplayWidth;

    bb0: {
        _2 = DisplayWidth(const 0_usize);
        _0 = <I as Iterator>::fold::<DisplayWidth, fn(DisplayWidth, DisplayWidth) -> <DisplayWidth as Add>::Output {<DisplayWidth as Add>::add}>(move _1, move _2, <DisplayWidth as Add>::add) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn escape(_1: String, _2: &mut Vec<ANSIGenericString<'_, str>>, _3: Style, _4: Style) -> () {
    debug string => _1;
    debug bits => _2;
    debug good => _3;
    debug bad => _4;
    let mut _0: ();
    let mut _5: bool;
    let mut _6: &mut std::str::Chars<'_>;
    let mut _7: std::str::Chars<'_>;
    let _8: &str;
    let mut _9: &std::string::String;
    let _10: ();
    let mut _11: ansi_term::ANSIGenericString<'_, str>;
    let mut _12: std::string::String;
    let mut _13: std::str::Chars<'_>;
    let mut _14: std::str::Chars<'_>;
    let _15: &str;
    let mut _16: &std::string::String;
    let mut _17: std::str::Chars<'_>;
    let mut _18: std::option::Option<char>;
    let mut _19: &mut std::str::Chars<'_>;
    let mut _20: isize;
    let mut _22: bool;
    let mut _23: char;
    let mut _24: bool;
    let mut _25: char;
    let _27: ();
    let mut _28: &mut std::string::String;
    let _29: ();
    let mut _30: ansi_term::ANSIGenericString<'_, str>;
    let mut _31: std::string::String;
    let mut _33: std::char::EscapeDefault;
    let _34: ();
    let mut _35: ansi_term::ANSIGenericString<'_, str>;
    let mut _36: bool;
    let mut _37: bool;
    scope 1 {
        debug iter => _17;
        let _21: char;
        scope 2 {
            debug c => _21;
            let mut _26: std::string::String;
            let _32: std::string::String;
            scope 3 {
                debug s => _26;
            }
            scope 4 {
                debug s => _32;
            }
        }
    }

    bb0: {
        _37 = const false;
        _36 = const false;
        _37 = const true;
        _9 = &_1;
        _8 = <String as Deref>::deref(move _9) -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _7 = core::str::<impl str>::chars(_8) -> [return: bb2, unwind: bb30];
    }

    bb2: {
        _6 = &mut _7;
        _5 = <Chars<'_> as Iterator>::all::<{closure@src/output/escape.rs:5:27: 5:30}>(move _6, const ZeroSized: {closure@src/output/escape.rs:5:27: 5:30}) -> [return: bb3, unwind: bb30];
    }

    bb3: {
        switchInt(move _5) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _37 = const false;
        _12 = move _1;
        _11 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_3, move _12) -> [return: bb5, unwind: bb30];
    }

    bb5: {
        _10 = Vec::<ANSIGenericString<'_, str>>::push(_2, move _11) -> [return: bb31, unwind: bb30];
    }

    bb6: {
        _16 = &_1;
        _15 = <String as Deref>::deref(move _16) -> [return: bb7, unwind: bb30];
    }

    bb7: {
        _14 = core::str::<impl str>::chars(_15) -> [return: bb8, unwind: bb30];
    }

    bb8: {
        _13 = <Chars<'_> as IntoIterator>::into_iter(move _14) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _17 = move _13;
        goto -> bb10;
    }

    bb10: {
        _19 = &mut _17;
        _18 = <Chars<'_> as Iterator>::next(_19) -> [return: bb11, unwind: bb30];
    }

    bb11: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb14, 1: bb12, otherwise: bb13];
    }

    bb12: {
        _21 = ((_18 as Some).0: char);
        _23 = const 32_u8 as char (IntToInt);
        _22 = Ge(_21, move _23);
        switchInt(move _22) -> [0: bb21, otherwise: bb15];
    }

    bb13: {
        unreachable;
    }

    bb14: {
        drop(_1) -> [return: bb25, unwind continue];
    }

    bb15: {
        _25 = const 127_u8 as char (IntToInt);
        _24 = Ne(_21, move _25);
        switchInt(move _24) -> [0: bb21, otherwise: bb16];
    }

    bb16: {
        _26 = String::new() -> [return: bb17, unwind: bb30];
    }

    bb17: {
        _36 = const true;
        _28 = &mut _26;
        _27 = String::push(move _28, _21) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _36 = const false;
        _31 = move _26;
        _30 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_3, move _31) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _29 = Vec::<ANSIGenericString<'_, str>>::push(_2, move _30) -> [return: bb20, unwind: bb28];
    }

    bb20: {
        _36 = const false;
        goto -> bb10;
    }

    bb21: {
        _33 = char::methods::<impl char>::escape_default(_21) -> [return: bb22, unwind: bb30];
    }

    bb22: {
        _32 = <std::char::EscapeDefault as Iterator>::collect::<String>(move _33) -> [return: bb23, unwind: bb30];
    }

    bb23: {
        _35 = ansi_term::display::<impl Style>::paint::<'_, String, str>(_4, move _32) -> [return: bb24, unwind: bb30];
    }

    bb24: {
        _34 = Vec::<ANSIGenericString<'_, str>>::push(_2, move _35) -> [return: bb32, unwind: bb30];
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        drop(_26) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_36) -> [0: bb30, otherwise: bb27];
    }

    bb29 (cleanup): {
        drop(_1) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_37) -> [0: bb26, otherwise: bb29];
    }

    bb31: {
        goto -> bb25;
    }

    bb32: {
        goto -> bb10;
    }
}

fn escape::{closure#0}(_1: &mut {closure@src/output/escape.rs:5:27: 5:30}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: char;
    let mut _5: char;

    bb0: {
        _4 = const 32_u8 as char (IntToInt);
        _3 = Ge(_2, move _4);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _5 = const 127_u8 as char (IntToInt);
        _0 = Ne(_2, move _5);
        goto -> bb3;
    }

    bb2: {
        _0 = const false;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:42:10: 42:19>::eq(_1: &TreePart, _2: &TreePart) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:42:21: 42:26>::fmt(_1: &TreePart, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Blank";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Edge";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "Line";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "Corner";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:42:34: 42:39>::clone(_1: &TreePart) -> TreePart {
    debug self => _1;
    let mut _0: output::tree::TreePart;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:58:1: 58:14>::ascii_art(_1: TreePart) -> &str {
    debug self => _1;
    let mut _0: &str;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const "   ";
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const "";
        goto -> bb6;
    }

    bb4: {
        _0 = const "  ";
        goto -> bb6;
    }

    bb5: {
        _0 = const "";
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:74:10: 74:15>::fmt(_1: &TreeTrunk, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::vec::Vec<output::tree::TreePart>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::option::Option<output::tree::TreeParams>;
    let _10: &std::option::Option<output::tree::TreeParams>;

    bb0: {
        _3 = const "TreeTrunk";
        _4 = const "stack";
        _6 = &((*_1).0: std::vec::Vec<output::tree::TreePart>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "last_params";
        _10 = &((*_1).1: std::option::Option<output::tree::TreeParams>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:74:17: 74:24>::default() -> TreeTrunk {
    let mut _0: output::tree::TreeTrunk;
    let mut _1: std::vec::Vec<output::tree::TreePart>;
    let mut _2: std::option::Option<output::tree::TreeParams>;

    bb0: {
        _1 = <Vec<TreePart> as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Option<TreeParams> as Default>::default() -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = TreeTrunk { stack: move _1, last_params: move _2 };
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn tree::<impl at src/output/tree.rs:86:10: 86:15>::fmt(_1: &TreeParams, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::tree::TreeDepth;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&bool;
    let _10: &bool;

    bb0: {
        _3 = const "TreeParams";
        _4 = const "depth";
        _6 = &((*_1).0: output::tree::TreeDepth);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "last";
        _10 = &((*_1).1: bool);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:86:23: 86:28>::clone(_1: &TreeParams) -> TreeParams {
    debug self => _1;
    let mut _0: output::tree::TreeParams;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:97:10: 97:15>::fmt(_1: &TreeDepth, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&usize;
    let _6: &usize;

    bb0: {
        _3 = const "TreeDepth";
        _6 = &((*_1).0: usize);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:97:23: 97:28>::clone(_1: &TreeDepth) -> TreeDepth {
    debug self => _1;
    let mut _0: output::tree::TreeDepth;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:100:1: 100:15>::new_row(_1: &mut TreeTrunk, _2: TreeParams) -> &[TreePart] {
    debug self => _1;
    debug params => _2;
    let mut _0: &[output::tree::TreePart];
    let mut _3: isize;
    let mut _5: output::tree::TreePart;
    let mut _6: bool;
    let mut _7: &mut output::tree::TreePart;
    let mut _8: &mut std::vec::Vec<output::tree::TreePart>;
    let mut _9: usize;
    let _10: ();
    let mut _11: &mut std::vec::Vec<output::tree::TreePart>;
    let mut _12: usize;
    let mut _13: usize;
    let mut _14: (usize, bool);
    let mut _15: output::tree::TreePart;
    let mut _16: output::tree::TreePart;
    let mut _17: bool;
    let mut _18: &mut output::tree::TreePart;
    let mut _19: &mut std::vec::Vec<output::tree::TreePart>;
    let mut _20: usize;
    let mut _21: std::option::Option<output::tree::TreeParams>;
    let mut _22: &std::vec::Vec<output::tree::TreePart>;
    let mut _23: std::ops::RangeFrom<usize>;
    scope 1 {
        debug last => _4;
        let _4: output::tree::TreeParams;
    }

    bb0: {
        _3 = discriminant(((*_1).1: std::option::Option<output::tree::TreeParams>));
        switchInt(move _3) -> [1: bb1, otherwise: bb6];
    }

    bb1: {
        _4 = ((((*_1).1: std::option::Option<output::tree::TreeParams>) as Some).0: output::tree::TreeParams);
        _6 = (_4.1: bool);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = TreePart::Blank;
        goto -> bb4;
    }

    bb3: {
        _5 = TreePart::Line;
        goto -> bb4;
    }

    bb4: {
        _8 = &mut ((*_1).0: std::vec::Vec<output::tree::TreePart>);
        _9 = ((_4.0: output::tree::TreeDepth).0: usize);
        _7 = <Vec<TreePart> as IndexMut<usize>>::index_mut(move _8, move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        (*_7) = move _5;
        goto -> bb6;
    }

    bb6: {
        _11 = &mut ((*_1).0: std::vec::Vec<output::tree::TreePart>);
        _13 = ((_2.0: output::tree::TreeDepth).0: usize);
        _14 = CheckedAdd(_13, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", move _13, const 1_usize) -> [success: bb7, unwind continue];
    }

    bb7: {
        _12 = move (_14.0: usize);
        _15 = TreePart::Edge;
        _10 = Vec::<TreePart>::resize(move _11, move _12, move _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        _17 = (_2.1: bool);
        switchInt(move _17) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _16 = TreePart::Corner;
        goto -> bb11;
    }

    bb10: {
        _16 = TreePart::Edge;
        goto -> bb11;
    }

    bb11: {
        _19 = &mut ((*_1).0: std::vec::Vec<output::tree::TreePart>);
        _20 = ((_2.0: output::tree::TreeDepth).0: usize);
        _18 = <Vec<TreePart> as IndexMut<usize>>::index_mut(move _19, move _20) -> [return: bb12, unwind continue];
    }

    bb12: {
        (*_18) = move _16;
        _21 = Option::<TreeParams>::Some(_2);
        ((*_1).1: std::option::Option<output::tree::TreeParams>) = move _21;
        _22 = &((*_1).0: std::vec::Vec<output::tree::TreePart>);
        _23 = RangeFrom::<usize> { start: const 1_usize };
        _0 = <Vec<TreePart> as std::ops::Index<RangeFrom<usize>>>::index(move _22, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

fn tree::<impl at src/output/tree.rs:143:1: 143:16>::new(_1: TreeDepth, _2: bool) -> TreeParams {
    debug depth => _1;
    debug last => _2;
    let mut _0: output::tree::TreeParams;

    bb0: {
        _0 = TreeParams { depth: _1, last: _2 };
        return;
    }
}

fn tree::<impl at src/output/tree.rs:143:1: 143:16>::is_at_root(_1: &TreeParams) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: usize;

    bb0: {
        _2 = (((*_1).0: output::tree::TreeDepth).0: usize);
        _0 = Eq(move _2, const 0_usize);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:153:1: 153:15>::root() -> TreeDepth {
    let mut _0: output::tree::TreeDepth;

    bb0: {
        _0 = TreeDepth(const 0_usize);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:153:1: 153:15>::deeper(_1: TreeDepth) -> TreeDepth {
    debug self => _1;
    let mut _0: output::tree::TreeDepth;
    let mut _2: usize;
    let mut _3: usize;
    let mut _4: (usize, bool);

    bb0: {
        _3 = (_1.0: usize);
        _4 = CheckedAdd(_3, const 1_usize);
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_usize) -> [success: bb1, unwind continue];
    }

    bb1: {
        _2 = move (_4.0: usize);
        _0 = TreeDepth(move _2);
        return;
    }
}

fn tree::<impl at src/output/tree.rs:153:1: 153:15>::iterate_over(_1: TreeDepth, _2: I) -> tree::Iter<I> {
    debug self => _1;
    debug inner => _2;
    let mut _0: output::tree::Iter<I>;

    bb0: {
        _0 = tree::Iter::<I> { current_depth: _1, inner: move _2 };
        return;
    }
}

fn tree::<impl at src/output/tree.rs:177:1: 178:48>::next(_1: &mut tree::Iter<I>) -> Option<(TreeParams, T)> {
    debug self => _1;
    let mut _0: std::option::Option<(output::tree::TreeParams, T)>;
    let _2: T;
    let mut _3: std::ops::ControlFlow<std::option::Option<std::convert::Infallible>, T>;
    let mut _4: std::option::Option<T>;
    let mut _5: &mut I;
    let mut _6: isize;
    let _7: T;
    let mut _9: output::tree::TreeDepth;
    let mut _10: bool;
    let mut _11: usize;
    let mut _12: &I;
    let mut _13: (output::tree::TreeParams, T);
    let mut _14: T;
    scope 1 {
        debug t => _2;
        let _8: output::tree::TreeParams;
        scope 6 {
            debug params => _8;
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _5 = &mut ((*_1).1: I);
        _4 = <I as Iterator>::next(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Option<T> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: T);
        _2 = move _7;
        _9 = ((*_1).0: output::tree::TreeDepth);
        _12 = &((*_1).1: I);
        _11 = <I as ExactSizeIterator>::len(move _12) -> [return: bb6, unwind: bb9];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = <Option<(TreeParams, T)> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb8, unwind continue];
    }

    bb6: {
        _10 = Eq(move _11, const 0_usize);
        _8 = TreeParams::new(move _9, move _10) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _14 = move _2;
        _13 = (_8, move _14);
        _0 = Option::<(TreeParams, T)>::Some(move _13);
        goto -> bb8;
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn output::<impl at src/output/mod.rs:20:10: 20:15>::fmt(_1: &View, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &output::Mode;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &output::TerminalWidth;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&output::file_name::Options;
    let _13: &output::file_name::Options;

    bb0: {
        _3 = const "View";
        _4 = const "mode";
        _6 = &((*_1).0: output::Mode);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "width";
        _9 = &((*_1).1: output::TerminalWidth);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "file_style";
        _13 = &((*_1).2: output::file_name::Options);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:29:10: 29:19>::eq(_1: &output::Mode, _2: &output::Mode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&output::Mode, &output::Mode);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _17: &output::Mode;
    let mut _18: &output::Mode;
    let mut _19: &output::Mode;
    let mut _20: &output::Mode;
    let mut _21: &output::Mode;
    let mut _22: &output::Mode;
    let mut _23: &output::Mode;
    let mut _24: &output::Mode;
    let mut _25: &output::Mode;
    let mut _26: &output::Mode;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &output::grid::Options;
            let _12: &output::grid::Options;
            let _13: &output::details::Options;
            let _14: &output::details::Options;
            let _15: &output::grid_details::Options;
            let _16: &output::grid_details::Options;
            scope 3 {
                debug __self_0 => _11;
                debug __arg1_0 => _12;
            }
            scope 4 {
                debug __self_0 => _13;
                debug __arg1_0 => _14;
            }
            scope 5 {
                debug __self_0 => _15;
                debug __arg1_0 => _16;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _17 = deref_copy (_6.0: &output::Mode);
        _10 = discriminant((*_17));
        switchInt(move _10) -> [0: bb3, 1: bb5, 2: bb6, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb10;
    }

    bb3: {
        _18 = deref_copy (_6.1: &output::Mode);
        _7 = discriminant((*_18));
        switchInt(move _7) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb10;
    }

    bb5: {
        _19 = deref_copy (_6.1: &output::Mode);
        _8 = discriminant((*_19));
        switchInt(move _8) -> [1: bb8, otherwise: bb4];
    }

    bb6: {
        _20 = deref_copy (_6.1: &output::Mode);
        _9 = discriminant((*_20));
        switchInt(move _9) -> [2: bb9, otherwise: bb4];
    }

    bb7: {
        _21 = deref_copy (_6.0: &output::Mode);
        _11 = &(((*_21) as Grid).0: output::grid::Options);
        _22 = deref_copy (_6.1: &output::Mode);
        _12 = &(((*_22) as Grid).0: output::grid::Options);
        _0 = <grid::Options as PartialEq>::eq(_11, _12) -> [return: bb10, unwind continue];
    }

    bb8: {
        _23 = deref_copy (_6.0: &output::Mode);
        _13 = &(((*_23) as Details).0: output::details::Options);
        _24 = deref_copy (_6.1: &output::Mode);
        _14 = &(((*_24) as Details).0: output::details::Options);
        _0 = <details::Options as PartialEq>::eq(_13, _14) -> [return: bb10, unwind continue];
    }

    bb9: {
        _25 = deref_copy (_6.0: &output::Mode);
        _15 = &(((*_25) as GridDetails).0: output::grid_details::Options);
        _26 = deref_copy (_6.1: &output::Mode);
        _16 = &(((*_26) as GridDetails).0: output::grid_details::Options);
        _0 = <grid_details::Options as PartialEq>::eq(_15, _16) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:29:21: 29:26>::fmt(_1: &output::Mode, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &output::grid::Options;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&output::grid::Options;
    let _8: &output::details::Options;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&output::details::Options;
    let _12: &output::grid_details::Options;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&output::grid_details::Options;
    let _16: &str;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _16 = const "Lines";
        _0 = Formatter::<'_>::write_str(_2, _16) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Grid).0: output::grid::Options);
        _5 = const "Grid";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb6, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as Details).0: output::details::Options);
        _9 = const "Details";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb6, unwind continue];
    }

    bb5: {
        _12 = &(((*_1) as GridDetails).0: output::grid_details::Options);
        _13 = const "GridDetails";
        _15 = &_12;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:40:10: 40:19>::eq(_1: &TerminalWidth, _2: &TerminalWidth) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&output::TerminalWidth, &output::TerminalWidth);
    let mut _7: isize;
    let mut _8: isize;
    let mut _11: usize;
    let mut _12: usize;
    let mut _13: &output::TerminalWidth;
    let mut _14: &output::TerminalWidth;
    let mut _15: &output::TerminalWidth;
    let mut _16: &output::TerminalWidth;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _9: &usize;
            let _10: &usize;
            scope 3 {
                debug __self_0 => _9;
                debug __arg1_0 => _10;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _13 = deref_copy (_6.0: &output::TerminalWidth);
        _8 = discriminant((*_13));
        switchInt(move _8) -> [0: bb3, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb6;
    }

    bb3: {
        _14 = deref_copy (_6.1: &output::TerminalWidth);
        _7 = discriminant((*_14));
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb6;
    }

    bb5: {
        _15 = deref_copy (_6.0: &output::TerminalWidth);
        _9 = &(((*_15) as Set).0: usize);
        _16 = deref_copy (_6.1: &output::TerminalWidth);
        _10 = &(((*_16) as Set).0: usize);
        _11 = (*_9);
        _12 = (*_10);
        _0 = Eq(move _11, move _12);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:40:21: 40:26>::fmt(_1: &TerminalWidth, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &usize;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&usize;
    let _8: &str;
    scope 1 {
        debug __self_0 => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Automatic";
        _0 = Formatter::<'_>::write_str(_2, _8) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Set).0: usize);
        _5 = const "Set";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:40:34: 40:39>::clone(_1: &TerminalWidth) -> TerminalWidth {
    debug self => _1;
    let mut _0: output::TerminalWidth;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn output::<impl at src/output/mod.rs:50:1: 50:19>::actual_terminal_width(_1: TerminalWidth) -> Option<usize> {
    debug self => _1;
    let mut _0: std::option::Option<usize>;
    let mut _2: isize;
    let _3: usize;
    let mut _4: std::option::Option<(usize, usize)>;
    scope 1 {
        debug width => _3;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = dimensions_stdout() -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = ((_1 as Set).0: usize);
        _0 = Option::<usize>::Some(_3);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<(usize, usize)>::map::<usize, {closure@src/output/mod.rs:58:69: 58:72}>(move _4, const ZeroSized: {closure@src/output/mod.rs:58:69: 58:72}) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn output::<impl at src/output/mod.rs:50:1: 50:19>::actual_terminal_width::{closure#0}(_1: {closure@src/output/mod.rs:58:69: 58:72}, _2: (usize, usize)) -> usize {
    debug t => _2;
    let mut _0: usize;

    bb0: {
        _0 = (_2.0: usize);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:6:10: 6:15>::fmt(_1: &ui_styles::UiStyles, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 17];
    let _5: [&dyn std::fmt::Debug; 17];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &bool;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &theme::ui_styles::FileKinds;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &theme::ui_styles::Permissions;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &theme::ui_styles::Size;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &theme::ui_styles::Users;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &theme::ui_styles::Links;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &theme::ui_styles::Git;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &ansi_term::Style;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &ansi_term::Style;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &ansi_term::Style;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &ansi_term::Style;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &ansi_term::Style;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &ansi_term::Style;
    let mut _32: &dyn std::fmt::Debug;
    let _33: &ansi_term::Style;
    let mut _34: &dyn std::fmt::Debug;
    let _35: &ansi_term::Style;
    let mut _36: &dyn std::fmt::Debug;
    let _37: &ansi_term::Style;
    let mut _38: &dyn std::fmt::Debug;
    let _39: &&ansi_term::Style;
    let _40: &ansi_term::Style;
    let _41: &str;
    let mut _42: &[&str];
    let mut _43: &[&str; 17];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _43 = const _;
        _7 = &((*_1).0: bool);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: theme::ui_styles::FileKinds);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: theme::ui_styles::Permissions);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: theme::ui_styles::Size);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: theme::ui_styles::Users);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: theme::ui_styles::Links);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: theme::ui_styles::Git);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: ansi_term::Style);
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: ansi_term::Style);
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _25 = &((*_1).9: ansi_term::Style);
        _24 = _25 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _27 = &((*_1).10: ansi_term::Style);
        _26 = _27 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _29 = &((*_1).11: ansi_term::Style);
        _28 = _29 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _31 = &((*_1).12: ansi_term::Style);
        _30 = _31 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _33 = &((*_1).13: ansi_term::Style);
        _32 = _33 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _35 = &((*_1).14: ansi_term::Style);
        _34 = _35 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _37 = &((*_1).15: ansi_term::Style);
        _36 = _37 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _40 = &((*_1).16: ansi_term::Style);
        _39 = &_40;
        _38 = _39 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32, move _34, move _36, move _38];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _41 = const "UiStyles";
        _42 = _43 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _41, move _42, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in ui_styles::<impl at src/theme/ui_styles.rs:6:10: 6:15>::fmt: &[&str; 17] = {
    let mut _0: &[&str; 17];
    let mut _1: [&str; 17];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;
    let mut _26: &str;
    let mut _27: &str;
    let mut _28: &str;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;

    bb0: {
        _3 = const "filekinds";
        _2 = &(*_3);
        _5 = const "perms";
        _4 = &(*_5);
        _7 = const "size";
        _6 = &(*_7);
        _9 = const "users";
        _8 = &(*_9);
        _11 = const "links";
        _10 = &(*_11);
        _13 = const "git";
        _12 = &(*_13);
        _15 = const "punctuation";
        _14 = &(*_15);
        _17 = const "date";
        _16 = &(*_17);
        _19 = const "inode";
        _18 = &(*_19);
        _21 = const "blocks";
        _20 = &(*_21);
        _23 = const "header";
        _22 = &(*_23);
        _25 = const "octal";
        _24 = &(*_25);
        _27 = const "symlink_path";
        _26 = &(*_27);
        _29 = const "control_char";
        _28 = &(*_29);
        _31 = const "broken_symlink";
        _30 = &(*_31);
        _33 = const "broken_path_overlay";
        _32 = &(*_33);
        _1 = [const "colourful", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30, move _32];
        _0 = &_1;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:6:17: 6:24>::default() -> ui_styles::UiStyles {
    let mut _0: theme::ui_styles::UiStyles;
    let mut _1: bool;
    let mut _2: theme::ui_styles::FileKinds;
    let mut _3: theme::ui_styles::Permissions;
    let mut _4: theme::ui_styles::Size;
    let mut _5: theme::ui_styles::Users;
    let mut _6: theme::ui_styles::Links;
    let mut _7: theme::ui_styles::Git;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Style;
    let mut _13: ansi_term::Style;
    let mut _14: ansi_term::Style;
    let mut _15: ansi_term::Style;
    let mut _16: ansi_term::Style;
    let mut _17: ansi_term::Style;

    bb0: {
        _1 = <bool as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <ui_styles::FileKinds as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <ui_styles::Permissions as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <ui_styles::Size as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <ui_styles::Users as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <ui_styles::Links as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <ui_styles::Git as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = <Style as Default>::default() -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = <Style as Default>::default() -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = <Style as Default>::default() -> [return: bb10, unwind continue];
    }

    bb10: {
        _11 = <Style as Default>::default() -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = <Style as Default>::default() -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = <Style as Default>::default() -> [return: bb13, unwind continue];
    }

    bb13: {
        _14 = <Style as Default>::default() -> [return: bb14, unwind continue];
    }

    bb14: {
        _15 = <Style as Default>::default() -> [return: bb15, unwind continue];
    }

    bb15: {
        _16 = <Style as Default>::default() -> [return: bb16, unwind continue];
    }

    bb16: {
        _17 = <Style as Default>::default() -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = ui_styles::UiStyles { colourful: move _1, filekinds: move _2, perms: move _3, size: move _4, users: move _5, links: move _6, git: move _7, punctuation: move _8, date: move _9, inode: move _10, blocks: move _11, header: move _12, octal: move _13, symlink_path: move _14, control_char: move _15, broken_symlink: move _16, broken_path_overlay: move _17 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:6:26: 6:35>::eq(_1: &ui_styles::UiStyles, _2: &ui_styles::UiStyles) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: &theme::ui_styles::FileKinds;
    let mut _8: &theme::ui_styles::FileKinds;
    let mut _9: bool;
    let mut _10: &theme::ui_styles::Permissions;
    let mut _11: &theme::ui_styles::Permissions;
    let mut _12: bool;
    let mut _13: &theme::ui_styles::Size;
    let mut _14: &theme::ui_styles::Size;
    let mut _15: bool;
    let mut _16: &theme::ui_styles::Users;
    let mut _17: &theme::ui_styles::Users;
    let mut _18: bool;
    let mut _19: &theme::ui_styles::Links;
    let mut _20: &theme::ui_styles::Links;
    let mut _21: bool;
    let mut _22: &theme::ui_styles::Git;
    let mut _23: &theme::ui_styles::Git;
    let mut _24: bool;
    let mut _25: &ansi_term::Style;
    let mut _26: &ansi_term::Style;
    let mut _27: bool;
    let mut _28: &ansi_term::Style;
    let mut _29: &ansi_term::Style;
    let mut _30: bool;
    let mut _31: &ansi_term::Style;
    let mut _32: &ansi_term::Style;
    let mut _33: bool;
    let mut _34: &ansi_term::Style;
    let mut _35: &ansi_term::Style;
    let mut _36: bool;
    let mut _37: &ansi_term::Style;
    let mut _38: &ansi_term::Style;
    let mut _39: bool;
    let mut _40: &ansi_term::Style;
    let mut _41: &ansi_term::Style;
    let mut _42: bool;
    let mut _43: &ansi_term::Style;
    let mut _44: &ansi_term::Style;
    let mut _45: bool;
    let mut _46: &ansi_term::Style;
    let mut _47: &ansi_term::Style;
    let mut _48: bool;
    let mut _49: &ansi_term::Style;
    let mut _50: &ansi_term::Style;
    let mut _51: &ansi_term::Style;
    let mut _52: &ansi_term::Style;

    bb0: {
        _4 = ((*_1).0: bool);
        _5 = ((*_2).0: bool);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb32, otherwise: bb1];
    }

    bb1: {
        _7 = &((*_1).1: theme::ui_styles::FileKinds);
        _8 = &((*_2).1: theme::ui_styles::FileKinds);
        _6 = <ui_styles::FileKinds as PartialEq>::eq(move _7, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _6) -> [0: bb32, otherwise: bb3];
    }

    bb3: {
        _10 = &((*_1).2: theme::ui_styles::Permissions);
        _11 = &((*_2).2: theme::ui_styles::Permissions);
        _9 = <ui_styles::Permissions as PartialEq>::eq(move _10, move _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _9) -> [0: bb32, otherwise: bb5];
    }

    bb5: {
        _13 = &((*_1).3: theme::ui_styles::Size);
        _14 = &((*_2).3: theme::ui_styles::Size);
        _12 = <ui_styles::Size as PartialEq>::eq(move _13, move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _12) -> [0: bb32, otherwise: bb7];
    }

    bb7: {
        _16 = &((*_1).4: theme::ui_styles::Users);
        _17 = &((*_2).4: theme::ui_styles::Users);
        _15 = <ui_styles::Users as PartialEq>::eq(move _16, move _17) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _15) -> [0: bb32, otherwise: bb9];
    }

    bb9: {
        _19 = &((*_1).5: theme::ui_styles::Links);
        _20 = &((*_2).5: theme::ui_styles::Links);
        _18 = <ui_styles::Links as PartialEq>::eq(move _19, move _20) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _18) -> [0: bb32, otherwise: bb11];
    }

    bb11: {
        _22 = &((*_1).6: theme::ui_styles::Git);
        _23 = &((*_2).6: theme::ui_styles::Git);
        _21 = <ui_styles::Git as PartialEq>::eq(move _22, move _23) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _21) -> [0: bb32, otherwise: bb13];
    }

    bb13: {
        _25 = &((*_1).7: ansi_term::Style);
        _26 = &((*_2).7: ansi_term::Style);
        _24 = <Style as PartialEq>::eq(move _25, move _26) -> [return: bb14, unwind continue];
    }

    bb14: {
        switchInt(move _24) -> [0: bb32, otherwise: bb15];
    }

    bb15: {
        _28 = &((*_1).8: ansi_term::Style);
        _29 = &((*_2).8: ansi_term::Style);
        _27 = <Style as PartialEq>::eq(move _28, move _29) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _27) -> [0: bb32, otherwise: bb17];
    }

    bb17: {
        _31 = &((*_1).9: ansi_term::Style);
        _32 = &((*_2).9: ansi_term::Style);
        _30 = <Style as PartialEq>::eq(move _31, move _32) -> [return: bb18, unwind continue];
    }

    bb18: {
        switchInt(move _30) -> [0: bb32, otherwise: bb19];
    }

    bb19: {
        _34 = &((*_1).10: ansi_term::Style);
        _35 = &((*_2).10: ansi_term::Style);
        _33 = <Style as PartialEq>::eq(move _34, move _35) -> [return: bb20, unwind continue];
    }

    bb20: {
        switchInt(move _33) -> [0: bb32, otherwise: bb21];
    }

    bb21: {
        _37 = &((*_1).11: ansi_term::Style);
        _38 = &((*_2).11: ansi_term::Style);
        _36 = <Style as PartialEq>::eq(move _37, move _38) -> [return: bb22, unwind continue];
    }

    bb22: {
        switchInt(move _36) -> [0: bb32, otherwise: bb23];
    }

    bb23: {
        _40 = &((*_1).12: ansi_term::Style);
        _41 = &((*_2).12: ansi_term::Style);
        _39 = <Style as PartialEq>::eq(move _40, move _41) -> [return: bb24, unwind continue];
    }

    bb24: {
        switchInt(move _39) -> [0: bb32, otherwise: bb25];
    }

    bb25: {
        _43 = &((*_1).13: ansi_term::Style);
        _44 = &((*_2).13: ansi_term::Style);
        _42 = <Style as PartialEq>::eq(move _43, move _44) -> [return: bb26, unwind continue];
    }

    bb26: {
        switchInt(move _42) -> [0: bb32, otherwise: bb27];
    }

    bb27: {
        _46 = &((*_1).14: ansi_term::Style);
        _47 = &((*_2).14: ansi_term::Style);
        _45 = <Style as PartialEq>::eq(move _46, move _47) -> [return: bb28, unwind continue];
    }

    bb28: {
        switchInt(move _45) -> [0: bb32, otherwise: bb29];
    }

    bb29: {
        _49 = &((*_1).15: ansi_term::Style);
        _50 = &((*_2).15: ansi_term::Style);
        _48 = <Style as PartialEq>::eq(move _49, move _50) -> [return: bb30, unwind continue];
    }

    bb30: {
        switchInt(move _48) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _51 = &((*_1).16: ansi_term::Style);
        _52 = &((*_2).16: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _51, move _52) -> [return: bb33, unwind continue];
    }

    bb32: {
        _0 = const false;
        goto -> bb33;
    }

    bb33: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:30:10: 30:15>::clone(_1: &ui_styles::FileKinds) -> ui_styles::FileKinds {
    debug self => _1;
    let mut _0: theme::ui_styles::FileKinds;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:30:23: 30:28>::fmt(_1: &ui_styles::FileKinds, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 9];
    let _5: [&dyn std::fmt::Debug; 9];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &ansi_term::Style;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &ansi_term::Style;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &ansi_term::Style;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &ansi_term::Style;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &ansi_term::Style;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &ansi_term::Style;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &ansi_term::Style;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &ansi_term::Style;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &&ansi_term::Style;
    let _24: &ansi_term::Style;
    let _25: &str;
    let mut _26: &[&str];
    let mut _27: &[&str; 9];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _27 = const _;
        _7 = &((*_1).0: ansi_term::Style);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: ansi_term::Style);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: ansi_term::Style);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: ansi_term::Style);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: ansi_term::Style);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: ansi_term::Style);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: ansi_term::Style);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: ansi_term::Style);
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _24 = &((*_1).8: ansi_term::Style);
        _23 = &_24;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _25 = const "FileKinds";
        _26 = _27 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _25, move _26, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in ui_styles::<impl at src/theme/ui_styles.rs:30:23: 30:28>::fmt: &[&str; 9] = {
    let mut _0: &[&str; 9];
    let mut _1: [&str; 9];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;

    bb0: {
        _3 = const "directory";
        _2 = &(*_3);
        _5 = const "symlink";
        _4 = &(*_5);
        _7 = const "pipe";
        _6 = &(*_7);
        _9 = const "block_device";
        _8 = &(*_9);
        _11 = const "char_device";
        _10 = &(*_11);
        _13 = const "socket";
        _12 = &(*_13);
        _15 = const "special";
        _14 = &(*_15);
        _17 = const "executable";
        _16 = &(*_17);
        _1 = [const "normal", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16];
        _0 = &_1;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:30:30: 30:37>::default() -> ui_styles::FileKinds {
    let mut _0: theme::ui_styles::FileKinds;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Style as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Style as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <Style as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <Style as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <Style as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = <Style as Default>::default() -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = <Style as Default>::default() -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = ui_styles::FileKinds { normal: move _1, directory: move _2, symlink: move _3, pipe: move _4, block_device: move _5, char_device: move _6, socket: move _7, special: move _8, executable: move _9 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:30:39: 30:48>::eq(_1: &ui_styles::FileKinds, _2: &ui_styles::FileKinds) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: bool;
    let mut _7: &ansi_term::Style;
    let mut _8: &ansi_term::Style;
    let mut _9: bool;
    let mut _10: &ansi_term::Style;
    let mut _11: &ansi_term::Style;
    let mut _12: bool;
    let mut _13: &ansi_term::Style;
    let mut _14: &ansi_term::Style;
    let mut _15: bool;
    let mut _16: &ansi_term::Style;
    let mut _17: &ansi_term::Style;
    let mut _18: bool;
    let mut _19: &ansi_term::Style;
    let mut _20: &ansi_term::Style;
    let mut _21: bool;
    let mut _22: &ansi_term::Style;
    let mut _23: &ansi_term::Style;
    let mut _24: bool;
    let mut _25: &ansi_term::Style;
    let mut _26: &ansi_term::Style;
    let mut _27: &ansi_term::Style;
    let mut _28: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb17, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: ansi_term::Style);
        _8 = &((*_2).1: ansi_term::Style);
        _6 = <Style as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb17, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: ansi_term::Style);
        _11 = &((*_2).2: ansi_term::Style);
        _9 = <Style as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb17, otherwise: bb6];
    }

    bb6: {
        _13 = &((*_1).3: ansi_term::Style);
        _14 = &((*_2).3: ansi_term::Style);
        _12 = <Style as PartialEq>::eq(move _13, move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _12) -> [0: bb17, otherwise: bb8];
    }

    bb8: {
        _16 = &((*_1).4: ansi_term::Style);
        _17 = &((*_2).4: ansi_term::Style);
        _15 = <Style as PartialEq>::eq(move _16, move _17) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _15) -> [0: bb17, otherwise: bb10];
    }

    bb10: {
        _19 = &((*_1).5: ansi_term::Style);
        _20 = &((*_2).5: ansi_term::Style);
        _18 = <Style as PartialEq>::eq(move _19, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _18) -> [0: bb17, otherwise: bb12];
    }

    bb12: {
        _22 = &((*_1).6: ansi_term::Style);
        _23 = &((*_2).6: ansi_term::Style);
        _21 = <Style as PartialEq>::eq(move _22, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _21) -> [0: bb17, otherwise: bb14];
    }

    bb14: {
        _25 = &((*_1).7: ansi_term::Style);
        _26 = &((*_2).7: ansi_term::Style);
        _24 = <Style as PartialEq>::eq(move _25, move _26) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _24) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _27 = &((*_1).8: ansi_term::Style);
        _28 = &((*_2).8: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _27, move _28) -> [return: bb18, unwind continue];
    }

    bb17: {
        _0 = const false;
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:43:10: 43:15>::clone(_1: &ui_styles::Permissions) -> ui_styles::Permissions {
    debug self => _1;
    let mut _0: theme::ui_styles::Permissions;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:43:23: 43:28>::fmt(_1: &ui_styles::Permissions, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 13];
    let _5: [&dyn std::fmt::Debug; 13];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &ansi_term::Style;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &ansi_term::Style;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &ansi_term::Style;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &ansi_term::Style;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &ansi_term::Style;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &ansi_term::Style;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &ansi_term::Style;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &ansi_term::Style;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &ansi_term::Style;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &ansi_term::Style;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &ansi_term::Style;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &ansi_term::Style;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &&ansi_term::Style;
    let _32: &ansi_term::Style;
    let _33: &str;
    let mut _34: &[&str];
    let mut _35: &[&str; 13];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _35 = const _;
        _7 = &((*_1).0: ansi_term::Style);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: ansi_term::Style);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: ansi_term::Style);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: ansi_term::Style);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: ansi_term::Style);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: ansi_term::Style);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: ansi_term::Style);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: ansi_term::Style);
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: ansi_term::Style);
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _25 = &((*_1).9: ansi_term::Style);
        _24 = _25 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _27 = &((*_1).10: ansi_term::Style);
        _26 = _27 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _29 = &((*_1).11: ansi_term::Style);
        _28 = _29 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _32 = &((*_1).12: ansi_term::Style);
        _31 = &_32;
        _30 = _31 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28, move _30];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _33 = const "Permissions";
        _34 = _35 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _33, move _34, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in ui_styles::<impl at src/theme/ui_styles.rs:43:23: 43:28>::fmt: &[&str; 13] = {
    let mut _0: &[&str; 13];
    let mut _1: [&str; 13];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;
    let mut _24: &str;
    let mut _25: &str;

    bb0: {
        _3 = const "user_write";
        _2 = &(*_3);
        _5 = const "user_execute_file";
        _4 = &(*_5);
        _7 = const "user_execute_other";
        _6 = &(*_7);
        _9 = const "group_read";
        _8 = &(*_9);
        _11 = const "group_write";
        _10 = &(*_11);
        _13 = const "group_execute";
        _12 = &(*_13);
        _15 = const "other_read";
        _14 = &(*_15);
        _17 = const "other_write";
        _16 = &(*_17);
        _19 = const "other_execute";
        _18 = &(*_19);
        _21 = const "special_user_file";
        _20 = &(*_21);
        _23 = const "special_other";
        _22 = &(*_23);
        _25 = const "attribute";
        _24 = &(*_25);
        _1 = [const "user_read", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24];
        _0 = &_1;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:43:30: 43:37>::default() -> ui_styles::Permissions {
    let mut _0: theme::ui_styles::Permissions;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Style;
    let mut _13: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Style as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Style as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <Style as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <Style as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <Style as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = <Style as Default>::default() -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = <Style as Default>::default() -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = <Style as Default>::default() -> [return: bb10, unwind continue];
    }

    bb10: {
        _11 = <Style as Default>::default() -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = <Style as Default>::default() -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = <Style as Default>::default() -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = ui_styles::Permissions { user_read: move _1, user_write: move _2, user_execute_file: move _3, user_execute_other: move _4, group_read: move _5, group_write: move _6, group_execute: move _7, other_read: move _8, other_write: move _9, other_execute: move _10, special_user_file: move _11, special_other: move _12, attribute: move _13 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:43:39: 43:48>::eq(_1: &ui_styles::Permissions, _2: &ui_styles::Permissions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: bool;
    let mut _7: &ansi_term::Style;
    let mut _8: &ansi_term::Style;
    let mut _9: bool;
    let mut _10: &ansi_term::Style;
    let mut _11: &ansi_term::Style;
    let mut _12: bool;
    let mut _13: &ansi_term::Style;
    let mut _14: &ansi_term::Style;
    let mut _15: bool;
    let mut _16: &ansi_term::Style;
    let mut _17: &ansi_term::Style;
    let mut _18: bool;
    let mut _19: &ansi_term::Style;
    let mut _20: &ansi_term::Style;
    let mut _21: bool;
    let mut _22: &ansi_term::Style;
    let mut _23: &ansi_term::Style;
    let mut _24: bool;
    let mut _25: &ansi_term::Style;
    let mut _26: &ansi_term::Style;
    let mut _27: bool;
    let mut _28: &ansi_term::Style;
    let mut _29: &ansi_term::Style;
    let mut _30: bool;
    let mut _31: &ansi_term::Style;
    let mut _32: &ansi_term::Style;
    let mut _33: bool;
    let mut _34: &ansi_term::Style;
    let mut _35: &ansi_term::Style;
    let mut _36: bool;
    let mut _37: &ansi_term::Style;
    let mut _38: &ansi_term::Style;
    let mut _39: &ansi_term::Style;
    let mut _40: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb25, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: ansi_term::Style);
        _8 = &((*_2).1: ansi_term::Style);
        _6 = <Style as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb25, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: ansi_term::Style);
        _11 = &((*_2).2: ansi_term::Style);
        _9 = <Style as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb25, otherwise: bb6];
    }

    bb6: {
        _13 = &((*_1).3: ansi_term::Style);
        _14 = &((*_2).3: ansi_term::Style);
        _12 = <Style as PartialEq>::eq(move _13, move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _12) -> [0: bb25, otherwise: bb8];
    }

    bb8: {
        _16 = &((*_1).4: ansi_term::Style);
        _17 = &((*_2).4: ansi_term::Style);
        _15 = <Style as PartialEq>::eq(move _16, move _17) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _15) -> [0: bb25, otherwise: bb10];
    }

    bb10: {
        _19 = &((*_1).5: ansi_term::Style);
        _20 = &((*_2).5: ansi_term::Style);
        _18 = <Style as PartialEq>::eq(move _19, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _18) -> [0: bb25, otherwise: bb12];
    }

    bb12: {
        _22 = &((*_1).6: ansi_term::Style);
        _23 = &((*_2).6: ansi_term::Style);
        _21 = <Style as PartialEq>::eq(move _22, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _21) -> [0: bb25, otherwise: bb14];
    }

    bb14: {
        _25 = &((*_1).7: ansi_term::Style);
        _26 = &((*_2).7: ansi_term::Style);
        _24 = <Style as PartialEq>::eq(move _25, move _26) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _24) -> [0: bb25, otherwise: bb16];
    }

    bb16: {
        _28 = &((*_1).8: ansi_term::Style);
        _29 = &((*_2).8: ansi_term::Style);
        _27 = <Style as PartialEq>::eq(move _28, move _29) -> [return: bb17, unwind continue];
    }

    bb17: {
        switchInt(move _27) -> [0: bb25, otherwise: bb18];
    }

    bb18: {
        _31 = &((*_1).9: ansi_term::Style);
        _32 = &((*_2).9: ansi_term::Style);
        _30 = <Style as PartialEq>::eq(move _31, move _32) -> [return: bb19, unwind continue];
    }

    bb19: {
        switchInt(move _30) -> [0: bb25, otherwise: bb20];
    }

    bb20: {
        _34 = &((*_1).10: ansi_term::Style);
        _35 = &((*_2).10: ansi_term::Style);
        _33 = <Style as PartialEq>::eq(move _34, move _35) -> [return: bb21, unwind continue];
    }

    bb21: {
        switchInt(move _33) -> [0: bb25, otherwise: bb22];
    }

    bb22: {
        _37 = &((*_1).11: ansi_term::Style);
        _38 = &((*_2).11: ansi_term::Style);
        _36 = <Style as PartialEq>::eq(move _37, move _38) -> [return: bb23, unwind continue];
    }

    bb23: {
        switchInt(move _36) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _39 = &((*_1).12: ansi_term::Style);
        _40 = &((*_2).12: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _39, move _40) -> [return: bb26, unwind continue];
    }

    bb25: {
        _0 = const false;
        goto -> bb26;
    }

    bb26: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:64:10: 64:15>::clone(_1: &ui_styles::Size) -> ui_styles::Size {
    debug self => _1;
    let mut _0: theme::ui_styles::Size;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:64:23: 64:28>::fmt(_1: &ui_styles::Size, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 12];
    let _5: [&dyn std::fmt::Debug; 12];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &ansi_term::Style;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &ansi_term::Style;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &ansi_term::Style;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &ansi_term::Style;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &ansi_term::Style;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &ansi_term::Style;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &ansi_term::Style;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &ansi_term::Style;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &ansi_term::Style;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &ansi_term::Style;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &ansi_term::Style;
    let mut _28: &dyn std::fmt::Debug;
    let _29: &&ansi_term::Style;
    let _30: &ansi_term::Style;
    let _31: &str;
    let mut _32: &[&str];
    let mut _33: &[&str; 12];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _33 = const _;
        _7 = &((*_1).0: ansi_term::Style);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: ansi_term::Style);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: ansi_term::Style);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: ansi_term::Style);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: ansi_term::Style);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: ansi_term::Style);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = &((*_1).6: ansi_term::Style);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &((*_1).7: ansi_term::Style);
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _23 = &((*_1).8: ansi_term::Style);
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _25 = &((*_1).9: ansi_term::Style);
        _24 = _25 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _27 = &((*_1).10: ansi_term::Style);
        _26 = _27 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _30 = &((*_1).11: ansi_term::Style);
        _29 = &_30;
        _28 = _29 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22, move _24, move _26, move _28];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _31 = const "Size";
        _32 = _33 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _31, move _32, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in ui_styles::<impl at src/theme/ui_styles.rs:64:23: 64:28>::fmt: &[&str; 12] = {
    let mut _0: &[&str; 12];
    let mut _1: [&str; 12];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;
    let mut _14: &str;
    let mut _15: &str;
    let mut _16: &str;
    let mut _17: &str;
    let mut _18: &str;
    let mut _19: &str;
    let mut _20: &str;
    let mut _21: &str;
    let mut _22: &str;
    let mut _23: &str;

    bb0: {
        _3 = const "minor";
        _2 = &(*_3);
        _5 = const "number_byte";
        _4 = &(*_5);
        _7 = const "number_kilo";
        _6 = &(*_7);
        _9 = const "number_mega";
        _8 = &(*_9);
        _11 = const "number_giga";
        _10 = &(*_11);
        _13 = const "number_huge";
        _12 = &(*_13);
        _15 = const "unit_byte";
        _14 = &(*_15);
        _17 = const "unit_kilo";
        _16 = &(*_17);
        _19 = const "unit_mega";
        _18 = &(*_19);
        _21 = const "unit_giga";
        _20 = &(*_21);
        _23 = const "unit_huge";
        _22 = &(*_23);
        _1 = [const "major", move _2, move _4, move _6, move _8, move _10, move _12, move _14, move _16, move _18, move _20, move _22];
        _0 = &_1;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:64:30: 64:37>::default() -> ui_styles::Size {
    let mut _0: theme::ui_styles::Size;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Style as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Style as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <Style as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <Style as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <Style as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = <Style as Default>::default() -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = <Style as Default>::default() -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = <Style as Default>::default() -> [return: bb10, unwind continue];
    }

    bb10: {
        _11 = <Style as Default>::default() -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = <Style as Default>::default() -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = ui_styles::Size { major: move _1, minor: move _2, number_byte: move _3, number_kilo: move _4, number_mega: move _5, number_giga: move _6, number_huge: move _7, unit_byte: move _8, unit_kilo: move _9, unit_mega: move _10, unit_giga: move _11, unit_huge: move _12 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:64:39: 64:48>::eq(_1: &ui_styles::Size, _2: &ui_styles::Size) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: bool;
    let mut _7: &ansi_term::Style;
    let mut _8: &ansi_term::Style;
    let mut _9: bool;
    let mut _10: &ansi_term::Style;
    let mut _11: &ansi_term::Style;
    let mut _12: bool;
    let mut _13: &ansi_term::Style;
    let mut _14: &ansi_term::Style;
    let mut _15: bool;
    let mut _16: &ansi_term::Style;
    let mut _17: &ansi_term::Style;
    let mut _18: bool;
    let mut _19: &ansi_term::Style;
    let mut _20: &ansi_term::Style;
    let mut _21: bool;
    let mut _22: &ansi_term::Style;
    let mut _23: &ansi_term::Style;
    let mut _24: bool;
    let mut _25: &ansi_term::Style;
    let mut _26: &ansi_term::Style;
    let mut _27: bool;
    let mut _28: &ansi_term::Style;
    let mut _29: &ansi_term::Style;
    let mut _30: bool;
    let mut _31: &ansi_term::Style;
    let mut _32: &ansi_term::Style;
    let mut _33: bool;
    let mut _34: &ansi_term::Style;
    let mut _35: &ansi_term::Style;
    let mut _36: &ansi_term::Style;
    let mut _37: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb23, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: ansi_term::Style);
        _8 = &((*_2).1: ansi_term::Style);
        _6 = <Style as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb23, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: ansi_term::Style);
        _11 = &((*_2).2: ansi_term::Style);
        _9 = <Style as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb23, otherwise: bb6];
    }

    bb6: {
        _13 = &((*_1).3: ansi_term::Style);
        _14 = &((*_2).3: ansi_term::Style);
        _12 = <Style as PartialEq>::eq(move _13, move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _12) -> [0: bb23, otherwise: bb8];
    }

    bb8: {
        _16 = &((*_1).4: ansi_term::Style);
        _17 = &((*_2).4: ansi_term::Style);
        _15 = <Style as PartialEq>::eq(move _16, move _17) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _15) -> [0: bb23, otherwise: bb10];
    }

    bb10: {
        _19 = &((*_1).5: ansi_term::Style);
        _20 = &((*_2).5: ansi_term::Style);
        _18 = <Style as PartialEq>::eq(move _19, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _18) -> [0: bb23, otherwise: bb12];
    }

    bb12: {
        _22 = &((*_1).6: ansi_term::Style);
        _23 = &((*_2).6: ansi_term::Style);
        _21 = <Style as PartialEq>::eq(move _22, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _21) -> [0: bb23, otherwise: bb14];
    }

    bb14: {
        _25 = &((*_1).7: ansi_term::Style);
        _26 = &((*_2).7: ansi_term::Style);
        _24 = <Style as PartialEq>::eq(move _25, move _26) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _24) -> [0: bb23, otherwise: bb16];
    }

    bb16: {
        _28 = &((*_1).8: ansi_term::Style);
        _29 = &((*_2).8: ansi_term::Style);
        _27 = <Style as PartialEq>::eq(move _28, move _29) -> [return: bb17, unwind continue];
    }

    bb17: {
        switchInt(move _27) -> [0: bb23, otherwise: bb18];
    }

    bb18: {
        _31 = &((*_1).9: ansi_term::Style);
        _32 = &((*_2).9: ansi_term::Style);
        _30 = <Style as PartialEq>::eq(move _31, move _32) -> [return: bb19, unwind continue];
    }

    bb19: {
        switchInt(move _30) -> [0: bb23, otherwise: bb20];
    }

    bb20: {
        _34 = &((*_1).10: ansi_term::Style);
        _35 = &((*_2).10: ansi_term::Style);
        _33 = <Style as PartialEq>::eq(move _34, move _35) -> [return: bb21, unwind continue];
    }

    bb21: {
        switchInt(move _33) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _36 = &((*_1).11: ansi_term::Style);
        _37 = &((*_2).11: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _36, move _37) -> [return: bb24, unwind continue];
    }

    bb23: {
        _0 = const false;
        goto -> bb24;
    }

    bb24: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:82:10: 82:15>::clone(_1: &ui_styles::Users) -> ui_styles::Users {
    debug self => _1;
    let mut _0: theme::ui_styles::Users;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:82:23: 82:28>::fmt(_1: &ui_styles::Users, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &ansi_term::Style;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &ansi_term::Style;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &ansi_term::Style;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&ansi_term::Style;
    let _16: &ansi_term::Style;

    bb0: {
        _3 = const "Users";
        _4 = const "user_you";
        _6 = &((*_1).0: ansi_term::Style);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "user_someone_else";
        _9 = &((*_1).1: ansi_term::Style);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "group_yours";
        _12 = &((*_1).2: ansi_term::Style);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "group_not_yours";
        _16 = &((*_1).3: ansi_term::Style);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:82:30: 82:37>::default() -> ui_styles::Users {
    let mut _0: theme::ui_styles::Users;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Style as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Style as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = ui_styles::Users { user_you: move _1, user_someone_else: move _2, group_yours: move _3, group_not_yours: move _4 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:82:39: 82:48>::eq(_1: &ui_styles::Users, _2: &ui_styles::Users) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: bool;
    let mut _7: &ansi_term::Style;
    let mut _8: &ansi_term::Style;
    let mut _9: bool;
    let mut _10: &ansi_term::Style;
    let mut _11: &ansi_term::Style;
    let mut _12: &ansi_term::Style;
    let mut _13: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: ansi_term::Style);
        _8 = &((*_2).1: ansi_term::Style);
        _6 = <Style as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: ansi_term::Style);
        _11 = &((*_2).2: ansi_term::Style);
        _9 = <Style as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _12 = &((*_1).3: ansi_term::Style);
        _13 = &((*_2).3: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _12, move _13) -> [return: bb8, unwind continue];
    }

    bb7: {
        _0 = const false;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:90:10: 90:15>::clone(_1: &ui_styles::Links) -> ui_styles::Links {
    debug self => _1;
    let mut _0: theme::ui_styles::Links;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:90:23: 90:28>::fmt(_1: &ui_styles::Links, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &ansi_term::Style;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&ansi_term::Style;
    let _10: &ansi_term::Style;

    bb0: {
        _3 = const "Links";
        _4 = const "normal";
        _6 = &((*_1).0: ansi_term::Style);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "multi_link_file";
        _10 = &((*_1).1: ansi_term::Style);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:90:30: 90:37>::default() -> ui_styles::Links {
    let mut _0: theme::ui_styles::Links;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = ui_styles::Links { normal: move _1, multi_link_file: move _2 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:90:39: 90:48>::eq(_1: &ui_styles::Links, _2: &ui_styles::Links) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: &ansi_term::Style;
    let mut _7: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: ansi_term::Style);
        _7 = &((*_2).1: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:96:10: 96:15>::clone(_1: &ui_styles::Git) -> ui_styles::Git {
    debug self => _1;
    let mut _0: theme::ui_styles::Git;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:96:23: 96:28>::fmt(_1: &ui_styles::Git, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 7];
    let _5: [&dyn std::fmt::Debug; 7];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &ansi_term::Style;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &ansi_term::Style;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &ansi_term::Style;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &ansi_term::Style;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &ansi_term::Style;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &ansi_term::Style;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&ansi_term::Style;
    let _20: &ansi_term::Style;
    let _21: &str;
    let mut _22: &[&str];
    let mut _23: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _23 = const _;
        _7 = &((*_1).0: ansi_term::Style);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: ansi_term::Style);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: ansi_term::Style);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: ansi_term::Style);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: ansi_term::Style);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: ansi_term::Style);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _20 = &((*_1).6: ansi_term::Style);
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _21 = const "Git";
        _22 = _23 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _21, move _22, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in ui_styles::<impl at src/theme/ui_styles.rs:96:23: 96:28>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "modified";
        _2 = &(*_3);
        _5 = const "deleted";
        _4 = &(*_5);
        _7 = const "renamed";
        _6 = &(*_7);
        _9 = const "typechange";
        _8 = &(*_9);
        _11 = const "ignored";
        _10 = &(*_11);
        _13 = const "conflicted";
        _12 = &(*_13);
        _1 = [const "new", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:96:30: 96:37>::default() -> ui_styles::Git {
    let mut _0: theme::ui_styles::Git;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Style;

    bb0: {
        _1 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Style as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Style as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Style as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <Style as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <Style as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <Style as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = ui_styles::Git { new: move _1, modified: move _2, deleted: move _3, renamed: move _4, typechange: move _5, ignored: move _6, conflicted: move _7 };
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:96:39: 96:48>::eq(_1: &ui_styles::Git, _2: &ui_styles::Git) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &ansi_term::Style;
    let mut _5: &ansi_term::Style;
    let mut _6: bool;
    let mut _7: &ansi_term::Style;
    let mut _8: &ansi_term::Style;
    let mut _9: bool;
    let mut _10: &ansi_term::Style;
    let mut _11: &ansi_term::Style;
    let mut _12: bool;
    let mut _13: &ansi_term::Style;
    let mut _14: &ansi_term::Style;
    let mut _15: bool;
    let mut _16: &ansi_term::Style;
    let mut _17: &ansi_term::Style;
    let mut _18: bool;
    let mut _19: &ansi_term::Style;
    let mut _20: &ansi_term::Style;
    let mut _21: &ansi_term::Style;
    let mut _22: &ansi_term::Style;

    bb0: {
        _4 = &((*_1).0: ansi_term::Style);
        _5 = &((*_2).0: ansi_term::Style);
        _3 = <Style as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb13, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: ansi_term::Style);
        _8 = &((*_2).1: ansi_term::Style);
        _6 = <Style as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb13, otherwise: bb4];
    }

    bb4: {
        _10 = &((*_1).2: ansi_term::Style);
        _11 = &((*_2).2: ansi_term::Style);
        _9 = <Style as PartialEq>::eq(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _9) -> [0: bb13, otherwise: bb6];
    }

    bb6: {
        _13 = &((*_1).3: ansi_term::Style);
        _14 = &((*_2).3: ansi_term::Style);
        _12 = <Style as PartialEq>::eq(move _13, move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _12) -> [0: bb13, otherwise: bb8];
    }

    bb8: {
        _16 = &((*_1).4: ansi_term::Style);
        _17 = &((*_2).4: ansi_term::Style);
        _15 = <Style as PartialEq>::eq(move _16, move _17) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _15) -> [0: bb13, otherwise: bb10];
    }

    bb10: {
        _19 = &((*_1).5: ansi_term::Style);
        _20 = &((*_2).5: ansi_term::Style);
        _18 = <Style as PartialEq>::eq(move _19, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _18) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _21 = &((*_1).6: ansi_term::Style);
        _22 = &((*_2).6: ansi_term::Style);
        _0 = <Style as PartialEq>::eq(move _21, move _22) -> [return: bb14, unwind continue];
    }

    bb13: {
        _0 = const false;
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:107:1: 107:14>::plain() -> ui_styles::UiStyles {
    let mut _0: theme::ui_styles::UiStyles;

    bb0: {
        _0 = <ui_styles::UiStyles as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:114:1: 114:14>::set_ls(_1: &mut ui_styles::UiStyles, _2: &Pair<'_>) -> bool {
    debug self => _1;
    debug pair => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: ansi_term::Style;
    let mut _13: ansi_term::Style;
    let mut _14: ansi_term::Style;
    let mut _15: ansi_term::Style;
    let mut _16: ansi_term::Style;
    let mut _17: ansi_term::Style;
    let mut _18: ansi_term::Style;
    let mut _19: ansi_term::Style;
    let mut _20: ansi_term::Style;

    bb0: {
        _11 = <str as PartialEq>::eq(((*_2).0: &str), const "di") -> [return: bb27, unwind continue];
    }

    bb1: {
        _12 = Pair::<'_>::to_style(_2) -> [return: bb28, unwind continue];
    }

    bb2: {
        _10 = <str as PartialEq>::eq(((*_2).0: &str), const "ex") -> [return: bb26, unwind continue];
    }

    bb3: {
        _13 = Pair::<'_>::to_style(_2) -> [return: bb29, unwind continue];
    }

    bb4: {
        _9 = <str as PartialEq>::eq(((*_2).0: &str), const "fi") -> [return: bb25, unwind continue];
    }

    bb5: {
        _14 = Pair::<'_>::to_style(_2) -> [return: bb30, unwind continue];
    }

    bb6: {
        _8 = <str as PartialEq>::eq(((*_2).0: &str), const "pi") -> [return: bb24, unwind continue];
    }

    bb7: {
        _15 = Pair::<'_>::to_style(_2) -> [return: bb31, unwind continue];
    }

    bb8: {
        _7 = <str as PartialEq>::eq(((*_2).0: &str), const "so") -> [return: bb23, unwind continue];
    }

    bb9: {
        _16 = Pair::<'_>::to_style(_2) -> [return: bb32, unwind continue];
    }

    bb10: {
        _6 = <str as PartialEq>::eq(((*_2).0: &str), const "bd") -> [return: bb22, unwind continue];
    }

    bb11: {
        _17 = Pair::<'_>::to_style(_2) -> [return: bb33, unwind continue];
    }

    bb12: {
        _5 = <str as PartialEq>::eq(((*_2).0: &str), const "cd") -> [return: bb21, unwind continue];
    }

    bb13: {
        _18 = Pair::<'_>::to_style(_2) -> [return: bb34, unwind continue];
    }

    bb14: {
        _4 = <str as PartialEq>::eq(((*_2).0: &str), const "ln") -> [return: bb20, unwind continue];
    }

    bb15: {
        _19 = Pair::<'_>::to_style(_2) -> [return: bb35, unwind continue];
    }

    bb16: {
        _3 = <str as PartialEq>::eq(((*_2).0: &str), const "or") -> [return: bb19, unwind continue];
    }

    bb17: {
        _20 = Pair::<'_>::to_style(_2) -> [return: bb36, unwind continue];
    }

    bb18: {
        _0 = const false;
        goto -> bb38;
    }

    bb19: {
        switchInt(move _3) -> [0: bb18, otherwise: bb17];
    }

    bb20: {
        switchInt(move _4) -> [0: bb16, otherwise: bb15];
    }

    bb21: {
        switchInt(move _5) -> [0: bb14, otherwise: bb13];
    }

    bb22: {
        switchInt(move _6) -> [0: bb12, otherwise: bb11];
    }

    bb23: {
        switchInt(move _7) -> [0: bb10, otherwise: bb9];
    }

    bb24: {
        switchInt(move _8) -> [0: bb8, otherwise: bb7];
    }

    bb25: {
        switchInt(move _9) -> [0: bb6, otherwise: bb5];
    }

    bb26: {
        switchInt(move _10) -> [0: bb4, otherwise: bb3];
    }

    bb27: {
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb28: {
        (((*_1).1: theme::ui_styles::FileKinds).1: ansi_term::Style) = move _12;
        goto -> bb37;
    }

    bb29: {
        (((*_1).1: theme::ui_styles::FileKinds).8: ansi_term::Style) = move _13;
        goto -> bb37;
    }

    bb30: {
        (((*_1).1: theme::ui_styles::FileKinds).0: ansi_term::Style) = move _14;
        goto -> bb37;
    }

    bb31: {
        (((*_1).1: theme::ui_styles::FileKinds).3: ansi_term::Style) = move _15;
        goto -> bb37;
    }

    bb32: {
        (((*_1).1: theme::ui_styles::FileKinds).6: ansi_term::Style) = move _16;
        goto -> bb37;
    }

    bb33: {
        (((*_1).1: theme::ui_styles::FileKinds).4: ansi_term::Style) = move _17;
        goto -> bb37;
    }

    bb34: {
        (((*_1).1: theme::ui_styles::FileKinds).5: ansi_term::Style) = move _18;
        goto -> bb37;
    }

    bb35: {
        (((*_1).1: theme::ui_styles::FileKinds).2: ansi_term::Style) = move _19;
        goto -> bb37;
    }

    bb36: {
        ((*_1).15: ansi_term::Style) = move _20;
        goto -> bb37;
    }

    bb37: {
        _0 = const true;
        goto -> bb38;
    }

    bb38: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:114:1: 114:14>::set_exa(_1: &mut ui_styles::UiStyles, _2: &Pair<'_>) -> bool {
    debug self => _1;
    debug pair => _2;
    let mut _0: bool;
    let _3: ();
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    let mut _50: ansi_term::Style;
    let mut _51: ansi_term::Style;
    let mut _52: ansi_term::Style;
    let mut _53: ansi_term::Style;
    let mut _54: ansi_term::Style;
    let mut _55: ansi_term::Style;
    let mut _56: ansi_term::Style;
    let mut _57: ansi_term::Style;
    let mut _58: ansi_term::Style;
    let mut _59: ansi_term::Style;
    let mut _60: ansi_term::Style;
    let mut _61: ansi_term::Style;
    let mut _62: ansi_term::Style;
    let mut _63: ansi_term::Style;
    let mut _64: ansi_term::Style;
    let mut _65: ansi_term::Style;
    let mut _66: ansi_term::Style;
    let mut _67: ansi_term::Style;
    let mut _68: ansi_term::Style;
    let mut _69: ansi_term::Style;
    let mut _70: ansi_term::Style;
    let mut _71: ansi_term::Style;
    let mut _72: ansi_term::Style;
    let mut _73: ansi_term::Style;
    let mut _74: ansi_term::Style;
    let mut _75: ansi_term::Style;
    let mut _76: ansi_term::Style;
    let mut _77: ansi_term::Style;
    let mut _78: ansi_term::Style;
    let mut _79: ansi_term::Style;
    let mut _80: ansi_term::Style;
    let mut _81: ansi_term::Style;
    let mut _82: ansi_term::Style;
    let mut _83: ansi_term::Style;
    let mut _84: ansi_term::Style;
    let mut _85: ansi_term::Style;
    let mut _86: ansi_term::Style;
    let mut _87: ansi_term::Style;
    let mut _88: ansi_term::Style;
    let mut _89: ansi_term::Style;
    let mut _90: ansi_term::Style;
    let mut _91: ansi_term::Style;
    let mut _92: ansi_term::Style;
    let mut _93: ansi_term::Style;
    let mut _94: ansi_term::Style;
    let mut _95: ansi_term::Style;

    bb0: {
        _49 = <str as PartialEq>::eq(((*_2).0: &str), const "ur") -> [return: bb138, unwind continue];
    }

    bb1: {
        _50 = Pair::<'_>::to_style(_2) -> [return: bb139, unwind continue];
    }

    bb2: {
        _48 = <str as PartialEq>::eq(((*_2).0: &str), const "uw") -> [return: bb137, unwind continue];
    }

    bb3: {
        _51 = Pair::<'_>::to_style(_2) -> [return: bb140, unwind continue];
    }

    bb4: {
        _47 = <str as PartialEq>::eq(((*_2).0: &str), const "ux") -> [return: bb136, unwind continue];
    }

    bb5: {
        _52 = Pair::<'_>::to_style(_2) -> [return: bb141, unwind continue];
    }

    bb6: {
        _46 = <str as PartialEq>::eq(((*_2).0: &str), const "ue") -> [return: bb135, unwind continue];
    }

    bb7: {
        _53 = Pair::<'_>::to_style(_2) -> [return: bb142, unwind continue];
    }

    bb8: {
        _45 = <str as PartialEq>::eq(((*_2).0: &str), const "gr") -> [return: bb134, unwind continue];
    }

    bb9: {
        _54 = Pair::<'_>::to_style(_2) -> [return: bb143, unwind continue];
    }

    bb10: {
        _44 = <str as PartialEq>::eq(((*_2).0: &str), const "gw") -> [return: bb133, unwind continue];
    }

    bb11: {
        _55 = Pair::<'_>::to_style(_2) -> [return: bb144, unwind continue];
    }

    bb12: {
        _43 = <str as PartialEq>::eq(((*_2).0: &str), const "gx") -> [return: bb132, unwind continue];
    }

    bb13: {
        _56 = Pair::<'_>::to_style(_2) -> [return: bb145, unwind continue];
    }

    bb14: {
        _42 = <str as PartialEq>::eq(((*_2).0: &str), const "tr") -> [return: bb131, unwind continue];
    }

    bb15: {
        _57 = Pair::<'_>::to_style(_2) -> [return: bb146, unwind continue];
    }

    bb16: {
        _41 = <str as PartialEq>::eq(((*_2).0: &str), const "tw") -> [return: bb130, unwind continue];
    }

    bb17: {
        _58 = Pair::<'_>::to_style(_2) -> [return: bb147, unwind continue];
    }

    bb18: {
        _40 = <str as PartialEq>::eq(((*_2).0: &str), const "tx") -> [return: bb129, unwind continue];
    }

    bb19: {
        _59 = Pair::<'_>::to_style(_2) -> [return: bb148, unwind continue];
    }

    bb20: {
        _39 = <str as PartialEq>::eq(((*_2).0: &str), const "su") -> [return: bb128, unwind continue];
    }

    bb21: {
        _60 = Pair::<'_>::to_style(_2) -> [return: bb149, unwind continue];
    }

    bb22: {
        _38 = <str as PartialEq>::eq(((*_2).0: &str), const "sf") -> [return: bb127, unwind continue];
    }

    bb23: {
        _61 = Pair::<'_>::to_style(_2) -> [return: bb150, unwind continue];
    }

    bb24: {
        _37 = <str as PartialEq>::eq(((*_2).0: &str), const "xa") -> [return: bb126, unwind continue];
    }

    bb25: {
        _62 = Pair::<'_>::to_style(_2) -> [return: bb151, unwind continue];
    }

    bb26: {
        _36 = <str as PartialEq>::eq(((*_2).0: &str), const "sn") -> [return: bb125, unwind continue];
    }

    bb27: {
        _63 = Pair::<'_>::to_style(_2) -> [return: bb152, unwind continue];
    }

    bb28: {
        _35 = <str as PartialEq>::eq(((*_2).0: &str), const "sb") -> [return: bb124, unwind continue];
    }

    bb29: {
        _64 = Pair::<'_>::to_style(_2) -> [return: bb153, unwind continue];
    }

    bb30: {
        _34 = <str as PartialEq>::eq(((*_2).0: &str), const "nb") -> [return: bb123, unwind continue];
    }

    bb31: {
        _65 = Pair::<'_>::to_style(_2) -> [return: bb154, unwind continue];
    }

    bb32: {
        _33 = <str as PartialEq>::eq(((*_2).0: &str), const "nk") -> [return: bb122, unwind continue];
    }

    bb33: {
        _66 = Pair::<'_>::to_style(_2) -> [return: bb155, unwind continue];
    }

    bb34: {
        _32 = <str as PartialEq>::eq(((*_2).0: &str), const "nm") -> [return: bb121, unwind continue];
    }

    bb35: {
        _67 = Pair::<'_>::to_style(_2) -> [return: bb156, unwind continue];
    }

    bb36: {
        _31 = <str as PartialEq>::eq(((*_2).0: &str), const "ng") -> [return: bb120, unwind continue];
    }

    bb37: {
        _68 = Pair::<'_>::to_style(_2) -> [return: bb157, unwind continue];
    }

    bb38: {
        _30 = <str as PartialEq>::eq(((*_2).0: &str), const "nh") -> [return: bb119, unwind continue];
    }

    bb39: {
        _69 = Pair::<'_>::to_style(_2) -> [return: bb158, unwind continue];
    }

    bb40: {
        _29 = <str as PartialEq>::eq(((*_2).0: &str), const "ub") -> [return: bb118, unwind continue];
    }

    bb41: {
        _70 = Pair::<'_>::to_style(_2) -> [return: bb159, unwind continue];
    }

    bb42: {
        _28 = <str as PartialEq>::eq(((*_2).0: &str), const "uk") -> [return: bb117, unwind continue];
    }

    bb43: {
        _71 = Pair::<'_>::to_style(_2) -> [return: bb160, unwind continue];
    }

    bb44: {
        _27 = <str as PartialEq>::eq(((*_2).0: &str), const "um") -> [return: bb116, unwind continue];
    }

    bb45: {
        _72 = Pair::<'_>::to_style(_2) -> [return: bb161, unwind continue];
    }

    bb46: {
        _26 = <str as PartialEq>::eq(((*_2).0: &str), const "ug") -> [return: bb115, unwind continue];
    }

    bb47: {
        _73 = Pair::<'_>::to_style(_2) -> [return: bb162, unwind continue];
    }

    bb48: {
        _25 = <str as PartialEq>::eq(((*_2).0: &str), const "uh") -> [return: bb114, unwind continue];
    }

    bb49: {
        _74 = Pair::<'_>::to_style(_2) -> [return: bb163, unwind continue];
    }

    bb50: {
        _24 = <str as PartialEq>::eq(((*_2).0: &str), const "df") -> [return: bb113, unwind continue];
    }

    bb51: {
        _75 = Pair::<'_>::to_style(_2) -> [return: bb164, unwind continue];
    }

    bb52: {
        _23 = <str as PartialEq>::eq(((*_2).0: &str), const "ds") -> [return: bb112, unwind continue];
    }

    bb53: {
        _76 = Pair::<'_>::to_style(_2) -> [return: bb165, unwind continue];
    }

    bb54: {
        _22 = <str as PartialEq>::eq(((*_2).0: &str), const "uu") -> [return: bb111, unwind continue];
    }

    bb55: {
        _77 = Pair::<'_>::to_style(_2) -> [return: bb166, unwind continue];
    }

    bb56: {
        _21 = <str as PartialEq>::eq(((*_2).0: &str), const "un") -> [return: bb110, unwind continue];
    }

    bb57: {
        _78 = Pair::<'_>::to_style(_2) -> [return: bb167, unwind continue];
    }

    bb58: {
        _20 = <str as PartialEq>::eq(((*_2).0: &str), const "gu") -> [return: bb109, unwind continue];
    }

    bb59: {
        _79 = Pair::<'_>::to_style(_2) -> [return: bb168, unwind continue];
    }

    bb60: {
        _19 = <str as PartialEq>::eq(((*_2).0: &str), const "gn") -> [return: bb108, unwind continue];
    }

    bb61: {
        _80 = Pair::<'_>::to_style(_2) -> [return: bb169, unwind continue];
    }

    bb62: {
        _18 = <str as PartialEq>::eq(((*_2).0: &str), const "lc") -> [return: bb107, unwind continue];
    }

    bb63: {
        _81 = Pair::<'_>::to_style(_2) -> [return: bb170, unwind continue];
    }

    bb64: {
        _17 = <str as PartialEq>::eq(((*_2).0: &str), const "lm") -> [return: bb106, unwind continue];
    }

    bb65: {
        _82 = Pair::<'_>::to_style(_2) -> [return: bb171, unwind continue];
    }

    bb66: {
        _16 = <str as PartialEq>::eq(((*_2).0: &str), const "ga") -> [return: bb105, unwind continue];
    }

    bb67: {
        _83 = Pair::<'_>::to_style(_2) -> [return: bb172, unwind continue];
    }

    bb68: {
        _15 = <str as PartialEq>::eq(((*_2).0: &str), const "gm") -> [return: bb104, unwind continue];
    }

    bb69: {
        _84 = Pair::<'_>::to_style(_2) -> [return: bb173, unwind continue];
    }

    bb70: {
        _14 = <str as PartialEq>::eq(((*_2).0: &str), const "gd") -> [return: bb103, unwind continue];
    }

    bb71: {
        _85 = Pair::<'_>::to_style(_2) -> [return: bb174, unwind continue];
    }

    bb72: {
        _13 = <str as PartialEq>::eq(((*_2).0: &str), const "gv") -> [return: bb102, unwind continue];
    }

    bb73: {
        _86 = Pair::<'_>::to_style(_2) -> [return: bb175, unwind continue];
    }

    bb74: {
        _12 = <str as PartialEq>::eq(((*_2).0: &str), const "gt") -> [return: bb101, unwind continue];
    }

    bb75: {
        _87 = Pair::<'_>::to_style(_2) -> [return: bb176, unwind continue];
    }

    bb76: {
        _11 = <str as PartialEq>::eq(((*_2).0: &str), const "xx") -> [return: bb100, unwind continue];
    }

    bb77: {
        _88 = Pair::<'_>::to_style(_2) -> [return: bb177, unwind continue];
    }

    bb78: {
        _10 = <str as PartialEq>::eq(((*_2).0: &str), const "da") -> [return: bb99, unwind continue];
    }

    bb79: {
        _89 = Pair::<'_>::to_style(_2) -> [return: bb178, unwind continue];
    }

    bb80: {
        _9 = <str as PartialEq>::eq(((*_2).0: &str), const "in") -> [return: bb98, unwind continue];
    }

    bb81: {
        _90 = Pair::<'_>::to_style(_2) -> [return: bb179, unwind continue];
    }

    bb82: {
        _8 = <str as PartialEq>::eq(((*_2).0: &str), const "bl") -> [return: bb97, unwind continue];
    }

    bb83: {
        _91 = Pair::<'_>::to_style(_2) -> [return: bb180, unwind continue];
    }

    bb84: {
        _7 = <str as PartialEq>::eq(((*_2).0: &str), const "hd") -> [return: bb96, unwind continue];
    }

    bb85: {
        _92 = Pair::<'_>::to_style(_2) -> [return: bb181, unwind continue];
    }

    bb86: {
        _6 = <str as PartialEq>::eq(((*_2).0: &str), const "lp") -> [return: bb95, unwind continue];
    }

    bb87: {
        _93 = Pair::<'_>::to_style(_2) -> [return: bb182, unwind continue];
    }

    bb88: {
        _5 = <str as PartialEq>::eq(((*_2).0: &str), const "cc") -> [return: bb94, unwind continue];
    }

    bb89: {
        _94 = Pair::<'_>::to_style(_2) -> [return: bb183, unwind continue];
    }

    bb90: {
        _4 = <str as PartialEq>::eq(((*_2).0: &str), const "bO") -> [return: bb93, unwind continue];
    }

    bb91: {
        _95 = Pair::<'_>::to_style(_2) -> [return: bb184, unwind continue];
    }

    bb92: {
        _0 = const false;
        goto -> bb186;
    }

    bb93: {
        switchInt(move _4) -> [0: bb92, otherwise: bb91];
    }

    bb94: {
        switchInt(move _5) -> [0: bb90, otherwise: bb89];
    }

    bb95: {
        switchInt(move _6) -> [0: bb88, otherwise: bb87];
    }

    bb96: {
        switchInt(move _7) -> [0: bb86, otherwise: bb85];
    }

    bb97: {
        switchInt(move _8) -> [0: bb84, otherwise: bb83];
    }

    bb98: {
        switchInt(move _9) -> [0: bb82, otherwise: bb81];
    }

    bb99: {
        switchInt(move _10) -> [0: bb80, otherwise: bb79];
    }

    bb100: {
        switchInt(move _11) -> [0: bb78, otherwise: bb77];
    }

    bb101: {
        switchInt(move _12) -> [0: bb76, otherwise: bb75];
    }

    bb102: {
        switchInt(move _13) -> [0: bb74, otherwise: bb73];
    }

    bb103: {
        switchInt(move _14) -> [0: bb72, otherwise: bb71];
    }

    bb104: {
        switchInt(move _15) -> [0: bb70, otherwise: bb69];
    }

    bb105: {
        switchInt(move _16) -> [0: bb68, otherwise: bb67];
    }

    bb106: {
        switchInt(move _17) -> [0: bb66, otherwise: bb65];
    }

    bb107: {
        switchInt(move _18) -> [0: bb64, otherwise: bb63];
    }

    bb108: {
        switchInt(move _19) -> [0: bb62, otherwise: bb61];
    }

    bb109: {
        switchInt(move _20) -> [0: bb60, otherwise: bb59];
    }

    bb110: {
        switchInt(move _21) -> [0: bb58, otherwise: bb57];
    }

    bb111: {
        switchInt(move _22) -> [0: bb56, otherwise: bb55];
    }

    bb112: {
        switchInt(move _23) -> [0: bb54, otherwise: bb53];
    }

    bb113: {
        switchInt(move _24) -> [0: bb52, otherwise: bb51];
    }

    bb114: {
        switchInt(move _25) -> [0: bb50, otherwise: bb49];
    }

    bb115: {
        switchInt(move _26) -> [0: bb48, otherwise: bb47];
    }

    bb116: {
        switchInt(move _27) -> [0: bb46, otherwise: bb45];
    }

    bb117: {
        switchInt(move _28) -> [0: bb44, otherwise: bb43];
    }

    bb118: {
        switchInt(move _29) -> [0: bb42, otherwise: bb41];
    }

    bb119: {
        switchInt(move _30) -> [0: bb40, otherwise: bb39];
    }

    bb120: {
        switchInt(move _31) -> [0: bb38, otherwise: bb37];
    }

    bb121: {
        switchInt(move _32) -> [0: bb36, otherwise: bb35];
    }

    bb122: {
        switchInt(move _33) -> [0: bb34, otherwise: bb33];
    }

    bb123: {
        switchInt(move _34) -> [0: bb32, otherwise: bb31];
    }

    bb124: {
        switchInt(move _35) -> [0: bb30, otherwise: bb29];
    }

    bb125: {
        switchInt(move _36) -> [0: bb28, otherwise: bb27];
    }

    bb126: {
        switchInt(move _37) -> [0: bb26, otherwise: bb25];
    }

    bb127: {
        switchInt(move _38) -> [0: bb24, otherwise: bb23];
    }

    bb128: {
        switchInt(move _39) -> [0: bb22, otherwise: bb21];
    }

    bb129: {
        switchInt(move _40) -> [0: bb20, otherwise: bb19];
    }

    bb130: {
        switchInt(move _41) -> [0: bb18, otherwise: bb17];
    }

    bb131: {
        switchInt(move _42) -> [0: bb16, otherwise: bb15];
    }

    bb132: {
        switchInt(move _43) -> [0: bb14, otherwise: bb13];
    }

    bb133: {
        switchInt(move _44) -> [0: bb12, otherwise: bb11];
    }

    bb134: {
        switchInt(move _45) -> [0: bb10, otherwise: bb9];
    }

    bb135: {
        switchInt(move _46) -> [0: bb8, otherwise: bb7];
    }

    bb136: {
        switchInt(move _47) -> [0: bb6, otherwise: bb5];
    }

    bb137: {
        switchInt(move _48) -> [0: bb4, otherwise: bb3];
    }

    bb138: {
        switchInt(move _49) -> [0: bb2, otherwise: bb1];
    }

    bb139: {
        (((*_1).2: theme::ui_styles::Permissions).0: ansi_term::Style) = move _50;
        goto -> bb185;
    }

    bb140: {
        (((*_1).2: theme::ui_styles::Permissions).1: ansi_term::Style) = move _51;
        goto -> bb185;
    }

    bb141: {
        (((*_1).2: theme::ui_styles::Permissions).2: ansi_term::Style) = move _52;
        goto -> bb185;
    }

    bb142: {
        (((*_1).2: theme::ui_styles::Permissions).3: ansi_term::Style) = move _53;
        goto -> bb185;
    }

    bb143: {
        (((*_1).2: theme::ui_styles::Permissions).4: ansi_term::Style) = move _54;
        goto -> bb185;
    }

    bb144: {
        (((*_1).2: theme::ui_styles::Permissions).5: ansi_term::Style) = move _55;
        goto -> bb185;
    }

    bb145: {
        (((*_1).2: theme::ui_styles::Permissions).6: ansi_term::Style) = move _56;
        goto -> bb185;
    }

    bb146: {
        (((*_1).2: theme::ui_styles::Permissions).7: ansi_term::Style) = move _57;
        goto -> bb185;
    }

    bb147: {
        (((*_1).2: theme::ui_styles::Permissions).8: ansi_term::Style) = move _58;
        goto -> bb185;
    }

    bb148: {
        (((*_1).2: theme::ui_styles::Permissions).9: ansi_term::Style) = move _59;
        goto -> bb185;
    }

    bb149: {
        (((*_1).2: theme::ui_styles::Permissions).10: ansi_term::Style) = move _60;
        goto -> bb185;
    }

    bb150: {
        (((*_1).2: theme::ui_styles::Permissions).11: ansi_term::Style) = move _61;
        goto -> bb185;
    }

    bb151: {
        (((*_1).2: theme::ui_styles::Permissions).12: ansi_term::Style) = move _62;
        goto -> bb185;
    }

    bb152: {
        _3 = ui_styles::UiStyles::set_number_style(_1, move _63) -> [return: bb185, unwind continue];
    }

    bb153: {
        _3 = ui_styles::UiStyles::set_unit_style(_1, move _64) -> [return: bb185, unwind continue];
    }

    bb154: {
        (((*_1).3: theme::ui_styles::Size).2: ansi_term::Style) = move _65;
        goto -> bb185;
    }

    bb155: {
        (((*_1).3: theme::ui_styles::Size).3: ansi_term::Style) = move _66;
        goto -> bb185;
    }

    bb156: {
        (((*_1).3: theme::ui_styles::Size).4: ansi_term::Style) = move _67;
        goto -> bb185;
    }

    bb157: {
        (((*_1).3: theme::ui_styles::Size).5: ansi_term::Style) = move _68;
        goto -> bb185;
    }

    bb158: {
        (((*_1).3: theme::ui_styles::Size).6: ansi_term::Style) = move _69;
        goto -> bb185;
    }

    bb159: {
        (((*_1).3: theme::ui_styles::Size).7: ansi_term::Style) = move _70;
        goto -> bb185;
    }

    bb160: {
        (((*_1).3: theme::ui_styles::Size).8: ansi_term::Style) = move _71;
        goto -> bb185;
    }

    bb161: {
        (((*_1).3: theme::ui_styles::Size).9: ansi_term::Style) = move _72;
        goto -> bb185;
    }

    bb162: {
        (((*_1).3: theme::ui_styles::Size).10: ansi_term::Style) = move _73;
        goto -> bb185;
    }

    bb163: {
        (((*_1).3: theme::ui_styles::Size).11: ansi_term::Style) = move _74;
        goto -> bb185;
    }

    bb164: {
        (((*_1).3: theme::ui_styles::Size).0: ansi_term::Style) = move _75;
        goto -> bb185;
    }

    bb165: {
        (((*_1).3: theme::ui_styles::Size).1: ansi_term::Style) = move _76;
        goto -> bb185;
    }

    bb166: {
        (((*_1).4: theme::ui_styles::Users).0: ansi_term::Style) = move _77;
        goto -> bb185;
    }

    bb167: {
        (((*_1).4: theme::ui_styles::Users).1: ansi_term::Style) = move _78;
        goto -> bb185;
    }

    bb168: {
        (((*_1).4: theme::ui_styles::Users).2: ansi_term::Style) = move _79;
        goto -> bb185;
    }

    bb169: {
        (((*_1).4: theme::ui_styles::Users).3: ansi_term::Style) = move _80;
        goto -> bb185;
    }

    bb170: {
        (((*_1).5: theme::ui_styles::Links).0: ansi_term::Style) = move _81;
        goto -> bb185;
    }

    bb171: {
        (((*_1).5: theme::ui_styles::Links).1: ansi_term::Style) = move _82;
        goto -> bb185;
    }

    bb172: {
        (((*_1).6: theme::ui_styles::Git).0: ansi_term::Style) = move _83;
        goto -> bb185;
    }

    bb173: {
        (((*_1).6: theme::ui_styles::Git).1: ansi_term::Style) = move _84;
        goto -> bb185;
    }

    bb174: {
        (((*_1).6: theme::ui_styles::Git).2: ansi_term::Style) = move _85;
        goto -> bb185;
    }

    bb175: {
        (((*_1).6: theme::ui_styles::Git).3: ansi_term::Style) = move _86;
        goto -> bb185;
    }

    bb176: {
        (((*_1).6: theme::ui_styles::Git).4: ansi_term::Style) = move _87;
        goto -> bb185;
    }

    bb177: {
        ((*_1).7: ansi_term::Style) = move _88;
        goto -> bb185;
    }

    bb178: {
        ((*_1).8: ansi_term::Style) = move _89;
        goto -> bb185;
    }

    bb179: {
        ((*_1).9: ansi_term::Style) = move _90;
        goto -> bb185;
    }

    bb180: {
        ((*_1).10: ansi_term::Style) = move _91;
        goto -> bb185;
    }

    bb181: {
        ((*_1).11: ansi_term::Style) = move _92;
        goto -> bb185;
    }

    bb182: {
        ((*_1).13: ansi_term::Style) = move _93;
        goto -> bb185;
    }

    bb183: {
        ((*_1).14: ansi_term::Style) = move _94;
        goto -> bb185;
    }

    bb184: {
        ((*_1).16: ansi_term::Style) = move _95;
        goto -> bb185;
    }

    bb185: {
        _0 = const true;
        goto -> bb186;
    }

    bb186: {
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:114:1: 114:14>::set_number_style(_1: &mut ui_styles::UiStyles, _2: Style) -> () {
    debug self => _1;
    debug style => _2;
    let mut _0: ();

    bb0: {
        (((*_1).3: theme::ui_styles::Size).2: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).3: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).4: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).5: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).6: ansi_term::Style) = _2;
        return;
    }
}

fn ui_styles::<impl at src/theme/ui_styles.rs:114:1: 114:14>::set_unit_style(_1: &mut ui_styles::UiStyles, _2: Style) -> () {
    debug self => _1;
    debug style => _2;
    let mut _0: ();

    bb0: {
        (((*_1).3: theme::ui_styles::Size).7: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).8: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).9: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).10: ansi_term::Style) = _2;
        (((*_1).3: theme::ui_styles::Size).11: ansi_term::Style) = _2;
        return;
    }
}

fn lsc::<impl at src/theme/lsc.rs:27:1: 27:26>::each_pair(_1: &mut LSColors<'_>, _2: C) -> () {
    debug self => _1;
    debug callback => _2;
    let mut _0: ();
    let mut _3: std::str::Split<'_, char>;
    let mut _4: std::str::Split<'_, char>;
    let mut _5: std::str::Split<'_, char>;
    let mut _6: std::option::Option<&str>;
    let mut _7: &mut std::str::Split<'_, char>;
    let mut _8: isize;
    let mut _11: std::iter::Take<std::str::Split<'_, char>>;
    let mut _12: std::str::Split<'_, char>;
    let mut _13: usize;
    let mut _14: &std::vec::Vec<&str>;
    let mut _15: bool;
    let _16: &&str;
    let mut _17: &std::vec::Vec<&str>;
    let mut _18: bool;
    let _19: &&str;
    let mut _20: &std::vec::Vec<&str>;
    let _21: ();
    let mut _22: &mut C;
    let mut _23: (theme::lsc::Pair<'_>,);
    let mut _24: theme::lsc::Pair<'_>;
    let _25: &&str;
    let mut _26: &std::vec::Vec<&str>;
    let _27: &&str;
    let mut _28: &std::vec::Vec<&str>;
    let mut _29: &str;
    let mut _30: &str;
    let mut _31: &str;
    let mut _32: &str;
    let mut _33: &str;
    scope 1 {
        debug iter => _5;
        let _9: &str;
        scope 2 {
            debug next => _9;
            let _10: std::vec::Vec<&str>;
            scope 3 {
                debug bits => _10;
            }
        }
    }

    bb0: {
        _29 = deref_copy ((*_1).0: &str);
        _4 = core::str::<impl str>::split::<'_, char>(_29, const ':') -> [return: bb1, unwind: bb24];
    }

    bb1: {
        _3 = <std::str::Split<'_, char> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _5 = move _3;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <std::str::Split<'_, char> as Iterator>::next(_7) -> [return: bb4, unwind: bb24];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _9 = ((_6 as Some).0: &str);
        _12 = core::str::<impl str>::split::<'_, char>(_9, const '=') -> [return: bb8, unwind: bb24];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb8: {
        _11 = <std::str::Split<'_, char> as Iterator>::take(move _12, const 3_usize) -> [return: bb9, unwind: bb24];
    }

    bb9: {
        _10 = <std::iter::Take<std::str::Split<'_, char>> as Iterator>::collect::<Vec<&str>>(move _11) -> [return: bb10, unwind: bb24];
    }

    bb10: {
        _14 = &_10;
        _13 = Vec::<&str>::len(move _14) -> [return: bb11, unwind: bb23];
    }

    bb11: {
        switchInt(move _13) -> [2: bb12, otherwise: bb21];
    }

    bb12: {
        _17 = &_10;
        _16 = <Vec<&str> as std::ops::Index<usize>>::index(move _17, const 0_usize) -> [return: bb13, unwind: bb23];
    }

    bb13: {
        _30 = deref_copy (*_16);
        _15 = core::str::<impl str>::is_empty(_30) -> [return: bb14, unwind: bb23];
    }

    bb14: {
        switchInt(move _15) -> [0: bb15, otherwise: bb21];
    }

    bb15: {
        _20 = &_10;
        _19 = <Vec<&str> as std::ops::Index<usize>>::index(move _20, const 1_usize) -> [return: bb16, unwind: bb23];
    }

    bb16: {
        _31 = deref_copy (*_19);
        _18 = core::str::<impl str>::is_empty(_31) -> [return: bb17, unwind: bb23];
    }

    bb17: {
        switchInt(move _18) -> [0: bb18, otherwise: bb21];
    }

    bb18: {
        _22 = &mut _2;
        _26 = &_10;
        _25 = <Vec<&str> as std::ops::Index<usize>>::index(move _26, const 0_usize) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        _32 = deref_copy (*_25);
        _28 = &_10;
        _27 = <Vec<&str> as std::ops::Index<usize>>::index(move _28, const 1_usize) -> [return: bb20, unwind: bb23];
    }

    bb20: {
        _33 = deref_copy (*_27);
        _24 = Pair::<'_> { key: _32, value: _33 };
        _23 = (move _24,);
        _21 = <C as FnMut<(Pair<'_>,)>>::call_mut(move _22, move _23) -> [return: bb26, unwind: bb23];
    }

    bb21: {
        drop(_10) -> [return: bb3, unwind: bb24];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_10) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        goto -> bb21;
    }
}

fn parse_into_high_colour(_1: &mut Peekable<I>) -> Option<Color> {
    debug iter => _1;
    let mut _0: std::option::Option<ansi_term::Colour>;
    let mut _2: std::option::Option<&&str>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: isize;
    let mut _6: std::option::Option<&str>;
    let mut _7: std::option::Option<&str>;
    let mut _8: isize;
    let mut _10: std::result::Result<u8, std::num::ParseIntError>;
    let mut _11: isize;
    let mut _13: ansi_term::Colour;
    let mut _14: std::option::Option<&str>;
    let mut _15: std::option::Option<&str>;
    let mut _16: isize;
    let mut _18: (std::option::Option<u8>, std::option::Option<u8>, std::option::Option<u8>);
    let mut _19: std::option::Option<u8>;
    let mut _20: std::result::Result<u8, std::num::ParseIntError>;
    let mut _21: std::option::Option<u8>;
    let mut _22: std::option::Option<&str>;
    let mut _23: std::option::Option<u8>;
    let mut _24: std::option::Option<&str>;
    let mut _25: isize;
    let mut _26: isize;
    let mut _27: isize;
    let mut _31: ansi_term::Colour;
    let mut _32: &&str;
    let mut _33: &&str;
    scope 1 {
        scope 2 {
            debug byte => _9;
            let _9: &str;
            scope 3 {
                debug num => _12;
                let _12: u8;
            }
        }
    }
    scope 4 {
        scope 5 {
            debug hexes => _17;
            let _17: &str;
            scope 6 {
                debug r => _28;
                debug g => _29;
                debug b => _30;
                let _28: u8;
                let _29: u8;
                let _30: u8;
            }
        }
    }

    bb0: {
        _2 = Peekable::<I>::peek(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [1: bb2, otherwise: bb25];
    }

    bb2: {
        _32 = deref_copy ((_2 as Some).0: &&str);
        _4 = <str as PartialEq>::eq((*_32), const "5") -> [return: bb7, unwind continue];
    }

    bb3: {
        _6 = <Peekable<I> as Iterator>::next(_1) -> [return: bb8, unwind continue];
    }

    bb4: {
        _33 = deref_copy ((_2 as Some).0: &&str);
        _3 = <str as PartialEq>::eq((*_33), const "2") -> [return: bb6, unwind continue];
    }

    bb5: {
        _14 = <Peekable<I> as Iterator>::next(_1) -> [return: bb13, unwind continue];
    }

    bb6: {
        switchInt(move _3) -> [0: bb25, otherwise: bb5];
    }

    bb7: {
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb8: {
        _7 = <Peekable<I> as Iterator>::next(_1) -> [return: bb9, unwind continue];
    }

    bb9: {
        _8 = discriminant(_7);
        switchInt(move _8) -> [1: bb10, otherwise: bb25];
    }

    bb10: {
        _9 = ((_7 as Some).0: &str);
        _10 = core::str::<impl str>::parse::<u8>(_9) -> [return: bb11, unwind continue];
    }

    bb11: {
        _11 = discriminant(_10);
        switchInt(move _11) -> [0: bb12, otherwise: bb25];
    }

    bb12: {
        _12 = ((_10 as Ok).0: u8);
        _13 = ansi_term::Colour::Fixed(_12);
        _0 = Option::<Color>::Some(move _13);
        goto -> bb26;
    }

    bb13: {
        _15 = <Peekable<I> as Iterator>::next(_1) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = discriminant(_15);
        switchInt(move _16) -> [1: bb15, otherwise: bb25];
    }

    bb15: {
        _17 = ((_15 as Some).0: &str);
        _20 = core::str::<impl str>::parse::<u8>(_17) -> [return: bb16, unwind continue];
    }

    bb16: {
        _19 = Result::<u8, ParseIntError>::ok(move _20) -> [return: bb17, unwind continue];
    }

    bb17: {
        _22 = <Peekable<I> as Iterator>::next(_1) -> [return: bb18, unwind continue];
    }

    bb18: {
        _21 = Option::<&str>::and_then::<u8, {closure@src/theme/lsc.rs:73:76: 73:79}>(move _22, const ZeroSized: {closure@src/theme/lsc.rs:73:76: 73:79}) -> [return: bb19, unwind continue];
    }

    bb19: {
        _24 = <Peekable<I> as Iterator>::next(_1) -> [return: bb20, unwind continue];
    }

    bb20: {
        _23 = Option::<&str>::and_then::<u8, {closure@src/theme/lsc.rs:74:76: 74:79}>(move _24, const ZeroSized: {closure@src/theme/lsc.rs:74:76: 74:79}) -> [return: bb21, unwind continue];
    }

    bb21: {
        _18 = (move _19, move _21, move _23);
        _27 = discriminant((_18.0: std::option::Option<u8>));
        switchInt(move _27) -> [1: bb22, otherwise: bb25];
    }

    bb22: {
        _26 = discriminant((_18.1: std::option::Option<u8>));
        switchInt(move _26) -> [1: bb23, otherwise: bb25];
    }

    bb23: {
        _25 = discriminant((_18.2: std::option::Option<u8>));
        switchInt(move _25) -> [1: bb24, otherwise: bb25];
    }

    bb24: {
        _28 = (((_18.0: std::option::Option<u8>) as Some).0: u8);
        _29 = (((_18.1: std::option::Option<u8>) as Some).0: u8);
        _30 = (((_18.2: std::option::Option<u8>) as Some).0: u8);
        _31 = ansi_term::Colour::RGB(_28, _29, _30);
        _0 = Option::<Color>::Some(move _31);
        goto -> bb26;
    }

    bb25: {
        _0 = Option::<Color>::None;
        goto -> bb26;
    }

    bb26: {
        return;
    }
}

fn parse_into_high_colour::{closure#0}(_1: {closure@src/theme/lsc.rs:73:76: 73:79}, _2: &str) -> Option<u8> {
    debug s => _2;
    let mut _0: std::option::Option<u8>;
    let mut _3: std::result::Result<u8, std::num::ParseIntError>;

    bb0: {
        _3 = core::str::<impl str>::parse::<u8>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<u8, ParseIntError>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn parse_into_high_colour::{closure#1}(_1: {closure@src/theme/lsc.rs:74:76: 74:79}, _2: &str) -> Option<u8> {
    debug s => _2;
    let mut _0: std::option::Option<u8>;
    let mut _3: std::result::Result<u8, std::num::ParseIntError>;

    bb0: {
        _3 = core::str::<impl str>::parse::<u8>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<u8, ParseIntError>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn lsc::<impl at src/theme/lsc.rs:93:1: 93:22>::to_style(_1: &Pair<'_>) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _4: std::str::Split<'_, char>;
    let mut _5: std::option::Option<&str>;
    let mut _6: &mut std::iter::Peekable<std::str::Split<'_, char>>;
    let mut _7: isize;
    let mut _9: &str;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _21: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: ansi_term::Style;
    let mut _37: &ansi_term::Style;
    let mut _38: ansi_term::Style;
    let mut _39: &ansi_term::Style;
    let mut _40: ansi_term::Style;
    let mut _41: &ansi_term::Style;
    let mut _42: ansi_term::Style;
    let mut _43: &ansi_term::Style;
    let mut _44: ansi_term::Style;
    let mut _45: &ansi_term::Style;
    let mut _46: ansi_term::Style;
    let mut _47: &ansi_term::Style;
    let mut _48: ansi_term::Style;
    let mut _49: &ansi_term::Style;
    let mut _50: ansi_term::Style;
    let mut _51: &ansi_term::Style;
    let mut _52: ansi_term::Style;
    let mut _53: &ansi_term::Style;
    let mut _54: ansi_term::Colour;
    let mut _55: ansi_term::Style;
    let mut _56: &ansi_term::Style;
    let mut _57: ansi_term::Colour;
    let mut _58: ansi_term::Style;
    let mut _59: &ansi_term::Style;
    let mut _60: ansi_term::Colour;
    let mut _61: ansi_term::Style;
    let mut _62: &ansi_term::Style;
    let mut _63: ansi_term::Colour;
    let mut _64: ansi_term::Style;
    let mut _65: &ansi_term::Style;
    let mut _66: ansi_term::Colour;
    let mut _67: ansi_term::Style;
    let mut _68: &ansi_term::Style;
    let mut _69: ansi_term::Colour;
    let mut _70: ansi_term::Style;
    let mut _71: &ansi_term::Style;
    let mut _72: ansi_term::Colour;
    let mut _73: ansi_term::Style;
    let mut _74: &ansi_term::Style;
    let mut _75: ansi_term::Colour;
    let mut _76: std::option::Option<ansi_term::Colour>;
    let mut _77: &mut std::iter::Peekable<std::str::Split<'_, char>>;
    let mut _78: isize;
    let mut _80: ansi_term::Style;
    let mut _81: &ansi_term::Style;
    let mut _82: ansi_term::Style;
    let mut _83: &ansi_term::Style;
    let mut _84: ansi_term::Colour;
    let mut _85: ansi_term::Style;
    let mut _86: &ansi_term::Style;
    let mut _87: ansi_term::Colour;
    let mut _88: ansi_term::Style;
    let mut _89: &ansi_term::Style;
    let mut _90: ansi_term::Colour;
    let mut _91: ansi_term::Style;
    let mut _92: &ansi_term::Style;
    let mut _93: ansi_term::Colour;
    let mut _94: ansi_term::Style;
    let mut _95: &ansi_term::Style;
    let mut _96: ansi_term::Colour;
    let mut _97: ansi_term::Style;
    let mut _98: &ansi_term::Style;
    let mut _99: ansi_term::Colour;
    let mut _100: ansi_term::Style;
    let mut _101: &ansi_term::Style;
    let mut _102: ansi_term::Colour;
    let mut _103: ansi_term::Style;
    let mut _104: &ansi_term::Style;
    let mut _105: ansi_term::Colour;
    let mut _106: std::option::Option<ansi_term::Colour>;
    let mut _107: &mut std::iter::Peekable<std::str::Split<'_, char>>;
    let mut _108: isize;
    let mut _110: ansi_term::Style;
    let mut _111: &ansi_term::Style;
    let mut _112: &str;
    scope 1 {
        debug style => _2;
        let mut _3: std::iter::Peekable<std::str::Split<'_, char>>;
        scope 2 {
            debug iter => _3;
            scope 3 {
                debug num => _8;
                let _8: &str;
                scope 4 {
                    debug c => _79;
                    let _79: ansi_term::Colour;
                }
                scope 5 {
                    debug c => _109;
                    let _109: ansi_term::Colour;
                }
            }
        }
    }

    bb0: {
        _2 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _112 = deref_copy ((*_1).1: &str);
        _4 = core::str::<impl str>::split::<'_, char>(_112, const ';') -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::str::Split<'_, char> as Iterator>::peekable(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &mut _3;
        _5 = <Peekable<std::str::Split<'_, char>> as Iterator>::next(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [1: bb5, otherwise: bb114];
    }

    bb5: {
        _8 = ((_5 as Some).0: &str);
        _9 = core::str::<impl str>::trim_start_matches::<'_, char>(_8, const '0') -> [return: bb6, unwind continue];
    }

    bb6: {
        _35 = <str as PartialEq>::eq(_9, const "1") -> [return: bb83, unwind continue];
    }

    bb7: {
        _37 = &_2;
        _36 = Style::bold(move _37) -> [return: bb84, unwind continue];
    }

    bb8: {
        _34 = <str as PartialEq>::eq(_9, const "2") -> [return: bb82, unwind continue];
    }

    bb9: {
        _39 = &_2;
        _38 = Style::dimmed(move _39) -> [return: bb85, unwind continue];
    }

    bb10: {
        _33 = <str as PartialEq>::eq(_9, const "3") -> [return: bb81, unwind continue];
    }

    bb11: {
        _41 = &_2;
        _40 = Style::italic(move _41) -> [return: bb86, unwind continue];
    }

    bb12: {
        _32 = <str as PartialEq>::eq(_9, const "4") -> [return: bb80, unwind continue];
    }

    bb13: {
        _43 = &_2;
        _42 = Style::underline(move _43) -> [return: bb87, unwind continue];
    }

    bb14: {
        _31 = <str as PartialEq>::eq(_9, const "5") -> [return: bb79, unwind continue];
    }

    bb15: {
        _45 = &_2;
        _44 = Style::blink(move _45) -> [return: bb88, unwind continue];
    }

    bb16: {
        _30 = <str as PartialEq>::eq(_9, const "7") -> [return: bb78, unwind continue];
    }

    bb17: {
        _47 = &_2;
        _46 = Style::reverse(move _47) -> [return: bb89, unwind continue];
    }

    bb18: {
        _29 = <str as PartialEq>::eq(_9, const "8") -> [return: bb77, unwind continue];
    }

    bb19: {
        _49 = &_2;
        _48 = Style::hidden(move _49) -> [return: bb90, unwind continue];
    }

    bb20: {
        _28 = <str as PartialEq>::eq(_9, const "9") -> [return: bb76, unwind continue];
    }

    bb21: {
        _51 = &_2;
        _50 = Style::strikethrough(move _51) -> [return: bb91, unwind continue];
    }

    bb22: {
        _27 = <str as PartialEq>::eq(_9, const "30") -> [return: bb75, unwind continue];
    }

    bb23: {
        _53 = &_2;
        _54 = ansi_term::Colour::Black;
        _52 = Style::fg(move _53, move _54) -> [return: bb92, unwind continue];
    }

    bb24: {
        _26 = <str as PartialEq>::eq(_9, const "31") -> [return: bb74, unwind continue];
    }

    bb25: {
        _56 = &_2;
        _57 = ansi_term::Colour::Red;
        _55 = Style::fg(move _56, move _57) -> [return: bb93, unwind continue];
    }

    bb26: {
        _25 = <str as PartialEq>::eq(_9, const "32") -> [return: bb73, unwind continue];
    }

    bb27: {
        _59 = &_2;
        _60 = ansi_term::Colour::Green;
        _58 = Style::fg(move _59, move _60) -> [return: bb94, unwind continue];
    }

    bb28: {
        _24 = <str as PartialEq>::eq(_9, const "33") -> [return: bb72, unwind continue];
    }

    bb29: {
        _62 = &_2;
        _63 = ansi_term::Colour::Yellow;
        _61 = Style::fg(move _62, move _63) -> [return: bb95, unwind continue];
    }

    bb30: {
        _23 = <str as PartialEq>::eq(_9, const "34") -> [return: bb71, unwind continue];
    }

    bb31: {
        _65 = &_2;
        _66 = ansi_term::Colour::Blue;
        _64 = Style::fg(move _65, move _66) -> [return: bb96, unwind continue];
    }

    bb32: {
        _22 = <str as PartialEq>::eq(_9, const "35") -> [return: bb70, unwind continue];
    }

    bb33: {
        _68 = &_2;
        _69 = ansi_term::Colour::Purple;
        _67 = Style::fg(move _68, move _69) -> [return: bb97, unwind continue];
    }

    bb34: {
        _21 = <str as PartialEq>::eq(_9, const "36") -> [return: bb69, unwind continue];
    }

    bb35: {
        _71 = &_2;
        _72 = ansi_term::Colour::Cyan;
        _70 = Style::fg(move _71, move _72) -> [return: bb98, unwind continue];
    }

    bb36: {
        _20 = <str as PartialEq>::eq(_9, const "37") -> [return: bb68, unwind continue];
    }

    bb37: {
        _74 = &_2;
        _75 = ansi_term::Colour::White;
        _73 = Style::fg(move _74, move _75) -> [return: bb99, unwind continue];
    }

    bb38: {
        _19 = <str as PartialEq>::eq(_9, const "38") -> [return: bb67, unwind continue];
    }

    bb39: {
        _77 = &mut _3;
        _76 = parse_into_high_colour::<'_, std::str::Split<'_, char>>(_77) -> [return: bb100, unwind continue];
    }

    bb40: {
        _18 = <str as PartialEq>::eq(_9, const "40") -> [return: bb66, unwind continue];
    }

    bb41: {
        _83 = &_2;
        _84 = ansi_term::Colour::Black;
        _82 = Style::on(move _83, move _84) -> [return: bb103, unwind continue];
    }

    bb42: {
        _17 = <str as PartialEq>::eq(_9, const "41") -> [return: bb65, unwind continue];
    }

    bb43: {
        _86 = &_2;
        _87 = ansi_term::Colour::Red;
        _85 = Style::on(move _86, move _87) -> [return: bb104, unwind continue];
    }

    bb44: {
        _16 = <str as PartialEq>::eq(_9, const "42") -> [return: bb64, unwind continue];
    }

    bb45: {
        _89 = &_2;
        _90 = ansi_term::Colour::Green;
        _88 = Style::on(move _89, move _90) -> [return: bb105, unwind continue];
    }

    bb46: {
        _15 = <str as PartialEq>::eq(_9, const "43") -> [return: bb63, unwind continue];
    }

    bb47: {
        _92 = &_2;
        _93 = ansi_term::Colour::Yellow;
        _91 = Style::on(move _92, move _93) -> [return: bb106, unwind continue];
    }

    bb48: {
        _14 = <str as PartialEq>::eq(_9, const "44") -> [return: bb62, unwind continue];
    }

    bb49: {
        _95 = &_2;
        _96 = ansi_term::Colour::Blue;
        _94 = Style::on(move _95, move _96) -> [return: bb107, unwind continue];
    }

    bb50: {
        _13 = <str as PartialEq>::eq(_9, const "45") -> [return: bb61, unwind continue];
    }

    bb51: {
        _98 = &_2;
        _99 = ansi_term::Colour::Purple;
        _97 = Style::on(move _98, move _99) -> [return: bb108, unwind continue];
    }

    bb52: {
        _12 = <str as PartialEq>::eq(_9, const "46") -> [return: bb60, unwind continue];
    }

    bb53: {
        _101 = &_2;
        _102 = ansi_term::Colour::Cyan;
        _100 = Style::on(move _101, move _102) -> [return: bb109, unwind continue];
    }

    bb54: {
        _11 = <str as PartialEq>::eq(_9, const "47") -> [return: bb59, unwind continue];
    }

    bb55: {
        _104 = &_2;
        _105 = ansi_term::Colour::White;
        _103 = Style::on(move _104, move _105) -> [return: bb110, unwind continue];
    }

    bb56: {
        _10 = <str as PartialEq>::eq(_9, const "48") -> [return: bb58, unwind continue];
    }

    bb57: {
        _107 = &mut _3;
        _106 = parse_into_high_colour::<'_, std::str::Split<'_, char>>(_107) -> [return: bb111, unwind continue];
    }

    bb58: {
        switchInt(move _10) -> [0: bb3, otherwise: bb57];
    }

    bb59: {
        switchInt(move _11) -> [0: bb56, otherwise: bb55];
    }

    bb60: {
        switchInt(move _12) -> [0: bb54, otherwise: bb53];
    }

    bb61: {
        switchInt(move _13) -> [0: bb52, otherwise: bb51];
    }

    bb62: {
        switchInt(move _14) -> [0: bb50, otherwise: bb49];
    }

    bb63: {
        switchInt(move _15) -> [0: bb48, otherwise: bb47];
    }

    bb64: {
        switchInt(move _16) -> [0: bb46, otherwise: bb45];
    }

    bb65: {
        switchInt(move _17) -> [0: bb44, otherwise: bb43];
    }

    bb66: {
        switchInt(move _18) -> [0: bb42, otherwise: bb41];
    }

    bb67: {
        switchInt(move _19) -> [0: bb40, otherwise: bb39];
    }

    bb68: {
        switchInt(move _20) -> [0: bb38, otherwise: bb37];
    }

    bb69: {
        switchInt(move _21) -> [0: bb36, otherwise: bb35];
    }

    bb70: {
        switchInt(move _22) -> [0: bb34, otherwise: bb33];
    }

    bb71: {
        switchInt(move _23) -> [0: bb32, otherwise: bb31];
    }

    bb72: {
        switchInt(move _24) -> [0: bb30, otherwise: bb29];
    }

    bb73: {
        switchInt(move _25) -> [0: bb28, otherwise: bb27];
    }

    bb74: {
        switchInt(move _26) -> [0: bb26, otherwise: bb25];
    }

    bb75: {
        switchInt(move _27) -> [0: bb24, otherwise: bb23];
    }

    bb76: {
        switchInt(move _28) -> [0: bb22, otherwise: bb21];
    }

    bb77: {
        switchInt(move _29) -> [0: bb20, otherwise: bb19];
    }

    bb78: {
        switchInt(move _30) -> [0: bb18, otherwise: bb17];
    }

    bb79: {
        switchInt(move _31) -> [0: bb16, otherwise: bb15];
    }

    bb80: {
        switchInt(move _32) -> [0: bb14, otherwise: bb13];
    }

    bb81: {
        switchInt(move _33) -> [0: bb12, otherwise: bb11];
    }

    bb82: {
        switchInt(move _34) -> [0: bb10, otherwise: bb9];
    }

    bb83: {
        switchInt(move _35) -> [0: bb8, otherwise: bb7];
    }

    bb84: {
        _2 = move _36;
        goto -> bb3;
    }

    bb85: {
        _2 = move _38;
        goto -> bb3;
    }

    bb86: {
        _2 = move _40;
        goto -> bb3;
    }

    bb87: {
        _2 = move _42;
        goto -> bb3;
    }

    bb88: {
        _2 = move _44;
        goto -> bb3;
    }

    bb89: {
        _2 = move _46;
        goto -> bb3;
    }

    bb90: {
        _2 = move _48;
        goto -> bb3;
    }

    bb91: {
        _2 = move _50;
        goto -> bb3;
    }

    bb92: {
        _2 = move _52;
        goto -> bb3;
    }

    bb93: {
        _2 = move _55;
        goto -> bb3;
    }

    bb94: {
        _2 = move _58;
        goto -> bb3;
    }

    bb95: {
        _2 = move _61;
        goto -> bb3;
    }

    bb96: {
        _2 = move _64;
        goto -> bb3;
    }

    bb97: {
        _2 = move _67;
        goto -> bb3;
    }

    bb98: {
        _2 = move _70;
        goto -> bb3;
    }

    bb99: {
        _2 = move _73;
        goto -> bb3;
    }

    bb100: {
        _78 = discriminant(_76);
        switchInt(move _78) -> [1: bb101, otherwise: bb3];
    }

    bb101: {
        _79 = ((_76 as Some).0: ansi_term::Colour);
        _81 = &_2;
        _80 = Style::fg(move _81, _79) -> [return: bb102, unwind continue];
    }

    bb102: {
        _2 = move _80;
        goto -> bb3;
    }

    bb103: {
        _2 = move _82;
        goto -> bb3;
    }

    bb104: {
        _2 = move _85;
        goto -> bb3;
    }

    bb105: {
        _2 = move _88;
        goto -> bb3;
    }

    bb106: {
        _2 = move _91;
        goto -> bb3;
    }

    bb107: {
        _2 = move _94;
        goto -> bb3;
    }

    bb108: {
        _2 = move _97;
        goto -> bb3;
    }

    bb109: {
        _2 = move _100;
        goto -> bb3;
    }

    bb110: {
        _2 = move _103;
        goto -> bb3;
    }

    bb111: {
        _108 = discriminant(_106);
        switchInt(move _108) -> [1: bb112, otherwise: bb3];
    }

    bb112: {
        _109 = ((_106 as Some).0: ansi_term::Colour);
        _111 = &_2;
        _110 = Style::on(move _111, _109) -> [return: bb113, unwind continue];
    }

    bb113: {
        _2 = move _110;
        goto -> bb3;
    }

    bb114: {
        _0 = _2;
        return;
    }
}

fn default_theme::<impl at src/theme/default_theme.rs:8:1: 8:14>::default_theme(_1: ColourScale) -> ui_styles::UiStyles {
    debug scale => _1;
    let mut _0: theme::ui_styles::UiStyles;
    let mut _2: theme::ui_styles::FileKinds;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Style;
    let mut _5: ansi_term::Colour;
    let mut _6: ansi_term::Style;
    let mut _7: ansi_term::Colour;
    let mut _8: ansi_term::Style;
    let mut _9: ansi_term::Colour;
    let mut _10: ansi_term::Style;
    let mut _11: ansi_term::Colour;
    let mut _12: ansi_term::Style;
    let mut _13: ansi_term::Colour;
    let mut _14: ansi_term::Style;
    let mut _15: ansi_term::Colour;
    let mut _16: ansi_term::Style;
    let mut _17: ansi_term::Colour;
    let mut _18: ansi_term::Style;
    let mut _19: ansi_term::Colour;
    let mut _20: theme::ui_styles::Permissions;
    let mut _21: ansi_term::Style;
    let mut _22: ansi_term::Colour;
    let mut _23: ansi_term::Style;
    let mut _24: ansi_term::Colour;
    let mut _25: ansi_term::Style;
    let mut _26: &ansi_term::Style;
    let _27: ansi_term::Style;
    let mut _28: ansi_term::Colour;
    let mut _29: ansi_term::Style;
    let mut _30: ansi_term::Colour;
    let mut _31: ansi_term::Style;
    let mut _32: ansi_term::Colour;
    let mut _33: ansi_term::Style;
    let mut _34: ansi_term::Colour;
    let mut _35: ansi_term::Style;
    let mut _36: ansi_term::Colour;
    let mut _37: ansi_term::Style;
    let mut _38: ansi_term::Colour;
    let mut _39: ansi_term::Style;
    let mut _40: ansi_term::Colour;
    let mut _41: ansi_term::Style;
    let mut _42: ansi_term::Colour;
    let mut _43: ansi_term::Style;
    let mut _44: ansi_term::Colour;
    let mut _45: ansi_term::Style;
    let mut _46: ansi_term::Colour;
    let mut _47: ansi_term::Style;
    let mut _48: theme::ui_styles::Size;
    let mut _49: theme::ui_styles::Users;
    let mut _50: ansi_term::Style;
    let mut _51: ansi_term::Colour;
    let mut _52: ansi_term::Style;
    let mut _53: ansi_term::Style;
    let mut _54: ansi_term::Colour;
    let mut _55: ansi_term::Style;
    let mut _56: theme::ui_styles::Links;
    let mut _57: ansi_term::Style;
    let mut _58: ansi_term::Colour;
    let mut _59: ansi_term::Style;
    let mut _60: ansi_term::Colour;
    let mut _61: ansi_term::Colour;
    let mut _62: theme::ui_styles::Git;
    let mut _63: ansi_term::Style;
    let mut _64: ansi_term::Colour;
    let mut _65: ansi_term::Style;
    let mut _66: ansi_term::Colour;
    let mut _67: ansi_term::Style;
    let mut _68: ansi_term::Colour;
    let mut _69: ansi_term::Style;
    let mut _70: ansi_term::Colour;
    let mut _71: ansi_term::Style;
    let mut _72: ansi_term::Colour;
    let mut _73: ansi_term::Style;
    let mut _74: &ansi_term::Style;
    let _75: ansi_term::Style;
    let mut _76: ansi_term::Style;
    let mut _77: ansi_term::Colour;
    let mut _78: ansi_term::Style;
    let mut _79: ansi_term::Colour;
    let mut _80: ansi_term::Style;
    let mut _81: ansi_term::Colour;
    let mut _82: ansi_term::Style;
    let mut _83: ansi_term::Colour;
    let mut _84: ansi_term::Style;
    let mut _85: ansi_term::Colour;
    let mut _86: ansi_term::Style;
    let mut _87: ansi_term::Colour;
    let mut _88: ansi_term::Style;
    let mut _89: &ansi_term::Style;
    let _90: ansi_term::Style;
    let mut _91: ansi_term::Style;
    let mut _92: ansi_term::Colour;
    let mut _93: ansi_term::Style;
    let mut _94: ansi_term::Colour;
    let mut _95: ansi_term::Style;
    let mut _96: ansi_term::Colour;
    let mut _97: ansi_term::Style;
    let mut _98: &ansi_term::Style;
    let _99: ansi_term::Style;

    bb0: {
        _3 = <Style as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ansi_term::Colour::Blue;
        _4 = Color::bold(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = ansi_term::Colour::Cyan;
        _6 = Color::normal(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = ansi_term::Colour::Yellow;
        _8 = Color::normal(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = ansi_term::Colour::Yellow;
        _10 = Color::bold(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = ansi_term::Colour::Yellow;
        _12 = Color::bold(move _13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _15 = ansi_term::Colour::Red;
        _14 = Color::bold(move _15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _17 = ansi_term::Colour::Yellow;
        _16 = Color::normal(move _17) -> [return: bb8, unwind continue];
    }

    bb8: {
        _19 = ansi_term::Colour::Green;
        _18 = Color::bold(move _19) -> [return: bb9, unwind continue];
    }

    bb9: {
        _2 = ui_styles::FileKinds { normal: move _3, directory: move _4, symlink: move _6, pipe: move _8, block_device: move _10, char_device: move _12, socket: move _14, special: move _16, executable: move _18 };
        _22 = ansi_term::Colour::Yellow;
        _21 = Color::bold(move _22) -> [return: bb10, unwind continue];
    }

    bb10: {
        _24 = ansi_term::Colour::Red;
        _23 = Color::bold(move _24) -> [return: bb11, unwind continue];
    }

    bb11: {
        _28 = ansi_term::Colour::Green;
        _27 = Color::bold(move _28) -> [return: bb12, unwind continue];
    }

    bb12: {
        _26 = &_27;
        _25 = Style::underline(move _26) -> [return: bb13, unwind continue];
    }

    bb13: {
        _30 = ansi_term::Colour::Green;
        _29 = Color::bold(move _30) -> [return: bb14, unwind continue];
    }

    bb14: {
        _32 = ansi_term::Colour::Yellow;
        _31 = Color::normal(move _32) -> [return: bb15, unwind continue];
    }

    bb15: {
        _34 = ansi_term::Colour::Red;
        _33 = Color::normal(move _34) -> [return: bb16, unwind continue];
    }

    bb16: {
        _36 = ansi_term::Colour::Green;
        _35 = Color::normal(move _36) -> [return: bb17, unwind continue];
    }

    bb17: {
        _38 = ansi_term::Colour::Yellow;
        _37 = Color::normal(move _38) -> [return: bb18, unwind continue];
    }

    bb18: {
        _40 = ansi_term::Colour::Red;
        _39 = Color::normal(move _40) -> [return: bb19, unwind continue];
    }

    bb19: {
        _42 = ansi_term::Colour::Green;
        _41 = Color::normal(move _42) -> [return: bb20, unwind continue];
    }

    bb20: {
        _44 = ansi_term::Colour::Purple;
        _43 = Color::normal(move _44) -> [return: bb21, unwind continue];
    }

    bb21: {
        _46 = ansi_term::Colour::Purple;
        _45 = Color::normal(move _46) -> [return: bb22, unwind continue];
    }

    bb22: {
        _47 = <Style as Default>::default() -> [return: bb23, unwind continue];
    }

    bb23: {
        _20 = ui_styles::Permissions { user_read: move _21, user_write: move _23, user_execute_file: move _25, user_execute_other: move _29, group_read: move _31, group_write: move _33, group_execute: move _35, other_read: move _37, other_write: move _39, other_execute: move _41, special_user_file: move _43, special_other: move _45, attribute: move _47 };
        _48 = default_theme::<impl ui_styles::Size>::colourful(_1) -> [return: bb24, unwind continue];
    }

    bb24: {
        _51 = ansi_term::Colour::Yellow;
        _50 = Color::bold(move _51) -> [return: bb25, unwind continue];
    }

    bb25: {
        _52 = <Style as Default>::default() -> [return: bb26, unwind continue];
    }

    bb26: {
        _54 = ansi_term::Colour::Yellow;
        _53 = Color::bold(move _54) -> [return: bb27, unwind continue];
    }

    bb27: {
        _55 = <Style as Default>::default() -> [return: bb28, unwind continue];
    }

    bb28: {
        _49 = ui_styles::Users { user_you: move _50, user_someone_else: move _52, group_yours: move _53, group_not_yours: move _55 };
        _58 = ansi_term::Colour::Red;
        _57 = Color::bold(move _58) -> [return: bb29, unwind continue];
    }

    bb29: {
        _60 = ansi_term::Colour::Red;
        _61 = ansi_term::Colour::Yellow;
        _59 = Color::on(move _60, move _61) -> [return: bb30, unwind continue];
    }

    bb30: {
        _56 = ui_styles::Links { normal: move _57, multi_link_file: move _59 };
        _64 = ansi_term::Colour::Green;
        _63 = Color::normal(move _64) -> [return: bb31, unwind continue];
    }

    bb31: {
        _66 = ansi_term::Colour::Blue;
        _65 = Color::normal(move _66) -> [return: bb32, unwind continue];
    }

    bb32: {
        _68 = ansi_term::Colour::Red;
        _67 = Color::normal(move _68) -> [return: bb33, unwind continue];
    }

    bb33: {
        _70 = ansi_term::Colour::Yellow;
        _69 = Color::normal(move _70) -> [return: bb34, unwind continue];
    }

    bb34: {
        _72 = ansi_term::Colour::Purple;
        _71 = Color::normal(move _72) -> [return: bb35, unwind continue];
    }

    bb35: {
        _75 = <Style as Default>::default() -> [return: bb36, unwind continue];
    }

    bb36: {
        _74 = &_75;
        _73 = Style::dimmed(move _74) -> [return: bb37, unwind continue];
    }

    bb37: {
        _77 = ansi_term::Colour::Red;
        _76 = Color::normal(move _77) -> [return: bb38, unwind continue];
    }

    bb38: {
        _62 = ui_styles::Git { new: move _63, modified: move _65, deleted: move _67, renamed: move _69, typechange: move _71, ignored: move _73, conflicted: move _76 };
        _79 = ansi_term::Colour::Fixed(const 244_u8);
        _78 = Color::normal(move _79) -> [return: bb39, unwind continue];
    }

    bb39: {
        _81 = ansi_term::Colour::Blue;
        _80 = Color::normal(move _81) -> [return: bb40, unwind continue];
    }

    bb40: {
        _83 = ansi_term::Colour::Purple;
        _82 = Color::normal(move _83) -> [return: bb41, unwind continue];
    }

    bb41: {
        _85 = ansi_term::Colour::Cyan;
        _84 = Color::normal(move _85) -> [return: bb42, unwind continue];
    }

    bb42: {
        _87 = ansi_term::Colour::Purple;
        _86 = Color::normal(move _87) -> [return: bb43, unwind continue];
    }

    bb43: {
        _90 = <Style as Default>::default() -> [return: bb44, unwind continue];
    }

    bb44: {
        _89 = &_90;
        _88 = Style::underline(move _89) -> [return: bb45, unwind continue];
    }

    bb45: {
        _92 = ansi_term::Colour::Cyan;
        _91 = Color::normal(move _92) -> [return: bb46, unwind continue];
    }

    bb46: {
        _94 = ansi_term::Colour::Red;
        _93 = Color::normal(move _94) -> [return: bb47, unwind continue];
    }

    bb47: {
        _96 = ansi_term::Colour::Red;
        _95 = Color::normal(move _96) -> [return: bb48, unwind continue];
    }

    bb48: {
        _99 = <Style as Default>::default() -> [return: bb49, unwind continue];
    }

    bb49: {
        _98 = &_99;
        _97 = Style::underline(move _98) -> [return: bb50, unwind continue];
    }

    bb50: {
        _0 = ui_styles::UiStyles { colourful: const true, filekinds: move _2, perms: move _20, size: move _48, users: move _49, links: move _56, git: move _62, punctuation: move _78, date: move _80, inode: move _82, blocks: move _84, header: move _88, octal: move _86, symlink_path: move _91, control_char: move _93, broken_symlink: move _95, broken_path_overlay: move _97 };
        return;
    }
}

fn default_theme::<impl at src/theme/default_theme.rs:85:1: 85:10>::colourful(_1: ColourScale) -> ui_styles::Size {
    debug scale => _1;
    let mut _0: theme::ui_styles::Size;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = default_theme::<impl ui_styles::Size>::colourful_fixed() -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = default_theme::<impl ui_styles::Size>::colourful_gradient() -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn default_theme::<impl at src/theme/default_theme.rs:85:1: 85:10>::colourful_fixed() -> ui_styles::Size {
    let mut _0: theme::ui_styles::Size;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Colour;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Colour;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Colour;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Colour;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Colour;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Colour;
    let mut _13: ansi_term::Style;
    let mut _14: ansi_term::Colour;
    let mut _15: ansi_term::Style;
    let mut _16: ansi_term::Colour;
    let mut _17: ansi_term::Style;
    let mut _18: ansi_term::Colour;
    let mut _19: ansi_term::Style;
    let mut _20: ansi_term::Colour;
    let mut _21: ansi_term::Style;
    let mut _22: ansi_term::Colour;
    let mut _23: ansi_term::Style;
    let mut _24: ansi_term::Colour;

    bb0: {
        _2 = ansi_term::Colour::Green;
        _1 = Color::bold(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ansi_term::Colour::Green;
        _3 = Color::normal(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = ansi_term::Colour::Green;
        _5 = Color::bold(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = ansi_term::Colour::Green;
        _7 = Color::bold(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = ansi_term::Colour::Green;
        _9 = Color::bold(move _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = ansi_term::Colour::Green;
        _11 = Color::bold(move _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _14 = ansi_term::Colour::Green;
        _13 = Color::bold(move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        _16 = ansi_term::Colour::Green;
        _15 = Color::normal(move _16) -> [return: bb8, unwind continue];
    }

    bb8: {
        _18 = ansi_term::Colour::Green;
        _17 = Color::normal(move _18) -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = ansi_term::Colour::Green;
        _19 = Color::normal(move _20) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = ansi_term::Colour::Green;
        _21 = Color::normal(move _22) -> [return: bb11, unwind continue];
    }

    bb11: {
        _24 = ansi_term::Colour::Green;
        _23 = Color::normal(move _24) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = ui_styles::Size { major: move _1, minor: move _3, number_byte: move _5, number_kilo: move _7, number_mega: move _9, number_giga: move _11, number_huge: move _13, unit_byte: move _15, unit_kilo: move _17, unit_mega: move _19, unit_giga: move _21, unit_huge: move _23 };
        return;
    }
}

fn default_theme::<impl at src/theme/default_theme.rs:85:1: 85:10>::colourful_gradient() -> ui_styles::Size {
    let mut _0: theme::ui_styles::Size;
    let mut _1: ansi_term::Style;
    let mut _2: ansi_term::Colour;
    let mut _3: ansi_term::Style;
    let mut _4: ansi_term::Colour;
    let mut _5: ansi_term::Style;
    let mut _6: ansi_term::Colour;
    let mut _7: ansi_term::Style;
    let mut _8: ansi_term::Colour;
    let mut _9: ansi_term::Style;
    let mut _10: ansi_term::Colour;
    let mut _11: ansi_term::Style;
    let mut _12: ansi_term::Colour;
    let mut _13: ansi_term::Style;
    let mut _14: ansi_term::Colour;
    let mut _15: ansi_term::Style;
    let mut _16: ansi_term::Colour;
    let mut _17: ansi_term::Style;
    let mut _18: ansi_term::Colour;
    let mut _19: ansi_term::Style;
    let mut _20: ansi_term::Colour;
    let mut _21: ansi_term::Style;
    let mut _22: ansi_term::Colour;
    let mut _23: ansi_term::Style;
    let mut _24: ansi_term::Colour;

    bb0: {
        _2 = ansi_term::Colour::Green;
        _1 = Color::bold(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ansi_term::Colour::Green;
        _3 = Color::normal(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = ansi_term::Colour::Fixed(const 118_u8);
        _5 = Color::normal(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = ansi_term::Colour::Fixed(const 190_u8);
        _7 = Color::normal(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = ansi_term::Colour::Fixed(const 226_u8);
        _9 = Color::normal(move _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = ansi_term::Colour::Fixed(const 220_u8);
        _11 = Color::normal(move _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _14 = ansi_term::Colour::Fixed(const 214_u8);
        _13 = Color::normal(move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        _16 = ansi_term::Colour::Green;
        _15 = Color::normal(move _16) -> [return: bb8, unwind continue];
    }

    bb8: {
        _18 = ansi_term::Colour::Green;
        _17 = Color::normal(move _18) -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = ansi_term::Colour::Green;
        _19 = Color::normal(move _20) -> [return: bb10, unwind continue];
    }

    bb10: {
        _22 = ansi_term::Colour::Green;
        _21 = Color::normal(move _22) -> [return: bb11, unwind continue];
    }

    bb11: {
        _24 = ansi_term::Colour::Green;
        _23 = Color::normal(move _24) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = ui_styles::Size { major: move _1, minor: move _3, number_byte: move _5, number_kilo: move _7, number_mega: move _9, number_giga: move _11, number_huge: move _13, unit_byte: move _15, unit_kilo: move _17, unit_mega: move _19, unit_giga: move _21, unit_huge: move _23 };
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:17:10: 17:19>::eq(_1: &theme::Options, _2: &theme::Options) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &theme::UseColours;
    let mut _5: &theme::UseColours;
    let mut _6: bool;
    let mut _7: &theme::ColourScale;
    let mut _8: &theme::ColourScale;
    let mut _9: &theme::Definitions;
    let mut _10: &theme::Definitions;

    bb0: {
        _4 = &((*_1).0: theme::UseColours);
        _5 = &((*_2).0: theme::UseColours);
        _3 = <UseColours as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _7 = &((*_1).1: theme::ColourScale);
        _8 = &((*_2).1: theme::ColourScale);
        _6 = <ColourScale as PartialEq>::eq(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = &((*_1).2: theme::Definitions);
        _10 = &((*_2).2: theme::Definitions);
        _0 = <Definitions as PartialEq>::eq(move _9, move _10) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = const false;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:17:21: 17:26>::fmt(_1: &theme::Options, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &theme::UseColours;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &theme::ColourScale;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&theme::Definitions;
    let _13: &theme::Definitions;

    bb0: {
        _3 = const "Options";
        _4 = const "use_colours";
        _6 = &((*_1).0: theme::UseColours);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "colour_scale";
        _9 = &((*_1).1: theme::ColourScale);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "definitions";
        _13 = &((*_1).2: theme::Definitions);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:34:10: 34:19>::eq(_1: &UseColours, _2: &UseColours) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:34:21: 34:26>::fmt(_1: &UseColours, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "Never";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Always";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Automatic";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:34:34: 34:39>::clone(_1: &UseColours) -> UseColours {
    debug self => _1;
    let mut _0: theme::UseColours;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:47:10: 47:19>::eq(_1: &ColourScale, _2: &ColourScale) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:47:21: 47:26>::fmt(_1: &ColourScale, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = const "Gradient";
        _3 = _6;
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Fixed";
        _3 = _5;
        goto -> bb4;
    }

    bb4: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:47:34: 47:39>::clone(_1: &ColourScale) -> ColourScale {
    debug self => _1;
    let mut _0: theme::ColourScale;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:53:10: 53:19>::eq(_1: &Definitions, _2: &Definitions) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::string::String>;
    let mut _5: &std::option::Option<std::string::String>;
    let mut _6: &std::option::Option<std::string::String>;
    let mut _7: &std::option::Option<std::string::String>;

    bb0: {
        _4 = &((*_1).0: std::option::Option<std::string::String>);
        _5 = &((*_2).0: std::option::Option<std::string::String>);
        _3 = <Option<String> as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &((*_1).1: std::option::Option<std::string::String>);
        _7 = &((*_2).1: std::option::Option<std::string::String>);
        _0 = <Option<String> as PartialEq>::eq(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:53:21: 53:26>::fmt(_1: &Definitions, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<std::string::String>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::option::Option<std::string::String>;
    let _10: &std::option::Option<std::string::String>;

    bb0: {
        _3 = const "Definitions";
        _4 = const "ls";
        _6 = &((*_1).0: std::option::Option<std::string::String>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "exa";
        _10 = &((*_1).1: std::option::Option<std::string::String>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:53:28: 53:35>::default() -> Definitions {
    let mut _0: theme::Definitions;
    let mut _1: std::option::Option<std::string::String>;
    let mut _2: std::option::Option<std::string::String>;

    bb0: {
        _1 = <Option<String> as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Option<String> as Default>::default() -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = Definitions { ls: move _1, exa: move _2 };
        return;
    }

    bb3 (cleanup): {
        drop(_1) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn theme::<impl at src/theme/mod.rs:65:1: 65:13>::to_theme(_1: &theme::Options, _2: bool) -> Theme {
    debug self => _1;
    debug isatty => _2;
    let mut _0: theme::Theme;
    let mut _3: bool;
    let mut _4: &theme::UseColours;
    let mut _5: bool;
    let mut _6: &theme::UseColours;
    let _7: theme::ui_styles::UiStyles;
    let mut _9: std::boxed::Box<dyn theme::FileColours>;
    let mut _10: theme::ui_styles::UiStyles;
    let mut _11: theme::ColourScale;
    let mut _14: (theme::ExtensionMappings, bool);
    let mut _15: &theme::Definitions;
    let mut _16: &mut theme::ui_styles::UiStyles;
    let mut _18: (bool, bool);
    let mut _19: bool;
    let mut _20: &theme::ExtensionMappings;
    let mut _21: std::boxed::Box<dyn theme::FileColours>;
    let mut _22: std::boxed::Box<theme::NoFileColours>;
    let mut _23: std::boxed::Box<dyn theme::FileColours>;
    let mut _24: std::boxed::Box<info::filetype::FileExtensions>;
    let mut _25: std::boxed::Box<dyn theme::FileColours>;
    let mut _26: std::boxed::Box<theme::ExtensionMappings>;
    let mut _27: theme::ExtensionMappings;
    let mut _28: std::boxed::Box<dyn theme::FileColours>;
    let mut _29: std::boxed::Box<(theme::ExtensionMappings, info::filetype::FileExtensions)>;
    let mut _30: (theme::ExtensionMappings, info::filetype::FileExtensions);
    let mut _31: theme::ExtensionMappings;
    let mut _32: theme::ui_styles::UiStyles;
    let mut _33: std::boxed::Box<dyn theme::FileColours>;
    let mut _34: &theme::UseColours;
    let mut _35: &theme::UseColours;
    let mut _36: bool;
    scope 1 {
        debug ui => _7;
        let _8: std::boxed::Box<theme::NoFileColours>;
        scope 2 {
            debug exts => _8;
        }
    }
    scope 3 {
        debug ui => _10;
        let _12: theme::ExtensionMappings;
        let _13: bool;
        scope 4 {
            debug exts => _12;
            debug use_default_filetypes => _13;
            let _17: std::boxed::Box<dyn theme::FileColours>;
            scope 5 {
                debug exts => _17;
            }
        }
    }

    bb0: {
        _36 = const false;
        _4 = &((*_1).0: theme::UseColours);
        _35 = const _;
        _3 = <UseColours as PartialEq>::eq(move _4, _35) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb5];
    }

    bb2: {
        _6 = &((*_1).0: theme::UseColours);
        _34 = const _;
        _5 = <UseColours as PartialEq>::eq(move _6, _34) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        switchInt(_2) -> [0: bb5, otherwise: bb8];
    }

    bb5: {
        _7 = ui_styles::UiStyles::plain() -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Box::<NoFileColours>::new(const NoFileColours) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = move _8 as std::boxed::Box<dyn theme::FileColours> (PointerCoercion(Unsize));
        _0 = Theme { ui: move _7, exts: move _9 };
        goto -> bb24;
    }

    bb8: {
        _11 = ((*_1).1: theme::ColourScale);
        _10 = default_theme::<impl ui_styles::UiStyles>::default_theme(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _15 = &((*_1).2: theme::Definitions);
        _16 = &mut _10;
        _14 = Definitions::parse_color_vars(move _15, _16) -> [return: bb10, unwind continue];
    }

    bb10: {
        _36 = const true;
        _12 = move (_14.0: theme::ExtensionMappings);
        _13 = (_14.1: bool);
        _20 = &_12;
        _19 = ExtensionMappings::is_non_empty(move _20) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _18 = (move _19, _13);
        switchInt((_18.0: bool)) -> [0: bb12, otherwise: bb13];
    }

    bb12: {
        switchInt((_18.1: bool)) -> [0: bb15, otherwise: bb17];
    }

    bb13: {
        switchInt((_18.1: bool)) -> [0: bb19, otherwise: bb14];
    }

    bb14: {
        _36 = const false;
        _31 = move _12;
        _30 = (move _31, const FileExtensions);
        _29 = Box::<(ExtensionMappings, FileExtensions)>::new(move _30) -> [return: bb21, unwind: bb28];
    }

    bb15: {
        _22 = Box::<NoFileColours>::new(const NoFileColours) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _21 = move _22 as std::boxed::Box<dyn theme::FileColours> (PointerCoercion(Unsize));
        _17 = move _21;
        goto -> bb22;
    }

    bb17: {
        _24 = Box::<FileExtensions>::new(const FileExtensions) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _23 = move _24 as std::boxed::Box<dyn theme::FileColours> (PointerCoercion(Unsize));
        _17 = move _23;
        goto -> bb22;
    }

    bb19: {
        _36 = const false;
        _27 = move _12;
        _26 = Box::<ExtensionMappings>::new(move _27) -> [return: bb20, unwind: bb28];
    }

    bb20: {
        _25 = move _26 as std::boxed::Box<dyn theme::FileColours> (PointerCoercion(Unsize));
        _17 = move _25;
        goto -> bb22;
    }

    bb21: {
        _28 = move _29 as std::boxed::Box<dyn theme::FileColours> (PointerCoercion(Unsize));
        _17 = move _28;
        goto -> bb22;
    }

    bb22: {
        _32 = move _10;
        _33 = move _17;
        _0 = Theme { ui: move _32, exts: move _33 };
        switchInt(_36) -> [0: bb23, otherwise: bb26];
    }

    bb23: {
        _36 = const false;
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        drop(_12) -> [return: bb23, unwind continue];
    }

    bb27 (cleanup): {
        drop(_12) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_36) -> [0: bb25, otherwise: bb27];
    }
}

promoted[0] in theme::<impl at src/theme/mod.rs:65:1: 65:13>::to_theme: &UseColours = {
    let mut _0: &theme::UseColours;
    let mut _1: theme::UseColours;

    bb0: {
        _1 = UseColours::Automatic;
        _0 = &_1;
        return;
    }
}

promoted[1] in theme::<impl at src/theme/mod.rs:65:1: 65:13>::to_theme: &UseColours = {
    let mut _0: &theme::UseColours;
    let mut _1: theme::UseColours;

    bb0: {
        _1 = UseColours::Never;
        _0 = &_1;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars(_1: &Definitions, _2: &mut ui_styles::UiStyles) -> (ExtensionMappings, bool) {
    debug self => _1;
    debug colours => _2;
    let mut _0: (theme::ExtensionMappings, bool);
    let mut _3: theme::ExtensionMappings;
    let mut _4: &std::option::Option<std::string::String>;
    let mut _5: isize;
    let _7: ();
    let mut _8: &mut theme::lsc::LSColors<'_>;
    let mut _9: theme::lsc::LSColors<'_>;
    let _10: &str;
    let mut _11: {closure@src/theme/mod.rs:107:37: 107:43};
    let mut _12: &mut &mut theme::ui_styles::UiStyles;
    let mut _13: &mut theme::ExtensionMappings;
    let mut _15: &std::option::Option<std::string::String>;
    let mut _16: isize;
    let mut _18: bool;
    let mut _19: &&std::string::String;
    let mut _20: bool;
    let _21: &str;
    let mut _22: &std::string::String;
    let _23: ();
    let mut _24: &mut theme::lsc::LSColors<'_>;
    let mut _25: theme::lsc::LSColors<'_>;
    let _26: &str;
    let mut _27: &std::string::String;
    let mut _28: {closure@src/theme/mod.rs:129:37: 129:43};
    let mut _29: &mut &mut theme::ui_styles::UiStyles;
    let mut _30: &mut theme::ExtensionMappings;
    let mut _31: theme::ExtensionMappings;
    let mut _32: bool;
    scope 1 {
        debug exts => _3;
        let mut _14: bool;
        scope 2 {
            debug lsc => _6;
            let _6: &std::string::String;
        }
        scope 3 {
            debug use_default_filetypes => _14;
            scope 4 {
                debug exa => _17;
                let _17: &std::string::String;
                let mut _33: &&str;
            }
        }
    }

    bb0: {
        _3 = <ExtensionMappings as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &((*_1).0: std::option::Option<std::string::String>);
        _5 = discriminant((*_4));
        switchInt(move _5) -> [1: bb2, otherwise: bb4];
    }

    bb2: {
        _6 = &(((*_4) as Some).0: std::string::String);
        _10 = <String as Deref>::deref(_6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _9 = LSColors::<'_>(_10);
        _8 = &mut _9;
        _12 = &mut _2;
        _13 = &mut _3;
        _11 = {closure@src/theme/mod.rs:107:37: 107:43} { colours: move _12, exts: move _13 };
        _7 = LSColors::<'_>::each_pair::<{closure@src/theme/mod.rs:107:37: 107:43}>(move _8, move _11) -> [return: bb16, unwind: bb14];
    }

    bb4: {
        _14 = const true;
        _15 = &((*_1).1: std::option::Option<std::string::String>);
        _16 = discriminant((*_15));
        switchInt(move _16) -> [1: bb5, otherwise: bb13];
    }

    bb5: {
        _17 = &(((*_15) as Some).0: std::string::String);
        _19 = &_17;
        _33 = const _;
        _18 = <&String as PartialEq<&str>>::eq(move _19, _33) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        switchInt(move _18) -> [0: bb7, otherwise: bb10];
    }

    bb7: {
        _22 = _17;
        _21 = <String as Deref>::deref(move _22) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _20 = core::str::<impl str>::starts_with::<'_, &str>(_21, const "reset:") -> [return: bb9, unwind: bb14];
    }

    bb9: {
        switchInt(move _20) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _14 = const false;
        goto -> bb11;
    }

    bb11: {
        _27 = _17;
        _26 = <String as Deref>::deref(move _27) -> [return: bb12, unwind: bb14];
    }

    bb12: {
        _25 = LSColors::<'_>(_26);
        _24 = &mut _25;
        _29 = &mut _2;
        _30 = &mut _3;
        _28 = {closure@src/theme/mod.rs:129:37: 129:43} { colours: move _29, exts: move _30 };
        _23 = LSColors::<'_>::each_pair::<{closure@src/theme/mod.rs:129:37: 129:43}>(move _24, move _28) -> [return: bb17, unwind: bb14];
    }

    bb13: {
        _31 = move _3;
        _32 = _14;
        _0 = (move _31, move _32);
        return;
    }

    bb14 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        goto -> bb4;
    }

    bb17: {
        goto -> bb13;
    }
}

promoted[0] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "reset";
        _0 = &_1;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#0}(_1: &mut {closure@src/theme/mod.rs:107:37: 107:43}, _2: Pair<'_>) -> () {
    debug pair => _2;
    debug colours => (*((*_1).0: &mut &mut theme::ui_styles::UiStyles));
    debug exts => (*((*_1).1: &mut theme::ExtensionMappings));
    let mut _0: ();
    let mut _3: bool;
    let _4: &theme::lsc::Pair<'_>;
    let mut _5: std::result::Result<glob::Pattern, glob::PatternError>;
    let mut _6: isize;
    let _7: glob::Pattern;
    let _8: ();
    let mut _9: glob::Pattern;
    let mut _10: ansi_term::Style;
    let mut _11: &theme::lsc::Pair<'_>;
    let _12: glob::PatternError;
    let mut _14: bool;
    let mut _15: &log::Level;
    let mut _16: bool;
    let mut _17: &log::Level;
    let mut _18: &log::LevelFilter;
    let _19: log::LevelFilter;
    let _20: ();
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 2];
    let _25: [core::fmt::rt::Argument<'_>; 2];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&str;
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &glob::PatternError;
    let mut _30: log::Level;
    let mut _34: &mut &mut theme::ui_styles::UiStyles;
    let mut _35: &mut theme::ui_styles::UiStyles;
    let mut _36: &str;
    let mut _37: &mut theme::ExtensionMappings;
    let mut _38: bool;
    scope 1 {
        debug pat => _7;
    }
    scope 2 {
        debug e => _12;
        let _13: log::Level;
        scope 3 {
            debug lvl => _13;
            let mut _31: &(&str, &str, &str, u32);
            let mut _32: &[&str; 2];
            let mut _33: &log::LevelFilter;
        }
    }

    bb0: {
        _38 = const false;
        _34 = deref_copy ((*_1).0: &mut &mut theme::ui_styles::UiStyles);
        _35 = deref_copy (*_34);
        _4 = &_2;
        _3 = ui_styles::UiStyles::set_ls(_35, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb17];
    }

    bb2: {
        _36 = deref_copy (_2.0: &str);
        _5 = glob::Pattern::new(_36) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_5);
        switchInt(move _6) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _12 = move ((_5 as Err).0: glob::PatternError);
        _13 = log::Level::Warn;
        _15 = &_13;
        _33 = const _;
        _14 = <Level as PartialOrd<LevelFilter>>::le(move _15, _33) -> [return: bb9, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_5 as Ok).0: glob::Pattern);
        _37 = deref_copy ((*_1).1: &mut theme::ExtensionMappings);
        _38 = const true;
        _9 = move _7;
        _11 = &_2;
        _10 = Pair::<'_>::to_style(move _11) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _38 = const false;
        _8 = ExtensionMappings::add(_37, move _9, move _10) -> [return: bb8, unwind: bb19];
    }

    bb8: {
        _38 = const false;
        goto -> bb17;
    }

    bb9: {
        switchInt(move _14) -> [0: bb17, otherwise: bb10];
    }

    bb10: {
        _17 = &_13;
        _19 = max_level() -> [return: bb11, unwind continue];
    }

    bb11: {
        _18 = &_19;
        _16 = <Level as PartialOrd<LevelFilter>>::le(move _17, move _18) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _16) -> [0: bb17, otherwise: bb13];
    }

    bb13: {
        _32 = const _;
        _22 = _32 as &[&str] (PointerCoercion(Unsize));
        _27 = &(_2.0: &str);
        _26 = core::fmt::rt::Argument::<'_>::new_debug::<&str>(_27) -> [return: bb14, unwind continue];
    }

    bb14: {
        _29 = &_12;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<PatternError>(_29) -> [return: bb15, unwind continue];
    }

    bb15: {
        _25 = [move _26, move _28];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb16, unwind continue];
    }

    bb16: {
        _30 = _13;
        _31 = const _;
        _20 = __private_api_log(move _21, move _30, _31) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_9) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_38) -> [0: bb20, otherwise: bb18];
    }

    bb20 (cleanup): {
        resume;
    }
}

promoted[0] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#0}: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::theme";
        _2 = &(*_3);
        _1 = (move _2, const "exa::theme", const "src/theme/mod.rs", const 114_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Couldn't parse glob pattern ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#0}: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#1}(_1: &mut {closure@src/theme/mod.rs:129:37: 129:43}, _2: Pair<'_>) -> () {
    debug pair => _2;
    debug colours => (*((*_1).0: &mut &mut theme::ui_styles::UiStyles));
    debug exts => (*((*_1).1: &mut theme::ExtensionMappings));
    let mut _0: ();
    let mut _3: bool;
    let _4: &theme::lsc::Pair<'_>;
    let mut _5: bool;
    let _6: &theme::lsc::Pair<'_>;
    let mut _7: std::result::Result<glob::Pattern, glob::PatternError>;
    let mut _8: isize;
    let _9: glob::Pattern;
    let _10: ();
    let mut _11: glob::Pattern;
    let mut _12: ansi_term::Style;
    let mut _13: &theme::lsc::Pair<'_>;
    let _14: glob::PatternError;
    let mut _16: bool;
    let mut _17: &log::Level;
    let mut _18: bool;
    let mut _19: &log::Level;
    let mut _20: &log::LevelFilter;
    let _21: log::LevelFilter;
    let _22: ();
    let mut _23: std::fmt::Arguments<'_>;
    let mut _24: &[&str];
    let mut _25: &[core::fmt::rt::Argument<'_>];
    let _26: &[core::fmt::rt::Argument<'_>; 2];
    let _27: [core::fmt::rt::Argument<'_>; 2];
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &&str;
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &glob::PatternError;
    let mut _32: log::Level;
    let mut _36: &mut &mut theme::ui_styles::UiStyles;
    let mut _37: &mut theme::ui_styles::UiStyles;
    let mut _38: &mut &mut theme::ui_styles::UiStyles;
    let mut _39: &mut theme::ui_styles::UiStyles;
    let mut _40: &str;
    let mut _41: &mut theme::ExtensionMappings;
    let mut _42: bool;
    scope 1 {
        debug pat => _9;
    }
    scope 2 {
        debug e => _14;
        let _15: log::Level;
        scope 3 {
            debug lvl => _15;
            let mut _33: &(&str, &str, &str, u32);
            let mut _34: &[&str; 2];
            let mut _35: &log::LevelFilter;
        }
    }

    bb0: {
        _42 = const false;
        _36 = deref_copy ((*_1).0: &mut &mut theme::ui_styles::UiStyles);
        _37 = deref_copy (*_36);
        _4 = &_2;
        _3 = ui_styles::UiStyles::set_ls(_37, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb2, otherwise: bb19];
    }

    bb2: {
        _38 = deref_copy ((*_1).0: &mut &mut theme::ui_styles::UiStyles);
        _39 = deref_copy (*_38);
        _6 = &_2;
        _5 = ui_styles::UiStyles::set_exa(_39, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb4, otherwise: bb19];
    }

    bb4: {
        _40 = deref_copy (_2.0: &str);
        _7 = glob::Pattern::new(_40) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _14 = move ((_7 as Err).0: glob::PatternError);
        _15 = log::Level::Warn;
        _17 = &_15;
        _35 = const _;
        _16 = <Level as PartialOrd<LevelFilter>>::le(move _17, _35) -> [return: bb11, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _9 = move ((_7 as Ok).0: glob::Pattern);
        _41 = deref_copy ((*_1).1: &mut theme::ExtensionMappings);
        _42 = const true;
        _11 = move _9;
        _13 = &_2;
        _12 = Pair::<'_>::to_style(move _13) -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _42 = const false;
        _10 = ExtensionMappings::add(_41, move _11, move _12) -> [return: bb10, unwind: bb21];
    }

    bb10: {
        _42 = const false;
        goto -> bb19;
    }

    bb11: {
        switchInt(move _16) -> [0: bb19, otherwise: bb12];
    }

    bb12: {
        _19 = &_15;
        _21 = max_level() -> [return: bb13, unwind continue];
    }

    bb13: {
        _20 = &_21;
        _18 = <Level as PartialOrd<LevelFilter>>::le(move _19, move _20) -> [return: bb14, unwind continue];
    }

    bb14: {
        switchInt(move _18) -> [0: bb19, otherwise: bb15];
    }

    bb15: {
        _34 = const _;
        _24 = _34 as &[&str] (PointerCoercion(Unsize));
        _29 = &(_2.0: &str);
        _28 = core::fmt::rt::Argument::<'_>::new_debug::<&str>(_29) -> [return: bb16, unwind continue];
    }

    bb16: {
        _31 = &_14;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<PatternError>(_31) -> [return: bb17, unwind continue];
    }

    bb17: {
        _27 = [move _28, move _30];
        _26 = &_27;
        _25 = _26 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _23 = std::fmt::Arguments::<'_>::new_v1(move _24, move _25) -> [return: bb18, unwind continue];
    }

    bb18: {
        _32 = _15;
        _33 = const _;
        _22 = __private_api_log(move _23, move _32, _33) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_11) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        switchInt(_42) -> [0: bb22, otherwise: bb20];
    }

    bb22 (cleanup): {
        resume;
    }
}

promoted[0] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#1}: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa::theme";
        _2 = &(*_3);
        _1 = (move _2, const "exa::theme", const "src/theme/mod.rs", const 136_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#1}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Couldn't parse glob pattern ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in theme::<impl at src/theme/mod.rs:93:1: 93:17>::parse_color_vars::{closure#1}: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:152:10: 152:19>::eq(_1: &NoFileColours, _2: &NoFileColours) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:152:21: 152:26>::fmt(_1: &NoFileColours, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "NoFileColours";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:154:1: 154:35>::colour_file(_1: &NoFileColours, _2: &file::File<'_>) -> Option<Style> {
    debug self => _1;
    debug _file => _2;
    let mut _0: std::option::Option<ansi_term::Style>;

    bb0: {
        _0 = Option::<Style>::None;
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:164:1: 166:22>::colour_file(_1: &(A, B), _2: &file::File<'_>) -> Option<Style> {
    debug self => _1;
    debug file => _2;
    let mut _0: std::option::Option<ansi_term::Style>;
    let mut _3: std::option::Option<ansi_term::Style>;
    let mut _4: &A;
    let mut _5: &fs::file::File<'_>;
    let mut _6: {closure@src/theme/mod.rs:170:22: 170:24};
    let mut _7: &&(A, B);
    let mut _8: &&fs::file::File<'_>;

    bb0: {
        _4 = &((*_1).0: A);
        _5 = _2;
        _3 = <A as FileColours>::colour_file(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_1;
        _8 = &_2;
        _6 = {closure@src/theme/mod.rs:170:22: 170:24} { self: move _7, file: move _8 };
        _0 = Option::<Style>::or_else::<{closure@src/theme/mod.rs:170:22: 170:24}>(move _3, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:164:1: 166:22>::colour_file::{closure#0}(_1: {closure@src/theme/mod.rs:170:22: 170:24}) -> Option<Style> {
    debug self => (*(_1.0: &&(A, B)));
    debug file => (*(_1.1: &&fs::file::File<'_>));
    let mut _0: std::option::Option<ansi_term::Style>;
    let mut _2: &B;
    let mut _3: &&(A, B);
    let mut _4: &(A, B);
    let mut _5: &&fs::file::File<'_>;
    let mut _6: &fs::file::File<'_>;

    bb0: {
        _3 = deref_copy (_1.0: &&(A, B));
        _4 = deref_copy (*_3);
        _2 = &((*_4).1: B);
        _5 = deref_copy (_1.1: &&fs::file::File<'_>);
        _6 = deref_copy (*_5);
        _0 = <B as FileColours>::colour_file(move _2, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:175:10: 175:19>::eq(_1: &ExtensionMappings, _2: &ExtensionMappings) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &std::vec::Vec<(glob::Pattern, ansi_term::Style)>;
    let mut _4: &std::vec::Vec<(glob::Pattern, ansi_term::Style)>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _4 = &((*_2).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _0 = <Vec<(glob::Pattern, Style)> as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:175:21: 175:26>::fmt(_1: &ExtensionMappings, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::vec::Vec<(glob::Pattern, ansi_term::Style)>;
    let _7: &std::vec::Vec<(glob::Pattern, ansi_term::Style)>;

    bb0: {
        _3 = const "ExtensionMappings";
        _4 = const "mappings";
        _7 = &((*_1).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:175:28: 175:35>::default() -> ExtensionMappings {
    let mut _0: theme::ExtensionMappings;
    let mut _1: std::vec::Vec<(glob::Pattern, ansi_term::Style)>;

    bb0: {
        _1 = <Vec<(glob::Pattern, Style)> as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ExtensionMappings { mappings: move _1 };
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:183:1: 183:39>::colour_file(_1: &ExtensionMappings, _2: &file::File<'_>) -> Option<Style> {
    debug self => _1;
    debug file => _2;
    let mut _0: std::option::Option<ansi_term::Style>;
    let mut _3: std::option::Option<&(glob::Pattern, ansi_term::Style)>;
    let mut _4: &mut std::iter::Rev<std::slice::Iter<'_, (glob::Pattern, ansi_term::Style)>>;
    let mut _5: std::iter::Rev<std::slice::Iter<'_, (glob::Pattern, ansi_term::Style)>>;
    let mut _6: std::slice::Iter<'_, (glob::Pattern, ansi_term::Style)>;
    let _7: &[(glob::Pattern, ansi_term::Style)];
    let mut _8: &std::vec::Vec<(glob::Pattern, ansi_term::Style)>;
    let mut _9: {closure@src/theme/mod.rs:186:19: 186:22};
    let mut _10: &&fs::file::File<'_>;

    bb0: {
        _8 = &((*_1).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _7 = <Vec<(glob::Pattern, Style)> as Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = core::slice::<impl [(glob::Pattern, Style)]>::iter(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = <std::slice::Iter<'_, (glob::Pattern, Style)> as Iterator>::rev(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = &mut _5;
        _10 = &_2;
        _9 = {closure@src/theme/mod.rs:186:19: 186:22} { file: move _10 };
        _3 = <Rev<std::slice::Iter<'_, (glob::Pattern, Style)>> as Iterator>::find::<{closure@src/theme/mod.rs:186:19: 186:22}>(move _4, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<&(glob::Pattern, Style)>::map::<Style, {closure@src/theme/mod.rs:187:19: 187:22}>(move _3, const ZeroSized: {closure@src/theme/mod.rs:187:19: 187:22}) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:183:1: 183:39>::colour_file::{closure#0}(_1: &mut {closure@src/theme/mod.rs:186:19: 186:22}, _2: &&(glob::Pattern, Style)) -> bool {
    debug t => _2;
    debug file => (*((*_1).0: &&fs::file::File<'_>));
    let mut _0: bool;
    let mut _3: &glob::Pattern;
    let _4: &str;
    let _5: &std::string::String;
    let mut _6: &(glob::Pattern, ansi_term::Style);
    let mut _7: &&fs::file::File<'_>;
    let mut _8: &fs::file::File<'_>;

    bb0: {
        _6 = deref_copy (*_2);
        _3 = &((*_6).0: glob::Pattern);
        _7 = deref_copy ((*_1).0: &&fs::file::File<'_>);
        _8 = deref_copy (*_7);
        _5 = &((*_8).0: std::string::String);
        _4 = <String as Deref>::deref(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = glob::Pattern::matches(move _3, _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:183:1: 183:39>::colour_file::{closure#1}(_1: {closure@src/theme/mod.rs:187:19: 187:22}, _2: &(glob::Pattern, Style)) -> Style {
    debug t => _2;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((*_2).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:191:1: 191:23>::is_non_empty(_1: &ExtensionMappings) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &std::vec::Vec<(glob::Pattern, ansi_term::Style)>;

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _2 = Vec::<(glob::Pattern, Style)>::is_empty(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _2);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:191:1: 191:23>::add(_1: &mut ExtensionMappings, _2: glob::Pattern, _3: Style) -> () {
    debug self => _1;
    debug pattern => _2;
    debug style => _3;
    let mut _0: ();
    let mut _4: &mut std::vec::Vec<(glob::Pattern, ansi_term::Style)>;
    let mut _5: (glob::Pattern, ansi_term::Style);

    bb0: {
        _4 = &mut ((*_1).0: std::vec::Vec<(glob::Pattern, ansi_term::Style)>);
        _5 = (move _2, _3);
        _0 = Vec::<(glob::Pattern, Style)>::push(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:204:1: 204:37>::block_count(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).10: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:204:1: 204:37>::no_blocks(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::normal(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::directory(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::pipe(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).3: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::symlink(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).2: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::block_device(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).4: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::char_device(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).5: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::socket(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).6: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:209:1: 209:39>::special(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::not_modified(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::new(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::modified(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::deleted(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).2: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::renamed(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).3: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::type_change(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).4: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::ignored(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).5: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:220:1: 220:34>::conflicted(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).6: theme::ui_styles::Git).6: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:232:1: 232:36>::yours(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).4: theme::ui_styles::Users).2: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:232:1: 232:36>::not_yours(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).4: theme::ui_styles::Users).3: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:237:1: 237:36>::normal(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).5: theme::ui_styles::Links).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:237:1: 237:36>::multi_link_file(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).5: theme::ui_styles::Links).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::dash(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::user_read(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::user_write(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::user_execute_file(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).2: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::user_execute_other(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).3: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::group_read(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).4: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::group_write(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).5: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::group_execute(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).6: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::other_read(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::other_write(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).8: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::other_execute(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).9: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::special_user_file(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).10: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::special_other(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).11: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:242:1: 242:42>::attribute(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).2: theme::ui_styles::Permissions).12: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::size(_1: &Theme, _2: Option<number_prefix::Prefix>) -> Style {
    debug self => _1;
    debug prefix => _2;
    let mut _0: ansi_term::Style;
    let mut _3: isize;
    let mut _4: isize;

    bb0: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb1, otherwise: bb3];
    }

    bb1: {
        _3 = discriminant(((_2 as Some).0: number_prefix::Prefix));
        switchInt(move _3) -> [0: bb5, 1: bb6, 2: bb7, 8: bb5, 9: bb6, 10: bb7, otherwise: bb2];
    }

    bb2: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).6: ansi_term::Style);
        goto -> bb8;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).2: ansi_term::Style);
        goto -> bb8;
    }

    bb5: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).3: ansi_term::Style);
        goto -> bb8;
    }

    bb6: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).4: ansi_term::Style);
        goto -> bb8;
    }

    bb7: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).5: ansi_term::Style);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::unit(_1: &Theme, _2: Option<number_prefix::Prefix>) -> Style {
    debug self => _1;
    debug prefix => _2;
    let mut _0: ansi_term::Style;
    let mut _3: isize;
    let mut _4: isize;

    bb0: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb1, otherwise: bb3];
    }

    bb1: {
        _3 = discriminant(((_2 as Some).0: number_prefix::Prefix));
        switchInt(move _3) -> [0: bb5, 1: bb6, 2: bb7, 8: bb5, 9: bb6, 10: bb7, otherwise: bb2];
    }

    bb2: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).11: ansi_term::Style);
        goto -> bb8;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).7: ansi_term::Style);
        goto -> bb8;
    }

    bb5: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).8: ansi_term::Style);
        goto -> bb8;
    }

    bb6: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).9: ansi_term::Style);
        goto -> bb8;
    }

    bb7: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).10: ansi_term::Style);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::no_size(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::major(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::comma(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:259:1: 259:35>::minor(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).3: theme::ui_styles::Size).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:290:1: 290:35>::you(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).4: theme::ui_styles::Users).0: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:290:1: 290:35>::someone_else(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).4: theme::ui_styles::Users).1: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::normal_arrow(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).7: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::broken_symlink(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).15: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::broken_filename(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;

    bb0: {
        _2 = (((*_1).0: theme::ui_styles::UiStyles).15: ansi_term::Style);
        _3 = (((*_1).0: theme::ui_styles::UiStyles).16: ansi_term::Style);
        _0 = apply_overlay(move _2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::broken_control_char(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;
    let mut _2: ansi_term::Style;
    let mut _3: ansi_term::Style;

    bb0: {
        _2 = (((*_1).0: theme::ui_styles::UiStyles).14: ansi_term::Style);
        _3 = (((*_1).0: theme::ui_styles::UiStyles).16: ansi_term::Style);
        _0 = apply_overlay(move _2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::control_char(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).14: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::symlink_path(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = (((*_1).0: theme::ui_styles::UiStyles).13: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::executable_file(_1: &Theme) -> Style {
    debug self => _1;
    let mut _0: ansi_term::Style;

    bb0: {
        _0 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).8: ansi_term::Style);
        return;
    }
}

fn theme::<impl at src/theme/mod.rs:295:1: 295:31>::colour_file(_1: &Theme, _2: &file::File<'_>) -> Style {
    debug self => _1;
    debug file => _2;
    let mut _0: ansi_term::Style;
    let mut _3: std::option::Option<ansi_term::Style>;
    let mut _4: &dyn theme::FileColours;
    let mut _5: ansi_term::Style;
    let mut _6: std::boxed::Box<dyn theme::FileColours>;
    let mut _7: *const dyn theme::FileColours;

    bb0: {
        _6 = deref_copy ((*_1).1: std::boxed::Box<dyn theme::FileColours>);
        _7 = (((_6.0: std::ptr::Unique<dyn theme::FileColours>).0: std::ptr::NonNull<dyn theme::FileColours>).0: *const dyn theme::FileColours);
        _4 = &(*_7);
        _3 = <dyn FileColours as FileColours>::colour_file(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ((((*_1).0: theme::ui_styles::UiStyles).1: theme::ui_styles::FileKinds).0: ansi_term::Style);
        _0 = Option::<Style>::unwrap_or(move _3, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn apply_overlay(_1: Style, _2: Style) -> Style {
    debug base => _1;
    debug overlay => _2;
    let mut _0: ansi_term::Style;
    let mut _3: isize;
    let mut _5: std::option::Option<ansi_term::Colour>;
    let mut _6: isize;
    let mut _8: std::option::Option<ansi_term::Colour>;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug fg => _4;
        let _4: ansi_term::Colour;
    }
    scope 2 {
        debug bg => _7;
        let _7: ansi_term::Colour;
    }

    bb0: {
        _3 = discriminant((_2.0: std::option::Option<ansi_term::Colour>));
        switchInt(move _3) -> [1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = (((_2.0: std::option::Option<ansi_term::Colour>) as Some).0: ansi_term::Colour);
        _5 = Option::<Color>::Some(_4);
        (_1.0: std::option::Option<ansi_term::Colour>) = move _5;
        goto -> bb2;
    }

    bb2: {
        _6 = discriminant((_2.1: std::option::Option<ansi_term::Colour>));
        switchInt(move _6) -> [1: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = (((_2.1: std::option::Option<ansi_term::Colour>) as Some).0: ansi_term::Colour);
        _8 = Option::<Color>::Some(_7);
        (_1.1: std::option::Option<ansi_term::Colour>) = move _8;
        goto -> bb4;
    }

    bb4: {
        _9 = (_2.2: bool);
        switchInt(move _9) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        (_1.2: bool) = const true;
        goto -> bb6;
    }

    bb6: {
        _10 = (_2.3: bool);
        switchInt(move _10) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        (_1.3: bool) = const true;
        goto -> bb8;
    }

    bb8: {
        _11 = (_2.4: bool);
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        (_1.4: bool) = const true;
        goto -> bb10;
    }

    bb10: {
        _12 = (_2.5: bool);
        switchInt(move _12) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        (_1.5: bool) = const true;
        goto -> bb12;
    }

    bb12: {
        _13 = (_2.6: bool);
        switchInt(move _13) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        (_1.6: bool) = const true;
        goto -> bb14;
    }

    bb14: {
        _14 = (_2.7: bool);
        switchInt(move _14) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        (_1.7: bool) = const true;
        goto -> bb16;
    }

    bb16: {
        _15 = (_2.8: bool);
        switchInt(move _15) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        (_1.8: bool) = const true;
        goto -> bb18;
    }

    bb18: {
        _16 = (_2.9: bool);
        switchInt(move _16) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        (_1.9: bool) = const true;
        goto -> bb20;
    }

    bb20: {
        _0 = _1;
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: std::option::Option<std::ffi::OsString>;
    let mut _3: &str;
    let mut _4: &&str;
    let _5: std::vec::Vec<std::ffi::OsString>;
    let mut _6: std::iter::Skip<std::env::ArgsOs>;
    let mut _7: std::env::ArgsOs;
    let mut _8: options::OptionsResult<'_>;
    let mut _9: std::iter::Map<std::slice::Iter<'_, std::ffi::OsString>, {closure@src/main.rs:54:42: 54:45}>;
    let mut _10: std::slice::Iter<'_, std::ffi::OsString>;
    let _11: &[std::ffi::OsString];
    let mut _12: &std::vec::Vec<std::ffi::OsString>;
    let mut _13: isize;
    let mut _16: bool;
    let mut _17: &std::vec::Vec<&std::ffi::OsStr>;
    let mut _18: std::vec::Vec<&std::ffi::OsStr>;
    let mut _19: std::boxed::Box<[&std::ffi::OsStr]>;
    let mut _20: std::boxed::Box<[&std::ffi::OsStr; 1]>;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: *mut u8;
    let mut _24: std::boxed::Box<[&std::ffi::OsStr; 1]>;
    let _25: &std::ffi::OsStr;
    let _26: &str;
    let _28: &options::Options;
    let _29: &[&std::ffi::OsStr];
    let _30: &std::vec::Vec<&std::ffi::OsStr>;
    let mut _33: output::TerminalWidth;
    let mut _35: &theme::Options;
    let mut _36: bool;
    let mut _37: &std::option::Option<usize>;
    let mut _39: options::Options;
    let mut _40: std::vec::Vec<&std::ffi::OsStr>;
    let mut _41: std::option::Option<usize>;
    let mut _42: std::option::Option<fs::feature::git::GitCache>;
    let mut _43: std::result::Result<i32, std::io::Error>;
    let mut _44: isize;
    let _46: !;
    let mut _49: bool;
    let mut _50: &std::io::ErrorKind;
    let _51: std::io::ErrorKind;
    let mut _53: bool;
    let mut _54: &log::Level;
    let mut _55: bool;
    let mut _56: &log::Level;
    let mut _57: &log::LevelFilter;
    let _58: log::LevelFilter;
    let _59: ();
    let mut _60: std::fmt::Arguments<'_>;
    let mut _61: &[&str];
    let mut _62: &[core::fmt::rt::Argument<'_>];
    let _63: &[core::fmt::rt::Argument<'_>; 1];
    let _64: [core::fmt::rt::Argument<'_>; 1];
    let mut _65: core::fmt::rt::Argument<'_>;
    let _66: &std::io::Error;
    let mut _67: log::Level;
    let _68: !;
    let _70: ();
    let mut _71: std::fmt::Arguments<'_>;
    let mut _72: &[&str];
    let mut _73: &[core::fmt::rt::Argument<'_>];
    let _74: &[core::fmt::rt::Argument<'_>; 1];
    let _75: [core::fmt::rt::Argument<'_>; 1];
    let mut _76: core::fmt::rt::Argument<'_>;
    let _77: &std::io::Error;
    let _78: !;
    let _80: ();
    let mut _81: std::fmt::Arguments<'_>;
    let mut _82: &[&str];
    let mut _83: &[core::fmt::rt::Argument<'_>];
    let _84: &[core::fmt::rt::Argument<'_>; 1];
    let _85: [core::fmt::rt::Argument<'_>; 1];
    let mut _86: core::fmt::rt::Argument<'_>;
    let _87: &options::help::HelpString;
    let _89: ();
    let mut _90: std::fmt::Arguments<'_>;
    let mut _91: &[&str];
    let mut _92: &[core::fmt::rt::Argument<'_>];
    let _93: &[core::fmt::rt::Argument<'_>; 1];
    let _94: [core::fmt::rt::Argument<'_>; 1];
    let mut _95: core::fmt::rt::Argument<'_>;
    let _96: &options::version::VersionString;
    let _98: ();
    let mut _99: std::fmt::Arguments<'_>;
    let mut _100: &[&str];
    let mut _101: &[core::fmt::rt::Argument<'_>];
    let _102: &[core::fmt::rt::Argument<'_>; 1];
    let _103: [core::fmt::rt::Argument<'_>; 1];
    let mut _104: core::fmt::rt::Argument<'_>;
    let _105: &options::error::OptionsError;
    let mut _106: std::option::Option<&str>;
    let mut _107: &options::error::OptionsError;
    let mut _108: isize;
    let _110: ();
    let mut _111: std::fmt::Arguments<'_>;
    let mut _112: &[&str];
    let mut _113: &[core::fmt::rt::Argument<'_>];
    let _114: &[core::fmt::rt::Argument<'_>; 1];
    let _115: [core::fmt::rt::Argument<'_>; 1];
    let mut _116: core::fmt::rt::Argument<'_>;
    let _117: &&str;
    let _118: !;
    let mut _129: bool;
    let mut _130: bool;
    let mut _131: bool;
    let mut _132: bool;
    let mut _133: isize;
    let mut _134: *const [&std::ffi::OsStr; 1];
    scope 1 {
        debug args => _5;
        let _14: options::Options;
        let mut _15: std::vec::Vec<&std::ffi::OsStr>;
        let _79: options::help::HelpString;
        let _88: options::version::VersionString;
        let _97: options::error::OptionsError;
        let mut _128: &LiveVars;
        scope 2 {
            debug options => _14;
            debug input_paths => _15;
            let _27: std::option::Option<fs::feature::git::GitCache>;
            let mut _135: *const ();
            let mut _136: usize;
            let mut _137: usize;
            let mut _138: usize;
            let mut _139: usize;
            let mut _140: bool;
            scope 3 {
            }
            scope 4 {
                debug git => _27;
                let _31: std::io::Stdout;
                scope 5 {
                    debug writer => _31;
                    let _32: std::option::Option<usize>;
                    scope 6 {
                        debug console_width => _32;
                        let _34: theme::Theme;
                        scope 7 {
                            debug theme => _34;
                            let _38: Exa<'_>;
                            scope 8 {
                                debug exa => _38;
                                let _45: i32;
                                let _47: std::io::Error;
                                let _48: &std::io::Error;
                                let _69: std::io::Error;
                                let mut _127: &std::io::ErrorKind;
                                scope 9 {
                                    debug exit_status => _45;
                                }
                                scope 10 {
                                    debug e => _47;
                                    debug e => _48;
                                    let _52: log::Level;
                                    scope 11 {
                                        debug lvl => _52;
                                        let mut _124: &(&str, &str, &str, u32);
                                        let mut _125: &[&str; 1];
                                        let mut _126: &log::LevelFilter;
                                    }
                                }
                                scope 12 {
                                    debug e => _69;
                                    let mut _123: &[&str; 2];
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 13 {
            debug help_text => const HelpString;
            let mut _122: &[&str; 1];
        }
        scope 14 {
            debug version_str => const VersionString;
            let mut _121: &[&str; 1];
        }
        scope 15 {
            debug error => _97;
            let mut _120: &[&str; 2];
            scope 16 {
                debug s => _109;
                let _109: &str;
                let mut _119: &[&str; 2];
            }
        }
    }

    bb0: {
        _132 = const false;
        _131 = const false;
        _130 = const false;
        _129 = const false;
        _4 = const {alloc100: &&str};
        _3 = (*_4);
        _2 = var_os::<&str>(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = configure::<OsString>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = args_os() -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <ArgsOs as Iterator>::skip(move _7, const 1_usize) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <std::iter::Skip<ArgsOs> as Iterator>::collect::<Vec<OsString>>(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = &_5;
        _11 = <Vec<OsString> as Deref>::deref(move _12) -> [return: bb6, unwind: bb67];
    }

    bb6: {
        _10 = core::slice::<impl [OsString]>::iter(_11) -> [return: bb7, unwind: bb67];
    }

    bb7: {
        _9 = <std::slice::Iter<'_, OsString> as Iterator>::map::<&OsStr, {closure@src/main.rs:54:42: 54:45}>(move _10, const ZeroSized: {closure@src/main.rs:54:42: 54:45}) -> [return: bb8, unwind: bb67];
    }

    bb8: {
        _128 = const _;
        _8 = options::Options::parse::<'_, Map<std::slice::Iter<'_, OsString>, {closure@src/main.rs:54:42: 54:45}>, LiveVars>(move _9, _128) -> [return: bb9, unwind: bb67];
    }

    bb9: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb12, 1: bb10, 2: bb45, 3: bb48, otherwise: bb11];
    }

    bb10: {
        _97 = move ((_8 as InvalidOptions).0: options::error::OptionsError);
        _120 = const _;
        _100 = _120 as &[&str] (PointerCoercion(Unsize));
        _105 = &_97;
        _104 = core::fmt::rt::Argument::<'_>::new_display::<OptionsError>(_105) -> [return: bb51, unwind: bb61];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _132 = const true;
        _14 = move ((_8 as Ok).0: options::Options);
        _131 = const true;
        _15 = move ((_8 as Ok).1: std::vec::Vec<&std::ffi::OsStr>);
        _17 = &_15;
        _16 = Vec::<&OsStr>::is_empty(move _17) -> [return: bb13, unwind: bb75];
    }

    bb13: {
        switchInt(move _16) -> [0: bb20, otherwise: bb14];
    }

    bb14: {
        _21 = SizeOf([&std::ffi::OsStr; 1]);
        _22 = AlignOf([&std::ffi::OsStr; 1]);
        _23 = alloc::alloc::exchange_malloc(move _21, move _22) -> [return: bb15, unwind: bb75];
    }

    bb15: {
        _24 = ShallowInitBox(move _23, [&std::ffi::OsStr; 1]);
        _26 = const ".";
        _25 = OsStr::new::<str>(_26) -> [return: bb16, unwind: bb64];
    }

    bb16: {
        _134 = (((_24.0: std::ptr::Unique<[&std::ffi::OsStr; 1]>).0: std::ptr::NonNull<[&std::ffi::OsStr; 1]>).0: *const [&std::ffi::OsStr; 1]);
        _135 = _134 as *const () (PtrToPtr);
        _136 = _135 as usize (Transmute);
        _137 = AlignOf([&std::ffi::OsStr; 1]);
        _138 = Sub(_137, const 1_usize);
        _139 = BitAnd(_136, _138);
        _140 = Eq(_139, const 0_usize);
        assert(_140, "misaligned pointer dereference: address must be a multiple of {} but is {}", _137, _136) -> [success: bb77, unwind unreachable];
    }

    bb17: {
        drop(_15) -> [return: bb18, unwind: bb19];
    }

    bb18: {
        _131 = const true;
        _15 = move _18;
        goto -> bb20;
    }

    bb19 (cleanup): {
        _131 = const true;
        _15 = move _18;
        goto -> bb75;
    }

    bb20: {
        _28 = &_14;
        _30 = &_15;
        _29 = <Vec<&OsStr> as Deref>::deref(_30) -> [return: bb21, unwind: bb75];
    }

    bb21: {
        _27 = git_options(_28, _29) -> [return: bb22, unwind: bb75];
    }

    bb22: {
        _130 = const true;
        _31 = stdout() -> [return: bb23, unwind: bb73];
    }

    bb23: {
        _33 = ((_14.2: output::View).1: output::TerminalWidth);
        _32 = TerminalWidth::actual_terminal_width(move _33) -> [return: bb24, unwind: bb73];
    }

    bb24: {
        _35 = &(_14.3: theme::Options);
        _37 = &_32;
        _36 = Option::<usize>::is_some(move _37) -> [return: bb25, unwind: bb73];
    }

    bb25: {
        _34 = theme::Options::to_theme(move _35, move _36) -> [return: bb26, unwind: bb73];
    }

    bb26: {
        _132 = const false;
        _39 = move _14;
        _131 = const false;
        _40 = move _15;
        _41 = _32;
        _130 = const false;
        _42 = move _27;
        _38 = Exa::<'_> { options: move _39, writer: move _31, input_paths: move _40, theme: move _34, console_width: move _41, git: move _42 };
        _43 = Exa::<'_>::run(move _38) -> [return: bb27, unwind: bb73];
    }

    bb27: {
        _129 = const true;
        _44 = discriminant(_43);
        switchInt(move _44) -> [0: bb28, 1: bb29, otherwise: bb11];
    }

    bb28: {
        _45 = ((_43 as Ok).0: i32);
        _46 = std::process::exit(_45) -> bb71;
    }

    bb29: {
        _48 = &((_43 as Err).0: std::io::Error);
        _51 = std::io::Error::kind(_48) -> [return: bb30, unwind: bb71];
    }

    bb30: {
        _50 = &_51;
        _127 = const _;
        _49 = <ErrorKind as PartialEq>::eq(move _50, _127) -> [return: bb31, unwind: bb71];
    }

    bb31: {
        switchInt(move _49) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _129 = const false;
        _47 = move ((_43 as Err).0: std::io::Error);
        _52 = log::Level::Warn;
        _54 = &_52;
        _126 = const _;
        _53 = <Level as PartialOrd<LevelFilter>>::le(move _54, _126) -> [return: bb34, unwind: bb63];
    }

    bb33: {
        _129 = const false;
        _69 = move ((_43 as Err).0: std::io::Error);
        _123 = const _;
        _72 = _123 as &[&str] (PointerCoercion(Unsize));
        _77 = &_69;
        _76 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_77) -> [return: bb42, unwind: bb62];
    }

    bb34: {
        switchInt(move _53) -> [0: bb41, otherwise: bb35];
    }

    bb35: {
        _56 = &_52;
        _58 = max_level() -> [return: bb36, unwind: bb63];
    }

    bb36: {
        _57 = &_58;
        _55 = <Level as PartialOrd<LevelFilter>>::le(move _56, move _57) -> [return: bb37, unwind: bb63];
    }

    bb37: {
        switchInt(move _55) -> [0: bb41, otherwise: bb38];
    }

    bb38: {
        _125 = const _;
        _61 = _125 as &[&str] (PointerCoercion(Unsize));
        _66 = &_47;
        _65 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_66) -> [return: bb39, unwind: bb63];
    }

    bb39: {
        _64 = [move _65];
        _63 = &_64;
        _62 = _63 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _60 = std::fmt::Arguments::<'_>::new_v1(move _61, move _62) -> [return: bb40, unwind: bb63];
    }

    bb40: {
        _67 = _52;
        _124 = const _;
        _59 = __private_api_log(move _60, move _67, _124) -> [return: bb78, unwind: bb63];
    }

    bb41: {
        _68 = std::process::exit(const _) -> bb63;
    }

    bb42: {
        _75 = [move _76];
        _74 = &_75;
        _73 = _74 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _71 = std::fmt::Arguments::<'_>::new_v1(move _72, move _73) -> [return: bb43, unwind: bb62];
    }

    bb43: {
        _70 = _eprint(move _71) -> [return: bb44, unwind: bb62];
    }

    bb44: {
        _78 = std::process::exit(const _) -> bb62;
    }

    bb45: {
        _122 = const _;
        _82 = _122 as &[&str] (PointerCoercion(Unsize));
        _87 = &_79;
        _86 = core::fmt::rt::Argument::<'_>::new_display::<HelpString>(_87) -> [return: bb46, unwind: bb66];
    }

    bb46: {
        _85 = [move _86];
        _84 = &_85;
        _83 = _84 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _81 = std::fmt::Arguments::<'_>::new_v1(move _82, move _83) -> [return: bb47, unwind: bb66];
    }

    bb47: {
        _80 = _print(move _81) -> [return: bb79, unwind: bb66];
    }

    bb48: {
        _121 = const _;
        _91 = _121 as &[&str] (PointerCoercion(Unsize));
        _96 = &_88;
        _95 = core::fmt::rt::Argument::<'_>::new_display::<VersionString>(_96) -> [return: bb49, unwind: bb66];
    }

    bb49: {
        _94 = [move _95];
        _93 = &_94;
        _92 = _93 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _90 = std::fmt::Arguments::<'_>::new_v1(move _91, move _92) -> [return: bb50, unwind: bb66];
    }

    bb50: {
        _89 = _print(move _90) -> [return: bb80, unwind: bb66];
    }

    bb51: {
        _103 = [move _104];
        _102 = &_103;
        _101 = _102 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _99 = std::fmt::Arguments::<'_>::new_v1(move _100, move _101) -> [return: bb52, unwind: bb61];
    }

    bb52: {
        _98 = _eprint(move _99) -> [return: bb53, unwind: bb61];
    }

    bb53: {
        _107 = &_97;
        _106 = OptionsError::suggestion(move _107) -> [return: bb54, unwind: bb61];
    }

    bb54: {
        _108 = discriminant(_106);
        switchInt(move _108) -> [1: bb55, otherwise: bb58];
    }

    bb55: {
        _109 = ((_106 as Some).0: &str);
        _119 = const _;
        _112 = _119 as &[&str] (PointerCoercion(Unsize));
        _117 = &_109;
        _116 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_117) -> [return: bb56, unwind: bb61];
    }

    bb56: {
        _115 = [move _116];
        _114 = &_115;
        _113 = _114 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _111 = std::fmt::Arguments::<'_>::new_v1(move _112, move _113) -> [return: bb57, unwind: bb61];
    }

    bb57: {
        _110 = _eprint(move _111) -> [return: bb81, unwind: bb61];
    }

    bb58: {
        _118 = std::process::exit(const _) -> bb61;
    }

    bb59: {
        drop(_5) -> [return: bb60, unwind continue];
    }

    bb60: {
        return;
    }

    bb61 (cleanup): {
        drop(_97) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_69) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_47) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_24) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        switchInt(_132) -> [0: bb66, otherwise: bb76];
    }

    bb66 (cleanup): {
        drop(_5) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        drop(_5) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        resume;
    }

    bb69 (cleanup): {
        switchInt(_129) -> [0: bb75, otherwise: bb70];
    }

    bb70 (cleanup): {
        drop(((_43 as Err).0: std::io::Error)) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        _133 = discriminant(_43);
        switchInt(move _133) -> [1: bb69, otherwise: bb75];
    }

    bb72 (cleanup): {
        drop(_27) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        switchInt(_130) -> [0: bb75, otherwise: bb72];
    }

    bb74 (cleanup): {
        drop(_15) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        switchInt(_131) -> [0: bb65, otherwise: bb74];
    }

    bb76 (cleanup): {
        drop(_14) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb77: {
        (*_134) = [_25];
        _20 = move _24;
        _19 = move _20 as std::boxed::Box<[&std::ffi::OsStr]> (PointerCoercion(Unsize));
        _18 = slice::<impl [&OsStr]>::into_vec::<std::alloc::Global>(move _19) -> [return: bb17, unwind: bb75];
    }

    bb78: {
        goto -> bb41;
    }

    bb79: {
        goto -> bb59;
    }

    bb80: {
        goto -> bb59;
    }

    bb81: {
        goto -> bb58;
    }
}

alloc100 (static: EXA_DEBUG, size: 16, align: 8) {
    alloc3980<imm> 09 00 00 00 00 00 00 00  ........
}

alloc3980 (size: 9, align: 1) {
    45 58 41 5f 44 45 42 55 47                       EXA_DEBUG
}

promoted[0] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "exa: ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[3] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

promoted[4] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[5] in main: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa";
        _2 = &(*_3);
        _1 = (move _2, const "exa", const "src/main.rs", const 76_u32);
        _0 = &_1;
        return;
    }
}

promoted[6] in main: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Broken pipe error: "];
        _0 = &_1;
        return;
    }
}

promoted[7] in main: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in main: &ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = BrokenPipe;
        _0 = &_1;
        return;
    }
}

promoted[9] in main: &LiveVars = {
    let mut _0: &LiveVars;
    let mut _1: LiveVars;

    bb0: {
        _1 = LiveVars;
        _0 = &_1;
        return;
    }
}

fn main::{closure#0}(_1: &mut {closure@src/main.rs:54:42: 54:45}, _2: &OsString) -> &OsStr {
    debug e => _2;
    let mut _0: &std::ffi::OsStr;

    bb0: {
        _0 = <OsString as AsRef<OsStr>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/main.rs:140:1: 140:23>::get(_1: &LiveVars, _2: &str) -> Option<OsString> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<std::ffi::OsString>;

    bb0: {
        _0 = var_os::<&str>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn git_options(_1: &options::Options, _2: &[&OsStr]) -> Option<GitCache> {
    debug options => _1;
    debug args => _2;
    let mut _0: std::option::Option<fs::feature::git::GitCache>;
    let mut _3: bool;
    let mut _4: fs::feature::git::GitCache;
    let mut _5: std::iter::Map<std::slice::Iter<'_, &std::ffi::OsStr>, fn(&&std::ffi::OsStr) -> std::path::PathBuf {<std::path::PathBuf as std::convert::From<&&std::ffi::OsStr>>::from}>;
    let mut _6: std::slice::Iter<'_, &std::ffi::OsStr>;

    bb0: {
        _3 = options::Options::should_scan_for_git(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb6, otherwise: bb2];
    }

    bb2: {
        _6 = core::slice::<impl [&OsStr]>::iter(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::slice::Iter<'_, &OsStr> as Iterator>::map::<PathBuf, fn(&&OsStr) -> PathBuf {<PathBuf as From<&&OsStr>>::from}>(move _6, <PathBuf as From<&&OsStr>>::from) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <Map<std::slice::Iter<'_, &OsStr>, fn(&&OsStr) -> PathBuf {<PathBuf as From<&&OsStr>>::from}> as Iterator>::collect::<GitCache>(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Option::<GitCache>::Some(move _4);
        goto -> bb7;
    }

    bb6: {
        _0 = Option::<GitCache>::None;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn <impl at src/main.rs:157:1: 157:23>::run(_1: Exa<'_>) -> Result<i32, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let _2: log::Level;
    let mut _3: bool;
    let mut _4: &log::Level;
    let mut _5: bool;
    let mut _6: &log::Level;
    let mut _7: &log::LevelFilter;
    let _8: log::LevelFilter;
    let _9: ();
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &options::Options;
    let mut _17: &[core::fmt::rt::Placeholder];
    let _18: &[core::fmt::rt::Placeholder; 1];
    let _19: [core::fmt::rt::Placeholder; 1];
    let mut _20: core::fmt::rt::Placeholder;
    let mut _21: core::fmt::rt::Alignment;
    let mut _22: core::fmt::rt::Count;
    let mut _23: core::fmt::rt::Count;
    let mut _24: core::fmt::rt::UnsafeArg;
    let mut _25: log::Level;
    let mut _26: std::vec::Vec<fs::file::File<'_>>;
    let mut _29: std::slice::Iter<'_, &std::ffi::OsStr>;
    let mut _30: &std::vec::Vec<&std::ffi::OsStr>;
    let _32: ();
    let mut _33: std::option::Option<&&std::ffi::OsStr>;
    let mut _34: &mut std::slice::Iter<'_, &std::ffi::OsStr>;
    let mut _35: isize;
    let mut _37: std::result::Result<fs::file::File<'_>, std::io::Error>;
    let mut _38: std::path::PathBuf;
    let mut _39: &&std::ffi::OsStr;
    let mut _40: std::option::Option<&fs::dir::Dir>;
    let mut _41: std::option::Option<std::string::String>;
    let mut _42: isize;
    let mut _44: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _45: std::result::Result<(), std::io::Error>;
    let mut _46: &mut std::io::Stderr;
    let mut _47: std::io::Stderr;
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 2];
    let _52: [core::fmt::rt::Argument<'_>; 2];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &&&std::ffi::OsStr;
    let mut _55: core::fmt::rt::Argument<'_>;
    let _56: &std::io::Error;
    let mut _57: isize;
    let mut _60: bool;
    let mut _61: &fs::file::File<'_>;
    let mut _62: bool;
    let mut _63: fs::dir_action::DirAction;
    let mut _64: std::result::Result<fs::dir::Dir, std::io::Error>;
    let mut _65: &fs::file::File<'_>;
    let mut _66: isize;
    let mut _68: &mut std::vec::Vec<fs::dir::Dir>;
    let mut _70: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _71: std::result::Result<(), std::io::Error>;
    let mut _72: &mut std::io::Stderr;
    let mut _73: std::io::Stderr;
    let mut _74: std::fmt::Arguments<'_>;
    let mut _75: &[&str];
    let mut _76: &[core::fmt::rt::Argument<'_>];
    let _77: &[core::fmt::rt::Argument<'_>; 2];
    let _78: [core::fmt::rt::Argument<'_>; 2];
    let mut _79: core::fmt::rt::Argument<'_>;
    let _80: &&&std::ffi::OsStr;
    let mut _81: core::fmt::rt::Argument<'_>;
    let _82: &std::io::Error;
    let mut _83: isize;
    let _85: ();
    let mut _86: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _87: fs::file::File<'_>;
    let mut _89: &std::vec::Vec<fs::file::File<'_>>;
    let mut _91: usize;
    let mut _92: &std::vec::Vec<fs::dir::Dir>;
    let _93: ();
    let mut _94: &fs::filter::FileFilter;
    let mut _95: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _96: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _97: std::result::Result<(), std::io::Error>;
    let mut _98: &mut Exa<'_>;
    let mut _99: std::option::Option<&fs::dir::Dir>;
    let mut _100: std::vec::Vec<fs::file::File<'_>>;
    let mut _101: isize;
    let mut _103: &mut Exa<'_>;
    let mut _104: std::vec::Vec<fs::dir::Dir>;
    let mut _105: bool;
    let mut _106: i32;
    let mut _112: bool;
    let mut _113: bool;
    let mut _114: bool;
    scope 1 {
        debug lvl => _2;
        let mut _109: &(&str, &str, &str, u32);
        let mut _110: &[&str; 1];
        let mut _111: &log::LevelFilter;
        scope 2 {
        }
    }
    scope 3 {
        debug files => _26;
        let mut _27: std::vec::Vec<fs::dir::Dir>;
        scope 4 {
            debug dirs => _27;
            let mut _28: i32;
            scope 5 {
                debug exit_status => _28;
                let mut _31: std::slice::Iter<'_, &std::ffi::OsStr>;
                let _88: bool;
                scope 6 {
                    debug iter => _31;
                    let _36: &&std::ffi::OsStr;
                    scope 7 {
                        debug file_path => _36;
                        let _43: std::io::Error;
                        let _59: fs::file::File<'_>;
                        scope 8 {
                            debug e => _43;
                            let _58: std::result::Result<std::convert::Infallible, std::io::Error>;
                            let mut _108: &[&str; 3];
                            scope 9 {
                                debug residual => _58;
                                scope 10 {
                                }
                            }
                            scope 11 {
                                debug val => const ();
                                scope 12 {
                                }
                            }
                        }
                        scope 13 {
                            debug f => _59;
                            let _67: fs::dir::Dir;
                            let _69: std::io::Error;
                            scope 14 {
                                debug d => _67;
                            }
                            scope 15 {
                                debug e => _69;
                                let _84: std::result::Result<std::convert::Infallible, std::io::Error>;
                                let mut _107: &[&str; 3];
                                scope 16 {
                                    debug residual => _84;
                                    scope 17 {
                                    }
                                }
                                scope 18 {
                                    debug val => const ();
                                    scope 19 {
                                    }
                                }
                            }
                        }
                    }
                }
                scope 20 {
                    debug no_files => _88;
                    let _90: bool;
                    scope 21 {
                        debug is_only_dir => _90;
                        let _102: std::result::Result<std::convert::Infallible, std::io::Error>;
                        scope 22 {
                            debug residual => _102;
                            scope 23 {
                            }
                        }
                        scope 24 {
                            debug val => const ();
                            scope 25 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _113 = const false;
        _114 = const false;
        _112 = const false;
        _2 = log::Level::Debug;
        _4 = &_2;
        _111 = const _;
        _3 = <Level as PartialOrd<LevelFilter>>::le(move _4, _111) -> [return: bb1, unwind: bb70];
    }

    bb1: {
        switchInt(move _3) -> [0: bb10, otherwise: bb2];
    }

    bb2: {
        _6 = &_2;
        _8 = max_level() -> [return: bb3, unwind: bb70];
    }

    bb3: {
        _7 = &_8;
        _5 = <Level as PartialOrd<LevelFilter>>::le(move _6, move _7) -> [return: bb4, unwind: bb70];
    }

    bb4: {
        switchInt(move _5) -> [0: bb10, otherwise: bb5];
    }

    bb5: {
        _110 = const _;
        _11 = _110 as &[&str] (PointerCoercion(Unsize));
        _16 = &(_1.0: options::Options);
        _15 = core::fmt::rt::Argument::<'_>::new_debug::<options::Options>(_16) -> [return: bb6, unwind: bb70];
    }

    bb6: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = core::fmt::rt::Alignment::Unknown;
        _22 = core::fmt::rt::Count::Implied;
        _23 = core::fmt::rt::Count::Implied;
        _20 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _21, const 4_u32, move _22, move _23) -> [return: bb7, unwind: bb70];
    }

    bb7: {
        _19 = [move _20];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _24 = core::fmt::rt::UnsafeArg::new() -> [return: bb8, unwind: bb70];
    }

    bb8: {
        _10 = std::fmt::Arguments::<'_>::new_v1_formatted(move _11, move _12, move _17, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb9, unwind: bb70];
    }

    bb9: {
        _25 = _2;
        _109 = const _;
        _9 = __private_api_log(move _10, move _25, _109) -> [return: bb80, unwind: bb70];
    }

    bb10: {
        _26 = Vec::<file::File<'_>>::new() -> [return: bb11, unwind: bb70];
    }

    bb11: {
        _113 = const true;
        _27 = Vec::<Dir>::new() -> [return: bb12, unwind: bb79];
    }

    bb12: {
        _114 = const true;
        _28 = const 0_i32;
        _30 = &(_1.2: std::vec::Vec<&std::ffi::OsStr>);
        _29 = <&Vec<&OsStr> as IntoIterator>::into_iter(move _30) -> [return: bb13, unwind: bb77];
    }

    bb13: {
        _31 = move _29;
        goto -> bb14;
    }

    bb14: {
        _34 = &mut _31;
        _33 = <std::slice::Iter<'_, &OsStr> as Iterator>::next(_34) -> [return: bb15, unwind: bb77];
    }

    bb15: {
        _35 = discriminant(_33);
        switchInt(move _35) -> [0: bb18, 1: bb16, otherwise: bb17];
    }

    bb16: {
        _36 = ((_33 as Some).0: &&std::ffi::OsStr);
        _39 = _36;
        _38 = <PathBuf as From<&&OsStr>>::from(move _39) -> [return: bb19, unwind: bb77];
    }

    bb17: {
        unreachable;
    }

    bb18: {
        _89 = &_26;
        _88 = Vec::<file::File<'_>>::is_empty(move _89) -> [return: bb51, unwind: bb77];
    }

    bb19: {
        _40 = Option::<&Dir>::None;
        _41 = Option::<String>::None;
        _37 = file::File::<'_>::from_args::<Option<&Dir>, Option<String>>(move _38, move _40, move _41) -> [return: bb20, unwind: bb77];
    }

    bb20: {
        _42 = discriminant(_37);
        switchInt(move _42) -> [0: bb21, 1: bb22, otherwise: bb17];
    }

    bb21: {
        _112 = const true;
        _59 = move ((_37 as Ok).0: fs::file::File<'_>);
        _61 = &_59;
        _60 = file::File::<'_>::points_to_directory(move _61) -> [return: bb32, unwind: bb75];
    }

    bb22: {
        _43 = move ((_37 as Err).0: std::io::Error);
        _28 = const 2_i32;
        _47 = stderr() -> [return: bb23, unwind: bb69];
    }

    bb23: {
        _46 = &mut _47;
        _108 = const _;
        _49 = _108 as &[&str] (PointerCoercion(Unsize));
        _54 = &_36;
        _53 = core::fmt::rt::Argument::<'_>::new_debug::<&&OsStr>(_54) -> [return: bb24, unwind: bb69];
    }

    bb24: {
        _56 = &_43;
        _55 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_56) -> [return: bb25, unwind: bb69];
    }

    bb25: {
        _52 = [move _53, move _55];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = std::fmt::Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb26, unwind: bb69];
    }

    bb26: {
        _45 = <Stderr as std::io::Write>::write_fmt(move _46, move _48) -> [return: bb27, unwind: bb69];
    }

    bb27: {
        _44 = <Result<(), std::io::Error> as Try>::branch(move _45) -> [return: bb28, unwind: bb69];
    }

    bb28: {
        _57 = discriminant(_44);
        switchInt(move _57) -> [0: bb29, 1: bb30, otherwise: bb17];
    }

    bb29: {
        drop(_43) -> [return: bb14, unwind: bb77];
    }

    bb30: {
        _58 = move ((_44 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _58) -> [return: bb31, unwind: bb69];
    }

    bb31: {
        drop(_43) -> [return: bb64, unwind: bb77];
    }

    bb32: {
        switchInt(move _60) -> [0: bb48, otherwise: bb33];
    }

    bb33: {
        _63 = ((_1.0: options::Options).0: fs::dir_action::DirAction);
        _62 = DirAction::treat_dirs_as_files(move _63) -> [return: bb34, unwind: bb75];
    }

    bb34: {
        switchInt(move _62) -> [0: bb35, otherwise: bb48];
    }

    bb35: {
        _65 = &_59;
        _64 = file::File::<'_>::to_dir(move _65) -> [return: bb36, unwind: bb75];
    }

    bb36: {
        _66 = discriminant(_64);
        switchInt(move _66) -> [0: bb38, 1: bb37, otherwise: bb17];
    }

    bb37: {
        _69 = move ((_64 as Err).0: std::io::Error);
        _73 = stderr() -> [return: bb39, unwind: bb68];
    }

    bb38: {
        _67 = move ((_64 as Ok).0: fs::dir::Dir);
        _68 = &mut _27;
        _32 = Vec::<Dir>::push(move _68, move _67) -> [return: bb81, unwind: bb75];
    }

    bb39: {
        _72 = &mut _73;
        _107 = const _;
        _75 = _107 as &[&str] (PointerCoercion(Unsize));
        _80 = &_36;
        _79 = core::fmt::rt::Argument::<'_>::new_debug::<&&OsStr>(_80) -> [return: bb40, unwind: bb68];
    }

    bb40: {
        _82 = &_69;
        _81 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_82) -> [return: bb41, unwind: bb68];
    }

    bb41: {
        _78 = [move _79, move _81];
        _77 = &_78;
        _76 = _77 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _74 = std::fmt::Arguments::<'_>::new_v1(move _75, move _76) -> [return: bb42, unwind: bb68];
    }

    bb42: {
        _71 = <Stderr as std::io::Write>::write_fmt(move _72, move _74) -> [return: bb43, unwind: bb68];
    }

    bb43: {
        _70 = <Result<(), std::io::Error> as Try>::branch(move _71) -> [return: bb44, unwind: bb68];
    }

    bb44: {
        _83 = discriminant(_70);
        switchInt(move _83) -> [0: bb45, 1: bb46, otherwise: bb17];
    }

    bb45: {
        drop(_69) -> [return: bb49, unwind: bb75];
    }

    bb46: {
        _84 = move ((_70 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _84) -> [return: bb47, unwind: bb68];
    }

    bb47: {
        drop(_69) -> [return: bb62, unwind: bb75];
    }

    bb48: {
        _86 = &mut _26;
        _112 = const false;
        _87 = move _59;
        _85 = Vec::<file::File<'_>>::push(move _86, move _87) -> [return: bb82, unwind: bb75];
    }

    bb49: {
        switchInt(_112) -> [0: bb50, otherwise: bb72];
    }

    bb50: {
        _112 = const false;
        goto -> bb14;
    }

    bb51: {
        _92 = &_27;
        _91 = Vec::<Dir>::len(move _92) -> [return: bb52, unwind: bb77];
    }

    bb52: {
        switchInt(move _91) -> [1: bb53, otherwise: bb54];
    }

    bb53: {
        _90 = _88;
        goto -> bb55;
    }

    bb54: {
        _90 = const false;
        goto -> bb55;
    }

    bb55: {
        _94 = &((_1.0: options::Options).1: fs::filter::FileFilter);
        _95 = &mut _26;
        _93 = FileFilter::filter_argument_files(move _94, _95) -> [return: bb56, unwind: bb77];
    }

    bb56: {
        _98 = &mut _1;
        _99 = Option::<&Dir>::None;
        _113 = const false;
        _100 = move _26;
        _97 = Exa::<'_>::print_files(move _98, move _99, move _100) -> [return: bb57, unwind: bb77];
    }

    bb57: {
        _96 = <Result<(), std::io::Error> as Try>::branch(move _97) -> [return: bb58, unwind: bb77];
    }

    bb58: {
        _101 = discriminant(_96);
        switchInt(move _101) -> [0: bb59, 1: bb60, otherwise: bb17];
    }

    bb59: {
        _103 = &mut _1;
        _114 = const false;
        _104 = move _27;
        _105 = _90;
        _106 = _28;
        _0 = Exa::<'_>::print_dirs(move _103, move _104, _88, move _105, move _106) -> [return: bb61, unwind: bb77];
    }

    bb60: {
        _102 = move ((_96 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _102) -> [return: bb83, unwind: bb77];
    }

    bb61: {
        _114 = const false;
        _113 = const false;
        drop(_1) -> [return: bb67, unwind continue];
    }

    bb62: {
        drop(_59) -> [return: bb63, unwind: bb77];
    }

    bb63: {
        _112 = const false;
        goto -> bb64;
    }

    bb64: {
        drop(_27) -> [return: bb65, unwind: bb79];
    }

    bb65: {
        _114 = const false;
        switchInt(_113) -> [0: bb66, otherwise: bb73];
    }

    bb66: {
        _113 = const false;
        drop(_1) -> [return: bb67, unwind continue];
    }

    bb67: {
        return;
    }

    bb68 (cleanup): {
        drop(_69) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        drop(_43) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        drop(_1) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        resume;
    }

    bb72: {
        drop(_59) -> [return: bb50, unwind: bb77];
    }

    bb73: {
        drop(_26) -> [return: bb66, unwind: bb70];
    }

    bb74 (cleanup): {
        drop(_59) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        switchInt(_112) -> [0: bb77, otherwise: bb74];
    }

    bb76 (cleanup): {
        drop(_27) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        switchInt(_114) -> [0: bb79, otherwise: bb76];
    }

    bb78 (cleanup): {
        drop(_26) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        switchInt(_113) -> [0: bb70, otherwise: bb78];
    }

    bb80: {
        goto -> bb10;
    }

    bb81: {
        goto -> bb49;
    }

    bb82: {
        goto -> bb49;
    }

    bb83: {
        goto -> bb64;
    }
}

promoted[0] in <impl at src/main.rs:157:1: 157:23>::run: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at src/main.rs:157:1: 157:23>::run: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in <impl at src/main.rs:157:1: 157:23>::run: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "exa";
        _2 = &(*_3);
        _1 = (move _2, const "exa", const "src/main.rs", const 159_u32);
        _0 = &_1;
        return;
    }
}

promoted[3] in <impl at src/main.rs:157:1: 157:23>::run: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Running with options: "];
        _0 = &_1;
        return;
    }
}

promoted[4] in <impl at src/main.rs:157:1: 157:23>::run: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn <impl at src/main.rs:157:1: 157:23>::print_dirs(_1: &mut Exa<'_>, _2: Vec<Dir>, _3: bool, _4: bool, _5: i32) -> Result<i32, std::io::Error> {
    debug self => _1;
    debug dir_files => _2;
    debug first => const false;
    debug is_only_dir => _4;
    debug exit_status => _5;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _6: std::vec::IntoIter<fs::dir::Dir>;
    let mut _7: std::vec::IntoIter<fs::dir::Dir>;
    let mut _8: std::option::Option<fs::dir::Dir>;
    let mut _9: &mut std::vec::IntoIter<fs::dir::Dir>;
    let mut _10: isize;
    let mut _12: bool;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _14: std::result::Result<(), std::io::Error>;
    let mut _15: &mut std::io::Stdout;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: isize;
    let _21: ();
    let mut _22: std::string::String;
    let mut _23: &std::path::Display<'_>;
    let _24: std::path::Display<'_>;
    let _25: &std::path::Path;
    let mut _26: &std::path::PathBuf;
    let mut _27: &mut std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _28: ansi_term::Style;
    let mut _29: ansi_term::Style;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _31: std::result::Result<(), std::io::Error>;
    let mut _32: &mut std::io::Stdout;
    let mut _33: std::fmt::Arguments<'_>;
    let mut _34: &[&str];
    let mut _35: &[core::fmt::rt::Argument<'_>];
    let _36: &[core::fmt::rt::Argument<'_>; 1];
    let _37: [core::fmt::rt::Argument<'_>; 1];
    let mut _38: core::fmt::rt::Argument<'_>;
    let _39: &ansi_term::ANSIGenericStrings<'_, str>;
    let _40: ansi_term::ANSIGenericStrings<'_, str>;
    let _41: &[ansi_term::ANSIGenericString<'_, str>];
    let _42: &std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
    let mut _43: isize;
    let mut _47: &fs::filter::GitIgnore;
    let mut _48: fs::dir::Files<'_, '_>;
    let mut _49: fs::dir::Files<'_, '_>;
    let mut _50: &fs::dir::Dir;
    let mut _51: fs::dir::DotFilter;
    let mut _52: std::option::Option<&fs::feature::git::GitCache>;
    let mut _53: &std::option::Option<fs::feature::git::GitCache>;
    let _55: ();
    let mut _56: std::option::Option<std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>>;
    let mut _57: &mut fs::dir::Files<'_, '_>;
    let mut _58: isize;
    let mut _60: isize;
    let mut _62: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _65: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _66: std::result::Result<(), std::io::Error>;
    let mut _67: &mut std::io::Stderr;
    let mut _68: std::io::Stderr;
    let mut _69: std::fmt::Arguments<'_>;
    let mut _70: &[&str];
    let mut _71: &[core::fmt::rt::Argument<'_>];
    let _72: &[core::fmt::rt::Argument<'_>; 2];
    let _73: [core::fmt::rt::Argument<'_>; 2];
    let mut _74: core::fmt::rt::Argument<'_>;
    let _75: &std::path::Display<'_>;
    let _76: std::path::Display<'_>;
    let _77: &std::path::Path;
    let mut _78: &std::path::PathBuf;
    let mut _79: core::fmt::rt::Argument<'_>;
    let _80: &std::io::Error;
    let mut _81: isize;
    let _83: ();
    let mut _84: &fs::filter::FileFilter;
    let mut _85: &mut std::vec::Vec<fs::file::File<'_>>;
    let _86: ();
    let mut _87: &fs::filter::FileFilter;
    let mut _88: &mut std::vec::Vec<fs::file::File<'_>>;
    let mut _89: std::option::Option<fs::dir_action::RecurseOptions>;
    let mut _90: fs::dir_action::DirAction;
    let mut _91: isize;
    let mut _94: usize;
    let mut _95: std::iter::Filter<std::path::Components<'_>, {closure@src/main.rs:230:58: 230:62}>;
    let mut _96: std::path::Components<'_>;
    let _97: &std::path::Path;
    let mut _98: &std::path::PathBuf;
    let mut _99: (usize, bool);
    let mut _100: bool;
    let mut _101: bool;
    let mut _103: std::iter::Filter<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/main.rs:234:61: 234:64}>;
    let mut _104: std::iter::Filter<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/main.rs:234:61: 234:64}>;
    let mut _105: std::slice::Iter<'_, fs::file::File<'_>>;
    let _106: &[fs::file::File<'_>];
    let mut _107: &std::vec::Vec<fs::file::File<'_>>;
    let _109: ();
    let mut _110: std::option::Option<&fs::file::File<'_>>;
    let mut _111: &mut std::iter::Filter<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/main.rs:234:61: 234:64}>;
    let mut _112: isize;
    let mut _114: std::result::Result<fs::dir::Dir, std::io::Error>;
    let mut _115: isize;
    let mut _117: &mut std::vec::Vec<fs::dir::Dir>;
    let mut _119: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _120: std::result::Result<(), std::io::Error>;
    let mut _121: &mut std::io::Stderr;
    let mut _122: std::io::Stderr;
    let mut _123: std::fmt::Arguments<'_>;
    let mut _124: &[&str];
    let mut _125: &[core::fmt::rt::Argument<'_>];
    let _126: &[core::fmt::rt::Argument<'_>; 2];
    let _127: [core::fmt::rt::Argument<'_>; 2];
    let mut _128: core::fmt::rt::Argument<'_>;
    let _129: &std::path::Display<'_>;
    let _130: std::path::Display<'_>;
    let _131: &std::path::Path;
    let mut _132: &std::path::PathBuf;
    let mut _133: core::fmt::rt::Argument<'_>;
    let _134: &std::io::Error;
    let mut _135: isize;
    let mut _137: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _138: std::result::Result<(), std::io::Error>;
    let mut _139: std::option::Option<&fs::dir::Dir>;
    let _140: &fs::dir::Dir;
    let mut _141: std::vec::Vec<fs::file::File<'_>>;
    let mut _142: isize;
    let mut _144: std::result::Result<i32, std::io::Error>;
    let mut _145: std::vec::Vec<fs::dir::Dir>;
    let mut _146: isize;
    let mut _148: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _149: std::result::Result<(), std::io::Error>;
    let mut _150: std::option::Option<&fs::dir::Dir>;
    let _151: &fs::dir::Dir;
    let mut _152: std::vec::Vec<fs::file::File<'_>>;
    let mut _153: isize;
    let mut _160: bool;
    let mut _161: bool;
    let mut _162: bool;
    scope 1 {
        debug iter => _7;
        let _11: fs::dir::Dir;
        scope 2 {
            debug dir => _11;
            let _19: std::result::Result<std::convert::Infallible, std::io::Error>;
            let mut _20: std::vec::Vec<ansi_term::ANSIGenericString<'_, str>>;
            let mut _45: std::vec::Vec<fs::file::File<'_>>;
            let mut _159: &[&str; 1];
            scope 3 {
                debug residual => _19;
                scope 4 {
                }
            }
            scope 5 {
                debug val => const ();
                scope 6 {
                }
            }
            scope 7 {
                debug bits => _20;
                let _44: std::result::Result<std::convert::Infallible, std::io::Error>;
                let mut _158: &[&str; 2];
                scope 8 {
                    debug residual => _44;
                    scope 9 {
                    }
                }
                scope 10 {
                    debug val => const ();
                    scope 11 {
                    }
                }
            }
            scope 12 {
                debug children => _45;
                let _46: bool;
                let mut _157: &fs::filter::GitIgnore;
                scope 13 {
                    debug git_ignore => _46;
                    let mut _54: fs::dir::Files<'_, '_>;
                    let _154: std::result::Result<std::convert::Infallible, std::io::Error>;
                    scope 14 {
                        debug iter => _54;
                        let _59: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>;
                        scope 15 {
                            debug file => _59;
                            let _61: fs::file::File<'_>;
                            let _63: std::path::PathBuf;
                            let _64: std::io::Error;
                            scope 16 {
                                debug file => _61;
                            }
                            scope 17 {
                                debug path => _63;
                                debug e => _64;
                                let _82: std::result::Result<std::convert::Infallible, std::io::Error>;
                                let mut _155: &[&str; 3];
                                scope 18 {
                                    debug residual => _82;
                                    scope 19 {
                                    }
                                }
                                scope 20 {
                                    debug val => const ();
                                    scope 21 {
                                    }
                                }
                            }
                        }
                    }
                    scope 22 {
                        debug recurse_opts => _92;
                        let _92: fs::dir_action::RecurseOptions;
                        let _93: usize;
                        scope 23 {
                            debug depth => _93;
                            let mut _102: std::vec::Vec<fs::dir::Dir>;
                            scope 24 {
                                debug child_dirs => _102;
                                let mut _108: std::iter::Filter<std::slice::Iter<'_, fs::file::File<'_>>, {closure@src/main.rs:234:61: 234:64}>;
                                let _143: std::result::Result<std::convert::Infallible, std::io::Error>;
                                let _147: std::io::Error;
                                scope 25 {
                                    debug iter => _108;
                                    let _113: &fs::file::File<'_>;
                                    scope 26 {
                                        debug child_dir => _113;
                                        let _116: fs::dir::Dir;
                                        let _118: std::io::Error;
                                        scope 27 {
                                            debug d => _116;
                                        }
                                        scope 28 {
                                            debug e => _118;
                                            let _136: std::result::Result<std::convert::Infallible, std::io::Error>;
                                            let mut _156: &[&str; 3];
                                            scope 29 {
                                                debug residual => _136;
                                                scope 30 {
                                                }
                                            }
                                            scope 31 {
                                                debug val => const ();
                                                scope 32 {
                                                }
                                            }
                                        }
                                    }
                                }
                                scope 33 {
                                    debug residual => _143;
                                    scope 34 {
                                    }
                                }
                                scope 35 {
                                    debug val => const ();
                                    scope 36 {
                                    }
                                }
                                scope 37 {
                                    debug e => _147;
                                }
                            }
                        }
                    }
                    scope 38 {
                        debug residual => _154;
                        scope 39 {
                        }
                    }
                    scope 40 {
                        debug val => const ();
                        scope 41 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _162 = const false;
        _161 = const false;
        _160 = const false;
        _6 = <Vec<Dir> as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = move _6;
        goto -> bb2;
    }

    bb2: {
        _9 = &mut _7;
        _8 = <std::vec::IntoIter<Dir> as Iterator>::next(_9) -> [return: bb3, unwind: bb116];
    }

    bb3: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _11 = move ((_8 as Some).0: fs::dir::Dir);
        _12 = _3;
        switchInt(move _12) -> [0: bb8, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        drop(_7) -> [return: bb102, unwind continue];
    }

    bb7: {
        _3 = const false;
        goto -> bb13;
    }

    bb8: {
        _15 = &mut ((*_1).1: std::io::Stdout);
        _159 = const _;
        _17 = _159 as &[&str] (PointerCoercion(Unsize));
        _16 = std::fmt::Arguments::<'_>::new_const(move _17) -> [return: bb9, unwind: bb115];
    }

    bb9: {
        _14 = <Stdout as std::io::Write>::write_fmt(_15, move _16) -> [return: bb10, unwind: bb115];
    }

    bb10: {
        _13 = <Result<(), std::io::Error> as Try>::branch(move _14) -> [return: bb11, unwind: bb115];
    }

    bb11: {
        _18 = discriminant(_13);
        switchInt(move _18) -> [0: bb13, 1: bb12, otherwise: bb5];
    }

    bb12: {
        _19 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _19) -> [return: bb128, unwind: bb115];
    }

    bb13: {
        switchInt(_4) -> [0: bb14, otherwise: bb31];
    }

    bb14: {
        _20 = Vec::<ANSIGenericString<'_, str>>::new() -> [return: bb15, unwind: bb115];
    }

    bb15: {
        _26 = &(_11.1: std::path::PathBuf);
        _25 = <PathBuf as Deref>::deref(move _26) -> [return: bb16, unwind: bb114];
    }

    bb16: {
        _24 = Path::display(_25) -> [return: bb17, unwind: bb114];
    }

    bb17: {
        _23 = &_24;
        _22 = <std::path::Display<'_> as ToString>::to_string(move _23) -> [return: bb18, unwind: bb114];
    }

    bb18: {
        _162 = const true;
        _27 = &mut _20;
        _28 = <Style as Default>::default() -> [return: bb19, unwind: bb127];
    }

    bb19: {
        _29 = <Style as Default>::default() -> [return: bb20, unwind: bb127];
    }

    bb20: {
        _162 = const false;
        _21 = escape(move _22, _27, move _28, move _29) -> [return: bb21, unwind: bb127];
    }

    bb21: {
        _162 = const false;
        _32 = &mut ((*_1).1: std::io::Stdout);
        _158 = const _;
        _34 = _158 as &[&str] (PointerCoercion(Unsize));
        _42 = &_20;
        _41 = <Vec<ANSIGenericString<'_, str>> as Deref>::deref(_42) -> [return: bb22, unwind: bb114];
    }

    bb22: {
        _40 = ANSIStrings(_41) -> [return: bb23, unwind: bb114];
    }

    bb23: {
        _39 = &_40;
        _38 = core::fmt::rt::Argument::<'_>::new_display::<ANSIGenericStrings<'_, str>>(_39) -> [return: bb24, unwind: bb114];
    }

    bb24: {
        _37 = [move _38];
        _36 = &_37;
        _35 = _36 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _33 = std::fmt::Arguments::<'_>::new_v1(move _34, move _35) -> [return: bb25, unwind: bb114];
    }

    bb25: {
        _31 = <Stdout as std::io::Write>::write_fmt(_32, move _33) -> [return: bb26, unwind: bb114];
    }

    bb26: {
        _30 = <Result<(), std::io::Error> as Try>::branch(move _31) -> [return: bb27, unwind: bb114];
    }

    bb27: {
        _43 = discriminant(_30);
        switchInt(move _43) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        drop(_20) -> [return: bb31, unwind: bb115];
    }

    bb29: {
        _44 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _44) -> [return: bb30, unwind: bb114];
    }

    bb30: {
        drop(_20) -> [return: bb108, unwind: bb115];
    }

    bb31: {
        _45 = Vec::<file::File<'_>>::new() -> [return: bb32, unwind: bb115];
    }

    bb32: {
        _161 = const true;
        _47 = &((((*_1).0: options::Options).1: fs::filter::FileFilter).6: fs::filter::GitIgnore);
        _157 = const _;
        _46 = <GitIgnore as PartialEq>::eq(move _47, _157) -> [return: bb33, unwind: bb125];
    }

    bb33: {
        _50 = &_11;
        _51 = ((((*_1).0: options::Options).1: fs::filter::FileFilter).4: fs::dir::DotFilter);
        _53 = &((*_1).5: std::option::Option<fs::feature::git::GitCache>);
        _52 = Option::<GitCache>::as_ref(move _53) -> [return: bb34, unwind: bb125];
    }

    bb34: {
        _49 = Dir::files(move _50, move _51, move _52, _46) -> [return: bb35, unwind: bb125];
    }

    bb35: {
        _48 = <Files<'_, '_> as IntoIterator>::into_iter(move _49) -> [return: bb36, unwind: bb125];
    }

    bb36: {
        _54 = move _48;
        goto -> bb37;
    }

    bb37: {
        _57 = &mut _54;
        _56 = <Files<'_, '_> as Iterator>::next(_57) -> [return: bb38, unwind: bb125];
    }

    bb38: {
        _58 = discriminant(_56);
        switchInt(move _58) -> [0: bb40, 1: bb39, otherwise: bb5];
    }

    bb39: {
        _59 = move ((_56 as Some).0: std::result::Result<fs::file::File<'_>, (std::path::PathBuf, std::io::Error)>);
        _60 = discriminant(_59);
        switchInt(move _60) -> [0: bb42, 1: bb41, otherwise: bb5];
    }

    bb40: {
        _84 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _85 = &mut _45;
        _83 = FileFilter::filter_child_files(move _84, _85) -> [return: bb55, unwind: bb125];
    }

    bb41: {
        _63 = move (((_59 as Err).0: (std::path::PathBuf, std::io::Error)).0: std::path::PathBuf);
        _64 = move (((_59 as Err).0: (std::path::PathBuf, std::io::Error)).1: std::io::Error);
        _68 = stderr() -> [return: bb43, unwind: bb112];
    }

    bb42: {
        _61 = move ((_59 as Ok).0: fs::file::File<'_>);
        _62 = &mut _45;
        _55 = Vec::<file::File<'_>>::push(move _62, move _61) -> [return: bb129, unwind: bb125];
    }

    bb43: {
        _67 = &mut _68;
        _155 = const _;
        _70 = _155 as &[&str] (PointerCoercion(Unsize));
        _78 = &_63;
        _77 = <PathBuf as Deref>::deref(move _78) -> [return: bb44, unwind: bb112];
    }

    bb44: {
        _76 = Path::display(_77) -> [return: bb45, unwind: bb112];
    }

    bb45: {
        _75 = &_76;
        _74 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_75) -> [return: bb46, unwind: bb112];
    }

    bb46: {
        _80 = &_64;
        _79 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_80) -> [return: bb47, unwind: bb112];
    }

    bb47: {
        _73 = [move _74, move _79];
        _72 = &_73;
        _71 = _72 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _69 = std::fmt::Arguments::<'_>::new_v1(move _70, move _71) -> [return: bb48, unwind: bb112];
    }

    bb48: {
        _66 = <Stderr as std::io::Write>::write_fmt(move _67, move _69) -> [return: bb49, unwind: bb112];
    }

    bb49: {
        _65 = <Result<(), std::io::Error> as Try>::branch(move _66) -> [return: bb50, unwind: bb112];
    }

    bb50: {
        _81 = discriminant(_65);
        switchInt(move _81) -> [0: bb51, 1: bb52, otherwise: bb5];
    }

    bb51: {
        drop(_64) -> [return: bb54, unwind: bb113];
    }

    bb52: {
        _82 = move ((_65 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _82) -> [return: bb53, unwind: bb112];
    }

    bb53: {
        drop(_64) -> [return: bb104, unwind: bb113];
    }

    bb54: {
        drop(_63) -> [return: bb118, unwind: bb125];
    }

    bb55: {
        _87 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _88 = &mut _45;
        _86 = FileFilter::sort_files::<'_, file::File<'_>>(move _87, _88) -> [return: bb56, unwind: bb125];
    }

    bb56: {
        _90 = (((*_1).0: options::Options).0: fs::dir_action::DirAction);
        _89 = DirAction::recurse_options(move _90) -> [return: bb57, unwind: bb125];
    }

    bb57: {
        _91 = discriminant(_89);
        switchInt(move _91) -> [1: bb58, otherwise: bb97];
    }

    bb58: {
        _92 = ((_89 as Some).0: fs::dir_action::RecurseOptions);
        _98 = &(_11.1: std::path::PathBuf);
        _97 = <PathBuf as Deref>::deref(move _98) -> [return: bb59, unwind: bb125];
    }

    bb59: {
        _96 = Path::components(_97) -> [return: bb60, unwind: bb125];
    }

    bb60: {
        _95 = <Components<'_> as Iterator>::filter::<{closure@src/main.rs:230:58: 230:62}>(move _96, const ZeroSized: {closure@src/main.rs:230:58: 230:62}) -> [return: bb61, unwind: bb125];
    }

    bb61: {
        _94 = <std::iter::Filter<Components<'_>, {closure@src/main.rs:230:58: 230:62}> as Iterator>::count(move _95) -> [return: bb62, unwind: bb125];
    }

    bb62: {
        _99 = CheckedAdd(_94, const 1_usize);
        assert(!move (_99.1: bool), "attempt to compute `{} + {}`, which would overflow", move _94, const 1_usize) -> [success: bb63, unwind: bb125];
    }

    bb63: {
        _93 = move (_99.0: usize);
        _100 = (_92.0: bool);
        switchInt(move _100) -> [0: bb64, otherwise: bb97];
    }

    bb64: {
        _101 = RecurseOptions::is_too_deep(_92, _93) -> [return: bb65, unwind: bb125];
    }

    bb65: {
        switchInt(move _101) -> [0: bb66, otherwise: bb97];
    }

    bb66: {
        _102 = Vec::<Dir>::new() -> [return: bb67, unwind: bb125];
    }

    bb67: {
        _160 = const true;
        _107 = &_45;
        _106 = <Vec<file::File<'_>> as Deref>::deref(move _107) -> [return: bb68, unwind: bb123];
    }

    bb68: {
        _105 = core::slice::<impl [file::File<'_>]>::iter(_106) -> [return: bb69, unwind: bb123];
    }

    bb69: {
        _104 = <std::slice::Iter<'_, file::File<'_>> as Iterator>::filter::<{closure@src/main.rs:234:61: 234:64}>(move _105, const ZeroSized: {closure@src/main.rs:234:61: 234:64}) -> [return: bb70, unwind: bb123];
    }

    bb70: {
        _103 = <std::iter::Filter<std::slice::Iter<'_, file::File<'_>>, {closure@src/main.rs:234:61: 234:64}> as IntoIterator>::into_iter(move _104) -> [return: bb71, unwind: bb123];
    }

    bb71: {
        _108 = move _103;
        goto -> bb72;
    }

    bb72: {
        _111 = &mut _108;
        _110 = <std::iter::Filter<std::slice::Iter<'_, file::File<'_>>, {closure@src/main.rs:234:61: 234:64}> as Iterator>::next(_111) -> [return: bb73, unwind: bb123];
    }

    bb73: {
        _112 = discriminant(_110);
        switchInt(move _112) -> [0: bb75, 1: bb74, otherwise: bb5];
    }

    bb74: {
        _113 = ((_110 as Some).0: &fs::file::File<'_>);
        _114 = file::File::<'_>::to_dir(_113) -> [return: bb76, unwind: bb123];
    }

    bb75: {
        _140 = &_11;
        _139 = Option::<&Dir>::Some(_140);
        _161 = const false;
        _141 = move _45;
        _138 = Exa::<'_>::print_files(_1, move _139, move _141) -> [return: bb90, unwind: bb123];
    }

    bb76: {
        _115 = discriminant(_114);
        switchInt(move _115) -> [0: bb78, 1: bb77, otherwise: bb5];
    }

    bb77: {
        _118 = move ((_114 as Err).0: std::io::Error);
        _122 = stderr() -> [return: bb79, unwind: bb111];
    }

    bb78: {
        _116 = move ((_114 as Ok).0: fs::dir::Dir);
        _117 = &mut _102;
        _109 = Vec::<Dir>::push(move _117, move _116) -> [return: bb130, unwind: bb123];
    }

    bb79: {
        _121 = &mut _122;
        _156 = const _;
        _124 = _156 as &[&str] (PointerCoercion(Unsize));
        _132 = &((*_113).2: std::path::PathBuf);
        _131 = <PathBuf as Deref>::deref(move _132) -> [return: bb80, unwind: bb111];
    }

    bb80: {
        _130 = Path::display(_131) -> [return: bb81, unwind: bb111];
    }

    bb81: {
        _129 = &_130;
        _128 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_129) -> [return: bb82, unwind: bb111];
    }

    bb82: {
        _134 = &_118;
        _133 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_134) -> [return: bb83, unwind: bb111];
    }

    bb83: {
        _127 = [move _128, move _133];
        _126 = &_127;
        _125 = _126 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _123 = std::fmt::Arguments::<'_>::new_v1(move _124, move _125) -> [return: bb84, unwind: bb111];
    }

    bb84: {
        _120 = <Stderr as std::io::Write>::write_fmt(move _121, move _123) -> [return: bb85, unwind: bb111];
    }

    bb85: {
        _119 = <Result<(), std::io::Error> as Try>::branch(move _120) -> [return: bb86, unwind: bb111];
    }

    bb86: {
        _135 = discriminant(_119);
        switchInt(move _135) -> [0: bb87, 1: bb88, otherwise: bb5];
    }

    bb87: {
        drop(_118) -> [return: bb72, unwind: bb123];
    }

    bb88: {
        _136 = move ((_119 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _136) -> [return: bb89, unwind: bb111];
    }

    bb89: {
        drop(_118) -> [return: bb120, unwind: bb123];
    }

    bb90: {
        _137 = <Result<(), std::io::Error> as Try>::branch(move _138) -> [return: bb91, unwind: bb123];
    }

    bb91: {
        _142 = discriminant(_137);
        switchInt(move _142) -> [0: bb92, 1: bb93, otherwise: bb5];
    }

    bb92: {
        _160 = const false;
        _145 = move _102;
        _144 = Exa::<'_>::print_dirs(_1, move _145, const false, const false, _5) -> [return: bb94, unwind: bb123];
    }

    bb93: {
        _143 = move ((_137 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _143) -> [return: bb131, unwind: bb123];
    }

    bb94: {
        _146 = discriminant(_144);
        switchInt(move _146) -> [0: bb96, 1: bb95, otherwise: bb5];
    }

    bb95: {
        _147 = move ((_144 as Err).0: std::io::Error);
        _0 = Result::<i32, std::io::Error>::Err(move _147);
        goto -> bb120;
    }

    bb96: {
        _160 = const false;
        _161 = const false;
        drop(_11) -> [return: bb2, unwind: bb116];
    }

    bb97: {
        _151 = &_11;
        _150 = Option::<&Dir>::Some(_151);
        _161 = const false;
        _152 = move _45;
        _149 = Exa::<'_>::print_files(_1, move _150, move _152) -> [return: bb98, unwind: bb125];
    }

    bb98: {
        _148 = <Result<(), std::io::Error> as Try>::branch(move _149) -> [return: bb99, unwind: bb125];
    }

    bb99: {
        _153 = discriminant(_148);
        switchInt(move _153) -> [0: bb100, 1: bb101, otherwise: bb5];
    }

    bb100: {
        _161 = const false;
        drop(_11) -> [return: bb2, unwind: bb116];
    }

    bb101: {
        _154 = move ((_148 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<i32, std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _154) -> [return: bb132, unwind: bb125];
    }

    bb102: {
        _0 = Result::<i32, std::io::Error>::Ok(_5);
        goto -> bb110;
    }

    bb103: {
        _160 = const false;
        goto -> bb106;
    }

    bb104: {
        drop(_63) -> [return: bb105, unwind: bb125];
    }

    bb105: {
        goto -> bb106;
    }

    bb106: {
        switchInt(_161) -> [0: bb107, otherwise: bb121];
    }

    bb107: {
        _161 = const false;
        goto -> bb108;
    }

    bb108: {
        drop(_11) -> [return: bb109, unwind: bb116];
    }

    bb109: {
        drop(_7) -> [return: bb110, unwind continue];
    }

    bb110: {
        return;
    }

    bb111 (cleanup): {
        drop(_118) -> [return: bb123, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_64) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_63) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_20) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_11) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_7) -> [return: bb117, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        resume;
    }

    bb118: {
        goto -> bb37;
    }

    bb119: {
        drop(_102) -> [return: bb103, unwind: bb125];
    }

    bb120: {
        switchInt(_160) -> [0: bb103, otherwise: bb119];
    }

    bb121: {
        drop(_45) -> [return: bb107, unwind: bb115];
    }

    bb122 (cleanup): {
        drop(_102) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        switchInt(_160) -> [0: bb125, otherwise: bb122];
    }

    bb124 (cleanup): {
        drop(_45) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        switchInt(_161) -> [0: bb115, otherwise: bb124];
    }

    bb126 (cleanup): {
        drop(_22) -> [return: bb114, unwind terminate(cleanup)];
    }

    bb127 (cleanup): {
        switchInt(_162) -> [0: bb114, otherwise: bb126];
    }

    bb128: {
        goto -> bb108;
    }

    bb129: {
        goto -> bb118;
    }

    bb130: {
        goto -> bb72;
    }

    bb131: {
        goto -> bb120;
    }

    bb132: {
        goto -> bb106;
    }
}

promoted[0] in <impl at src/main.rs:157:1: 157:23>::print_dirs: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "[", const ": ", const "]\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at src/main.rs:157:1: 157:23>::print_dirs: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in <impl at src/main.rs:157:1: 157:23>::print_dirs: &GitIgnore = {
    let mut _0: &fs::filter::GitIgnore;
    let mut _1: fs::filter::GitIgnore;

    bb0: {
        _1 = GitIgnore::CheckAndIgnore;
        _0 = &_1;
        return;
    }
}

promoted[3] in <impl at src/main.rs:157:1: 157:23>::print_dirs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ":\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in <impl at src/main.rs:157:1: 157:23>::print_dirs: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

fn <impl at src/main.rs:157:1: 157:23>::print_dirs::{closure#0}(_1: &mut {closure@src/main.rs:230:58: 230:62}, _2: &Component<'_>) -> bool {
    let mut _0: bool;
    let _3: std::path::Component<'_>;
    let mut _4: &std::path::Component<'_>;
    scope 1 {
        debug c => _3;
        let mut _5: &std::path::Component<'_>;
    }

    bb0: {
        _3 = (*_2);
        _4 = &_3;
        _5 = const _;
        _0 = <Component<'_> as PartialEq>::ne(move _4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in <impl at src/main.rs:157:1: 157:23>::print_dirs::{closure#0}: &Component<'_> = {
    let mut _0: &std::path::Component<'_>;
    let mut _1: std::path::Component<'_>;

    bb0: {
        _1 = Component::<'_>::CurDir;
        _0 = &_1;
        return;
    }
}

fn <impl at src/main.rs:157:1: 157:23>::print_dirs::{closure#1}(_1: &mut {closure@src/main.rs:234:61: 234:64}, _2: &&file::File<'_>) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: &fs::file::File<'_>;
    let mut _6: &fs::file::File<'_>;

    bb0: {
        _5 = deref_copy (*_2);
        _3 = file::File::<'_>::is_directory(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = deref_copy (*_2);
        _4 = ((*_6).5: bool);
        _0 = Not(move _4);
        goto -> bb4;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn <impl at src/main.rs:157:1: 157:23>::print_files(_1: &mut Exa<'_>, _2: Option<&Dir>, _3: Vec<file::File<'_>>) -> Result<(), std::io::Error> {
    debug self => _1;
    debug dir => _2;
    debug files => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: bool;
    let mut _5: &std::vec::Vec<fs::file::File<'_>>;
    let _6: &theme::Theme;
    let mut _9: (&output::Mode, std::option::Option<usize>);
    let mut _10: std::option::Option<usize>;
    let mut _11: isize;
    let mut _12: isize;
    let mut _13: isize;
    let mut _18: std::vec::Vec<fs::file::File<'_>>;
    let mut _19: &mut std::io::Stdout;
    let mut _22: std::vec::Vec<fs::file::File<'_>>;
    let mut _23: &mut std::io::Stdout;
    let mut _27: fs::dir_action::DirAction;
    let mut _29: &fs::filter::GitIgnore;
    let mut _31: &std::option::Option<fs::feature::git::GitCache>;
    let mut _33: std::vec::Vec<fs::file::File<'_>>;
    let mut _34: &mut std::io::Stdout;
    let mut _42: &fs::filter::GitIgnore;
    let mut _44: &std::option::Option<fs::feature::git::GitCache>;
    let mut _46: std::vec::Vec<fs::file::File<'_>>;
    let mut _47: &mut std::io::Stdout;
    let _50: &output::details::Options;
    let mut _53: fs::dir_action::DirAction;
    let mut _55: &fs::filter::GitIgnore;
    let mut _57: &std::option::Option<fs::feature::git::GitCache>;
    let mut _59: std::vec::Vec<fs::file::File<'_>>;
    let mut _60: &mut std::io::Stdout;
    let mut _64: &output::Mode;
    let mut _65: &output::Mode;
    let mut _66: &output::Mode;
    let mut _67: &output::Mode;
    let mut _68: &output::Mode;
    let mut _69: &output::details::Options;
    let mut _70: bool;
    scope 1 {
        debug theme => _6;
        let _7: &output::Mode;
        let _8: &output::file_name::Options;
        scope 2 {
            debug mode => _7;
            debug file_style => _8;
            let _14: &output::grid::Options;
            let _15: usize;
            let _20: &fs::filter::FileFilter;
            let _24: &output::details::Options;
            let _35: &output::grid_details::Options;
            let _36: usize;
            let _48: &output::grid_details::Options;
            scope 3 {
                debug opts => _14;
                debug console_width => _15;
                let _16: &fs::filter::FileFilter;
                scope 4 {
                    debug filter => _16;
                    let _17: output::grid::Render<'_>;
                    scope 5 {
                        debug r => _17;
                    }
                }
            }
            scope 6 {
                debug filter => _20;
                let _21: output::lines::Render<'_>;
                scope 7 {
                    debug r => _21;
                }
            }
            scope 8 {
                debug opts => _24;
                let _25: &fs::filter::FileFilter;
                scope 9 {
                    debug filter => _25;
                    let _26: std::option::Option<fs::dir_action::RecurseOptions>;
                    scope 10 {
                        debug recurse => _26;
                        let _28: bool;
                        let mut _63: &fs::filter::GitIgnore;
                        scope 11 {
                            debug git_ignoring => _28;
                            let _30: std::option::Option<&fs::feature::git::GitCache>;
                            scope 12 {
                                debug git => _30;
                                let _32: output::details::Render<'_>;
                                scope 13 {
                                    debug r => _32;
                                }
                            }
                        }
                    }
                }
            }
            scope 14 {
                debug opts => _35;
                debug console_width => _36;
                let _37: &output::grid::Options;
                scope 15 {
                    debug grid => _37;
                    let _38: &output::details::Options;
                    scope 16 {
                        debug details => _38;
                        let _39: output::grid_details::RowThreshold;
                        scope 17 {
                            debug row_threshold => _39;
                            let _40: &fs::filter::FileFilter;
                            scope 18 {
                                debug filter => _40;
                                let _41: bool;
                                let mut _62: &fs::filter::GitIgnore;
                                scope 19 {
                                    debug git_ignoring => _41;
                                    let _43: std::option::Option<&fs::feature::git::GitCache>;
                                    scope 20 {
                                        debug git => _43;
                                        let _45: output::grid_details::Render<'_>;
                                        scope 21 {
                                            debug r => _45;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 22 {
                debug opts => _48;
                let _49: &&output::details::Options;
                scope 23 {
                    debug opts => _49;
                    let _51: &fs::filter::FileFilter;
                    scope 24 {
                        debug filter => _51;
                        let _52: std::option::Option<fs::dir_action::RecurseOptions>;
                        scope 25 {
                            debug recurse => _52;
                            let _54: bool;
                            let mut _61: &fs::filter::GitIgnore;
                            scope 26 {
                                debug git_ignoring => _54;
                                let _56: std::option::Option<&fs::feature::git::GitCache>;
                                scope 27 {
                                    debug git => _56;
                                    let _58: output::details::Render<'_>;
                                    scope 28 {
                                        debug r => _58;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _70 = const false;
        _70 = const true;
        _5 = &_3;
        _4 = Vec::<file::File<'_>>::is_empty(move _5) -> [return: bb1, unwind: bb24];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Result::<(), std::io::Error>::Ok(const ());
        drop(_3) -> [return: bb21, unwind continue];
    }

    bb3: {
        _6 = &((*_1).3: theme::Theme);
        _7 = &((((*_1).0: options::Options).2: output::View).0: output::Mode);
        _8 = &((((*_1).0: options::Options).2: output::View).2: output::file_name::Options);
        _10 = ((*_1).4: std::option::Option<usize>);
        _9 = (_7, move _10);
        _64 = deref_copy (_9.0: &output::Mode);
        _13 = discriminant((*_64));
        switchInt(move _13) -> [0: bb4, 1: bb10, 2: bb6, 3: bb9, otherwise: bb5];
    }

    bb4: {
        _11 = discriminant((_9.1: std::option::Option<usize>));
        switchInt(move _11) -> [0: bb9, 1: bb8, otherwise: bb5];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _12 = discriminant((_9.1: std::option::Option<usize>));
        switchInt(move _12) -> [0: bb7, 1: bb14, otherwise: bb5];
    }

    bb7: {
        _65 = deref_copy (_9.0: &output::Mode);
        _48 = &(((*_65) as GridDetails).0: output::grid_details::Options);
        _50 = grid_details::Options::to_details_options(_48) -> [return: bb17, unwind: bb24];
    }

    bb8: {
        _66 = deref_copy (_9.0: &output::Mode);
        _14 = &(((*_66) as Grid).0: output::grid::Options);
        _15 = (((_9.1: std::option::Option<usize>) as Some).0: usize);
        _16 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _70 = const false;
        _18 = move _3;
        _17 = grid::Render::<'_> { files: move _18, theme: _6, file_style: _8, opts: _14, console_width: _15, filter: _16 };
        _19 = &mut ((*_1).1: std::io::Stdout);
        _0 = grid::Render::<'_>::render::<Stdout>(move _17, _19) -> [return: bb25, unwind: bb24];
    }

    bb9: {
        _20 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _70 = const false;
        _22 = move _3;
        _21 = lines::Render::<'_> { files: move _22, theme: _6, file_style: _8, filter: _20 };
        _23 = &mut ((*_1).1: std::io::Stdout);
        _0 = lines::Render::<'_>::render::<Stdout>(move _21, _23) -> [return: bb26, unwind: bb24];
    }

    bb10: {
        _67 = deref_copy (_9.0: &output::Mode);
        _24 = &(((*_67) as Details).0: output::details::Options);
        _25 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _27 = (((*_1).0: options::Options).0: fs::dir_action::DirAction);
        _26 = DirAction::recurse_options(move _27) -> [return: bb11, unwind: bb24];
    }

    bb11: {
        _29 = &((((*_1).0: options::Options).1: fs::filter::FileFilter).6: fs::filter::GitIgnore);
        _63 = const _;
        _28 = <GitIgnore as PartialEq>::eq(move _29, _63) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        _31 = &((*_1).5: std::option::Option<fs::feature::git::GitCache>);
        _30 = Option::<GitCache>::as_ref(move _31) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _70 = const false;
        _33 = move _3;
        _32 = details::Render::<'_> { dir: _2, files: move _33, theme: _6, file_style: _8, opts: _24, recurse: _26, filter: _25, git_ignoring: _28, git: _30 };
        _34 = &mut ((*_1).1: std::io::Stdout);
        _0 = details::Render::<'_>::render::<Stdout>(move _32, _34) -> [return: bb27, unwind: bb24];
    }

    bb14: {
        _68 = deref_copy (_9.0: &output::Mode);
        _35 = &(((*_68) as GridDetails).0: output::grid_details::Options);
        _36 = (((_9.1: std::option::Option<usize>) as Some).0: usize);
        _37 = &((*_35).0: output::grid::Options);
        _38 = &((*_35).1: output::details::Options);
        _39 = ((*_35).2: output::grid_details::RowThreshold);
        _40 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _42 = &((((*_1).0: options::Options).1: fs::filter::FileFilter).6: fs::filter::GitIgnore);
        _62 = const _;
        _41 = <GitIgnore as PartialEq>::eq(move _42, _62) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _44 = &((*_1).5: std::option::Option<fs::feature::git::GitCache>);
        _43 = Option::<GitCache>::as_ref(move _44) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _70 = const false;
        _46 = move _3;
        _45 = grid_details::Render::<'_> { dir: _2, files: move _46, theme: _6, file_style: _8, grid: _37, details: _38, filter: _40, row_threshold: _39, git_ignoring: _41, git: _43, console_width: _36 };
        _47 = &mut ((*_1).1: std::io::Stdout);
        _0 = grid_details::Render::<'_>::render::<Stdout>(move _45, _47) -> [return: bb28, unwind: bb24];
    }

    bb17: {
        _49 = &_50;
        _51 = &(((*_1).0: options::Options).1: fs::filter::FileFilter);
        _53 = (((*_1).0: options::Options).0: fs::dir_action::DirAction);
        _52 = DirAction::recurse_options(move _53) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _55 = &((((*_1).0: options::Options).1: fs::filter::FileFilter).6: fs::filter::GitIgnore);
        _61 = const _;
        _54 = <GitIgnore as PartialEq>::eq(move _55, _61) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        _57 = &((*_1).5: std::option::Option<fs::feature::git::GitCache>);
        _56 = Option::<GitCache>::as_ref(move _57) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        _70 = const false;
        _59 = move _3;
        _69 = deref_copy (*_49);
        _58 = details::Render::<'_> { dir: _2, files: move _59, theme: _6, file_style: _8, opts: _69, recurse: _52, filter: _51, git_ignoring: _54, git: _56 };
        _60 = &mut ((*_1).1: std::io::Stdout);
        _0 = details::Render::<'_>::render::<Stdout>(move _58, _60) -> [return: bb29, unwind: bb24];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        drop(_3) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_70) -> [0: bb22, otherwise: bb23];
    }

    bb25: {
        goto -> bb21;
    }

    bb26: {
        goto -> bb21;
    }

    bb27: {
        goto -> bb21;
    }

    bb28: {
        goto -> bb21;
    }

    bb29: {
        goto -> bb21;
    }
}

promoted[0] in <impl at src/main.rs:157:1: 157:23>::print_files: &GitIgnore = {
    let mut _0: &fs::filter::GitIgnore;
    let mut _1: fs::filter::GitIgnore;

    bb0: {
        _1 = GitIgnore::CheckAndIgnore;
        _0 = &_1;
        return;
    }
}

promoted[1] in <impl at src/main.rs:157:1: 157:23>::print_files: &GitIgnore = {
    let mut _0: &fs::filter::GitIgnore;
    let mut _1: fs::filter::GitIgnore;

    bb0: {
        _1 = GitIgnore::CheckAndIgnore;
        _0 = &_1;
        return;
    }
}

promoted[2] in <impl at src/main.rs:157:1: 157:23>::print_files: &GitIgnore = {
    let mut _0: &fs::filter::GitIgnore;
    let mut _1: fs::filter::GitIgnore;

    bb0: {
        _1 = GitIgnore::CheckAndIgnore;
        _0 = &_1;
        return;
    }
}

const SUCCESS: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 0_i32;
        return;
    }
}

const RUNTIME_ERROR: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 1_i32;
        return;
    }
}

const OPTIONS_ERROR: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 3_i32;
        return;
    }
}

fn FileTarget::Ok(_1: Box<file::File<'_>>) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Ok(move _1);
        return;
    }
}

// MIR FOR CTFE
fn FileTarget::Ok(_1: Box<file::File<'_>>) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Ok(move _1);
        return;
    }
}

fn FileTarget::Broken(_1: PathBuf) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Broken(move _1);
        return;
    }
}

// MIR FOR CTFE
fn FileTarget::Broken(_1: PathBuf) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Broken(move _1);
        return;
    }
}

fn FileTarget::Err(_1: std::io::Error) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Err(move _1);
        return;
    }
}

// MIR FOR CTFE
fn FileTarget::Err(_1: std::io::Error) -> FileTarget<'_> {
    let mut _0: fs::file::FileTarget<'_>;

    bb0: {
        _0 = FileTarget::<'_>::Err(move _1);
        return;
    }
}

fn DirAction::Recurse(_1: RecurseOptions) -> DirAction {
    let mut _0: fs::dir_action::DirAction;

    bb0: {
        _0 = DirAction::Recurse(move _1);
        return;
    }
}

// MIR FOR CTFE
fn DirAction::Recurse(_1: RecurseOptions) -> DirAction {
    let mut _0: fs::dir_action::DirAction;

    bb0: {
        _0 = DirAction::Recurse(move _1);
        return;
    }
}

fn Inode(_1: u64) -> Inode {
    let mut _0: fs::fields::Inode;

    bb0: {
        _0 = Inode(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Inode(_1: u64) -> Inode {
    let mut _0: fs::fields::Inode;

    bb0: {
        _0 = Inode(move _1);
        return;
    }
}

fn Blocks::Some(_1: u64) -> Blocks {
    let mut _0: fs::fields::Blocks;

    bb0: {
        _0 = Blocks::Some(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Blocks::Some(_1: u64) -> Blocks {
    let mut _0: fs::fields::Blocks;

    bb0: {
        _0 = Blocks::Some(move _1);
        return;
    }
}

fn fields::User(_1: u32) -> fields::User {
    let mut _0: fs::fields::User;

    bb0: {
        _0 = fields::User(move _1);
        return;
    }
}

// MIR FOR CTFE
fn fields::User(_1: u32) -> fields::User {
    let mut _0: fs::fields::User;

    bb0: {
        _0 = fields::User(move _1);
        return;
    }
}

fn fields::Group(_1: u32) -> fields::Group {
    let mut _0: fs::fields::Group;

    bb0: {
        _0 = fields::Group(move _1);
        return;
    }
}

// MIR FOR CTFE
fn fields::Group(_1: u32) -> fields::Group {
    let mut _0: fs::fields::Group;

    bb0: {
        _0 = fields::Group(move _1);
        return;
    }
}

fn fields::Size::Some(_1: u64) -> fields::Size {
    let mut _0: fs::fields::Size;

    bb0: {
        _0 = fields::Size::Some(move _1);
        return;
    }
}

// MIR FOR CTFE
fn fields::Size::Some(_1: u64) -> fields::Size {
    let mut _0: fs::fields::Size;

    bb0: {
        _0 = fields::Size::Some(move _1);
        return;
    }
}

fn fields::Size::DeviceIDs(_1: DeviceIDs) -> fields::Size {
    let mut _0: fs::fields::Size;

    bb0: {
        _0 = fields::Size::DeviceIDs(move _1);
        return;
    }
}

// MIR FOR CTFE
fn fields::Size::DeviceIDs(_1: DeviceIDs) -> fields::Size {
    let mut _0: fs::fields::Size;

    bb0: {
        _0 = fields::Size::DeviceIDs(move _1);
        return;
    }
}

fn SortField::Name(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::Name(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SortField::Name(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::Name(move _1);
        return;
    }
}

fn SortField::Extension(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::Extension(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SortField::Extension(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::Extension(move _1);
        return;
    }
}

fn SortField::NameMixHidden(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::NameMixHidden(move _1);
        return;
    }
}

// MIR FOR CTFE
fn SortField::NameMixHidden(_1: SortCase) -> SortField {
    let mut _0: fs::filter::SortField;

    bb0: {
        _0 = SortField::NameMixHidden(move _1);
        return;
    }
}

fn OptionsError::Parse(_1: ParseError) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Parse(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Parse(_1: ParseError) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Parse(move _1);
        return;
    }
}

fn OptionsError::BadArgument(_1: &Arg, _2: OsString) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::BadArgument(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::BadArgument(_1: &Arg, _2: OsString) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::BadArgument(move _1, move _2);
        return;
    }
}

fn OptionsError::Unsupported(_1: String) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Unsupported(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Unsupported(_1: String) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Unsupported(move _1);
        return;
    }
}

fn OptionsError::Duplicate(_1: Flag, _2: Flag) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Duplicate(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Duplicate(_1: Flag, _2: Flag) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Duplicate(move _1, move _2);
        return;
    }
}

fn OptionsError::Conflict(_1: &Arg, _2: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Conflict(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Conflict(_1: &Arg, _2: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Conflict(move _1, move _2);
        return;
    }
}

fn OptionsError::Useless(_1: &Arg, _2: bool, _3: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Useless(move _1, move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Useless(_1: &Arg, _2: bool, _3: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Useless(move _1, move _2, move _3);
        return;
    }
}

fn OptionsError::Useless2(_1: &Arg, _2: &Arg, _3: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Useless2(move _1, move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::Useless2(_1: &Arg, _2: &Arg, _3: &Arg) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::Useless2(move _1, move _2, move _3);
        return;
    }
}

fn OptionsError::FailedParse(_1: String, _2: NumberSource, _3: ParseIntError) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::FailedParse(move _1, move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::FailedParse(_1: String, _2: NumberSource, _3: ParseIntError) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::FailedParse(move _1, move _2, move _3);
        return;
    }
}

fn OptionsError::FailedGlobPattern(_1: String) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::FailedGlobPattern(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsError::FailedGlobPattern(_1: String) -> OptionsError {
    let mut _0: options::error::OptionsError;

    bb0: {
        _0 = OptionsError::FailedGlobPattern(move _1);
        return;
    }
}

fn NumberSource::Arg(_1: &Arg) -> NumberSource {
    let mut _0: options::error::NumberSource;

    bb0: {
        _0 = NumberSource::Arg(move _1);
        return;
    }
}

// MIR FOR CTFE
fn NumberSource::Arg(_1: &Arg) -> NumberSource {
    let mut _0: options::error::NumberSource;

    bb0: {
        _0 = NumberSource::Arg(move _1);
        return;
    }
}

fn NumberSource::Env(_1: &str) -> NumberSource {
    let mut _0: options::error::NumberSource;

    bb0: {
        _0 = NumberSource::Env(move _1);
        return;
    }
}

// MIR FOR CTFE
fn NumberSource::Env(_1: &str) -> NumberSource {
    let mut _0: options::error::NumberSource;

    bb0: {
        _0 = NumberSource::Env(move _1);
        return;
    }
}

fn Choices(_1: &[&str]) -> Choices {
    let mut _0: options::error::Choices;

    bb0: {
        _0 = Choices(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Choices(_1: &[&str]) -> Choices {
    let mut _0: options::error::Choices;

    bb0: {
        _0 = Choices(move _1);
        return;
    }
}

fn Flag::Short(_1: u8) -> Flag {
    let mut _0: options::parser::Flag;

    bb0: {
        _0 = Flag::Short(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Flag::Short(_1: u8) -> Flag {
    let mut _0: options::parser::Flag;

    bb0: {
        _0 = Flag::Short(move _1);
        return;
    }
}

fn Flag::Long(_1: &str) -> Flag {
    let mut _0: options::parser::Flag;

    bb0: {
        _0 = Flag::Long(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Flag::Long(_1: &str) -> Flag {
    let mut _0: options::parser::Flag;

    bb0: {
        _0 = Flag::Long(move _1);
        return;
    }
}

fn TakesValue::Necessary(_1: Option<&[&str]>) -> TakesValue {
    let mut _0: options::parser::TakesValue;

    bb0: {
        _0 = TakesValue::Necessary(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TakesValue::Necessary(_1: Option<&[&str]>) -> TakesValue {
    let mut _0: options::parser::TakesValue;

    bb0: {
        _0 = TakesValue::Necessary(move _1);
        return;
    }
}

fn TakesValue::Optional(_1: Option<&[&str]>) -> TakesValue {
    let mut _0: options::parser::TakesValue;

    bb0: {
        _0 = TakesValue::Optional(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TakesValue::Optional(_1: Option<&[&str]>) -> TakesValue {
    let mut _0: options::parser::TakesValue;

    bb0: {
        _0 = TakesValue::Optional(move _1);
        return;
    }
}

fn options::parser::Args(_1: &[&Arg]) -> options::parser::Args {
    let mut _0: options::parser::Args;

    bb0: {
        _0 = options::parser::Args(move _1);
        return;
    }
}

// MIR FOR CTFE
fn options::parser::Args(_1: &[&Arg]) -> options::parser::Args {
    let mut _0: options::parser::Args;

    bb0: {
        _0 = options::parser::Args(move _1);
        return;
    }
}

fn OptionsResult::Ok(_1: options::Options, _2: Vec<&OsStr>) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Ok(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn OptionsResult::Ok(_1: options::Options, _2: Vec<&OsStr>) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Ok(move _1, move _2);
        return;
    }
}

fn OptionsResult::InvalidOptions(_1: OptionsError) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::InvalidOptions(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsResult::InvalidOptions(_1: OptionsError) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::InvalidOptions(move _1);
        return;
    }
}

fn OptionsResult::Help(_1: HelpString) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Help(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsResult::Help(_1: HelpString) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Help(move _1);
        return;
    }
}

fn OptionsResult::Version(_1: VersionString) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Version(move _1);
        return;
    }
}

// MIR FOR CTFE
fn OptionsResult::Version(_1: VersionString) -> OptionsResult<'_> {
    let mut _0: options::OptionsResult<'_>;

    bb0: {
        _0 = OptionsResult::<'_>::Version(move _1);
        return;
    }
}

fn ShowIcons::On(_1: u32) -> ShowIcons {
    let mut _0: output::file_name::ShowIcons;

    bb0: {
        _0 = ShowIcons::On(move _1);
        return;
    }
}

// MIR FOR CTFE
fn ShowIcons::On(_1: u32) -> ShowIcons {
    let mut _0: output::file_name::ShowIcons;

    bb0: {
        _0 = ShowIcons::On(move _1);
        return;
    }
}

fn RowThreshold::MinimumRows(_1: usize) -> RowThreshold {
    let mut _0: output::grid_details::RowThreshold;

    bb0: {
        _0 = RowThreshold::MinimumRows(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RowThreshold::MinimumRows(_1: usize) -> RowThreshold {
    let mut _0: output::grid_details::RowThreshold;

    bb0: {
        _0 = RowThreshold::MinimumRows(move _1);
        return;
    }
}

fn Column::Timestamp(_1: table::TimeType) -> Column {
    let mut _0: output::table::Column;

    bb0: {
        _0 = Column::Timestamp(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Column::Timestamp(_1: table::TimeType) -> Column {
    let mut _0: output::table::Column;

    bb0: {
        _0 = Column::Timestamp(move _1);
        return;
    }
}

fn TableWidths(_1: Vec<usize>) -> TableWidths {
    let mut _0: output::table::TableWidths;

    bb0: {
        _0 = TableWidths(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TableWidths(_1: Vec<usize>) -> TableWidths {
    let mut _0: output::table::TableWidths;

    bb0: {
        _0 = TableWidths(move _1);
        return;
    }
}

fn TextCellContents(_1: Vec<ANSIGenericString<'_, str>>) -> TextCellContents {
    let mut _0: output::cell::TextCellContents;

    bb0: {
        _0 = TextCellContents(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TextCellContents(_1: Vec<ANSIGenericString<'_, str>>) -> TextCellContents {
    let mut _0: output::cell::TextCellContents;

    bb0: {
        _0 = TextCellContents(move _1);
        return;
    }
}

fn DisplayWidth(_1: usize) -> DisplayWidth {
    let mut _0: output::cell::DisplayWidth;

    bb0: {
        _0 = DisplayWidth(move _1);
        return;
    }
}

// MIR FOR CTFE
fn DisplayWidth(_1: usize) -> DisplayWidth {
    let mut _0: output::cell::DisplayWidth;

    bb0: {
        _0 = DisplayWidth(move _1);
        return;
    }
}

fn TreeDepth(_1: usize) -> TreeDepth {
    let mut _0: output::tree::TreeDepth;

    bb0: {
        _0 = TreeDepth(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TreeDepth(_1: usize) -> TreeDepth {
    let mut _0: output::tree::TreeDepth;

    bb0: {
        _0 = TreeDepth(move _1);
        return;
    }
}

fn output::Mode::Grid(_1: grid::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::Grid(move _1);
        return;
    }
}

// MIR FOR CTFE
fn output::Mode::Grid(_1: grid::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::Grid(move _1);
        return;
    }
}

fn output::Mode::Details(_1: details::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::Details(move _1);
        return;
    }
}

// MIR FOR CTFE
fn output::Mode::Details(_1: details::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::Details(move _1);
        return;
    }
}

fn output::Mode::GridDetails(_1: grid_details::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::GridDetails(move _1);
        return;
    }
}

// MIR FOR CTFE
fn output::Mode::GridDetails(_1: grid_details::Options) -> output::Mode {
    let mut _0: output::Mode;

    bb0: {
        _0 = output::Mode::GridDetails(move _1);
        return;
    }
}

fn TerminalWidth::Set(_1: usize) -> TerminalWidth {
    let mut _0: output::TerminalWidth;

    bb0: {
        _0 = TerminalWidth::Set(move _1);
        return;
    }
}

// MIR FOR CTFE
fn TerminalWidth::Set(_1: usize) -> TerminalWidth {
    let mut _0: output::TerminalWidth;

    bb0: {
        _0 = TerminalWidth::Set(move _1);
        return;
    }
}

fn LSColors(_1: &str) -> LSColors<'_> {
    let mut _0: theme::lsc::LSColors<'_>;

    bb0: {
        _0 = LSColors::<'_>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn LSColors(_1: &str) -> LSColors<'_> {
    let mut _0: theme::lsc::LSColors<'_>;

    bb0: {
        _0 = LSColors::<'_>(move _1);
        return;
    }
}
