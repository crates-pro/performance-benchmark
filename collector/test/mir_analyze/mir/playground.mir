// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const C: i8 = {
    let mut _0: i8;

    bb0: {
        _0 = const 0_i8;
        return;
    }
}

static S: u8 = {
    let mut _0: u8;

    bb0: {
        _0 = const 1_u8;
        return;
    }
}

fn <impl at src\main.rs:10:1: 10:7>::get_number(_1: &A) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = ((*_1).0: i32);
        return;
    }
}

fn ret_1() -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn ret_2() -> i32 {
    let mut _0: i32;

    bb0: {
        _0 = const 2_i32;
        return;
    }
}

fn never_return() -> ! {
    let mut _0: !;
    let _1: !;

    bb0: {
        _1 = panic_cold_explicit() -> unwind continue;
    }
}

fn panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

// MIR FOR CTFE
fn panic_cold_explicit() -> ! {
    let mut _0: !;

    bb0: {
        ConstEvalCounter;
        _0 = core::panicking::panic_explicit() -> unwind continue;
    }
}

fn main() -> () {
    let mut _0: ();
    let _1: ();
    let _2: i32;
    let _7: i32;
    let mut _8: &A;
    let mut _11: (i8, bool);
    let mut _13: (i8, bool);
    let mut _15: (i8, bool);
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _27: u32;
    let mut _28: bool;
    let mut _30: u32;
    let mut _31: bool;
    let mut _41: bool;
    let mut _43: bool;
    let mut _45: usize;
    let mut _46: i8;
    let mut _47: usize;
    let mut _48: usize;
    let mut _50: &u8;
    let mut _52: &mut i32;
    let _53: usize;
    let mut _54: usize;
    let mut _55: bool;
    let _57: usize;
    let mut _58: usize;
    let mut _59: bool;
    let _61: usize;
    let mut _62: usize;
    let mut _63: &[i32];
    let mut _64: &[i32; 3];
    let mut _65: (usize, bool);
    let mut _66: usize;
    let mut _67: bool;
    let _68: &[i32];
    let mut _69: &[i32; 3];
    let mut _70: std::ops::Range<usize>;
    let mut _72: &mut i32;
    let _73: usize;
    let mut _74: usize;
    let mut _75: bool;
    let mut _78: !;
    scope 1 {
        debug _y => _2;
        let mut _3: A;
        scope 2 {
            debug a => _3;
            let _4: i32;
            scope 3 {
                debug _x => _4;
                let _5: &i32;
                scope 4 {
                    debug _x => _5;
                    let _6: &mut i32;
                    scope 5 {
                        debug _x => _6;
                        let _9: &mut i32;
                        scope 6 {
                            debug t => _9;
                            let _10: i8;
                            scope 7 {
                                debug _x => _10;
                                let _12: i8;
                                scope 8 {
                                    debug _x => _12;
                                    let _14: i8;
                                    scope 9 {
                                        debug _x => _14;
                                        let _16: i8;
                                        scope 10 {
                                            debug _x => _16;
                                            let _21: i8;
                                            scope 11 {
                                                debug _x => _21;
                                                let _26: i8;
                                                scope 12 {
                                                    debug _x => _26;
                                                    let _29: i8;
                                                    scope 13 {
                                                        debug _x => _29;
                                                        let _32: i8;
                                                        scope 14 {
                                                            debug _x => _32;
                                                            let _33: i8;
                                                            scope 15 {
                                                                debug _x => _33;
                                                                let _34: i8;
                                                                scope 16 {
                                                                    debug _x => _34;
                                                                    let _35: bool;
                                                                    scope 17 {
                                                                        debug _x => _35;
                                                                        let _36: bool;
                                                                        scope 18 {
                                                                            debug _x => _36;
                                                                            let _37: bool;
                                                                            scope 19 {
                                                                                debug _x => _37;
                                                                                let _38: bool;
                                                                                scope 20 {
                                                                                    debug _x => _38;
                                                                                    let _39: bool;
                                                                                    scope 21 {
                                                                                        debug _x => _39;
                                                                                        let _40: i8;
                                                                                        scope 22 {
                                                                                            debug _x => _40;
                                                                                            let _42: bool;
                                                                                            scope 23 {
                                                                                                debug _x => _42;
                                                                                                let mut _44: usize;
                                                                                                let mut _79: &i8;
                                                                                                scope 24 {
                                                                                                    debug _x => _44;
                                                                                                    let _49: u8;
                                                                                                    scope 25 {
                                                                                                        debug _y => _49;
                                                                                                        let mut _51: [i32; 3];
                                                                                                        scope 26 {
                                                                                                            debug _x => _51;
                                                                                                            let _56: i32;
                                                                                                            scope 27 {
                                                                                                                debug _y => _56;
                                                                                                                let _60: i32;
                                                                                                                scope 28 {
                                                                                                                    debug _y => _60;
                                                                                                                    scope 29 {
                                                                                                                        debug _y => _68;
                                                                                                                        let mut _71: i32;
                                                                                                                        scope 30 {
                                                                                                                            debug _x => _71;
                                                                                                                            let _76: u8;
                                                                                                                            scope 31 {
                                                                                                                                debug _x => const 1_u8;
                                                                                                                                let _77: i32;
                                                                                                                                scope 32 {
                                                                                                                                    debug _y => _77;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _1 = ret_1() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = ret_2() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = A { number: const 0_i32 };
        _4 = (_3.0: i32);
        _5 = &(_3.0: i32);
        _6 = &mut (_3.0: i32);
        _8 = &_3;
        _7 = A::get_number(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut (_3.0: i32);
        (*_9) = const 3_i32;
        _11 = CheckedAdd(const _, const 1_i8);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, const 1_i8) -> [success: bb4, unwind continue];
    }

    bb4: {
        _10 = move (_11.0: i8);
        _13 = CheckedSub(const _, _10);
        assert(!move (_13.1: bool), "attempt to compute `{} - {}`, which would overflow", const _, _10) -> [success: bb5, unwind continue];
    }

    bb5: {
        _12 = move (_13.0: i8);
        _15 = CheckedMul(const _, const 1_i8);
        assert(!move (_15.1: bool), "attempt to compute `{} * {}`, which would overflow", const _, const 1_i8) -> [success: bb6, unwind continue];
    }

    bb6: {
        _14 = move (_15.0: i8);
        _17 = Eq(const 1_i8, const 0_i8);
        assert(!move _17, "attempt to divide `{}` by zero", const _) -> [success: bb7, unwind continue];
    }

    bb7: {
        _18 = Eq(const 1_i8, const -1_i8);
        _19 = Eq(const _, const i8::MIN);
        _20 = BitAnd(move _18, move _19);
        assert(!move _20, "attempt to compute `{} / {}`, which would overflow", const _, const 1_i8) -> [success: bb8, unwind continue];
    }

    bb8: {
        _16 = Div(const _, const 1_i8);
        _22 = Eq(const 1_i8, const 0_i8);
        assert(!move _22, "attempt to calculate the remainder of `{}` with a divisor of zero", const _) -> [success: bb9, unwind continue];
    }

    bb9: {
        _23 = Eq(const 1_i8, const -1_i8);
        _24 = Eq(const _, const i8::MIN);
        _25 = BitAnd(move _23, move _24);
        assert(!move _25, "attempt to compute the remainder of `{} % {}`, which would overflow", const _, const 1_i8) -> [success: bb10, unwind continue];
    }

    bb10: {
        _21 = Rem(const _, const 1_i8);
        _27 = const 1_i32 as u32 (IntToInt);
        _28 = Lt(move _27, const 8_u32);
        assert(move _28, "attempt to shift left by `{}`, which would overflow", const 1_i32) -> [success: bb11, unwind continue];
    }

    bb11: {
        _26 = Shl(const _, const 1_i32);
        _30 = const 1_i32 as u32 (IntToInt);
        _31 = Lt(move _30, const 8_u32);
        assert(move _31, "attempt to shift right by `{}`, which would overflow", const 1_i32) -> [success: bb12, unwind continue];
    }

    bb12: {
        _29 = Shr(const _, const 1_i32);
        _32 = BitXor(const _, const 1_i8);
        _33 = BitAnd(const _, const 1_i8);
        _34 = BitOr(const _, const 1_i8);
        _35 = Lt(const _, const 1_i8);
        _36 = Gt(const _, const 1_i8);
        _37 = Le(const _, const 1_i8);
        _38 = Ge(const _, const 1_i8);
        _39 = Eq(const _, const 1_i8);
        _41 = Eq(const _, const i8::MIN);
        assert(!move _41, "attempt to negate `{}`, which would overflow", const _) -> [success: bb13, unwind continue];
    }

    bb13: {
        _40 = Neg(const _);
        _43 = Eq(_40, const _);
        _42 = Not(move _43);
        _79 = const _;
        _44 = std::mem::size_of_val::<i8>(_79) -> [return: bb14, unwind continue];
    }

    bb14: {
        _47 = _44;
        _46 = move _47 as i8 (IntToInt);
        switchInt(_46) -> [255: bb16, 0: bb17, 1: bb18, 2: bb18, 3: bb18, otherwise: bb15];
    }

    bb15: {
        _45 = const 5_usize;
        goto -> bb19;
    }

    bb16: {
        _45 = const 1_usize;
        goto -> bb19;
    }

    bb17: {
        _45 = const 3_usize;
        goto -> bb19;
    }

    bb18: {
        _45 = const 4_usize;
        goto -> bb19;
    }

    bb19: {
        _44 = move _45;
        _48 = const 5_usize;
        _44 = move _48;
        _50 = const {alloc1: &u8};
        _49 = (*_50);
        _51 = [const 1_i32, const 2_i32, const 3_i32];
        _53 = const 2_usize;
        _54 = const 3_usize;
        _55 = Lt(_53, _54);
        assert(move _55, "index out of bounds: the length is {} but the index is {}", move _54, _53) -> [success: bb20, unwind continue];
    }

    bb20: {
        _52 = &mut _51[_53];
        (*_52) = const 4_i32;
        _57 = const 1_usize;
        _58 = const 3_usize;
        _59 = Lt(_57, _58);
        assert(move _59, "index out of bounds: the length is {} but the index is {}", move _58, _57) -> [success: bb21, unwind continue];
    }

    bb21: {
        _56 = _51[_57];
        _64 = &_51;
        _63 = move _64 as &[i32] (PointerCoercion(Unsize));
        _62 = Len((*_63));
        _65 = CheckedSub(_62, const 1_usize);
        assert(!move (_65.1: bool), "attempt to compute `{} - {}`, which would overflow", move _62, const 1_usize) -> [success: bb22, unwind continue];
    }

    bb22: {
        _61 = move (_65.0: usize);
        _66 = const 3_usize;
        _67 = Lt(_61, _66);
        assert(move _67, "index out of bounds: the length is {} but the index is {}", move _66, _61) -> [success: bb23, unwind continue];
    }

    bb23: {
        _60 = _51[_61];
        _69 = &_51;
        _70 = std::ops::Range::<usize> { start: const 1_usize, end: const 2_usize };
        _68 = <[i32; 3] as Index<std::ops::Range<usize>>>::index(move _69, move _70) -> [return: bb24, unwind continue];
    }

    bb24: {
        _73 = const 2_usize;
        _74 = const 3_usize;
        _75 = Lt(_73, _74);
        assert(move _75, "index out of bounds: the length is {} but the index is {}", move _74, _73) -> [success: bb25, unwind continue];
    }

    bb25: {
        _72 = &mut _51[_73];
        _71 = (*_72);
        _71 = const 3_i32;
        _76 = const 1_u8;
        _77 = _76 as i32 (IntToInt);
        _78 = never_return() -> unwind continue;
    }
}

alloc1 (static: S, size: 1, align: 1) {
    01                                              │ .
}

promoted[0] in main: &i8 = {
    let mut _0: &i8;
    let mut _1: i8;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}
