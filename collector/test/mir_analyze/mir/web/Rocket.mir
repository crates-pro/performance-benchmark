// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn exports::<impl at core/codegen/src/exports.rs:4:10: 4:15>::fmt(_1: &StaticPath, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &std::option::Option<proc_macro2::Span>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&&str;
    let _8: &&str;

    bb0: {
        _3 = const "StaticPath";
        _5 = &((*_1).0: std::option::Option<proc_macro2::Span>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: &str);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:4:23: 4:28>::clone(_1: &StaticPath) -> StaticPath {
    debug self => _1;
    let mut _0: exports::StaticPath;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:7:10: 7:15>::fmt(_1: &exports::StaticTokens, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&fn() -> proc_macro2::TokenStream;
    let _6: &fn() -> proc_macro2::TokenStream;

    bb0: {
        _3 = const "StaticTokens";
        _6 = &((*_1).0: fn() -> proc_macro2::TokenStream);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:7:23: 7:28>::clone(_1: &exports::StaticTokens) -> exports::StaticTokens {
    debug self => _1;
    let mut _0: exports::StaticTokens;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:16:1: 16:31>::to_tokens(_1: &exports::StaticTokens, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: proc_macro2::TokenStream;
    let mut _5: fn() -> proc_macro2::TokenStream;

    bb0: {
        _5 = ((*_1).0: fn() -> proc_macro2::TokenStream);
        _4 = move _5() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <TokenStream2 as quote::TokenStreamExt>::append_all::<TokenStream2>(_2, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:22:1: 22:16>::respanned(_1: StaticPath, _2: proc_macro2::Span) -> StaticPath {
    debug self => _1;
    debug span => _2;
    let mut _0: exports::StaticPath;
    let mut _3: std::option::Option<proc_macro2::Span>;

    bb0: {
        _3 = Option::<proc_macro2::Span>::Some(_2);
        (_1.0: std::option::Option<proc_macro2::Span>) = move _3;
        _0 = _1;
        return;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:29:1: 29:29>::to_tokens(_1: &StaticPath, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: syn::Path;
    let mut _4: std::result::Result<syn::Path, syn::Error>;
    let mut _5: isize;
    let mut _8: proc_macro2::token_stream::IntoIter;
    let mut _9: proc_macro2::TokenStream;
    let mut _10: syn::Path;
    let mut _11: {closure@core/codegen/src/exports.rs:35:22: 35:29};
    let mut _12: &proc_macro2::Span;
    let _13: ();
    let mut _14: &syn::Path;
    let mut _15: &str;
    let mut _16: bool;
    scope 1 {
        debug path => _3;
        scope 2 {
            debug span => _6;
            let _6: proc_macro2::Span;
            let _7: std::iter::Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/exports.rs:35:22: 35:29}>;
            scope 3 {
                debug new_tokens => _7;
            }
        }
    }

    bb0: {
        _16 = const false;
        _15 = deref_copy ((*_1).1: &str);
        _4 = syn::parse_str::<syn::Path>(_15) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::result::Result::<syn::Path, syn::Error>::unwrap(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _16 = const true;
        _5 = discriminant(((*_1).0: std::option::Option<proc_macro2::Span>));
        switchInt(move _5) -> [1: bb3, otherwise: bb7];
    }

    bb3: {
        _6 = ((((*_1).0: std::option::Option<proc_macro2::Span>) as Some).0: proc_macro2::Span);
        _16 = const false;
        _10 = move _3;
        _9 = <syn::Path as ToTokens>::into_token_stream(move _10) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _8 = <TokenStream2 as IntoIterator>::into_iter(move _9) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _12 = &_6;
        _11 = {closure@core/codegen/src/exports.rs:35:22: 35:29} { span: move _12 };
        _7 = <proc_macro2::token_stream::IntoIter as Iterator>::map::<proc_macro2::TokenTree, {closure@core/codegen/src/exports.rs:35:22: 35:29}>(move _8, move _11) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _13 = <TokenStream2 as quote::TokenStreamExt>::append_all::<Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/exports.rs:35:22: 35:29}>>(_2, move _7) -> [return: bb14, unwind: bb13];
    }

    bb7: {
        _14 = &_3;
        _0 = <syn::Path as ToTokens>::to_tokens(move _14, _2) -> [return: bb15, unwind: bb13];
    }

    bb8: {
        _16 = const false;
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        drop(_3) -> [return: bb8, unwind continue];
    }

    bb11: {
        switchInt(_16) -> [0: bb8, otherwise: bb10];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_16) -> [0: bb9, otherwise: bb12];
    }

    bb14: {
        goto -> bb11;
    }

    bb15: {
        goto -> bb11;
    }
}

fn exports::<impl at core/codegen/src/exports.rs:29:1: 29:29>::to_tokens::{closure#0}(_1: &mut {closure@core/codegen/src/exports.rs:35:22: 35:29}, _2: proc_macro2::TokenTree) -> proc_macro2::TokenTree {
    debug t => _2;
    debug span => (*((*_1).0: &proc_macro2::Span));
    let mut _0: proc_macro2::TokenTree;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenTree;
    let mut _5: proc_macro2::Span;
    let mut _6: &proc_macro2::Span;

    bb0: {
        _4 = &mut _2;
        _6 = deref_copy ((*_1).0: &proc_macro2::Span);
        _5 = (*_6);
        _3 = proc_macro2::TokenTree::set_span(move _4, move _5) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move _2;
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

const exports::__req: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__req");
        StorageDead(_1);
        return;
    }
}

const exports::__status: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__status");
        StorageDead(_1);
        return;
    }
}

const __catcher: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__catcher");
        StorageDead(_1);
        return;
    }
}

const exports::__data: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__data");
        StorageDead(_1);
        return;
    }
}

const __error: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__error");
        StorageDead(_1);
        return;
    }
}

const __trail: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "__trail");
        StorageDead(_1);
        return;
    }
}

const _request: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::request");
        StorageDead(_1);
        return;
    }
}

const exports::_response: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::response");
        StorageDead(_1);
        return;
    }
}

const exports::_route: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::route");
        StorageDead(_1);
        return;
    }
}

const exports::_catcher: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::catcher");
        StorageDead(_1);
        return;
    }
}

const _sentinel: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::sentinel");
        StorageDead(_1);
        return;
    }
}

const _log: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::log");
        StorageDead(_1);
        return;
    }
}

const exports::_form: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::form::prelude");
        StorageDead(_1);
        return;
    }
}

const exports::_http: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::http");
        StorageDead(_1);
        return;
    }
}

const _uri: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::http::uri");
        StorageDead(_1);
        return;
    }
}

const exports::_fmt: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::http::uri::fmt");
        StorageDead(_1);
        return;
    }
}

const exports::_Option: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::option::Option");
        StorageDead(_1);
        return;
    }
}

const exports::_Result: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::result::Result");
        StorageDead(_1);
        return;
    }
}

const exports::_Some: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::option::Option::Some");
        StorageDead(_1);
        return;
    }
}

const exports::_None: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::option::Option::None");
        StorageDead(_1);
        return;
    }
}

const exports::_Ok: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::result::Result::Ok");
        StorageDead(_1);
        return;
    }
}

const exports::_Err: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::result::Result::Err");
        StorageDead(_1);
        return;
    }
}

const exports::_Box: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::boxed::Box");
        StorageDead(_1);
        return;
    }
}

const _Vec: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::vec::Vec");
        StorageDead(_1);
        return;
    }
}

const exports::_Cow: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::borrow::Cow");
        StorageDead(_1);
        return;
    }
}

const BorrowMut: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::std::borrow::BorrowMut");
        StorageDead(_1);
        return;
    }
}

const Outcome: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::outcome::Outcome");
        StorageDead(_1);
        return;
    }
}

const FromForm: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::form::FromForm");
        StorageDead(_1);
        return;
    }
}

const FromRequest: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::request::FromRequest");
        StorageDead(_1);
        return;
    }
}

const FromData: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::data::FromData");
        StorageDead(_1);
        return;
    }
}

const FromSegments: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::request::FromSegments");
        StorageDead(_1);
        return;
    }
}

const FromParam: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::request::FromParam");
        StorageDead(_1);
        return;
    }
}

const exports::Request: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::request::Request");
        StorageDead(_1);
        return;
    }
}

const exports::Response: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::response::Response");
        StorageDead(_1);
        return;
    }
}

const exports::Data: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::data::Data");
        StorageDead(_1);
        return;
    }
}

const StaticRouteInfo: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::StaticRouteInfo");
        StorageDead(_1);
        return;
    }
}

const StaticCatcherInfo: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::StaticCatcherInfo");
        StorageDead(_1);
        return;
    }
}

const exports::Route: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::Route");
        StorageDead(_1);
        return;
    }
}

const exports::Catcher: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::Catcher");
        StorageDead(_1);
        return;
    }
}

const SmallVec: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::http::private::SmallVec");
        StorageDead(_1);
        return;
    }
}

const exports::Status: StaticPath = {
    let mut _0: exports::StaticPath;
    let mut _1: std::option::Option<proc_macro2::Span>;

    bb0: {
        StorageLive(_1);
        _1 = Option::<proc_macro2::Span>::None;
        _0 = StaticPath(move _1, const "::rocket::http::Status");
        StorageDead(_1);
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:9:1: 9:17>::new() -> Diagnostics {
    let mut _0: proc_macro_ext::Diagnostics;
    let mut _1: std::vec::Vec<devise::Diagnostic>;

    bb0: {
        _1 = Vec::<devise::Diagnostic>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Diagnostics(move _1);
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:9:1: 9:17>::push(_1: &mut Diagnostics, _2: devise::Diagnostic) -> () {
    debug self => _1;
    debug diag => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: &mut std::vec::Vec<devise::Diagnostic>;

    bb0: {
        _4 = &mut ((*_1).0: std::vec::Vec<devise::Diagnostic>);
        _3 = Vec::<devise::Diagnostic>::push(move _4, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:9:1: 9:17>::emit_head(_1: Diagnostics) -> devise::Diagnostic {
    debug self => _1;
    let mut _0: devise::Diagnostic;
    let mut _2: std::vec::IntoIter<devise::Diagnostic>;
    let mut _3: std::vec::Vec<devise::Diagnostic>;
    let mut _5: std::option::Option<devise::Diagnostic>;
    let mut _6: &mut std::vec::IntoIter<devise::Diagnostic>;
    let _7: &str;
    let mut _8: std::vec::IntoIter<devise::Diagnostic>;
    let mut _9: std::vec::IntoIter<devise::Diagnostic>;
    let mut _11: std::option::Option<devise::Diagnostic>;
    let mut _12: &mut std::vec::IntoIter<devise::Diagnostic>;
    let mut _13: isize;
    let _15: proc_macro2::TokenStream;
    let mut _16: devise::Diagnostic;
    let mut _17: devise::Diagnostic;
    let mut _18: bool;
    let mut _19: bool;
    scope 1 {
        debug iter => _2;
        let mut _4: devise::Diagnostic;
        scope 2 {
            debug last => _4;
            let mut _10: std::vec::IntoIter<devise::Diagnostic>;
            scope 3 {
                debug iter => _10;
                let _14: devise::Diagnostic;
                scope 4 {
                    debug diag => _14;
                }
            }
        }
    }

    bb0: {
        _19 = const false;
        _18 = const false;
        _3 = move (_1.0: std::vec::Vec<devise::Diagnostic>);
        _2 = <Vec<devise::Diagnostic> as IntoIterator>::into_iter(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _19 = const true;
        _6 = &mut _2;
        _5 = <std::vec::IntoIter<devise::Diagnostic> as Iterator>::next(move _6) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _7 = const "Diagnostic::emit_head empty";
        _4 = Option::<devise::Diagnostic>::expect(move _5, _7) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _18 = const true;
        _19 = const false;
        _9 = move _2;
        _8 = <std::vec::IntoIter<devise::Diagnostic> as IntoIterator>::into_iter(move _9) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _10 = move _8;
        goto -> bb5;
    }

    bb5: {
        _12 = &mut _10;
        _11 = <std::vec::IntoIter<devise::Diagnostic> as Iterator>::next(_12) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb9, 1: bb7, otherwise: bb8];
    }

    bb7: {
        _14 = move ((_11 as Some).0: devise::Diagnostic);
        _18 = const false;
        _16 = move _4;
        _15 = devise::Diagnostic::emit_as_item_tokens(move _16) -> [return: bb10, unwind: bb13];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        drop(_10) -> [return: bb12, unwind: bb17];
    }

    bb10: {
        drop(_15) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        _17 = move _14;
        _18 = const true;
        _4 = move _17;
        goto -> bb5;
    }

    bb12: {
        _18 = const false;
        _0 = move _4;
        _18 = const false;
        _19 = const false;
        return;
    }

    bb13 (cleanup): {
        drop(_14) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        drop(_10) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_4) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_18) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_19) -> [0: bb15, otherwise: bb18];
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:9:1: 9:17>::head_err_or(_1: Diagnostics, _2: T) -> std::result::Result<T, devise::Diagnostic> {
    debug self => _1;
    debug ok => _2;
    let mut _0: std::result::Result<T, devise::Diagnostic>;
    let mut _3: bool;
    let mut _4: &std::vec::Vec<devise::Diagnostic>;
    let mut _5: T;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro_ext::Diagnostics;
    let mut _8: bool;
    let mut _9: bool;

    bb0: {
        _9 = const false;
        _8 = const false;
        _9 = const true;
        _8 = const true;
        _4 = &(_1.0: std::vec::Vec<devise::Diagnostic>);
        _3 = Vec::<devise::Diagnostic>::is_empty(move _4) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        switchInt(_3) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _9 = const false;
        _7 = move _1;
        _6 = Diagnostics::emit_head(move _7) -> [return: bb4, unwind: bb8];
    }

    bb3: {
        _8 = const false;
        _5 = move _2;
        _0 = std::result::Result::<T, devise::Diagnostic>::Ok(move _5);
        goto -> bb5;
    }

    bb4: {
        _0 = std::result::Result::<T, devise::Diagnostic>::Err(move _6);
        goto -> bb5;
    }

    bb5: {
        switchInt(_8) -> [0: bb6, otherwise: bb10];
    }

    bb6: {
        switchInt(_9) -> [0: bb7, otherwise: bb11];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        drop(_2) -> [return: bb6, unwind: bb13];
    }

    bb11: {
        drop(_1) -> [return: bb7, unwind continue];
    }

    bb12 (cleanup): {
        drop(_1) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_9) -> [0: bb9, otherwise: bb12];
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:38:1: 38:38>::from(_1: devise::Diagnostic) -> Diagnostics {
    debug diag => _1;
    let mut _0: proc_macro_ext::Diagnostics;
    let mut _2: std::vec::Vec<devise::Diagnostic>;
    let mut _3: std::boxed::Box<[devise::Diagnostic]>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: *mut u8;
    let mut _7: std::boxed::Box<[devise::Diagnostic; 1]>;
    let mut _8: devise::Diagnostic;
    let mut _9: bool;
    let mut _10: *const [devise::Diagnostic; 1];
    let mut _11: *const ();
    let mut _12: usize;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: usize;
    let mut _16: bool;
    scope 1 {
    }

    bb0: {
        _9 = const false;
        _9 = const true;
        _4 = SizeOf([devise::Diagnostic; 1]);
        _5 = AlignOf([devise::Diagnostic; 1]);
        _6 = alloc::alloc::exchange_malloc(move _4, move _5) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _7 = ShallowInitBox(move _6, [devise::Diagnostic; 1]);
        _9 = const false;
        _8 = move _1;
        _10 = (((_7.0: std::ptr::Unique<[devise::Diagnostic; 1]>).0: std::ptr::NonNull<[devise::Diagnostic; 1]>).0: *const [devise::Diagnostic; 1]);
        _11 = _10 as *const () (PtrToPtr);
        _12 = _11 as usize (Transmute);
        _13 = AlignOf([devise::Diagnostic; 1]);
        _14 = Sub(_13, const 1_usize);
        _15 = BitAnd(_12, _14);
        _16 = Eq(_15, const 0_usize);
        assert(_16, "misaligned pointer dereference: address must be a multiple of {} but is {}", _13, _12) -> [success: bb6, unwind unreachable];
    }

    bb2: {
        _0 = Diagnostics(move _2);
        return;
    }

    bb3 (cleanup): {
        resume;
    }

    bb4 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        switchInt(_9) -> [0: bb3, otherwise: bb4];
    }

    bb6: {
        (*_10) = [move _8];
        _3 = move _7 as std::boxed::Box<[devise::Diagnostic]> (PointerCoercion(Unsize));
        _2 = slice::<impl [devise::Diagnostic]>::into_vec::<std::alloc::Global>(move _3) -> [return: bb2, unwind: bb5];
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:44:1: 44:43>::from(_1: Vec<devise::Diagnostic>) -> Diagnostics {
    debug diags => _1;
    let mut _0: proc_macro_ext::Diagnostics;

    bb0: {
        _0 = Diagnostics(move _1);
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:52:1: 52:15>::new(_1: S, _2: proc_macro2::Span) -> StringLit {
    debug string => _1;
    debug span => _2;
    let mut _0: proc_macro_ext::StringLit;
    let _3: std::string::String;
    let _5: &str;
    let _6: &std::string::String;
    let _7: ();
    let mut _8: &mut proc_macro2::Literal;
    let mut _9: std::string::String;
    let mut _10: proc_macro2::Literal;
    scope 1 {
        debug string => _3;
        let mut _4: proc_macro2::Literal;
        scope 2 {
            debug lit => _4;
        }
    }

    bb0: {
        _3 = <S as Into<std::string::String>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_3;
        _5 = <std::string::String as std::ops::Deref>::deref(_6) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = proc_macro2::Literal::string(_5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _8 = &mut _4;
        _7 = proc_macro2::Literal::set_span(move _8, _2) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _9 = move _3;
        _10 = move _4;
        _0 = StringLit(move _9, move _10);
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:52:1: 52:15>::span(_1: &StringLit) -> proc_macro2::Span {
    debug self => _1;
    let mut _0: proc_macro2::Span;
    let mut _2: &proc_macro2::Literal;

    bb0: {
        _2 = &((*_1).1: proc_macro2::Literal);
        _0 = proc_macro2::Literal::span(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:52:1: 52:15>::subspan(_1: &StringLit, _2: R) -> proc_macro2::Span {
    debug self => _1;
    debug range => _2;
    let mut _0: proc_macro2::Span;
    let mut _3: std::option::Option<proc_macro2::Span>;
    let mut _4: &proc_macro2::Literal;
    let mut _5: {closure@core/codegen/src/proc_macro_ext.rs:68:46: 68:48};
    let mut _6: &&proc_macro_ext::StringLit;

    bb0: {
        _4 = &((*_1).1: proc_macro2::Literal);
        _3 = proc_macro2::Literal::subspan::<R>(move _4, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_1;
        _5 = {closure@core/codegen/src/proc_macro_ext.rs:68:46: 68:48} { self: move _6 };
        _0 = Option::<proc_macro2::Span>::unwrap_or_else::<{closure@core/codegen/src/proc_macro_ext.rs:68:46: 68:48}>(move _3, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:52:1: 52:15>::subspan::{closure#0}(_1: {closure@core/codegen/src/proc_macro_ext.rs:68:46: 68:48}) -> proc_macro2::Span {
    debug self => (*(_1.0: &&proc_macro_ext::StringLit));
    let mut _0: proc_macro2::Span;
    let mut _2: &&proc_macro_ext::StringLit;
    let mut _3: &proc_macro_ext::StringLit;

    bb0: {
        _2 = deref_copy (_1.0: &&proc_macro_ext::StringLit);
        _3 = deref_copy (*_2);
        _0 = StringLit::span(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:72:1: 72:37>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<StringLit, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro_ext::StringLit, syn::Error>;
    let _2: syn::LitStr;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::LitStr>;
    let mut _4: std::result::Result<syn::LitStr, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: syn::LitStr;
    let mut _8: proc_macro_ext::StringLit;
    let mut _9: std::string::String;
    let mut _10: &syn::LitStr;
    let mut _11: proc_macro2::Span;
    let mut _12: &syn::LitStr;
    let mut _13: bool;
    scope 1 {
        debug lit => _2;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _13 = const false;
        _4 = ParseBuffer::<'_>::parse::<LitStr>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<LitStr, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: syn::LitStr);
        _2 = move _7;
        _10 = &_2;
        _9 = LitStr::value(move _10) -> [return: bb6, unwind: bb10];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<StringLit, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb9, unwind continue];
    }

    bb6: {
        _13 = const true;
        _12 = &_2;
        _11 = LitStr::span(move _12) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _13 = const false;
        _8 = StringLit::new::<std::string::String>(move _9, move _11) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _13 = const false;
        _0 = std::result::Result::<StringLit, syn::Error>::Ok(move _8);
        drop(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_9) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_13) -> [0: bb10, otherwise: bb12];
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:79:1: 79:36>::from_meta(_1: &devise::MetaItem) -> std::result::Result<StringLit, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<proc_macro_ext::StringLit, devise::Diagnostic>;
    let mut _2: proc_macro_ext::StringLit;
    let mut _3: std::string::String;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::string::String>;
    let mut _5: std::result::Result<std::string::String, devise::Diagnostic>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _8: std::string::String;
    let mut _9: proc_macro2::Span;
    let mut _10: bool;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _10 = const false;
        _5 = <std::string::String as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <std::result::Result<std::string::String, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: std::string::String);
        _10 = const true;
        _3 = move _8;
        _9 = devise::MetaItem::value_span(_1) -> [return: bb7, unwind: bb12];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<StringLit, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = const false;
        goto -> bb9;
    }

    bb7: {
        _10 = const false;
        _2 = StringLit::new::<std::string::String>(move _3, move _9) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _10 = const false;
        _0 = std::result::Result::<StringLit, devise::Diagnostic>::Ok(move _2);
        goto -> bb9;
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        resume;
    }

    bb11 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        switchInt(_10) -> [0: bb10, otherwise: bb11];
    }
}

fn proc_macro_ext::<impl at core/codegen/src/proc_macro_ext.rs:85:1: 85:35>::deref(_1: &StringLit) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &std::string::String;

    bb0: {
        _2 = &((*_1).0: std::string::String);
        _0 = <std::string::String as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:10:10: 10:15>::fmt(_1: &FieldName, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &name::Name;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&name::Name;
    let _8: &name::Name;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&name::Name;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Uncased).0: name::Name);
        _9 = const "Uncased";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Cased).0: name::Name);
        _5 = const "Cased";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const form_field::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta(_1: &devise::MetaItem) -> std::result::Result<form_field::FieldAttr, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<derive::form_field::FieldAttr, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _13: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _14: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _16: std::option::Option<&devise::MetaItem>;
    let mut _17: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _18: isize;
    let mut _22: std::option::Option<&proc_macro2::Ident>;
    let mut _23: isize;
    let mut _25: devise::Diagnostic;
    let mut _26: bool;
    let mut _27: &&proc_macro2::Ident;
    let mut _28: bool;
    let mut _29: &std::option::Option<std::option::Option<derive::form_field::FieldName>>;
    let mut _30: devise::Diagnostic;
    let mut _32: std::fmt::Arguments<'_>;
    let mut _33: &[&str];
    let mut _34: &[core::fmt::rt::Argument<'_>];
    let _35: &[core::fmt::rt::Argument<'_>; 0];
    let _36: [core::fmt::rt::Argument<'_>; 0];
    let mut _37: std::option::Option<std::option::Option<derive::form_field::FieldName>>;
    let mut _38: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<derive::form_field::FieldName>>;
    let mut _39: std::result::Result<std::option::Option<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _40: isize;
    let mut _43: bool;
    let mut _44: &&proc_macro2::Ident;
    let mut _45: bool;
    let mut _46: &std::option::Option<std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _47: devise::Diagnostic;
    let mut _49: std::fmt::Arguments<'_>;
    let mut _50: &[&str];
    let mut _51: &[core::fmt::rt::Argument<'_>];
    let _52: &[core::fmt::rt::Argument<'_>; 0];
    let _53: [core::fmt::rt::Argument<'_>; 0];
    let mut _54: std::option::Option<std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _55: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _56: std::result::Result<std::option::Option<devise::SpanWrapped<syn::Expr>>, devise::Diagnostic>;
    let mut _57: isize;
    let mut _60: bool;
    let mut _61: &&proc_macro2::Ident;
    let mut _62: bool;
    let mut _63: &std::option::Option<std::option::Option<syn::Expr>>;
    let mut _64: devise::Diagnostic;
    let mut _66: std::fmt::Arguments<'_>;
    let mut _67: &[&str];
    let mut _68: &[core::fmt::rt::Argument<'_>];
    let _69: &[core::fmt::rt::Argument<'_>; 0];
    let _70: [core::fmt::rt::Argument<'_>; 0];
    let mut _71: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _72: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<syn::Expr>>;
    let mut _73: std::result::Result<std::option::Option<syn::Expr>, devise::Diagnostic>;
    let mut _74: isize;
    let mut _77: bool;
    let mut _78: &&proc_macro2::Ident;
    let mut _79: bool;
    let mut _80: &std::option::Option<std::option::Option<syn::Expr>>;
    let mut _81: devise::Diagnostic;
    let mut _83: std::fmt::Arguments<'_>;
    let mut _84: &[&str];
    let mut _85: &[core::fmt::rt::Argument<'_>];
    let _86: &[core::fmt::rt::Argument<'_>; 0];
    let _87: [core::fmt::rt::Argument<'_>; 0];
    let mut _88: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _89: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<syn::Expr>>;
    let mut _90: std::result::Result<std::option::Option<syn::Expr>, devise::Diagnostic>;
    let mut _91: isize;
    let mut _95: std::fmt::Arguments<'_>;
    let mut _96: &[&str];
    let mut _97: &[core::fmt::rt::Argument<'_>];
    let _98: &[core::fmt::rt::Argument<'_>; 1];
    let _99: [core::fmt::rt::Argument<'_>; 1];
    let mut _100: core::fmt::rt::Argument<'_>;
    let _101: &&proc_macro2::Ident;
    let mut _102: devise::Diagnostic;
    let mut _103: derive::form_field::FieldAttr;
    let mut _104: std::option::Option<derive::form_field::FieldName>;
    let mut _105: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<derive::form_field::FieldName>>;
    let mut _106: std::result::Result<std::option::Option<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _107: std::option::Option<std::option::Option<derive::form_field::FieldName>>;
    let mut _108: std::option::Option<std::option::Option<derive::form_field::FieldName>>;
    let mut _109: {closure@core/codegen/src/derive/form_field.rs:18:5: 18:8};
    let mut _110: &proc_macro2::Span;
    let mut _111: isize;
    let mut _114: std::option::Option<devise::SpanWrapped<syn::Expr>>;
    let mut _115: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _116: std::result::Result<std::option::Option<devise::SpanWrapped<syn::Expr>>, devise::Diagnostic>;
    let mut _117: std::option::Option<std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _118: std::option::Option<std::option::Option<devise::SpanWrapped<syn::Expr>>>;
    let mut _119: {closure@core/codegen/src/derive/form_field.rs:19:5: 19:8};
    let mut _120: &proc_macro2::Span;
    let mut _121: isize;
    let mut _124: std::option::Option<syn::Expr>;
    let mut _125: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<syn::Expr>>;
    let mut _126: std::result::Result<std::option::Option<syn::Expr>, devise::Diagnostic>;
    let mut _127: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _128: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _129: {closure@core/codegen/src/derive/form_field.rs:20:5: 20:8};
    let mut _130: &proc_macro2::Span;
    let mut _131: isize;
    let mut _134: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<syn::Expr>>;
    let mut _135: std::result::Result<std::option::Option<syn::Expr>, devise::Diagnostic>;
    let mut _136: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _137: std::option::Option<std::option::Option<syn::Expr>>;
    let mut _138: {closure@core/codegen/src/derive/form_field.rs:21:5: 21:8};
    let mut _139: &proc_macro2::Span;
    let mut _140: isize;
    let mut _152: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _153: bool;
    let mut _154: bool;
    let mut _155: bool;
    let mut _156: bool;
    let mut _157: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug name => _9;
                scope 9 {
                    debug validate => _10;
                    scope 11 {
                        debug default => _11;
                        scope 13 {
                            debug default_with => _12;
                            let mut _15: syn::punctuated::Iter<'_, devise::MetaItem>;
                            let _112: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _113: std::option::Option<derive::form_field::FieldName>;
                            let _122: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _123: std::option::Option<devise::SpanWrapped<syn::Expr>>;
                            let _132: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _133: std::option::Option<syn::Expr>;
                            let _141: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _142: std::option::Option<syn::Expr>;
                            scope 15 {
                                debug iter => _15;
                                let _19: &devise::MetaItem;
                                scope 16 {
                                    debug __meta => _19;
                                    let _20: proc_macro2::Span;
                                    scope 17 {
                                        debug __span => _20;
                                        let _21: &proc_macro2::Ident;
                                        let _24: &proc_macro2::Ident;
                                        scope 18 {
                                            debug __name => _21;
                                            let _31: std::string::String;
                                            let _41: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _42: std::option::Option<derive::form_field::FieldName>;
                                            let _48: std::string::String;
                                            let _58: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _59: std::option::Option<devise::SpanWrapped<syn::Expr>>;
                                            let _65: std::string::String;
                                            let _75: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _76: std::option::Option<syn::Expr>;
                                            let _82: std::string::String;
                                            let _92: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _93: std::option::Option<syn::Expr>;
                                            let _94: std::string::String;
                                            let mut _143: &[&str; 1];
                                            let mut _144: &[&str; 1];
                                            let mut _145: &[&str; 1];
                                            let mut _146: &[&str; 1];
                                            let mut _147: &[&str; 2];
                                            let mut _148: &&str;
                                            let mut _149: &&str;
                                            let mut _150: &&str;
                                            let mut _151: &&str;
                                            scope 20 {
                                                debug res => _31;
                                            }
                                            scope 21 {
                                                debug residual => _41;
                                                scope 22 {
                                                }
                                            }
                                            scope 23 {
                                                debug val => _42;
                                                scope 24 {
                                                }
                                            }
                                            scope 25 {
                                                debug res => _48;
                                            }
                                            scope 26 {
                                                debug residual => _58;
                                                scope 27 {
                                                }
                                            }
                                            scope 28 {
                                                debug val => _59;
                                                scope 29 {
                                                }
                                            }
                                            scope 30 {
                                                debug res => _65;
                                            }
                                            scope 31 {
                                                debug residual => _75;
                                                scope 32 {
                                                }
                                            }
                                            scope 33 {
                                                debug val => _76;
                                                scope 34 {
                                                }
                                            }
                                            scope 35 {
                                                debug res => _82;
                                            }
                                            scope 36 {
                                                debug residual => _92;
                                                scope 37 {
                                                }
                                            }
                                            scope 38 {
                                                debug val => _93;
                                                scope 39 {
                                                }
                                            }
                                            scope 40 {
                                                debug __msg => _94;
                                            }
                                            scope 41 {
                                                debug res => _94;
                                            }
                                        }
                                        scope 19 {
                                            debug __ident => _24;
                                        }
                                    }
                                }
                            }
                            scope 42 {
                                debug residual => _112;
                                scope 43 {
                                }
                            }
                            scope 44 {
                                debug val => _113;
                                scope 45 {
                                }
                            }
                            scope 46 {
                                debug residual => _122;
                                scope 47 {
                                }
                            }
                            scope 48 {
                                debug val => _123;
                                scope 49 {
                                }
                            }
                            scope 50 {
                                debug residual => _132;
                                scope 51 {
                                }
                            }
                            scope 52 {
                                debug val => _133;
                                scope 53 {
                                }
                            }
                            scope 54 {
                                debug residual => _141;
                                scope 55 {
                                }
                            }
                            scope 56 {
                                debug val => _142;
                                scope 57 {
                                }
                            }
                        }
                        scope 14 {
                            let mut _12: std::option::Option<std::option::Option<syn::Expr>>;
                        }
                    }
                    scope 12 {
                        let mut _11: std::option::Option<std::option::Option<syn::Expr>>;
                    }
                }
                scope 10 {
                    let mut _10: std::option::Option<std::option::Option<devise::SpanWrapped<syn::Expr>>>;
                }
            }
            scope 8 {
                let mut _9: std::option::Option<std::option::Option<derive::form_field::FieldName>>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _157 = const false;
        _156 = const false;
        _155 = const false;
        _154 = const false;
        _153 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _152 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_152 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _157 = const true;
        _3 = move _8;
        _156 = const true;
        _9 = Option::<Option<FieldName>>::None;
        _155 = const true;
        _10 = Option::<Option<devise::SpanWrapped<syn::Expr>>>::None;
        _154 = const true;
        _11 = Option::<Option<syn::Expr>>::None;
        _153 = const true;
        _12 = Option::<Option<syn::Expr>>::None;
        _157 = const false;
        _14 = move _3;
        _13 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _14) -> [return: bb7, unwind: bb143];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb128, unwind continue];
    }

    bb7: {
        _15 = move _13;
        goto -> bb8;
    }

    bb8: {
        _17 = &mut _15;
        _16 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_17) -> [return: bb9, unwind: bb142];
    }

    bb9: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb11, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _19 = ((_16 as Some).0: &devise::MetaItem);
        _20 = <devise::MetaItem as devise::Spanned>::span(_19) -> [return: bb12, unwind: bb142];
    }

    bb11: {
        drop(_15) -> [return: bb85, unwind: bb143];
    }

    bb12: {
        _22 = devise::MetaItem::name(_19) -> [return: bb13, unwind: bb142];
    }

    bb13: {
        _23 = discriminant(_22);
        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb5];
    }

    bb14: {
        _25 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_20, const "expected key/value `key = value`") -> [return: bb16, unwind: bb142];
    }

    bb15: {
        _24 = ((_22 as Some).0: &proc_macro2::Ident);
        _21 = _24;
        _27 = &_21;
        _151 = const _;
        _26 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _27, _151) -> [return: bb17, unwind: bb142];
    }

    bb16: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _25);
        goto -> bb122;
    }

    bb17: {
        switchInt(move _26) -> [0: bb32, otherwise: bb18];
    }

    bb18: {
        _29 = &_9;
        _28 = Option::<Option<FieldName>>::is_some(move _29) -> [return: bb19, unwind: bb142];
    }

    bb19: {
        switchInt(move _28) -> [0: bb25, otherwise: bb20];
    }

    bb20: {
        _143 = const _;
        _33 = _143 as &[&str] (PointerCoercion(Unsize));
        _36 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb142];
    }

    bb21: {
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _32 = std::fmt::Arguments::<'_>::new_v1(move _33, move _34) -> [return: bb22, unwind: bb142];
    }

    bb22: {
        _31 = format(move _32) -> [return: bb23, unwind: bb142];
    }

    bb23: {
        _30 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_20, move _31) -> [return: bb24, unwind: bb142];
    }

    bb24: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _30);
        goto -> bb122;
    }

    bb25: {
        _39 = <Option<FieldName> as devise::FromMeta>::from_meta(_19) -> [return: bb26, unwind: bb142];
    }

    bb26: {
        _38 = <std::result::Result<Option<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _39) -> [return: bb27, unwind: bb142];
    }

    bb27: {
        _40 = discriminant(_38);
        switchInt(move _40) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        _42 = move ((_38 as Continue).0: std::option::Option<derive::form_field::FieldName>);
        _37 = Option::<Option<FieldName>>::Some(move _42);
        drop(_9) -> [return: bb30, unwind: bb31];
    }

    bb29: {
        _41 = move ((_38 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _41) -> [return: bb157, unwind: bb142];
    }

    bb30: {
        _156 = const true;
        _9 = move _37;
        goto -> bb8;
    }

    bb31 (cleanup): {
        _156 = const true;
        _9 = move _37;
        goto -> bb142;
    }

    bb32: {
        _44 = &_21;
        _150 = const _;
        _43 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _44, _150) -> [return: bb33, unwind: bb142];
    }

    bb33: {
        switchInt(move _43) -> [0: bb48, otherwise: bb34];
    }

    bb34: {
        _46 = &_10;
        _45 = Option::<Option<devise::SpanWrapped<syn::Expr>>>::is_some(move _46) -> [return: bb35, unwind: bb142];
    }

    bb35: {
        switchInt(move _45) -> [0: bb41, otherwise: bb36];
    }

    bb36: {
        _144 = const _;
        _50 = _144 as &[&str] (PointerCoercion(Unsize));
        _53 = core::fmt::rt::Argument::<'_>::none() -> [return: bb37, unwind: bb142];
    }

    bb37: {
        _52 = &_53;
        _51 = _52 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _49 = std::fmt::Arguments::<'_>::new_v1(move _50, move _51) -> [return: bb38, unwind: bb142];
    }

    bb38: {
        _48 = format(move _49) -> [return: bb39, unwind: bb142];
    }

    bb39: {
        _47 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_20, move _48) -> [return: bb40, unwind: bb142];
    }

    bb40: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _47);
        goto -> bb122;
    }

    bb41: {
        _56 = <Option<devise::SpanWrapped<syn::Expr>> as devise::FromMeta>::from_meta(_19) -> [return: bb42, unwind: bb142];
    }

    bb42: {
        _55 = <std::result::Result<Option<devise::SpanWrapped<syn::Expr>>, devise::Diagnostic> as std::ops::Try>::branch(move _56) -> [return: bb43, unwind: bb142];
    }

    bb43: {
        _57 = discriminant(_55);
        switchInt(move _57) -> [0: bb44, 1: bb45, otherwise: bb5];
    }

    bb44: {
        _59 = move ((_55 as Continue).0: std::option::Option<devise::SpanWrapped<syn::Expr>>);
        _54 = Option::<Option<devise::SpanWrapped<syn::Expr>>>::Some(move _59);
        drop(_10) -> [return: bb46, unwind: bb47];
    }

    bb45: {
        _58 = move ((_55 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _58) -> [return: bb158, unwind: bb142];
    }

    bb46: {
        _155 = const true;
        _10 = move _54;
        goto -> bb8;
    }

    bb47 (cleanup): {
        _155 = const true;
        _10 = move _54;
        goto -> bb142;
    }

    bb48: {
        _61 = &_21;
        _149 = const _;
        _60 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _61, _149) -> [return: bb49, unwind: bb142];
    }

    bb49: {
        switchInt(move _60) -> [0: bb64, otherwise: bb50];
    }

    bb50: {
        _63 = &_11;
        _62 = Option::<Option<syn::Expr>>::is_some(move _63) -> [return: bb51, unwind: bb142];
    }

    bb51: {
        switchInt(move _62) -> [0: bb57, otherwise: bb52];
    }

    bb52: {
        _145 = const _;
        _67 = _145 as &[&str] (PointerCoercion(Unsize));
        _70 = core::fmt::rt::Argument::<'_>::none() -> [return: bb53, unwind: bb142];
    }

    bb53: {
        _69 = &_70;
        _68 = _69 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _66 = std::fmt::Arguments::<'_>::new_v1(move _67, move _68) -> [return: bb54, unwind: bb142];
    }

    bb54: {
        _65 = format(move _66) -> [return: bb55, unwind: bb142];
    }

    bb55: {
        _64 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_20, move _65) -> [return: bb56, unwind: bb142];
    }

    bb56: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _64);
        goto -> bb122;
    }

    bb57: {
        _73 = <Option<syn::Expr> as devise::FromMeta>::from_meta(_19) -> [return: bb58, unwind: bb142];
    }

    bb58: {
        _72 = <std::result::Result<Option<syn::Expr>, devise::Diagnostic> as std::ops::Try>::branch(move _73) -> [return: bb59, unwind: bb142];
    }

    bb59: {
        _74 = discriminant(_72);
        switchInt(move _74) -> [0: bb60, 1: bb61, otherwise: bb5];
    }

    bb60: {
        _76 = move ((_72 as Continue).0: std::option::Option<syn::Expr>);
        _71 = Option::<Option<syn::Expr>>::Some(move _76);
        drop(_11) -> [return: bb62, unwind: bb63];
    }

    bb61: {
        _75 = move ((_72 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _75) -> [return: bb159, unwind: bb142];
    }

    bb62: {
        _154 = const true;
        _11 = move _71;
        goto -> bb8;
    }

    bb63 (cleanup): {
        _154 = const true;
        _11 = move _71;
        goto -> bb142;
    }

    bb64: {
        _78 = &_21;
        _148 = const _;
        _77 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _78, _148) -> [return: bb65, unwind: bb142];
    }

    bb65: {
        switchInt(move _77) -> [0: bb80, otherwise: bb66];
    }

    bb66: {
        _80 = &_12;
        _79 = Option::<Option<syn::Expr>>::is_some(move _80) -> [return: bb67, unwind: bb142];
    }

    bb67: {
        switchInt(move _79) -> [0: bb73, otherwise: bb68];
    }

    bb68: {
        _146 = const _;
        _84 = _146 as &[&str] (PointerCoercion(Unsize));
        _87 = core::fmt::rt::Argument::<'_>::none() -> [return: bb69, unwind: bb142];
    }

    bb69: {
        _86 = &_87;
        _85 = _86 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _83 = std::fmt::Arguments::<'_>::new_v1(move _84, move _85) -> [return: bb70, unwind: bb142];
    }

    bb70: {
        _82 = format(move _83) -> [return: bb71, unwind: bb142];
    }

    bb71: {
        _81 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_20, move _82) -> [return: bb72, unwind: bb142];
    }

    bb72: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _81);
        goto -> bb122;
    }

    bb73: {
        _90 = <Option<syn::Expr> as devise::FromMeta>::from_meta(_19) -> [return: bb74, unwind: bb142];
    }

    bb74: {
        _89 = <std::result::Result<Option<syn::Expr>, devise::Diagnostic> as std::ops::Try>::branch(move _90) -> [return: bb75, unwind: bb142];
    }

    bb75: {
        _91 = discriminant(_89);
        switchInt(move _91) -> [0: bb76, 1: bb77, otherwise: bb5];
    }

    bb76: {
        _93 = move ((_89 as Continue).0: std::option::Option<syn::Expr>);
        _88 = Option::<Option<syn::Expr>>::Some(move _93);
        drop(_12) -> [return: bb78, unwind: bb79];
    }

    bb77: {
        _92 = move ((_89 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _92) -> [return: bb160, unwind: bb142];
    }

    bb78: {
        _153 = const true;
        _12 = move _88;
        goto -> bb8;
    }

    bb79 (cleanup): {
        _153 = const true;
        _12 = move _88;
        goto -> bb142;
    }

    bb80: {
        _147 = const _;
        _96 = _147 as &[&str] (PointerCoercion(Unsize));
        _101 = &_21;
        _100 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_101) -> [return: bb81, unwind: bb142];
    }

    bb81: {
        _99 = [move _100];
        _98 = &_99;
        _97 = _98 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _95 = std::fmt::Arguments::<'_>::new_v1(move _96, move _97) -> [return: bb82, unwind: bb142];
    }

    bb82: {
        _94 = format(move _95) -> [return: bb83, unwind: bb142];
    }

    bb83: {
        _102 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_20, move _94) -> [return: bb84, unwind: bb142];
    }

    bb84: {
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Err(move _102);
        goto -> bb122;
    }

    bb85: {
        _156 = const false;
        _108 = move _9;
        _107 = Option::<Option<FieldName>>::or_else::<fn() -> Option<Option<FieldName>> {<Option<FieldName> as devise::FromMeta>::default}>(move _108, <Option<FieldName> as devise::FromMeta>::default) -> [return: bb86, unwind: bb143];
    }

    bb86: {
        _110 = &_2;
        _109 = {closure@core/codegen/src/derive/form_field.rs:18:5: 18:8} { __span: move _110 };
        _106 = Option::<Option<FieldName>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:18:5: 18:8}>(move _107, move _109) -> [return: bb87, unwind: bb143];
    }

    bb87: {
        _105 = <std::result::Result<Option<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _106) -> [return: bb88, unwind: bb143];
    }

    bb88: {
        _111 = discriminant(_105);
        switchInt(move _111) -> [0: bb89, 1: bb90, otherwise: bb5];
    }

    bb89: {
        _113 = move ((_105 as Continue).0: std::option::Option<derive::form_field::FieldName>);
        _104 = move _113;
        _155 = const false;
        _118 = move _10;
        _117 = Option::<Option<devise::SpanWrapped<syn::Expr>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<syn::Expr>>> {<Option<devise::SpanWrapped<syn::Expr>> as devise::FromMeta>::default}>(move _118, <Option<devise::SpanWrapped<syn::Expr>> as devise::FromMeta>::default) -> [return: bb92, unwind: bb139];
    }

    bb90: {
        _112 = move ((_105 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _112) -> [return: bb91, unwind: bb140];
    }

    bb91: {
        drop(_12) -> [return: bb119, unwind: bb141];
    }

    bb92: {
        _120 = &_2;
        _119 = {closure@core/codegen/src/derive/form_field.rs:19:5: 19:8} { __span: move _120 };
        _116 = Option::<Option<devise::SpanWrapped<syn::Expr>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:19:5: 19:8}>(move _117, move _119) -> [return: bb93, unwind: bb139];
    }

    bb93: {
        _115 = <std::result::Result<Option<devise::SpanWrapped<syn::Expr>>, devise::Diagnostic> as std::ops::Try>::branch(move _116) -> [return: bb94, unwind: bb139];
    }

    bb94: {
        _121 = discriminant(_115);
        switchInt(move _121) -> [0: bb95, 1: bb96, otherwise: bb5];
    }

    bb95: {
        _123 = move ((_115 as Continue).0: std::option::Option<devise::SpanWrapped<syn::Expr>>);
        _114 = move _123;
        _154 = const false;
        _128 = move _11;
        _127 = Option::<Option<syn::Expr>>::or_else::<fn() -> Option<Option<syn::Expr>> {<Option<syn::Expr> as devise::FromMeta>::default}>(move _128, <Option<syn::Expr> as devise::FromMeta>::default) -> [return: bb98, unwind: bb136];
    }

    bb96: {
        _122 = move ((_115 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _122) -> [return: bb97, unwind: bb137];
    }

    bb97: {
        drop(_104) -> [return: bb116, unwind: bb138];
    }

    bb98: {
        _130 = &_2;
        _129 = {closure@core/codegen/src/derive/form_field.rs:20:5: 20:8} { __span: move _130 };
        _126 = Option::<Option<syn::Expr>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:20:5: 20:8}>(move _127, move _129) -> [return: bb99, unwind: bb136];
    }

    bb99: {
        _125 = <std::result::Result<Option<syn::Expr>, devise::Diagnostic> as std::ops::Try>::branch(move _126) -> [return: bb100, unwind: bb136];
    }

    bb100: {
        _131 = discriminant(_125);
        switchInt(move _131) -> [0: bb101, 1: bb102, otherwise: bb5];
    }

    bb101: {
        _133 = move ((_125 as Continue).0: std::option::Option<syn::Expr>);
        _124 = move _133;
        _153 = const false;
        _137 = move _12;
        _136 = Option::<Option<syn::Expr>>::or_else::<fn() -> Option<Option<syn::Expr>> {<Option<syn::Expr> as devise::FromMeta>::default}>(move _137, <Option<syn::Expr> as devise::FromMeta>::default) -> [return: bb104, unwind: bb133];
    }

    bb102: {
        _132 = move ((_125 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _132) -> [return: bb103, unwind: bb134];
    }

    bb103: {
        drop(_114) -> [return: bb113, unwind: bb135];
    }

    bb104: {
        _139 = &_2;
        _138 = {closure@core/codegen/src/derive/form_field.rs:21:5: 21:8} { __span: move _139 };
        _135 = Option::<Option<syn::Expr>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:21:5: 21:8}>(move _136, move _138) -> [return: bb105, unwind: bb133];
    }

    bb105: {
        _134 = <std::result::Result<Option<syn::Expr>, devise::Diagnostic> as std::ops::Try>::branch(move _135) -> [return: bb106, unwind: bb133];
    }

    bb106: {
        _140 = discriminant(_134);
        switchInt(move _140) -> [0: bb107, 1: bb108, otherwise: bb5];
    }

    bb107: {
        _142 = move ((_134 as Continue).0: std::option::Option<syn::Expr>);
        _103 = form_field::FieldAttr { name: move _104, validate: move _114, default: move _124, default_with: move _142 };
        _0 = std::result::Result::<form_field::FieldAttr, devise::Diagnostic>::Ok(move _103);
        _153 = const false;
        _154 = const false;
        _155 = const false;
        _156 = const false;
        _157 = const false;
        goto -> bb129;
    }

    bb108: {
        _141 = move ((_134 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<form_field::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _141) -> [return: bb109, unwind: bb130];
    }

    bb109: {
        drop(_124) -> [return: bb110, unwind: bb131];
    }

    bb110: {
        drop(_114) -> [return: bb111, unwind: bb132];
    }

    bb111: {
        drop(_104) -> [return: bb112, unwind continue];
    }

    bb112: {
        _153 = const false;
        _154 = const false;
        _155 = const false;
        _156 = const false;
        _157 = const false;
        goto -> bb129;
    }

    bb113: {
        drop(_104) -> [return: bb114, unwind: bb148];
    }

    bb114: {
        drop(_12) -> [return: bb115, unwind continue];
    }

    bb115: {
        _153 = const false;
        _154 = const false;
        _155 = const false;
        _156 = const false;
        _157 = const false;
        goto -> bb129;
    }

    bb116: {
        drop(_12) -> [return: bb117, unwind: bb150];
    }

    bb117: {
        _153 = const false;
        drop(_11) -> [return: bb118, unwind continue];
    }

    bb118: {
        _154 = const false;
        _155 = const false;
        _156 = const false;
        _157 = const false;
        goto -> bb129;
    }

    bb119: {
        _153 = const false;
        drop(_11) -> [return: bb120, unwind: bb152];
    }

    bb120: {
        _154 = const false;
        drop(_10) -> [return: bb121, unwind continue];
    }

    bb121: {
        _155 = const false;
        _156 = const false;
        _157 = const false;
        goto -> bb129;
    }

    bb122: {
        drop(_15) -> [return: bb123, unwind: bb143];
    }

    bb123: {
        drop(_12) -> [return: bb124, unwind: bb144];
    }

    bb124: {
        _153 = const false;
        drop(_11) -> [return: bb125, unwind: bb145];
    }

    bb125: {
        _154 = const false;
        drop(_10) -> [return: bb126, unwind: bb154];
    }

    bb126: {
        _155 = const false;
        drop(_9) -> [return: bb127, unwind: bb156];
    }

    bb127: {
        _156 = const false;
        goto -> bb128;
    }

    bb128: {
        _157 = const false;
        goto -> bb129;
    }

    bb129: {
        return;
    }

    bb130 (cleanup): {
        drop(_124) -> [return: bb131, unwind terminate(cleanup)];
    }

    bb131 (cleanup): {
        drop(_114) -> [return: bb132, unwind terminate(cleanup)];
    }

    bb132 (cleanup): {
        drop(_104) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb133 (cleanup): {
        drop(_124) -> [return: bb134, unwind terminate(cleanup)];
    }

    bb134 (cleanup): {
        drop(_114) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb135 (cleanup): {
        drop(_104) -> [return: bb148, unwind terminate(cleanup)];
    }

    bb136 (cleanup): {
        drop(_114) -> [return: bb137, unwind terminate(cleanup)];
    }

    bb137 (cleanup): {
        drop(_104) -> [return: bb138, unwind terminate(cleanup)];
    }

    bb138 (cleanup): {
        drop(_12) -> [return: bb150, unwind terminate(cleanup)];
    }

    bb139 (cleanup): {
        drop(_104) -> [return: bb140, unwind terminate(cleanup)];
    }

    bb140 (cleanup): {
        drop(_12) -> [return: bb141, unwind terminate(cleanup)];
    }

    bb141 (cleanup): {
        drop(_11) -> [return: bb152, unwind terminate(cleanup)];
    }

    bb142 (cleanup): {
        drop(_15) -> [return: bb143, unwind terminate(cleanup)];
    }

    bb143 (cleanup): {
        drop(_12) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb144 (cleanup): {
        drop(_11) -> [return: bb145, unwind terminate(cleanup)];
    }

    bb145 (cleanup): {
        drop(_10) -> [return: bb154, unwind terminate(cleanup)];
    }

    bb146 (cleanup): {
        resume;
    }

    bb147 (cleanup): {
        drop(_12) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb148 (cleanup): {
        switchInt(_153) -> [0: bb146, otherwise: bb147];
    }

    bb149 (cleanup): {
        drop(_11) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb150 (cleanup): {
        switchInt(_154) -> [0: bb146, otherwise: bb149];
    }

    bb151 (cleanup): {
        drop(_10) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb152 (cleanup): {
        switchInt(_155) -> [0: bb146, otherwise: bb151];
    }

    bb153 (cleanup): {
        drop(_9) -> [return: bb156, unwind terminate(cleanup)];
    }

    bb154 (cleanup): {
        switchInt(_156) -> [0: bb156, otherwise: bb153];
    }

    bb155 (cleanup): {
        drop(_3) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb156 (cleanup): {
        switchInt(_157) -> [0: bb146, otherwise: bb155];
    }

    bb157: {
        goto -> bb122;
    }

    bb158: {
        goto -> bb122;
    }

    bb159: {
        goto -> bb122;
    }

    bb160: {
        goto -> bb122;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: name"];
        _0 = &_1;
        return;
    }
}

promoted[1] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: validate"];
        _0 = &_1;
        return;
    }
}

promoted[2] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: default"];
        _0 = &_1;
        return;
    }
}

promoted[3] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: default_with"];
        _0 = &_1;
        return;
    }
}

promoted[4] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[5] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "default_with";
        _0 = &_1;
        return;
    }
}

promoted[6] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "default";
        _0 = &_1;
        return;
    }
}

promoted[7] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "validate";
        _0 = &_1;
        return;
    }
}

promoted[8] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "name";
        _0 = &_1;
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#0}(_1: {closure@core/codegen/src/derive/form_field.rs:18:5: 18:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `name`"];
        _0 = &_1;
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#1}(_1: {closure@core/codegen/src/derive/form_field.rs:19:5: 19:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `validate`"];
        _0 = &_1;
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#2}(_1: {closure@core/codegen/src/derive/form_field.rs:20:5: 20:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#2}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `default`"];
        _0 = &_1;
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#3}(_1: {closure@core/codegen/src/derive/form_field.rs:21:5: 21:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:16:10: 16:18>::from_meta::{closure#3}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `default_with`"];
        _0 = &_1;
        return;
    }
}

const form_field::<impl at core/codegen/src/derive/form_field.rs:24:1: 24:15>::NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "field";
        return;
    }
}

const form_field::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta(_1: &devise::MetaItem) -> std::result::Result<VariantAttr, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<derive::form_field::VariantAttr, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _10: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _11: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _13: std::option::Option<&devise::MetaItem>;
    let mut _14: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _15: isize;
    let mut _19: std::option::Option<&proc_macro2::Ident>;
    let mut _20: isize;
    let mut _22: devise::Diagnostic;
    let mut _23: bool;
    let mut _24: &&proc_macro2::Ident;
    let mut _25: bool;
    let mut _26: &std::option::Option<name::Name>;
    let mut _27: devise::Diagnostic;
    let mut _29: std::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 0];
    let _33: [core::fmt::rt::Argument<'_>; 0];
    let mut _34: std::option::Option<name::Name>;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, name::Name>;
    let mut _36: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _37: isize;
    let mut _41: std::fmt::Arguments<'_>;
    let mut _42: &[&str];
    let mut _43: &[core::fmt::rt::Argument<'_>];
    let _44: &[core::fmt::rt::Argument<'_>; 1];
    let _45: [core::fmt::rt::Argument<'_>; 1];
    let mut _46: core::fmt::rt::Argument<'_>;
    let _47: &&proc_macro2::Ident;
    let mut _48: devise::Diagnostic;
    let mut _49: derive::form_field::VariantAttr;
    let mut _50: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, name::Name>;
    let mut _51: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _52: std::option::Option<name::Name>;
    let mut _53: std::option::Option<name::Name>;
    let mut _54: {closure@core/codegen/src/derive/form_field.rs:38:5: 38:8};
    let mut _55: &proc_macro2::Span;
    let mut _56: isize;
    let mut _62: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _63: bool;
    let mut _64: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug value => _9;
                let mut _12: syn::punctuated::Iter<'_, devise::MetaItem>;
                let _57: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _58: name::Name;
                scope 9 {
                    debug iter => _12;
                    let _16: &devise::MetaItem;
                    scope 10 {
                        debug __meta => _16;
                        let _17: proc_macro2::Span;
                        scope 11 {
                            debug __span => _17;
                            let _18: &proc_macro2::Ident;
                            let _21: &proc_macro2::Ident;
                            scope 12 {
                                debug __name => _18;
                                let _28: std::string::String;
                                let _38: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _39: name::Name;
                                let _40: std::string::String;
                                let mut _59: &[&str; 1];
                                let mut _60: &[&str; 2];
                                let mut _61: &&str;
                                scope 14 {
                                    debug res => _28;
                                }
                                scope 15 {
                                    debug residual => _38;
                                    scope 16 {
                                    }
                                }
                                scope 17 {
                                    debug val => _39;
                                    scope 18 {
                                    }
                                }
                                scope 19 {
                                    debug __msg => _40;
                                }
                                scope 20 {
                                    debug res => _40;
                                }
                            }
                            scope 13 {
                                debug __ident => _21;
                            }
                        }
                    }
                }
                scope 21 {
                    debug residual => _57;
                    scope 22 {
                    }
                }
                scope 23 {
                    debug val => _58;
                    scope 24 {
                    }
                }
            }
            scope 8 {
                let mut _9: std::option::Option<name::Name>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _64 = const false;
        _63 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _62 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_62 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _64 = const true;
        _3 = move _8;
        _63 = const true;
        _9 = Option::<name::Name>::None;
        _64 = const false;
        _11 = move _3;
        _10 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _11) -> [return: bb7, unwind: bb53];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<VariantAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb47, unwind continue];
    }

    bb7: {
        _12 = move _10;
        goto -> bb8;
    }

    bb8: {
        _14 = &mut _12;
        _13 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_14) -> [return: bb9, unwind: bb49];
    }

    bb9: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb11, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _16 = ((_13 as Some).0: &devise::MetaItem);
        _17 = <devise::MetaItem as devise::Spanned>::span(_16) -> [return: bb12, unwind: bb49];
    }

    bb11: {
        drop(_12) -> [return: bb37, unwind: bb53];
    }

    bb12: {
        _19 = devise::MetaItem::name(_16) -> [return: bb13, unwind: bb49];
    }

    bb13: {
        _20 = discriminant(_19);
        switchInt(move _20) -> [0: bb14, 1: bb15, otherwise: bb5];
    }

    bb14: {
        _22 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_17, const "expected key/value `key = value`") -> [return: bb16, unwind: bb49];
    }

    bb15: {
        _21 = ((_19 as Some).0: &proc_macro2::Ident);
        _18 = _21;
        _24 = &_18;
        _61 = const _;
        _23 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _24, _61) -> [return: bb17, unwind: bb49];
    }

    bb16: {
        _0 = std::result::Result::<VariantAttr, devise::Diagnostic>::Err(move _22);
        goto -> bb44;
    }

    bb17: {
        switchInt(move _23) -> [0: bb32, otherwise: bb18];
    }

    bb18: {
        _26 = &_9;
        _25 = Option::<name::Name>::is_some(move _26) -> [return: bb19, unwind: bb49];
    }

    bb19: {
        switchInt(move _25) -> [0: bb25, otherwise: bb20];
    }

    bb20: {
        _59 = const _;
        _30 = _59 as &[&str] (PointerCoercion(Unsize));
        _33 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb49];
    }

    bb21: {
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _29 = std::fmt::Arguments::<'_>::new_v1(move _30, move _31) -> [return: bb22, unwind: bb49];
    }

    bb22: {
        _28 = format(move _29) -> [return: bb23, unwind: bb49];
    }

    bb23: {
        _27 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_17, move _28) -> [return: bb24, unwind: bb49];
    }

    bb24: {
        _0 = std::result::Result::<VariantAttr, devise::Diagnostic>::Err(move _27);
        goto -> bb44;
    }

    bb25: {
        _36 = <name::Name as devise::FromMeta>::from_meta(_16) -> [return: bb26, unwind: bb49];
    }

    bb26: {
        _35 = <std::result::Result<name::Name, devise::Diagnostic> as std::ops::Try>::branch(move _36) -> [return: bb27, unwind: bb49];
    }

    bb27: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        _39 = move ((_35 as Continue).0: name::Name);
        _34 = Option::<name::Name>::Some(move _39);
        drop(_9) -> [return: bb30, unwind: bb31];
    }

    bb29: {
        _38 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<VariantAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _38) -> [return: bb55, unwind: bb49];
    }

    bb30: {
        _63 = const true;
        _9 = move _34;
        goto -> bb8;
    }

    bb31 (cleanup): {
        _63 = const true;
        _9 = move _34;
        goto -> bb49;
    }

    bb32: {
        _60 = const _;
        _42 = _60 as &[&str] (PointerCoercion(Unsize));
        _47 = &_18;
        _46 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_47) -> [return: bb33, unwind: bb49];
    }

    bb33: {
        _45 = [move _46];
        _44 = &_45;
        _43 = _44 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _41 = std::fmt::Arguments::<'_>::new_v1(move _42, move _43) -> [return: bb34, unwind: bb49];
    }

    bb34: {
        _40 = format(move _41) -> [return: bb35, unwind: bb49];
    }

    bb35: {
        _48 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_17, move _40) -> [return: bb36, unwind: bb49];
    }

    bb36: {
        _0 = std::result::Result::<VariantAttr, devise::Diagnostic>::Err(move _48);
        goto -> bb44;
    }

    bb37: {
        _63 = const false;
        _53 = move _9;
        _52 = Option::<name::Name>::or_else::<fn() -> Option<name::Name> {<name::Name as devise::FromMeta>::default}>(move _53, <name::Name as devise::FromMeta>::default) -> [return: bb38, unwind: bb53];
    }

    bb38: {
        _55 = &_2;
        _54 = {closure@core/codegen/src/derive/form_field.rs:38:5: 38:8} { __span: move _55 };
        _51 = Option::<name::Name>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:38:5: 38:8}>(move _52, move _54) -> [return: bb39, unwind: bb53];
    }

    bb39: {
        _50 = <std::result::Result<name::Name, devise::Diagnostic> as std::ops::Try>::branch(move _51) -> [return: bb40, unwind: bb53];
    }

    bb40: {
        _56 = discriminant(_50);
        switchInt(move _56) -> [0: bb41, 1: bb42, otherwise: bb5];
    }

    bb41: {
        _58 = move ((_50 as Continue).0: name::Name);
        _49 = VariantAttr { value: move _58 };
        _0 = std::result::Result::<VariantAttr, devise::Diagnostic>::Ok(move _49);
        _63 = const false;
        _64 = const false;
        goto -> bb48;
    }

    bb42: {
        _57 = move ((_50 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<VariantAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _57) -> [return: bb43, unwind continue];
    }

    bb43: {
        _63 = const false;
        _64 = const false;
        goto -> bb48;
    }

    bb44: {
        drop(_12) -> [return: bb45, unwind: bb53];
    }

    bb45: {
        drop(_9) -> [return: bb46, unwind: bb50];
    }

    bb46: {
        _63 = const false;
        goto -> bb47;
    }

    bb47: {
        _64 = const false;
        goto -> bb48;
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_12) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        switchInt(_64) -> [0: bb51, otherwise: bb54];
    }

    bb51 (cleanup): {
        resume;
    }

    bb52 (cleanup): {
        drop(_9) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        switchInt(_63) -> [0: bb50, otherwise: bb52];
    }

    bb54 (cleanup): {
        drop(_3) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb55: {
        goto -> bb44;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: value"];
        _0 = &_1;
        return;
    }
}

promoted[1] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[2] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "value";
        _0 = &_1;
        return;
    }
}

fn form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta::{closure#0}(_1: {closure@core/codegen/src/derive/form_field.rs:38:5: 38:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::_::<impl at core/codegen/src/derive/form_field.rs:36:10: 36:18>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `value`"];
        _0 = &_1;
        return;
    }
}

const form_field::<impl at core/codegen/src/derive/form_field.rs:41:1: 41:17>::NAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "field";
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:50:1: 50:32>::first_form_field_value(_1: &Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<FieldName, devise::Diagnostic> {
    debug self => _1;
    let mut _0: std::result::Result<derive::form_field::FieldName, devise::Diagnostic>;
    let _2: std::option::Option<derive::form_field::VariantAttr>;
    let mut _3: &mut std::vec::IntoIter<derive::form_field::VariantAttr>;
    let mut _4: std::vec::IntoIter<derive::form_field::VariantAttr>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::VariantAttr>>;
    let mut _6: std::result::Result<std::vec::Vec<derive::form_field::VariantAttr>, devise::Diagnostic>;
    let _7: &str;
    let _8: &[syn::Attribute];
    let _9: &std::vec::Vec<syn::Attribute>;
    let _10: &syn::Variant;
    let mut _11: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _14: std::vec::Vec<derive::form_field::VariantAttr>;
    let mut _15: derive::form_field::FieldName;
    let mut _16: std::option::Option<derive::form_field::VariantAttr>;
    let mut _17: {closure@core/codegen/src/derive/form_field.rs:57:17: 57:19};
    let mut _18: &&devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _19: bool;
    scope 1 {
        debug first => _2;
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _19 = const false;
        _7 = const _;
        _11 = _1;
        _10 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as std::ops::Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &((*_10).0: std::vec::Vec<syn::Attribute>);
        _8 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = <VariantAttr as devise::FromMeta>::from_attrs(_7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::result::Result<Vec<VariantAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _14 = move ((_5 as Continue).0: std::vec::Vec<derive::form_field::VariantAttr>);
        _4 = <Vec<VariantAttr> as IntoIterator>::into_iter(move _14) -> [return: bb9, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<FieldName, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _19 = const false;
        goto -> bb12;
    }

    bb9: {
        _3 = &mut _4;
        _2 = <std::vec::IntoIter<VariantAttr> as Iterator>::next(move _3) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        _19 = const true;
        drop(_4) -> [return: bb15, unwind: bb17];
    }

    bb11: {
        _0 = std::result::Result::<FieldName, devise::Diagnostic>::Ok(move _15);
        _19 = const false;
        goto -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_4) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        _19 = const false;
        _16 = move _2;
        _18 = &_1;
        _17 = {closure@core/codegen/src/derive/form_field.rs:57:17: 57:19} { self: move _18 };
        _15 = Option::<VariantAttr>::map_or_else::<FieldName, {closure@core/codegen/src/derive/form_field.rs:57:17: 57:19}, {closure@core/codegen/src/derive/form_field.rs:58:17: 58:23}>(move _16, move _17, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:58:17: 58:23}) -> [return: bb11, unwind: bb17];
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_19) -> [0: bb14, otherwise: bb16];
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:50:1: 50:32>::first_form_field_value::{closure#0}(_1: {closure@core/codegen/src/derive/form_field.rs:57:17: 57:19}) -> FieldName {
    debug self => (*(_1.0: &&devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>));
    let mut _0: derive::form_field::FieldName;
    let mut _2: name::Name;
    let mut _3: &proc_macro2::Ident;
    let _4: &syn::Variant;
    let mut _5: &&devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _6: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;

    bb0: {
        _5 = deref_copy (_1.0: &&devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>);
        _6 = deref_copy (*_5);
        _4 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as std::ops::Deref>::deref(_6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &((*_4).1: proc_macro2::Ident);
        _2 = <name::Name as From<&proc_macro2::Ident>>::from(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = FieldName::Uncased(move _2);
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:50:1: 50:32>::first_form_field_value::{closure#1}(_1: {closure@core/codegen/src/derive/form_field.rs:58:17: 58:23}, _2: VariantAttr) -> FieldName {
    debug attr => _2;
    let mut _0: derive::form_field::FieldName;
    let mut _3: name::Name;

    bb0: {
        _3 = move (_2.0: name::Name);
        _0 = FieldName::Uncased(move _3);
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:50:1: 50:32>::form_field_values(_1: &Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<Vec<FieldName>, devise::Diagnostic> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let _2: std::vec::Vec<derive::form_field::FieldName>;
    let mut _3: std::iter::Map<std::vec::IntoIter<derive::form_field::VariantAttr>, {closure@core/codegen/src/derive/form_field.rs:64:18: 64:24}>;
    let mut _4: std::vec::IntoIter<derive::form_field::VariantAttr>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::VariantAttr>>;
    let mut _6: std::result::Result<std::vec::Vec<derive::form_field::VariantAttr>, devise::Diagnostic>;
    let _7: &str;
    let _8: &[syn::Attribute];
    let _9: &std::vec::Vec<syn::Attribute>;
    let _10: &syn::Variant;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _13: std::vec::Vec<derive::form_field::VariantAttr>;
    let mut _14: bool;
    let mut _15: &std::vec::Vec<derive::form_field::FieldName>;
    let mut _16: std::vec::Vec<derive::form_field::FieldName>;
    let mut _17: std::boxed::Box<[derive::form_field::FieldName]>;
    let mut _18: std::boxed::Box<[derive::form_field::FieldName; 1]>;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: *mut u8;
    let mut _22: std::boxed::Box<[derive::form_field::FieldName; 1]>;
    let mut _23: derive::form_field::FieldName;
    let mut _24: name::Name;
    let mut _25: &proc_macro2::Ident;
    let _26: &syn::Variant;
    let mut _27: std::vec::Vec<derive::form_field::FieldName>;
    let mut _28: &mut std::boxed::Box<[derive::form_field::FieldName; 1]>;
    let mut _29: ();
    let mut _30: *const [derive::form_field::FieldName; 1];
    scope 1 {
        debug attr_values => _2;
        let mut _31: *const ();
        let mut _32: usize;
        let mut _33: usize;
        let mut _34: usize;
        let mut _35: usize;
        let mut _36: bool;
        scope 6 {
        }
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }

    bb0: {
        _7 = const _;
        _10 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &((*_10).0: std::vec::Vec<syn::Attribute>);
        _8 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = <VariantAttr as devise::FromMeta>::from_attrs(_7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::result::Result<Vec<VariantAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_5);
        switchInt(move _11) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = move ((_5 as Continue).0: std::vec::Vec<derive::form_field::VariantAttr>);
        _4 = <Vec<VariantAttr> as IntoIterator>::into_iter(move _13) -> [return: bb8, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _12 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _12) -> [return: bb18, unwind continue];
    }

    bb8: {
        _3 = <std::vec::IntoIter<VariantAttr> as Iterator>::map::<FieldName, {closure@core/codegen/src/derive/form_field.rs:64:18: 64:24}>(move _4, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:64:18: 64:24}) -> [return: bb9, unwind continue];
    }

    bb9: {
        _2 = <Map<std::vec::IntoIter<VariantAttr>, {closure@core/codegen/src/derive/form_field.rs:64:18: 64:24}> as Iterator>::collect::<Vec<FieldName>>(move _3) -> [return: bb10, unwind continue];
    }

    bb10: {
        _15 = &_2;
        _14 = Vec::<FieldName>::is_empty(move _15) -> [return: bb11, unwind: bb19];
    }

    bb11: {
        switchInt(move _14) -> [0: bb17, otherwise: bb12];
    }

    bb12: {
        _19 = SizeOf([derive::form_field::FieldName; 1]);
        _20 = AlignOf([derive::form_field::FieldName; 1]);
        _21 = alloc::alloc::exchange_malloc(move _19, move _20) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _22 = ShallowInitBox(move _21, [derive::form_field::FieldName; 1]);
        _26 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as std::ops::Deref>::deref(_1) -> [return: bb14, unwind: bb21];
    }

    bb14: {
        _25 = &((*_26).1: proc_macro2::Ident);
        _24 = <name::Name as From<&proc_macro2::Ident>>::from(move _25) -> [return: bb15, unwind: bb21];
    }

    bb15: {
        _23 = FieldName::Uncased(move _24);
        _30 = (((_22.0: std::ptr::Unique<[derive::form_field::FieldName; 1]>).0: std::ptr::NonNull<[derive::form_field::FieldName; 1]>).0: *const [derive::form_field::FieldName; 1]);
        _31 = _30 as *const () (PtrToPtr);
        _32 = _31 as usize (Transmute);
        _33 = AlignOf([derive::form_field::FieldName; 1]);
        _34 = Sub(_33, const 1_usize);
        _35 = BitAnd(_32, _34);
        _36 = Eq(_35, const 0_usize);
        assert(_36, "misaligned pointer dereference: address must be a multiple of {} but is {}", _33, _32) -> [success: bb22, unwind unreachable];
    }

    bb16: {
        _0 = std::result::Result::<Vec<FieldName>, devise::Diagnostic>::Ok(move _16);
        drop(_2) -> [return: bb18, unwind continue];
    }

    bb17: {
        _27 = move _2;
        _0 = std::result::Result::<Vec<FieldName>, devise::Diagnostic>::Ok(move _27);
        goto -> bb18;
    }

    bb18: {
        return;
    }

    bb19 (cleanup): {
        drop(_2) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21 (cleanup): {
        _28 = &mut _22;
        _29 = <std::boxed::Box<[FieldName; 1]> as Drop>::drop(move _28) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb22: {
        (*_30) = [move _23];
        _18 = move _22;
        _17 = move _18 as std::boxed::Box<[derive::form_field::FieldName]> (PointerCoercion(Unsize));
        _16 = slice::<impl [FieldName]>::into_vec::<std::alloc::Global>(move _17) -> [return: bb16, unwind: bb19];
    }

    bb23 (cleanup): {
        goto -> bb19;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:50:1: 50:32>::form_field_values::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:64:18: 64:24}, _2: VariantAttr) -> FieldName {
    debug attr => _2;
    let mut _0: derive::form_field::FieldName;
    let mut _3: name::Name;

    bb0: {
        _3 = move (_2.0: name::Name);
        _0 = FieldName::Uncased(move _3);
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta(_1: &devise::MetaItem) -> std::result::Result<FieldName, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<derive::form_field::FieldName, devise::Diagnostic>;
    let _2: derive::form_field::FieldName;
    let mut _3: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _4: isize;
    let _5: name::Name;
    let _6: syn::Expr;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::Expr>;
    let mut _8: std::result::Result<syn::Expr, devise::Diagnostic>;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _11: syn::Expr;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, devise::MetaItem>;
    let mut _14: std::result::Result<devise::MetaItem, syn::Error>;
    let mut _15: proc_macro2::TokenStream;
    let _17: ();
    let _18: &syn::Expr;
    let mut _19: &mut proc_macro2::TokenStream;
    let mut _20: isize;
    let mut _23: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, <derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner>;
    let mut _24: std::result::Result<<derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>;
    let _25: &devise::MetaItem;
    let mut _26: isize;
    let mut _29: name::Name;
    let mut _30: bool;
    let _31: &str;
    let _32: &name::Name;
    let mut _33: &derive::form_field::FieldName;
    let _35: &[std::string::String];
    let mut _36: &std::vec::Vec<std::string::String>;
    let _37: std::vec::Vec<std::string::String>;
    let mut _38: std::iter::Map<std::slice::Iter<'_, char>, {closure@core/codegen/src/derive/form_field.rs:108:22: 108:25}>;
    let mut _39: std::slice::Iter<'_, char>;
    let _40: &[char];
    let _41: &str;
    let mut _42: devise::Diagnostic;
    let mut _43: devise::Diagnostic;
    let mut _44: proc_macro2::Span;
    let mut _46: std::fmt::Arguments<'_>;
    let mut _47: &[&str];
    let mut _48: &[core::fmt::rt::Argument<'_>];
    let _49: &[core::fmt::rt::Argument<'_>; 1];
    let _50: [core::fmt::rt::Argument<'_>; 1];
    let mut _51: core::fmt::rt::Argument<'_>;
    let _52: &std::string::String;
    let mut _53: derive::form_field::FieldName;
    let mut _55: bool;
    let mut _56: isize;
    let mut _57: isize;
    let mut _58: isize;
    scope 1 {
        debug field_name => _2;
        let _34: std::string::String;
        scope 19 {
            debug chars => _34;
            let _45: std::string::String;
            let mut _54: &[&str; 1];
            scope 20 {
                debug res => _45;
            }
        }
    }
    scope 2 {
        debug name => _5;
    }
    scope 3 {
        debug expr => _6;
        let _12: devise::MetaItem;
        let mut _16: proc_macro2::TokenStream;
        let _21: std::result::Result<std::convert::Infallible, syn::Error>;
        let _22: devise::MetaItem;
        scope 8 {
            debug item => _12;
            let _27: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
            let _28: <derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner;
            scope 14 {
                debug inner => _28;
            }
            scope 15 {
                debug residual => _27;
                scope 16 {
                }
            }
            scope 17 {
                debug val => _28;
                scope 18 {
                }
            }
        }
        scope 9 {
            debug _s => _16;
        }
        scope 10 {
            debug residual => _21;
            scope 11 {
            }
        }
        scope 12 {
            debug val => _22;
            scope 13 {
            }
        }
    }
    scope 4 {
        debug residual => _10;
        scope 5 {
        }
    }
    scope 6 {
        debug val => _11;
        scope 7 {
        }
    }

    bb0: {
        _55 = const false;
        _3 = <name::Name as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _8 = devise::MetaItem::expr(_1) -> [return: bb5, unwind: bb56];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Ok).0: name::Name);
        _2 = FieldName::Cased(move _5);
        goto -> bb51;
    }

    bb5: {
        _7 = <std::result::Result<syn::Expr, devise::Diagnostic> as std::ops::Try>::branch(move _8) -> [return: bb6, unwind: bb56];
    }

    bb6: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb7, 1: bb8, otherwise: bb3];
    }

    bb7: {
        _11 = move ((_7 as Continue).0: syn::Expr);
        _6 = move _11;
        _16 = TokenStream2::new() -> [return: bb9, unwind: bb47];
    }

    bb8: {
        _10 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<FieldName, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _10) -> [return: bb57, unwind: bb56];
    }

    bb9: {
        _18 = &_6;
        _19 = &mut _16;
        _17 = <syn::Expr as ToTokens>::to_tokens(_18, _19) -> [return: bb10, unwind: bb46];
    }

    bb10: {
        _15 = move _16;
        _14 = syn::parse2::<devise::MetaItem>(move _15) -> [return: bb11, unwind: bb47];
    }

    bb11: {
        _13 = <std::result::Result<devise::MetaItem, syn::Error> as std::ops::Try>::branch(move _14) -> [return: bb12, unwind: bb47];
    }

    bb12: {
        _20 = discriminant(_13);
        switchInt(move _20) -> [0: bb13, 1: bb14, otherwise: bb3];
    }

    bb13: {
        _22 = move ((_13 as Continue).0: devise::MetaItem);
        _12 = move _22;
        _25 = &_12;
        _24 = <<FieldName as devise::FromMeta>::from_meta::Inner as devise::FromMeta>::from_meta(_25) -> [return: bb15, unwind: bb45];
    }

    bb14: {
        _21 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<FieldName, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _21) -> [return: bb58, unwind: bb47];
    }

    bb15: {
        _23 = <std::result::Result<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic> as std::ops::Try>::branch(move _24) -> [return: bb16, unwind: bb45];
    }

    bb16: {
        _26 = discriminant(_23);
        switchInt(move _26) -> [0: bb17, 1: bb18, otherwise: bb3];
    }

    bb17: {
        _28 = move ((_23 as Continue).0: <derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner);
        _29 = move (_28.0: name::Name);
        _2 = FieldName::Uncased(move _29);
        drop(_12) -> [return: bb20, unwind: bb47];
    }

    bb18: {
        _27 = move ((_23 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<FieldName, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _27) -> [return: bb19, unwind: bb45];
    }

    bb19: {
        drop(_12) -> [return: bb39, unwind: bb47];
    }

    bb20: {
        drop(_6) -> [return: bb51, unwind: bb56];
    }

    bb21: {
        _31 = name::Name::as_str(_32) -> [return: bb22, unwind: bb44];
    }

    bb22: {
        _30 = is_valid_field_name(_31) -> [return: bb23, unwind: bb44];
    }

    bb23: {
        switchInt(move _30) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _53 = move _2;
        _0 = std::result::Result::<FieldName, devise::Diagnostic>::Ok(move _53);
        goto -> bb41;
    }

    bb25: {
        _40 = const _;
        _39 = core::slice::<impl [char]>::iter(_40) -> [return: bb26, unwind: bb44];
    }

    bb26: {
        _38 = <std::slice::Iter<'_, char> as Iterator>::map::<std::string::String, {closure@core/codegen/src/derive/form_field.rs:108:22: 108:25}>(move _39, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:108:22: 108:25}) -> [return: bb27, unwind: bb44];
    }

    bb27: {
        _37 = <Map<std::slice::Iter<'_, char>, {closure@core/codegen/src/derive/form_field.rs:108:22: 108:25}> as Iterator>::collect::<Vec<std::string::String>>(move _38) -> [return: bb28, unwind: bb44];
    }

    bb28: {
        _36 = &_37;
        _35 = <Vec<std::string::String> as std::ops::Deref>::deref(move _36) -> [return: bb29, unwind: bb43];
    }

    bb29: {
        _41 = const ", ";
        _34 = slice::<impl [std::string::String]>::join::<&str>(_35, _41) -> [return: bb30, unwind: bb43];
    }

    bb30: {
        drop(_37) -> [return: bb31, unwind: bb42];
    }

    bb31: {
        _44 = devise::MetaItem::value_span(_1) -> [return: bb32, unwind: bb42];
    }

    bb32: {
        _43 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _44, const "invalid form field name") -> [return: bb33, unwind: bb42];
    }

    bb33: {
        _55 = const true;
        _54 = const _;
        _47 = _54 as &[&str] (PointerCoercion(Unsize));
        _52 = &_34;
        _51 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_52) -> [return: bb34, unwind: bb54];
    }

    bb34: {
        _50 = [move _51];
        _49 = &_50;
        _48 = _49 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _46 = std::fmt::Arguments::<'_>::new_v1(move _47, move _48) -> [return: bb35, unwind: bb54];
    }

    bb35: {
        _45 = format(move _46) -> [return: bb36, unwind: bb54];
    }

    bb36: {
        _55 = const false;
        _42 = devise::Diagnostic::help::<std::string::String>(move _43, move _45) -> [return: bb37, unwind: bb54];
    }

    bb37: {
        _55 = const false;
        _0 = std::result::Result::<FieldName, devise::Diagnostic>::Err(move _42);
        drop(_34) -> [return: bb38, unwind: bb44];
    }

    bb38: {
        drop(_2) -> [return: bb41, unwind continue];
    }

    bb39: {
        drop(_6) -> [return: bb40, unwind: bb56];
    }

    bb40: {
        _57 = discriminant(_3);
        switchInt(move _57) -> [0: bb41, otherwise: bb52];
    }

    bb41: {
        return;
    }

    bb42 (cleanup): {
        drop(_34) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_37) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_2) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_12) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_16) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        drop(_6) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        resume;
    }

    bb49: {
        _33 = &_2;
        _32 = <FieldName as std::ops::Deref>::deref(move _33) -> [return: bb21, unwind: bb44];
    }

    bb50: {
        drop(_3) -> [return: bb49, unwind: bb44];
    }

    bb51: {
        _56 = discriminant(_3);
        switchInt(move _56) -> [0: bb49, otherwise: bb50];
    }

    bb52: {
        drop(_3) -> [return: bb41, unwind continue];
    }

    bb53 (cleanup): {
        drop(_43) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        switchInt(_55) -> [0: bb42, otherwise: bb53];
    }

    bb55 (cleanup): {
        drop(_3) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        _58 = discriminant(_3);
        switchInt(move _58) -> [0: bb48, otherwise: bb55];
    }

    bb57: {
        goto -> bb40;
    }

    bb58: {
        goto -> bb39;
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "field name cannot be `isindex` or contain "];
        _0 = &_1;
        return;
    }
}

const CONTROL_CHARS: &[char] = {
    let mut _0: &[char];
    let mut _1: &[char; 6];
    let _2: &[char; 6];
    let _3: [char; 6];
    let mut _4: &[char; 6];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[char] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in CONTROL_CHARS: &[char; 6] = {
    let mut _0: &[char; 6];
    let mut _1: [char; 6];

    bb0: {
        _1 = [const '&', const '=', const '?', const '.', const '[', const ']'];
        _0 = &_1;
        return;
    }
}

fn is_valid_field_name(_1: &str) -> bool {
    debug s => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &&str;
    let mut _4: bool;
    let mut _5: &str;
    let mut _6: &mut std::str::Chars<'_>;
    let mut _7: std::str::Chars<'_>;
    let mut _8: &str;
    let mut _9: &&str;

    bb0: {
        _3 = &_1;
        _9 = const _;
        _2 = <&str as PartialEq>::eq(move _3, _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = _1;
        _4 = core::str::<impl str>::is_empty(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const false;
        goto -> bb7;
    }

    bb5: {
        _8 = _1;
        _7 = core::str::<impl str>::chars(move _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = &mut _7;
        _0 = <Chars<'_> as Iterator>::all::<{closure@core/codegen/src/derive/form_field.rs:87:27: 87:30}>(move _6, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:87:27: 87:30}) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

promoted[0] in is_valid_field_name: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "isindex";
        _0 = &_1;
        return;
    }
}

fn is_valid_field_name::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:87:27: 87:30}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &char;
    let mut _5: bool;
    let _6: &[char];
    let _7: &char;

    bb0: {
        _4 = &_2;
        _3 = char::methods::<impl char>::is_ascii_graphic(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = const _;
        _7 = &_2;
        _5 = core::slice::<impl [char]>::contains(_6, _7) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb5;
    }

    bb4: {
        _0 = Not(move _5);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

const form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_::<impl at core/codegen/src/derive/form_field.rs:93:26: 93:34>::from_meta(_1: &devise::MetaItem) -> std::result::Result<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<<derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _10: std::option::Option<&devise::MetaItem>;
    let mut _11: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _12: isize;
    let mut _15: bool;
    let mut _16: std::option::Option<name::Name>;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, name::Name>;
    let mut _18: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _19: isize;
    let mut _23: devise::Diagnostic;
    let mut _24: proc_macro2::Span;
    let mut _25: devise::Diagnostic;
    let mut _26: proc_macro2::Span;
    let mut _28: std::fmt::Arguments<'_>;
    let mut _29: &[&str];
    let mut _30: &[core::fmt::rt::Argument<'_>];
    let _31: &[core::fmt::rt::Argument<'_>; 0];
    let _32: [core::fmt::rt::Argument<'_>; 0];
    let mut _33: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _34: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _36: std::option::Option<&devise::MetaItem>;
    let mut _37: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _38: isize;
    let mut _42: std::option::Option<&proc_macro2::Ident>;
    let mut _43: isize;
    let mut _45: devise::Diagnostic;
    let mut _47: std::fmt::Arguments<'_>;
    let mut _48: &[&str];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 1];
    let _51: [core::fmt::rt::Argument<'_>; 1];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &&proc_macro2::Ident;
    let mut _54: devise::Diagnostic;
    let mut _55: <derive::form_field::FieldName as devise::FromMeta>::from_meta::Inner;
    let mut _56: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, name::Name>;
    let mut _57: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _58: std::option::Option<name::Name>;
    let mut _59: std::option::Option<name::Name>;
    let mut _60: {closure@core/codegen/src/derive/form_field.rs:95:21: 95:22};
    let mut _61: &proc_macro2::Span;
    let mut _62: isize;
    let mut _67: &devise::MetaItem;
    let mut _68: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _69: bool;
    let mut _70: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug uncased => _9;
                let _13: &devise::MetaItem;
                let _14: &&devise::MetaItem;
                let _22: &devise::MetaItem;
                let _27: std::string::String;
                let mut _35: syn::punctuated::Iter<'_, devise::MetaItem>;
                let _63: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _64: name::Name;
                let mut _65: &[&str; 1];
                scope 9 {
                    debug __i => _13;
                    debug __i => _14;
                    let _20: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                    let _21: name::Name;
                    scope 10 {
                        debug residual => _20;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _21;
                        scope 13 {
                        }
                    }
                }
                scope 14 {
                    debug __i => _22;
                }
                scope 15 {
                    debug res => _27;
                }
                scope 16 {
                    debug iter => _35;
                    let _39: &devise::MetaItem;
                    scope 17 {
                        debug __meta => _39;
                        let _40: proc_macro2::Span;
                        scope 18 {
                            debug __span => _40;
                            let _41: &proc_macro2::Ident;
                            let _44: &proc_macro2::Ident;
                            scope 19 {
                                debug __name => _41;
                                let _46: std::string::String;
                                let mut _66: &[&str; 2];
                                scope 21 {
                                    debug __msg => _46;
                                }
                                scope 22 {
                                    debug res => _46;
                                }
                            }
                            scope 20 {
                                debug __ident => _44;
                            }
                        }
                    }
                }
                scope 23 {
                    debug residual => _63;
                    scope 24 {
                    }
                }
                scope 25 {
                    debug val => _64;
                    scope 26 {
                    }
                }
            }
            scope 8 {
                let mut _9: std::option::Option<name::Name>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _69 = const false;
        _70 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _68 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_68 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _69 = const true;
        _3 = move _8;
        _70 = const true;
        _9 = Option::<name::Name>::None;
        _11 = &mut _3;
        _10 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(move _11) -> [return: bb7, unwind: bb54];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb48, unwind continue];
    }

    bb7: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb5];
    }

    bb8: {
        _26 = _2;
        _65 = const _;
        _29 = _65 as &[&str] (PointerCoercion(Unsize));
        _32 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb54];
    }

    bb9: {
        _14 = &((_10 as Some).0: &devise::MetaItem);
        _67 = deref_copy (*_14);
        _15 = devise::MetaItem::is_bare(_67) -> [return: bb10, unwind: bb54];
    }

    bb10: {
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _13 = ((_10 as Some).0: &devise::MetaItem);
        _18 = <name::Name as devise::FromMeta>::from_meta(_13) -> [return: bb13, unwind: bb54];
    }

    bb12: {
        _22 = ((_10 as Some).0: &devise::MetaItem);
        _24 = <devise::MetaItem as devise::Spanned>::span(_22) -> [return: bb19, unwind: bb54];
    }

    bb13: {
        _17 = <std::result::Result<name::Name, devise::Diagnostic> as std::ops::Try>::branch(move _18) -> [return: bb14, unwind: bb54];
    }

    bb14: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb15, 1: bb16, otherwise: bb5];
    }

    bb15: {
        _21 = move ((_17 as Continue).0: name::Name);
        _16 = Option::<name::Name>::Some(move _21);
        drop(_9) -> [return: bb17, unwind: bb18];
    }

    bb16: {
        _20 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _20) -> [return: bb57, unwind: bb54];
    }

    bb17: {
        _70 = const true;
        _9 = move _16;
        _69 = const false;
        _34 = move _3;
        _33 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _34) -> [return: bb25, unwind: bb54];
    }

    bb18 (cleanup): {
        _70 = const true;
        _9 = move _16;
        goto -> bb54;
    }

    bb19: {
        _23 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _24, const "unexpected keyed parameter: expected literal or identifier") -> [return: bb20, unwind: bb54];
    }

    bb20: {
        _0 = std::result::Result::<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>::Err(move _23);
        goto -> bb46;
    }

    bb21: {
        _31 = &_32;
        _30 = _31 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _28 = std::fmt::Arguments::<'_>::new_v1(move _29, move _30) -> [return: bb22, unwind: bb54];
    }

    bb22: {
        _27 = format(move _28) -> [return: bb23, unwind: bb54];
    }

    bb23: {
        _25 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _26, move _27) -> [return: bb24, unwind: bb54];
    }

    bb24: {
        _0 = std::result::Result::<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>::Err(move _25);
        goto -> bb46;
    }

    bb25: {
        _35 = move _33;
        _37 = &mut _35;
        _36 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_37) -> [return: bb26, unwind: bb50];
    }

    bb26: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb28, 1: bb27, otherwise: bb5];
    }

    bb27: {
        _39 = ((_36 as Some).0: &devise::MetaItem);
        _40 = <devise::MetaItem as devise::Spanned>::span(_39) -> [return: bb29, unwind: bb50];
    }

    bb28: {
        drop(_35) -> [return: bb38, unwind: bb54];
    }

    bb29: {
        _42 = devise::MetaItem::name(_39) -> [return: bb30, unwind: bb50];
    }

    bb30: {
        _43 = discriminant(_42);
        switchInt(move _43) -> [0: bb31, 1: bb32, otherwise: bb5];
    }

    bb31: {
        _45 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_40, const "expected key/value `key = value`") -> [return: bb33, unwind: bb50];
    }

    bb32: {
        _44 = ((_42 as Some).0: &proc_macro2::Ident);
        _41 = _44;
        _66 = const _;
        _48 = _66 as &[&str] (PointerCoercion(Unsize));
        _53 = &_41;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_53) -> [return: bb34, unwind: bb50];
    }

    bb33: {
        _0 = std::result::Result::<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>::Err(move _45);
        goto -> bb45;
    }

    bb34: {
        _51 = [move _52];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _47 = std::fmt::Arguments::<'_>::new_v1(move _48, move _49) -> [return: bb35, unwind: bb50];
    }

    bb35: {
        _46 = format(move _47) -> [return: bb36, unwind: bb50];
    }

    bb36: {
        _54 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_40, move _46) -> [return: bb37, unwind: bb50];
    }

    bb37: {
        _0 = std::result::Result::<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>::Err(move _54);
        goto -> bb45;
    }

    bb38: {
        _70 = const false;
        _59 = move _9;
        _58 = Option::<name::Name>::or_else::<fn() -> Option<name::Name> {<name::Name as devise::FromMeta>::default}>(move _59, <name::Name as devise::FromMeta>::default) -> [return: bb39, unwind: bb54];
    }

    bb39: {
        _61 = &_2;
        _60 = {closure@core/codegen/src/derive/form_field.rs:95:21: 95:22} { __span: move _61 };
        _57 = Option::<name::Name>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/form_field.rs:95:21: 95:22}>(move _58, move _60) -> [return: bb40, unwind: bb54];
    }

    bb40: {
        _56 = <std::result::Result<name::Name, devise::Diagnostic> as std::ops::Try>::branch(move _57) -> [return: bb41, unwind: bb54];
    }

    bb41: {
        _62 = discriminant(_56);
        switchInt(move _62) -> [0: bb42, 1: bb43, otherwise: bb5];
    }

    bb42: {
        _64 = move ((_56 as Continue).0: name::Name);
        _55 = <FieldName as devise::FromMeta>::from_meta::Inner { uncased: move _64 };
        _0 = std::result::Result::<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic>::Ok(move _55);
        _70 = const false;
        _69 = const false;
        goto -> bb49;
    }

    bb43: {
        _63 = move ((_56 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<<FieldName as devise::FromMeta>::from_meta::Inner, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _63) -> [return: bb44, unwind continue];
    }

    bb44: {
        _70 = const false;
        _69 = const false;
        goto -> bb49;
    }

    bb45: {
        drop(_35) -> [return: bb46, unwind: bb54];
    }

    bb46: {
        drop(_9) -> [return: bb47, unwind: bb56];
    }

    bb47: {
        _70 = const false;
        switchInt(_69) -> [0: bb48, otherwise: bb52];
    }

    bb48: {
        _69 = const false;
        goto -> bb49;
    }

    bb49: {
        return;
    }

    bb50 (cleanup): {
        drop(_35) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        resume;
    }

    bb52: {
        drop(_3) -> [return: bb48, unwind continue];
    }

    bb53 (cleanup): {
        drop(_9) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        switchInt(_70) -> [0: bb56, otherwise: bb53];
    }

    bb55 (cleanup): {
        drop(_3) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        switchInt(_69) -> [0: bb51, otherwise: bb55];
    }

    bb57: {
        goto -> bb46;
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_::<impl at core/codegen/src/derive/form_field.rs:93:26: 93:34>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing expected parameter: `uncased`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_::<impl at core/codegen/src/derive/form_field.rs:93:26: 93:34>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_::<impl at core/codegen/src/derive/form_field.rs:93:26: 93:34>::from_meta::{closure#0}(_1: {closure@core/codegen/src/derive/form_field.rs:95:21: 95:22}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::_::<impl at core/codegen/src/derive/form_field.rs:93:26: 93:34>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `uncased`"];
        _0 = &_1;
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:108:22: 108:25}, _2: &char) -> std::string::String {
    debug c => _2;
    let mut _0: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &&char;
    let mut _10: &[&str; 1];
    scope 1 {
        debug res => _0;
    }

    bb0: {
        _10 = const _;
        _4 = _10 as &[&str] (PointerCoercion(Unsize));
        _9 = &_2;
        _8 = core::fmt::rt::Argument::<'_>::new_debug::<&char>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = std::fmt::Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = format(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:75:1: 75:28>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:121:1: 121:35>::deref(_1: &FieldName) -> &name::Name {
    debug self => _1;
    let mut _0: &name::Name;
    let mut _2: isize;
    let _3: &name::Name;
    scope 1 {
        debug n => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb4, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = &(((*_1) as Uncased).0: name::Name);
        goto -> bb3;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = _3;
        return;
    }

    bb4: {
        _3 = &(((*_1) as Cased).0: name::Name);
        goto -> bb3;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:131:1: 131:28>::to_tokens(_1: &FieldName, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &name::Name;

    bb0: {
        _3 = <FieldName as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <name::Name as ToTokens>::to_tokens(_3, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:137:1: 137:29>::eq(_1: &FieldName, _2: &FieldName) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: (&derive::form_field::FieldName, &derive::form_field::FieldName);
    let mut _4: isize;
    let mut _5: isize;
    let mut _6: isize;
    let _7: &name::Name;
    let _8: &name::Name;
    let mut _9: &&name::Name;
    let mut _10: &&name::Name;
    let _11: &name::Name;
    let _12: &name::Name;
    let mut _13: &&name::Name;
    let mut _14: &&rocket_http::uncased::UncasedStr;
    let _15: &rocket_http::uncased::UncasedStr;
    let mut _16: &name::Name;
    let _17: &name::Name;
    let _18: &name::Name;
    let mut _19: &&rocket_http::uncased::UncasedStr;
    let _20: &rocket_http::uncased::UncasedStr;
    let mut _21: &&rocket_http::uncased::UncasedStr;
    let _22: &rocket_http::uncased::UncasedStr;
    let mut _23: &derive::form_field::FieldName;
    let mut _24: &derive::form_field::FieldName;
    let mut _25: &derive::form_field::FieldName;
    let mut _26: &derive::form_field::FieldName;
    let mut _27: &derive::form_field::FieldName;
    let mut _28: &derive::form_field::FieldName;
    let mut _29: &derive::form_field::FieldName;
    let mut _30: &derive::form_field::FieldName;
    let mut _31: &derive::form_field::FieldName;
    let mut _32: &derive::form_field::FieldName;
    let mut _33: &derive::form_field::FieldName;
    scope 1 {
        debug a => _7;
        debug b => _8;
    }
    scope 2 {
        debug a => _11;
        debug u => _12;
    }
    scope 3 {
        debug u1 => _17;
        debug u2 => _18;
    }

    bb0: {
        _3 = (_1, _2);
        _23 = deref_copy (_3.0: &derive::form_field::FieldName);
        _6 = discriminant((*_23));
        switchInt(move _6) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _24 = deref_copy (_3.1: &derive::form_field::FieldName);
        _4 = discriminant((*_24));
        switchInt(move _4) -> [0: bb5, 1: bb7, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _25 = deref_copy (_3.1: &derive::form_field::FieldName);
        _5 = discriminant((*_25));
        switchInt(move _5) -> [0: bb8, 1: bb4, otherwise: bb2];
    }

    bb4: {
        _26 = deref_copy (_3.0: &derive::form_field::FieldName);
        _17 = &(((*_26) as Uncased).0: name::Name);
        _27 = deref_copy (_3.1: &derive::form_field::FieldName);
        _18 = &(((*_27) as Uncased).0: name::Name);
        _20 = name::Name::as_uncased_str(_17) -> [return: bb10, unwind continue];
    }

    bb5: {
        _28 = deref_copy (_3.0: &derive::form_field::FieldName);
        _7 = &(((*_28) as Cased).0: name::Name);
        _29 = deref_copy (_3.1: &derive::form_field::FieldName);
        _8 = &(((*_29) as Cased).0: name::Name);
        _9 = &_7;
        _10 = &_8;
        _0 = <&name::Name as PartialEq>::eq(move _9, move _10) -> [return: bb12, unwind continue];
    }

    bb6: {
        _13 = &_11;
        _16 = _12;
        _15 = name::Name::as_uncased_str(move _16) -> [return: bb9, unwind continue];
    }

    bb7: {
        _30 = deref_copy (_3.0: &derive::form_field::FieldName);
        _11 = &(((*_30) as Cased).0: name::Name);
        _31 = deref_copy (_3.1: &derive::form_field::FieldName);
        _12 = &(((*_31) as Uncased).0: name::Name);
        goto -> bb6;
    }

    bb8: {
        _32 = deref_copy (_3.0: &derive::form_field::FieldName);
        _12 = &(((*_32) as Uncased).0: name::Name);
        _33 = deref_copy (_3.1: &derive::form_field::FieldName);
        _11 = &(((*_33) as Cased).0: name::Name);
        goto -> bb6;
    }

    bb9: {
        _14 = &_15;
        _0 = <&name::Name as PartialEq<&UncasedStr>>::eq(move _13, move _14) -> [return: bb12, unwind continue];
    }

    bb10: {
        _19 = &_20;
        _22 = name::Name::as_uncased_str(_18) -> [return: bb11, unwind continue];
    }

    bb11: {
        _21 = &_22;
        _0 = <&UncasedStr as PartialEq>::eq(move _19, move _21) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::ident(_1: &devise::Field<'_>) -> &proc_macro2::Ident {
    debug self => _1;
    let mut _0: &proc_macro2::Ident;
    let mut _2: std::option::Option<&proc_macro2::Ident>;
    let mut _3: &std::option::Option<proc_macro2::Ident>;
    let _4: &syn::Field;
    let _5: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let _6: &str;

    bb0: {
        _5 = <devise::Field<'_> as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = &((*_4).2: std::option::Option<proc_macro2::Ident>);
        _2 = Option::<proc_macro2::Ident>::as_ref(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = const "named";
        _0 = Option::<&proc_macro2::Ident>::expect(move _2, _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::field_names(_1: &devise::Field<'_>) -> std::result::Result<Vec<FieldName>, devise::Diagnostic> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let _2: std::vec::Vec<derive::form_field::FieldName>;
    let mut _3: std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:157:25: 157:31}>;
    let mut _4: std::vec::IntoIter<derive::form_field::FieldAttr>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldAttr>>;
    let mut _6: std::result::Result<std::vec::Vec<derive::form_field::FieldAttr>, devise::Diagnostic>;
    let _7: &str;
    let _8: &[syn::Attribute];
    let _9: &std::vec::Vec<syn::Attribute>;
    let _10: &syn::Field;
    let _11: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _14: std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _15: bool;
    let mut _16: &std::vec::Vec<derive::form_field::FieldName>;
    let mut _18: &proc_macro2::Ident;
    let mut _19: std::vec::Vec<derive::form_field::FieldName>;
    let mut _20: std::boxed::Box<[derive::form_field::FieldName]>;
    let mut _21: usize;
    let mut _22: usize;
    let mut _23: *mut u8;
    let mut _24: std::boxed::Box<[derive::form_field::FieldName; 1]>;
    let mut _25: derive::form_field::FieldName;
    let mut _26: name::Name;
    let mut _27: std::vec::Vec<derive::form_field::FieldName>;
    let mut _28: bool;
    let mut _29: *const [derive::form_field::FieldName; 1];
    scope 1 {
        debug attr_names => _2;
        let _17: name::Name;
        scope 6 {
            debug ident_name => _17;
            let mut _30: *const ();
            let mut _31: usize;
            let mut _32: usize;
            let mut _33: usize;
            let mut _34: usize;
            let mut _35: bool;
            scope 7 {
            }
        }
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _28 = const false;
        _7 = const _;
        _11 = <devise::Field<'_> as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &((*_10).0: std::vec::Vec<syn::Attribute>);
        _8 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <form_field::FieldAttr as devise::FromMeta>::from_attrs(_7, _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <std::result::Result<Vec<form_field::FieldAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _14 = move ((_5 as Continue).0: std::vec::Vec<derive::form_field::FieldAttr>);
        _4 = <Vec<form_field::FieldAttr> as IntoIterator>::into_iter(move _14) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _13 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _13) -> [return: bb19, unwind continue];
    }

    bb9: {
        _3 = <std::vec::IntoIter<form_field::FieldAttr> as Iterator>::filter_map::<FieldName, {closure@core/codegen/src/derive/form_field.rs:157:25: 157:31}>(move _4, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:157:25: 157:31}) -> [return: bb10, unwind continue];
    }

    bb10: {
        _2 = <FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:157:25: 157:31}> as Iterator>::collect::<Vec<FieldName>>(move _3) -> [return: bb11, unwind continue];
    }

    bb11: {
        _16 = &_2;
        _15 = Vec::<FieldName>::is_empty(move _16) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        switchInt(move _15) -> [0: bb18, otherwise: bb13];
    }

    bb13: {
        _18 = <devise::Field<'_> as form_field::FieldExt>::ident(_1) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _17 = <name::Name as From<&proc_macro2::Ident>>::from(move _18) -> [return: bb15, unwind: bb20];
    }

    bb15: {
        _28 = const true;
        _21 = SizeOf([derive::form_field::FieldName; 1]);
        _22 = AlignOf([derive::form_field::FieldName; 1]);
        _23 = alloc::alloc::exchange_malloc(move _21, move _22) -> [return: bb16, unwind: bb23];
    }

    bb16: {
        _24 = ShallowInitBox(move _23, [derive::form_field::FieldName; 1]);
        _28 = const false;
        _26 = move _17;
        _25 = FieldName::Cased(move _26);
        _29 = (((_24.0: std::ptr::Unique<[derive::form_field::FieldName; 1]>).0: std::ptr::NonNull<[derive::form_field::FieldName; 1]>).0: *const [derive::form_field::FieldName; 1]);
        _30 = _29 as *const () (PtrToPtr);
        _31 = _30 as usize (Transmute);
        _32 = AlignOf([derive::form_field::FieldName; 1]);
        _33 = Sub(_32, const 1_usize);
        _34 = BitAnd(_31, _33);
        _35 = Eq(_34, const 0_usize);
        assert(_35, "misaligned pointer dereference: address must be a multiple of {} but is {}", _32, _31) -> [success: bb24, unwind unreachable];
    }

    bb17: {
        _0 = std::result::Result::<Vec<FieldName>, devise::Diagnostic>::Ok(move _19);
        _28 = const false;
        drop(_2) -> [return: bb19, unwind continue];
    }

    bb18: {
        _27 = move _2;
        _0 = std::result::Result::<Vec<FieldName>, devise::Diagnostic>::Ok(move _27);
        goto -> bb19;
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_2) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }

    bb22 (cleanup): {
        drop(_17) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_28) -> [0: bb20, otherwise: bb22];
    }

    bb24: {
        (*_29) = [move _25];
        _20 = move _24 as std::boxed::Box<[derive::form_field::FieldName]> (PointerCoercion(Unsize));
        _19 = slice::<impl [FieldName]>::into_vec::<std::alloc::Global>(move _20) -> [return: bb17, unwind: bb23];
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::field_names::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:157:25: 157:31}, _2: form_field::FieldAttr) -> Option<FieldName> {
    debug attr => _2;
    let mut _0: std::option::Option<derive::form_field::FieldName>;

    bb0: {
        _0 = move (_2.0: std::option::Option<derive::form_field::FieldName>);
        drop((_2.1: std::option::Option<devise::SpanWrapped<syn::Expr>>)) -> [return: bb6, unwind: bb4];
    }

    bb1 (cleanup): {
        resume;
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop((_2.3: std::option::Option<syn::Expr>)) -> [return: bb1, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        drop((_2.2: std::option::Option<syn::Expr>)) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5: {
        drop((_2.3: std::option::Option<syn::Expr>)) -> [return: bb2, unwind continue];
    }

    bb6: {
        drop((_2.2: std::option::Option<syn::Expr>)) -> [return: bb5, unwind: bb3];
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::first_field_name(_1: &devise::Field<'_>) -> std::result::Result<FieldName, devise::Diagnostic> {
    debug self => _1;
    let mut _0: std::result::Result<derive::form_field::FieldName, devise::Diagnostic>;
    let mut _2: std::vec::IntoIter<derive::form_field::FieldName>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldName>>;
    let mut _4: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _7: std::vec::Vec<derive::form_field::FieldName>;
    let mut _8: derive::form_field::FieldName;
    let mut _9: std::option::Option<derive::form_field::FieldName>;
    let mut _10: &mut std::vec::IntoIter<derive::form_field::FieldName>;
    let _11: &str;
    scope 1 {
        debug names => _2;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = <devise::Field<'_> as form_field::FieldExt>::field_names(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: std::vec::Vec<derive::form_field::FieldName>);
        _2 = <Vec<FieldName> as IntoIterator>::into_iter(move _7) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<FieldName, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _6) -> [return: bb9, unwind continue];
    }

    bb6: {
        _10 = &mut _2;
        _9 = <std::vec::IntoIter<FieldName> as Iterator>::next(move _10) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _11 = const "always have >= 1 name";
        _8 = Option::<FieldName>::expect(move _9, _11) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _0 = std::result::Result::<FieldName, devise::Diagnostic>::Ok(move _8);
        drop(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::stripped_ty(_1: &devise::Field<'_>) -> syn::Type {
    debug self => _1;
    let mut _0: syn::Type;
    let mut _2: &syn::Type;
    let _3: &syn::Field;
    let _4: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;

    bb0: {
        _4 = <devise::Field<'_> as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = &((*_3).4: syn::Type);
        _0 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:149:1: 149:28>::name_view(_1: &devise::Field<'_>) -> std::result::Result<syn::Expr, devise::Diagnostic> {
    debug self => _1;
    let mut _0: std::result::Result<syn::Expr, devise::Diagnostic>;
    let _2: std::vec::Vec<derive::form_field::FieldName>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldName>>;
    let mut _4: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _7: std::vec::Vec<derive::form_field::FieldName>;
    let mut _9: std::option::Option<&derive::form_field::FieldName>;
    let _10: &[derive::form_field::FieldName];
    let mut _11: &std::vec::Vec<derive::form_field::FieldName>;
    let _12: &str;
    let mut _14: std::option::Option<proc_macro2::Span>;
    let mut _15: proc_macro2::Span;
    let _19: ();
    let _20: &exports::StaticPath;
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: &str;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let mut _34: proc_macro2::Delimiter;
    let mut _35: proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let mut _39: proc_macro2::Delimiter;
    let mut _40: proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: &str;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let _53: &&derive::form_field::FieldName;
    let mut _54: &mut proc_macro2::TokenStream;
    let mut _55: syn::Expr;
    let mut _56: std::result::Result<syn::Expr, syn::Error>;
    scope 1 {
        debug field_names => _2;
        let _8: &derive::form_field::FieldName;
        scope 6 {
            debug field_name => _8;
            scope 7 {
                debug _form => _13;
                let _16: proc_macro2::TokenStream;
                let mut _17: proc_macro2::TokenStream;
                scope 9 {
                    debug name_view => _16;
                }
                scope 10 {
                    debug _s => _17;
                    let _18: proc_macro2::Span;
                    scope 11 {
                        debug _span => _18;
                        let mut _36: proc_macro2::TokenStream;
                        scope 12 {
                            debug _s => _36;
                            scope 13 {
                                debug _span => _18;
                                let mut _41: proc_macro2::TokenStream;
                                scope 14 {
                                    debug _s => _41;
                                    scope 15 {
                                        debug _span => _18;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 8 {
                let _13: exports::StaticPath;
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = <devise::Field<'_> as form_field::FieldExt>::field_names(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: std::vec::Vec<derive::form_field::FieldName>);
        _2 = move _7;
        _11 = &_2;
        _10 = <Vec<FieldName> as std::ops::Deref>::deref(move _11) -> [return: bb6, unwind: bb32];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<syn::Expr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _6) -> [return: bb28, unwind continue];
    }

    bb6: {
        _9 = core::slice::<impl [FieldName]>::first(_10) -> [return: bb7, unwind: bb32];
    }

    bb7: {
        _12 = const "always have name";
        _8 = Option::<&FieldName>::expect(move _9, _12) -> [return: bb8, unwind: bb32];
    }

    bb8: {
        _15 = <devise::Field<'_> as devise::Spanned>::span(_1) -> [return: bb9, unwind: bb32];
    }

    bb9: {
        _14 = Option::<proc_macro2::Span>::Some(move _15);
        _13 = StaticPath(move _14, const "::rocket::form::prelude");
        _17 = TokenStream2::new() -> [return: bb10, unwind: bb32];
    }

    bb10: {
        _18 = <devise::Field<'_> as devise::Spanned>::span(_1) -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _20 = &_13;
        _21 = &mut _17;
        _19 = <StaticPath as ToTokens>::to_tokens(_20, _21) -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _23 = &mut _17;
        _22 = push_colon2_spanned(_23, _18) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _25 = &mut _17;
        _26 = const "NameBuf";
        _24 = push_ident_spanned(_25, _18, _26) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _28 = &mut _17;
        _27 = push_colon2_spanned(_28, _18) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _30 = &mut _17;
        _31 = const "from";
        _29 = push_ident_spanned(_30, _18, _31) -> [return: bb16, unwind: bb31];
    }

    bb16: {
        _33 = &mut _17;
        _34 = proc_macro2::Delimiter::Parenthesis;
        _36 = TokenStream2::new() -> [return: bb17, unwind: bb31];
    }

    bb17: {
        _38 = &mut _36;
        _39 = proc_macro2::Delimiter::Parenthesis;
        _41 = TokenStream2::new() -> [return: bb18, unwind: bb30];
    }

    bb18: {
        _43 = &mut _41;
        _44 = const "__c";
        _42 = push_ident_spanned(_43, _18, _44) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _46 = &mut _41;
        _45 = push_dot_spanned(_46, _18) -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _48 = &mut _41;
        _49 = const "__parent";
        _47 = push_ident_spanned(_48, _18, _49) -> [return: bb21, unwind: bb29];
    }

    bb21: {
        _51 = &mut _41;
        _50 = push_comma_spanned(_51, _18) -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _53 = &_8;
        _54 = &mut _41;
        _52 = <&FieldName as ToTokens>::to_tokens(_53, _54) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        _40 = move _41;
        _37 = push_group_spanned(_38, _18, move _39, move _40) -> [return: bb24, unwind: bb30];
    }

    bb24: {
        _35 = move _36;
        _32 = push_group_spanned(_33, _18, move _34, move _35) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _16 = move _17;
        _56 = syn::parse2::<syn::Expr>(move _16) -> [return: bb26, unwind: bb32];
    }

    bb26: {
        _55 = std::result::Result::<syn::Expr, syn::Error>::unwrap(move _56) -> [return: bb27, unwind: bb32];
    }

    bb27: {
        _0 = std::result::Result::<syn::Expr, devise::Diagnostic>::Ok(move _55);
        drop(_2) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_41) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_36) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_17) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_2) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:191:1: 191:44>::visit_expr_field(_1: &mut RecordMemberAccesses, _2: &ExprField) -> () {
    debug self => _1;
    debug i => _2;
    let mut _0: ();
    let mut _3: &syn::Expr;
    let mut _4: isize;
    let mut _6: bool;
    let mut _7: &syn::Path;
    let _8: &str;
    let _9: ();
    let mut _10: &mut std::vec::Vec<syn::Member>;
    let mut _11: syn::Member;
    let mut _12: &syn::Member;
    let _13: ();
    let mut _14: std::boxed::Box<syn::Expr>;
    let mut _15: *const syn::Expr;
    scope 1 {
        debug e => _5;
        let _5: &syn::ExprPath;
    }

    bb0: {
        _14 = deref_copy ((*_2).1: std::boxed::Box<syn::Expr>);
        _15 = (((_14.0: std::ptr::Unique<syn::Expr>).0: std::ptr::NonNull<syn::Expr>).0: *const syn::Expr);
        _3 = &(*_15);
        _4 = discriminant((*_3));
        switchInt(move _4) -> [25: bb1, otherwise: bb5];
    }

    bb1: {
        _5 = &(((*_3) as Path).0: syn::ExprPath);
        _7 = &((*_5).2: syn::Path);
        _8 = const "self";
        _6 = syn::path::parsing::<impl syn::Path>::is_ident::<str>(move _7, _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _6) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _10 = &mut ((*_1).0: std::vec::Vec<syn::Member>);
        _12 = &((*_2).3: syn::Member);
        _11 = <Member as Clone>::clone(move _12) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = Vec::<Member>::push(move _10, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = syn::visit::visit_expr_field::<'_, RecordMemberAccesses>(_1, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:210:1: 210:27>::visit_token_stream(_1: &mut ValidationMutator<'_>, _2: TokenStream2) -> TokenStream2 {
    debug self => _1;
    debug tt => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::token_stream::IntoIter;
    let mut _5: ();
    let mut _6: std::option::Option<proc_macro2::TokenTree>;
    let mut _7: &mut proc_macro2::token_stream::IntoIter;
    let mut _8: isize;
    let mut _10: isize;
    let mut _13: bool;
    let mut _14: (std::option::Option<proc_macro2::TokenTree>, std::option::Option<proc_macro2::TokenTree>);
    let mut _15: std::option::Option<proc_macro2::TokenTree>;
    let mut _16: &mut proc_macro2::token_stream::IntoIter;
    let mut _17: std::option::Option<proc_macro2::TokenTree>;
    let mut _18: &mut proc_macro2::token_stream::IntoIter;
    let mut _19: isize;
    let mut _20: isize;
    let mut _21: isize;
    let mut _22: isize;
    let mut _27: char;
    let mut _29: proc_macro2::TokenStream;
    let _31: ();
    let _32: &proc_macro2::Ident;
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: ();
    let _35: &proc_macro2::Punct;
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let _38: &proc_macro2::Ident;
    let mut _39: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut syn::Expr;
    let _43: ();
    let mut _44: &syn::Expr;
    let mut _45: &mut proc_macro2::TokenStream;
    let mut _48: &mut proc_macro2::TokenStream;
    let mut _49: &[std::option::Option<proc_macro2::TokenTree>; 3];
    let _50: [std::option::Option<proc_macro2::TokenTree>; 3];
    let mut _51: std::option::Option<proc_macro2::TokenTree>;
    let mut _52: proc_macro2::TokenTree;
    let mut _53: proc_macro2::Ident;
    let mut _56: proc_macro2::TokenStream;
    let mut _57: &proc_macro2::Group;
    let mut _59: proc_macro2::Delimiter;
    let mut _60: &proc_macro2::Group;
    let mut _61: proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::Group;
    let mut _64: proc_macro2::Span;
    let mut _65: &proc_macro2::Group;
    let mut _67: proc_macro2::Group;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _71: &mut proc_macro2::TokenStream;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: bool;
    let mut _77: bool;
    let mut _78: bool;
    let mut _79: bool;
    let mut _80: bool;
    let mut _81: bool;
    let mut _82: bool;
    let mut _83: isize;
    let mut _84: isize;
    let mut _85: isize;
    let mut _86: isize;
    let mut _87: isize;
    let mut _88: isize;
    let mut _89: isize;
    let mut _90: isize;
    let mut _91: isize;
    let mut _92: isize;
    let mut _93: isize;
    let mut _94: isize;
    scope 1 {
        debug iter => _3;
        let mut _4: proc_macro2::TokenStream;
        scope 2 {
            debug stream => _4;
            scope 3 {
                debug tt => _9;
                let _9: proc_macro2::TokenTree;
                let _11: proc_macro2::Ident;
                let _12: &proc_macro2::Ident;
                let _54: proc_macro2::Group;
                let _70: proc_macro2::TokenTree;
                let mut _72: &&str;
                scope 4 {
                    debug s3lf => _11;
                    debug s3lf => _12;
                    let _23: proc_macro2::Punct;
                    let _24: &proc_macro2::Punct;
                    let _25: proc_macro2::Ident;
                    let _26: &proc_macro2::Ident;
                    let _46: std::option::Option<proc_macro2::TokenTree>;
                    let _47: std::option::Option<proc_macro2::TokenTree>;
                    scope 5 {
                        debug p => _23;
                        debug p => _24;
                        debug i => _25;
                        debug i => _26;
                        let _28: syn::ExprField;
                        let mut _30: proc_macro2::TokenStream;
                        scope 6 {
                            debug field => _28;
                            let mut _40: syn::Expr;
                            scope 8 {
                                debug expr => _40;
                            }
                        }
                        scope 7 {
                            debug _s => _30;
                        }
                    }
                    scope 9 {
                        debug tt1 => _46;
                        debug tt2 => _47;
                    }
                }
                scope 10 {
                    debug group => _54;
                    let _55: proc_macro2::TokenStream;
                    scope 11 {
                        debug tt => _55;
                        let mut _58: proc_macro2::Group;
                        scope 12 {
                            debug new => _58;
                            let _66: proc_macro2::TokenTree;
                            scope 13 {
                                debug group => _66;
                            }
                        }
                    }
                }
                scope 14 {
                    debug tt => _70;
                }
            }
        }
    }

    bb0: {
        _78 = const false;
        _77 = const false;
        _80 = const false;
        _79 = const false;
        _82 = const false;
        _75 = const false;
        _73 = const false;
        _76 = const false;
        _74 = const false;
        _81 = const false;
        _3 = <TokenStream2 as IntoIterator>::into_iter(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = TokenStream2::new() -> [return: bb94, unwind: bb46];
    }

    bb2: {
        _7 = &mut _3;
        _6 = <proc_macro2::token_stream::IntoIter as Iterator>::next(move _7) -> [return: bb3, unwind: bb45];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [1: bb4, otherwise: bb36];
    }

    bb4: {
        _78 = const true;
        _82 = const true;
        _9 = move ((_6 as Some).0: proc_macro2::TokenTree);
        _10 = discriminant(_9);
        switchInt(move _10) -> [0: bb28, 1: bb6, otherwise: bb5];
    }

    bb5: {
        _78 = const false;
        _82 = const false;
        _70 = move _9;
        _71 = &mut _4;
        _5 = <TokenStream2 as quote::TokenStreamExt>::append::<proc_macro2::TokenTree>(move _71, move _70) -> [return: bb95, unwind: bb93];
    }

    bb6: {
        _12 = &((_9 as Ident).0: proc_macro2::Ident);
        _72 = const _;
        _13 = <proc_macro2::Ident as PartialEq<&str>>::eq(_12, _72) -> [return: bb7, unwind: bb93];
    }

    bb7: {
        switchInt(move _13) -> [0: bb5, otherwise: bb8];
    }

    bb8: {
        _82 = const false;
        _77 = const true;
        _11 = move ((_9 as Ident).0: proc_macro2::Ident);
        _16 = &mut _3;
        _15 = <proc_macro2::token_stream::IntoIter as Iterator>::next(move _16) -> [return: bb9, unwind: bb88];
    }

    bb9: {
        _18 = &mut _3;
        _17 = <proc_macro2::token_stream::IntoIter as Iterator>::next(move _18) -> [return: bb10, unwind: bb44];
    }

    bb10: {
        _73 = const true;
        _74 = const true;
        _81 = const true;
        _75 = const true;
        _76 = const true;
        _14 = (move _15, move _17);
        _22 = discriminant((_14.0: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _22) -> [1: bb12, otherwise: bb11];
    }

    bb11: {
        _75 = const false;
        _76 = const false;
        _46 = move (_14.0: std::option::Option<proc_macro2::TokenTree>);
        _73 = const false;
        _74 = const false;
        _81 = const false;
        _47 = move (_14.1: std::option::Option<proc_macro2::TokenTree>);
        _48 = &mut _4;
        _77 = const false;
        _53 = move _11;
        _52 = proc_macro2::TokenTree::Ident(move _53);
        _51 = Option::<proc_macro2::TokenTree>::Some(move _52);
        _50 = [move _51, move _46, move _47];
        _49 = &_50;
        _5 = <TokenStream2 as quote::TokenStreamExt>::append_all::<&[Option<proc_macro2::TokenTree>; 3]>(move _48, move _49) -> [return: bb26, unwind: bb40];
    }

    bb12: {
        _21 = discriminant((_14.1: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _21) -> [1: bb13, otherwise: bb11];
    }

    bb13: {
        _20 = discriminant((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _20) -> [2: bb14, otherwise: bb11];
    }

    bb14: {
        _19 = discriminant((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _19) -> [1: bb15, otherwise: bb11];
    }

    bb15: {
        _24 = &(((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree) as Punct).0: proc_macro2::Punct);
        _26 = &(((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree) as Ident).0: proc_macro2::Ident);
        _27 = proc_macro2::Punct::as_char(_24) -> [return: bb16, unwind: bb86];
    }

    bb16: {
        switchInt(move _27) -> [46: bb17, otherwise: bb11];
    }

    bb17: {
        _23 = move (((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree) as Punct).0: proc_macro2::Punct);
        _81 = const false;
        _25 = move (((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree) as Ident).0: proc_macro2::Ident);
        _30 = TokenStream2::new() -> [return: bb18, unwind: bb43];
    }

    bb18: {
        _32 = &_11;
        _33 = &mut _30;
        _31 = <proc_macro2::Ident as ToTokens>::to_tokens(_32, _33) -> [return: bb19, unwind: bb42];
    }

    bb19: {
        _35 = &_23;
        _36 = &mut _30;
        _34 = <proc_macro2::Punct as ToTokens>::to_tokens(_35, _36) -> [return: bb20, unwind: bb42];
    }

    bb20: {
        _38 = &_25;
        _39 = &mut _30;
        _37 = <proc_macro2::Ident as ToTokens>::to_tokens(_38, _39) -> [return: bb21, unwind: bb42];
    }

    bb21: {
        _29 = move _30;
        _28 = syn::parse_quote::parse::<ExprField>(move _29) -> [return: bb22, unwind: bb43];
    }

    bb22: {
        _40 = syn::Expr::Field(move _28);
        _42 = &mut _40;
        _41 = <ValidationMutator<'_> as VisitMut>::visit_expr_mut(_1, _42) -> [return: bb23, unwind: bb41];
    }

    bb23: {
        _44 = &_40;
        _45 = &mut _4;
        _43 = <syn::Expr as ToTokens>::to_tokens(move _44, _45) -> [return: bb24, unwind: bb41];
    }

    bb24: {
        drop(_40) -> [return: bb25, unwind: bb43];
    }

    bb25: {
        drop(_25) -> [return: bb65, unwind: bb86];
    }

    bb26: {
        drop(_50) -> [return: bb65, unwind: bb86];
    }

    bb27: {
        _77 = const false;
        goto -> bb70;
    }

    bb28: {
        _54 = move ((_9 as Group).0: proc_macro2::Group);
        _57 = &_54;
        _56 = proc_macro2::Group::stream(move _57) -> [return: bb29, unwind: bb39];
    }

    bb29: {
        _55 = ValidationMutator::<'_>::visit_token_stream(_1, move _56) -> [return: bb30, unwind: bb39];
    }

    bb30: {
        _80 = const true;
        _60 = &_54;
        _59 = proc_macro2::Group::delimiter(move _60) -> [return: bb31, unwind: bb74];
    }

    bb31: {
        _80 = const false;
        _61 = move _55;
        _58 = proc_macro2::Group::new(move _59, move _61) -> [return: bb32, unwind: bb74];
    }

    bb32: {
        _79 = const true;
        _63 = &mut _58;
        _65 = &_54;
        _64 = proc_macro2::Group::span(move _65) -> [return: bb33, unwind: bb72];
    }

    bb33: {
        _62 = proc_macro2::Group::set_span(move _63, move _64) -> [return: bb34, unwind: bb72];
    }

    bb34: {
        _79 = const false;
        _67 = move _58;
        _66 = proc_macro2::TokenTree::Group(move _67);
        _69 = &mut _4;
        _68 = <TokenStream2 as quote::TokenStreamExt>::append::<proc_macro2::TokenTree>(move _69, move _66) -> [return: bb35, unwind: bb72];
    }

    bb35: {
        _79 = const false;
        _80 = const false;
        drop(_54) -> [return: bb70, unwind: bb93];
    }

    bb36: {
        drop(_6) -> [return: bb37, unwind: bb45];
    }

    bb37: {
        _0 = move _4;
        drop(_3) -> [return: bb38, unwind continue];
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_54) -> [return: bb93, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_50) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_40) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_30) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_25) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_15) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_4) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_3) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }

    bb48 (cleanup): {
        switchInt(_73) -> [0: bb88, otherwise: bb52];
    }

    bb49 (cleanup): {
        switchInt(_74) -> [0: bb88, otherwise: bb51];
    }

    bb50 (cleanup): {
        drop((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree)) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        _83 = discriminant((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _83) -> [1: bb88, otherwise: bb50];
    }

    bb52 (cleanup): {
        _84 = discriminant((_14.1: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _84) -> [1: bb49, otherwise: bb88];
    }

    bb53: {
        _73 = const false;
        _73 = const false;
        _74 = const false;
        _81 = const false;
        _75 = const false;
        _76 = const false;
        switchInt(_77) -> [0: bb27, otherwise: bb66];
    }

    bb54: {
        switchInt(_74) -> [0: bb55, otherwise: bb57];
    }

    bb55: {
        _74 = const false;
        goto -> bb53;
    }

    bb56: {
        drop((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree)) -> [return: bb55, unwind: bb88];
    }

    bb57: {
        _85 = discriminant((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _85) -> [1: bb55, otherwise: bb56];
    }

    bb58: {
        _86 = discriminant((_14.1: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _86) -> [1: bb54, otherwise: bb53];
    }

    bb59: {
        _75 = const false;
        switchInt(_73) -> [0: bb53, otherwise: bb58];
    }

    bb60: {
        switchInt(_76) -> [0: bb61, otherwise: bb63];
    }

    bb61: {
        _76 = const false;
        goto -> bb59;
    }

    bb62: {
        drop((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree)) -> [return: bb61, unwind: bb48];
    }

    bb63: {
        _87 = discriminant((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _87) -> [2: bb61, otherwise: bb62];
    }

    bb64: {
        _88 = discriminant((_14.0: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _88) -> [1: bb60, otherwise: bb59];
    }

    bb65: {
        switchInt(_75) -> [0: bb59, otherwise: bb64];
    }

    bb66: {
        drop(_11) -> [return: bb27, unwind: bb93];
    }

    bb67: {
        _78 = const false;
        _78 = const false;
        _82 = const false;
        goto -> bb2;
    }

    bb68: {
        drop(_9) -> [return: bb67, unwind: bb45];
    }

    bb69: {
        _89 = discriminant(_9);
        switchInt(move _89) -> [0: bb67, 1: bb67, otherwise: bb68];
    }

    bb70: {
        switchInt(_78) -> [0: bb67, otherwise: bb69];
    }

    bb71 (cleanup): {
        drop(_58) -> [return: bb74, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        switchInt(_79) -> [0: bb74, otherwise: bb71];
    }

    bb73 (cleanup): {
        drop(_55) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        switchInt(_80) -> [0: bb39, otherwise: bb73];
    }

    bb75 (cleanup): {
        switchInt(_73) -> [0: bb88, otherwise: bb81];
    }

    bb76 (cleanup): {
        switchInt(_74) -> [0: bb88, otherwise: bb80];
    }

    bb77 (cleanup): {
        switchInt(_81) -> [0: bb88, otherwise: bb78];
    }

    bb78 (cleanup): {
        drop((((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree) as Ident).0: proc_macro2::Ident)) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        drop((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree)) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb80 (cleanup): {
        _90 = discriminant((((_14.1: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _90) -> [1: bb77, otherwise: bb79];
    }

    bb81 (cleanup): {
        _91 = discriminant((_14.1: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _91) -> [1: bb76, otherwise: bb88];
    }

    bb82 (cleanup): {
        switchInt(_76) -> [0: bb75, otherwise: bb84];
    }

    bb83 (cleanup): {
        drop((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree)) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb84 (cleanup): {
        _92 = discriminant((((_14.0: std::option::Option<proc_macro2::TokenTree>) as Some).0: proc_macro2::TokenTree));
        switchInt(move _92) -> [2: bb75, otherwise: bb83];
    }

    bb85 (cleanup): {
        _93 = discriminant((_14.0: std::option::Option<proc_macro2::TokenTree>));
        switchInt(move _93) -> [1: bb82, otherwise: bb75];
    }

    bb86 (cleanup): {
        switchInt(_75) -> [0: bb75, otherwise: bb85];
    }

    bb87 (cleanup): {
        drop(_11) -> [return: bb93, unwind terminate(cleanup)];
    }

    bb88 (cleanup): {
        switchInt(_77) -> [0: bb93, otherwise: bb87];
    }

    bb89 (cleanup): {
        switchInt(_82) -> [0: bb45, otherwise: bb90];
    }

    bb90 (cleanup): {
        drop(((_9 as Ident).0: proc_macro2::Ident)) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb91 (cleanup): {
        drop(_9) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        _94 = discriminant(_9);
        switchInt(move _94) -> [0: bb45, 1: bb89, otherwise: bb91];
    }

    bb93 (cleanup): {
        switchInt(_78) -> [0: bb45, otherwise: bb92];
    }

    bb94: {
        goto -> bb2;
    }

    bb95: {
        goto -> bb70;
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:210:1: 210:27>::visit_token_stream: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "self";
        _0 = &_1;
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:244:1: 244:40>::visit_expr_call_mut(_1: &mut ValidationMutator<'_>, _2: &mut ExprCall) -> () {
    debug self => _1;
    debug call => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: bool;
    let _5: &proc_macro2::Ident;
    let _6: &proc_macro2::Ident;
    let mut _7: (&proc_macro2::Ident, &proc_macro2::Ident);
    let mut _8: &proc_macro2::Ident;
    let mut _9: &proc_macro2::Ident;
    let mut _11: std::result::Result<syn::Expr, syn::Error>;
    let mut _12: proc_macro2::TokenStream;
    let mut _15: &proc_macro2::Ident;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let _19: &&proc_macro2::Ident;
    let mut _20: &mut proc_macro2::TokenStream;
    let mut _22: proc_macro2::Ident;
    let mut _23: proc_macro2::Span;
    let mut _24: &proc_macro2::Ident;
    let mut _25: std::result::Result<syn::Expr, syn::Error>;
    let mut _26: proc_macro2::TokenStream;
    let mut _29: &proc_macro2::Ident;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let _33: &proc_macro2::Ident;
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let _38: &&proc_macro2::Ident;
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut syn::punctuated::Punctuated<syn::Expr, syn::token::Comma>;
    let mut _42: syn::Expr;
    let mut _43: bool;
    scope 1 {
        debug parent => _5;
        debug field => _6;
        let _10: syn::Expr;
        let mut _13: proc_macro2::TokenStream;
        let _21: proc_macro2::Ident;
        scope 2 {
            debug form_field => _10;
        }
        scope 3 {
            debug _s => _13;
            let _14: proc_macro2::Span;
            scope 4 {
                debug _span => _14;
            }
        }
        scope 5 {
            debug parent => _21;
            let mut _27: proc_macro2::TokenStream;
            scope 6 {
                debug _s => _27;
                let _28: proc_macro2::Span;
                scope 7 {
                    debug _span => _28;
                }
            }
        }
    }

    bb0: {
        _43 = const false;
        _3 = syn::visit_mut::visit_expr_call_mut::<ValidationMutator<'_>>(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ((*_1).3: bool);
        switchInt(move _4) -> [0: bb2, otherwise: bb23];
    }

    bb2: {
        _8 = ((*_1).1: &proc_macro2::Ident);
        _9 = ((*_1).0: &proc_macro2::Ident);
        _7 = (move _8, move _9);
        _5 = (_7.0: &proc_macro2::Ident);
        _6 = (_7.1: &proc_macro2::Ident);
        switchInt(((*_1).2: bool)) -> [0: bb3, otherwise: bb4];
    }

    bb3: {
        _43 = const true;
        _22 = <proc_macro2::Ident as Clone>::clone(_5) -> [return: bb10, unwind continue];
    }

    bb4: {
        _13 = TokenStream2::new() -> [return: bb5, unwind continue];
    }

    bb5: {
        _15 = _6;
        _14 = proc_macro2::Ident::span(move _15) -> [return: bb6, unwind: bb26];
    }

    bb6: {
        _17 = &mut _13;
        _16 = push_and_spanned(_17, _14) -> [return: bb7, unwind: bb26];
    }

    bb7: {
        _19 = &_6;
        _20 = &mut _13;
        _18 = <&proc_macro2::Ident as ToTokens>::to_tokens(_19, _20) -> [return: bb8, unwind: bb26];
    }

    bb8: {
        _12 = move _13;
        _11 = syn::parse2::<syn::Expr>(move _12) -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = std::result::Result::<syn::Expr, syn::Error>::unwrap(move _11) -> [return: bb21, unwind continue];
    }

    bb10: {
        _24 = _6;
        _23 = proc_macro2::Ident::span(move _24) -> [return: bb11, unwind: bb29];
    }

    bb11: {
        _43 = const false;
        _21 = <proc_macro2::Ident as syn_ext::IdentExt>::with_span(move _22, move _23) -> [return: bb12, unwind: bb29];
    }

    bb12: {
        _43 = const false;
        _27 = TokenStream2::new() -> [return: bb13, unwind: bb25];
    }

    bb13: {
        _29 = _6;
        _28 = proc_macro2::Ident::span(move _29) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _31 = &mut _27;
        _30 = push_and_spanned(_31, _28) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _33 = &_21;
        _34 = &mut _27;
        _32 = <proc_macro2::Ident as ToTokens>::to_tokens(_33, _34) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _36 = &mut _27;
        _35 = push_dot_spanned(_36, _28) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _38 = &_6;
        _39 = &mut _27;
        _37 = <&proc_macro2::Ident as ToTokens>::to_tokens(_38, _39) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _26 = move _27;
        _25 = syn::parse2::<syn::Expr>(move _26) -> [return: bb19, unwind: bb25];
    }

    bb19: {
        _10 = std::result::Result::<syn::Expr, syn::Error>::unwrap(move _25) -> [return: bb20, unwind: bb25];
    }

    bb20: {
        drop(_21) -> [return: bb21, unwind continue];
    }

    bb21: {
        _41 = &mut ((*_2).3: syn::punctuated::Punctuated<syn::Expr, syn::token::Comma>);
        _42 = move _10;
        _40 = syn::punctuated::Punctuated::<syn::Expr, syn::token::Comma>::insert(move _41, const 0_usize, move _42) -> [return: bb22, unwind continue];
    }

    bb22: {
        ((*_1).3: bool) = const true;
        goto -> bb23;
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_27) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_21) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_13) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }

    bb28 (cleanup): {
        drop(_22) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        switchInt(_43) -> [0: bb27, otherwise: bb28];
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:244:1: 244:40>::visit_ident_mut(_1: &mut ValidationMutator<'_>, _2: &mut proc_macro2::Ident) -> () {
    debug self => _1;
    debug i => _2;
    let mut _0: ();
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: &&mut proc_macro2::Ident;
    let mut _6: proc_macro2::Ident;
    let mut _7: proc_macro2::Ident;
    let mut _8: proc_macro2::Span;
    let mut _9: &&mut proc_macro2::Ident;
    let mut _10: &&str;
    let mut _11: &proc_macro2::Ident;
    let mut _12: bool;

    bb0: {
        _12 = const false;
        _3 = ((*_1).2: bool);
        switchInt(move _3) -> [0: bb1, otherwise: bb9];
    }

    bb1: {
        _5 = &_2;
        _10 = const _;
        _4 = <&mut proc_macro2::Ident as PartialEq<&str>>::eq(move _5, _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb9, otherwise: bb3];
    }

    bb3: {
        _11 = deref_copy ((*_1).1: &proc_macro2::Ident);
        _12 = const true;
        _7 = <proc_macro2::Ident as Clone>::clone(_11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = &_2;
        _8 = <&mut proc_macro2::Ident as devise::Spanned>::span(move _9) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _12 = const false;
        _6 = <proc_macro2::Ident as syn_ext::IdentExt>::with_span(move _7, move _8) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _12 = const false;
        drop((*_2)) -> [return: bb7, unwind: bb8];
    }

    bb7: {
        (*_2) = move _6;
        goto -> bb9;
    }

    bb8 (cleanup): {
        (*_2) = move _6;
        goto -> bb10;
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        resume;
    }

    bb11 (cleanup): {
        drop(_7) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        switchInt(_12) -> [0: bb10, otherwise: bb11];
    }
}

promoted[0] in form_field::<impl at core/codegen/src/derive/form_field.rs:244:1: 244:40>::visit_ident_mut: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "self";
        _0 = &_1;
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:244:1: 244:40>::visit_macro_mut(_1: &mut ValidationMutator<'_>, _2: &mut syn::Macro) -> () {
    debug self => _1;
    debug mac => _2;
    let mut _0: ();
    let mut _3: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: &proc_macro2::TokenStream;
    let _6: ();

    bb0: {
        _5 = &((*_2).3: proc_macro2::TokenStream);
        _4 = <TokenStream2 as Clone>::clone(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = ValidationMutator::<'_>::visit_token_stream(_1, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        drop(((*_2).3: proc_macro2::TokenStream)) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        ((*_2).3: proc_macro2::TokenStream) = move _3;
        _6 = syn::visit_mut::visit_macro_mut::<ValidationMutator<'_>>(_1, _2) -> [return: bb5, unwind continue];
    }

    bb4 (cleanup): {
        ((*_2).3: proc_macro2::TokenStream) = move _3;
        resume;
    }

    bb5: {
        return;
    }
}

fn form_field::<impl at core/codegen/src/derive/form_field.rs:244:1: 244:40>::visit_expr_mut(_1: &mut ValidationMutator<'_>, _2: &mut syn::Expr) -> () {
    debug self => _1;
    debug i => _2;
    let mut _0: ();
    let mut _3: isize;
    let mut _5: &syn::Expr;
    let mut _6: isize;
    let mut _8: bool;
    let mut _9: &syn::Path;
    let _10: &str;
    let mut _11: bool;
    let mut _13: syn::Expr;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let _17: &&&proc_macro2::Ident;
    let mut _18: &mut proc_macro2::TokenStream;
    let mut _19: std::boxed::Box<syn::Expr>;
    let mut _20: *const syn::Expr;
    scope 1 {
        debug e => _4;
        let _4: &mut syn::ExprField;
        scope 2 {
            debug e => _7;
            let _7: &syn::ExprPath;
            let _12: &&proc_macro2::Ident;
            scope 3 {
                debug new_expr => _12;
                let mut _15: proc_macro2::TokenStream;
                scope 4 {
                    debug _s => _15;
                }
            }
        }
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [13: bb1, otherwise: bb11];
    }

    bb1: {
        _4 = &mut (((*_2) as Field).0: syn::ExprField);
        _19 = deref_copy ((*_4).1: std::boxed::Box<syn::Expr>);
        _20 = (((_19.0: std::ptr::Unique<syn::Expr>).0: std::ptr::NonNull<syn::Expr>).0: *const syn::Expr);
        _5 = &(*_20);
        _6 = discriminant((*_5));
        switchInt(move _6) -> [25: bb2, otherwise: bb11];
    }

    bb2: {
        _7 = &(((*_5) as Path).0: syn::ExprPath);
        _9 = &((*_7).2: syn::Path);
        _10 = const "self";
        _8 = syn::path::parsing::<impl syn::Path>::is_ident::<str>(move _9, _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _8) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _11 = ((*_1).2: bool);
        switchInt(move _11) -> [0: bb11, otherwise: bb5];
    }

    bb5: {
        _12 = &((*_1).0: &proc_macro2::Ident);
        _15 = TokenStream2::new() -> [return: bb6, unwind continue];
    }

    bb6: {
        _17 = &_12;
        _18 = &mut _15;
        _16 = <&&proc_macro2::Ident as ToTokens>::to_tokens(_17, _18) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _14 = move _15;
        _13 = syn::parse_quote::parse::<syn::Expr>(move _14) -> [return: bb8, unwind continue];
    }

    bb8: {
        drop((*_2)) -> [return: bb9, unwind: bb10];
    }

    bb9: {
        (*_2) = move _13;
        goto -> bb11;
    }

    bb10 (cleanup): {
        (*_2) = move _13;
        goto -> bb14;
    }

    bb11: {
        _0 = syn::visit_mut::visit_expr_mut::<ValidationMutator<'_>>(_1, _2) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_15) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn form_field::validators(_1: devise::Field<'_>, _2: &proc_macro2::Ident, _3: bool) -> std::result::Result<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic> {
    debug field => _1;
    debug parent => _2;
    debug local => _3;
    let mut _0: std::result::Result<std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic>;
    let _4: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
    let mut _5: std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>;
    let mut _6: std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>;
    let mut _7: std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>;
    let mut _8: std::vec::IntoIter<derive::form_field::FieldAttr>;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldAttr>>;
    let mut _10: std::result::Result<std::vec::Vec<derive::form_field::FieldAttr>, devise::Diagnostic>;
    let _11: &str;
    let _12: &[syn::Attribute];
    let _13: &std::vec::Vec<syn::Attribute>;
    let _14: &syn::Field;
    let _15: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _16: &devise::Field<'_>;
    let mut _17: isize;
    let _18: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _19: std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _20: {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25};
    let mut _21: {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37};
    let mut _22: {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34};
    scope 1 {
        debug exprs => _4;
    }
    scope 2 {
        debug residual => _18;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _19;
        scope 5 {
        }
    }

    bb0: {
        _11 = const _;
        _16 = &_1;
        _15 = <devise::Field<'_> as std::ops::Deref>::deref(move _16) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_15) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = &((*_14).0: std::vec::Vec<syn::Attribute>);
        _12 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_13) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = <form_field::FieldAttr as devise::FromMeta>::from_attrs(_11, _12) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = <std::result::Result<Vec<form_field::FieldAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = discriminant(_9);
        switchInt(move _17) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _19 = move ((_9 as Continue).0: std::vec::Vec<derive::form_field::FieldAttr>);
        _8 = <Vec<form_field::FieldAttr> as IntoIterator>::into_iter(move _19) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _18 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _18) -> [return: bb14, unwind continue];
    }

    bb9: {
        _7 = <std::vec::IntoIter<form_field::FieldAttr> as Iterator>::filter_map::<devise::SpanWrapped<syn::Expr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>(move _8, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}) -> [return: bb10, unwind continue];
    }

    bb10: {
        _20 = {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25} { field: _1 };
        _6 = <FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}> as Iterator>::map::<(devise::SpanWrapped<syn::Expr>, bool), {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>(move _7, move _20) -> [return: bb11, unwind continue];
    }

    bb11: {
        _21 = {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37} { local: _3 };
        _5 = <Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}> as Iterator>::filter::<{closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>(move _6, move _21) -> [return: bb12, unwind continue];
    }

    bb12: {
        _22 = {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34} { field: _1, parent: _2, local: _3 };
        _4 = <Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}> as Iterator>::map::<syn::Expr, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>(move _5, move _22) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = std::result::Result::<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic>::Ok(move _4);
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn form_field::validators::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}, _2: form_field::FieldAttr) -> Option<devise::SpanWrapped<syn::Expr>> {
    debug a => _2;
    let mut _0: std::option::Option<devise::SpanWrapped<syn::Expr>>;

    bb0: {
        _0 = move (_2.1: std::option::Option<devise::SpanWrapped<syn::Expr>>);
        drop((_2.0: std::option::Option<derive::form_field::FieldName>)) -> [return: bb6, unwind: bb4];
    }

    bb1 (cleanup): {
        resume;
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop((_2.3: std::option::Option<syn::Expr>)) -> [return: bb1, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        drop((_2.2: std::option::Option<syn::Expr>)) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5: {
        drop((_2.3: std::option::Option<syn::Expr>)) -> [return: bb2, unwind continue];
    }

    bb6: {
        drop((_2.2: std::option::Option<syn::Expr>)) -> [return: bb5, unwind: bb3];
    }
}

fn form_field::validators::{closure#1}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}, _2: devise::SpanWrapped<syn::Expr>) -> (devise::SpanWrapped<syn::Expr>, bool) {
    debug expr => _2;
    debug field => ((*_1).0: devise::Field<'_>);
    let mut _0: (devise::SpanWrapped<syn::Expr>, bool);
    let mut _3: derive::form_field::RecordMemberAccesses;
    let mut _4: std::vec::Vec<syn::Member>;
    let _5: ();
    let mut _6: &mut derive::form_field::RecordMemberAccesses;
    let _7: &syn::Expr;
    let _8: &devise::SpanWrapped<syn::Expr>;
    let mut _10: &devise::Field<'_>;
    let mut _12: &mut std::slice::Iter<'_, syn::Member>;
    let mut _13: std::slice::Iter<'_, syn::Member>;
    let _14: &[syn::Member];
    let mut _15: &std::vec::Vec<syn::Member>;
    let mut _16: {closure@core/codegen/src/derive/form_field.rs:304:22: 304:30};
    let mut _17: &&proc_macro2::Ident;
    let mut _18: devise::SpanWrapped<syn::Expr>;
    let mut _19: bool;
    scope 1 {
        debug members => _3;
        let _9: &proc_macro2::Ident;
        scope 2 {
            debug field_ident => _9;
            let _11: bool;
            scope 3 {
                debug is_local_validation => _11;
            }
        }
    }

    bb0: {
        _19 = const false;
        _19 = const true;
        _4 = Vec::<Member>::new() -> [return: bb1, unwind: bb12];
    }

    bb1: {
        _3 = RecordMemberAccesses(move _4);
        _6 = &mut _3;
        _8 = &_2;
        _7 = <devise::SpanWrapped<syn::Expr> as std::ops::Deref>::deref(_8) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _5 = <RecordMemberAccesses as Visit<'_>>::visit_expr(move _6, _7) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _10 = &((*_1).0: devise::Field<'_>);
        _9 = <devise::Field<'_> as form_field::FieldExt>::ident(move _10) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _15 = &(_3.0: std::vec::Vec<syn::Member>);
        _14 = <Vec<Member> as std::ops::Deref>::deref(move _15) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _13 = core::slice::<impl [Member]>::iter(_14) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _12 = &mut _13;
        _17 = &_9;
        _16 = {closure@core/codegen/src/derive/form_field.rs:304:22: 304:30} { field_ident: move _17 };
        _11 = <std::slice::Iter<'_, Member> as Iterator>::all::<{closure@core/codegen/src/derive/form_field.rs:304:22: 304:30}>(move _12, move _16) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _19 = const false;
        _18 = move _2;
        _0 = (move _18, _11);
        drop(_3) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        switchInt(_19) -> [0: bb10, otherwise: bb11];
    }
}

fn form_field::validators::{closure#1}::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:304:22: 304:30}, _2: &Member) -> bool {
    debug member => _2;
    debug field_ident => (*((*_1).0: &&proc_macro2::Ident));
    let mut _0: bool;
    let mut _3: isize;
    let _4: &proc_macro2::Ident;
    let mut _5: &&proc_macro2::Ident;
    let mut _6: &&proc_macro2::Ident;
    scope 1 {
        debug i => _4;
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = const false;
        goto -> bb3;
    }

    bb2: {
        _4 = &(((*_2) as Named).0: proc_macro2::Ident);
        _5 = &_4;
        _6 = deref_copy ((*_1).0: &&proc_macro2::Ident);
        _0 = <&proc_macro2::Ident as PartialEq>::eq(move _5, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn form_field::validators::{closure#2}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}, _2: &(devise::SpanWrapped<syn::Expr>, bool)) -> bool {
    debug local => ((*_1).0: bool);
    let mut _0: bool;
    let _3: &bool;
    let mut _4: bool;
    let mut _5: bool;
    scope 1 {
        debug is_local => _3;
    }

    bb0: {
        _3 = &((*_2).1: bool);
        _4 = (*_3);
        _5 = ((*_1).0: bool);
        _0 = Eq(move _4, move _5);
        return;
    }
}

fn form_field::validators::{closure#3}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}, _2: (devise::SpanWrapped<syn::Expr>, bool)) -> syn::Expr {
    debug field => ((*_1).0: devise::Field<'_>);
    debug parent => ((*_1).1: &proc_macro2::Ident);
    debug local => ((*_1).2: bool);
    let mut _0: syn::Expr;
    let mut _3: devise::SpanWrapped<syn::Expr>;
    let mut _5: std::option::Option<proc_macro2::Span>;
    let mut _6: &proc_macro2::Span;
    let _7: proc_macro2::Span;
    let _8: &proc_macro2::Ident;
    let mut _9: &devise::Field<'_>;
    let mut _10: proc_macro2::Span;
    let mut _11: &syn::Type;
    let _12: &syn::Field;
    let _13: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _14: &devise::Field<'_>;
    let mut _15: proc_macro2::Span;
    let mut _16: &syn::Type;
    let _17: &syn::Field;
    let _18: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _19: &devise::Field<'_>;
    let _21: proc_macro2::Ident;
    let mut _22: proc_macro2::Ident;
    let _23: &proc_macro2::Ident;
    let mut _24: &devise::Field<'_>;
    let mut _26: bool;
    let _27: ();
    let mut _28: &mut derive::form_field::ValidationMutator<'_>;
    let mut _29: &mut syn::Expr;
    let mut _30: &mut devise::SpanWrapped<syn::Expr>;
    let mut _32: std::option::Option<proc_macro2::Span>;
    let mut _34: std::option::Option<proc_macro2::Span>;
    let mut _35: std::result::Result<syn::Expr, syn::Error>;
    let mut _36: proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let mut _40: proc_macro2::Delimiter;
    let mut _41: proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let _52: &exports::StaticPath;
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let mut _68: proc_macro2::Delimiter;
    let mut _69: proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let _75: &devise::SpanWrapped<syn::Expr>;
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: &str;
    let mut _82: &proc_macro2::Ident;
    scope 1 {
        debug expr => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug field_span => _4;
            let _20: &proc_macro2::Ident;
            scope 3 {
                debug field => _20;
                let mut _25: derive::form_field::ValidationMutator<'_>;
                scope 4 {
                    debug v => _25;
                    let _31: proc_macro2::Span;
                    scope 5 {
                        debug span => _31;
                        scope 6 {
                            debug _form => _33;
                            let mut _37: proc_macro2::TokenStream;
                            scope 8 {
                                debug _s => _37;
                                scope 9 {
                                    debug _span => _31;
                                    let mut _42: proc_macro2::TokenStream;
                                    scope 10 {
                                        debug _s => _42;
                                        scope 11 {
                                            debug _span => _31;
                                            scope 12 {
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        scope 7 {
                            let _33: exports::StaticPath;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = move (_2.0: devise::SpanWrapped<syn::Expr>);
        _9 = &((*_1).0: devise::Field<'_>);
        _8 = <devise::Field<'_> as form_field::FieldExt>::ident(move _9) -> [return: bb1, unwind: bb43];
    }

    bb1: {
        _7 = proc_macro2::Ident::span(_8) -> [return: bb2, unwind: bb43];
    }

    bb2: {
        _6 = &_7;
        _14 = &((*_1).0: devise::Field<'_>);
        _13 = <devise::Field<'_> as std::ops::Deref>::deref(move _14) -> [return: bb3, unwind: bb43];
    }

    bb3: {
        _12 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_13) -> [return: bb4, unwind: bb43];
    }

    bb4: {
        _11 = &((*_12).4: syn::Type);
        _10 = <syn::Type as devise::Spanned>::span(move _11) -> [return: bb5, unwind: bb43];
    }

    bb5: {
        _5 = proc_macro2::Span::join(move _6, move _10) -> [return: bb6, unwind: bb43];
    }

    bb6: {
        _19 = &((*_1).0: devise::Field<'_>);
        _18 = <devise::Field<'_> as std::ops::Deref>::deref(move _19) -> [return: bb7, unwind: bb43];
    }

    bb7: {
        _17 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_18) -> [return: bb8, unwind: bb43];
    }

    bb8: {
        _16 = &((*_17).4: syn::Type);
        _15 = <syn::Type as devise::Spanned>::span(move _16) -> [return: bb9, unwind: bb43];
    }

    bb9: {
        _4 = Option::<proc_macro2::Span>::unwrap_or(move _5, move _15) -> [return: bb10, unwind: bb43];
    }

    bb10: {
        _24 = &((*_1).0: devise::Field<'_>);
        _23 = <devise::Field<'_> as form_field::FieldExt>::ident(move _24) -> [return: bb11, unwind: bb43];
    }

    bb11: {
        _22 = <proc_macro2::Ident as Clone>::clone(_23) -> [return: bb12, unwind: bb43];
    }

    bb12: {
        _21 = <proc_macro2::Ident as syn_ext::IdentExt>::with_span(move _22, _4) -> [return: bb13, unwind: bb43];
    }

    bb13: {
        _20 = &_21;
        _82 = deref_copy ((*_1).1: &proc_macro2::Ident);
        _26 = ((*_1).2: bool);
        _25 = ValidationMutator::<'_> { field: _20, parent: _82, local: move _26, visited: const false };
        _28 = &mut _25;
        _30 = &mut _3;
        _29 = <devise::SpanWrapped<syn::Expr> as DerefMut>::deref_mut(_30) -> [return: bb14, unwind: bb42];
    }

    bb14: {
        _27 = <ValidationMutator<'_> as VisitMut>::visit_expr_mut(move _28, _29) -> [return: bb15, unwind: bb42];
    }

    bb15: {
        _32 = (_3.1: std::option::Option<proc_macro2::Span>);
        _31 = Option::<proc_macro2::Span>::unwrap_or(move _32, _4) -> [return: bb16, unwind: bb42];
    }

    bb16: {
        _34 = Option::<proc_macro2::Span>::Some(_31);
        _33 = StaticPath(move _34, const "::rocket::form::prelude");
        _37 = TokenStream2::new() -> [return: bb17, unwind: bb42];
    }

    bb17: {
        _39 = &mut _37;
        _40 = proc_macro2::Delimiter::Brace;
        _42 = TokenStream2::new() -> [return: bb18, unwind: bb41];
    }

    bb18: {
        _44 = &mut _42;
        _45 = const "let";
        _43 = push_ident_spanned(_44, _31, _45) -> [return: bb19, unwind: bb40];
    }

    bb19: {
        _47 = &mut _42;
        _48 = const "__result";
        _46 = push_ident_spanned(_47, _31, _48) -> [return: bb20, unwind: bb40];
    }

    bb20: {
        _50 = &mut _42;
        _49 = push_colon_spanned(_50, _31) -> [return: bb21, unwind: bb40];
    }

    bb21: {
        _52 = &_33;
        _53 = &mut _42;
        _51 = <StaticPath as ToTokens>::to_tokens(_52, _53) -> [return: bb22, unwind: bb40];
    }

    bb22: {
        _55 = &mut _42;
        _54 = push_colon2_spanned(_55, _31) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        _57 = &mut _42;
        _58 = const "Result";
        _56 = push_ident_spanned(_57, _31, _58) -> [return: bb24, unwind: bb40];
    }

    bb24: {
        _60 = &mut _42;
        _59 = push_lt_spanned(_60, _31) -> [return: bb25, unwind: bb40];
    }

    bb25: {
        _62 = &mut _42;
        _63 = const "'_";
        _61 = push_lifetime_spanned(_62, _31, _63) -> [return: bb26, unwind: bb40];
    }

    bb26: {
        _65 = &mut _42;
        _64 = push_comma_spanned(_65, _31) -> [return: bb27, unwind: bb40];
    }

    bb27: {
        _67 = &mut _42;
        _68 = proc_macro2::Delimiter::Parenthesis;
        _69 = TokenStream2::new() -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _66 = push_group_spanned(_67, _31, move _68, move _69) -> [return: bb29, unwind: bb40];
    }

    bb29: {
        _71 = &mut _42;
        _70 = push_gt_spanned(_71, _31) -> [return: bb30, unwind: bb40];
    }

    bb30: {
        _73 = &mut _42;
        _72 = push_eq_spanned(_73, _31) -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _75 = &_3;
        _76 = &mut _42;
        _74 = <devise::SpanWrapped<syn::Expr> as ToTokens>::to_tokens(_75, _76) -> [return: bb32, unwind: bb40];
    }

    bb32: {
        _78 = &mut _42;
        _77 = push_semi_spanned(_78, _31) -> [return: bb33, unwind: bb40];
    }

    bb33: {
        _80 = &mut _42;
        _81 = const "__result";
        _79 = push_ident_spanned(_80, _31, _81) -> [return: bb34, unwind: bb40];
    }

    bb34: {
        _41 = move _42;
        _38 = push_group_spanned(_39, _31, move _40, move _41) -> [return: bb35, unwind: bb41];
    }

    bb35: {
        _36 = move _37;
        _35 = syn::parse2::<syn::Expr>(move _36) -> [return: bb36, unwind: bb42];
    }

    bb36: {
        _0 = std::result::Result::<syn::Expr, syn::Error>::unwrap(move _35) -> [return: bb37, unwind: bb42];
    }

    bb37: {
        drop(_21) -> [return: bb38, unwind: bb43];
    }

    bb38: {
        drop(_3) -> [return: bb39, unwind continue];
    }

    bb39: {
        return;
    }

    bb40 (cleanup): {
        drop(_42) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_37) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_21) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_3) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        resume;
    }
}

fn default_expr(_1: &syn::Expr) -> TokenStream2 {
    debug expr => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: bool;
    let mut _3: isize;
    let _4: &syn::ExprPath;
    let _5: &&syn::ExprPath;
    let mut _6: bool;
    let mut _7: &syn::Path;
    let _8: &str;
    let mut _9: proc_macro2::TokenStream;
    let _10: ();
    let _11: &&syn::Expr;
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: bool;
    let mut _14: isize;
    let mut _15: isize;
    let mut _16: proc_macro2::TokenStream;
    let mut _18: &syn::Expr;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &str;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let mut _24: proc_macro2::Delimiter;
    let mut _25: proc_macro2::TokenStream;
    let _27: ();
    let _28: &&syn::Expr;
    let mut _29: &mut proc_macro2::TokenStream;
    let mut _30: proc_macro2::TokenStream;
    let mut _32: &syn::Expr;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let mut _38: proc_macro2::Delimiter;
    let mut _39: proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let mut _43: proc_macro2::Delimiter;
    let mut _44: proc_macro2::TokenStream;
    let _46: ();
    let _47: &&syn::Expr;
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let mut _56: proc_macro2::Delimiter;
    let mut _57: proc_macro2::TokenStream;
    let mut _58: &syn::ExprPath;
    scope 1 {
        debug e => _4;
        debug e => _5;
    }
    scope 2 {
        debug _s => _9;
    }
    scope 3 {
        debug _s => _16;
        let _17: proc_macro2::Span;
        scope 4 {
            debug _span => _17;
            let mut _26: proc_macro2::TokenStream;
            scope 5 {
                debug _s => _26;
                scope 6 {
                }
            }
        }
    }
    scope 7 {
        debug _s => _30;
        let _31: proc_macro2::Span;
        scope 8 {
            debug _span => _31;
            let mut _40: proc_macro2::TokenStream;
            scope 9 {
                debug _s => _40;
                scope 10 {
                    debug _span => _31;
                    let mut _45: proc_macro2::TokenStream;
                    scope 11 {
                        debug _s => _45;
                        scope 12 {
                        }
                    }
                    scope 13 {
                    }
                }
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [25: bb2, otherwise: bb1];
    }

    bb1: {
        _2 = const false;
        goto -> bb5;
    }

    bb2: {
        _4 = &(((*_1) as Path).0: syn::ExprPath);
        _5 = &_4;
        _58 = deref_copy (*_5);
        _7 = &((*_58).2: syn::Path);
        _8 = const "None";
        _6 = syn::path::parsing::<impl syn::Path>::is_ident::<str>(move _7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb1, otherwise: bb4];
    }

    bb4: {
        _2 = const true;
        goto -> bb5;
    }

    bb5: {
        switchInt(move _2) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _9 = TokenStream2::new() -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = &_1;
        _12 = &mut _9;
        _10 = <&syn::Expr as ToTokens>::to_tokens(_11, _12) -> [return: bb8, unwind: bb39];
    }

    bb8: {
        _0 = move _9;
        goto -> bb33;
    }

    bb9: {
        _15 = discriminant((*_1));
        switchInt(move _15) -> [19: bb11, otherwise: bb10];
    }

    bb10: {
        _13 = const false;
        goto -> bb12;
    }

    bb11: {
        _14 = discriminant(((((*_1) as Lit).0: syn::ExprLit).1: syn::Lit));
        _13 = Eq(_14, const 4_isize);
        goto -> bb12;
    }

    bb12: {
        switchInt(move _13) -> [0: bb20, otherwise: bb13];
    }

    bb13: {
        _16 = TokenStream2::new() -> [return: bb14, unwind continue];
    }

    bb14: {
        _18 = _1;
        _17 = <syn::Expr as devise::Spanned>::span(move _18) -> [return: bb15, unwind: bb38];
    }

    bb15: {
        _20 = &mut _16;
        _21 = const "Some";
        _19 = push_ident_spanned(_20, _17, _21) -> [return: bb16, unwind: bb38];
    }

    bb16: {
        _23 = &mut _16;
        _24 = proc_macro2::Delimiter::Parenthesis;
        _26 = TokenStream2::new() -> [return: bb17, unwind: bb38];
    }

    bb17: {
        _28 = &_1;
        _29 = &mut _26;
        _27 = <&syn::Expr as ToTokens>::to_tokens(_28, _29) -> [return: bb18, unwind: bb37];
    }

    bb18: {
        _25 = move _26;
        _22 = push_group_spanned(_23, _17, move _24, move _25) -> [return: bb19, unwind: bb38];
    }

    bb19: {
        _0 = move _16;
        goto -> bb33;
    }

    bb20: {
        _30 = TokenStream2::new() -> [return: bb21, unwind continue];
    }

    bb21: {
        _32 = _1;
        _31 = <syn::Expr as devise::Spanned>::span(move _32) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        _34 = &mut _30;
        _35 = const "Some";
        _33 = push_ident_spanned(_34, _31, _35) -> [return: bb23, unwind: bb36];
    }

    bb23: {
        _37 = &mut _30;
        _38 = proc_macro2::Delimiter::Parenthesis;
        _40 = TokenStream2::new() -> [return: bb24, unwind: bb36];
    }

    bb24: {
        _42 = &mut _40;
        _43 = proc_macro2::Delimiter::Brace;
        _45 = TokenStream2::new() -> [return: bb25, unwind: bb35];
    }

    bb25: {
        _47 = &_1;
        _48 = &mut _45;
        _46 = <&syn::Expr as ToTokens>::to_tokens(_47, _48) -> [return: bb26, unwind: bb34];
    }

    bb26: {
        _44 = move _45;
        _41 = push_group_spanned(_42, _31, move _43, move _44) -> [return: bb27, unwind: bb35];
    }

    bb27: {
        _50 = &mut _40;
        _49 = push_dot_spanned(_50, _31) -> [return: bb28, unwind: bb35];
    }

    bb28: {
        _52 = &mut _40;
        _53 = const "into";
        _51 = push_ident_spanned(_52, _31, _53) -> [return: bb29, unwind: bb35];
    }

    bb29: {
        _55 = &mut _40;
        _56 = proc_macro2::Delimiter::Parenthesis;
        _57 = TokenStream2::new() -> [return: bb30, unwind: bb35];
    }

    bb30: {
        _54 = push_group_spanned(_55, _31, move _56, move _57) -> [return: bb31, unwind: bb35];
    }

    bb31: {
        _39 = move _40;
        _36 = push_group_spanned(_37, _31, move _38, move _39) -> [return: bb32, unwind: bb36];
    }

    bb32: {
        _0 = move _30;
        goto -> bb33;
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_45) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_40) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_30) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_26) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_16) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_9) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        resume;
    }
}

fn form_field::default(_1: devise::Field<'_>) -> std::result::Result<Option<TokenStream2>, devise::Diagnostic> {
    debug field => _1;
    let mut _0: std::result::Result<std::option::Option<proc_macro2::TokenStream>, devise::Diagnostic>;
    let _2: std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldAttr>>;
    let mut _4: std::result::Result<std::vec::Vec<derive::form_field::FieldAttr>, devise::Diagnostic>;
    let _5: &str;
    let _6: &[syn::Attribute];
    let _7: &std::vec::Vec<syn::Attribute>;
    let _8: &syn::Field;
    let _9: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _10: &devise::Field<'_>;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _13: std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _15: std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>;
    let mut _16: std::slice::Iter<'_, derive::form_field::FieldAttr>;
    let _17: &[derive::form_field::FieldAttr];
    let mut _18: &std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _20: std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>;
    let mut _21: std::slice::Iter<'_, derive::form_field::FieldAttr>;
    let _22: &[derive::form_field::FieldAttr];
    let mut _23: &std::vec::Vec<derive::form_field::FieldAttr>;
    let mut _26: (std::option::Option<proc_macro2::TokenStream>, std::option::Option<proc_macro2::TokenStream>);
    let mut _27: std::option::Option<proc_macro2::TokenStream>;
    let mut _28: &mut std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>, for<'a> fn(&'a syn::Expr) -> proc_macro2::TokenStream {derive::form_field::default_expr}>;
    let mut _29: std::option::Option<proc_macro2::TokenStream>;
    let mut _30: &mut std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}>;
    let mut _31: (std::option::Option<proc_macro2::TokenStream>, std::option::Option<proc_macro2::TokenStream>);
    let mut _32: std::option::Option<proc_macro2::TokenStream>;
    let mut _33: &mut std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>, for<'a> fn(&'a syn::Expr) -> proc_macro2::TokenStream {derive::form_field::default_expr}>;
    let mut _34: std::option::Option<proc_macro2::TokenStream>;
    let mut _35: &mut std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}>;
    let mut _36: isize;
    let mut _37: isize;
    let mut _39: devise::Diagnostic;
    let mut _40: devise::Diagnostic;
    let mut _41: proc_macro2::Span;
    let mut _42: &proc_macro2::TokenStream;
    let mut _44: &devise::Field<'_>;
    let mut _45: (std::option::Option<proc_macro2::TokenStream>, std::option::Option<proc_macro2::TokenStream>);
    let mut _46: std::option::Option<proc_macro2::TokenStream>;
    let mut _47: std::option::Option<proc_macro2::TokenStream>;
    let mut _48: isize;
    let mut _49: isize;
    let mut _50: isize;
    let mut _53: devise::Diagnostic;
    let mut _54: devise::Diagnostic;
    let mut _55: devise::Diagnostic;
    let mut _56: proc_macro2::Span;
    let mut _57: &proc_macro2::TokenStream;
    let mut _58: proc_macro2::Span;
    let mut _59: &proc_macro2::TokenStream;
    let mut _61: std::option::Option<proc_macro2::TokenStream>;
    let mut _62: proc_macro2::TokenStream;
    let mut _65: &proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let mut _68: proc_macro2::Delimiter;
    let mut _69: proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: &str;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: &str;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: ();
    let _85: &syn::Type;
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: ();
    let _92: &proc_macro2::TokenStream;
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: ();
    let mut _97: &mut proc_macro2::TokenStream;
    let _98: &str;
    let mut _99: std::option::Option<proc_macro2::TokenStream>;
    let mut _100: bool;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: isize;
    let mut _104: isize;
    let mut _105: isize;
    let mut _106: isize;
    let mut _107: isize;
    scope 1 {
        debug attrs => _2;
        let mut _14: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>, for<'a> fn(&'a syn::Expr) -> proc_macro2::TokenStream {derive::form_field::default_expr}>;
        scope 6 {
            debug expr => _14;
            let mut _19: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}>;
            scope 7 {
                debug expr_with => _19;
                let _24: std::option::Option<proc_macro2::TokenStream>;
                let _25: std::option::Option<proc_macro2::TokenStream>;
                scope 8 {
                    debug default => _24;
                    debug default_with => _25;
                    let _43: syn::Type;
                    scope 9 {
                        debug e => _38;
                        let _38: proc_macro2::TokenStream;
                    }
                    scope 10 {
                        debug ty => _43;
                        let _51: proc_macro2::TokenStream;
                        let _52: proc_macro2::TokenStream;
                        let _60: proc_macro2::TokenStream;
                        scope 11 {
                            debug e1 => _51;
                            debug e2 => _52;
                        }
                        scope 12 {
                            debug e => _60;
                            let mut _63: proc_macro2::TokenStream;
                            scope 13 {
                                debug _s => _63;
                                let _64: proc_macro2::Span;
                                scope 14 {
                                    debug _span => _64;
                                    let mut _70: proc_macro2::TokenStream;
                                    scope 15 {
                                        debug _s => _70;
                                        scope 16 {
                                            debug _span => _64;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }

    bb0: {
        _102 = const false;
        _101 = const false;
        _100 = const false;
        _5 = const _;
        _10 = &_1;
        _9 = <devise::Field<'_> as std::ops::Deref>::deref(move _10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &((*_8).0: std::vec::Vec<syn::Attribute>);
        _6 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <form_field::FieldAttr as devise::FromMeta>::from_attrs(_5, _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<Vec<form_field::FieldAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _11 = discriminant(_3);
        switchInt(move _11) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _13 = move ((_3 as Continue).0: std::vec::Vec<derive::form_field::FieldAttr>);
        _2 = move _13;
        _18 = &_2;
        _17 = <Vec<form_field::FieldAttr> as std::ops::Deref>::deref(move _18) -> [return: bb9, unwind: bb79];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _12 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Option<TokenStream2>, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _12) -> [return: bb66, unwind continue];
    }

    bb9: {
        _16 = core::slice::<impl [form_field::FieldAttr]>::iter(_17) -> [return: bb10, unwind: bb79];
    }

    bb10: {
        _15 = <std::slice::Iter<'_, form_field::FieldAttr> as Iterator>::filter_map::<&syn::Expr, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>(move _16, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}) -> [return: bb11, unwind: bb79];
    }

    bb11: {
        _14 = <FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}> as Iterator>::map::<TokenStream2, for<'a> fn(&'a syn::Expr) -> TokenStream2 {default_expr}>(move _15, default_expr) -> [return: bb12, unwind: bb79];
    }

    bb12: {
        _23 = &_2;
        _22 = <Vec<form_field::FieldAttr> as std::ops::Deref>::deref(move _23) -> [return: bb13, unwind: bb79];
    }

    bb13: {
        _21 = core::slice::<impl [form_field::FieldAttr]>::iter(_22) -> [return: bb14, unwind: bb79];
    }

    bb14: {
        _20 = <std::slice::Iter<'_, form_field::FieldAttr> as Iterator>::filter_map::<&syn::Expr, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>(move _21, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}) -> [return: bb15, unwind: bb79];
    }

    bb15: {
        _19 = <FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}>(move _20, const ZeroSized: {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}) -> [return: bb16, unwind: bb79];
    }

    bb16: {
        _28 = &mut _14;
        _27 = <Map<FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>, for<'a> fn(&'a syn::Expr) -> TokenStream2 {default_expr}> as Iterator>::next(move _28) -> [return: bb17, unwind: bb79];
    }

    bb17: {
        _30 = &mut _19;
        _29 = <Map<FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}> as Iterator>::next(move _30) -> [return: bb18, unwind: bb78];
    }

    bb18: {
        _26 = (move _27, move _29);
        _24 = move (_26.0: std::option::Option<proc_macro2::TokenStream>);
        _25 = move (_26.1: std::option::Option<proc_macro2::TokenStream>);
        _33 = &mut _14;
        _32 = <Map<FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}>, for<'a> fn(&'a syn::Expr) -> TokenStream2 {default_expr}> as Iterator>::next(move _33) -> [return: bb19, unwind: bb76];
    }

    bb19: {
        _35 = &mut _19;
        _34 = <Map<FilterMap<std::slice::Iter<'_, form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}>, {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}> as Iterator>::next(move _35) -> [return: bb20, unwind: bb75];
    }

    bb20: {
        _100 = const true;
        _101 = const true;
        _31 = (move _32, move _34);
        _37 = discriminant((_31.0: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _37) -> [1: bb23, otherwise: bb21];
    }

    bb21: {
        _36 = discriminant((_31.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _36) -> [1: bb24, otherwise: bb28];
    }

    bb22: {
        _42 = &_38;
        _41 = <TokenStream2 as devise::Spanned>::span(move _42) -> [return: bb25, unwind: bb74];
    }

    bb23: {
        _101 = const false;
        _38 = move (((_31.0: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        goto -> bb22;
    }

    bb24: {
        _100 = const false;
        _38 = move (((_31.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        goto -> bb22;
    }

    bb25: {
        _40 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _41, const "duplicate default field expression") -> [return: bb26, unwind: bb74];
    }

    bb26: {
        _39 = devise::Diagnostic::help::<&str>(move _40, const "at most one `default` or `default_with` is allowed") -> [return: bb27, unwind: bb74];
    }

    bb27: {
        _0 = std::result::Result::<Option<TokenStream2>, devise::Diagnostic>::Err(move _39);
        drop(_38) -> [return: bb63, unwind: bb97];
    }

    bb28: {
        drop(_31) -> [return: bb29, unwind: bb76];
    }

    bb29: {
        _100 = const false;
        _101 = const false;
        _44 = &_1;
        _43 = <devise::Field<'_> as form_field::FieldExt>::stripped_ty(move _44) -> [return: bb30, unwind: bb76];
    }

    bb30: {
        _46 = move _24;
        _47 = move _25;
        _45 = (move _46, move _47);
        _50 = discriminant((_45.0: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _50) -> [0: bb31, 1: bb33, otherwise: bb7];
    }

    bb31: {
        _48 = discriminant((_45.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _48) -> [0: bb32, 1: bb42, otherwise: bb7];
    }

    bb32: {
        _99 = Option::<TokenStream2>::None;
        _0 = std::result::Result::<Option<TokenStream2>, devise::Diagnostic>::Ok(move _99);
        goto -> bb58;
    }

    bb33: {
        _49 = discriminant((_45.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _49) -> [0: bb41, 1: bb34, otherwise: bb7];
    }

    bb34: {
        _51 = move (((_45.0: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        _52 = move (((_45.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        _57 = &_51;
        _56 = <TokenStream2 as devise::Spanned>::span(move _57) -> [return: bb35, unwind: bb70];
    }

    bb35: {
        _55 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _56, const "duplicate default expressions") -> [return: bb36, unwind: bb70];
    }

    bb36: {
        _54 = devise::Diagnostic::help::<&str>(move _55, const "only one of `default` or `default_with` must be used") -> [return: bb37, unwind: bb70];
    }

    bb37: {
        _102 = const true;
        _59 = &_52;
        _58 = <TokenStream2 as devise::Spanned>::span(move _59) -> [return: bb38, unwind: bb91];
    }

    bb38: {
        _102 = const false;
        _53 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _54, move _58, const "other default expression is here") -> [return: bb39, unwind: bb91];
    }

    bb39: {
        _102 = const false;
        _0 = std::result::Result::<Option<TokenStream2>, devise::Diagnostic>::Err(move _53);
        drop(_52) -> [return: bb60, unwind: bb71];
    }

    bb40: {
        _63 = TokenStream2::new() -> [return: bb43, unwind: bb69];
    }

    bb41: {
        _60 = move (((_45.0: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        goto -> bb40;
    }

    bb42: {
        _60 = move (((_45.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream);
        goto -> bb40;
    }

    bb43: {
        _65 = &_60;
        _64 = <TokenStream2 as devise::Spanned>::span(move _65) -> [return: bb44, unwind: bb68];
    }

    bb44: {
        _67 = &mut _63;
        _68 = proc_macro2::Delimiter::Brace;
        _70 = TokenStream2::new() -> [return: bb45, unwind: bb68];
    }

    bb45: {
        _72 = &mut _70;
        _73 = const "let";
        _71 = push_ident_spanned(_72, _64, _73) -> [return: bb46, unwind: bb67];
    }

    bb46: {
        _75 = &mut _70;
        _76 = const "__default";
        _74 = push_ident_spanned(_75, _64, _76) -> [return: bb47, unwind: bb67];
    }

    bb47: {
        _78 = &mut _70;
        _77 = push_colon_spanned(_78, _64) -> [return: bb48, unwind: bb67];
    }

    bb48: {
        _80 = &mut _70;
        _81 = const "Option";
        _79 = push_ident_spanned(_80, _64, _81) -> [return: bb49, unwind: bb67];
    }

    bb49: {
        _83 = &mut _70;
        _82 = push_lt_spanned(_83, _64) -> [return: bb50, unwind: bb67];
    }

    bb50: {
        _85 = &_43;
        _86 = &mut _70;
        _84 = <syn::Type as ToTokens>::to_tokens(_85, _86) -> [return: bb51, unwind: bb67];
    }

    bb51: {
        _88 = &mut _70;
        _87 = push_gt_spanned(_88, _64) -> [return: bb52, unwind: bb67];
    }

    bb52: {
        _90 = &mut _70;
        _89 = push_eq_spanned(_90, _64) -> [return: bb53, unwind: bb67];
    }

    bb53: {
        _92 = &_60;
        _93 = &mut _70;
        _91 = <TokenStream2 as ToTokens>::to_tokens(_92, _93) -> [return: bb54, unwind: bb67];
    }

    bb54: {
        _95 = &mut _70;
        _94 = push_semi_spanned(_95, _64) -> [return: bb55, unwind: bb67];
    }

    bb55: {
        _97 = &mut _70;
        _98 = const "__default";
        _96 = push_ident_spanned(_97, _64, _98) -> [return: bb56, unwind: bb67];
    }

    bb56: {
        _69 = move _70;
        _66 = push_group_spanned(_67, _64, move _68, move _69) -> [return: bb57, unwind: bb68];
    }

    bb57: {
        _62 = move _63;
        _61 = Option::<TokenStream2>::Some(move _62);
        _0 = std::result::Result::<Option<TokenStream2>, devise::Diagnostic>::Ok(move _61);
        drop(_60) -> [return: bb58, unwind: bb72];
    }

    bb58: {
        drop(_43) -> [return: bb59, unwind: bb73];
    }

    bb59: {
        drop(_2) -> [return: bb66, unwind continue];
    }

    bb60: {
        drop(_51) -> [return: bb61, unwind: bb72];
    }

    bb61: {
        drop(_43) -> [return: bb62, unwind: bb73];
    }

    bb62: {
        drop(_2) -> [return: bb66, unwind continue];
    }

    bb63: {
        _105 = discriminant((_31.0: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _105) -> [1: bb88, otherwise: bb87];
    }

    bb64: {
        drop(_24) -> [return: bb65, unwind: bb79];
    }

    bb65: {
        drop(_2) -> [return: bb66, unwind continue];
    }

    bb66: {
        return;
    }

    bb67 (cleanup): {
        drop(_70) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop(_63) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        drop(_60) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        drop(_52) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        drop(_51) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        drop(_43) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        drop(_2) -> [return: bb80, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        drop(_38) -> [return: bb97, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        drop(_32) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        drop(_25) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        drop(_24) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb78 (cleanup): {
        drop(_27) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        drop(_2) -> [return: bb80, unwind terminate(cleanup)];
    }

    bb80 (cleanup): {
        resume;
    }

    bb81 (cleanup): {
        _103 = discriminant((_31.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _103) -> [1: bb82, otherwise: bb76];
    }

    bb82 (cleanup): {
        switchInt(_100) -> [0: bb76, otherwise: bb83];
    }

    bb83 (cleanup): {
        drop((((_31.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream)) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb84: {
        _100 = const false;
        _101 = const false;
        drop(_25) -> [return: bb64, unwind: bb77];
    }

    bb85: {
        switchInt(_100) -> [0: bb84, otherwise: bb86];
    }

    bb86: {
        drop((((_31.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream)) -> [return: bb84, unwind: bb76];
    }

    bb87: {
        _104 = discriminant((_31.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _104) -> [1: bb85, otherwise: bb84];
    }

    bb88: {
        switchInt(_101) -> [0: bb87, otherwise: bb89];
    }

    bb89: {
        drop((((_31.0: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream)) -> [return: bb87, unwind: bb81];
    }

    bb90 (cleanup): {
        drop(_54) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb91 (cleanup): {
        switchInt(_102) -> [0: bb70, otherwise: bb90];
    }

    bb92 (cleanup): {
        _106 = discriminant((_31.1: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _106) -> [1: bb93, otherwise: bb76];
    }

    bb93 (cleanup): {
        switchInt(_100) -> [0: bb76, otherwise: bb94];
    }

    bb94 (cleanup): {
        drop((((_31.1: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream)) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb95 (cleanup): {
        switchInt(_101) -> [0: bb92, otherwise: bb96];
    }

    bb96 (cleanup): {
        drop((((_31.0: std::option::Option<proc_macro2::TokenStream>) as Some).0: proc_macro2::TokenStream)) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        _107 = discriminant((_31.0: std::option::Option<proc_macro2::TokenStream>));
        switchInt(move _107) -> [1: bb95, otherwise: bb92];
    }
}

fn form_field::default::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:353:44: 353:47}, _2: &form_field::FieldAttr) -> Option<&syn::Expr> {
    debug a => _2;
    let mut _0: std::option::Option<&syn::Expr>;
    let mut _3: &std::option::Option<syn::Expr>;

    bb0: {
        _3 = &((*_2).2: std::option::Option<syn::Expr>);
        _0 = Option::<syn::Expr>::as_ref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn form_field::default::{closure#1}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:357:21: 357:24}, _2: &form_field::FieldAttr) -> Option<&syn::Expr> {
    debug a => _2;
    let mut _0: std::option::Option<&syn::Expr>;
    let mut _3: &std::option::Option<syn::Expr>;

    bb0: {
        _3 = &((*_2).3: std::option::Option<syn::Expr>);
        _0 = Option::<syn::Expr>::as_ref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn form_field::default::{closure#2}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:358:14: 358:17}, _2: &syn::Expr) -> TokenStream2 {
    debug e => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = <syn::Expr as ToTokens>::to_token_stream(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn form_field::first_duplicate(_1: impl Iterator<Item = K> + Clone, _2: impl Fn(&K) -> Result<Vec<V>>) -> std::result::Result<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic> {
    debug keys => _1;
    debug values => _2;
    let mut _0: std::result::Result<std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic>;
    let mut _3: std::vec::Vec<V>;
    let mut _4: std::vec::Vec<(usize, K)>;
    let mut _5: (std::vec::Vec<V>, std::vec::Vec<(usize, K)>);
    let mut _6: std::vec::Vec<V>;
    let mut _7: std::vec::Vec<(usize, K)>;
    let mut _8: impl Iterator<Item = K> + Clone;
    let mut _9: impl Iterator<Item = K> + Clone;
    let mut _11: std::option::Option<K>;
    let mut _12: &mut impl Iterator<Item = K> + Clone;
    let mut _13: isize;
    let _15: ();
    let mut _16: &mut std::vec::Vec<V>;
    let mut _17: &mut std::vec::Vec<V>;
    let mut _18: std::vec::Vec<V>;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<V>>;
    let mut _20: std::result::Result<std::vec::Vec<V>, devise::Diagnostic>;
    let mut _21: &impl Fn(&K) -> Result<Vec<V>>;
    let mut _22: (&K,);
    let _23: &K;
    let mut _24: isize;
    let _27: ();
    let mut _28: &mut std::vec::Vec<(usize, K)>;
    let mut _29: (usize, K);
    let mut _30: usize;
    let mut _31: &std::vec::Vec<V>;
    let mut _32: K;
    let mut _34: &std::vec::Vec<(usize, K)>;
    let mut _35: std::iter::Enumerate<std::slice::Iter<'_, V>>;
    let mut _36: std::iter::Enumerate<std::slice::Iter<'_, V>>;
    let mut _37: std::slice::Iter<'_, V>;
    let _38: &[V];
    let mut _39: &std::vec::Vec<V>;
    let mut _41: std::option::Option<(usize, &V)>;
    let mut _42: &mut std::iter::Enumerate<std::slice::Iter<'_, V>>;
    let mut _43: isize;
    let mut _47: std::iter::Enumerate<std::slice::Iter<'_, V>>;
    let mut _48: std::slice::Iter<'_, V>;
    let _49: &[V];
    let mut _50: &std::vec::Vec<V>;
    let mut _51: usize;
    let mut _52: (usize, bool);
    let mut _53: std::option::Option<(usize, &V)>;
    let mut _54: &mut std::iter::Filter<std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, V>>>, {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51}>;
    let mut _55: std::iter::Filter<std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, V>>>, {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51}>;
    let mut _56: {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51};
    let mut _57: &&V;
    let mut _58: isize;
    let mut _63: &(usize, K);
    let mut _64: &{closure@core/codegen/src/derive/form_field.rs:401:15: 401:18};
    let mut _65: (usize,);
    let mut _68: &(usize, K);
    let mut _69: &{closure@core/codegen/src/derive/form_field.rs:401:15: 401:18};
    let mut _70: (usize,);
    let mut _72: usize;
    let mut _73: proc_macro2::Span;
    let mut _74: proc_macro2::Span;
    let mut _75: &V;
    let mut _77: usize;
    let mut _78: proc_macro2::Span;
    let mut _79: proc_macro2::Span;
    let mut _80: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>;
    let mut _81: ((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span));
    let mut _82: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>;
    let mut _83: bool;
    let mut _84: bool;
    scope 1 {
        debug all_values => _3;
        debug key_map => _4;
        let mut _10: impl Iterator<Item = K> + Clone;
        let _33: {closure@core/codegen/src/derive/form_field.rs:401:15: 401:18};
        scope 2 {
            debug iter => _10;
            let _14: K;
            scope 3 {
                debug key => _14;
                let _25: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _26: std::vec::Vec<V>;
                scope 4 {
                    debug residual => _25;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => _26;
                    scope 7 {
                    }
                }
            }
        }
        scope 8 {
            debug key => _33;
            let mut _40: std::iter::Enumerate<std::slice::Iter<'_, V>>;
            scope 9 {
                debug iter => _40;
                let _44: usize;
                let _45: &V;
                scope 10 {
                    debug i => _44;
                    debug a => _45;
                    let _46: std::iter::Skip<std::iter::Enumerate<std::slice::Iter<'_, V>>>;
                    scope 11 {
                        debug rest => _46;
                        scope 12 {
                            debug j => _59;
                            debug b => _60;
                            let _59: usize;
                            let _60: &V;
                            let _61: &usize;
                            let _62: &K;
                            scope 13 {
                                debug a_i => _61;
                                debug key_a => _62;
                                let _66: &usize;
                                let _67: &K;
                                scope 14 {
                                    debug b_i => _66;
                                    debug key_b => _67;
                                    let _71: (usize, proc_macro2::Span, proc_macro2::Span);
                                    scope 15 {
                                        debug a => _71;
                                        let _76: (usize, proc_macro2::Span, proc_macro2::Span);
                                        scope 16 {
                                            debug b => _76;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _84 = const false;
        _83 = const false;
        _84 = const true;
        _6 = Vec::<V>::new() -> [return: bb1, unwind: bb52];
    }

    bb1: {
        _7 = Vec::<(usize, K)>::new() -> [return: bb2, unwind: bb51];
    }

    bb2: {
        _5 = (move _6, move _7);
        _3 = move (_5.0: std::vec::Vec<V>);
        _4 = move (_5.1: std::vec::Vec<(usize, K)>);
        _84 = const false;
        _9 = move _1;
        _8 = <impl Iterator<Item = K> + Clone as IntoIterator>::into_iter(move _9) -> [return: bb3, unwind: bb49];
    }

    bb3: {
        _10 = move _8;
        goto -> bb4;
    }

    bb4: {
        _12 = &mut _10;
        _11 = <impl Iterator<Item = K> + Clone as Iterator>::next(_12) -> [return: bb5, unwind: bb48];
    }

    bb5: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _83 = const true;
        _14 = move ((_11 as Some).0: K);
        _16 = &mut _3;
        _21 = &_2;
        _23 = &_14;
        _22 = (_23,);
        _20 = <impl Fn(&K) -> Result<Vec<V>> as std::ops::Fn<(&K,)>>::call(move _21, move _22) -> [return: bb9, unwind: bb56];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        drop(_10) -> [return: bb17, unwind: bb49];
    }

    bb9: {
        _19 = <std::result::Result<Vec<V>, devise::Diagnostic> as std::ops::Try>::branch(move _20) -> [return: bb10, unwind: bb56];
    }

    bb10: {
        _24 = discriminant(_19);
        switchInt(move _24) -> [0: bb11, 1: bb12, otherwise: bb7];
    }

    bb11: {
        _26 = move ((_19 as Continue).0: std::vec::Vec<V>);
        _18 = move _26;
        _17 = &mut _18;
        _15 = Vec::<V>::append(move _16, _17) -> [return: bb14, unwind: bb47];
    }

    bb12: {
        _25 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _25) -> [return: bb13, unwind: bb56];
    }

    bb13: {
        drop(_14) -> [return: bb42, unwind: bb48];
    }

    bb14: {
        drop(_18) -> [return: bb54, unwind: bb56];
    }

    bb15: {
        _83 = const false;
        _32 = move _14;
        _29 = (move _30, move _32);
        _27 = Vec::<(usize, K)>::push(move _28, move _29) -> [return: bb16, unwind: bb56];
    }

    bb16: {
        _83 = const false;
        goto -> bb4;
    }

    bb17: {
        _34 = &_4;
        _33 = {closure@core/codegen/src/derive/form_field.rs:401:15: 401:18} { key_map: move _34 };
        _39 = &_3;
        _38 = <Vec<V> as std::ops::Deref>::deref(move _39) -> [return: bb18, unwind: bb49];
    }

    bb18: {
        _37 = core::slice::<impl [V]>::iter(_38) -> [return: bb19, unwind: bb49];
    }

    bb19: {
        _36 = <std::slice::Iter<'_, V> as Iterator>::enumerate(move _37) -> [return: bb20, unwind: bb49];
    }

    bb20: {
        _35 = <Enumerate<std::slice::Iter<'_, V>> as IntoIterator>::into_iter(move _36) -> [return: bb21, unwind: bb49];
    }

    bb21: {
        _40 = move _35;
        goto -> bb22;
    }

    bb22: {
        _42 = &mut _40;
        _41 = <Enumerate<std::slice::Iter<'_, V>> as Iterator>::next(_42) -> [return: bb23, unwind: bb49];
    }

    bb23: {
        _43 = discriminant(_41);
        switchInt(move _43) -> [0: bb25, 1: bb24, otherwise: bb7];
    }

    bb24: {
        _44 = (((_41 as Some).0: (usize, &V)).0: usize);
        _45 = (((_41 as Some).0: (usize, &V)).1: &V);
        _50 = &_3;
        _49 = <Vec<V> as std::ops::Deref>::deref(move _50) -> [return: bb26, unwind: bb49];
    }

    bb25: {
        _82 = Option::<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>::None;
        _0 = std::result::Result::<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic>::Ok(move _82);
        drop(_4) -> [return: bb40, unwind: bb50];
    }

    bb26: {
        _48 = core::slice::<impl [V]>::iter(_49) -> [return: bb27, unwind: bb49];
    }

    bb27: {
        _47 = <std::slice::Iter<'_, V> as Iterator>::enumerate(move _48) -> [return: bb28, unwind: bb49];
    }

    bb28: {
        _52 = CheckedAdd(_44, const 1_usize);
        assert(!move (_52.1: bool), "attempt to compute `{} + {}`, which would overflow", _44, const 1_usize) -> [success: bb29, unwind: bb49];
    }

    bb29: {
        _51 = move (_52.0: usize);
        _46 = <Enumerate<std::slice::Iter<'_, V>> as Iterator>::skip(move _47, move _51) -> [return: bb30, unwind: bb49];
    }

    bb30: {
        _57 = &_45;
        _56 = {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51} { a: move _57 };
        _55 = <Skip<Enumerate<std::slice::Iter<'_, V>>> as Iterator>::filter::<{closure@core/codegen/src/derive/form_field.rs:405:43: 405:51}>(move _46, move _56) -> [return: bb31, unwind: bb49];
    }

    bb31: {
        _54 = &mut _55;
        _53 = <Filter<Skip<Enumerate<std::slice::Iter<'_, V>>>, {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51}> as Iterator>::next(move _54) -> [return: bb32, unwind: bb49];
    }

    bb32: {
        _58 = discriminant(_53);
        switchInt(move _58) -> [1: bb33, otherwise: bb22];
    }

    bb33: {
        _59 = (((_53 as Some).0: (usize, &V)).0: usize);
        _60 = (((_53 as Some).0: (usize, &V)).1: &V);
        _64 = &_33;
        _65 = (_44,);
        _63 = <{closure@core/codegen/src/derive/form_field.rs:401:15: 401:18} as std::ops::Fn<(usize,)>>::call(move _64, move _65) -> [return: bb34, unwind: bb49];
    }

    bb34: {
        _61 = &((*_63).0: usize);
        _62 = &((*_63).1: K);
        _69 = &_33;
        _70 = (_59,);
        _68 = <{closure@core/codegen/src/derive/form_field.rs:401:15: 401:18} as std::ops::Fn<(usize,)>>::call(move _69, move _70) -> [return: bb35, unwind: bb49];
    }

    bb35: {
        _66 = &((*_68).0: usize);
        _67 = &((*_68).1: K);
        _72 = (*_61);
        _73 = <K as devise::Spanned>::span(_62) -> [return: bb36, unwind: bb49];
    }

    bb36: {
        _75 = _45;
        _74 = <V as devise::Spanned>::span(move _75) -> [return: bb37, unwind: bb49];
    }

    bb37: {
        _71 = (move _72, move _73, move _74);
        _77 = (*_66);
        _78 = <K as devise::Spanned>::span(_67) -> [return: bb38, unwind: bb49];
    }

    bb38: {
        _79 = <V as devise::Spanned>::span(_60) -> [return: bb39, unwind: bb49];
    }

    bb39: {
        _76 = (move _77, move _78, move _79);
        _81 = (_71, _76);
        _80 = Option::<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>::Some(move _81);
        _0 = std::result::Result::<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic>::Ok(move _80);
        goto -> bb43;
    }

    bb40: {
        drop(_3) -> [return: bb41, unwind: bb52];
    }

    bb41: {
        drop(_2) -> [return: bb46, unwind: bb58];
    }

    bb42: {
        _83 = const false;
        drop(_10) -> [return: bb43, unwind: bb49];
    }

    bb43: {
        drop(_4) -> [return: bb44, unwind: bb50];
    }

    bb44: {
        drop(_3) -> [return: bb45, unwind: bb52];
    }

    bb45: {
        drop(_2) -> [return: bb46, unwind: bb58];
    }

    bb46: {
        return;
    }

    bb47 (cleanup): {
        drop(_18) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        drop(_10) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_4) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_3) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_6) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_2) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        resume;
    }

    bb54: {
        _28 = &mut _4;
        _31 = &_3;
        _30 = Vec::<V>::len(move _31) -> [return: bb15, unwind: bb56];
    }

    bb55 (cleanup): {
        drop(_14) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        switchInt(_83) -> [0: bb48, otherwise: bb55];
    }

    bb57 (cleanup): {
        drop(_1) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        switchInt(_84) -> [0: bb53, otherwise: bb57];
    }
}

fn form_field::first_duplicate::{closure#0}(_1: &{closure@core/codegen/src/derive/form_field.rs:401:15: 401:18}, _2: usize) -> &(usize, K) {
    debug k => _2;
    debug key_map => (*((*_1).0: &std::vec::Vec<(usize, K)>));
    let mut _0: &(usize, K);
    let mut _3: std::option::Option<&(usize, K)>;
    let mut _4: &mut std::slice::Iter<'_, (usize, K)>;
    let mut _5: std::slice::Iter<'_, (usize, K)>;
    let _6: &[(usize, K)];
    let mut _7: {closure@core/codegen/src/derive/form_field.rs:401:39: 401:47};
    let mut _8: &usize;
    let _9: &str;
    let mut _10: &std::vec::Vec<(usize, K)>;

    bb0: {
        _10 = deref_copy ((*_1).0: &std::vec::Vec<(usize, K)>);
        _6 = <Vec<(usize, K)> as std::ops::Deref>::deref(_10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = core::slice::<impl [(usize, K)]>::iter(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = &mut _5;
        _8 = &_2;
        _7 = {closure@core/codegen/src/derive/form_field.rs:401:39: 401:47} { k: move _8 };
        _3 = <std::slice::Iter<'_, (usize, K)> as Iterator>::find::<{closure@core/codegen/src/derive/form_field.rs:401:39: 401:47}>(move _4, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = const "k < *i";
        _0 = Option::<&(usize, K)>::expect(move _3, _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn form_field::first_duplicate::{closure#0}::{closure#0}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:401:39: 401:47}, _2: &&(usize, K)) -> bool {
    debug k => (*((*_1).0: &usize));
    let mut _0: bool;
    let _3: &usize;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: &(usize, K);
    let mut _7: &usize;
    scope 1 {
        debug i => _3;
    }

    bb0: {
        _6 = deref_copy (*_2);
        _3 = &((*_6).0: usize);
        _7 = deref_copy ((*_1).0: &usize);
        _4 = (*_7);
        _5 = (*_3);
        _0 = Lt(move _4, move _5);
        return;
    }
}

fn form_field::first_duplicate::{closure#1}(_1: &mut {closure@core/codegen/src/derive/form_field.rs:405:43: 405:51}, _2: &(usize, &V)) -> bool {
    debug a => (*((*_1).0: &&V));
    let mut _0: bool;
    let _3: &&V;
    let mut _4: &&V;
    scope 1 {
        debug b => _3;
    }

    bb0: {
        _3 = &((*_2).1: &V);
        _4 = deref_copy ((*_1).0: &&V);
        _0 = <&V as PartialEq>::eq(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fields_map(_1: devise::Fields<'_>, _2: F) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug fields => _1;
    debug map_f => _2;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: std::vec::Vec<proc_macro2::TokenStream>;
    let mut _4: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _5: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _7: std::option::Option<devise::Field<'_>>;
    let mut _8: &mut std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _9: isize;
    let mut _13: (&proc_macro2::Ident, syn::Type);
    let mut _14: &proc_macro2::Ident;
    let mut _15: &devise::Field<'_>;
    let mut _16: syn::Type;
    let mut _17: &devise::Field<'_>;
    let mut _21: &syn::Type;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let mut _24: proc_macro2::Delimiter;
    let mut _25: proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: &str;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: &str;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: &str;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let _51: &&proc_macro2::Ident;
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let mut _60: proc_macro2::Delimiter;
    let mut _61: proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: ();
    let _68: &syn::Type;
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: ();
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: &str;
    let _80: ();
    let mut _81: &mut proc_macro2::TokenStream;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: &str;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: &str;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let mut _94: proc_macro2::Delimiter;
    let mut _95: proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: &str;
    let mut _101: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldName>>;
    let mut _102: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _103: &devise::Field<'_>;
    let mut _104: isize;
    let mut _108: std::result::Result<syn::Expr, syn::Error>;
    let mut _109: proc_macro2::TokenStream;
    let _110: &str;
    let mut _112: &F;
    let mut _113: (&syn::Type, &syn::Expr);
    let _114: &syn::Type;
    let _115: &syn::Expr;
    let mut _117: std::slice::Iter<'_, derive::form_field::FieldName>;
    let _118: &[derive::form_field::FieldName];
    let mut _119: &std::vec::Vec<derive::form_field::FieldName>;
    let mut _120: {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56};
    let mut _121: &proc_macro2::TokenStream;
    let _122: ();
    let mut _123: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _124: proc_macro2::TokenStream;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let _128: &str;
    let _129: ();
    let mut _130: &mut proc_macro2::TokenStream;
    let _131: ();
    let mut _132: &mut proc_macro2::TokenStream;
    let _133: &str;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: ();
    let mut _137: &mut proc_macro2::TokenStream;
    let _138: &str;
    let _139: ();
    let mut _140: &mut proc_macro2::TokenStream;
    let _141: ();
    let mut _142: &mut proc_macro2::TokenStream;
    let _143: &str;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let mut _151: proc_macro2::Delimiter;
    let mut _152: proc_macro2::TokenStream;
    let _153: ();
    let mut _154: &mut proc_macro2::TokenStream;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: &str;
    let _158: ();
    let mut _159: &mut proc_macro2::TokenStream;
    let _160: &str;
    let _161: ();
    let mut _162: &mut proc_macro2::TokenStream;
    let _163: ();
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: &str;
    let _166: ();
    let mut _167: &mut proc_macro2::TokenStream;
    let _168: ();
    let mut _169: &mut proc_macro2::TokenStream;
    let _170: &str;
    let _171: ();
    let mut _172: &mut proc_macro2::TokenStream;
    let mut _173: proc_macro2::Delimiter;
    let mut _174: proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: &str;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let mut _182: proc_macro2::Delimiter;
    let mut _183: proc_macro2::TokenStream;
    let _184: ();
    let mut _185: &mut proc_macro2::TokenStream;
    let mut _186: proc_macro2::Delimiter;
    let mut _187: proc_macro2::TokenStream;
    let mut _190: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _191: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _193: bool;
    let mut _195: std::option::Option<&proc_macro2::TokenStream>;
    let mut _196: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _197: isize;
    let _199: ();
    let _200: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _201: &mut proc_macro2::TokenStream;
    let _202: ();
    let mut _203: &mut proc_macro2::TokenStream;
    let _204: ();
    let mut _205: &mut proc_macro2::TokenStream;
    let _206: &str;
    let _207: ();
    let mut _208: &mut proc_macro2::TokenStream;
    let _209: &str;
    let _210: ();
    let mut _211: &mut proc_macro2::TokenStream;
    let _212: &str;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: ();
    let mut _216: &mut proc_macro2::TokenStream;
    let _217: &str;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let _220: ();
    let mut _221: &mut proc_macro2::TokenStream;
    let _222: ();
    let mut _223: &mut proc_macro2::TokenStream;
    let _224: &str;
    let _225: ();
    let mut _226: &mut proc_macro2::TokenStream;
    let _227: ();
    let mut _228: &mut proc_macro2::TokenStream;
    let _229: &str;
    let _230: ();
    let mut _231: &mut proc_macro2::TokenStream;
    let _232: ();
    let mut _233: &mut proc_macro2::TokenStream;
    let _234: &str;
    let _235: ();
    let mut _236: &mut proc_macro2::TokenStream;
    let _237: ();
    let mut _238: &mut proc_macro2::TokenStream;
    let mut _239: proc_macro2::Delimiter;
    let mut _240: proc_macro2::TokenStream;
    let _241: ();
    let mut _242: &mut proc_macro2::TokenStream;
    let _243: ();
    let mut _244: &mut proc_macro2::TokenStream;
    let _245: ();
    let mut _246: &mut proc_macro2::TokenStream;
    let _247: ();
    let mut _248: &mut proc_macro2::TokenStream;
    let _249: &str;
    let _250: ();
    let mut _251: &mut proc_macro2::TokenStream;
    let _252: ();
    let mut _253: &mut proc_macro2::TokenStream;
    let _254: &str;
    let _255: ();
    let mut _256: &mut proc_macro2::TokenStream;
    let _257: ();
    let mut _258: &mut proc_macro2::TokenStream;
    let _259: &str;
    let _260: ();
    let mut _261: &mut proc_macro2::TokenStream;
    let mut _262: proc_macro2::Delimiter;
    let mut _263: proc_macro2::TokenStream;
    let _265: ();
    let mut _266: &mut proc_macro2::TokenStream;
    let _267: &str;
    let _268: ();
    let mut _269: &mut proc_macro2::TokenStream;
    let _270: ();
    let mut _271: &mut proc_macro2::TokenStream;
    let _272: &str;
    let _273: ();
    let mut _274: &mut proc_macro2::TokenStream;
    let mut _275: proc_macro2::Delimiter;
    let mut _276: proc_macro2::TokenStream;
    let _277: ();
    let mut _278: &mut proc_macro2::TokenStream;
    let mut _280: bool;
    scope 1 {
        debug matchers => _3;
        let mut _6: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
        let mut _125: proc_macro2::TokenStream;
        scope 2 {
            debug iter => _6;
            let _10: devise::Field<'_>;
            scope 3 {
                debug field => _10;
                let _11: &proc_macro2::Ident;
                let _12: syn::Type;
                scope 4 {
                    debug ident => _11;
                    debug ty => _12;
                    let _18: proc_macro2::TokenStream;
                    let mut _19: proc_macro2::TokenStream;
                    scope 5 {
                        debug field_context => _18;
                        let _100: std::vec::Vec<derive::form_field::FieldName>;
                        let _105: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _106: std::vec::Vec<derive::form_field::FieldName>;
                        scope 14 {
                            debug field_names => _100;
                            let _107: syn::Expr;
                            scope 19 {
                                debug field_context => _107;
                                let _111: proc_macro2::TokenStream;
                                scope 20 {
                                    debug push => _111;
                                    let _116: std::iter::Map<std::slice::Iter<'_, derive::form_field::FieldName>, {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56}>;
                                    scope 21 {
                                        debug field_matchers => _116;
                                    }
                                }
                            }
                        }
                        scope 15 {
                            debug residual => _105;
                            scope 16 {
                            }
                        }
                        scope 17 {
                            debug val => _106;
                            scope 18 {
                            }
                        }
                    }
                    scope 6 {
                        debug _s => _19;
                        let _20: proc_macro2::Span;
                        scope 7 {
                            debug _span => _20;
                            let mut _26: proc_macro2::TokenStream;
                            scope 8 {
                                debug _s => _26;
                                scope 9 {
                                    debug _span => _20;
                                    let mut _62: proc_macro2::TokenStream;
                                    scope 10 {
                                        debug _s => _62;
                                        scope 11 {
                                            debug _span => _20;
                                            let mut _96: proc_macro2::TokenStream;
                                            let mut _279: &exports::StaticPath;
                                            scope 12 {
                                                debug _s => _96;
                                                scope 13 {
                                                    debug _span => _20;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 22 {
            debug _s => _125;
            let mut _188: proc_macro2::TokenStream;
            scope 23 {
                debug _s => _188;
                let mut _264: proc_macro2::TokenStream;
                scope 24 {
                    debug has_iter => const ThereIsNoIteratorInRepetition;
                    scope 25 {
                        debug matchers => _189;
                        debug i => const HasIterator;
                        let _192: quote::__private::HasIterator;
                        scope 27 {
                            debug has_iter => const HasIterator;
                            scope 28 {
                                let _194: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                let _198: &proc_macro2::TokenStream;
                                scope 29 {
                                    debug matchers => _194;
                                }
                                scope 30 {
                                    debug _x => _198;
                                }
                            }
                        }
                    }
                    scope 26 {
                        let mut _189: std::slice::Iter<'_, proc_macro2::TokenStream>;
                    }
                }
                scope 31 {
                    debug _s => _264;
                }
            }
        }
    }

    bb0: {
        _280 = const false;
        _3 = Vec::<TokenStream2>::new() -> [return: bb1, unwind: bb144];
    }

    bb1: {
        _5 = devise::Fields::<'_>::iter(_1) -> [return: bb2, unwind: bb143];
    }

    bb2: {
        _4 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as IntoIterator>::into_iter(move _5) -> [return: bb3, unwind: bb143];
    }

    bb3: {
        _6 = move _4;
        goto -> bb4;
    }

    bb4: {
        _8 = &mut _6;
        _7 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::next(_8) -> [return: bb5, unwind: bb142];
    }

    bb5: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _10 = ((_7 as Some).0: devise::Field<'_>);
        _15 = &_10;
        _14 = <devise::Field<'_> as form_field::FieldExt>::ident(move _15) -> [return: bb9, unwind: bb142];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        drop(_6) -> [return: bb59, unwind: bb143];
    }

    bb9: {
        _17 = &_10;
        _16 = <devise::Field<'_> as form_field::FieldExt>::stripped_ty(move _17) -> [return: bb10, unwind: bb142];
    }

    bb10: {
        _13 = (move _14, move _16);
        _11 = (_13.0: &proc_macro2::Ident);
        _12 = move (_13.1: syn::Type);
        _19 = TokenStream2::new() -> [return: bb11, unwind: bb141];
    }

    bb11: {
        _21 = &_12;
        _20 = <syn::Type as devise::Spanned>::span(move _21) -> [return: bb12, unwind: bb140];
    }

    bb12: {
        _23 = &mut _19;
        _24 = proc_macro2::Delimiter::Brace;
        _26 = TokenStream2::new() -> [return: bb13, unwind: bb140];
    }

    bb13: {
        _28 = &mut _26;
        _29 = const "let";
        _27 = push_ident_spanned(_28, _20, _29) -> [return: bb14, unwind: bb139];
    }

    bb14: {
        _31 = &mut _26;
        _32 = const "__o";
        _30 = push_ident_spanned(_31, _20, _32) -> [return: bb15, unwind: bb139];
    }

    bb15: {
        _34 = &mut _26;
        _33 = push_eq_spanned(_34, _20) -> [return: bb16, unwind: bb139];
    }

    bb16: {
        _36 = &mut _26;
        _37 = const "__c";
        _35 = push_ident_spanned(_36, _20, _37) -> [return: bb17, unwind: bb139];
    }

    bb17: {
        _39 = &mut _26;
        _38 = push_dot_spanned(_39, _20) -> [return: bb18, unwind: bb139];
    }

    bb18: {
        _41 = &mut _26;
        _42 = const "__opts";
        _40 = push_ident_spanned(_41, _20, _42) -> [return: bb19, unwind: bb139];
    }

    bb19: {
        _44 = &mut _26;
        _43 = push_semi_spanned(_44, _20) -> [return: bb20, unwind: bb139];
    }

    bb20: {
        _46 = &mut _26;
        _47 = const "__c";
        _45 = push_ident_spanned(_46, _20, _47) -> [return: bb21, unwind: bb139];
    }

    bb21: {
        _49 = &mut _26;
        _48 = push_dot_spanned(_49, _20) -> [return: bb22, unwind: bb139];
    }

    bb22: {
        _51 = &_11;
        _52 = &mut _26;
        _50 = <&proc_macro2::Ident as ToTokens>::to_tokens(_51, _52) -> [return: bb23, unwind: bb139];
    }

    bb23: {
        _54 = &mut _26;
        _53 = push_dot_spanned(_54, _20) -> [return: bb24, unwind: bb139];
    }

    bb24: {
        _56 = &mut _26;
        _57 = const "get_or_insert_with";
        _55 = push_ident_spanned(_56, _20, _57) -> [return: bb25, unwind: bb139];
    }

    bb25: {
        _59 = &mut _26;
        _60 = proc_macro2::Delimiter::Parenthesis;
        _62 = TokenStream2::new() -> [return: bb26, unwind: bb139];
    }

    bb26: {
        _64 = &mut _62;
        _63 = push_or_or_spanned(_64, _20) -> [return: bb27, unwind: bb138];
    }

    bb27: {
        _66 = &mut _62;
        _65 = push_lt_spanned(_66, _20) -> [return: bb28, unwind: bb138];
    }

    bb28: {
        _68 = &_12;
        _69 = &mut _62;
        _67 = <syn::Type as ToTokens>::to_tokens(_68, _69) -> [return: bb29, unwind: bb138];
    }

    bb29: {
        _71 = &mut _62;
        _72 = const "as";
        _70 = push_ident_spanned(_71, _20, _72) -> [return: bb30, unwind: bb138];
    }

    bb30: {
        _279 = const _;
        _74 = &mut _62;
        _73 = <StaticPath as ToTokens>::to_tokens(_279, _74) -> [return: bb31, unwind: bb138];
    }

    bb31: {
        _76 = &mut _62;
        _75 = push_colon2_spanned(_76, _20) -> [return: bb32, unwind: bb138];
    }

    bb32: {
        _78 = &mut _62;
        _79 = const "FromForm";
        _77 = push_ident_spanned(_78, _20, _79) -> [return: bb33, unwind: bb138];
    }

    bb33: {
        _81 = &mut _62;
        _80 = push_lt_spanned(_81, _20) -> [return: bb34, unwind: bb138];
    }

    bb34: {
        _83 = &mut _62;
        _84 = const "'__f";
        _82 = push_lifetime_spanned(_83, _20, _84) -> [return: bb35, unwind: bb138];
    }

    bb35: {
        _86 = &mut _62;
        _85 = push_shr_spanned(_86, _20) -> [return: bb36, unwind: bb138];
    }

    bb36: {
        _88 = &mut _62;
        _87 = push_colon2_spanned(_88, _20) -> [return: bb37, unwind: bb138];
    }

    bb37: {
        _90 = &mut _62;
        _91 = const "init";
        _89 = push_ident_spanned(_90, _20, _91) -> [return: bb38, unwind: bb138];
    }

    bb38: {
        _93 = &mut _62;
        _94 = proc_macro2::Delimiter::Parenthesis;
        _96 = TokenStream2::new() -> [return: bb39, unwind: bb138];
    }

    bb39: {
        _98 = &mut _96;
        _99 = const "__o";
        _97 = push_ident_spanned(_98, _20, _99) -> [return: bb40, unwind: bb137];
    }

    bb40: {
        _95 = move _96;
        _92 = push_group_spanned(_93, _20, move _94, move _95) -> [return: bb41, unwind: bb138];
    }

    bb41: {
        _61 = move _62;
        _58 = push_group_spanned(_59, _20, move _60, move _61) -> [return: bb42, unwind: bb139];
    }

    bb42: {
        _25 = move _26;
        _22 = push_group_spanned(_23, _20, move _24, move _25) -> [return: bb43, unwind: bb140];
    }

    bb43: {
        _280 = const true;
        _18 = move _19;
        _103 = &_10;
        _102 = <devise::Field<'_> as form_field::FieldExt>::field_names(move _103) -> [return: bb44, unwind: bb147];
    }

    bb44: {
        _101 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _102) -> [return: bb45, unwind: bb147];
    }

    bb45: {
        _104 = discriminant(_101);
        switchInt(move _104) -> [0: bb46, 1: bb47, otherwise: bb7];
    }

    bb46: {
        _106 = move ((_101 as Continue).0: std::vec::Vec<derive::form_field::FieldName>);
        _100 = move _106;
        _280 = const false;
        _109 = move _18;
        _108 = syn::parse2::<syn::Expr>(move _109) -> [return: bb49, unwind: bb136];
    }

    bb47: {
        _105 = move ((_101 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _105) -> [return: bb48, unwind: bb147];
    }

    bb48: {
        drop(_18) -> [return: bb126, unwind: bb141];
    }

    bb49: {
        _110 = const "valid expr";
        _107 = std::result::Result::<syn::Expr, syn::Error>::expect(move _108, _110) -> [return: bb50, unwind: bb136];
    }

    bb50: {
        _112 = &_2;
        _114 = &_12;
        _115 = &_107;
        _113 = (_114, _115);
        _111 = <F as std::ops::Fn<(&syn::Type, &syn::Expr)>>::call(move _112, move _113) -> [return: bb51, unwind: bb135];
    }

    bb51: {
        _119 = &_100;
        _118 = <Vec<FieldName> as std::ops::Deref>::deref(move _119) -> [return: bb52, unwind: bb134];
    }

    bb52: {
        _117 = core::slice::<impl [FieldName]>::iter(_118) -> [return: bb53, unwind: bb134];
    }

    bb53: {
        _121 = &_111;
        _120 = {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56} { push: move _121 };
        _116 = <std::slice::Iter<'_, FieldName> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56}>(move _117, move _120) -> [return: bb54, unwind: bb134];
    }

    bb54: {
        _123 = &mut _3;
        _122 = <Vec<TokenStream2> as Extend<TokenStream2>>::extend::<Map<std::slice::Iter<'_, FieldName>, {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56}>>(move _123, move _116) -> [return: bb55, unwind: bb134];
    }

    bb55: {
        drop(_111) -> [return: bb56, unwind: bb135];
    }

    bb56: {
        drop(_107) -> [return: bb57, unwind: bb136];
    }

    bb57: {
        drop(_100) -> [return: bb58, unwind: bb147];
    }

    bb58: {
        _280 = const false;
        drop(_12) -> [return: bb4, unwind: bb142];
    }

    bb59: {
        _125 = TokenStream2::new() -> [return: bb60, unwind: bb143];
    }

    bb60: {
        _127 = &mut _125;
        _128 = const "__c";
        _126 = push_ident(_127, _128) -> [return: bb61, unwind: bb133];
    }

    bb61: {
        _130 = &mut _125;
        _129 = push_dot(_130) -> [return: bb62, unwind: bb133];
    }

    bb62: {
        _132 = &mut _125;
        _133 = const "__parent";
        _131 = push_ident(_132, _133) -> [return: bb63, unwind: bb133];
    }

    bb63: {
        _135 = &mut _125;
        _134 = push_eq(_135) -> [return: bb64, unwind: bb133];
    }

    bb64: {
        _137 = &mut _125;
        _138 = const "__f";
        _136 = push_ident(_137, _138) -> [return: bb65, unwind: bb133];
    }

    bb65: {
        _140 = &mut _125;
        _139 = push_dot(_140) -> [return: bb66, unwind: bb133];
    }

    bb66: {
        _142 = &mut _125;
        _143 = const "name";
        _141 = push_ident(_142, _143) -> [return: bb67, unwind: bb133];
    }

    bb67: {
        _145 = &mut _125;
        _144 = push_dot(_145) -> [return: bb68, unwind: bb133];
    }

    bb68: {
        _147 = &mut _125;
        _148 = const "parent";
        _146 = push_ident(_147, _148) -> [return: bb69, unwind: bb133];
    }

    bb69: {
        _150 = &mut _125;
        _151 = proc_macro2::Delimiter::Parenthesis;
        _152 = TokenStream2::new() -> [return: bb70, unwind: bb133];
    }

    bb70: {
        _149 = push_group(_150, move _151, move _152) -> [return: bb71, unwind: bb133];
    }

    bb71: {
        _154 = &mut _125;
        _153 = push_semi(_154) -> [return: bb72, unwind: bb133];
    }

    bb72: {
        _156 = &mut _125;
        _157 = const "match";
        _155 = push_ident(_156, _157) -> [return: bb73, unwind: bb133];
    }

    bb73: {
        _159 = &mut _125;
        _160 = const "__f";
        _158 = push_ident(_159, _160) -> [return: bb74, unwind: bb133];
    }

    bb74: {
        _162 = &mut _125;
        _161 = push_dot(_162) -> [return: bb75, unwind: bb133];
    }

    bb75: {
        _164 = &mut _125;
        _165 = const "name";
        _163 = push_ident(_164, _165) -> [return: bb76, unwind: bb133];
    }

    bb76: {
        _167 = &mut _125;
        _166 = push_dot(_167) -> [return: bb77, unwind: bb133];
    }

    bb77: {
        _169 = &mut _125;
        _170 = const "key_lossy";
        _168 = push_ident(_169, _170) -> [return: bb78, unwind: bb133];
    }

    bb78: {
        _172 = &mut _125;
        _173 = proc_macro2::Delimiter::Parenthesis;
        _174 = TokenStream2::new() -> [return: bb79, unwind: bb133];
    }

    bb79: {
        _171 = push_group(_172, move _173, move _174) -> [return: bb80, unwind: bb133];
    }

    bb80: {
        _176 = &mut _125;
        _175 = push_dot(_176) -> [return: bb81, unwind: bb133];
    }

    bb81: {
        _178 = &mut _125;
        _179 = const "as_str";
        _177 = push_ident(_178, _179) -> [return: bb82, unwind: bb133];
    }

    bb82: {
        _181 = &mut _125;
        _182 = proc_macro2::Delimiter::Parenthesis;
        _183 = TokenStream2::new() -> [return: bb83, unwind: bb133];
    }

    bb83: {
        _180 = push_group(_181, move _182, move _183) -> [return: bb84, unwind: bb133];
    }

    bb84: {
        _185 = &mut _125;
        _186 = proc_macro2::Delimiter::Brace;
        _188 = TokenStream2::new() -> [return: bb85, unwind: bb133];
    }

    bb85: {
        _191 = &_3;
        _190 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _191) -> [return: bb86, unwind: bb132];
    }

    bb86: {
        _189 = move (_190.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _192 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb148, unwind: bb132];
    }

    bb87: {
        _193 = const true;
        switchInt(move _193) -> [0: bb92, otherwise: bb88];
    }

    bb88: {
        _196 = &mut _189;
        _195 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _196) -> [return: bb89, unwind: bb132];
    }

    bb89: {
        _197 = discriminant(_195);
        switchInt(move _197) -> [0: bb92, 1: bb90, otherwise: bb7];
    }

    bb90: {
        _198 = ((_195 as Some).0: &proc_macro2::TokenStream);
        _194 = RepInterp::<&TokenStream2>(_198);
        _200 = &_194;
        _201 = &mut _188;
        _199 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_200, _201) -> [return: bb91, unwind: bb132];
    }

    bb91: {
        _203 = &mut _188;
        _202 = push_comma(_203) -> [return: bb149, unwind: bb132];
    }

    bb92: {
        _205 = &mut _188;
        _206 = const "__k";
        _204 = push_ident(_205, _206) -> [return: bb93, unwind: bb132];
    }

    bb93: {
        _208 = &mut _188;
        _209 = const "if";
        _207 = push_ident(_208, _209) -> [return: bb94, unwind: bb132];
    }

    bb94: {
        _211 = &mut _188;
        _212 = const "__k";
        _210 = push_ident(_211, _212) -> [return: bb95, unwind: bb132];
    }

    bb95: {
        _214 = &mut _188;
        _213 = push_eq_eq(_214) -> [return: bb96, unwind: bb132];
    }

    bb96: {
        _216 = &mut _188;
        _217 = const "\"_method\"";
        _215 = quote::__private::parse(_216, _217) -> [return: bb97, unwind: bb132];
    }

    bb97: {
        _219 = &mut _188;
        _218 = push_or_or(_219) -> [return: bb98, unwind: bb132];
    }

    bb98: {
        _221 = &mut _188;
        _220 = push_bang(_221) -> [return: bb99, unwind: bb132];
    }

    bb99: {
        _223 = &mut _188;
        _224 = const "__c";
        _222 = push_ident(_223, _224) -> [return: bb100, unwind: bb132];
    }

    bb100: {
        _226 = &mut _188;
        _225 = push_dot(_226) -> [return: bb101, unwind: bb132];
    }

    bb101: {
        _228 = &mut _188;
        _229 = const "__opts";
        _227 = push_ident(_228, _229) -> [return: bb102, unwind: bb132];
    }

    bb102: {
        _231 = &mut _188;
        _230 = push_dot(_231) -> [return: bb103, unwind: bb132];
    }

    bb103: {
        _233 = &mut _188;
        _234 = const "strict";
        _232 = push_ident(_233, _234) -> [return: bb104, unwind: bb132];
    }

    bb104: {
        _236 = &mut _188;
        _235 = push_fat_arrow(_236) -> [return: bb105, unwind: bb132];
    }

    bb105: {
        _238 = &mut _188;
        _239 = proc_macro2::Delimiter::Brace;
        _240 = TokenStream2::new() -> [return: bb106, unwind: bb132];
    }

    bb106: {
        _237 = push_group(_238, move _239, move _240) -> [return: bb107, unwind: bb132];
    }

    bb107: {
        _242 = &mut _188;
        _241 = push_comma(_242) -> [return: bb108, unwind: bb132];
    }

    bb108: {
        _244 = &mut _188;
        _243 = push_underscore(_244) -> [return: bb109, unwind: bb132];
    }

    bb109: {
        _246 = &mut _188;
        _245 = push_fat_arrow(_246) -> [return: bb110, unwind: bb132];
    }

    bb110: {
        _248 = &mut _188;
        _249 = const "__c";
        _247 = push_ident(_248, _249) -> [return: bb111, unwind: bb132];
    }

    bb111: {
        _251 = &mut _188;
        _250 = push_dot(_251) -> [return: bb112, unwind: bb132];
    }

    bb112: {
        _253 = &mut _188;
        _254 = const "__errors";
        _252 = push_ident(_253, _254) -> [return: bb113, unwind: bb132];
    }

    bb113: {
        _256 = &mut _188;
        _255 = push_dot(_256) -> [return: bb114, unwind: bb132];
    }

    bb114: {
        _258 = &mut _188;
        _259 = const "push";
        _257 = push_ident(_258, _259) -> [return: bb115, unwind: bb132];
    }

    bb115: {
        _261 = &mut _188;
        _262 = proc_macro2::Delimiter::Parenthesis;
        _264 = TokenStream2::new() -> [return: bb116, unwind: bb132];
    }

    bb116: {
        _266 = &mut _264;
        _267 = const "__f";
        _265 = push_ident(_266, _267) -> [return: bb117, unwind: bb131];
    }

    bb117: {
        _269 = &mut _264;
        _268 = push_dot(_269) -> [return: bb118, unwind: bb131];
    }

    bb118: {
        _271 = &mut _264;
        _272 = const "unexpected";
        _270 = push_ident(_271, _272) -> [return: bb119, unwind: bb131];
    }

    bb119: {
        _274 = &mut _264;
        _275 = proc_macro2::Delimiter::Parenthesis;
        _276 = TokenStream2::new() -> [return: bb120, unwind: bb131];
    }

    bb120: {
        _273 = push_group(_274, move _275, move _276) -> [return: bb121, unwind: bb131];
    }

    bb121: {
        _263 = move _264;
        _260 = push_group(_261, move _262, move _263) -> [return: bb122, unwind: bb132];
    }

    bb122: {
        _278 = &mut _188;
        _277 = push_comma(_278) -> [return: bb123, unwind: bb132];
    }

    bb123: {
        _187 = move _188;
        _184 = push_group(_185, move _186, move _187) -> [return: bb124, unwind: bb133];
    }

    bb124: {
        _124 = move _125;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _124);
        drop(_3) -> [return: bb125, unwind: bb144];
    }

    bb125: {
        drop(_2) -> [return: bb130, unwind continue];
    }

    bb126: {
        _280 = const false;
        drop(_12) -> [return: bb127, unwind: bb142];
    }

    bb127: {
        drop(_6) -> [return: bb128, unwind: bb143];
    }

    bb128: {
        drop(_3) -> [return: bb129, unwind: bb144];
    }

    bb129: {
        drop(_2) -> [return: bb130, unwind continue];
    }

    bb130: {
        return;
    }

    bb131 (cleanup): {
        drop(_264) -> [return: bb132, unwind terminate(cleanup)];
    }

    bb132 (cleanup): {
        drop(_188) -> [return: bb133, unwind terminate(cleanup)];
    }

    bb133 (cleanup): {
        drop(_125) -> [return: bb143, unwind terminate(cleanup)];
    }

    bb134 (cleanup): {
        drop(_111) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb135 (cleanup): {
        drop(_107) -> [return: bb136, unwind terminate(cleanup)];
    }

    bb136 (cleanup): {
        drop(_100) -> [return: bb147, unwind terminate(cleanup)];
    }

    bb137 (cleanup): {
        drop(_96) -> [return: bb138, unwind terminate(cleanup)];
    }

    bb138 (cleanup): {
        drop(_62) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb139 (cleanup): {
        drop(_26) -> [return: bb140, unwind terminate(cleanup)];
    }

    bb140 (cleanup): {
        drop(_19) -> [return: bb141, unwind terminate(cleanup)];
    }

    bb141 (cleanup): {
        drop(_12) -> [return: bb142, unwind terminate(cleanup)];
    }

    bb142 (cleanup): {
        drop(_6) -> [return: bb143, unwind terminate(cleanup)];
    }

    bb143 (cleanup): {
        drop(_3) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb144 (cleanup): {
        drop(_2) -> [return: bb145, unwind terminate(cleanup)];
    }

    bb145 (cleanup): {
        resume;
    }

    bb146 (cleanup): {
        drop(_18) -> [return: bb141, unwind terminate(cleanup)];
    }

    bb147 (cleanup): {
        switchInt(_280) -> [0: bb141, otherwise: bb146];
    }

    bb148: {
        goto -> bb87;
    }

    bb149: {
        goto -> bb87;
    }
}

promoted[0] in fields_map: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn fields_map::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:22:53: 22:56}, _2: &FieldName) -> TokenStream2 {
    debug f => _2;
    debug push => (*((*_1).0: &proc_macro2::TokenStream));
    let mut _0: proc_macro2::TokenStream;
    let mut _3: isize;
    let _4: &name::Name;
    let _6: ();
    let _7: &&name::Name;
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &name::Name;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &str;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let mut _36: proc_macro2::Delimiter;
    let mut _37: proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let _41: &&name::Name;
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let mut _47: proc_macro2::Delimiter;
    let mut _48: proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let mut _52: &proc_macro2::TokenStream;
    let mut _53: &proc_macro2::TokenStream;
    scope 1 {
        debug name => _4;
        let mut _5: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _5;
            let mut _15: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _15;
            }
        }
    }
    scope 4 {
        debug name => _18;
        let mut _19: proc_macro2::TokenStream;
        scope 5 {
            debug _s => _19;
            let mut _49: proc_macro2::TokenStream;
            scope 6 {
                debug _s => _49;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _18 = &(((*_2) as Uncased).0: name::Name);
        _19 = TokenStream2::new() -> [return: bb10, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_2) as Cased).0: name::Name);
        _5 = TokenStream2::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = &_4;
        _8 = &mut _5;
        _6 = <&name::Name as ToTokens>::to_tokens(_7, _8) -> [return: bb5, unwind: bb28];
    }

    bb5: {
        _10 = &mut _5;
        _9 = push_fat_arrow(_10) -> [return: bb6, unwind: bb28];
    }

    bb6: {
        _12 = &mut _5;
        _13 = proc_macro2::Delimiter::Brace;
        _15 = TokenStream2::new() -> [return: bb7, unwind: bb28];
    }

    bb7: {
        _52 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _17 = &mut _15;
        _16 = <TokenStream2 as ToTokens>::to_tokens(_52, _17) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb9, unwind: bb28];
    }

    bb9: {
        _0 = move _5;
        goto -> bb24;
    }

    bb10: {
        _21 = &mut _19;
        _22 = const "__n";
        _20 = push_ident(_21, _22) -> [return: bb11, unwind: bb26];
    }

    bb11: {
        _24 = &mut _19;
        _25 = const "if";
        _23 = push_ident(_24, _25) -> [return: bb12, unwind: bb26];
    }

    bb12: {
        _27 = &mut _19;
        _28 = const "__n";
        _26 = push_ident(_27, _28) -> [return: bb13, unwind: bb26];
    }

    bb13: {
        _30 = &mut _19;
        _29 = push_dot(_30) -> [return: bb14, unwind: bb26];
    }

    bb14: {
        _32 = &mut _19;
        _33 = const "as_uncased";
        _31 = push_ident(_32, _33) -> [return: bb15, unwind: bb26];
    }

    bb15: {
        _35 = &mut _19;
        _36 = proc_macro2::Delimiter::Parenthesis;
        _37 = TokenStream2::new() -> [return: bb16, unwind: bb26];
    }

    bb16: {
        _34 = push_group(_35, move _36, move _37) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _39 = &mut _19;
        _38 = push_eq_eq(_39) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _41 = &_18;
        _42 = &mut _19;
        _40 = <&name::Name as ToTokens>::to_tokens(_41, _42) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _44 = &mut _19;
        _43 = push_fat_arrow(_44) -> [return: bb20, unwind: bb26];
    }

    bb20: {
        _46 = &mut _19;
        _47 = proc_macro2::Delimiter::Brace;
        _49 = TokenStream2::new() -> [return: bb21, unwind: bb26];
    }

    bb21: {
        _53 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _51 = &mut _49;
        _50 = <TokenStream2 as ToTokens>::to_tokens(_53, _51) -> [return: bb22, unwind: bb25];
    }

    bb22: {
        _48 = move _49;
        _45 = push_group(_46, move _47, move _48) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        _0 = move _19;
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_49) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_19) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_15) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_5) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        resume;
    }
}

fn context_type(_1: devise::Input<'_>) -> (TokenStream2, Option<WhereClause>) {
    debug input => _1;
    let mut _0: (proc_macro2::TokenStream, std::option::Option<syn::WhereClause>);
    let mut _2: syn::Generics;
    let _3: &syn::Generics;
    let _4: &devise::ItemInput;
    let mut _5: &devise::Input<'_>;
    let mut _7: proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let mut _12: bool;
    let mut _13: &mut syn::Generics;
    let _14: &syn::Lifetime;
    let _15: ();
    let mut _16: &mut syn::Generics;
    let mut _17: syn::LifetimeDef;
    let mut _18: syn::Lifetime;
    let mut _19: &syn::Lifetime;
    let _21: &proc_macro2::Ident;
    let _22: &devise::ItemInput;
    let mut _23: &devise::Input<'_>;
    let _24: ();
    let mut _25: &mut syn::Generics;
    let mut _26: syn::TypeParamBound;
    let mut _27: proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let _39: &syn::Lifetime;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut syn::Generics;
    let mut _45: syn::TypeParamBound;
    let mut _46: syn::Lifetime;
    let mut _49: (syn::ImplGenerics<'_>, syn::TypeGenerics<'_>, std::option::Option<&syn::WhereClause>);
    let mut _50: &syn::Generics;
    let mut _51: proc_macro2::TokenStream;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: &str;
    let _56: ();
    let _57: &syn::TypeGenerics<'_>;
    let mut _58: &mut proc_macro2::TokenStream;
    let mut _59: std::option::Option<syn::WhereClause>;
    let mut _61: bool;
    scope 1 {
        debug gen => _2;
        let _6: syn::Lifetime;
        let mut _8: proc_macro2::TokenStream;
        scope 2 {
            debug lifetime => _6;
            let _20: proc_macro2::Span;
            scope 4 {
                debug span => _20;
                let mut _28: proc_macro2::TokenStream;
                let _47: syn::TypeGenerics<'_>;
                let _48: std::option::Option<&syn::WhereClause>;
                scope 5 {
                    debug _s => _28;
                    let mut _60: &exports::StaticPath;
                }
                scope 6 {
                    debug ty_gen => _47;
                    debug where_clause => _48;
                    let mut _52: proc_macro2::TokenStream;
                    scope 7 {
                        debug _s => _52;
                        scope 8 {
                            debug _span => _20;
                        }
                    }
                }
            }
        }
        scope 3 {
            debug _s => _8;
        }
    }

    bb0: {
        _61 = const false;
        _5 = &_1;
        _4 = <devise::Input<'_> as std::ops::Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = ItemInput::generics(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <Generics as Clone>::clone(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = TokenStream2::new() -> [return: bb4, unwind: bb36];
    }

    bb4: {
        _10 = &mut _8;
        _11 = const "'__f";
        _9 = push_lifetime(_10, _11) -> [return: bb5, unwind: bb35];
    }

    bb5: {
        _7 = move _8;
        _6 = syn::parse_quote::parse::<syn::Lifetime>(move _7) -> [return: bb6, unwind: bb36];
    }

    bb6: {
        _61 = const true;
        _13 = &mut _2;
        _14 = &_6;
        _12 = <Generics as GenericsExt>::replace_lifetime(move _13, const 0_usize, _14) -> [return: bb7, unwind: bb39];
    }

    bb7: {
        switchInt(move _12) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        _16 = &mut _2;
        _19 = &_6;
        _18 = <syn::Lifetime as Clone>::clone(move _19) -> [return: bb9, unwind: bb39];
    }

    bb9: {
        _17 = LifetimeDef::new(move _18) -> [return: bb10, unwind: bb39];
    }

    bb10: {
        _15 = <Generics as GenericsExt>::insert_lifetime(move _16, move _17) -> [return: bb40, unwind: bb39];
    }

    bb11: {
        _23 = &_1;
        _22 = <devise::Input<'_> as std::ops::Deref>::deref(move _23) -> [return: bb12, unwind: bb39];
    }

    bb12: {
        _21 = ItemInput::ident(_22) -> [return: bb13, unwind: bb39];
    }

    bb13: {
        _20 = proc_macro2::Ident::span(_21) -> [return: bb14, unwind: bb39];
    }

    bb14: {
        _25 = &mut _2;
        _28 = TokenStream2::new() -> [return: bb15, unwind: bb39];
    }

    bb15: {
        _60 = const _;
        _30 = &mut _28;
        _29 = <StaticPath as ToTokens>::to_tokens(_60, _30) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _32 = &mut _28;
        _31 = push_colon2(_32) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _34 = &mut _28;
        _35 = const "FromForm";
        _33 = push_ident(_34, _35) -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _37 = &mut _28;
        _36 = push_lt(_37) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _39 = &_6;
        _40 = &mut _28;
        _38 = <syn::Lifetime as ToTokens>::to_tokens(_39, _40) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _42 = &mut _28;
        _41 = push_gt(_42) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _27 = move _28;
        _26 = syn::parse_quote::parse::<TypeParamBound>(move _27) -> [return: bb22, unwind: bb39];
    }

    bb22: {
        _24 = <Generics as GenericsExt>::add_type_bound(move _25, move _26) -> [return: bb23, unwind: bb39];
    }

    bb23: {
        _44 = &mut _2;
        _61 = const false;
        _46 = move _6;
        _45 = <TypeParamBound as From<syn::Lifetime>>::from(move _46) -> [return: bb24, unwind: bb39];
    }

    bb24: {
        _43 = <Generics as GenericsExt>::add_type_bound(move _44, move _45) -> [return: bb25, unwind: bb39];
    }

    bb25: {
        _50 = &_2;
        _49 = Generics::split_for_impl(move _50) -> [return: bb26, unwind: bb39];
    }

    bb26: {
        _47 = move (_49.1: syn::TypeGenerics<'_>);
        _48 = (_49.2: std::option::Option<&syn::WhereClause>);
        _52 = TokenStream2::new() -> [return: bb27, unwind: bb39];
    }

    bb27: {
        _54 = &mut _52;
        _55 = const "FromFormGeneratedContext";
        _53 = push_ident_spanned(_54, _20, _55) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        _57 = &_47;
        _58 = &mut _52;
        _56 = <TypeGenerics<'_> as ToTokens>::to_tokens(_57, _58) -> [return: bb29, unwind: bb33];
    }

    bb29: {
        _51 = move _52;
        _59 = Option::<&WhereClause>::cloned(_48) -> [return: bb30, unwind: bb32];
    }

    bb30: {
        _0 = (move _51, move _59);
        _61 = const false;
        drop(_2) -> [return: bb31, unwind continue];
    }

    bb31: {
        return;
    }

    bb32 (cleanup): {
        drop(_51) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_52) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_28) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_8) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_2) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        resume;
    }

    bb38 (cleanup): {
        drop(_6) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        switchInt(_61) -> [0: bb36, otherwise: bb38];
    }

    bb40: {
        goto -> bb11;
    }
}

promoted[0] in context_type: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: &mut devise::DeriveGenerator;
    let mut _3: &mut devise::DeriveGenerator;
    let mut _4: &mut devise::DeriveGenerator;
    let mut _5: &mut devise::DeriveGenerator;
    let mut _6: &mut devise::DeriveGenerator;
    let mut _7: &mut devise::DeriveGenerator;
    let mut _8: &mut devise::DeriveGenerator;
    let mut _9: &mut devise::DeriveGenerator;
    let mut _10: &mut devise::DeriveGenerator;
    let mut _11: &mut devise::DeriveGenerator;
    let mut _12: &mut devise::DeriveGenerator;
    let mut _13: &mut devise::DeriveGenerator;
    let mut _14: devise::DeriveGenerator;
    let mut _15: proc_macro::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: &str;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: &str;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: &str;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let mut _42: devise::Support;
    let mut _43: devise::Support;
    let mut _44: proc_macro2::TokenStream;
    let mut _45: proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: &str;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let mut _65: devise::ValidatorBuild;
    let mut _66: devise::ValidatorBuild;
    let mut _67: devise::ValidatorBuild;
    let mut _68: devise::MapperBuild;
    let mut _69: devise::MapperBuild;
    let mut _70: devise::MapperBuild;
    let mut _71: devise::MapperBuild;
    let mut _72: proc_macro2::TokenStream;
    let mut _73: proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let mut _78: proc_macro2::Delimiter;
    let mut _79: proc_macro2::TokenStream;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: &str;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let mut _86: proc_macro2::Delimiter;
    let mut _87: proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: &str;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: &str;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: ();
    let mut _100: &mut proc_macro2::TokenStream;
    let _101: &str;
    let _102: ();
    let mut _103: &mut proc_macro2::TokenStream;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: &str;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let mut _109: proc_macro2::TokenStream;
    let mut _110: proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let mut _115: proc_macro2::Delimiter;
    let mut _116: proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: &str;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: &str;
    let mut _126: devise::MapperBuild;
    let mut _127: devise::MapperBuild;
    let mut _128: devise::MapperBuild;
    let mut _129: devise::MapperBuild;
    let mut _130: devise::MapperBuild;
    let mut _131: devise::MapperBuild;
    let mut _132: devise::MapperBuild;
    let mut _133: devise::MapperBuild;
    let mut _134: devise::MapperBuild;
    let mut _135: devise::MapperBuild;
    let mut _136: devise::MapperBuild;
    let mut _137: devise::MapperBuild;
    let mut _138: devise::MapperBuild;
    let mut _139: devise::MapperBuild;
    let mut _143: bool;
    scope 1 {
        debug _s => _17;
        let mut _142: &exports::StaticPath;
    }
    scope 2 {
        debug _s => _45;
        let mut _141: &exports::StaticPath;
    }
    scope 3 {
        debug _s => _73;
        let mut _80: proc_macro2::TokenStream;
        let mut _140: &exports::StaticPath;
        scope 4 {
            debug _s => _80;
            let mut _88: proc_macro2::TokenStream;
            scope 5 {
                debug _s => _88;
            }
        }
    }
    scope 6 {
        debug _s => _110;
        let mut _117: proc_macro2::TokenStream;
        scope 7 {
            debug _s => _117;
        }
    }

    bb0: {
        _143 = const false;
        _143 = const true;
        _15 = move _1;
        _17 = TokenStream2::new() -> [return: bb1, unwind: bb90];
    }

    bb1: {
        _19 = &mut _17;
        _20 = const "impl";
        _18 = push_ident(_19, _20) -> [return: bb2, unwind: bb87];
    }

    bb2: {
        _22 = &mut _17;
        _21 = push_lt(_22) -> [return: bb3, unwind: bb87];
    }

    bb3: {
        _24 = &mut _17;
        _25 = const "'__f";
        _23 = push_lifetime(_24, _25) -> [return: bb4, unwind: bb87];
    }

    bb4: {
        _27 = &mut _17;
        _26 = push_gt(_27) -> [return: bb5, unwind: bb87];
    }

    bb5: {
        _142 = const _;
        _29 = &mut _17;
        _28 = <StaticPath as ToTokens>::to_tokens(_142, _29) -> [return: bb6, unwind: bb87];
    }

    bb6: {
        _31 = &mut _17;
        _30 = push_colon2(_31) -> [return: bb7, unwind: bb87];
    }

    bb7: {
        _33 = &mut _17;
        _34 = const "FromForm";
        _32 = push_ident(_33, _34) -> [return: bb8, unwind: bb87];
    }

    bb8: {
        _36 = &mut _17;
        _35 = push_lt(_36) -> [return: bb9, unwind: bb87];
    }

    bb9: {
        _38 = &mut _17;
        _39 = const "'__f";
        _37 = push_lifetime(_38, _39) -> [return: bb10, unwind: bb87];
    }

    bb10: {
        _41 = &mut _17;
        _40 = push_gt(_41) -> [return: bb11, unwind: bb87];
    }

    bb11: {
        _16 = move _17;
        _143 = const false;
        _14 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _15, move _16) -> [return: bb12, unwind: bb90];
    }

    bb12: {
        _13 = &mut _14;
        _143 = const false;
        _43 = <devise::Support as std::ops::BitOr>::bitor(const _, const _) -> [return: bb13, unwind: bb86];
    }

    bb13: {
        _42 = <devise::Support as std::ops::BitOr>::bitor(move _43, const _) -> [return: bb14, unwind: bb86];
    }

    bb14: {
        _12 = devise::DeriveGenerator::support(move _13, move _42) -> [return: bb15, unwind: bb86];
    }

    bb15: {
        _11 = devise::DeriveGenerator::replace_generic(_12, const 0_usize, const 0_usize) -> [return: bb16, unwind: bb86];
    }

    bb16: {
        _45 = TokenStream2::new() -> [return: bb17, unwind: bb86];
    }

    bb17: {
        _141 = const _;
        _47 = &mut _45;
        _46 = <StaticPath as ToTokens>::to_tokens(_141, _47) -> [return: bb18, unwind: bb85];
    }

    bb18: {
        _49 = &mut _45;
        _48 = push_colon2(_49) -> [return: bb19, unwind: bb85];
    }

    bb19: {
        _51 = &mut _45;
        _52 = const "FromForm";
        _50 = push_ident(_51, _52) -> [return: bb20, unwind: bb85];
    }

    bb20: {
        _54 = &mut _45;
        _53 = push_lt(_54) -> [return: bb21, unwind: bb85];
    }

    bb21: {
        _56 = &mut _45;
        _57 = const "'__f";
        _55 = push_lifetime(_56, _57) -> [return: bb22, unwind: bb85];
    }

    bb22: {
        _59 = &mut _45;
        _58 = push_gt(_59) -> [return: bb23, unwind: bb85];
    }

    bb23: {
        _61 = &mut _45;
        _60 = push_add(_61) -> [return: bb24, unwind: bb85];
    }

    bb24: {
        _63 = &mut _45;
        _64 = const "'__f";
        _62 = push_lifetime(_63, _64) -> [return: bb25, unwind: bb85];
    }

    bb25: {
        _44 = move _45;
        _10 = devise::DeriveGenerator::type_bound::<TokenStream2>(_11, move _44) -> [return: bb26, unwind: bb86];
    }

    bb26: {
        _67 = devise::ValidatorBuild::new() -> [return: bb27, unwind: bb86];
    }

    bb27: {
        _66 = devise::ValidatorBuild::input_validate::<{closure@core/codegen/src/derive/from_form.rs:64:29: 64:35}>(move _67, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:64:29: 64:35}) -> [return: bb28, unwind: bb86];
    }

    bb28: {
        _65 = devise::ValidatorBuild::fields_validate::<{closure@core/codegen/src/derive/from_form.rs:68:30: 68:41}>(move _66, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:68:30: 68:41}) -> [return: bb29, unwind: bb86];
    }

    bb29: {
        _9 = devise::DeriveGenerator::validator::<devise::ValidatorBuild>(_10, move _65) -> [return: bb30, unwind: bb86];
    }

    bb30: {
        _71 = devise::MapperBuild::new() -> [return: bb31, unwind: bb86];
    }

    bb31: {
        _70 = devise::MapperBuild::try_input_map::<{closure@core/codegen/src/derive/from_form.rs:92:28: 92:43}>(move _71, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:92:28: 92:43}) -> [return: bb32, unwind: bb86];
    }

    bb32: {
        _69 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/from_form.rs:106:29: 106:35}>(move _70, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:106:29: 106:35}) -> [return: bb33, unwind: bb86];
    }

    bb33: {
        _68 = devise::MapperBuild::field_map::<{closure@core/codegen/src/derive/from_form.rs:107:24: 107:34}>(move _69, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:107:24: 107:34}) -> [return: bb34, unwind: bb86];
    }

    bb34: {
        _8 = devise::DeriveGenerator::outer_mapper::<devise::MapperBuild>(_9, move _68) -> [return: bb35, unwind: bb86];
    }

    bb35: {
        _73 = TokenStream2::new() -> [return: bb36, unwind: bb86];
    }

    bb36: {
        _75 = &mut _73;
        _74 = push_pound(_75) -> [return: bb37, unwind: bb84];
    }

    bb37: {
        _77 = &mut _73;
        _78 = proc_macro2::Delimiter::Bracket;
        _80 = TokenStream2::new() -> [return: bb38, unwind: bb84];
    }

    bb38: {
        _82 = &mut _80;
        _83 = const "allow";
        _81 = push_ident(_82, _83) -> [return: bb39, unwind: bb83];
    }

    bb39: {
        _85 = &mut _80;
        _86 = proc_macro2::Delimiter::Parenthesis;
        _88 = TokenStream2::new() -> [return: bb40, unwind: bb83];
    }

    bb40: {
        _90 = &mut _88;
        _91 = const "unused_imports";
        _89 = push_ident(_90, _91) -> [return: bb41, unwind: bb82];
    }

    bb41: {
        _87 = move _88;
        _84 = push_group(_85, move _86, move _87) -> [return: bb42, unwind: bb83];
    }

    bb42: {
        _79 = move _80;
        _76 = push_group(_77, move _78, move _79) -> [return: bb43, unwind: bb84];
    }

    bb43: {
        _93 = &mut _73;
        _94 = const "use";
        _92 = push_ident(_93, _94) -> [return: bb44, unwind: bb84];
    }

    bb44: {
        _140 = const _;
        _96 = &mut _73;
        _95 = <StaticPath as ToTokens>::to_tokens(_140, _96) -> [return: bb45, unwind: bb84];
    }

    bb45: {
        _98 = &mut _73;
        _97 = push_colon2(_98) -> [return: bb46, unwind: bb84];
    }

    bb46: {
        _100 = &mut _73;
        _101 = const "uncased";
        _99 = push_ident(_100, _101) -> [return: bb47, unwind: bb84];
    }

    bb47: {
        _103 = &mut _73;
        _102 = push_colon2(_103) -> [return: bb48, unwind: bb84];
    }

    bb48: {
        _105 = &mut _73;
        _106 = const "AsUncased";
        _104 = push_ident(_105, _106) -> [return: bb49, unwind: bb84];
    }

    bb49: {
        _108 = &mut _73;
        _107 = push_semi(_108) -> [return: bb50, unwind: bb84];
    }

    bb50: {
        _72 = move _73;
        _7 = devise::DeriveGenerator::outer_mapper::<TokenStream2>(_8, move _72) -> [return: bb51, unwind: bb86];
    }

    bb51: {
        _110 = TokenStream2::new() -> [return: bb52, unwind: bb86];
    }

    bb52: {
        _112 = &mut _110;
        _111 = push_pound(_112) -> [return: bb53, unwind: bb81];
    }

    bb53: {
        _114 = &mut _110;
        _115 = proc_macro2::Delimiter::Bracket;
        _117 = TokenStream2::new() -> [return: bb54, unwind: bb81];
    }

    bb54: {
        _119 = &mut _117;
        _120 = const "rocket";
        _118 = push_ident(_119, _120) -> [return: bb55, unwind: bb80];
    }

    bb55: {
        _122 = &mut _117;
        _121 = push_colon2(_122) -> [return: bb56, unwind: bb80];
    }

    bb56: {
        _124 = &mut _117;
        _125 = const "async_trait";
        _123 = push_ident(_124, _125) -> [return: bb57, unwind: bb80];
    }

    bb57: {
        _116 = move _117;
        _113 = push_group(_114, move _115, move _116) -> [return: bb58, unwind: bb81];
    }

    bb58: {
        _109 = move _110;
        _6 = devise::DeriveGenerator::outer_mapper::<TokenStream2>(_7, move _109) -> [return: bb59, unwind: bb86];
    }

    bb59: {
        _129 = devise::MapperBuild::new() -> [return: bb60, unwind: bb86];
    }

    bb60: {
        _128 = devise::MapperBuild::try_input_map::<{closure@core/codegen/src/derive/from_form.rs:123:28: 123:43}>(move _129, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:123:28: 123:43}) -> [return: bb61, unwind: bb86];
    }

    bb61: {
        _127 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/from_form.rs:139:29: 139:35}>(move _128, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:139:29: 139:35}) -> [return: bb62, unwind: bb86];
    }

    bb62: {
        _126 = devise::MapperBuild::field_map::<{closure@core/codegen/src/derive/from_form.rs:140:24: 140:34}>(move _127, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:140:24: 140:34}) -> [return: bb63, unwind: bb86];
    }

    bb63: {
        _5 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_6, move _126) -> [return: bb64, unwind: bb86];
    }

    bb64: {
        _132 = devise::MapperBuild::new() -> [return: bb65, unwind: bb86];
    }

    bb65: {
        _131 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/from_form.rs:150:26: 150:37}>(move _132, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:150:26: 150:37}) -> [return: bb66, unwind: bb86];
    }

    bb66: {
        _130 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/from_form.rs:155:29: 155:35}>(move _131, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:155:29: 155:35}) -> [return: bb67, unwind: bb86];
    }

    bb67: {
        _4 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_5, move _130) -> [return: bb68, unwind: bb86];
    }

    bb68: {
        _135 = devise::MapperBuild::new() -> [return: bb69, unwind: bb86];
    }

    bb69: {
        _134 = devise::MapperBuild::try_input_map::<{closure@core/codegen/src/derive/from_form.rs:160:28: 160:43}>(move _135, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:160:28: 160:43}) -> [return: bb70, unwind: bb86];
    }

    bb70: {
        _133 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/from_form.rs:174:29: 174:35}>(move _134, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:174:29: 174:35}) -> [return: bb71, unwind: bb86];
    }

    bb71: {
        _3 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_4, move _133) -> [return: bb72, unwind: bb86];
    }

    bb72: {
        _139 = devise::MapperBuild::new() -> [return: bb73, unwind: bb86];
    }

    bb73: {
        _138 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/from_form.rs:180:26: 180:37}>(move _139, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:180:26: 180:37}) -> [return: bb74, unwind: bb86];
    }

    bb74: {
        _137 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/from_form.rs:188:29: 188:45}>(move _138, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:188:29: 188:45}) -> [return: bb75, unwind: bb86];
    }

    bb75: {
        _136 = devise::MapperBuild::try_field_map::<{closure@core/codegen/src/derive/from_form.rs:230:28: 230:34}>(move _137, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:230:28: 230:34}) -> [return: bb76, unwind: bb86];
    }

    bb76: {
        _2 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_3, move _136) -> [return: bb77, unwind: bb86];
    }

    bb77: {
        _0 = devise::DeriveGenerator::to_tokens::<TokenStream2>(_2) -> [return: bb78, unwind: bb86];
    }

    bb78: {
        drop(_14) -> [return: bb79, unwind continue];
    }

    bb79: {
        return;
    }

    bb80 (cleanup): {
        drop(_117) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        drop(_110) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        drop(_88) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        drop(_80) -> [return: bb84, unwind terminate(cleanup)];
    }

    bb84 (cleanup): {
        drop(_73) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb85 (cleanup): {
        drop(_45) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb86 (cleanup): {
        drop(_14) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb87 (cleanup): {
        drop(_17) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb88 (cleanup): {
        resume;
    }

    bb89 (cleanup): {
        drop(_15) -> [return: bb88, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        switchInt(_143) -> [0: bb88, otherwise: bb89];
    }
}

promoted[0] in from_form::derive_from_form: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form::derive_from_form: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:64:29: 64:35}, _2: &mut devise::ValidatorBuild, _3: devise::Input<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug i => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: std::option::Option<(usize, &syn::LifetimeDef)>;
    let mut _5: std::iter::Enumerate<syn::generics::Lifetimes<'_>>;
    let mut _6: syn::generics::Lifetimes<'_>;
    let _7: &syn::Generics;
    let _8: &devise::ItemInput;
    let mut _9: &devise::Input<'_>;
    let mut _10: isize;
    let _11: usize;
    let _12: &usize;
    let _13: &syn::LifetimeDef;
    let _14: &&syn::LifetimeDef;
    let mut _15: bool;
    let mut _16: usize;
    let mut _17: devise::Diagnostic;
    let mut _18: proc_macro2::Span;
    scope 1 {
        debug i => _11;
        debug i => _12;
        debug lt => _13;
        debug lt => _14;
    }

    bb0: {
        _9 = &_3;
        _8 = <devise::Input<'_> as std::ops::Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = ItemInput::generics(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = Generics::lifetimes(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <syn::generics::Lifetimes<'_> as Iterator>::enumerate(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <Enumerate<syn::generics::Lifetimes<'_>> as Iterator>::last(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [1: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb11;
    }

    bb7: {
        _12 = &(((_4 as Some).0: (usize, &syn::LifetimeDef)).0: usize);
        _14 = &(((_4 as Some).0: (usize, &syn::LifetimeDef)).1: &syn::LifetimeDef);
        _16 = (*_12);
        _15 = Ge(move _16, const 1_usize);
        switchInt(move _15) -> [0: bb6, otherwise: bb8];
    }

    bb8: {
        _11 = (((_4 as Some).0: (usize, &syn::LifetimeDef)).0: usize);
        _13 = (((_4 as Some).0: (usize, &syn::LifetimeDef)).1: &syn::LifetimeDef);
        _18 = <LifetimeDef as devise::Spanned>::span(_13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _17 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _18, const "only one lifetime is supported") -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _17);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn from_form::derive_from_form::{closure#1}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:68:30: 68:41}, _2: &mut devise::ValidatorBuild, _3: devise::Fields<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: devise::Fields<'_>;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro2::Span;
    let mut _8: &devise::Fields<'_>;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>>;
    let mut _10: std::result::Result<std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic>;
    let mut _11: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _12: devise::Fields<'_>;
    let mut _13: isize;
    let mut _16: isize;
    let mut _24: bool;
    let mut _25: devise::Diagnostic;
    let mut _26: devise::Diagnostic;
    let mut _27: devise::Diagnostic;
    let mut _28: devise::Diagnostic;
    let mut _29: devise::Diagnostic;
    let mut _30: devise::Diagnostic;
    scope 1 {
        debug d => _17;
        let _14: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _15: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>;
        let _17: ((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span));
        let _18: usize;
        let _19: proc_macro2::Span;
        let _20: proc_macro2::Span;
        scope 2 {
            debug residual => _14;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _15;
            scope 5 {
            }
        }
        scope 6 {
            debug field_a_i => _18;
            debug field_a => _19;
            debug name_a => _20;
            let _21: usize;
            let _22: proc_macro2::Span;
            let _23: proc_macro2::Span;
            scope 7 {
                debug field_b_i => _21;
                debug field_b => _22;
                debug name_b => _23;
            }
        }
    }

    bb0: {
        _5 = _3;
        _4 = devise::Fields::<'_>::is_empty(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _8 = &_3;
        _7 = <devise::Fields<'_> as devise::Spanned>::span(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _7, const "at least one field is required") -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _6);
        goto -> bb22;
    }

    bb5: {
        _12 = _3;
        _11 = devise::Fields::<'_>::iter(move _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = form_field::first_duplicate::<devise::Field<'_>, FieldName, Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:73:65: 73:68}>(move _11, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:73:65: 73:68}) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = <std::result::Result<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic> as std::ops::Try>::branch(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _13 = discriminant(_9);
        switchInt(move _13) -> [0: bb9, 1: bb11, otherwise: bb10];
    }

    bb9: {
        _15 = ((_9 as Continue).0: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>);
        _16 = discriminant(_15);
        switchInt(move _16) -> [1: bb13, otherwise: bb12];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _14 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<(), devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _14) -> [return: bb22, unwind continue];
    }

    bb12: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb22;
    }

    bb13: {
        _17 = ((_15 as Some).0: ((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span)));
        _18 = ((_17.0: (usize, proc_macro2::Span, proc_macro2::Span)).0: usize);
        _19 = ((_17.0: (usize, proc_macro2::Span, proc_macro2::Span)).1: proc_macro2::Span);
        _20 = ((_17.0: (usize, proc_macro2::Span, proc_macro2::Span)).2: proc_macro2::Span);
        _21 = ((_17.1: (usize, proc_macro2::Span, proc_macro2::Span)).0: usize);
        _22 = ((_17.1: (usize, proc_macro2::Span, proc_macro2::Span)).1: proc_macro2::Span);
        _23 = ((_17.1: (usize, proc_macro2::Span, proc_macro2::Span)).2: proc_macro2::Span);
        _24 = Eq(_18, _21);
        switchInt(move _24) -> [0: bb18, otherwise: bb14];
    }

    bb14: {
        _27 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_19, const "field has conflicting names") -> [return: bb15, unwind continue];
    }

    bb15: {
        _26 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _27, _20, const "this field name...") -> [return: bb16, unwind continue];
    }

    bb16: {
        _25 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _26, _23, const "...conflicts with this field name") -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _25);
        goto -> bb22;
    }

    bb18: {
        _30 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_23, const "field name conflicts with previous name") -> [return: bb19, unwind continue];
    }

    bb19: {
        _29 = devise::Diagnostic::span_help::<proc_macro2::Span, &str>(move _30, _22, const "declared in this field") -> [return: bb20, unwind continue];
    }

    bb20: {
        _28 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _29, _19, const "previous field with conflicting name") -> [return: bb21, unwind continue];
    }

    bb21: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _28);
        goto -> bb22;
    }

    bb22: {
        return;
    }
}

fn from_form::derive_from_form::{closure#1}::{closure#0}(_1: &{closure@core/codegen/src/derive/from_form.rs:73:65: 73:68}, _2: &devise::Field<'_>) -> std::result::Result<Vec<FieldName>, devise::Diagnostic> {
    debug f => _2;
    let mut _0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;

    bb0: {
        _0 = <devise::Field<'_> as form_field::FieldExt>::field_names(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#2}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:92:28: 92:43}, _2: &mut devise::MapperBuild, _3: devise::Input<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug input => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: proc_macro2::TokenStream;
    let _5: std::option::Option<syn::WhereClause>;
    let mut _6: (proc_macro2::TokenStream, std::option::Option<syn::WhereClause>);
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, proc_macro2::TokenStream>;
    let mut _9: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _10: isize;
    let mut _13: proc_macro2::TokenStream;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let mut _19: proc_macro2::Delimiter;
    let mut _20: proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: &str;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: &str;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let mut _34: proc_macro2::Delimiter;
    let mut _35: proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: &str;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let mut _42: proc_macro2::Delimiter;
    let mut _43: proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let _55: &proc_macro2::TokenStream;
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let _58: &std::option::Option<syn::WhereClause>;
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: proc_macro2::Delimiter;
    let mut _63: proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: &str;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: &str;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let _90: &str;
    let _91: ();
    let mut _92: &mut proc_macro2::TokenStream;
    let _93: ();
    let mut _94: &mut proc_macro2::TokenStream;
    let _95: &str;
    let _96: ();
    let mut _97: &mut proc_macro2::TokenStream;
    let _98: ();
    let mut _99: &mut proc_macro2::TokenStream;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let _102: &str;
    let _103: ();
    let mut _104: &mut proc_macro2::TokenStream;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: &str;
    let _114: ();
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: &str;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: ();
    let _126: &proc_macro2::TokenStream;
    let mut _127: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ctxt_ty => _4;
        debug where_clause => _5;
        let _7: proc_macro2::TokenStream;
        let _11: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _12: proc_macro2::TokenStream;
        scope 2 {
            debug output => _7;
            let mut _14: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _14;
                let mut _21: proc_macro2::TokenStream;
                let mut _36: proc_macro2::TokenStream;
                let mut _64: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _21;
                }
                scope 9 {
                    debug _s => _36;
                    let mut _44: proc_macro2::TokenStream;
                    scope 10 {
                        debug _s => _44;
                    }
                }
                scope 11 {
                    debug _s => _64;
                    let mut _128: &exports::StaticPath;
                    let mut _129: &exports::StaticPath;
                    let mut _130: &exports::StaticPath;
                    let mut _131: &exports::StaticPath;
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _6 = context_type(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = move (_6.0: proc_macro2::TokenStream);
        _5 = move (_6.1: std::option::Option<syn::WhereClause>);
        _9 = devise::mapper::input_default::<&mut devise::MapperBuild>(move _2, _3) -> [return: bb2, unwind: bb65];
    }

    bb2: {
        _8 = <std::result::Result<TokenStream2, devise::Diagnostic> as std::ops::Try>::branch(move _9) -> [return: bb3, unwind: bb65];
    }

    bb3: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _12 = move ((_8 as Continue).0: proc_macro2::TokenStream);
        _7 = move _12;
        _14 = TokenStream2::new() -> [return: bb8, unwind: bb64];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _11) -> [return: bb7, unwind: bb65];
    }

    bb7: {
        drop(_5) -> [return: bb57, unwind: bb66];
    }

    bb8: {
        _16 = &mut _14;
        _15 = push_pound(_16) -> [return: bb9, unwind: bb63];
    }

    bb9: {
        _18 = &mut _14;
        _19 = proc_macro2::Delimiter::Bracket;
        _21 = TokenStream2::new() -> [return: bb10, unwind: bb63];
    }

    bb10: {
        _23 = &mut _21;
        _24 = const "doc";
        _22 = push_ident(_23, _24) -> [return: bb11, unwind: bb62];
    }

    bb11: {
        _26 = &mut _21;
        _25 = push_eq(_26) -> [return: bb12, unwind: bb62];
    }

    bb12: {
        _28 = &mut _21;
        _29 = const "r\" Rocket generated FormForm context.\"";
        _27 = quote::__private::parse(_28, _29) -> [return: bb13, unwind: bb62];
    }

    bb13: {
        _20 = move _21;
        _17 = push_group(_18, move _19, move _20) -> [return: bb14, unwind: bb63];
    }

    bb14: {
        _31 = &mut _14;
        _30 = push_pound(_31) -> [return: bb15, unwind: bb63];
    }

    bb15: {
        _33 = &mut _14;
        _34 = proc_macro2::Delimiter::Bracket;
        _36 = TokenStream2::new() -> [return: bb16, unwind: bb63];
    }

    bb16: {
        _38 = &mut _36;
        _39 = const "doc";
        _37 = push_ident(_38, _39) -> [return: bb17, unwind: bb61];
    }

    bb17: {
        _41 = &mut _36;
        _42 = proc_macro2::Delimiter::Parenthesis;
        _44 = TokenStream2::new() -> [return: bb18, unwind: bb61];
    }

    bb18: {
        _46 = &mut _44;
        _47 = const "hidden";
        _45 = push_ident(_46, _47) -> [return: bb19, unwind: bb60];
    }

    bb19: {
        _43 = move _44;
        _40 = push_group(_41, move _42, move _43) -> [return: bb20, unwind: bb61];
    }

    bb20: {
        _35 = move _36;
        _32 = push_group(_33, move _34, move _35) -> [return: bb21, unwind: bb63];
    }

    bb21: {
        _49 = &mut _14;
        _50 = const "pub";
        _48 = push_ident(_49, _50) -> [return: bb22, unwind: bb63];
    }

    bb22: {
        _52 = &mut _14;
        _53 = const "struct";
        _51 = push_ident(_52, _53) -> [return: bb23, unwind: bb63];
    }

    bb23: {
        _55 = &_4;
        _56 = &mut _14;
        _54 = <TokenStream2 as ToTokens>::to_tokens(_55, _56) -> [return: bb24, unwind: bb63];
    }

    bb24: {
        _58 = &_5;
        _59 = &mut _14;
        _57 = <Option<WhereClause> as ToTokens>::to_tokens(_58, _59) -> [return: bb25, unwind: bb63];
    }

    bb25: {
        _61 = &mut _14;
        _62 = proc_macro2::Delimiter::Brace;
        _64 = TokenStream2::new() -> [return: bb26, unwind: bb63];
    }

    bb26: {
        _66 = &mut _64;
        _67 = const "__opts";
        _65 = push_ident(_66, _67) -> [return: bb27, unwind: bb59];
    }

    bb27: {
        _69 = &mut _64;
        _68 = push_colon(_69) -> [return: bb28, unwind: bb59];
    }

    bb28: {
        _131 = const _;
        _71 = &mut _64;
        _70 = <StaticPath as ToTokens>::to_tokens(_131, _71) -> [return: bb29, unwind: bb59];
    }

    bb29: {
        _73 = &mut _64;
        _72 = push_colon2(_73) -> [return: bb30, unwind: bb59];
    }

    bb30: {
        _75 = &mut _64;
        _76 = const "Options";
        _74 = push_ident(_75, _76) -> [return: bb31, unwind: bb59];
    }

    bb31: {
        _78 = &mut _64;
        _77 = push_comma(_78) -> [return: bb32, unwind: bb59];
    }

    bb32: {
        _80 = &mut _64;
        _81 = const "__errors";
        _79 = push_ident(_80, _81) -> [return: bb33, unwind: bb59];
    }

    bb33: {
        _83 = &mut _64;
        _82 = push_colon(_83) -> [return: bb34, unwind: bb59];
    }

    bb34: {
        _130 = const _;
        _85 = &mut _64;
        _84 = <StaticPath as ToTokens>::to_tokens(_130, _85) -> [return: bb35, unwind: bb59];
    }

    bb35: {
        _87 = &mut _64;
        _86 = push_colon2(_87) -> [return: bb36, unwind: bb59];
    }

    bb36: {
        _89 = &mut _64;
        _90 = const "Errors";
        _88 = push_ident(_89, _90) -> [return: bb37, unwind: bb59];
    }

    bb37: {
        _92 = &mut _64;
        _91 = push_lt(_92) -> [return: bb38, unwind: bb59];
    }

    bb38: {
        _94 = &mut _64;
        _95 = const "'__f";
        _93 = push_lifetime(_94, _95) -> [return: bb39, unwind: bb59];
    }

    bb39: {
        _97 = &mut _64;
        _96 = push_gt(_97) -> [return: bb40, unwind: bb59];
    }

    bb40: {
        _99 = &mut _64;
        _98 = push_comma(_99) -> [return: bb41, unwind: bb59];
    }

    bb41: {
        _101 = &mut _64;
        _102 = const "__parent";
        _100 = push_ident(_101, _102) -> [return: bb42, unwind: bb59];
    }

    bb42: {
        _104 = &mut _64;
        _103 = push_colon(_104) -> [return: bb43, unwind: bb59];
    }

    bb43: {
        _129 = const _;
        _106 = &mut _64;
        _105 = <StaticPath as ToTokens>::to_tokens(_129, _106) -> [return: bb44, unwind: bb59];
    }

    bb44: {
        _108 = &mut _64;
        _107 = push_lt(_108) -> [return: bb45, unwind: bb59];
    }

    bb45: {
        _110 = &mut _64;
        _109 = push_and(_110) -> [return: bb46, unwind: bb59];
    }

    bb46: {
        _112 = &mut _64;
        _113 = const "'__f";
        _111 = push_lifetime(_112, _113) -> [return: bb47, unwind: bb59];
    }

    bb47: {
        _128 = const _;
        _115 = &mut _64;
        _114 = <StaticPath as ToTokens>::to_tokens(_128, _115) -> [return: bb48, unwind: bb59];
    }

    bb48: {
        _117 = &mut _64;
        _116 = push_colon2(_117) -> [return: bb49, unwind: bb59];
    }

    bb49: {
        _119 = &mut _64;
        _120 = const "Name";
        _118 = push_ident(_119, _120) -> [return: bb50, unwind: bb59];
    }

    bb50: {
        _122 = &mut _64;
        _121 = push_gt(_122) -> [return: bb51, unwind: bb59];
    }

    bb51: {
        _124 = &mut _64;
        _123 = push_comma(_124) -> [return: bb52, unwind: bb59];
    }

    bb52: {
        _126 = &_7;
        _127 = &mut _64;
        _125 = <TokenStream2 as ToTokens>::to_tokens(_126, _127) -> [return: bb53, unwind: bb59];
    }

    bb53: {
        _63 = move _64;
        _60 = push_group(_61, move _62, move _63) -> [return: bb54, unwind: bb63];
    }

    bb54: {
        _13 = move _14;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _13);
        drop(_7) -> [return: bb55, unwind: bb65];
    }

    bb55: {
        drop(_5) -> [return: bb56, unwind: bb66];
    }

    bb56: {
        drop(_4) -> [return: bb58, unwind continue];
    }

    bb57: {
        drop(_4) -> [return: bb58, unwind continue];
    }

    bb58: {
        return;
    }

    bb59 (cleanup): {
        drop(_64) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_44) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_36) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_21) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_14) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_7) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_5) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_4) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form::derive_from_form::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in from_form::derive_from_form::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#3}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:106:29: 106:35}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug m => _2;
    debug f => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _0 = fields_null::<&mut devise::MapperBuild>(move _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#4}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:107:24: 107:34}, _2: &mut devise::MapperBuild, _3: devise::Field<'_>) -> TokenStream2 {
    debug field => _3;
    let mut _0: proc_macro2::TokenStream;
    let _4: &proc_macro2::Ident;
    let mut _5: syn::Type;
    let mut _6: (&proc_macro2::Ident, syn::Type);
    let mut _7: &proc_macro2::Ident;
    let mut _8: &devise::Field<'_>;
    let mut _9: syn::Type;
    let mut _10: &devise::Field<'_>;
    let _11: ();
    let mut _12: &mut syn::Type;
    let mut _13: syn::Lifetime;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let mut _23: &syn::Type;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let _29: &syn::Type;
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: &str;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let mut _55: &proc_macro2::TokenStream;
    let mut _56: proc_macro2::Span;
    let mut _57: &syn::Type;
    let mut _60: &syn::Type;
    let _61: ();
    let _62: &&proc_macro2::Ident;
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let _67: &proc_macro2::TokenStream;
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ident => _4;
        debug ty => _5;
        let mut _15: proc_macro2::TokenStream;
        let _19: proc_macro2::TokenStream;
        let _20: proc_macro2::TokenStream;
        let mut _21: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _15;
        }
        scope 3 {
            debug field_ty => _19;
            let mut _58: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _58;
                let _59: proc_macro2::Span;
                scope 8 {
                    debug _span => _59;
                }
            }
        }
        scope 4 {
            debug tokens => _20;
        }
        scope 5 {
            debug _s => _21;
            let _22: proc_macro2::Span;
            scope 6 {
                debug _span => _22;
                let mut _71: &exports::StaticPath;
                let mut _72: &exports::StaticPath;
            }
        }
    }

    bb0: {
        _8 = &_3;
        _7 = <devise::Field<'_> as form_field::FieldExt>::ident(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &_3;
        _9 = <devise::Field<'_> as form_field::FieldExt>::stripped_ty(move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = (move _7, move _9);
        _4 = (_6.0: &proc_macro2::Ident);
        _5 = move (_6.1: syn::Type);
        _12 = &mut _5;
        _15 = TokenStream2::new() -> [return: bb3, unwind: bb38];
    }

    bb3: {
        _17 = &mut _15;
        _18 = const "'__f";
        _16 = push_lifetime(_17, _18) -> [return: bb4, unwind: bb37];
    }

    bb4: {
        _14 = move _15;
        _13 = syn::parse_quote::parse::<syn::Lifetime>(move _14) -> [return: bb5, unwind: bb38];
    }

    bb5: {
        _11 = <syn::Type as devise::ext::TypeExt>::replace_lifetimes(move _12, move _13) -> [return: bb6, unwind: bb38];
    }

    bb6: {
        _21 = TokenStream2::new() -> [return: bb7, unwind: bb38];
    }

    bb7: {
        _23 = &_5;
        _22 = <syn::Type as devise::Spanned>::span(move _23) -> [return: bb8, unwind: bb36];
    }

    bb8: {
        _72 = const _;
        _25 = &mut _21;
        _24 = <StaticPath as ToTokens>::to_tokens(_72, _25) -> [return: bb9, unwind: bb36];
    }

    bb9: {
        _27 = &mut _21;
        _26 = push_shl_spanned(_27, _22) -> [return: bb10, unwind: bb36];
    }

    bb10: {
        _29 = &_5;
        _30 = &mut _21;
        _28 = <syn::Type as ToTokens>::to_tokens(_29, _30) -> [return: bb11, unwind: bb36];
    }

    bb11: {
        _32 = &mut _21;
        _33 = const "as";
        _31 = push_ident_spanned(_32, _22, _33) -> [return: bb12, unwind: bb36];
    }

    bb12: {
        _71 = const _;
        _35 = &mut _21;
        _34 = <StaticPath as ToTokens>::to_tokens(_71, _35) -> [return: bb13, unwind: bb36];
    }

    bb13: {
        _37 = &mut _21;
        _36 = push_colon2_spanned(_37, _22) -> [return: bb14, unwind: bb36];
    }

    bb14: {
        _39 = &mut _21;
        _40 = const "FromForm";
        _38 = push_ident_spanned(_39, _22, _40) -> [return: bb15, unwind: bb36];
    }

    bb15: {
        _42 = &mut _21;
        _41 = push_lt_spanned(_42, _22) -> [return: bb16, unwind: bb36];
    }

    bb16: {
        _44 = &mut _21;
        _45 = const "'__f";
        _43 = push_lifetime_spanned(_44, _22, _45) -> [return: bb17, unwind: bb36];
    }

    bb17: {
        _47 = &mut _21;
        _46 = push_shr_spanned(_47, _22) -> [return: bb18, unwind: bb36];
    }

    bb18: {
        _49 = &mut _21;
        _48 = push_colon2_spanned(_49, _22) -> [return: bb19, unwind: bb36];
    }

    bb19: {
        _51 = &mut _21;
        _52 = const "Context";
        _50 = push_ident_spanned(_51, _22, _52) -> [return: bb20, unwind: bb36];
    }

    bb20: {
        _54 = &mut _21;
        _53 = push_gt_spanned(_54, _22) -> [return: bb21, unwind: bb36];
    }

    bb21: {
        _20 = move _21;
        _55 = &_20;
        _57 = &_5;
        _56 = <syn::Type as devise::Spanned>::span(move _57) -> [return: bb22, unwind: bb35];
    }

    bb22: {
        _19 = <TokenStream2 as AstItemExt>::respanned_tokens(move _55, move _56) -> [return: bb23, unwind: bb35];
    }

    bb23: {
        drop(_20) -> [return: bb24, unwind: bb38];
    }

    bb24: {
        _58 = TokenStream2::new() -> [return: bb25, unwind: bb34];
    }

    bb25: {
        _60 = &_5;
        _59 = <syn::Type as devise::Spanned>::span(move _60) -> [return: bb26, unwind: bb33];
    }

    bb26: {
        _62 = &_4;
        _63 = &mut _58;
        _61 = <&proc_macro2::Ident as ToTokens>::to_tokens(_62, _63) -> [return: bb27, unwind: bb33];
    }

    bb27: {
        _65 = &mut _58;
        _64 = push_colon_spanned(_65, _59) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        _67 = &_19;
        _68 = &mut _58;
        _66 = <TokenStream2 as ToTokens>::to_tokens(_67, _68) -> [return: bb29, unwind: bb33];
    }

    bb29: {
        _70 = &mut _58;
        _69 = push_comma_spanned(_70, _59) -> [return: bb30, unwind: bb33];
    }

    bb30: {
        _0 = move _58;
        drop(_19) -> [return: bb31, unwind: bb38];
    }

    bb31: {
        drop(_5) -> [return: bb32, unwind continue];
    }

    bb32: {
        return;
    }

    bb33 (cleanup): {
        drop(_58) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_19) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_20) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_21) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_15) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_5) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#4}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#4}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#5}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:123:28: 123:43}, _2: &mut devise::MapperBuild, _3: devise::Input<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug input => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: proc_macro2::TokenStream;
    let mut _5: (proc_macro2::TokenStream, std::option::Option<syn::WhereClause>);
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, proc_macro2::TokenStream>;
    let mut _8: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _9: isize;
    let mut _12: proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: &str;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let _23: &proc_macro2::TokenStream;
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: &str;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let mut _35: proc_macro2::Delimiter;
    let mut _36: proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: &str;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: proc_macro2::Delimiter;
    let mut _63: proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let mut _75: proc_macro2::Delimiter;
    let mut _76: proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: &str;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: &str;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: &str;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: &str;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let mut _102: proc_macro2::Delimiter;
    let mut _103: proc_macro2::TokenStream;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: ();
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: &str;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: ();
    let _116: &proc_macro2::TokenStream;
    let mut _117: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ctxt_ty => _4;
        let _6: proc_macro2::TokenStream;
        let _10: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _11: proc_macro2::TokenStream;
        scope 2 {
            debug output => _6;
            let mut _13: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _13;
                let mut _37: proc_macro2::TokenStream;
                let mut _64: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _37;
                    let mut _120: &exports::StaticPath;
                }
                scope 9 {
                    debug _s => _64;
                    let mut _77: proc_macro2::TokenStream;
                    scope 10 {
                        debug _s => _77;
                        let mut _118: &exports::StaticPath;
                        let mut _119: &exports::StaticPath;
                    }
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _5 = context_type(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = move (_5.0: proc_macro2::TokenStream);
        drop((_5.1: std::option::Option<syn::WhereClause>)) -> [return: bb60, unwind: bb58];
    }

    bb2: {
        _7 = <std::result::Result<TokenStream2, devise::Diagnostic> as std::ops::Try>::branch(move _8) -> [return: bb3, unwind: bb58];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _11 = move ((_7 as Continue).0: proc_macro2::TokenStream);
        _6 = move _11;
        _13 = TokenStream2::new() -> [return: bb8, unwind: bb57];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _10) -> [return: bb7, unwind: bb58];
    }

    bb7: {
        drop(_4) -> [return: bb52, unwind continue];
    }

    bb8: {
        _15 = &mut _13;
        _16 = const "type";
        _14 = push_ident(_15, _16) -> [return: bb9, unwind: bb56];
    }

    bb9: {
        _18 = &mut _13;
        _19 = const "Context";
        _17 = push_ident(_18, _19) -> [return: bb10, unwind: bb56];
    }

    bb10: {
        _21 = &mut _13;
        _20 = push_eq(_21) -> [return: bb11, unwind: bb56];
    }

    bb11: {
        _23 = &_4;
        _24 = &mut _13;
        _22 = <TokenStream2 as ToTokens>::to_tokens(_23, _24) -> [return: bb12, unwind: bb56];
    }

    bb12: {
        _26 = &mut _13;
        _25 = push_semi(_26) -> [return: bb13, unwind: bb56];
    }

    bb13: {
        _28 = &mut _13;
        _29 = const "fn";
        _27 = push_ident(_28, _29) -> [return: bb14, unwind: bb56];
    }

    bb14: {
        _31 = &mut _13;
        _32 = const "init";
        _30 = push_ident(_31, _32) -> [return: bb15, unwind: bb56];
    }

    bb15: {
        _34 = &mut _13;
        _35 = proc_macro2::Delimiter::Parenthesis;
        _37 = TokenStream2::new() -> [return: bb16, unwind: bb56];
    }

    bb16: {
        _39 = &mut _37;
        _40 = const "__opts";
        _38 = push_ident(_39, _40) -> [return: bb17, unwind: bb55];
    }

    bb17: {
        _42 = &mut _37;
        _41 = push_colon(_42) -> [return: bb18, unwind: bb55];
    }

    bb18: {
        _120 = const _;
        _44 = &mut _37;
        _43 = <StaticPath as ToTokens>::to_tokens(_120, _44) -> [return: bb19, unwind: bb55];
    }

    bb19: {
        _46 = &mut _37;
        _45 = push_colon2(_46) -> [return: bb20, unwind: bb55];
    }

    bb20: {
        _48 = &mut _37;
        _49 = const "Options";
        _47 = push_ident(_48, _49) -> [return: bb21, unwind: bb55];
    }

    bb21: {
        _36 = move _37;
        _33 = push_group(_34, move _35, move _36) -> [return: bb22, unwind: bb56];
    }

    bb22: {
        _51 = &mut _13;
        _50 = push_rarrow(_51) -> [return: bb23, unwind: bb56];
    }

    bb23: {
        _53 = &mut _13;
        _54 = const "Self";
        _52 = push_ident(_53, _54) -> [return: bb24, unwind: bb56];
    }

    bb24: {
        _56 = &mut _13;
        _55 = push_colon2(_56) -> [return: bb25, unwind: bb56];
    }

    bb25: {
        _58 = &mut _13;
        _59 = const "Context";
        _57 = push_ident(_58, _59) -> [return: bb26, unwind: bb56];
    }

    bb26: {
        _61 = &mut _13;
        _62 = proc_macro2::Delimiter::Brace;
        _64 = TokenStream2::new() -> [return: bb27, unwind: bb56];
    }

    bb27: {
        _66 = &mut _64;
        _67 = const "Self";
        _65 = push_ident(_66, _67) -> [return: bb28, unwind: bb54];
    }

    bb28: {
        _69 = &mut _64;
        _68 = push_colon2(_69) -> [return: bb29, unwind: bb54];
    }

    bb29: {
        _71 = &mut _64;
        _72 = const "Context";
        _70 = push_ident(_71, _72) -> [return: bb30, unwind: bb54];
    }

    bb30: {
        _74 = &mut _64;
        _75 = proc_macro2::Delimiter::Brace;
        _77 = TokenStream2::new() -> [return: bb31, unwind: bb54];
    }

    bb31: {
        _79 = &mut _77;
        _80 = const "__opts";
        _78 = push_ident(_79, _80) -> [return: bb32, unwind: bb53];
    }

    bb32: {
        _82 = &mut _77;
        _81 = push_comma(_82) -> [return: bb33, unwind: bb53];
    }

    bb33: {
        _84 = &mut _77;
        _85 = const "__errors";
        _83 = push_ident(_84, _85) -> [return: bb34, unwind: bb53];
    }

    bb34: {
        _87 = &mut _77;
        _86 = push_colon(_87) -> [return: bb35, unwind: bb53];
    }

    bb35: {
        _119 = const _;
        _89 = &mut _77;
        _88 = <StaticPath as ToTokens>::to_tokens(_119, _89) -> [return: bb36, unwind: bb53];
    }

    bb36: {
        _91 = &mut _77;
        _90 = push_colon2(_91) -> [return: bb37, unwind: bb53];
    }

    bb37: {
        _93 = &mut _77;
        _94 = const "Errors";
        _92 = push_ident(_93, _94) -> [return: bb38, unwind: bb53];
    }

    bb38: {
        _96 = &mut _77;
        _95 = push_colon2(_96) -> [return: bb39, unwind: bb53];
    }

    bb39: {
        _98 = &mut _77;
        _99 = const "new";
        _97 = push_ident(_98, _99) -> [return: bb40, unwind: bb53];
    }

    bb40: {
        _101 = &mut _77;
        _102 = proc_macro2::Delimiter::Parenthesis;
        _103 = TokenStream2::new() -> [return: bb41, unwind: bb53];
    }

    bb41: {
        _100 = push_group(_101, move _102, move _103) -> [return: bb42, unwind: bb53];
    }

    bb42: {
        _105 = &mut _77;
        _104 = push_comma(_105) -> [return: bb43, unwind: bb53];
    }

    bb43: {
        _107 = &mut _77;
        _108 = const "__parent";
        _106 = push_ident(_107, _108) -> [return: bb44, unwind: bb53];
    }

    bb44: {
        _110 = &mut _77;
        _109 = push_colon(_110) -> [return: bb45, unwind: bb53];
    }

    bb45: {
        _118 = const _;
        _112 = &mut _77;
        _111 = <StaticPath as ToTokens>::to_tokens(_118, _112) -> [return: bb46, unwind: bb53];
    }

    bb46: {
        _114 = &mut _77;
        _113 = push_comma(_114) -> [return: bb47, unwind: bb53];
    }

    bb47: {
        _116 = &_6;
        _117 = &mut _77;
        _115 = <TokenStream2 as ToTokens>::to_tokens(_116, _117) -> [return: bb48, unwind: bb53];
    }

    bb48: {
        _76 = move _77;
        _73 = push_group(_74, move _75, move _76) -> [return: bb49, unwind: bb54];
    }

    bb49: {
        _63 = move _64;
        _60 = push_group(_61, move _62, move _63) -> [return: bb50, unwind: bb56];
    }

    bb50: {
        _12 = move _13;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _12);
        drop(_6) -> [return: bb51, unwind: bb58];
    }

    bb51: {
        drop(_4) -> [return: bb52, unwind continue];
    }

    bb52: {
        return;
    }

    bb53 (cleanup): {
        drop(_77) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_64) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_37) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_13) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_6) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_4) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        resume;
    }

    bb60: {
        _8 = devise::mapper::input_default::<&mut devise::MapperBuild>(move _2, _3) -> [return: bb2, unwind: bb58];
    }
}

promoted[0] in from_form::derive_from_form::{closure#5}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#5}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form::derive_from_form::{closure#5}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#6}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:139:29: 139:35}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug m => _2;
    debug f => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _0 = fields_null::<&mut devise::MapperBuild>(move _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#7}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:140:24: 140:34}, _2: &mut devise::MapperBuild, _3: devise::Field<'_>) -> TokenStream2 {
    debug field => _3;
    let mut _0: proc_macro2::TokenStream;
    let _4: &proc_macro2::Ident;
    let mut _5: std::option::Option<&proc_macro2::Ident>;
    let mut _6: &std::option::Option<proc_macro2::Ident>;
    let _7: &syn::Field;
    let _8: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _9: &devise::Field<'_>;
    let _10: &str;
    let mut _12: &syn::Type;
    let _13: &syn::Field;
    let _14: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _15: &devise::Field<'_>;
    let mut _18: &syn::Type;
    let _19: ();
    let _20: &&proc_macro2::Ident;
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ident => _4;
        let _11: syn::Type;
        scope 2 {
            debug ty => _11;
            let mut _16: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _16;
                let _17: proc_macro2::Span;
                scope 4 {
                    debug _span => _17;
                    let mut _28: &exports::StaticPath;
                }
            }
        }
    }

    bb0: {
        _9 = &_3;
        _8 = <devise::Field<'_> as std::ops::Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = &((*_7).2: std::option::Option<proc_macro2::Ident>);
        _5 = Option::<proc_macro2::Ident>::as_ref(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = const "named";
        _4 = Option::<&proc_macro2::Ident>::expect(move _5, _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _15 = &_3;
        _14 = <devise::Field<'_> as std::ops::Deref>::deref(move _15) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = &((*_13).4: syn::Type);
        _11 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _16 = TokenStream2::new() -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _18 = &_11;
        _17 = <syn::Type as devise::Spanned>::span(move _18) -> [return: bb9, unwind: bb15];
    }

    bb9: {
        _20 = &_4;
        _21 = &mut _16;
        _19 = <&proc_macro2::Ident as ToTokens>::to_tokens(_20, _21) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _23 = &mut _16;
        _22 = push_colon_spanned(_23, _17) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _28 = const _;
        _25 = &mut _16;
        _24 = <StaticPath as ToTokens>::to_tokens(_28, _25) -> [return: bb12, unwind: bb15];
    }

    bb12: {
        _27 = &mut _16;
        _26 = push_comma_spanned(_27, _17) -> [return: bb13, unwind: bb15];
    }

    bb13: {
        _0 = move _16;
        drop(_11) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_16) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_11) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#7}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#8}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:150:26: 150:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: &str;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let mut _57: proc_macro2::Delimiter;
    let mut _58: proc_macro2::TokenStream;
    let _60: ();
    let _61: &proc_macro2::TokenStream;
    let mut _62: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _59: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _15;
            let mut _63: &exports::StaticPath;
        }
        scope 3 {
            debug _s => _59;
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb29];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "push_value";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb28];
    }

    bb4: {
        _17 = &mut _15;
        _18 = const "__c";
        _16 = push_ident(_17, _18) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _20 = &mut _15;
        _19 = push_colon(_20) -> [return: bb6, unwind: bb27];
    }

    bb6: {
        _22 = &mut _15;
        _21 = push_and(_22) -> [return: bb7, unwind: bb27];
    }

    bb7: {
        _24 = &mut _15;
        _25 = const "mut";
        _23 = push_ident(_24, _25) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _27 = &mut _15;
        _28 = const "Self";
        _26 = push_ident(_27, _28) -> [return: bb9, unwind: bb27];
    }

    bb9: {
        _30 = &mut _15;
        _29 = push_colon2(_30) -> [return: bb10, unwind: bb27];
    }

    bb10: {
        _32 = &mut _15;
        _33 = const "Context";
        _31 = push_ident(_32, _33) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _35 = &mut _15;
        _34 = push_comma(_35) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _37 = &mut _15;
        _38 = const "__f";
        _36 = push_ident(_37, _38) -> [return: bb13, unwind: bb27];
    }

    bb13: {
        _40 = &mut _15;
        _39 = push_colon(_40) -> [return: bb14, unwind: bb27];
    }

    bb14: {
        _63 = const _;
        _42 = &mut _15;
        _41 = <StaticPath as ToTokens>::to_tokens(_63, _42) -> [return: bb15, unwind: bb27];
    }

    bb15: {
        _44 = &mut _15;
        _43 = push_colon2(_44) -> [return: bb16, unwind: bb27];
    }

    bb16: {
        _46 = &mut _15;
        _47 = const "ValueField";
        _45 = push_ident(_46, _47) -> [return: bb17, unwind: bb27];
    }

    bb17: {
        _49 = &mut _15;
        _48 = push_lt(_49) -> [return: bb18, unwind: bb27];
    }

    bb18: {
        _51 = &mut _15;
        _52 = const "'__f";
        _50 = push_lifetime(_51, _52) -> [return: bb19, unwind: bb27];
    }

    bb19: {
        _54 = &mut _15;
        _53 = push_gt(_54) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb21, unwind: bb28];
    }

    bb21: {
        _56 = &mut _4;
        _57 = proc_macro2::Delimiter::Brace;
        _59 = TokenStream2::new() -> [return: bb22, unwind: bb28];
    }

    bb22: {
        _61 = &_3;
        _62 = &mut _59;
        _60 = <TokenStream2 as ToTokens>::to_tokens(_61, _62) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        _58 = move _59;
        _55 = push_group(_56, move _57, move _58) -> [return: bb24, unwind: bb28];
    }

    bb24: {
        _0 = move _4;
        drop(_3) -> [return: bb25, unwind continue];
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        drop(_59) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_15) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_4) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_3) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#8}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#9}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:155:29: 155:35}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _0 = fields_map::<{closure@core/codegen/src/derive/from_form.rs:155:50: 155:60}>(_3, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:155:50: 155:60}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#9}::{closure#0}(_1: &{closure@core/codegen/src/derive/from_form.rs:155:50: 155:60}, _2: &syn::Type, _3: &syn::Expr) -> TokenStream2 {
    debug ty => _2;
    debug ctxt => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let mut _6: &syn::Type;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let mut _9: proc_macro2::Delimiter;
    let mut _10: proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let _15: &&syn::Type;
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: &str;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let mut _41: proc_macro2::Delimiter;
    let mut _42: proc_macro2::TokenStream;
    let _44: ();
    let _45: &&syn::Expr;
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &str;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: &str;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let mut _59: proc_macro2::Delimiter;
    let mut _60: proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let _5: proc_macro2::Span;
        scope 2 {
            debug _span => _5;
            let mut _11: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _11;
                scope 4 {
                    debug _span => _5;
                    let mut _43: proc_macro2::TokenStream;
                    let mut _63: &exports::StaticPath;
                    scope 5 {
                        debug _s => _43;
                        scope 6 {
                            debug _span => _5;
                            scope 7 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = _2;
        _5 = <syn::Type as devise::Spanned>::span(move _6) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _8 = &mut _4;
        _9 = proc_macro2::Delimiter::Brace;
        _11 = TokenStream2::new() -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _13 = &mut _11;
        _12 = push_lt_spanned(_13, _5) -> [return: bb4, unwind: bb27];
    }

    bb4: {
        _15 = &_2;
        _16 = &mut _11;
        _14 = <&syn::Type as ToTokens>::to_tokens(_15, _16) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _18 = &mut _11;
        _19 = const "as";
        _17 = push_ident_spanned(_18, _5, _19) -> [return: bb6, unwind: bb27];
    }

    bb6: {
        _63 = const _;
        _21 = &mut _11;
        _20 = <StaticPath as ToTokens>::to_tokens(_63, _21) -> [return: bb7, unwind: bb27];
    }

    bb7: {
        _23 = &mut _11;
        _22 = push_colon2_spanned(_23, _5) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _25 = &mut _11;
        _26 = const "FromForm";
        _24 = push_ident_spanned(_25, _5, _26) -> [return: bb9, unwind: bb27];
    }

    bb9: {
        _28 = &mut _11;
        _27 = push_lt_spanned(_28, _5) -> [return: bb10, unwind: bb27];
    }

    bb10: {
        _30 = &mut _11;
        _31 = const "'__f";
        _29 = push_lifetime_spanned(_30, _5, _31) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _33 = &mut _11;
        _32 = push_shr_spanned(_33, _5) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _35 = &mut _11;
        _34 = push_colon2_spanned(_35, _5) -> [return: bb13, unwind: bb27];
    }

    bb13: {
        _37 = &mut _11;
        _38 = const "push_value";
        _36 = push_ident_spanned(_37, _5, _38) -> [return: bb14, unwind: bb27];
    }

    bb14: {
        _40 = &mut _11;
        _41 = proc_macro2::Delimiter::Parenthesis;
        _43 = TokenStream2::new() -> [return: bb15, unwind: bb27];
    }

    bb15: {
        _45 = &_3;
        _46 = &mut _43;
        _44 = <&syn::Expr as ToTokens>::to_tokens(_45, _46) -> [return: bb16, unwind: bb26];
    }

    bb16: {
        _48 = &mut _43;
        _47 = push_comma_spanned(_48, _5) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _50 = &mut _43;
        _51 = const "__f";
        _49 = push_ident_spanned(_50, _5, _51) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _53 = &mut _43;
        _52 = push_dot_spanned(_53, _5) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _55 = &mut _43;
        _56 = const "shift";
        _54 = push_ident_spanned(_55, _5, _56) -> [return: bb20, unwind: bb26];
    }

    bb20: {
        _58 = &mut _43;
        _59 = proc_macro2::Delimiter::Parenthesis;
        _60 = TokenStream2::new() -> [return: bb21, unwind: bb26];
    }

    bb21: {
        _57 = push_group_spanned(_58, _5, move _59, move _60) -> [return: bb22, unwind: bb26];
    }

    bb22: {
        _42 = move _43;
        _39 = push_group_spanned(_40, _5, move _41, move _42) -> [return: bb23, unwind: bb27];
    }

    bb23: {
        _62 = &mut _11;
        _61 = push_semi_spanned(_62, _5) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        _10 = move _11;
        _7 = push_group_spanned(_8, _5, move _9, move _10) -> [return: bb25, unwind: bb28];
    }

    bb25: {
        _0 = move _4;
        return;
    }

    bb26 (cleanup): {
        drop(_43) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_11) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_4) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#9}::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#10}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:160:28: 160:43}, _2: &mut devise::MapperBuild, _3: devise::Input<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug input => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: proc_macro2::TokenStream;
    let mut _5: (proc_macro2::TokenStream, std::option::Option<syn::WhereClause>);
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, proc_macro2::TokenStream>;
    let mut _8: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _9: isize;
    let mut _12: proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: &str;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &str;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let mut _25: proc_macro2::Delimiter;
    let mut _26: proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: &str;
    let _38: ();
    let _39: &proc_macro2::TokenStream;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: &str;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: ();
    let mut _68: &mut proc_macro2::TokenStream;
    let mut _69: proc_macro2::Delimiter;
    let mut _70: proc_macro2::TokenStream;
    let _72: ();
    let _73: &proc_macro2::TokenStream;
    let mut _74: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ctxt_ty => _4;
        let _6: proc_macro2::TokenStream;
        let _10: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _11: proc_macro2::TokenStream;
        scope 2 {
            debug output => _6;
            let mut _13: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _13;
                let mut _27: proc_macro2::TokenStream;
                let mut _71: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _27;
                    let mut _75: &exports::StaticPath;
                }
                scope 9 {
                    debug _s => _71;
                }
            }
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _5 = context_type(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = move (_5.0: proc_macro2::TokenStream);
        drop((_5.1: std::option::Option<syn::WhereClause>)) -> [return: bb41, unwind: bb39];
    }

    bb2: {
        _7 = <std::result::Result<TokenStream2, devise::Diagnostic> as std::ops::Try>::branch(move _8) -> [return: bb3, unwind: bb39];
    }

    bb3: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _11 = move ((_7 as Continue).0: proc_macro2::TokenStream);
        _6 = move _11;
        _13 = TokenStream2::new() -> [return: bb8, unwind: bb38];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _10) -> [return: bb7, unwind: bb39];
    }

    bb7: {
        drop(_4) -> [return: bb34, unwind continue];
    }

    bb8: {
        _15 = &mut _13;
        _16 = const "async";
        _14 = push_ident(_15, _16) -> [return: bb9, unwind: bb37];
    }

    bb9: {
        _18 = &mut _13;
        _19 = const "fn";
        _17 = push_ident(_18, _19) -> [return: bb10, unwind: bb37];
    }

    bb10: {
        _21 = &mut _13;
        _22 = const "push_data";
        _20 = push_ident(_21, _22) -> [return: bb11, unwind: bb37];
    }

    bb11: {
        _24 = &mut _13;
        _25 = proc_macro2::Delimiter::Parenthesis;
        _27 = TokenStream2::new() -> [return: bb12, unwind: bb37];
    }

    bb12: {
        _29 = &mut _27;
        _30 = const "__c";
        _28 = push_ident(_29, _30) -> [return: bb13, unwind: bb36];
    }

    bb13: {
        _32 = &mut _27;
        _31 = push_colon(_32) -> [return: bb14, unwind: bb36];
    }

    bb14: {
        _34 = &mut _27;
        _33 = push_and(_34) -> [return: bb15, unwind: bb36];
    }

    bb15: {
        _36 = &mut _27;
        _37 = const "mut";
        _35 = push_ident(_36, _37) -> [return: bb16, unwind: bb36];
    }

    bb16: {
        _39 = &_4;
        _40 = &mut _27;
        _38 = <TokenStream2 as ToTokens>::to_tokens(_39, _40) -> [return: bb17, unwind: bb36];
    }

    bb17: {
        _42 = &mut _27;
        _41 = push_comma(_42) -> [return: bb18, unwind: bb36];
    }

    bb18: {
        _44 = &mut _27;
        _45 = const "__f";
        _43 = push_ident(_44, _45) -> [return: bb19, unwind: bb36];
    }

    bb19: {
        _47 = &mut _27;
        _46 = push_colon(_47) -> [return: bb20, unwind: bb36];
    }

    bb20: {
        _75 = const _;
        _49 = &mut _27;
        _48 = <StaticPath as ToTokens>::to_tokens(_75, _49) -> [return: bb21, unwind: bb36];
    }

    bb21: {
        _51 = &mut _27;
        _50 = push_colon2(_51) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        _53 = &mut _27;
        _54 = const "DataField";
        _52 = push_ident(_53, _54) -> [return: bb23, unwind: bb36];
    }

    bb23: {
        _56 = &mut _27;
        _55 = push_lt(_56) -> [return: bb24, unwind: bb36];
    }

    bb24: {
        _58 = &mut _27;
        _59 = const "'__f";
        _57 = push_lifetime(_58, _59) -> [return: bb25, unwind: bb36];
    }

    bb25: {
        _61 = &mut _27;
        _60 = push_comma(_61) -> [return: bb26, unwind: bb36];
    }

    bb26: {
        _63 = &mut _27;
        _64 = const "'_";
        _62 = push_lifetime(_63, _64) -> [return: bb27, unwind: bb36];
    }

    bb27: {
        _66 = &mut _27;
        _65 = push_gt(_66) -> [return: bb28, unwind: bb36];
    }

    bb28: {
        _26 = move _27;
        _23 = push_group(_24, move _25, move _26) -> [return: bb29, unwind: bb37];
    }

    bb29: {
        _68 = &mut _13;
        _69 = proc_macro2::Delimiter::Brace;
        _71 = TokenStream2::new() -> [return: bb30, unwind: bb37];
    }

    bb30: {
        _73 = &_6;
        _74 = &mut _71;
        _72 = <TokenStream2 as ToTokens>::to_tokens(_73, _74) -> [return: bb31, unwind: bb35];
    }

    bb31: {
        _70 = move _71;
        _67 = push_group(_68, move _69, move _70) -> [return: bb32, unwind: bb37];
    }

    bb32: {
        _12 = move _13;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _12);
        drop(_6) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        drop(_4) -> [return: bb34, unwind continue];
    }

    bb34: {
        return;
    }

    bb35 (cleanup): {
        drop(_71) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_27) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_13) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_6) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_4) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        resume;
    }

    bb41: {
        _8 = devise::mapper::input_default::<&mut devise::MapperBuild>(move _2, _3) -> [return: bb2, unwind: bb39];
    }
}

promoted[0] in from_form::derive_from_form::{closure#10}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#11}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:174:29: 174:35}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _0 = fields_map::<{closure@core/codegen/src/derive/from_form.rs:174:50: 174:60}>(_3, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:174:50: 174:60}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#11}::{closure#0}(_1: &{closure@core/codegen/src/derive/from_form.rs:174:50: 174:60}, _2: &syn::Type, _3: &syn::Expr) -> TokenStream2 {
    debug ty => _2;
    debug ctxt => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let mut _6: &syn::Type;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let mut _9: proc_macro2::Delimiter;
    let mut _10: proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: &str;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: &str;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let _23: &&syn::Type;
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: &str;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: &str;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let mut _49: proc_macro2::Delimiter;
    let mut _50: proc_macro2::TokenStream;
    let _52: ();
    let _53: &&syn::Expr;
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: &str;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let mut _67: proc_macro2::Delimiter;
    let mut _68: proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: &str;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let _5: proc_macro2::Span;
        scope 2 {
            debug _span => _5;
            let mut _11: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _11;
                scope 4 {
                    debug _span => _5;
                    let mut _51: proc_macro2::TokenStream;
                    let mut _81: &exports::StaticPath;
                    scope 5 {
                        debug _s => _51;
                        scope 6 {
                            debug _span => _5;
                            scope 7 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = _2;
        _5 = <syn::Type as devise::Spanned>::span(move _6) -> [return: bb2, unwind: bb35];
    }

    bb2: {
        _8 = &mut _4;
        _9 = proc_macro2::Delimiter::Brace;
        _11 = TokenStream2::new() -> [return: bb3, unwind: bb35];
    }

    bb3: {
        _13 = &mut _11;
        _14 = const "let";
        _12 = push_ident_spanned(_13, _5, _14) -> [return: bb4, unwind: bb34];
    }

    bb4: {
        _16 = &mut _11;
        _17 = const "_fut";
        _15 = push_ident_spanned(_16, _5, _17) -> [return: bb5, unwind: bb34];
    }

    bb5: {
        _19 = &mut _11;
        _18 = push_eq_spanned(_19, _5) -> [return: bb6, unwind: bb34];
    }

    bb6: {
        _21 = &mut _11;
        _20 = push_lt_spanned(_21, _5) -> [return: bb7, unwind: bb34];
    }

    bb7: {
        _23 = &_2;
        _24 = &mut _11;
        _22 = <&syn::Type as ToTokens>::to_tokens(_23, _24) -> [return: bb8, unwind: bb34];
    }

    bb8: {
        _26 = &mut _11;
        _27 = const "as";
        _25 = push_ident_spanned(_26, _5, _27) -> [return: bb9, unwind: bb34];
    }

    bb9: {
        _81 = const _;
        _29 = &mut _11;
        _28 = <StaticPath as ToTokens>::to_tokens(_81, _29) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _31 = &mut _11;
        _30 = push_colon2_spanned(_31, _5) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _33 = &mut _11;
        _34 = const "FromForm";
        _32 = push_ident_spanned(_33, _5, _34) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _36 = &mut _11;
        _35 = push_lt_spanned(_36, _5) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _38 = &mut _11;
        _39 = const "'__f";
        _37 = push_lifetime_spanned(_38, _5, _39) -> [return: bb14, unwind: bb34];
    }

    bb14: {
        _41 = &mut _11;
        _40 = push_shr_spanned(_41, _5) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _43 = &mut _11;
        _42 = push_colon2_spanned(_43, _5) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _45 = &mut _11;
        _46 = const "push_data";
        _44 = push_ident_spanned(_45, _5, _46) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _48 = &mut _11;
        _49 = proc_macro2::Delimiter::Parenthesis;
        _51 = TokenStream2::new() -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _53 = &_3;
        _54 = &mut _51;
        _52 = <&syn::Expr as ToTokens>::to_tokens(_53, _54) -> [return: bb19, unwind: bb33];
    }

    bb19: {
        _56 = &mut _51;
        _55 = push_comma_spanned(_56, _5) -> [return: bb20, unwind: bb33];
    }

    bb20: {
        _58 = &mut _51;
        _59 = const "__f";
        _57 = push_ident_spanned(_58, _5, _59) -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _61 = &mut _51;
        _60 = push_dot_spanned(_61, _5) -> [return: bb22, unwind: bb33];
    }

    bb22: {
        _63 = &mut _51;
        _64 = const "shift";
        _62 = push_ident_spanned(_63, _5, _64) -> [return: bb23, unwind: bb33];
    }

    bb23: {
        _66 = &mut _51;
        _67 = proc_macro2::Delimiter::Parenthesis;
        _68 = TokenStream2::new() -> [return: bb24, unwind: bb33];
    }

    bb24: {
        _65 = push_group_spanned(_66, _5, move _67, move _68) -> [return: bb25, unwind: bb33];
    }

    bb25: {
        _50 = move _51;
        _47 = push_group_spanned(_48, _5, move _49, move _50) -> [return: bb26, unwind: bb34];
    }

    bb26: {
        _70 = &mut _11;
        _69 = push_semi_spanned(_70, _5) -> [return: bb27, unwind: bb34];
    }

    bb27: {
        _72 = &mut _11;
        _73 = const "_fut";
        _71 = push_ident_spanned(_72, _5, _73) -> [return: bb28, unwind: bb34];
    }

    bb28: {
        _75 = &mut _11;
        _74 = push_dot_spanned(_75, _5) -> [return: bb29, unwind: bb34];
    }

    bb29: {
        _77 = &mut _11;
        _78 = const "await";
        _76 = push_ident_spanned(_77, _5, _78) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        _80 = &mut _11;
        _79 = push_semi_spanned(_80, _5) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        _10 = move _11;
        _7 = push_group_spanned(_8, _5, move _9, move _10) -> [return: bb32, unwind: bb35];
    }

    bb32: {
        _0 = move _4;
        return;
    }

    bb33 (cleanup): {
        drop(_51) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_11) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_4) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#11}::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#12}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:180:26: 180:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &str;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: &str;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let mut _59: proc_macro2::Delimiter;
    let mut _60: proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let mut _66: proc_macro2::Delimiter;
    let mut _67: proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: &str;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let mut _74: proc_macro2::Delimiter;
    let mut _75: proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: &str;
    let _80: ();
    let mut _81: &mut proc_macro2::TokenStream;
    let _82: &str;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: &str;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: ();
    let _97: &proc_macro2::TokenStream;
    let mut _98: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _61: proc_macro2::TokenStream;
        let mut _100: &exports::StaticPath;
        let mut _101: &exports::StaticPath;
        scope 2 {
            debug _s => _15;
        }
        scope 3 {
            debug _s => _61;
            let mut _68: proc_macro2::TokenStream;
            let mut _99: &exports::StaticPath;
            scope 4 {
                debug _s => _68;
                let mut _76: proc_macro2::TokenStream;
                scope 5 {
                    debug _s => _76;
                }
            }
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb46];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb45];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "finalize";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb45];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb45];
    }

    bb4: {
        _17 = &mut _15;
        _18 = const "mut";
        _16 = push_ident(_17, _18) -> [return: bb5, unwind: bb44];
    }

    bb5: {
        _20 = &mut _15;
        _21 = const "__c";
        _19 = push_ident(_20, _21) -> [return: bb6, unwind: bb44];
    }

    bb6: {
        _23 = &mut _15;
        _22 = push_colon(_23) -> [return: bb7, unwind: bb44];
    }

    bb7: {
        _25 = &mut _15;
        _26 = const "Self";
        _24 = push_ident(_25, _26) -> [return: bb8, unwind: bb44];
    }

    bb8: {
        _28 = &mut _15;
        _27 = push_colon2(_28) -> [return: bb9, unwind: bb44];
    }

    bb9: {
        _30 = &mut _15;
        _31 = const "Context";
        _29 = push_ident(_30, _31) -> [return: bb10, unwind: bb44];
    }

    bb10: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb11, unwind: bb45];
    }

    bb11: {
        _33 = &mut _4;
        _32 = push_rarrow(_33) -> [return: bb12, unwind: bb45];
    }

    bb12: {
        _101 = const _;
        _35 = &mut _4;
        _34 = <StaticPath as ToTokens>::to_tokens(_101, _35) -> [return: bb13, unwind: bb45];
    }

    bb13: {
        _37 = &mut _4;
        _36 = push_lt(_37) -> [return: bb14, unwind: bb45];
    }

    bb14: {
        _39 = &mut _4;
        _40 = const "Self";
        _38 = push_ident(_39, _40) -> [return: bb15, unwind: bb45];
    }

    bb15: {
        _42 = &mut _4;
        _41 = push_comma(_42) -> [return: bb16, unwind: bb45];
    }

    bb16: {
        _100 = const _;
        _44 = &mut _4;
        _43 = <StaticPath as ToTokens>::to_tokens(_100, _44) -> [return: bb17, unwind: bb45];
    }

    bb17: {
        _46 = &mut _4;
        _45 = push_colon2(_46) -> [return: bb18, unwind: bb45];
    }

    bb18: {
        _48 = &mut _4;
        _49 = const "Errors";
        _47 = push_ident(_48, _49) -> [return: bb19, unwind: bb45];
    }

    bb19: {
        _51 = &mut _4;
        _50 = push_lt(_51) -> [return: bb20, unwind: bb45];
    }

    bb20: {
        _53 = &mut _4;
        _54 = const "'__f";
        _52 = push_lifetime(_53, _54) -> [return: bb21, unwind: bb45];
    }

    bb21: {
        _56 = &mut _4;
        _55 = push_shr(_56) -> [return: bb22, unwind: bb45];
    }

    bb22: {
        _58 = &mut _4;
        _59 = proc_macro2::Delimiter::Brace;
        _61 = TokenStream2::new() -> [return: bb23, unwind: bb45];
    }

    bb23: {
        _63 = &mut _61;
        _62 = push_pound(_63) -> [return: bb24, unwind: bb43];
    }

    bb24: {
        _65 = &mut _61;
        _66 = proc_macro2::Delimiter::Bracket;
        _68 = TokenStream2::new() -> [return: bb25, unwind: bb43];
    }

    bb25: {
        _70 = &mut _68;
        _71 = const "allow";
        _69 = push_ident(_70, _71) -> [return: bb26, unwind: bb42];
    }

    bb26: {
        _73 = &mut _68;
        _74 = proc_macro2::Delimiter::Parenthesis;
        _76 = TokenStream2::new() -> [return: bb27, unwind: bb42];
    }

    bb27: {
        _78 = &mut _76;
        _79 = const "unused_imports";
        _77 = push_ident(_78, _79) -> [return: bb28, unwind: bb41];
    }

    bb28: {
        _75 = move _76;
        _72 = push_group(_73, move _74, move _75) -> [return: bb29, unwind: bb42];
    }

    bb29: {
        _67 = move _68;
        _64 = push_group(_65, move _66, move _67) -> [return: bb30, unwind: bb43];
    }

    bb30: {
        _81 = &mut _61;
        _82 = const "use";
        _80 = push_ident(_81, _82) -> [return: bb31, unwind: bb43];
    }

    bb31: {
        _99 = const _;
        _84 = &mut _61;
        _83 = <StaticPath as ToTokens>::to_tokens(_99, _84) -> [return: bb32, unwind: bb43];
    }

    bb32: {
        _86 = &mut _61;
        _85 = push_colon2(_86) -> [return: bb33, unwind: bb43];
    }

    bb33: {
        _88 = &mut _61;
        _89 = const "validate";
        _87 = push_ident(_88, _89) -> [return: bb34, unwind: bb43];
    }

    bb34: {
        _91 = &mut _61;
        _90 = push_colon2(_91) -> [return: bb35, unwind: bb43];
    }

    bb35: {
        _93 = &mut _61;
        _92 = push_star(_93) -> [return: bb36, unwind: bb43];
    }

    bb36: {
        _95 = &mut _61;
        _94 = push_semi(_95) -> [return: bb37, unwind: bb43];
    }

    bb37: {
        _97 = &_3;
        _98 = &mut _61;
        _96 = <TokenStream2 as ToTokens>::to_tokens(_97, _98) -> [return: bb38, unwind: bb43];
    }

    bb38: {
        _60 = move _61;
        _57 = push_group(_58, move _59, move _60) -> [return: bb39, unwind: bb45];
    }

    bb39: {
        _0 = move _4;
        drop(_3) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_76) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_68) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_61) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_15) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_4) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_3) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#12}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#12}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form::derive_from_form::{closure#12}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#13}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:188:29: 188:45}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug fields => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: std::vec::Vec<proc_macro2::TokenStream>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<proc_macro2::TokenStream>>;
    let mut _6: std::result::Result<std::vec::Vec<proc_macro2::TokenStream>, devise::Diagnostic>;
    let mut _7: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29}>;
    let mut _8: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _9: devise::Fields<'_>;
    let mut _10: {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29};
    let mut _11: &mut &mut devise::MapperBuild;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _14: std::vec::Vec<proc_macro2::TokenStream>;
    let mut _16: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:194:26: 194:29}>;
    let mut _17: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _18: devise::Fields<'_>;
    let _20: &str;
    let mut _21: proc_macro2::Span;
    let mut _22: &devise::Fields<'_>;
    let mut _27: (exports::StaticPath, exports::StaticPath, exports::StaticPath, exports::StaticPath);
    let mut _30: (std::vec::Vec<syn::Expr>, std::vec::Vec<syn::Expr>);
    let mut _31: std::iter::Flatten<std::iter::Map<std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>, {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}>>;
    let mut _32: std::iter::Map<std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>, {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}>;
    let mut _33: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>;
    let mut _34: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _35: devise::Fields<'_>;
    let mut _36: {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29};
    let mut _37: &proc_macro2::Ident;
    let mut _38: proc_macro2::TokenStream;
    let mut _41: &devise::Fields<'_>;
    let mut _43: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _44: &std::vec::Vec<proc_macro2::Ident>;
    let mut _47: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _48: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _51: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _52: &exports::StaticPath;
    let mut _55: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _58: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _59: &exports::StaticPath;
    let mut _62: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _65: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _66: &exports::StaticPath;
    let mut _69: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _70: &exports::StaticPath;
    let mut _72: bool;
    let mut _74: std::option::Option<&proc_macro2::Ident>;
    let mut _75: &mut std::slice::Iter<'_, proc_macro2::Ident>;
    let mut _76: isize;
    let mut _79: std::option::Option<&proc_macro2::TokenStream>;
    let mut _80: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _81: isize;
    let mut _84: std::option::Option<&exports::StaticPath>;
    let mut _85: isize;
    let mut _88: std::option::Option<&proc_macro2::Ident>;
    let mut _89: isize;
    let mut _92: std::option::Option<&exports::StaticPath>;
    let mut _93: isize;
    let mut _96: std::option::Option<&proc_macro2::Ident>;
    let mut _97: isize;
    let mut _100: std::option::Option<&exports::StaticPath>;
    let mut _101: isize;
    let mut _104: std::option::Option<&exports::StaticPath>;
    let mut _105: isize;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: &str;
    let _110: ();
    let _111: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: &str;
    let _118: ();
    let _119: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _120: &mut proc_macro2::TokenStream;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let mut _123: proc_macro2::Delimiter;
    let mut _124: proc_macro2::TokenStream;
    let _126: ();
    let _127: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _128: &mut proc_macro2::TokenStream;
    let _129: ();
    let mut _130: &mut proc_macro2::TokenStream;
    let mut _131: proc_macro2::Delimiter;
    let mut _132: proc_macro2::TokenStream;
    let _134: ();
    let _135: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _136: &mut proc_macro2::TokenStream;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: ();
    let _140: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _141: &mut proc_macro2::TokenStream;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let mut _144: proc_macro2::Delimiter;
    let mut _145: proc_macro2::TokenStream;
    let _147: ();
    let _148: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _149: &mut proc_macro2::TokenStream;
    let _150: ();
    let mut _151: &mut proc_macro2::TokenStream;
    let _152: ();
    let _153: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _154: &mut proc_macro2::TokenStream;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let mut _157: proc_macro2::Delimiter;
    let mut _158: proc_macro2::TokenStream;
    let _160: ();
    let mut _161: &mut proc_macro2::TokenStream;
    let _162: &str;
    let _163: ();
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let mut _167: proc_macro2::Delimiter;
    let mut _168: proc_macro2::TokenStream;
    let _170: ();
    let mut _171: &mut proc_macro2::TokenStream;
    let _172: &str;
    let _173: ();
    let mut _174: &mut proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: &str;
    let _178: ();
    let mut _179: &mut proc_macro2::TokenStream;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let _182: &str;
    let _183: ();
    let mut _184: &mut proc_macro2::TokenStream;
    let mut _185: proc_macro2::Delimiter;
    let mut _186: proc_macro2::TokenStream;
    let _188: ();
    let mut _189: &mut proc_macro2::TokenStream;
    let _190: &str;
    let _191: ();
    let mut _192: &mut proc_macro2::TokenStream;
    let _193: ();
    let _194: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _195: &mut proc_macro2::TokenStream;
    let _196: ();
    let mut _197: &mut proc_macro2::TokenStream;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let _200: &str;
    let _201: ();
    let mut _202: &mut proc_macro2::TokenStream;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let _205: &str;
    let _206: ();
    let mut _207: &mut proc_macro2::TokenStream;
    let _208: ();
    let mut _209: &mut proc_macro2::TokenStream;
    let _210: &str;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: &str;
    let _216: ();
    let mut _217: &mut proc_macro2::TokenStream;
    let mut _218: proc_macro2::Delimiter;
    let mut _219: proc_macro2::TokenStream;
    let _220: ();
    let mut _221: &mut proc_macro2::TokenStream;
    let mut _222: proc_macro2::Delimiter;
    let mut _223: proc_macro2::TokenStream;
    let _225: ();
    let mut _226: &mut proc_macro2::TokenStream;
    let _227: &str;
    let _228: ();
    let mut _229: &mut proc_macro2::TokenStream;
    let _230: ();
    let mut _231: &mut proc_macro2::TokenStream;
    let mut _232: proc_macro2::Delimiter;
    let mut _233: proc_macro2::TokenStream;
    let _235: ();
    let mut _236: &mut proc_macro2::TokenStream;
    let _237: &str;
    let _238: ();
    let mut _239: &mut proc_macro2::TokenStream;
    let _240: ();
    let mut _241: &mut proc_macro2::TokenStream;
    let _242: &str;
    let _243: ();
    let mut _244: &mut proc_macro2::TokenStream;
    let _245: ();
    let mut _246: &mut proc_macro2::TokenStream;
    let _247: &str;
    let _248: ();
    let _249: &proc_macro2::Ident;
    let mut _250: &mut proc_macro2::TokenStream;
    let _251: ();
    let mut _252: &mut proc_macro2::TokenStream;
    let _253: ();
    let mut _254: &mut proc_macro2::TokenStream;
    let _255: &str;
    let _256: ();
    let mut _257: &mut proc_macro2::TokenStream;
    let mut _258: proc_macro2::Delimiter;
    let mut _259: proc_macro2::TokenStream;
    let mut _263: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _264: &std::vec::Vec<proc_macro2::Ident>;
    let mut _267: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _269: bool;
    let mut _271: std::option::Option<&proc_macro2::Ident>;
    let mut _272: &mut std::slice::Iter<'_, proc_macro2::Ident>;
    let mut _273: isize;
    let mut _276: std::option::Option<&proc_macro2::Ident>;
    let mut _277: isize;
    let mut _279: bool;
    let mut _280: usize;
    let _281: ();
    let mut _282: &mut proc_macro2::TokenStream;
    let mut _283: (usize, bool);
    let _284: ();
    let _285: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _286: &mut proc_macro2::TokenStream;
    let _287: ();
    let mut _288: &mut proc_macro2::TokenStream;
    let _289: ();
    let _290: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _291: &mut proc_macro2::TokenStream;
    let _292: ();
    let mut _293: &mut proc_macro2::TokenStream;
    let _294: ();
    let mut _295: &mut proc_macro2::TokenStream;
    let _296: &str;
    let _297: ();
    let mut _298: &mut proc_macro2::TokenStream;
    let mut _299: proc_macro2::Delimiter;
    let mut _300: proc_macro2::TokenStream;
    let _301: ();
    let mut _302: &mut proc_macro2::TokenStream;
    let mut _304: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _305: &exports::StaticPath;
    let mut _308: (std::slice::Iter<'_, syn::Expr>, quote::__private::HasIterator);
    let mut _309: &std::vec::Vec<syn::Expr>;
    let mut _312: (std::slice::Iter<'_, syn::Expr>, quote::__private::HasIterator);
    let mut _313: &std::vec::Vec<syn::Expr>;
    let mut _315: bool;
    let mut _317: std::option::Option<&exports::StaticPath>;
    let mut _318: isize;
    let mut _321: std::option::Option<&syn::Expr>;
    let mut _322: &mut std::slice::Iter<'_, syn::Expr>;
    let mut _323: isize;
    let mut _326: std::option::Option<&syn::Expr>;
    let mut _327: &mut std::slice::Iter<'_, syn::Expr>;
    let mut _328: isize;
    let _330: ();
    let mut _331: &mut proc_macro2::TokenStream;
    let _332: &str;
    let _333: ();
    let mut _334: &mut proc_macro2::TokenStream;
    let _335: &str;
    let _336: ();
    let _337: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _338: &mut proc_macro2::TokenStream;
    let _339: ();
    let mut _340: &mut proc_macro2::TokenStream;
    let mut _341: proc_macro2::Delimiter;
    let mut _342: proc_macro2::TokenStream;
    let _344: ();
    let mut _345: &mut proc_macro2::TokenStream;
    let _346: &str;
    let _347: ();
    let mut _348: &mut proc_macro2::TokenStream;
    let _349: ();
    let _350: &quote::__private::RepInterp<&syn::Expr>;
    let mut _351: &mut proc_macro2::TokenStream;
    let _352: ();
    let mut _353: &mut proc_macro2::TokenStream;
    let mut _354: proc_macro2::Delimiter;
    let mut _355: proc_macro2::TokenStream;
    let _357: ();
    let mut _358: &mut proc_macro2::TokenStream;
    let _359: &str;
    let _360: ();
    let mut _361: &mut proc_macro2::TokenStream;
    let _362: ();
    let mut _363: &mut proc_macro2::TokenStream;
    let _364: &str;
    let _365: ();
    let mut _366: &mut proc_macro2::TokenStream;
    let _367: ();
    let mut _368: &mut proc_macro2::TokenStream;
    let _369: &str;
    let _370: ();
    let mut _371: &mut proc_macro2::TokenStream;
    let mut _372: proc_macro2::Delimiter;
    let mut _373: proc_macro2::TokenStream;
    let _375: ();
    let mut _376: &mut proc_macro2::TokenStream;
    let _377: &str;
    let _378: ();
    let mut _379: &mut proc_macro2::TokenStream;
    let _380: ();
    let mut _381: &mut proc_macro2::TokenStream;
    let _382: &str;
    let _383: ();
    let mut _384: &mut proc_macro2::TokenStream;
    let mut _385: proc_macro2::Delimiter;
    let mut _386: proc_macro2::TokenStream;
    let _388: ();
    let _389: &quote::__private::RepInterp<&syn::Expr>;
    let mut _390: &mut proc_macro2::TokenStream;
    let _391: ();
    let mut _392: &mut proc_macro2::TokenStream;
    let _393: ();
    let mut _394: &mut proc_macro2::TokenStream;
    let _395: &str;
    let _396: ();
    let mut _397: &mut proc_macro2::TokenStream;
    let _398: ();
    let mut _399: &mut proc_macro2::TokenStream;
    let _400: &str;
    let _401: ();
    let mut _402: &mut proc_macro2::TokenStream;
    let _403: ();
    let mut _404: &mut proc_macro2::TokenStream;
    let _405: &str;
    let _406: ();
    let mut _407: &mut proc_macro2::TokenStream;
    let _408: ();
    let mut _409: &mut proc_macro2::TokenStream;
    let _410: &str;
    let _411: ();
    let mut _412: &mut proc_macro2::TokenStream;
    let mut _413: proc_macro2::Delimiter;
    let mut _414: proc_macro2::TokenStream;
    let _415: ();
    let mut _416: &mut proc_macro2::TokenStream;
    let mut _417: proc_macro2::Delimiter;
    let mut _418: proc_macro2::TokenStream;
    let _420: ();
    let mut _421: &mut proc_macro2::TokenStream;
    let _422: &str;
    let _423: ();
    let mut _424: &mut proc_macro2::TokenStream;
    let _425: ();
    let mut _426: &mut proc_macro2::TokenStream;
    let mut _427: proc_macro2::Delimiter;
    let mut _428: proc_macro2::TokenStream;
    let _430: ();
    let mut _431: &mut proc_macro2::TokenStream;
    let _432: &str;
    let _433: ();
    let mut _434: &mut proc_macro2::TokenStream;
    let _435: ();
    let mut _436: &mut proc_macro2::TokenStream;
    let _437: &str;
    let _438: ();
    let mut _439: &mut proc_macro2::TokenStream;
    let _440: ();
    let mut _441: &mut proc_macro2::TokenStream;
    let _442: &str;
    let _443: ();
    let mut _444: &mut proc_macro2::TokenStream;
    let mut _445: proc_macro2::Delimiter;
    let mut _446: proc_macro2::TokenStream;
    let _448: ();
    let _449: &proc_macro2::Ident;
    let mut _450: &mut proc_macro2::TokenStream;
    let mut _453: {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29};
    scope 1 {
        debug finalize_field => _4;
        let _15: std::vec::Vec<proc_macro2::Ident>;
        scope 6 {
            debug ident => _15;
            let _19: proc_macro2::Ident;
            scope 7 {
                debug o => _19;
                let _23: exports::StaticPath;
                let _24: exports::StaticPath;
                let _25: exports::StaticPath;
                let _26: exports::StaticPath;
                scope 8 {
                    debug _ok => _23;
                    debug _some => _24;
                    debug _err => _25;
                    debug _none => _26;
                    let _28: std::vec::Vec<syn::Expr>;
                    let _29: std::vec::Vec<syn::Expr>;
                    scope 9 {
                        debug name_view => _28;
                        debug validate => _29;
                        let mut _39: proc_macro2::TokenStream;
                        scope 10 {
                            debug _s => _39;
                            let _40: proc_macro2::Span;
                            scope 11 {
                                debug _span => _40;
                                let mut _224: proc_macro2::TokenStream;
                                let mut _260: proc_macro2::TokenStream;
                                let mut _419: proc_macro2::TokenStream;
                                let mut _447: proc_macro2::TokenStream;
                                scope 12 {
                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                    scope 13 {
                                        debug ident => _42;
                                        debug i => const HasIterator;
                                        let _45: quote::__private::HasIterator;
                                        scope 15 {
                                            debug has_iter => const HasIterator;
                                            scope 16 {
                                                debug finalize_field => _46;
                                                debug i => const HasIterator;
                                                let _49: quote::__private::HasIterator;
                                                scope 18 {
                                                    debug has_iter => const HasIterator;
                                                    scope 19 {
                                                        debug _ok => _50;
                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                        let _53: quote::__private::HasIterator;
                                                        scope 21 {
                                                            debug has_iter => const HasIterator;
                                                            scope 22 {
                                                                debug ident => _54;
                                                                debug i => const HasIterator;
                                                                let _56: quote::__private::HasIterator;
                                                                scope 24 {
                                                                    debug has_iter => const HasIterator;
                                                                    scope 25 {
                                                                        debug _some => _57;
                                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                                        let _60: quote::__private::HasIterator;
                                                                        scope 27 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 28 {
                                                                                debug ident => _61;
                                                                                debug i => const HasIterator;
                                                                                let _63: quote::__private::HasIterator;
                                                                                scope 30 {
                                                                                    debug has_iter => const HasIterator;
                                                                                    scope 31 {
                                                                                        debug _err => _64;
                                                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                                                        let _67: quote::__private::HasIterator;
                                                                                        scope 33 {
                                                                                            debug has_iter => const HasIterator;
                                                                                            scope 34 {
                                                                                                debug _none => _68;
                                                                                                debug i => const ThereIsNoIteratorInRepetition;
                                                                                                let _71: quote::__private::HasIterator;
                                                                                                scope 36 {
                                                                                                    debug has_iter => const HasIterator;
                                                                                                    scope 37 {
                                                                                                        let _73: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                                        let _77: &proc_macro2::Ident;
                                                                                                        scope 38 {
                                                                                                            debug ident => _73;
                                                                                                            let _78: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                                                            let _82: &proc_macro2::TokenStream;
                                                                                                            scope 40 {
                                                                                                                debug finalize_field => _78;
                                                                                                                let _83: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                let _86: &exports::StaticPath;
                                                                                                                scope 42 {
                                                                                                                    debug _ok => _83;
                                                                                                                    let _87: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                                                    let _90: &proc_macro2::Ident;
                                                                                                                    scope 44 {
                                                                                                                        debug ident => _87;
                                                                                                                        let _91: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                        let _94: &exports::StaticPath;
                                                                                                                        scope 46 {
                                                                                                                            debug _some => _91;
                                                                                                                            let _95: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                                                            let _98: &proc_macro2::Ident;
                                                                                                                            scope 48 {
                                                                                                                                debug ident => _95;
                                                                                                                                let _99: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                let _102: &exports::StaticPath;
                                                                                                                                scope 50 {
                                                                                                                                    debug _err => _99;
                                                                                                                                    let _103: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                    let _106: &exports::StaticPath;
                                                                                                                                    scope 52 {
                                                                                                                                        debug _none => _103;
                                                                                                                                        let mut _125: proc_macro2::TokenStream;
                                                                                                                                        scope 54 {
                                                                                                                                            debug _s => _125;
                                                                                                                                            scope 55 {
                                                                                                                                                debug _span => _40;
                                                                                                                                                let mut _133: proc_macro2::TokenStream;
                                                                                                                                                let mut _146: proc_macro2::TokenStream;
                                                                                                                                                let mut _159: proc_macro2::TokenStream;
                                                                                                                                                let mut _169: proc_macro2::TokenStream;
                                                                                                                                                scope 56 {
                                                                                                                                                    debug _s => _133;
                                                                                                                                                    scope 57 {
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                scope 58 {
                                                                                                                                                    debug _s => _146;
                                                                                                                                                    scope 59 {
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                scope 60 {
                                                                                                                                                    debug _s => _159;
                                                                                                                                                    scope 61 {
                                                                                                                                                        debug _span => _40;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                scope 62 {
                                                                                                                                                    debug _s => _169;
                                                                                                                                                    scope 63 {
                                                                                                                                                        debug _span => _40;
                                                                                                                                                        let mut _187: proc_macro2::TokenStream;
                                                                                                                                                        scope 64 {
                                                                                                                                                            debug _s => _187;
                                                                                                                                                            scope 65 {
                                                                                                                                                                debug _span => _40;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    scope 53 {
                                                                                                                                        debug _x => _106;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                scope 51 {
                                                                                                                                    debug _x => _102;
                                                                                                                                }
                                                                                                                            }
                                                                                                                            scope 49 {
                                                                                                                                debug _x => _98;
                                                                                                                            }
                                                                                                                        }
                                                                                                                        scope 47 {
                                                                                                                            debug _x => _94;
                                                                                                                        }
                                                                                                                    }
                                                                                                                    scope 45 {
                                                                                                                        debug _x => _90;
                                                                                                                    }
                                                                                                                }
                                                                                                                scope 43 {
                                                                                                                    debug _x => _86;
                                                                                                                }
                                                                                                            }
                                                                                                            scope 41 {
                                                                                                                debug _x => _82;
                                                                                                            }
                                                                                                        }
                                                                                                        scope 39 {
                                                                                                            debug _x => _77;
                                                                                                        }
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            scope 35 {
                                                                                                let mut _68: &exports::StaticPath;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 32 {
                                                                                        let mut _64: &exports::StaticPath;
                                                                                    }
                                                                                }
                                                                            }
                                                                            scope 29 {
                                                                                let mut _61: std::slice::Iter<'_, proc_macro2::Ident>;
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 26 {
                                                                        let mut _57: &exports::StaticPath;
                                                                    }
                                                                }
                                                            }
                                                            scope 23 {
                                                                let mut _54: std::slice::Iter<'_, proc_macro2::Ident>;
                                                            }
                                                        }
                                                    }
                                                    scope 20 {
                                                        let mut _50: &exports::StaticPath;
                                                    }
                                                }
                                            }
                                            scope 17 {
                                                let mut _46: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                            }
                                        }
                                    }
                                    scope 14 {
                                        let mut _42: std::slice::Iter<'_, proc_macro2::Ident>;
                                    }
                                }
                                scope 66 {
                                }
                                scope 67 {
                                    debug _s => _224;
                                    scope 68 {
                                        debug _span => _40;
                                        let mut _234: proc_macro2::TokenStream;
                                        let mut _452: &exports::StaticPath;
                                        scope 69 {
                                            debug _s => _234;
                                            scope 70 {
                                                debug _span => _40;
                                            }
                                        }
                                    }
                                }
                                scope 71 {
                                    debug _s => _260;
                                    scope 72 {
                                        debug _span => _40;
                                        let mut _261: usize;
                                        scope 73 {
                                            debug _i => _261;
                                            scope 74 {
                                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                                scope 75 {
                                                    debug ident => _262;
                                                    debug i => const HasIterator;
                                                    let _265: quote::__private::HasIterator;
                                                    scope 77 {
                                                        debug has_iter => const HasIterator;
                                                        scope 78 {
                                                            debug ident => _266;
                                                            debug i => const HasIterator;
                                                            let _268: quote::__private::HasIterator;
                                                            scope 80 {
                                                                debug has_iter => const HasIterator;
                                                                scope 81 {
                                                                    let _270: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                    let _274: &proc_macro2::Ident;
                                                                    scope 82 {
                                                                        debug ident => _270;
                                                                        let _275: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                        let _278: &proc_macro2::Ident;
                                                                        scope 84 {
                                                                            debug ident => _275;
                                                                            scope 86 {
                                                                            }
                                                                        }
                                                                        scope 85 {
                                                                            debug _x => _278;
                                                                        }
                                                                    }
                                                                    scope 83 {
                                                                        debug _x => _274;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 79 {
                                                            let mut _266: std::slice::Iter<'_, proc_macro2::Ident>;
                                                        }
                                                    }
                                                }
                                                scope 76 {
                                                    let mut _262: std::slice::Iter<'_, proc_macro2::Ident>;
                                                }
                                            }
                                        }
                                    }
                                }
                                scope 87 {
                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                    scope 88 {
                                        debug _err => _303;
                                        debug i => const ThereIsNoIteratorInRepetition;
                                        let _306: quote::__private::ThereIsNoIteratorInRepetition;
                                        scope 90 {
                                            debug has_iter => const ThereIsNoIteratorInRepetition;
                                            scope 91 {
                                                debug validate => _307;
                                                debug i => const HasIterator;
                                                let _310: quote::__private::HasIterator;
                                                scope 93 {
                                                    debug has_iter => const HasIterator;
                                                    scope 94 {
                                                        debug name_view => _311;
                                                        debug i => const HasIterator;
                                                        let _314: quote::__private::HasIterator;
                                                        scope 96 {
                                                            debug has_iter => const HasIterator;
                                                            scope 97 {
                                                                let _316: quote::__private::RepInterp<&exports::StaticPath>;
                                                                let _319: &exports::StaticPath;
                                                                scope 98 {
                                                                    debug _err => _316;
                                                                    let _320: quote::__private::RepInterp<&syn::Expr>;
                                                                    let _324: &syn::Expr;
                                                                    scope 100 {
                                                                        debug validate => _320;
                                                                        let _325: quote::__private::RepInterp<&syn::Expr>;
                                                                        let _329: &syn::Expr;
                                                                        scope 102 {
                                                                            debug name_view => _325;
                                                                            let mut _343: proc_macro2::TokenStream;
                                                                            let mut _356: proc_macro2::TokenStream;
                                                                            scope 104 {
                                                                                debug _s => _343;
                                                                                scope 105 {
                                                                                    debug _span => _40;
                                                                                }
                                                                            }
                                                                            scope 106 {
                                                                                debug _s => _356;
                                                                                scope 107 {
                                                                                    debug _span => _40;
                                                                                    let mut _374: proc_macro2::TokenStream;
                                                                                    scope 108 {
                                                                                        debug _s => _374;
                                                                                        scope 109 {
                                                                                            debug _span => _40;
                                                                                            let mut _387: proc_macro2::TokenStream;
                                                                                            scope 110 {
                                                                                                debug _s => _387;
                                                                                                scope 111 {
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        scope 103 {
                                                                            debug _x => _329;
                                                                        }
                                                                    }
                                                                    scope 101 {
                                                                        debug _x => _324;
                                                                    }
                                                                }
                                                                scope 99 {
                                                                    debug _x => _319;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 95 {
                                                        let mut _311: std::slice::Iter<'_, syn::Expr>;
                                                    }
                                                }
                                            }
                                            scope 92 {
                                                let mut _307: std::slice::Iter<'_, syn::Expr>;
                                            }
                                        }
                                    }
                                    scope 89 {
                                        let mut _303: &exports::StaticPath;
                                    }
                                }
                                scope 112 {
                                }
                                scope 113 {
                                    debug _s => _419;
                                    scope 114 {
                                        debug _span => _40;
                                        let mut _429: proc_macro2::TokenStream;
                                        let mut _451: &exports::StaticPath;
                                        scope 115 {
                                            debug _s => _429;
                                            scope 116 {
                                                debug _span => _40;
                                            }
                                        }
                                    }
                                }
                                scope 117 {
                                    debug _s => _447;
                                    scope 118 {
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _9 = _3;
        _8 = devise::Fields::<'_>::iter(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = &mut _2;
        _10 = {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29} { mapper: move _11 };
        _7 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::map::<std::result::Result<TokenStream2, devise::Diagnostic>, {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29}>(move _8, move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = <Map<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29}> as Iterator>::collect::<std::result::Result<Vec<TokenStream2>, devise::Diagnostic>>(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::result::Result<Vec<TokenStream2>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _14 = move ((_5 as Continue).0: std::vec::Vec<proc_macro2::TokenStream>);
        _4 = move _14;
        _18 = _3;
        _17 = devise::Fields::<'_>::iter(move _18) -> [return: bb8, unwind: bb219];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _13) -> [return: bb197, unwind continue];
    }

    bb8: {
        _16 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::map::<proc_macro2::Ident, {closure@core/codegen/src/derive/from_form.rs:194:26: 194:29}>(move _17, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:194:26: 194:29}) -> [return: bb9, unwind: bb219];
    }

    bb9: {
        _15 = <Map<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:194:26: 194:29}> as Iterator>::collect::<Vec<proc_macro2::Ident>>(move _16) -> [return: bb10, unwind: bb219];
    }

    bb10: {
        _20 = const "__o";
        _22 = &_3;
        _21 = <devise::Fields<'_> as devise::Spanned>::span(move _22) -> [return: bb11, unwind: bb218];
    }

    bb11: {
        _19 = proc_macro2::Ident::new(_20, move _21) -> [return: bb12, unwind: bb218];
    }

    bb12: {
        _27 = (const _, const _, const _, const _);
        _23 = (_27.0: exports::StaticPath);
        _24 = (_27.1: exports::StaticPath);
        _25 = (_27.2: exports::StaticPath);
        _26 = (_27.3: exports::StaticPath);
        _35 = _3;
        _34 = devise::Fields::<'_>::iter(move _35) -> [return: bb13, unwind: bb217];
    }

    bb13: {
        _37 = &_19;
        _453 = {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29} { o: move _37 };
        _36 = move (_453 as subtype {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29});
        _33 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::map::<(syn::Expr, Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>), {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>(move _34, move _36) -> [return: bb14, unwind: bb217];
    }

    bb14: {
        _32 = <Map<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}> as Iterator>::map::<Map<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52}>, {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}>(move _33, const ZeroSized: {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}) -> [return: bb15, unwind: bb217];
    }

    bb15: {
        _31 = <Map<Map<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>, {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}> as Iterator>::flatten(move _32) -> [return: bb16, unwind: bb217];
    }

    bb16: {
        _30 = <Flatten<Map<Map<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>, {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}>, {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}>> as Split2<syn::Expr, syn::Expr>>::split2(move _31) -> [return: bb17, unwind: bb217];
    }

    bb17: {
        _28 = move (_30.0: std::vec::Vec<syn::Expr>);
        _29 = move (_30.1: std::vec::Vec<syn::Expr>);
        _39 = TokenStream2::new() -> [return: bb18, unwind: bb215];
    }

    bb18: {
        _41 = &_3;
        _40 = <devise::Fields<'_> as devise::Spanned>::span(move _41) -> [return: bb19, unwind: bb214];
    }

    bb19: {
        _44 = &_15;
        _43 = <Vec<proc_macro2::Ident> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _44) -> [return: bb20, unwind: bb214];
    }

    bb20: {
        _42 = move (_43.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _45 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb21, unwind: bb214];
    }

    bb21: {
        _48 = &_4;
        _47 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _48) -> [return: bb22, unwind: bb214];
    }

    bb22: {
        _46 = move (_47.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _49 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb23, unwind: bb214];
    }

    bb23: {
        _52 = &_23;
        _51 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _52) -> [return: bb24, unwind: bb214];
    }

    bb24: {
        _50 = (_51.0: &exports::StaticPath);
        _53 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb25, unwind: bb214];
    }

    bb25: {
        _55 = <std::slice::Iter<'_, proc_macro2::Ident> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _42) -> [return: bb26, unwind: bb214];
    }

    bb26: {
        _54 = move (_55.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _56 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb27, unwind: bb214];
    }

    bb27: {
        _59 = &_24;
        _58 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _59) -> [return: bb28, unwind: bb214];
    }

    bb28: {
        _57 = (_58.0: &exports::StaticPath);
        _60 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb29, unwind: bb214];
    }

    bb29: {
        _62 = <std::slice::Iter<'_, proc_macro2::Ident> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _54) -> [return: bb30, unwind: bb214];
    }

    bb30: {
        _61 = move (_62.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _63 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb31, unwind: bb214];
    }

    bb31: {
        _66 = &_25;
        _65 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _66) -> [return: bb32, unwind: bb214];
    }

    bb32: {
        _64 = (_65.0: &exports::StaticPath);
        _67 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb33, unwind: bb214];
    }

    bb33: {
        _70 = &_26;
        _69 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _70) -> [return: bb34, unwind: bb214];
    }

    bb34: {
        _68 = (_69.0: &exports::StaticPath);
        _71 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb221, unwind: bb214];
    }

    bb35: {
        _72 = const true;
        switchInt(move _72) -> [0: bb87, otherwise: bb36];
    }

    bb36: {
        _75 = &mut _61;
        _74 = <std::slice::Iter<'_, proc_macro2::Ident> as Iterator>::next(move _75) -> [return: bb37, unwind: bb214];
    }

    bb37: {
        _76 = discriminant(_74);
        switchInt(move _76) -> [0: bb87, 1: bb38, otherwise: bb6];
    }

    bb38: {
        _77 = ((_74 as Some).0: &proc_macro2::Ident);
        _73 = RepInterp::<&proc_macro2::Ident>(_77);
        _80 = &mut _46;
        _79 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _80) -> [return: bb39, unwind: bb214];
    }

    bb39: {
        _81 = discriminant(_79);
        switchInt(move _81) -> [0: bb87, 1: bb40, otherwise: bb6];
    }

    bb40: {
        _82 = ((_79 as Some).0: &proc_macro2::TokenStream);
        _78 = RepInterp::<&TokenStream2>(_82);
        _84 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_50) -> [return: bb41, unwind: bb214];
    }

    bb41: {
        _85 = discriminant(_84);
        switchInt(move _85) -> [0: bb87, 1: bb42, otherwise: bb6];
    }

    bb42: {
        _86 = ((_84 as Some).0: &exports::StaticPath);
        _83 = RepInterp::<&StaticPath>(_86);
        _88 = RepInterp::<&proc_macro2::Ident>::next(_73) -> [return: bb43, unwind: bb214];
    }

    bb43: {
        _89 = discriminant(_88);
        switchInt(move _89) -> [0: bb87, 1: bb44, otherwise: bb6];
    }

    bb44: {
        _90 = ((_88 as Some).0: &proc_macro2::Ident);
        _87 = RepInterp::<&proc_macro2::Ident>(_90);
        _92 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_57) -> [return: bb45, unwind: bb214];
    }

    bb45: {
        _93 = discriminant(_92);
        switchInt(move _93) -> [0: bb87, 1: bb46, otherwise: bb6];
    }

    bb46: {
        _94 = ((_92 as Some).0: &exports::StaticPath);
        _91 = RepInterp::<&StaticPath>(_94);
        _96 = RepInterp::<&proc_macro2::Ident>::next(_87) -> [return: bb47, unwind: bb214];
    }

    bb47: {
        _97 = discriminant(_96);
        switchInt(move _97) -> [0: bb87, 1: bb48, otherwise: bb6];
    }

    bb48: {
        _98 = ((_96 as Some).0: &proc_macro2::Ident);
        _95 = RepInterp::<&proc_macro2::Ident>(_98);
        _100 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_64) -> [return: bb49, unwind: bb214];
    }

    bb49: {
        _101 = discriminant(_100);
        switchInt(move _101) -> [0: bb87, 1: bb50, otherwise: bb6];
    }

    bb50: {
        _102 = ((_100 as Some).0: &exports::StaticPath);
        _99 = RepInterp::<&StaticPath>(_102);
        _104 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_68) -> [return: bb51, unwind: bb214];
    }

    bb51: {
        _105 = discriminant(_104);
        switchInt(move _105) -> [0: bb87, 1: bb52, otherwise: bb6];
    }

    bb52: {
        _106 = ((_104 as Some).0: &exports::StaticPath);
        _103 = RepInterp::<&StaticPath>(_106);
        _108 = &mut _39;
        _109 = const "let";
        _107 = push_ident_spanned(_108, _40, _109) -> [return: bb53, unwind: bb214];
    }

    bb53: {
        _111 = &_95;
        _112 = &mut _39;
        _110 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_111, _112) -> [return: bb54, unwind: bb214];
    }

    bb54: {
        _114 = &mut _39;
        _113 = push_eq_spanned(_114, _40) -> [return: bb55, unwind: bb214];
    }

    bb55: {
        _116 = &mut _39;
        _117 = const "match";
        _115 = push_ident_spanned(_116, _40, _117) -> [return: bb56, unwind: bb214];
    }

    bb56: {
        _119 = &_78;
        _120 = &mut _39;
        _118 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_119, _120) -> [return: bb57, unwind: bb214];
    }

    bb57: {
        _122 = &mut _39;
        _123 = proc_macro2::Delimiter::Brace;
        _125 = TokenStream2::new() -> [return: bb58, unwind: bb214];
    }

    bb58: {
        _127 = &_83;
        _128 = &mut _125;
        _126 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_127, _128) -> [return: bb59, unwind: bb213];
    }

    bb59: {
        _130 = &mut _125;
        _131 = proc_macro2::Delimiter::Parenthesis;
        _133 = TokenStream2::new() -> [return: bb60, unwind: bb213];
    }

    bb60: {
        _135 = &_95;
        _136 = &mut _133;
        _134 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_135, _136) -> [return: bb61, unwind: bb212];
    }

    bb61: {
        _132 = move _133;
        _129 = push_group_spanned(_130, _40, move _131, move _132) -> [return: bb62, unwind: bb213];
    }

    bb62: {
        _138 = &mut _125;
        _137 = push_fat_arrow_spanned(_138, _40) -> [return: bb63, unwind: bb213];
    }

    bb63: {
        _140 = &_91;
        _141 = &mut _125;
        _139 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_140, _141) -> [return: bb64, unwind: bb213];
    }

    bb64: {
        _143 = &mut _125;
        _144 = proc_macro2::Delimiter::Parenthesis;
        _146 = TokenStream2::new() -> [return: bb65, unwind: bb213];
    }

    bb65: {
        _148 = &_95;
        _149 = &mut _146;
        _147 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_148, _149) -> [return: bb66, unwind: bb211];
    }

    bb66: {
        _145 = move _146;
        _142 = push_group_spanned(_143, _40, move _144, move _145) -> [return: bb67, unwind: bb213];
    }

    bb67: {
        _151 = &mut _125;
        _150 = push_comma_spanned(_151, _40) -> [return: bb68, unwind: bb213];
    }

    bb68: {
        _153 = &_99;
        _154 = &mut _125;
        _152 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_153, _154) -> [return: bb69, unwind: bb213];
    }

    bb69: {
        _156 = &mut _125;
        _157 = proc_macro2::Delimiter::Parenthesis;
        _159 = TokenStream2::new() -> [return: bb70, unwind: bb213];
    }

    bb70: {
        _161 = &mut _159;
        _162 = const "__e";
        _160 = push_ident_spanned(_161, _40, _162) -> [return: bb71, unwind: bb210];
    }

    bb71: {
        _158 = move _159;
        _155 = push_group_spanned(_156, _40, move _157, move _158) -> [return: bb72, unwind: bb213];
    }

    bb72: {
        _164 = &mut _125;
        _163 = push_fat_arrow_spanned(_164, _40) -> [return: bb73, unwind: bb213];
    }

    bb73: {
        _166 = &mut _125;
        _167 = proc_macro2::Delimiter::Brace;
        _169 = TokenStream2::new() -> [return: bb74, unwind: bb213];
    }

    bb74: {
        _171 = &mut _169;
        _172 = const "__c";
        _170 = push_ident_spanned(_171, _40, _172) -> [return: bb75, unwind: bb209];
    }

    bb75: {
        _174 = &mut _169;
        _173 = push_dot_spanned(_174, _40) -> [return: bb76, unwind: bb209];
    }

    bb76: {
        _176 = &mut _169;
        _177 = const "__errors";
        _175 = push_ident_spanned(_176, _40, _177) -> [return: bb77, unwind: bb209];
    }

    bb77: {
        _179 = &mut _169;
        _178 = push_dot_spanned(_179, _40) -> [return: bb78, unwind: bb209];
    }

    bb78: {
        _181 = &mut _169;
        _182 = const "extend";
        _180 = push_ident_spanned(_181, _40, _182) -> [return: bb79, unwind: bb209];
    }

    bb79: {
        _184 = &mut _169;
        _185 = proc_macro2::Delimiter::Parenthesis;
        _187 = TokenStream2::new() -> [return: bb80, unwind: bb209];
    }

    bb80: {
        _189 = &mut _187;
        _190 = const "__e";
        _188 = push_ident_spanned(_189, _40, _190) -> [return: bb81, unwind: bb208];
    }

    bb81: {
        _186 = move _187;
        _183 = push_group_spanned(_184, _40, move _185, move _186) -> [return: bb82, unwind: bb209];
    }

    bb82: {
        _192 = &mut _169;
        _191 = push_semi_spanned(_192, _40) -> [return: bb83, unwind: bb209];
    }

    bb83: {
        _194 = &_103;
        _195 = &mut _169;
        _193 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_194, _195) -> [return: bb84, unwind: bb209];
    }

    bb84: {
        _168 = move _169;
        _165 = push_group_spanned(_166, _40, move _167, move _168) -> [return: bb85, unwind: bb213];
    }

    bb85: {
        _124 = move _125;
        _121 = push_group_spanned(_122, _40, move _123, move _124) -> [return: bb86, unwind: bb214];
    }

    bb86: {
        _197 = &mut _39;
        _196 = push_semi_spanned(_197, _40) -> [return: bb222, unwind: bb214];
    }

    bb87: {
        _199 = &mut _39;
        _200 = const "if";
        _198 = push_ident_spanned(_199, _40, _200) -> [return: bb88, unwind: bb214];
    }

    bb88: {
        _202 = &mut _39;
        _201 = push_bang_spanned(_202, _40) -> [return: bb89, unwind: bb214];
    }

    bb89: {
        _204 = &mut _39;
        _205 = const "__c";
        _203 = push_ident_spanned(_204, _40, _205) -> [return: bb90, unwind: bb214];
    }

    bb90: {
        _207 = &mut _39;
        _206 = push_dot_spanned(_207, _40) -> [return: bb91, unwind: bb214];
    }

    bb91: {
        _209 = &mut _39;
        _210 = const "__errors";
        _208 = push_ident_spanned(_209, _40, _210) -> [return: bb92, unwind: bb214];
    }

    bb92: {
        _212 = &mut _39;
        _211 = push_dot_spanned(_212, _40) -> [return: bb93, unwind: bb214];
    }

    bb93: {
        _214 = &mut _39;
        _215 = const "is_empty";
        _213 = push_ident_spanned(_214, _40, _215) -> [return: bb94, unwind: bb214];
    }

    bb94: {
        _217 = &mut _39;
        _218 = proc_macro2::Delimiter::Parenthesis;
        _219 = TokenStream2::new() -> [return: bb95, unwind: bb214];
    }

    bb95: {
        _216 = push_group_spanned(_217, _40, move _218, move _219) -> [return: bb96, unwind: bb214];
    }

    bb96: {
        _221 = &mut _39;
        _222 = proc_macro2::Delimiter::Brace;
        _224 = TokenStream2::new() -> [return: bb97, unwind: bb214];
    }

    bb97: {
        _226 = &mut _224;
        _227 = const "return";
        _225 = push_ident_spanned(_226, _40, _227) -> [return: bb98, unwind: bb207];
    }

    bb98: {
        _452 = const _;
        _229 = &mut _224;
        _228 = <StaticPath as ToTokens>::to_tokens(_452, _229) -> [return: bb99, unwind: bb207];
    }

    bb99: {
        _231 = &mut _224;
        _232 = proc_macro2::Delimiter::Parenthesis;
        _234 = TokenStream2::new() -> [return: bb100, unwind: bb207];
    }

    bb100: {
        _236 = &mut _234;
        _237 = const "__c";
        _235 = push_ident_spanned(_236, _40, _237) -> [return: bb101, unwind: bb206];
    }

    bb101: {
        _239 = &mut _234;
        _238 = push_dot_spanned(_239, _40) -> [return: bb102, unwind: bb206];
    }

    bb102: {
        _241 = &mut _234;
        _242 = const "__errors";
        _240 = push_ident_spanned(_241, _40, _242) -> [return: bb103, unwind: bb206];
    }

    bb103: {
        _233 = move _234;
        _230 = push_group_spanned(_231, _40, move _232, move _233) -> [return: bb104, unwind: bb207];
    }

    bb104: {
        _244 = &mut _224;
        _243 = push_semi_spanned(_244, _40) -> [return: bb105, unwind: bb207];
    }

    bb105: {
        _223 = move _224;
        _220 = push_group_spanned(_221, _40, move _222, move _223) -> [return: bb106, unwind: bb214];
    }

    bb106: {
        _246 = &mut _39;
        _247 = const "let";
        _245 = push_ident_spanned(_246, _40, _247) -> [return: bb107, unwind: bb214];
    }

    bb107: {
        _249 = &_19;
        _250 = &mut _39;
        _248 = <proc_macro2::Ident as ToTokens>::to_tokens(_249, _250) -> [return: bb108, unwind: bb214];
    }

    bb108: {
        _252 = &mut _39;
        _251 = push_eq_spanned(_252, _40) -> [return: bb109, unwind: bb214];
    }

    bb109: {
        _254 = &mut _39;
        _255 = const "Self";
        _253 = push_ident_spanned(_254, _40, _255) -> [return: bb110, unwind: bb214];
    }

    bb110: {
        _257 = &mut _39;
        _258 = proc_macro2::Delimiter::Brace;
        _260 = TokenStream2::new() -> [return: bb111, unwind: bb214];
    }

    bb111: {
        _261 = const 0_usize;
        _264 = &_15;
        _263 = <Vec<proc_macro2::Ident> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _264) -> [return: bb112, unwind: bb205];
    }

    bb112: {
        _262 = move (_263.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _265 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb113, unwind: bb205];
    }

    bb113: {
        _267 = <std::slice::Iter<'_, proc_macro2::Ident> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _262) -> [return: bb114, unwind: bb205];
    }

    bb114: {
        _266 = move (_267.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _268 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb223, unwind: bb205];
    }

    bb115: {
        _269 = const true;
        switchInt(move _269) -> [0: bb130, otherwise: bb116];
    }

    bb116: {
        _272 = &mut _266;
        _271 = <std::slice::Iter<'_, proc_macro2::Ident> as Iterator>::next(move _272) -> [return: bb117, unwind: bb205];
    }

    bb117: {
        _273 = discriminant(_271);
        switchInt(move _273) -> [0: bb130, 1: bb118, otherwise: bb6];
    }

    bb118: {
        _274 = ((_271 as Some).0: &proc_macro2::Ident);
        _270 = RepInterp::<&proc_macro2::Ident>(_274);
        _276 = RepInterp::<&proc_macro2::Ident>::next(_270) -> [return: bb119, unwind: bb205];
    }

    bb119: {
        _277 = discriminant(_276);
        switchInt(move _277) -> [0: bb130, 1: bb120, otherwise: bb6];
    }

    bb120: {
        _278 = ((_276 as Some).0: &proc_macro2::Ident);
        _275 = RepInterp::<&proc_macro2::Ident>(_278);
        _280 = _261;
        _279 = Gt(move _280, const 0_usize);
        switchInt(move _279) -> [0: bb122, otherwise: bb121];
    }

    bb121: {
        _282 = &mut _260;
        _281 = push_comma_spanned(_282, _40) -> [return: bb224, unwind: bb205];
    }

    bb122: {
        _283 = CheckedAdd(_261, const 1_usize);
        assert(!move (_283.1: bool), "attempt to compute `{} + {}`, which would overflow", _261, const 1_usize) -> [success: bb123, unwind: bb205];
    }

    bb123: {
        _261 = move (_283.0: usize);
        _285 = &_275;
        _286 = &mut _260;
        _284 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_285, _286) -> [return: bb124, unwind: bb205];
    }

    bb124: {
        _288 = &mut _260;
        _287 = push_colon_spanned(_288, _40) -> [return: bb125, unwind: bb205];
    }

    bb125: {
        _290 = &_275;
        _291 = &mut _260;
        _289 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_290, _291) -> [return: bb126, unwind: bb205];
    }

    bb126: {
        _293 = &mut _260;
        _292 = push_dot_spanned(_293, _40) -> [return: bb127, unwind: bb205];
    }

    bb127: {
        _295 = &mut _260;
        _296 = const "unwrap";
        _294 = push_ident_spanned(_295, _40, _296) -> [return: bb128, unwind: bb205];
    }

    bb128: {
        _298 = &mut _260;
        _299 = proc_macro2::Delimiter::Parenthesis;
        _300 = TokenStream2::new() -> [return: bb129, unwind: bb205];
    }

    bb129: {
        _297 = push_group_spanned(_298, _40, move _299, move _300) -> [return: bb225, unwind: bb205];
    }

    bb130: {
        _259 = move _260;
        _256 = push_group_spanned(_257, _40, move _258, move _259) -> [return: bb131, unwind: bb214];
    }

    bb131: {
        _302 = &mut _39;
        _301 = push_semi_spanned(_302, _40) -> [return: bb132, unwind: bb214];
    }

    bb132: {
        _305 = &_25;
        _304 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _305) -> [return: bb133, unwind: bb214];
    }

    bb133: {
        _303 = (_304.0: &exports::StaticPath);
        _306 = <ThereIsNoIteratorInRepetition as std::ops::BitOr>::bitor(const ThereIsNoIteratorInRepetition, const ThereIsNoIteratorInRepetition) -> [return: bb134, unwind: bb214];
    }

    bb134: {
        _309 = &_29;
        _308 = <Vec<syn::Expr> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _309) -> [return: bb135, unwind: bb214];
    }

    bb135: {
        _307 = move (_308.0: std::slice::Iter<'_, syn::Expr>);
        _310 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb136, unwind: bb214];
    }

    bb136: {
        _313 = &_28;
        _312 = <Vec<syn::Expr> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _313) -> [return: bb137, unwind: bb214];
    }

    bb137: {
        _311 = move (_312.0: std::slice::Iter<'_, syn::Expr>);
        _314 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb226, unwind: bb214];
    }

    bb138: {
        _315 = const true;
        switchInt(move _315) -> [0: bb169, otherwise: bb139];
    }

    bb139: {
        _317 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_303) -> [return: bb140, unwind: bb214];
    }

    bb140: {
        _318 = discriminant(_317);
        switchInt(move _318) -> [0: bb169, 1: bb141, otherwise: bb6];
    }

    bb141: {
        _319 = ((_317 as Some).0: &exports::StaticPath);
        _316 = RepInterp::<&StaticPath>(_319);
        _322 = &mut _307;
        _321 = <std::slice::Iter<'_, syn::Expr> as Iterator>::next(move _322) -> [return: bb142, unwind: bb214];
    }

    bb142: {
        _323 = discriminant(_321);
        switchInt(move _323) -> [0: bb169, 1: bb143, otherwise: bb6];
    }

    bb143: {
        _324 = ((_321 as Some).0: &syn::Expr);
        _320 = RepInterp::<&syn::Expr>(_324);
        _327 = &mut _311;
        _326 = <std::slice::Iter<'_, syn::Expr> as Iterator>::next(move _327) -> [return: bb144, unwind: bb214];
    }

    bb144: {
        _328 = discriminant(_326);
        switchInt(move _328) -> [0: bb169, 1: bb145, otherwise: bb6];
    }

    bb145: {
        _329 = ((_326 as Some).0: &syn::Expr);
        _325 = RepInterp::<&syn::Expr>(_329);
        _331 = &mut _39;
        _332 = const "if";
        _330 = push_ident_spanned(_331, _40, _332) -> [return: bb146, unwind: bb214];
    }

    bb146: {
        _334 = &mut _39;
        _335 = const "let";
        _333 = push_ident_spanned(_334, _40, _335) -> [return: bb147, unwind: bb214];
    }

    bb147: {
        _337 = &_316;
        _338 = &mut _39;
        _336 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_337, _338) -> [return: bb148, unwind: bb214];
    }

    bb148: {
        _340 = &mut _39;
        _341 = proc_macro2::Delimiter::Parenthesis;
        _343 = TokenStream2::new() -> [return: bb149, unwind: bb214];
    }

    bb149: {
        _345 = &mut _343;
        _346 = const "__e";
        _344 = push_ident_spanned(_345, _40, _346) -> [return: bb150, unwind: bb204];
    }

    bb150: {
        _342 = move _343;
        _339 = push_group_spanned(_340, _40, move _341, move _342) -> [return: bb151, unwind: bb214];
    }

    bb151: {
        _348 = &mut _39;
        _347 = push_eq_spanned(_348, _40) -> [return: bb152, unwind: bb214];
    }

    bb152: {
        _350 = &_320;
        _351 = &mut _39;
        _349 = <RepInterp<&syn::Expr> as ToTokens>::to_tokens(_350, _351) -> [return: bb153, unwind: bb214];
    }

    bb153: {
        _353 = &mut _39;
        _354 = proc_macro2::Delimiter::Brace;
        _356 = TokenStream2::new() -> [return: bb154, unwind: bb214];
    }

    bb154: {
        _358 = &mut _356;
        _359 = const "__c";
        _357 = push_ident_spanned(_358, _40, _359) -> [return: bb155, unwind: bb203];
    }

    bb155: {
        _361 = &mut _356;
        _360 = push_dot_spanned(_361, _40) -> [return: bb156, unwind: bb203];
    }

    bb156: {
        _363 = &mut _356;
        _364 = const "__errors";
        _362 = push_ident_spanned(_363, _40, _364) -> [return: bb157, unwind: bb203];
    }

    bb157: {
        _366 = &mut _356;
        _365 = push_dot_spanned(_366, _40) -> [return: bb158, unwind: bb203];
    }

    bb158: {
        _368 = &mut _356;
        _369 = const "extend";
        _367 = push_ident_spanned(_368, _40, _369) -> [return: bb159, unwind: bb203];
    }

    bb159: {
        _371 = &mut _356;
        _372 = proc_macro2::Delimiter::Parenthesis;
        _374 = TokenStream2::new() -> [return: bb160, unwind: bb203];
    }

    bb160: {
        _376 = &mut _374;
        _377 = const "__e";
        _375 = push_ident_spanned(_376, _40, _377) -> [return: bb161, unwind: bb202];
    }

    bb161: {
        _379 = &mut _374;
        _378 = push_dot_spanned(_379, _40) -> [return: bb162, unwind: bb202];
    }

    bb162: {
        _381 = &mut _374;
        _382 = const "with_name";
        _380 = push_ident_spanned(_381, _40, _382) -> [return: bb163, unwind: bb202];
    }

    bb163: {
        _384 = &mut _374;
        _385 = proc_macro2::Delimiter::Parenthesis;
        _387 = TokenStream2::new() -> [return: bb164, unwind: bb202];
    }

    bb164: {
        _389 = &_325;
        _390 = &mut _387;
        _388 = <RepInterp<&syn::Expr> as ToTokens>::to_tokens(_389, _390) -> [return: bb165, unwind: bb201];
    }

    bb165: {
        _386 = move _387;
        _383 = push_group_spanned(_384, _40, move _385, move _386) -> [return: bb166, unwind: bb202];
    }

    bb166: {
        _373 = move _374;
        _370 = push_group_spanned(_371, _40, move _372, move _373) -> [return: bb167, unwind: bb203];
    }

    bb167: {
        _392 = &mut _356;
        _391 = push_semi_spanned(_392, _40) -> [return: bb168, unwind: bb203];
    }

    bb168: {
        _355 = move _356;
        _352 = push_group_spanned(_353, _40, move _354, move _355) -> [return: bb227, unwind: bb214];
    }

    bb169: {
        _394 = &mut _39;
        _395 = const "if";
        _393 = push_ident_spanned(_394, _40, _395) -> [return: bb170, unwind: bb214];
    }

    bb170: {
        _397 = &mut _39;
        _396 = push_bang_spanned(_397, _40) -> [return: bb171, unwind: bb214];
    }

    bb171: {
        _399 = &mut _39;
        _400 = const "__c";
        _398 = push_ident_spanned(_399, _40, _400) -> [return: bb172, unwind: bb214];
    }

    bb172: {
        _402 = &mut _39;
        _401 = push_dot_spanned(_402, _40) -> [return: bb173, unwind: bb214];
    }

    bb173: {
        _404 = &mut _39;
        _405 = const "__errors";
        _403 = push_ident_spanned(_404, _40, _405) -> [return: bb174, unwind: bb214];
    }

    bb174: {
        _407 = &mut _39;
        _406 = push_dot_spanned(_407, _40) -> [return: bb175, unwind: bb214];
    }

    bb175: {
        _409 = &mut _39;
        _410 = const "is_empty";
        _408 = push_ident_spanned(_409, _40, _410) -> [return: bb176, unwind: bb214];
    }

    bb176: {
        _412 = &mut _39;
        _413 = proc_macro2::Delimiter::Parenthesis;
        _414 = TokenStream2::new() -> [return: bb177, unwind: bb214];
    }

    bb177: {
        _411 = push_group_spanned(_412, _40, move _413, move _414) -> [return: bb178, unwind: bb214];
    }

    bb178: {
        _416 = &mut _39;
        _417 = proc_macro2::Delimiter::Brace;
        _419 = TokenStream2::new() -> [return: bb179, unwind: bb214];
    }

    bb179: {
        _421 = &mut _419;
        _422 = const "return";
        _420 = push_ident_spanned(_421, _40, _422) -> [return: bb180, unwind: bb200];
    }

    bb180: {
        _451 = const _;
        _424 = &mut _419;
        _423 = <StaticPath as ToTokens>::to_tokens(_451, _424) -> [return: bb181, unwind: bb200];
    }

    bb181: {
        _426 = &mut _419;
        _427 = proc_macro2::Delimiter::Parenthesis;
        _429 = TokenStream2::new() -> [return: bb182, unwind: bb200];
    }

    bb182: {
        _431 = &mut _429;
        _432 = const "__c";
        _430 = push_ident_spanned(_431, _40, _432) -> [return: bb183, unwind: bb199];
    }

    bb183: {
        _434 = &mut _429;
        _433 = push_dot_spanned(_434, _40) -> [return: bb184, unwind: bb199];
    }

    bb184: {
        _436 = &mut _429;
        _437 = const "__errors";
        _435 = push_ident_spanned(_436, _40, _437) -> [return: bb185, unwind: bb199];
    }

    bb185: {
        _428 = move _429;
        _425 = push_group_spanned(_426, _40, move _427, move _428) -> [return: bb186, unwind: bb200];
    }

    bb186: {
        _439 = &mut _419;
        _438 = push_semi_spanned(_439, _40) -> [return: bb187, unwind: bb200];
    }

    bb187: {
        _418 = move _419;
        _415 = push_group_spanned(_416, _40, move _417, move _418) -> [return: bb188, unwind: bb214];
    }

    bb188: {
        _441 = &mut _39;
        _442 = const "Ok";
        _440 = push_ident_spanned(_441, _40, _442) -> [return: bb189, unwind: bb214];
    }

    bb189: {
        _444 = &mut _39;
        _445 = proc_macro2::Delimiter::Parenthesis;
        _447 = TokenStream2::new() -> [return: bb190, unwind: bb214];
    }

    bb190: {
        _449 = &_19;
        _450 = &mut _447;
        _448 = <proc_macro2::Ident as ToTokens>::to_tokens(_449, _450) -> [return: bb191, unwind: bb198];
    }

    bb191: {
        _446 = move _447;
        _443 = push_group_spanned(_444, _40, move _445, move _446) -> [return: bb192, unwind: bb214];
    }

    bb192: {
        _38 = move _39;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _38);
        drop(_29) -> [return: bb193, unwind: bb216];
    }

    bb193: {
        drop(_28) -> [return: bb194, unwind: bb217];
    }

    bb194: {
        drop(_19) -> [return: bb195, unwind: bb218];
    }

    bb195: {
        drop(_15) -> [return: bb196, unwind: bb219];
    }

    bb196: {
        drop(_4) -> [return: bb197, unwind continue];
    }

    bb197: {
        return;
    }

    bb198 (cleanup): {
        drop(_447) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb199 (cleanup): {
        drop(_429) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb200 (cleanup): {
        drop(_419) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb201 (cleanup): {
        drop(_387) -> [return: bb202, unwind terminate(cleanup)];
    }

    bb202 (cleanup): {
        drop(_374) -> [return: bb203, unwind terminate(cleanup)];
    }

    bb203 (cleanup): {
        drop(_356) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb204 (cleanup): {
        drop(_343) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb205 (cleanup): {
        drop(_260) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb206 (cleanup): {
        drop(_234) -> [return: bb207, unwind terminate(cleanup)];
    }

    bb207 (cleanup): {
        drop(_224) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb208 (cleanup): {
        drop(_187) -> [return: bb209, unwind terminate(cleanup)];
    }

    bb209 (cleanup): {
        drop(_169) -> [return: bb213, unwind terminate(cleanup)];
    }

    bb210 (cleanup): {
        drop(_159) -> [return: bb213, unwind terminate(cleanup)];
    }

    bb211 (cleanup): {
        drop(_146) -> [return: bb213, unwind terminate(cleanup)];
    }

    bb212 (cleanup): {
        drop(_133) -> [return: bb213, unwind terminate(cleanup)];
    }

    bb213 (cleanup): {
        drop(_125) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb214 (cleanup): {
        drop(_39) -> [return: bb215, unwind terminate(cleanup)];
    }

    bb215 (cleanup): {
        drop(_29) -> [return: bb216, unwind terminate(cleanup)];
    }

    bb216 (cleanup): {
        drop(_28) -> [return: bb217, unwind terminate(cleanup)];
    }

    bb217 (cleanup): {
        drop(_19) -> [return: bb218, unwind terminate(cleanup)];
    }

    bb218 (cleanup): {
        drop(_15) -> [return: bb219, unwind terminate(cleanup)];
    }

    bb219 (cleanup): {
        drop(_4) -> [return: bb220, unwind terminate(cleanup)];
    }

    bb220 (cleanup): {
        resume;
    }

    bb221: {
        goto -> bb35;
    }

    bb222: {
        goto -> bb35;
    }

    bb223: {
        goto -> bb115;
    }

    bb224: {
        goto -> bb122;
    }

    bb225: {
        goto -> bb115;
    }

    bb226: {
        goto -> bb138;
    }

    bb227: {
        goto -> bb138;
    }
}

promoted[0] in from_form::derive_from_form::{closure#13}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#13}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#13}::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:190:26: 190:29}, _2: devise::Field<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _2;
    debug mapper => (*((*_1).0: &mut &mut devise::MapperBuild));
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: &mut &mut devise::MapperBuild;
    let mut _4: &mut devise::MapperBuild;

    bb0: {
        _3 = deref_copy ((*_1).0: &mut &mut devise::MapperBuild);
        _4 = deref_copy (*_3);
        _0 = <devise::MapperBuild as devise::Mapper>::map_field(_4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#13}::{closure#1}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:194:26: 194:29}, _2: devise::Field<'_>) -> proc_macro2::Ident {
    debug f => _2;
    let mut _0: proc_macro2::Ident;
    let _3: &proc_macro2::Ident;
    let mut _4: &devise::Field<'_>;

    bb0: {
        _4 = &_2;
        _3 = <devise::Field<'_> as form_field::FieldExt>::ident(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <proc_macro2::Ident as Clone>::clone(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn from_form::derive_from_form::{closure#13}::{closure#2}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:200:26: 200:29}, _2: devise::Field<'_>) -> (syn::Expr, Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>) {
    debug f => _2;
    debug o => (*((*_1).0: &proc_macro2::Ident));
    let mut _0: (syn::Expr, std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>);
    let mut _3: syn::Expr;
    let mut _4: std::result::Result<syn::Expr, devise::Diagnostic>;
    let mut _5: &devise::Field<'_>;
    let mut _6: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
    let mut _7: std::result::Result<std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic>;
    let mut _8: devise::Field<'_>;
    let mut _9: &proc_macro2::Ident;

    bb0: {
        _5 = &_2;
        _4 = <devise::Field<'_> as form_field::FieldExt>::name_view(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::result::Result::<syn::Expr, devise::Diagnostic>::unwrap(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = _2;
        _9 = deref_copy ((*_1).0: &proc_macro2::Ident);
        _7 = form_field::validators(move _8, _9, const false) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _6 = std::result::Result::<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic>::unwrap(move _7) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = (move _3, move _6);
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn from_form::derive_from_form::{closure#13}::{closure#3}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:201:26: 201:36}, _2: (syn::Expr, Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>)) -> Map<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52}> {
    let mut _0: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52}>;
    let _3: syn::Expr;
    let _4: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
    let mut _5: {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52};
    let mut _6: impl std::iter::Iterator<Item = syn::Expr> + '_;
    scope 1 {
        debug nv => _3;
        debug vs => _4;
    }

    bb0: {
        _3 = move (_2.0: syn::Expr);
        _6 = move (_2.1: impl std::iter::Iterator<Item = syn::Expr> + '_);
        _4 = move (_6 as subtype Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>);
        _5 = {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52} { nv: move _3 };
        _0 = <Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}> as Iterator>::map::<(syn::Expr, syn::Expr), {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52}>(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form::derive_from_form::{closure#13}::{closure#3}::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:201:44: 201:52}, _2: syn::Expr) -> (syn::Expr, syn::Expr) {
    debug v => _2;
    debug nv => ((*_1).0: syn::Expr);
    let mut _0: (syn::Expr, syn::Expr);
    let mut _3: syn::Expr;
    let mut _4: &syn::Expr;
    let mut _5: syn::Expr;

    bb0: {
        _4 = &((*_1).0: syn::Expr);
        _3 = <syn::Expr as Clone>::clone(move _4) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _5 = move _2;
        _0 = (move _3, move _5);
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn from_form::derive_from_form::{closure#14}(_1: &mut {closure@core/codegen/src/derive/from_form.rs:230:28: 230:34}, _2: &mut devise::MapperBuild, _3: devise::Field<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: &proc_macro2::Ident;
    let _5: syn::Type;
    let _6: syn::Expr;
    let mut _7: (&proc_macro2::Ident, syn::Type, syn::Expr);
    let mut _8: &proc_macro2::Ident;
    let mut _9: &devise::Field<'_>;
    let mut _10: syn::Type;
    let mut _11: &devise::Field<'_>;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::Expr>;
    let mut _13: std::result::Result<syn::Expr, devise::Diagnostic>;
    let mut _14: &devise::Field<'_>;
    let mut _15: isize;
    let _16: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _17: syn::Expr;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>>;
    let mut _20: std::result::Result<std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic>;
    let mut _21: devise::Field<'_>;
    let _22: &&proc_macro2::Ident;
    let mut _23: isize;
    let mut _27: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<proc_macro2::TokenStream>>;
    let mut _28: std::result::Result<std::option::Option<proc_macro2::TokenStream>, devise::Diagnostic>;
    let mut _29: devise::Field<'_>;
    let mut _30: isize;
    let mut _33: {closure@core/codegen/src/derive/from_form.rs:234:37: 234:39};
    let mut _34: &syn::Type;
    let mut _36: proc_macro2::TokenStream;
    let mut _39: &syn::Type;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let mut _42: proc_macro2::Delimiter;
    let mut _43: proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let _54: &syn::Expr;
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: &str;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: &str;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: ();
    let _82: &&proc_macro2::Ident;
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: &str;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let mut _91: proc_macro2::Delimiter;
    let mut _92: proc_macro2::TokenStream;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: ();
    let _97: &proc_macro2::TokenStream;
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: ();
    let mut _100: &mut proc_macro2::TokenStream;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: &str;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let mut _106: proc_macro2::Delimiter;
    let mut _107: proc_macro2::TokenStream;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: &str;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: &str;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: ();
    let mut _126: &mut proc_macro2::TokenStream;
    let _127: &str;
    let _128: ();
    let mut _129: &mut proc_macro2::TokenStream;
    let mut _130: proc_macro2::Delimiter;
    let mut _131: proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: ();
    let _137: &syn::Type;
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: ();
    let mut _140: &mut proc_macro2::TokenStream;
    let _141: &str;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: ();
    let mut _152: &mut proc_macro2::TokenStream;
    let _153: &str;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let _156: ();
    let mut _157: &mut proc_macro2::TokenStream;
    let _158: ();
    let mut _159: &mut proc_macro2::TokenStream;
    let _160: &str;
    let _161: ();
    let mut _162: &mut proc_macro2::TokenStream;
    let _163: ();
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: &str;
    let _166: ();
    let mut _167: &mut proc_macro2::TokenStream;
    let mut _168: proc_macro2::Delimiter;
    let mut _169: proc_macro2::TokenStream;
    let _171: ();
    let mut _172: &mut proc_macro2::TokenStream;
    let _173: ();
    let _174: &&proc_macro2::Ident;
    let mut _175: &mut proc_macro2::TokenStream;
    let _176: ();
    let mut _177: &mut proc_macro2::TokenStream;
    let _178: ();
    let mut _179: &mut proc_macro2::TokenStream;
    let mut _180: proc_macro2::Delimiter;
    let mut _181: proc_macro2::TokenStream;
    let _183: ();
    let mut _184: &mut proc_macro2::TokenStream;
    let _185: &str;
    let _186: ();
    let mut _187: &mut proc_macro2::TokenStream;
    let _188: &str;
    let _189: ();
    let mut _190: &mut proc_macro2::TokenStream;
    let _191: &str;
    let _192: ();
    let mut _193: &mut proc_macro2::TokenStream;
    let _194: ();
    let mut _195: &mut proc_macro2::TokenStream;
    let _196: ();
    let mut _197: &mut proc_macro2::TokenStream;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let _200: &str;
    let _201: ();
    let mut _202: &mut proc_macro2::TokenStream;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let _205: &str;
    let _206: ();
    let mut _207: &mut proc_macro2::TokenStream;
    let mut _208: proc_macro2::Delimiter;
    let mut _209: proc_macro2::TokenStream;
    let _210: ();
    let mut _211: &mut proc_macro2::TokenStream;
    let mut _213: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _214: &exports::StaticPath;
    let mut _217: (std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, quote::__private::HasIterator);
    let mut _218: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
    let mut _220: bool;
    let mut _222: std::option::Option<&exports::StaticPath>;
    let mut _223: isize;
    let mut _226: std::option::Option<syn::Expr>;
    let mut _227: &mut std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
    let mut _228: isize;
    let _230: ();
    let mut _231: &mut proc_macro2::TokenStream;
    let _232: &str;
    let _233: ();
    let mut _234: &mut proc_macro2::TokenStream;
    let _235: &str;
    let _236: ();
    let _237: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _238: &mut proc_macro2::TokenStream;
    let _239: ();
    let mut _240: &mut proc_macro2::TokenStream;
    let mut _241: proc_macro2::Delimiter;
    let mut _242: proc_macro2::TokenStream;
    let _244: ();
    let mut _245: &mut proc_macro2::TokenStream;
    let _246: &str;
    let _247: ();
    let mut _248: &mut proc_macro2::TokenStream;
    let _249: ();
    let _250: &quote::__private::RepInterp<syn::Expr>;
    let mut _251: &mut proc_macro2::TokenStream;
    let _252: ();
    let mut _253: &mut proc_macro2::TokenStream;
    let mut _254: proc_macro2::Delimiter;
    let mut _255: proc_macro2::TokenStream;
    let _257: ();
    let mut _258: &mut proc_macro2::TokenStream;
    let _259: &str;
    let _260: ();
    let mut _261: &mut proc_macro2::TokenStream;
    let _262: ();
    let mut _263: &mut proc_macro2::TokenStream;
    let _264: &str;
    let _265: ();
    let mut _266: &mut proc_macro2::TokenStream;
    let mut _267: proc_macro2::Delimiter;
    let mut _268: proc_macro2::TokenStream;
    let _270: ();
    let mut _271: &mut proc_macro2::TokenStream;
    let _272: &str;
    let _273: ();
    let mut _274: &mut proc_macro2::TokenStream;
    let _275: ();
    let mut _276: &mut proc_macro2::TokenStream;
    let _277: &str;
    let _278: ();
    let mut _279: &mut proc_macro2::TokenStream;
    let _280: ();
    let mut _281: &mut proc_macro2::TokenStream;
    let _282: &str;
    let _283: ();
    let mut _284: &mut proc_macro2::TokenStream;
    let mut _285: proc_macro2::Delimiter;
    let mut _286: proc_macro2::TokenStream;
    let _287: ();
    let mut _288: &mut proc_macro2::TokenStream;
    let _289: ();
    let mut _290: &mut proc_macro2::TokenStream;
    let _291: &str;
    let _292: ();
    let mut _293: &mut proc_macro2::TokenStream;
    let mut _294: proc_macro2::Delimiter;
    let mut _295: proc_macro2::TokenStream;
    let _297: ();
    let mut _298: &mut proc_macro2::TokenStream;
    let _299: ();
    let _300: &&proc_macro2::Ident;
    let mut _301: &mut proc_macro2::TokenStream;
    let _302: ();
    let mut _303: &mut proc_macro2::TokenStream;
    let _304: ();
    let mut _305: &mut proc_macro2::TokenStream;
    let _306: &str;
    let _307: ();
    let mut _308: &mut proc_macro2::TokenStream;
    let mut _309: proc_macro2::Delimiter;
    let mut _310: proc_macro2::TokenStream;
    let _312: ();
    let mut _313: &mut proc_macro2::TokenStream;
    let _314: &str;
    let _315: ();
    let mut _316: &mut proc_macro2::TokenStream;
    let _317: ();
    let mut _318: &mut proc_macro2::TokenStream;
    let _319: &str;
    let _320: ();
    let mut _321: &mut proc_macro2::TokenStream;
    let mut _322: proc_macro2::Delimiter;
    let mut _323: proc_macro2::TokenStream;
    let _325: ();
    let mut _326: &mut proc_macro2::TokenStream;
    let _327: ();
    let mut _328: &mut proc_macro2::TokenStream;
    let _329: &str;
    let _330: ();
    let mut _331: &mut proc_macro2::TokenStream;
    let _332: ();
    let mut _333: &mut proc_macro2::TokenStream;
    let _334: &str;
    let _335: ();
    let mut _336: &mut proc_macro2::TokenStream;
    let _337: ();
    let mut _338: &mut proc_macro2::TokenStream;
    let _339: &str;
    let _340: ();
    let mut _341: &mut proc_macro2::TokenStream;
    let mut _342: proc_macro2::Delimiter;
    let mut _343: proc_macro2::TokenStream;
    let _345: ();
    let mut _346: &mut proc_macro2::TokenStream;
    let _347: &str;
    let _348: ();
    let mut _349: &mut proc_macro2::TokenStream;
    let _350: ();
    let mut _351: &mut proc_macro2::TokenStream;
    let _352: &str;
    let _353: ();
    let mut _354: &mut proc_macro2::TokenStream;
    let mut _355: proc_macro2::Delimiter;
    let mut _356: proc_macro2::TokenStream;
    let _358: ();
    let mut _359: &mut proc_macro2::TokenStream;
    let _360: ();
    let mut _361: &mut proc_macro2::TokenStream;
    let _362: &str;
    let _363: ();
    let mut _364: &mut proc_macro2::TokenStream;
    let _365: ();
    let mut _366: &mut proc_macro2::TokenStream;
    let _367: &str;
    let _368: ();
    let mut _369: &mut proc_macro2::TokenStream;
    let _370: ();
    let mut _371: &mut proc_macro2::TokenStream;
    let _372: &str;
    let _373: ();
    let mut _374: &mut proc_macro2::TokenStream;
    let mut _375: proc_macro2::Delimiter;
    let mut _376: proc_macro2::TokenStream;
    let _377: ();
    let mut _378: &mut proc_macro2::TokenStream;
    let _379: ();
    let mut _380: &mut proc_macro2::TokenStream;
    let _381: &str;
    let _382: ();
    let mut _383: &mut proc_macro2::TokenStream;
    let mut _384: proc_macro2::Delimiter;
    let mut _385: proc_macro2::TokenStream;
    let _387: ();
    let mut _388: &mut proc_macro2::TokenStream;
    let _389: ();
    let mut _390: &mut proc_macro2::TokenStream;
    let _391: ();
    let mut _392: &mut proc_macro2::TokenStream;
    let _393: ();
    let mut _394: &mut proc_macro2::TokenStream;
    let _395: &str;
    let _396: ();
    let mut _397: &mut proc_macro2::TokenStream;
    let _398: ();
    let mut _399: &mut proc_macro2::TokenStream;
    let _400: &str;
    let _401: ();
    let mut _402: &mut proc_macro2::TokenStream;
    let _403: ();
    let mut _404: &mut proc_macro2::TokenStream;
    let _405: &str;
    let _406: ();
    let mut _407: &mut proc_macro2::TokenStream;
    let mut _408: proc_macro2::Delimiter;
    let mut _409: proc_macro2::TokenStream;
    let _410: ();
    let mut _411: &mut proc_macro2::TokenStream;
    let _412: ();
    let mut _413: &mut proc_macro2::TokenStream;
    let _414: &str;
    let _415: ();
    let mut _416: &mut proc_macro2::TokenStream;
    let mut _417: proc_macro2::Delimiter;
    let mut _418: proc_macro2::TokenStream;
    let _420: ();
    let mut _421: &mut proc_macro2::TokenStream;
    let _422: &str;
    let mut _427: &proc_macro2::Ident;
    let mut _428: impl std::iter::Iterator<Item = syn::Expr> + '_;
    let mut _429: impl std::iter::Iterator<Item = syn::Expr> + '_;
    let mut _430: bool;
    scope 1 {
        debug ident => _4;
        debug ty => _5;
        debug name_view => _6;
        let _18: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
        let _24: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _25: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
        scope 6 {
            debug validator => _18;
            let _26: proc_macro2::TokenStream;
            let _31: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
            let _32: std::option::Option<proc_macro2::TokenStream>;
            scope 11 {
                debug default => _26;
                let _35: exports::StaticPath;
                scope 16 {
                    debug _err => const _;
                    let mut _37: proc_macro2::TokenStream;
                    scope 17 {
                        debug _s => _37;
                        let _38: proc_macro2::Span;
                        scope 18 {
                            debug _span => _38;
                            let mut _44: proc_macro2::TokenStream;
                            scope 19 {
                                debug _s => _44;
                                scope 20 {
                                    debug _span => _38;
                                    let mut _93: proc_macro2::TokenStream;
                                    let mut _170: proc_macro2::TokenStream;
                                    let mut _324: proc_macro2::TokenStream;
                                    let mut _357: proc_macro2::TokenStream;
                                    scope 21 {
                                        debug _s => _93;
                                        scope 22 {
                                            debug _span => _38;
                                            let mut _108: proc_macro2::TokenStream;
                                            let mut _425: &exports::StaticPath;
                                            scope 23 {
                                                debug _s => _108;
                                                scope 24 {
                                                    debug _span => _38;
                                                    let mut _426: &exports::StaticPath;
                                                    scope 25 {
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    scope 26 {
                                        debug _s => _170;
                                        scope 27 {
                                            debug _span => _38;
                                            let mut _182: proc_macro2::TokenStream;
                                            scope 28 {
                                                debug _s => _182;
                                                scope 29 {
                                                    debug _span => _38;
                                                    let mut _296: proc_macro2::TokenStream;
                                                    let mut _311: proc_macro2::TokenStream;
                                                    let mut _424: &exports::StaticPath;
                                                    scope 30 {
                                                    }
                                                    scope 31 {
                                                        debug has_iter => const ThereIsNoIteratorInRepetition;
                                                        scope 32 {
                                                            debug _err => _212;
                                                            debug i => const ThereIsNoIteratorInRepetition;
                                                            let _215: quote::__private::ThereIsNoIteratorInRepetition;
                                                            scope 34 {
                                                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                scope 35 {
                                                                    debug validator => _216;
                                                                    debug i => const HasIterator;
                                                                    let _219: quote::__private::HasIterator;
                                                                    scope 37 {
                                                                        debug has_iter => const HasIterator;
                                                                        scope 38 {
                                                                            let _221: quote::__private::RepInterp<&exports::StaticPath>;
                                                                            let _224: &exports::StaticPath;
                                                                            scope 39 {
                                                                                debug _err => _221;
                                                                                let _225: quote::__private::RepInterp<syn::Expr>;
                                                                                let _229: syn::Expr;
                                                                                scope 41 {
                                                                                    debug validator => _225;
                                                                                    let mut _243: proc_macro2::TokenStream;
                                                                                    let mut _256: proc_macro2::TokenStream;
                                                                                    scope 43 {
                                                                                        debug _s => _243;
                                                                                        scope 44 {
                                                                                            debug _span => _38;
                                                                                        }
                                                                                    }
                                                                                    scope 45 {
                                                                                        debug _s => _256;
                                                                                        scope 46 {
                                                                                            debug _span => _38;
                                                                                            let mut _269: proc_macro2::TokenStream;
                                                                                            scope 47 {
                                                                                                debug _s => _269;
                                                                                                scope 48 {
                                                                                                    debug _span => _38;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                }
                                                                                scope 42 {
                                                                                    debug _x => _229;
                                                                                }
                                                                            }
                                                                            scope 40 {
                                                                                debug _x => _224;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                                scope 36 {
                                                                    let mut _216: std::iter::Map<std::iter::Filter<std::iter::Map<std::iter::FilterMap<std::vec::IntoIter<derive::form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>;
                                                                }
                                                            }
                                                        }
                                                        scope 33 {
                                                            let mut _212: &exports::StaticPath;
                                                        }
                                                    }
                                                    scope 49 {
                                                    }
                                                    scope 50 {
                                                        debug _s => _296;
                                                        scope 51 {
                                                            debug _span => _38;
                                                        }
                                                    }
                                                    scope 52 {
                                                        debug _s => _311;
                                                        scope 53 {
                                                            debug _span => _38;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    scope 54 {
                                        debug _s => _324;
                                        scope 55 {
                                            debug _span => _38;
                                            let mut _344: proc_macro2::TokenStream;
                                            scope 56 {
                                                debug _s => _344;
                                                scope 57 {
                                                    debug _span => _38;
                                                }
                                            }
                                        }
                                    }
                                    scope 58 {
                                        debug _s => _357;
                                        scope 59 {
                                            debug _span => _38;
                                            let mut _386: proc_macro2::TokenStream;
                                            let mut _419: proc_macro2::TokenStream;
                                            scope 60 {
                                            }
                                            scope 61 {
                                                debug _s => _386;
                                                scope 62 {
                                                    debug _span => _38;
                                                    let mut _423: &exports::StaticPath;
                                                    scope 63 {
                                                    }
                                                }
                                            }
                                            scope 64 {
                                                debug _s => _419;
                                                scope 65 {
                                                    debug _span => _38;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 12 {
                debug residual => _31;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _32;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _24;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _25;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _16;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _17;
        scope 5 {
        }
    }

    bb0: {
        _430 = const false;
        _9 = &_3;
        _8 = <devise::Field<'_> as form_field::FieldExt>::ident(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = &_3;
        _10 = <devise::Field<'_> as form_field::FieldExt>::stripped_ty(move _11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _14 = &_3;
        _13 = <devise::Field<'_> as form_field::FieldExt>::name_view(move _14) -> [return: bb3, unwind: bb206];
    }

    bb3: {
        _12 = <std::result::Result<syn::Expr, devise::Diagnostic> as std::ops::Try>::branch(move _13) -> [return: bb4, unwind: bb206];
    }

    bb4: {
        _15 = discriminant(_12);
        switchInt(move _15) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _17 = move ((_12 as Continue).0: syn::Expr);
        _7 = (move _8, move _10, move _17);
        _4 = (_7.0: &proc_macro2::Ident);
        _5 = move (_7.1: syn::Type);
        _6 = move (_7.2: syn::Expr);
        _21 = _3;
        _22 = &_4;
        _427 = deref_copy (*_22);
        _20 = form_field::validators(move _21, _427, const true) -> [return: bb9, unwind: bb203];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _16 = move ((_12 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _16) -> [return: bb8, unwind: bb205];
    }

    bb8: {
        drop(_10) -> [return: bb183, unwind continue];
    }

    bb9: {
        _19 = <std::result::Result<Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>, devise::Diagnostic> as std::ops::Try>::branch(move _20) -> [return: bb10, unwind: bb203];
    }

    bb10: {
        _23 = discriminant(_19);
        switchInt(move _23) -> [0: bb11, 1: bb12, otherwise: bb6];
    }

    bb11: {
        _428 = move ((_19 as Continue).0: impl std::iter::Iterator<Item = syn::Expr> + '_);
        _25 = move (_428 as subtype Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>);
        _430 = const true;
        _18 = move _25;
        _29 = _3;
        _28 = form_field::default(move _29) -> [return: bb13, unwind: bb209];
    }

    bb12: {
        _24 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _24) -> [return: bb210, unwind: bb203];
    }

    bb13: {
        _27 = <std::result::Result<Option<TokenStream2>, devise::Diagnostic> as std::ops::Try>::branch(move _28) -> [return: bb14, unwind: bb209];
    }

    bb14: {
        _30 = discriminant(_27);
        switchInt(move _30) -> [0: bb15, 1: bb16, otherwise: bb6];
    }

    bb15: {
        _32 = move ((_27 as Continue).0: std::option::Option<proc_macro2::TokenStream>);
        _34 = &_5;
        _33 = {closure@core/codegen/src/derive/from_form.rs:234:37: 234:39} { ty: move _34 };
        _26 = Option::<TokenStream2>::unwrap_or_else::<{closure@core/codegen/src/derive/from_form.rs:234:37: 234:39}>(move _32, move _33) -> [return: bb18, unwind: bb209];
    }

    bb16: {
        _31 = move ((_27 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _31) -> [return: bb17, unwind: bb209];
    }

    bb17: {
        drop(_18) -> [return: bb181, unwind: bb203];
    }

    bb18: {
        _35 = const _;
        _37 = TokenStream2::new() -> [return: bb19, unwind: bb202];
    }

    bb19: {
        _39 = &_5;
        _38 = <syn::Type as devise::Spanned>::span(move _39) -> [return: bb20, unwind: bb201];
    }

    bb20: {
        _41 = &mut _37;
        _42 = proc_macro2::Delimiter::Brace;
        _44 = TokenStream2::new() -> [return: bb21, unwind: bb201];
    }

    bb21: {
        _46 = &mut _44;
        _47 = const "let";
        _45 = push_ident_spanned(_46, _38, _47) -> [return: bb22, unwind: bb200];
    }

    bb22: {
        _49 = &mut _44;
        _50 = const "__name";
        _48 = push_ident_spanned(_49, _38, _50) -> [return: bb23, unwind: bb200];
    }

    bb23: {
        _52 = &mut _44;
        _51 = push_eq_spanned(_52, _38) -> [return: bb24, unwind: bb200];
    }

    bb24: {
        _54 = &_6;
        _55 = &mut _44;
        _53 = <syn::Expr as ToTokens>::to_tokens(_54, _55) -> [return: bb25, unwind: bb200];
    }

    bb25: {
        _57 = &mut _44;
        _56 = push_semi_spanned(_57, _38) -> [return: bb26, unwind: bb200];
    }

    bb26: {
        _59 = &mut _44;
        _60 = const "let";
        _58 = push_ident_spanned(_59, _38, _60) -> [return: bb27, unwind: bb200];
    }

    bb27: {
        _62 = &mut _44;
        _63 = const "__opts";
        _61 = push_ident_spanned(_62, _38, _63) -> [return: bb28, unwind: bb200];
    }

    bb28: {
        _65 = &mut _44;
        _64 = push_eq_spanned(_65, _38) -> [return: bb29, unwind: bb200];
    }

    bb29: {
        _67 = &mut _44;
        _68 = const "__c";
        _66 = push_ident_spanned(_67, _38, _68) -> [return: bb30, unwind: bb200];
    }

    bb30: {
        _70 = &mut _44;
        _69 = push_dot_spanned(_70, _38) -> [return: bb31, unwind: bb200];
    }

    bb31: {
        _72 = &mut _44;
        _73 = const "__opts";
        _71 = push_ident_spanned(_72, _38, _73) -> [return: bb32, unwind: bb200];
    }

    bb32: {
        _75 = &mut _44;
        _74 = push_semi_spanned(_75, _38) -> [return: bb33, unwind: bb200];
    }

    bb33: {
        _77 = &mut _44;
        _78 = const "__c";
        _76 = push_ident_spanned(_77, _38, _78) -> [return: bb34, unwind: bb200];
    }

    bb34: {
        _80 = &mut _44;
        _79 = push_dot_spanned(_80, _38) -> [return: bb35, unwind: bb200];
    }

    bb35: {
        _82 = &_4;
        _83 = &mut _44;
        _81 = <&proc_macro2::Ident as ToTokens>::to_tokens(_82, _83) -> [return: bb36, unwind: bb200];
    }

    bb36: {
        _85 = &mut _44;
        _84 = push_dot_spanned(_85, _38) -> [return: bb37, unwind: bb200];
    }

    bb37: {
        _87 = &mut _44;
        _88 = const "map_or_else";
        _86 = push_ident_spanned(_87, _38, _88) -> [return: bb38, unwind: bb200];
    }

    bb38: {
        _90 = &mut _44;
        _91 = proc_macro2::Delimiter::Parenthesis;
        _93 = TokenStream2::new() -> [return: bb39, unwind: bb200];
    }

    bb39: {
        _95 = &mut _93;
        _94 = push_or_or_spanned(_95, _38) -> [return: bb40, unwind: bb199];
    }

    bb40: {
        _97 = &_26;
        _98 = &mut _93;
        _96 = <TokenStream2 as ToTokens>::to_tokens(_97, _98) -> [return: bb41, unwind: bb199];
    }

    bb41: {
        _100 = &mut _93;
        _99 = push_dot_spanned(_100, _38) -> [return: bb42, unwind: bb199];
    }

    bb42: {
        _102 = &mut _93;
        _103 = const "ok_or_else";
        _101 = push_ident_spanned(_102, _38, _103) -> [return: bb43, unwind: bb199];
    }

    bb43: {
        _105 = &mut _93;
        _106 = proc_macro2::Delimiter::Parenthesis;
        _108 = TokenStream2::new() -> [return: bb44, unwind: bb199];
    }

    bb44: {
        _110 = &mut _108;
        _109 = push_or_or_spanned(_110, _38) -> [return: bb45, unwind: bb198];
    }

    bb45: {
        _426 = const _;
        _112 = &mut _108;
        _111 = <StaticPath as ToTokens>::to_tokens(_426, _112) -> [return: bb46, unwind: bb198];
    }

    bb46: {
        _114 = &mut _108;
        _113 = push_colon2_spanned(_114, _38) -> [return: bb47, unwind: bb198];
    }

    bb47: {
        _116 = &mut _108;
        _117 = const "ErrorKind";
        _115 = push_ident_spanned(_116, _38, _117) -> [return: bb48, unwind: bb198];
    }

    bb48: {
        _119 = &mut _108;
        _118 = push_colon2_spanned(_119, _38) -> [return: bb49, unwind: bb198];
    }

    bb49: {
        _121 = &mut _108;
        _122 = const "Missing";
        _120 = push_ident_spanned(_121, _38, _122) -> [return: bb50, unwind: bb198];
    }

    bb50: {
        _124 = &mut _108;
        _123 = push_dot_spanned(_124, _38) -> [return: bb51, unwind: bb198];
    }

    bb51: {
        _126 = &mut _108;
        _127 = const "into";
        _125 = push_ident_spanned(_126, _38, _127) -> [return: bb52, unwind: bb198];
    }

    bb52: {
        _129 = &mut _108;
        _130 = proc_macro2::Delimiter::Parenthesis;
        _131 = TokenStream2::new() -> [return: bb53, unwind: bb198];
    }

    bb53: {
        _128 = push_group_spanned(_129, _38, move _130, move _131) -> [return: bb54, unwind: bb198];
    }

    bb54: {
        _107 = move _108;
        _104 = push_group_spanned(_105, _38, move _106, move _107) -> [return: bb55, unwind: bb199];
    }

    bb55: {
        _133 = &mut _93;
        _132 = push_comma_spanned(_133, _38) -> [return: bb56, unwind: bb199];
    }

    bb56: {
        _135 = &mut _93;
        _134 = push_lt_spanned(_135, _38) -> [return: bb57, unwind: bb199];
    }

    bb57: {
        _137 = &_5;
        _138 = &mut _93;
        _136 = <syn::Type as ToTokens>::to_tokens(_137, _138) -> [return: bb58, unwind: bb199];
    }

    bb58: {
        _140 = &mut _93;
        _141 = const "as";
        _139 = push_ident_spanned(_140, _38, _141) -> [return: bb59, unwind: bb199];
    }

    bb59: {
        _425 = const _;
        _143 = &mut _93;
        _142 = <StaticPath as ToTokens>::to_tokens(_425, _143) -> [return: bb60, unwind: bb199];
    }

    bb60: {
        _145 = &mut _93;
        _144 = push_colon2_spanned(_145, _38) -> [return: bb61, unwind: bb199];
    }

    bb61: {
        _147 = &mut _93;
        _148 = const "FromForm";
        _146 = push_ident_spanned(_147, _38, _148) -> [return: bb62, unwind: bb199];
    }

    bb62: {
        _150 = &mut _93;
        _149 = push_lt_spanned(_150, _38) -> [return: bb63, unwind: bb199];
    }

    bb63: {
        _152 = &mut _93;
        _153 = const "'__f";
        _151 = push_lifetime_spanned(_152, _38, _153) -> [return: bb64, unwind: bb199];
    }

    bb64: {
        _155 = &mut _93;
        _154 = push_shr_spanned(_155, _38) -> [return: bb65, unwind: bb199];
    }

    bb65: {
        _157 = &mut _93;
        _156 = push_colon2_spanned(_157, _38) -> [return: bb66, unwind: bb199];
    }

    bb66: {
        _159 = &mut _93;
        _160 = const "finalize";
        _158 = push_ident_spanned(_159, _38, _160) -> [return: bb67, unwind: bb199];
    }

    bb67: {
        _92 = move _93;
        _89 = push_group_spanned(_90, _38, move _91, move _92) -> [return: bb68, unwind: bb200];
    }

    bb68: {
        _162 = &mut _44;
        _161 = push_dot_spanned(_162, _38) -> [return: bb69, unwind: bb200];
    }

    bb69: {
        _164 = &mut _44;
        _165 = const "and_then";
        _163 = push_ident_spanned(_164, _38, _165) -> [return: bb70, unwind: bb200];
    }

    bb70: {
        _167 = &mut _44;
        _168 = proc_macro2::Delimiter::Parenthesis;
        _170 = TokenStream2::new() -> [return: bb71, unwind: bb200];
    }

    bb71: {
        _172 = &mut _170;
        _171 = push_or_spanned(_172, _38) -> [return: bb72, unwind: bb197];
    }

    bb72: {
        _174 = &_4;
        _175 = &mut _170;
        _173 = <&proc_macro2::Ident as ToTokens>::to_tokens(_174, _175) -> [return: bb73, unwind: bb197];
    }

    bb73: {
        _177 = &mut _170;
        _176 = push_or_spanned(_177, _38) -> [return: bb74, unwind: bb197];
    }

    bb74: {
        _179 = &mut _170;
        _180 = proc_macro2::Delimiter::Brace;
        _182 = TokenStream2::new() -> [return: bb75, unwind: bb197];
    }

    bb75: {
        _184 = &mut _182;
        _185 = const "let";
        _183 = push_ident_spanned(_184, _38, _185) -> [return: bb76, unwind: bb196];
    }

    bb76: {
        _187 = &mut _182;
        _188 = const "mut";
        _186 = push_ident_spanned(_187, _38, _188) -> [return: bb77, unwind: bb196];
    }

    bb77: {
        _190 = &mut _182;
        _191 = const "__es";
        _189 = push_ident_spanned(_190, _38, _191) -> [return: bb78, unwind: bb196];
    }

    bb78: {
        _193 = &mut _182;
        _192 = push_eq_spanned(_193, _38) -> [return: bb79, unwind: bb196];
    }

    bb79: {
        _424 = const _;
        _195 = &mut _182;
        _194 = <StaticPath as ToTokens>::to_tokens(_424, _195) -> [return: bb80, unwind: bb196];
    }

    bb80: {
        _197 = &mut _182;
        _196 = push_colon2_spanned(_197, _38) -> [return: bb81, unwind: bb196];
    }

    bb81: {
        _199 = &mut _182;
        _200 = const "Errors";
        _198 = push_ident_spanned(_199, _38, _200) -> [return: bb82, unwind: bb196];
    }

    bb82: {
        _202 = &mut _182;
        _201 = push_colon2_spanned(_202, _38) -> [return: bb83, unwind: bb196];
    }

    bb83: {
        _204 = &mut _182;
        _205 = const "new";
        _203 = push_ident_spanned(_204, _38, _205) -> [return: bb84, unwind: bb196];
    }

    bb84: {
        _207 = &mut _182;
        _208 = proc_macro2::Delimiter::Parenthesis;
        _209 = TokenStream2::new() -> [return: bb85, unwind: bb196];
    }

    bb85: {
        _206 = push_group_spanned(_207, _38, move _208, move _209) -> [return: bb86, unwind: bb196];
    }

    bb86: {
        _211 = &mut _182;
        _210 = push_semi_spanned(_211, _38) -> [return: bb87, unwind: bb196];
    }

    bb87: {
        _214 = &_35;
        _213 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _214) -> [return: bb88, unwind: bb196];
    }

    bb88: {
        _212 = (_213.0: &exports::StaticPath);
        _215 = <ThereIsNoIteratorInRepetition as std::ops::BitOr>::bitor(const ThereIsNoIteratorInRepetition, const ThereIsNoIteratorInRepetition) -> [return: bb89, unwind: bb196];
    }

    bb89: {
        _430 = const false;
        _218 = move _18;
        _217 = <Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _218) -> [return: bb90, unwind: bb196];
    }

    bb90: {
        _429 = move (_217.0: impl std::iter::Iterator<Item = syn::Expr> + '_);
        _216 = move (_429 as subtype Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}>);
        _219 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb211, unwind: bb195];
    }

    bb91: {
        _220 = const true;
        switchInt(move _220) -> [0: bb114, otherwise: bb92];
    }

    bb92: {
        _222 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_212) -> [return: bb93, unwind: bb195];
    }

    bb93: {
        _223 = discriminant(_222);
        switchInt(move _223) -> [0: bb114, 1: bb94, otherwise: bb6];
    }

    bb94: {
        _224 = ((_222 as Some).0: &exports::StaticPath);
        _221 = RepInterp::<&StaticPath>(_224);
        _227 = &mut _216;
        _226 = <Map<Filter<Map<FilterMap<std::vec::IntoIter<form_field::FieldAttr>, {closure@core/codegen/src/derive/form_field.rs:297:21: 297:24}>, {closure@core/codegen/src/derive/form_field.rs:298:14: 298:25}>, {closure@core/codegen/src/derive/form_field.rs:311:17: 311:37}>, {closure@core/codegen/src/derive/form_field.rs:312:14: 312:34}> as Iterator>::next(move _227) -> [return: bb95, unwind: bb195];
    }

    bb95: {
        _228 = discriminant(_226);
        switchInt(move _228) -> [0: bb114, 1: bb96, otherwise: bb6];
    }

    bb96: {
        _229 = move ((_226 as Some).0: syn::Expr);
        _225 = RepInterp::<syn::Expr>(move _229);
        _231 = &mut _182;
        _232 = const "if";
        _230 = push_ident_spanned(_231, _38, _232) -> [return: bb97, unwind: bb194];
    }

    bb97: {
        _234 = &mut _182;
        _235 = const "let";
        _233 = push_ident_spanned(_234, _38, _235) -> [return: bb98, unwind: bb194];
    }

    bb98: {
        _237 = &_221;
        _238 = &mut _182;
        _236 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_237, _238) -> [return: bb99, unwind: bb194];
    }

    bb99: {
        _240 = &mut _182;
        _241 = proc_macro2::Delimiter::Parenthesis;
        _243 = TokenStream2::new() -> [return: bb100, unwind: bb194];
    }

    bb100: {
        _245 = &mut _243;
        _246 = const "__e";
        _244 = push_ident_spanned(_245, _38, _246) -> [return: bb101, unwind: bb193];
    }

    bb101: {
        _242 = move _243;
        _239 = push_group_spanned(_240, _38, move _241, move _242) -> [return: bb102, unwind: bb194];
    }

    bb102: {
        _248 = &mut _182;
        _247 = push_eq_spanned(_248, _38) -> [return: bb103, unwind: bb194];
    }

    bb103: {
        _250 = &_225;
        _251 = &mut _182;
        _249 = <RepInterp<syn::Expr> as ToTokens>::to_tokens(_250, _251) -> [return: bb104, unwind: bb194];
    }

    bb104: {
        _253 = &mut _182;
        _254 = proc_macro2::Delimiter::Brace;
        _256 = TokenStream2::new() -> [return: bb105, unwind: bb194];
    }

    bb105: {
        _258 = &mut _256;
        _259 = const "__es";
        _257 = push_ident_spanned(_258, _38, _259) -> [return: bb106, unwind: bb192];
    }

    bb106: {
        _261 = &mut _256;
        _260 = push_dot_spanned(_261, _38) -> [return: bb107, unwind: bb192];
    }

    bb107: {
        _263 = &mut _256;
        _264 = const "extend";
        _262 = push_ident_spanned(_263, _38, _264) -> [return: bb108, unwind: bb192];
    }

    bb108: {
        _266 = &mut _256;
        _267 = proc_macro2::Delimiter::Parenthesis;
        _269 = TokenStream2::new() -> [return: bb109, unwind: bb192];
    }

    bb109: {
        _271 = &mut _269;
        _272 = const "__e";
        _270 = push_ident_spanned(_271, _38, _272) -> [return: bb110, unwind: bb191];
    }

    bb110: {
        _268 = move _269;
        _265 = push_group_spanned(_266, _38, move _267, move _268) -> [return: bb111, unwind: bb192];
    }

    bb111: {
        _274 = &mut _256;
        _273 = push_semi_spanned(_274, _38) -> [return: bb112, unwind: bb192];
    }

    bb112: {
        _255 = move _256;
        _252 = push_group_spanned(_253, _38, move _254, move _255) -> [return: bb113, unwind: bb194];
    }

    bb113: {
        drop(_225) -> [return: bb91, unwind: bb195];
    }

    bb114: {
        drop(_216) -> [return: bb115, unwind: bb196];
    }

    bb115: {
        _276 = &mut _182;
        _277 = const "__es";
        _275 = push_ident_spanned(_276, _38, _277) -> [return: bb116, unwind: bb196];
    }

    bb116: {
        _279 = &mut _182;
        _278 = push_dot_spanned(_279, _38) -> [return: bb117, unwind: bb196];
    }

    bb117: {
        _281 = &mut _182;
        _282 = const "is_empty";
        _280 = push_ident_spanned(_281, _38, _282) -> [return: bb118, unwind: bb196];
    }

    bb118: {
        _284 = &mut _182;
        _285 = proc_macro2::Delimiter::Parenthesis;
        _286 = TokenStream2::new() -> [return: bb119, unwind: bb196];
    }

    bb119: {
        _283 = push_group_spanned(_284, _38, move _285, move _286) -> [return: bb120, unwind: bb196];
    }

    bb120: {
        _288 = &mut _182;
        _287 = push_dot_spanned(_288, _38) -> [return: bb121, unwind: bb196];
    }

    bb121: {
        _290 = &mut _182;
        _291 = const "then";
        _289 = push_ident_spanned(_290, _38, _291) -> [return: bb122, unwind: bb196];
    }

    bb122: {
        _293 = &mut _182;
        _294 = proc_macro2::Delimiter::Parenthesis;
        _296 = TokenStream2::new() -> [return: bb123, unwind: bb196];
    }

    bb123: {
        _298 = &mut _296;
        _297 = push_or_or_spanned(_298, _38) -> [return: bb124, unwind: bb190];
    }

    bb124: {
        _300 = &_4;
        _301 = &mut _296;
        _299 = <&proc_macro2::Ident as ToTokens>::to_tokens(_300, _301) -> [return: bb125, unwind: bb190];
    }

    bb125: {
        _295 = move _296;
        _292 = push_group_spanned(_293, _38, move _294, move _295) -> [return: bb126, unwind: bb196];
    }

    bb126: {
        _303 = &mut _182;
        _302 = push_dot_spanned(_303, _38) -> [return: bb127, unwind: bb196];
    }

    bb127: {
        _305 = &mut _182;
        _306 = const "ok_or";
        _304 = push_ident_spanned(_305, _38, _306) -> [return: bb128, unwind: bb196];
    }

    bb128: {
        _308 = &mut _182;
        _309 = proc_macro2::Delimiter::Parenthesis;
        _311 = TokenStream2::new() -> [return: bb129, unwind: bb196];
    }

    bb129: {
        _313 = &mut _311;
        _314 = const "__es";
        _312 = push_ident_spanned(_313, _38, _314) -> [return: bb130, unwind: bb189];
    }

    bb130: {
        _310 = move _311;
        _307 = push_group_spanned(_308, _38, move _309, move _310) -> [return: bb131, unwind: bb196];
    }

    bb131: {
        _181 = move _182;
        _178 = push_group_spanned(_179, _38, move _180, move _181) -> [return: bb132, unwind: bb197];
    }

    bb132: {
        _169 = move _170;
        _166 = push_group_spanned(_167, _38, move _168, move _169) -> [return: bb133, unwind: bb200];
    }

    bb133: {
        _316 = &mut _44;
        _315 = push_dot_spanned(_316, _38) -> [return: bb134, unwind: bb200];
    }

    bb134: {
        _318 = &mut _44;
        _319 = const "map_err";
        _317 = push_ident_spanned(_318, _38, _319) -> [return: bb135, unwind: bb200];
    }

    bb135: {
        _321 = &mut _44;
        _322 = proc_macro2::Delimiter::Parenthesis;
        _324 = TokenStream2::new() -> [return: bb136, unwind: bb200];
    }

    bb136: {
        _326 = &mut _324;
        _325 = push_or_spanned(_326, _38) -> [return: bb137, unwind: bb188];
    }

    bb137: {
        _328 = &mut _324;
        _329 = const "__e";
        _327 = push_ident_spanned(_328, _38, _329) -> [return: bb138, unwind: bb188];
    }

    bb138: {
        _331 = &mut _324;
        _330 = push_or_spanned(_331, _38) -> [return: bb139, unwind: bb188];
    }

    bb139: {
        _333 = &mut _324;
        _334 = const "__e";
        _332 = push_ident_spanned(_333, _38, _334) -> [return: bb140, unwind: bb188];
    }

    bb140: {
        _336 = &mut _324;
        _335 = push_dot_spanned(_336, _38) -> [return: bb141, unwind: bb188];
    }

    bb141: {
        _338 = &mut _324;
        _339 = const "with_name";
        _337 = push_ident_spanned(_338, _38, _339) -> [return: bb142, unwind: bb188];
    }

    bb142: {
        _341 = &mut _324;
        _342 = proc_macro2::Delimiter::Parenthesis;
        _344 = TokenStream2::new() -> [return: bb143, unwind: bb188];
    }

    bb143: {
        _346 = &mut _344;
        _347 = const "__name";
        _345 = push_ident_spanned(_346, _38, _347) -> [return: bb144, unwind: bb187];
    }

    bb144: {
        _343 = move _344;
        _340 = push_group_spanned(_341, _38, move _342, move _343) -> [return: bb145, unwind: bb188];
    }

    bb145: {
        _323 = move _324;
        _320 = push_group_spanned(_321, _38, move _322, move _323) -> [return: bb146, unwind: bb200];
    }

    bb146: {
        _349 = &mut _44;
        _348 = push_dot_spanned(_349, _38) -> [return: bb147, unwind: bb200];
    }

    bb147: {
        _351 = &mut _44;
        _352 = const "map_err";
        _350 = push_ident_spanned(_351, _38, _352) -> [return: bb148, unwind: bb200];
    }

    bb148: {
        _354 = &mut _44;
        _355 = proc_macro2::Delimiter::Parenthesis;
        _357 = TokenStream2::new() -> [return: bb149, unwind: bb200];
    }

    bb149: {
        _359 = &mut _357;
        _358 = push_or_spanned(_359, _38) -> [return: bb150, unwind: bb186];
    }

    bb150: {
        _361 = &mut _357;
        _362 = const "__e";
        _360 = push_ident_spanned(_361, _38, _362) -> [return: bb151, unwind: bb186];
    }

    bb151: {
        _364 = &mut _357;
        _363 = push_or_spanned(_364, _38) -> [return: bb152, unwind: bb186];
    }

    bb152: {
        _366 = &mut _357;
        _367 = const "__e";
        _365 = push_ident_spanned(_366, _38, _367) -> [return: bb153, unwind: bb186];
    }

    bb153: {
        _369 = &mut _357;
        _368 = push_dot_spanned(_369, _38) -> [return: bb154, unwind: bb186];
    }

    bb154: {
        _371 = &mut _357;
        _372 = const "is_empty";
        _370 = push_ident_spanned(_371, _38, _372) -> [return: bb155, unwind: bb186];
    }

    bb155: {
        _374 = &mut _357;
        _375 = proc_macro2::Delimiter::Parenthesis;
        _376 = TokenStream2::new() -> [return: bb156, unwind: bb186];
    }

    bb156: {
        _373 = push_group_spanned(_374, _38, move _375, move _376) -> [return: bb157, unwind: bb186];
    }

    bb157: {
        _378 = &mut _357;
        _377 = push_dot_spanned(_378, _38) -> [return: bb158, unwind: bb186];
    }

    bb158: {
        _380 = &mut _357;
        _381 = const "then";
        _379 = push_ident_spanned(_380, _38, _381) -> [return: bb159, unwind: bb186];
    }

    bb159: {
        _383 = &mut _357;
        _384 = proc_macro2::Delimiter::Parenthesis;
        _386 = TokenStream2::new() -> [return: bb160, unwind: bb186];
    }

    bb160: {
        _388 = &mut _386;
        _387 = push_or_or_spanned(_388, _38) -> [return: bb161, unwind: bb185];
    }

    bb161: {
        _423 = const _;
        _390 = &mut _386;
        _389 = <StaticPath as ToTokens>::to_tokens(_423, _390) -> [return: bb162, unwind: bb185];
    }

    bb162: {
        _392 = &mut _386;
        _391 = push_colon2_spanned(_392, _38) -> [return: bb163, unwind: bb185];
    }

    bb163: {
        _394 = &mut _386;
        _395 = const "ErrorKind";
        _393 = push_ident_spanned(_394, _38, _395) -> [return: bb164, unwind: bb185];
    }

    bb164: {
        _397 = &mut _386;
        _396 = push_colon2_spanned(_397, _38) -> [return: bb165, unwind: bb185];
    }

    bb165: {
        _399 = &mut _386;
        _400 = const "Unknown";
        _398 = push_ident_spanned(_399, _38, _400) -> [return: bb166, unwind: bb185];
    }

    bb166: {
        _402 = &mut _386;
        _401 = push_dot_spanned(_402, _38) -> [return: bb167, unwind: bb185];
    }

    bb167: {
        _404 = &mut _386;
        _405 = const "into";
        _403 = push_ident_spanned(_404, _38, _405) -> [return: bb168, unwind: bb185];
    }

    bb168: {
        _407 = &mut _386;
        _408 = proc_macro2::Delimiter::Parenthesis;
        _409 = TokenStream2::new() -> [return: bb169, unwind: bb185];
    }

    bb169: {
        _406 = push_group_spanned(_407, _38, move _408, move _409) -> [return: bb170, unwind: bb185];
    }

    bb170: {
        _385 = move _386;
        _382 = push_group_spanned(_383, _38, move _384, move _385) -> [return: bb171, unwind: bb186];
    }

    bb171: {
        _411 = &mut _357;
        _410 = push_dot_spanned(_411, _38) -> [return: bb172, unwind: bb186];
    }

    bb172: {
        _413 = &mut _357;
        _414 = const "unwrap_or";
        _412 = push_ident_spanned(_413, _38, _414) -> [return: bb173, unwind: bb186];
    }

    bb173: {
        _416 = &mut _357;
        _417 = proc_macro2::Delimiter::Parenthesis;
        _419 = TokenStream2::new() -> [return: bb174, unwind: bb186];
    }

    bb174: {
        _421 = &mut _419;
        _422 = const "__e";
        _420 = push_ident_spanned(_421, _38, _422) -> [return: bb175, unwind: bb184];
    }

    bb175: {
        _418 = move _419;
        _415 = push_group_spanned(_416, _38, move _417, move _418) -> [return: bb176, unwind: bb186];
    }

    bb176: {
        _356 = move _357;
        _353 = push_group_spanned(_354, _38, move _355, move _356) -> [return: bb177, unwind: bb200];
    }

    bb177: {
        _43 = move _44;
        _40 = push_group_spanned(_41, _38, move _42, move _43) -> [return: bb178, unwind: bb201];
    }

    bb178: {
        _36 = move _37;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _36);
        drop(_26) -> [return: bb179, unwind: bb209];
    }

    bb179: {
        _430 = const false;
        drop(_6) -> [return: bb180, unwind: bb204];
    }

    bb180: {
        drop(_5) -> [return: bb183, unwind continue];
    }

    bb181: {
        _430 = const false;
        drop(_6) -> [return: bb182, unwind: bb204];
    }

    bb182: {
        drop(_5) -> [return: bb183, unwind continue];
    }

    bb183: {
        return;
    }

    bb184 (cleanup): {
        drop(_419) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb185 (cleanup): {
        drop(_386) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb186 (cleanup): {
        drop(_357) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb187 (cleanup): {
        drop(_344) -> [return: bb188, unwind terminate(cleanup)];
    }

    bb188 (cleanup): {
        drop(_324) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb189 (cleanup): {
        drop(_311) -> [return: bb196, unwind terminate(cleanup)];
    }

    bb190 (cleanup): {
        drop(_296) -> [return: bb196, unwind terminate(cleanup)];
    }

    bb191 (cleanup): {
        drop(_269) -> [return: bb192, unwind terminate(cleanup)];
    }

    bb192 (cleanup): {
        drop(_256) -> [return: bb194, unwind terminate(cleanup)];
    }

    bb193 (cleanup): {
        drop(_243) -> [return: bb194, unwind terminate(cleanup)];
    }

    bb194 (cleanup): {
        drop(_225) -> [return: bb195, unwind terminate(cleanup)];
    }

    bb195 (cleanup): {
        drop(_216) -> [return: bb196, unwind terminate(cleanup)];
    }

    bb196 (cleanup): {
        drop(_182) -> [return: bb197, unwind terminate(cleanup)];
    }

    bb197 (cleanup): {
        drop(_170) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb198 (cleanup): {
        drop(_108) -> [return: bb199, unwind terminate(cleanup)];
    }

    bb199 (cleanup): {
        drop(_93) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb200 (cleanup): {
        drop(_44) -> [return: bb201, unwind terminate(cleanup)];
    }

    bb201 (cleanup): {
        drop(_37) -> [return: bb202, unwind terminate(cleanup)];
    }

    bb202 (cleanup): {
        drop(_26) -> [return: bb209, unwind terminate(cleanup)];
    }

    bb203 (cleanup): {
        drop(_6) -> [return: bb204, unwind terminate(cleanup)];
    }

    bb204 (cleanup): {
        drop(_5) -> [return: bb207, unwind terminate(cleanup)];
    }

    bb205 (cleanup): {
        drop(_10) -> [return: bb207, unwind terminate(cleanup)];
    }

    bb206 (cleanup): {
        drop(_10) -> [return: bb207, unwind terminate(cleanup)];
    }

    bb207 (cleanup): {
        resume;
    }

    bb208 (cleanup): {
        drop(_18) -> [return: bb203, unwind terminate(cleanup)];
    }

    bb209 (cleanup): {
        switchInt(_430) -> [0: bb203, otherwise: bb208];
    }

    bb210: {
        goto -> bb181;
    }

    bb211: {
        goto -> bb91;
    }
}

promoted[0] in from_form::derive_from_form::{closure#14}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form::derive_from_form::{closure#14}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form::derive_from_form::{closure#14}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in from_form::derive_from_form::{closure#14}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form::derive_from_form::{closure#14}::{closure#0}(_1: {closure@core/codegen/src/derive/from_form.rs:234:37: 234:39}) -> TokenStream2 {
    debug ty => (*(_1.0: &syn::Type));
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let _4: ();
    let mut _5: &mut proc_macro2::TokenStream;
    let mut _6: proc_macro2::Delimiter;
    let mut _7: proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &str;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: &str;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let mut _37: proc_macro2::Delimiter;
    let mut _38: proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: &str;
    let mut _44: &syn::Type;
    let mut _45: &syn::Type;
    scope 1 {
        debug _s => _2;
        let _3: proc_macro2::Span;
        scope 2 {
            debug _span => _3;
            let mut _8: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _8;
                scope 4 {
                    debug _span => _3;
                    let mut _39: proc_macro2::TokenStream;
                    let mut _43: &exports::StaticPath;
                    scope 5 {
                        debug _s => _39;
                        scope 6 {
                            debug _span => _3;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _44 = deref_copy (_1.0: &syn::Type);
        _3 = <syn::Type as devise::Spanned>::span(_44) -> [return: bb2, unwind: bb21];
    }

    bb2: {
        _5 = &mut _2;
        _6 = proc_macro2::Delimiter::Brace;
        _8 = TokenStream2::new() -> [return: bb3, unwind: bb21];
    }

    bb3: {
        _10 = &mut _8;
        _9 = push_lt_spanned(_10, _3) -> [return: bb4, unwind: bb20];
    }

    bb4: {
        _45 = deref_copy (_1.0: &syn::Type);
        _12 = &mut _8;
        _11 = <syn::Type as ToTokens>::to_tokens(_45, _12) -> [return: bb5, unwind: bb20];
    }

    bb5: {
        _14 = &mut _8;
        _15 = const "as";
        _13 = push_ident_spanned(_14, _3, _15) -> [return: bb6, unwind: bb20];
    }

    bb6: {
        _43 = const _;
        _17 = &mut _8;
        _16 = <StaticPath as ToTokens>::to_tokens(_43, _17) -> [return: bb7, unwind: bb20];
    }

    bb7: {
        _19 = &mut _8;
        _18 = push_colon2_spanned(_19, _3) -> [return: bb8, unwind: bb20];
    }

    bb8: {
        _21 = &mut _8;
        _22 = const "FromForm";
        _20 = push_ident_spanned(_21, _3, _22) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _24 = &mut _8;
        _23 = push_lt_spanned(_24, _3) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _26 = &mut _8;
        _27 = const "'__f";
        _25 = push_lifetime_spanned(_26, _3, _27) -> [return: bb11, unwind: bb20];
    }

    bb11: {
        _29 = &mut _8;
        _28 = push_shr_spanned(_29, _3) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        _31 = &mut _8;
        _30 = push_colon2_spanned(_31, _3) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _33 = &mut _8;
        _34 = const "default";
        _32 = push_ident_spanned(_33, _3, _34) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _36 = &mut _8;
        _37 = proc_macro2::Delimiter::Parenthesis;
        _39 = TokenStream2::new() -> [return: bb15, unwind: bb20];
    }

    bb15: {
        _41 = &mut _39;
        _42 = const "__opts";
        _40 = push_ident_spanned(_41, _3, _42) -> [return: bb16, unwind: bb19];
    }

    bb16: {
        _38 = move _39;
        _35 = push_group_spanned(_36, _3, move _37, move _38) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        _7 = move _8;
        _4 = push_group_spanned(_5, _3, move _6, move _7) -> [return: bb18, unwind: bb21];
    }

    bb18: {
        _0 = move _2;
        return;
    }

    bb19 (cleanup): {
        drop(_39) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop(_8) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }
}

promoted[0] in from_form::derive_from_form::{closure#14}::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form_field::derive_from_form_field(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: &mut devise::DeriveGenerator;
    let mut _3: &mut devise::DeriveGenerator;
    let mut _4: &mut devise::DeriveGenerator;
    let mut _5: &mut devise::DeriveGenerator;
    let mut _6: &mut devise::DeriveGenerator;
    let mut _7: devise::DeriveGenerator;
    let mut _8: proc_macro::TokenStream;
    let mut _9: proc_macro2::TokenStream;
    let mut _10: proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let mut _35: devise::ValidatorBuild;
    let mut _36: devise::ValidatorBuild;
    let mut _37: devise::ValidatorBuild;
    let mut _38: proc_macro2::TokenStream;
    let mut _39: proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let mut _44: proc_macro2::Delimiter;
    let mut _45: proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let mut _52: proc_macro2::Delimiter;
    let mut _53: proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: &str;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let mut _75: devise::MapperBuild;
    let mut _76: devise::MapperBuild;
    let mut _77: devise::MapperBuild;
    let mut _78: devise::MapperBuild;
    let mut _81: bool;
    scope 1 {
        debug _s => _10;
        let mut _80: &exports::StaticPath;
    }
    scope 2 {
        debug _s => _39;
        let mut _46: proc_macro2::TokenStream;
        let mut _79: &exports::StaticPath;
        scope 3 {
            debug _s => _46;
            let mut _54: proc_macro2::TokenStream;
            scope 4 {
                debug _s => _54;
            }
        }
    }

    bb0: {
        _81 = const false;
        _81 = const true;
        _8 = move _1;
        _10 = TokenStream2::new() -> [return: bb1, unwind: bb48];
    }

    bb1: {
        _12 = &mut _10;
        _13 = const "impl";
        _11 = push_ident(_12, _13) -> [return: bb2, unwind: bb45];
    }

    bb2: {
        _15 = &mut _10;
        _14 = push_lt(_15) -> [return: bb3, unwind: bb45];
    }

    bb3: {
        _17 = &mut _10;
        _18 = const "'__v";
        _16 = push_lifetime(_17, _18) -> [return: bb4, unwind: bb45];
    }

    bb4: {
        _20 = &mut _10;
        _19 = push_gt(_20) -> [return: bb5, unwind: bb45];
    }

    bb5: {
        _80 = const _;
        _22 = &mut _10;
        _21 = <StaticPath as ToTokens>::to_tokens(_80, _22) -> [return: bb6, unwind: bb45];
    }

    bb6: {
        _24 = &mut _10;
        _23 = push_colon2(_24) -> [return: bb7, unwind: bb45];
    }

    bb7: {
        _26 = &mut _10;
        _27 = const "FromFormField";
        _25 = push_ident(_26, _27) -> [return: bb8, unwind: bb45];
    }

    bb8: {
        _29 = &mut _10;
        _28 = push_lt(_29) -> [return: bb9, unwind: bb45];
    }

    bb9: {
        _31 = &mut _10;
        _32 = const "'__v";
        _30 = push_lifetime(_31, _32) -> [return: bb10, unwind: bb45];
    }

    bb10: {
        _34 = &mut _10;
        _33 = push_gt(_34) -> [return: bb11, unwind: bb45];
    }

    bb11: {
        _9 = move _10;
        _81 = const false;
        _7 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _8, move _9) -> [return: bb12, unwind: bb48];
    }

    bb12: {
        _6 = &mut _7;
        _81 = const false;
        _5 = devise::DeriveGenerator::support(move _6, const _) -> [return: bb13, unwind: bb44];
    }

    bb13: {
        _37 = devise::ValidatorBuild::new() -> [return: bb14, unwind: bb44];
    }

    bb14: {
        _36 = devise::ValidatorBuild::fields_validate::<{closure@core/codegen/src/derive/from_form_field.rs:12:30: 12:41}>(move _37, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:12:30: 12:41}) -> [return: bb15, unwind: bb44];
    }

    bb15: {
        _35 = devise::ValidatorBuild::enum_validate::<{closure@core/codegen/src/derive/from_form_field.rs:19:28: 19:37}>(move _36, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:19:28: 19:37}) -> [return: bb16, unwind: bb44];
    }

    bb16: {
        _4 = devise::DeriveGenerator::validator::<devise::ValidatorBuild>(_5, move _35) -> [return: bb17, unwind: bb44];
    }

    bb17: {
        _39 = TokenStream2::new() -> [return: bb18, unwind: bb44];
    }

    bb18: {
        _41 = &mut _39;
        _40 = push_pound(_41) -> [return: bb19, unwind: bb43];
    }

    bb19: {
        _43 = &mut _39;
        _44 = proc_macro2::Delimiter::Bracket;
        _46 = TokenStream2::new() -> [return: bb20, unwind: bb43];
    }

    bb20: {
        _48 = &mut _46;
        _49 = const "allow";
        _47 = push_ident(_48, _49) -> [return: bb21, unwind: bb42];
    }

    bb21: {
        _51 = &mut _46;
        _52 = proc_macro2::Delimiter::Parenthesis;
        _54 = TokenStream2::new() -> [return: bb22, unwind: bb42];
    }

    bb22: {
        _56 = &mut _54;
        _57 = const "unused_imports";
        _55 = push_ident(_56, _57) -> [return: bb23, unwind: bb41];
    }

    bb23: {
        _53 = move _54;
        _50 = push_group(_51, move _52, move _53) -> [return: bb24, unwind: bb42];
    }

    bb24: {
        _45 = move _46;
        _42 = push_group(_43, move _44, move _45) -> [return: bb25, unwind: bb43];
    }

    bb25: {
        _59 = &mut _39;
        _60 = const "use";
        _58 = push_ident(_59, _60) -> [return: bb26, unwind: bb43];
    }

    bb26: {
        _79 = const _;
        _62 = &mut _39;
        _61 = <StaticPath as ToTokens>::to_tokens(_79, _62) -> [return: bb27, unwind: bb43];
    }

    bb27: {
        _64 = &mut _39;
        _63 = push_colon2(_64) -> [return: bb28, unwind: bb43];
    }

    bb28: {
        _66 = &mut _39;
        _67 = const "uncased";
        _65 = push_ident(_66, _67) -> [return: bb29, unwind: bb43];
    }

    bb29: {
        _69 = &mut _39;
        _68 = push_colon2(_69) -> [return: bb30, unwind: bb43];
    }

    bb30: {
        _71 = &mut _39;
        _72 = const "AsUncased";
        _70 = push_ident(_71, _72) -> [return: bb31, unwind: bb43];
    }

    bb31: {
        _74 = &mut _39;
        _73 = push_semi(_74) -> [return: bb32, unwind: bb43];
    }

    bb32: {
        _38 = move _39;
        _3 = devise::DeriveGenerator::outer_mapper::<TokenStream2>(_4, move _38) -> [return: bb33, unwind: bb44];
    }

    bb33: {
        _78 = devise::MapperBuild::new() -> [return: bb34, unwind: bb44];
    }

    bb34: {
        _77 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/from_form_field.rs:47:26: 47:37}>(move _78, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:47:26: 47:37}) -> [return: bb35, unwind: bb44];
    }

    bb35: {
        _76 = devise::MapperBuild::try_enum_map::<{closure@core/codegen/src/derive/from_form_field.rs:55:27: 55:41}>(move _77, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:55:27: 55:41}) -> [return: bb36, unwind: bb44];
    }

    bb36: {
        _75 = devise::MapperBuild::try_variant_map::<{closure@core/codegen/src/derive/from_form_field.rs:79:30: 79:42}>(move _76, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:79:30: 79:42}) -> [return: bb37, unwind: bb44];
    }

    bb37: {
        _2 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_3, move _75) -> [return: bb38, unwind: bb44];
    }

    bb38: {
        _0 = devise::DeriveGenerator::to_tokens::<TokenStream2>(_2) -> [return: bb39, unwind: bb44];
    }

    bb39: {
        drop(_7) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_54) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_46) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_39) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_7) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_10) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        resume;
    }

    bb47 (cleanup): {
        drop(_8) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_81) -> [0: bb46, otherwise: bb47];
    }
}

promoted[0] in from_form_field::derive_from_form_field: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form_field::derive_from_form_field: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:12:30: 12:41}, _2: &mut devise::ValidatorBuild, _3: devise::Fields<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: devise::Fields<'_>;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro2::Span;
    let mut _8: &devise::Fields<'_>;

    bb0: {
        _5 = _3;
        _4 = devise::Fields::<'_>::is_empty(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb6;
    }

    bb3: {
        _8 = &_3;
        _7 = <devise::Fields<'_> as devise::Spanned>::span(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _7, const "variants cannot have fields") -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _6);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#1}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:19:28: 19:37}, _2: &mut devise::ValidatorBuild, _3: Derived<'_, ItemEnum>) -> std::result::Result<(), devise::Diagnostic> {
    debug data => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: &syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>;
    let _6: &syn::ItemEnum;
    let mut _7: &devise::Derived<'_, syn::ItemEnum>;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: &devise::Derived<'_, syn::ItemEnum>;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>>;
    let mut _12: std::result::Result<std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic>;
    let mut _13: std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>;
    let mut _14: devise::Derived<'_, syn::ItemEnum>;
    let mut _15: isize;
    let mut _18: isize;
    let mut _26: bool;
    let mut _27: devise::Diagnostic;
    let mut _28: devise::Diagnostic;
    let mut _29: devise::Diagnostic;
    let mut _30: devise::Diagnostic;
    let mut _31: devise::Diagnostic;
    let mut _32: devise::Diagnostic;
    scope 1 {
        debug d => _19;
        let _16: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _17: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>;
        let _19: ((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span));
        let _20: usize;
        let _21: proc_macro2::Span;
        let _22: proc_macro2::Span;
        scope 2 {
            debug residual => _16;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _17;
            scope 5 {
            }
        }
        scope 6 {
            debug variant_a_i => _20;
            debug variant_a => _21;
            debug value_a => _22;
            let _23: usize;
            let _24: proc_macro2::Span;
            let _25: proc_macro2::Span;
            scope 7 {
                debug variant_b_i => _23;
                debug variant_b => _24;
                debug value_b => _25;
            }
        }
    }

    bb0: {
        _7 = &_3;
        _6 = <Derived<'_, ItemEnum> as std::ops::Deref>::deref(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_6).6: syn::punctuated::Punctuated<syn::Variant, syn::token::Comma>);
        _4 = syn::punctuated::Punctuated::<syn::Variant, syn::token::Comma>::is_empty(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _10 = &_3;
        _9 = <Derived<'_, ItemEnum> as devise::Spanned>::span(move _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _9, const "enum must have at least one variant") -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _8);
        goto -> bb23;
    }

    bb6: {
        _14 = _3;
        _13 = Derived::<'_, ItemEnum>::variants(move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = form_field::first_duplicate::<Derived<'_, syn::Variant, Derived<'_, ItemEnum>>, FieldName, Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:24:67: 24:70}>(move _13, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:24:67: 24:70}) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = <std::result::Result<Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>, devise::Diagnostic> as std::ops::Try>::branch(move _12) -> [return: bb9, unwind continue];
    }

    bb9: {
        _15 = discriminant(_11);
        switchInt(move _15) -> [0: bb10, 1: bb12, otherwise: bb11];
    }

    bb10: {
        _17 = ((_11 as Continue).0: std::option::Option<((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span))>);
        _18 = discriminant(_17);
        switchInt(move _18) -> [1: bb14, otherwise: bb13];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _16 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<(), devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _16) -> [return: bb23, unwind continue];
    }

    bb13: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb23;
    }

    bb14: {
        _19 = ((_17 as Some).0: ((usize, proc_macro2::Span, proc_macro2::Span), (usize, proc_macro2::Span, proc_macro2::Span)));
        _20 = ((_19.0: (usize, proc_macro2::Span, proc_macro2::Span)).0: usize);
        _21 = ((_19.0: (usize, proc_macro2::Span, proc_macro2::Span)).1: proc_macro2::Span);
        _22 = ((_19.0: (usize, proc_macro2::Span, proc_macro2::Span)).2: proc_macro2::Span);
        _23 = ((_19.1: (usize, proc_macro2::Span, proc_macro2::Span)).0: usize);
        _24 = ((_19.1: (usize, proc_macro2::Span, proc_macro2::Span)).1: proc_macro2::Span);
        _25 = ((_19.1: (usize, proc_macro2::Span, proc_macro2::Span)).2: proc_macro2::Span);
        _26 = Eq(_20, _23);
        switchInt(move _26) -> [0: bb19, otherwise: bb15];
    }

    bb15: {
        _29 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_21, const "variant has conflicting values") -> [return: bb16, unwind continue];
    }

    bb16: {
        _28 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _29, _22, const "this value...") -> [return: bb17, unwind continue];
    }

    bb17: {
        _27 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _28, _25, const "...conflicts with this value") -> [return: bb18, unwind continue];
    }

    bb18: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _27);
        goto -> bb23;
    }

    bb19: {
        _32 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_25, const "field value conflicts with previous value") -> [return: bb20, unwind continue];
    }

    bb20: {
        _31 = devise::Diagnostic::span_help::<proc_macro2::Span, &str>(move _32, _24, const "...declared in this variant") -> [return: bb21, unwind continue];
    }

    bb21: {
        _30 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _31, _21, const "previous field with conflicting name") -> [return: bb22, unwind continue];
    }

    bb22: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _30);
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#1}::{closure#0}(_1: &{closure@core/codegen/src/derive/from_form_field.rs:24:67: 24:70}, _2: &Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<Vec<FieldName>, devise::Diagnostic> {
    debug v => _2;
    let mut _0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;

    bb0: {
        _0 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as VariantExt>::form_field_values(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#2}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:47:26: 47:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: &str;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: &str;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let mut _63: proc_macro2::Delimiter;
    let mut _64: proc_macro2::TokenStream;
    let _66: ();
    let _67: &proc_macro2::TokenStream;
    let mut _68: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _65: proc_macro2::TokenStream;
        let mut _69: &exports::StaticPath;
        scope 2 {
            debug _s => _15;
            let mut _70: &exports::StaticPath;
        }
        scope 3 {
            debug _s => _65;
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb32];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "from_value";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _17 = &mut _15;
        _18 = const "__f";
        _16 = push_ident(_17, _18) -> [return: bb5, unwind: bb30];
    }

    bb5: {
        _20 = &mut _15;
        _19 = push_colon(_20) -> [return: bb6, unwind: bb30];
    }

    bb6: {
        _70 = const _;
        _22 = &mut _15;
        _21 = <StaticPath as ToTokens>::to_tokens(_70, _22) -> [return: bb7, unwind: bb30];
    }

    bb7: {
        _24 = &mut _15;
        _23 = push_colon2(_24) -> [return: bb8, unwind: bb30];
    }

    bb8: {
        _26 = &mut _15;
        _27 = const "ValueField";
        _25 = push_ident(_26, _27) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _29 = &mut _15;
        _28 = push_lt(_29) -> [return: bb10, unwind: bb30];
    }

    bb10: {
        _31 = &mut _15;
        _32 = const "'__v";
        _30 = push_lifetime(_31, _32) -> [return: bb11, unwind: bb30];
    }

    bb11: {
        _34 = &mut _15;
        _33 = push_gt(_34) -> [return: bb12, unwind: bb30];
    }

    bb12: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _36 = &mut _4;
        _35 = push_rarrow(_36) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _38 = &mut _4;
        _39 = const "Result";
        _37 = push_ident(_38, _39) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _41 = &mut _4;
        _40 = push_lt(_41) -> [return: bb16, unwind: bb31];
    }

    bb16: {
        _43 = &mut _4;
        _44 = const "Self";
        _42 = push_ident(_43, _44) -> [return: bb17, unwind: bb31];
    }

    bb17: {
        _46 = &mut _4;
        _45 = push_comma(_46) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        _69 = const _;
        _48 = &mut _4;
        _47 = <StaticPath as ToTokens>::to_tokens(_69, _48) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        _50 = &mut _4;
        _49 = push_colon2(_50) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _52 = &mut _4;
        _53 = const "Errors";
        _51 = push_ident(_52, _53) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        _55 = &mut _4;
        _54 = push_lt(_55) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _57 = &mut _4;
        _58 = const "'__v";
        _56 = push_lifetime(_57, _58) -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _60 = &mut _4;
        _59 = push_shr(_60) -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _62 = &mut _4;
        _63 = proc_macro2::Delimiter::Brace;
        _65 = TokenStream2::new() -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _67 = &_3;
        _68 = &mut _65;
        _66 = <TokenStream2 as ToTokens>::to_tokens(_67, _68) -> [return: bb26, unwind: bb29];
    }

    bb26: {
        _64 = move _65;
        _61 = push_group(_62, move _63, move _64) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _0 = move _4;
        drop(_3) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_65) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_15) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_4) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_3) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }
}

promoted[0] in from_form_field::derive_from_form_field::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form_field::derive_from_form_field::{closure#2}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#3}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:55:27: 55:41}, _2: &mut devise::MapperBuild, _3: Derived<'_, ItemEnum>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug data => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _4: std::vec::Vec<derive::form_field::FieldName>;
    let mut _5: std::iter::Map<std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}>;
    let mut _6: std::iter::Map<std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}>;
    let mut _7: std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>;
    let mut _9: std::option::Option<std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>>;
    let mut _10: &mut std::iter::Map<std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}>;
    let mut _11: isize;
    let _13: ();
    let mut _14: &mut std::vec::Vec<derive::form_field::FieldName>;
    let mut _15: &mut std::vec::Vec<derive::form_field::FieldName>;
    let mut _16: std::vec::Vec<derive::form_field::FieldName>;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldName>>;
    let mut _18: isize;
    let mut _22: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<proc_macro2::TokenStream>>;
    let mut _23: std::result::Result<std::vec::Vec<proc_macro2::TokenStream>, devise::Diagnostic>;
    let mut _24: std::iter::Map<std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29}>;
    let mut _25: std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>;
    let mut _26: {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29};
    let mut _27: &mut &mut devise::MapperBuild;
    let mut _28: isize;
    let mut _33: (std::iter::Repeat<exports::StaticPath>, std::iter::Repeat<exports::StaticPath>);
    let mut _34: std::iter::Repeat<exports::StaticPath>;
    let mut _35: std::iter::Repeat<exports::StaticPath>;
    let mut _36: proc_macro2::TokenStream;
    let mut _39: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _40: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _42: bool;
    let mut _44: std::option::Option<&proc_macro2::TokenStream>;
    let mut _45: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _46: isize;
    let _48: ();
    let _49: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: &str;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let mut _66: proc_macro2::Delimiter;
    let mut _67: proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: &str;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: &str;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let mut _89: proc_macro2::Delimiter;
    let mut _90: proc_macro2::TokenStream;
    let mut _94: (std::iter::Repeat<exports::StaticPath>, quote::__private::HasIterator);
    let mut _97: (std::slice::Iter<'_, derive::form_field::FieldName>, quote::__private::HasIterator);
    let mut _98: &std::vec::Vec<derive::form_field::FieldName>;
    let mut _100: bool;
    let mut _102: std::option::Option<exports::StaticPath>;
    let mut _103: &mut std::iter::Repeat<exports::StaticPath>;
    let mut _104: isize;
    let mut _107: std::option::Option<&derive::form_field::FieldName>;
    let mut _108: &mut std::slice::Iter<'_, derive::form_field::FieldName>;
    let mut _109: isize;
    let mut _111: bool;
    let mut _112: usize;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let mut _115: (usize, bool);
    let _116: ();
    let _117: &quote::__private::RepInterp<exports::StaticPath>;
    let mut _118: &mut proc_macro2::TokenStream;
    let _119: ();
    let mut _120: &mut proc_macro2::TokenStream;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: &str;
    let _124: ();
    let mut _125: &mut proc_macro2::TokenStream;
    let mut _126: proc_macro2::Delimiter;
    let mut _127: proc_macro2::TokenStream;
    let _129: ();
    let _130: &quote::__private::RepInterp<&derive::form_field::FieldName>;
    let mut _131: &mut proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: &str;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: &str;
    let _140: ();
    let mut _141: &mut proc_macro2::TokenStream;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: ();
    let mut _152: &mut proc_macro2::TokenStream;
    let _153: &str;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let mut _156: proc_macro2::Delimiter;
    let mut _157: proc_macro2::TokenStream;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: &str;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: ();
    let mut _165: &mut proc_macro2::TokenStream;
    let _166: &str;
    let _167: ();
    let mut _168: &mut proc_macro2::TokenStream;
    let mut _169: proc_macro2::Delimiter;
    let mut _170: proc_macro2::TokenStream;
    let _172: ();
    let mut _173: &mut proc_macro2::TokenStream;
    let _174: &str;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: &str;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let _182: ();
    let mut _183: &mut proc_macro2::TokenStream;
    let _184: &str;
    let _185: ();
    let mut _186: &mut proc_macro2::TokenStream;
    let mut _187: proc_macro2::Delimiter;
    let mut _188: proc_macro2::TokenStream;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let _192: &str;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: &str;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let _200: ();
    let mut _201: &mut proc_macro2::TokenStream;
    let _202: ();
    let mut _203: &mut proc_macro2::TokenStream;
    let mut _204: proc_macro2::Delimiter;
    let mut _205: proc_macro2::TokenStream;
    let _207: ();
    let mut _208: &mut proc_macro2::TokenStream;
    let _209: &str;
    let _210: ();
    let mut _211: &mut proc_macro2::TokenStream;
    scope 1 {
        debug variant_value => _4;
        let mut _8: std::iter::Map<std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}>;
        let _21: std::vec::Vec<proc_macro2::TokenStream>;
        let _29: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _30: std::vec::Vec<proc_macro2::TokenStream>;
        scope 2 {
            debug iter => _8;
            let _12: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
            scope 3 {
                debug v => _12;
                let _19: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _20: std::vec::Vec<derive::form_field::FieldName>;
                scope 4 {
                    debug residual => _19;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => _20;
                    scope 7 {
                    }
                }
            }
        }
        scope 8 {
            debug variant_condition => _21;
            let _31: std::iter::Repeat<exports::StaticPath>;
            let _32: std::iter::Repeat<exports::StaticPath>;
            scope 13 {
                debug _ok => _31;
                debug _cow => _32;
                let mut _37: proc_macro2::TokenStream;
                scope 14 {
                    debug _s => _37;
                    let mut _68: proc_macro2::TokenStream;
                    let mut _91: proc_macro2::TokenStream;
                    let mut _158: proc_macro2::TokenStream;
                    let mut _171: proc_macro2::TokenStream;
                    let mut _189: proc_macro2::TokenStream;
                    let mut _206: proc_macro2::TokenStream;
                    let mut _212: &exports::StaticPath;
                    let mut _213: &exports::StaticPath;
                    scope 15 {
                        debug has_iter => const ThereIsNoIteratorInRepetition;
                        scope 16 {
                            debug variant_condition => _38;
                            debug i => const HasIterator;
                            let _41: quote::__private::HasIterator;
                            scope 18 {
                                debug has_iter => const HasIterator;
                                scope 19 {
                                    let _43: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                    let _47: &proc_macro2::TokenStream;
                                    scope 20 {
                                        debug variant_condition => _43;
                                    }
                                    scope 21 {
                                        debug _x => _47;
                                    }
                                }
                            }
                        }
                        scope 17 {
                            let mut _38: std::slice::Iter<'_, proc_macro2::TokenStream>;
                        }
                    }
                    scope 22 {
                        debug _s => _68;
                        let mut _214: &exports::StaticPath;
                    }
                    scope 23 {
                        debug _s => _91;
                        let mut _92: usize;
                        scope 24 {
                            debug _i => _92;
                            scope 25 {
                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                scope 26 {
                                    debug _cow => _93;
                                    debug i => const HasIterator;
                                    let _95: quote::__private::HasIterator;
                                    scope 28 {
                                        debug has_iter => const HasIterator;
                                        scope 29 {
                                            debug variant_value => _96;
                                            debug i => const HasIterator;
                                            let _99: quote::__private::HasIterator;
                                            scope 31 {
                                                debug has_iter => const HasIterator;
                                                scope 32 {
                                                    let _101: quote::__private::RepInterp<exports::StaticPath>;
                                                    let _105: exports::StaticPath;
                                                    scope 33 {
                                                        debug _cow => _101;
                                                        let _106: quote::__private::RepInterp<&derive::form_field::FieldName>;
                                                        let _110: &derive::form_field::FieldName;
                                                        scope 35 {
                                                            debug variant_value => _106;
                                                            let mut _128: proc_macro2::TokenStream;
                                                            scope 37 {
                                                                debug _s => _128;
                                                            }
                                                        }
                                                        scope 36 {
                                                            debug _x => _110;
                                                        }
                                                    }
                                                    scope 34 {
                                                        debug _x => _105;
                                                    }
                                                }
                                            }
                                        }
                                        scope 30 {
                                            let mut _96: std::slice::Iter<'_, derive::form_field::FieldName>;
                                        }
                                    }
                                }
                                scope 27 {
                                    let mut _93: std::iter::Repeat<exports::StaticPath>;
                                }
                            }
                        }
                    }
                    scope 38 {
                        debug _s => _158;
                    }
                    scope 39 {
                        debug _s => _171;
                    }
                    scope 40 {
                        debug _s => _189;
                    }
                    scope 41 {
                        debug _s => _206;
                    }
                }
            }
        }
        scope 9 {
            debug residual => _29;
            scope 10 {
            }
        }
        scope 11 {
            debug val => _30;
            scope 12 {
            }
        }
    }

    bb0: {
        _4 = Vec::<FieldName>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Derived::<'_, ItemEnum>::variants(_3) -> [return: bb2, unwind: bb112];
    }

    bb2: {
        _6 = <Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}> as Iterator>::map::<std::result::Result<Vec<FieldName>, devise::Diagnostic>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}>(move _7, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}) -> [return: bb3, unwind: bb112];
    }

    bb3: {
        _5 = <Map<Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}> as IntoIterator>::into_iter(move _6) -> [return: bb4, unwind: bb112];
    }

    bb4: {
        _8 = move _5;
        goto -> bb5;
    }

    bb5: {
        _10 = &mut _8;
        _9 = <Map<Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}> as Iterator>::next(_10) -> [return: bb6, unwind: bb111];
    }

    bb6: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb9, 1: bb7, otherwise: bb8];
    }

    bb7: {
        _12 = move ((_9 as Some).0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>);
        _14 = &mut _4;
        _17 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _12) -> [return: bb10, unwind: bb111];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        drop(_8) -> [return: bb15, unwind: bb112];
    }

    bb10: {
        _18 = discriminant(_17);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb8];
    }

    bb11: {
        _20 = move ((_17 as Continue).0: std::vec::Vec<derive::form_field::FieldName>);
        _16 = move _20;
        _15 = &mut _16;
        _13 = Vec::<FieldName>::append(move _14, _15) -> [return: bb14, unwind: bb110];
    }

    bb12: {
        _19 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _19) -> [return: bb13, unwind: bb111];
    }

    bb13: {
        drop(_8) -> [return: bb99, unwind: bb112];
    }

    bb14: {
        drop(_16) -> [return: bb5, unwind: bb111];
    }

    bb15: {
        _25 = Derived::<'_, ItemEnum>::variants(_3) -> [return: bb16, unwind: bb112];
    }

    bb16: {
        _27 = &mut _2;
        _26 = {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29} { mapper: move _27 };
        _24 = <Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}> as Iterator>::map::<std::result::Result<TokenStream2, devise::Diagnostic>, {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29}>(move _25, move _26) -> [return: bb17, unwind: bb112];
    }

    bb17: {
        _23 = <Map<Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}>, {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29}> as Iterator>::collect::<std::result::Result<Vec<TokenStream2>, devise::Diagnostic>>(move _24) -> [return: bb18, unwind: bb112];
    }

    bb18: {
        _22 = <std::result::Result<Vec<TokenStream2>, devise::Diagnostic> as std::ops::Try>::branch(move _23) -> [return: bb19, unwind: bb112];
    }

    bb19: {
        _28 = discriminant(_22);
        switchInt(move _28) -> [0: bb20, 1: bb21, otherwise: bb8];
    }

    bb20: {
        _30 = move ((_22 as Continue).0: std::vec::Vec<proc_macro2::TokenStream>);
        _21 = move _30;
        _34 = std::iter::repeat::<StaticPath>(const _) -> [return: bb22, unwind: bb109];
    }

    bb21: {
        _29 = move ((_22 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _29) -> [return: bb114, unwind: bb112];
    }

    bb22: {
        _35 = std::iter::repeat::<StaticPath>(const _) -> [return: bb23, unwind: bb109];
    }

    bb23: {
        _33 = (move _34, move _35);
        _31 = move (_33.0: std::iter::Repeat<exports::StaticPath>);
        _32 = move (_33.1: std::iter::Repeat<exports::StaticPath>);
        _37 = TokenStream2::new() -> [return: bb24, unwind: bb109];
    }

    bb24: {
        _40 = &_21;
        _39 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _40) -> [return: bb25, unwind: bb108];
    }

    bb25: {
        _38 = move (_39.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _41 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb115, unwind: bb108];
    }

    bb26: {
        _42 = const true;
        switchInt(move _42) -> [0: bb30, otherwise: bb27];
    }

    bb27: {
        _45 = &mut _38;
        _44 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _45) -> [return: bb28, unwind: bb108];
    }

    bb28: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb30, 1: bb29, otherwise: bb8];
    }

    bb29: {
        _47 = ((_44 as Some).0: &proc_macro2::TokenStream);
        _43 = RepInterp::<&TokenStream2>(_47);
        _49 = &_43;
        _50 = &mut _37;
        _48 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_49, _50) -> [return: bb116, unwind: bb108];
    }

    bb30: {
        _52 = &mut _37;
        _53 = const "const";
        _51 = push_ident(_52, _53) -> [return: bb31, unwind: bb108];
    }

    bb31: {
        _55 = &mut _37;
        _56 = const "OPTS";
        _54 = push_ident(_55, _56) -> [return: bb32, unwind: bb108];
    }

    bb32: {
        _58 = &mut _37;
        _57 = push_colon(_58) -> [return: bb33, unwind: bb108];
    }

    bb33: {
        _60 = &mut _37;
        _59 = push_and(_60) -> [return: bb34, unwind: bb108];
    }

    bb34: {
        _62 = &mut _37;
        _63 = const "'static";
        _61 = push_lifetime(_62, _63) -> [return: bb35, unwind: bb108];
    }

    bb35: {
        _65 = &mut _37;
        _66 = proc_macro2::Delimiter::Bracket;
        _68 = TokenStream2::new() -> [return: bb36, unwind: bb108];
    }

    bb36: {
        _214 = const _;
        _70 = &mut _68;
        _69 = <StaticPath as ToTokens>::to_tokens(_214, _70) -> [return: bb37, unwind: bb107];
    }

    bb37: {
        _72 = &mut _68;
        _71 = push_lt(_72) -> [return: bb38, unwind: bb107];
    }

    bb38: {
        _74 = &mut _68;
        _75 = const "'static";
        _73 = push_lifetime(_74, _75) -> [return: bb39, unwind: bb107];
    }

    bb39: {
        _77 = &mut _68;
        _76 = push_comma(_77) -> [return: bb40, unwind: bb107];
    }

    bb40: {
        _79 = &mut _68;
        _80 = const "str";
        _78 = push_ident(_79, _80) -> [return: bb41, unwind: bb107];
    }

    bb41: {
        _82 = &mut _68;
        _81 = push_gt(_82) -> [return: bb42, unwind: bb107];
    }

    bb42: {
        _67 = move _68;
        _64 = push_group(_65, move _66, move _67) -> [return: bb43, unwind: bb108];
    }

    bb43: {
        _84 = &mut _37;
        _83 = push_eq(_84) -> [return: bb44, unwind: bb108];
    }

    bb44: {
        _86 = &mut _37;
        _85 = push_and(_86) -> [return: bb45, unwind: bb108];
    }

    bb45: {
        _88 = &mut _37;
        _89 = proc_macro2::Delimiter::Bracket;
        _91 = TokenStream2::new() -> [return: bb46, unwind: bb108];
    }

    bb46: {
        _92 = const 0_usize;
        _94 = <std::iter::Repeat<StaticPath> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _32) -> [return: bb47, unwind: bb106];
    }

    bb47: {
        _93 = move (_94.0: std::iter::Repeat<exports::StaticPath>);
        _95 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb48, unwind: bb106];
    }

    bb48: {
        _98 = &_4;
        _97 = <Vec<FieldName> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _98) -> [return: bb49, unwind: bb106];
    }

    bb49: {
        _96 = move (_97.0: std::slice::Iter<'_, derive::form_field::FieldName>);
        _99 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb117, unwind: bb106];
    }

    bb50: {
        _100 = const true;
        switchInt(move _100) -> [0: bb64, otherwise: bb51];
    }

    bb51: {
        _103 = &mut _93;
        _102 = <std::iter::Repeat<StaticPath> as Iterator>::next(move _103) -> [return: bb52, unwind: bb106];
    }

    bb52: {
        _104 = discriminant(_102);
        switchInt(move _104) -> [0: bb64, 1: bb53, otherwise: bb8];
    }

    bb53: {
        _105 = ((_102 as Some).0: exports::StaticPath);
        _101 = RepInterp::<StaticPath>(_105);
        _108 = &mut _96;
        _107 = <std::slice::Iter<'_, FieldName> as Iterator>::next(move _108) -> [return: bb54, unwind: bb106];
    }

    bb54: {
        _109 = discriminant(_107);
        switchInt(move _109) -> [0: bb64, 1: bb55, otherwise: bb8];
    }

    bb55: {
        _110 = ((_107 as Some).0: &derive::form_field::FieldName);
        _106 = RepInterp::<&FieldName>(_110);
        _112 = _92;
        _111 = Gt(move _112, const 0_usize);
        switchInt(move _111) -> [0: bb57, otherwise: bb56];
    }

    bb56: {
        _114 = &mut _91;
        _113 = push_comma(_114) -> [return: bb118, unwind: bb106];
    }

    bb57: {
        _115 = CheckedAdd(_92, const 1_usize);
        assert(!move (_115.1: bool), "attempt to compute `{} + {}`, which would overflow", _92, const 1_usize) -> [success: bb58, unwind: bb106];
    }

    bb58: {
        _92 = move (_115.0: usize);
        _117 = &_101;
        _118 = &mut _91;
        _116 = <RepInterp<StaticPath> as ToTokens>::to_tokens(_117, _118) -> [return: bb59, unwind: bb106];
    }

    bb59: {
        _120 = &mut _91;
        _119 = push_colon2(_120) -> [return: bb60, unwind: bb106];
    }

    bb60: {
        _122 = &mut _91;
        _123 = const "Borrowed";
        _121 = push_ident(_122, _123) -> [return: bb61, unwind: bb106];
    }

    bb61: {
        _125 = &mut _91;
        _126 = proc_macro2::Delimiter::Parenthesis;
        _128 = TokenStream2::new() -> [return: bb62, unwind: bb106];
    }

    bb62: {
        _130 = &_106;
        _131 = &mut _128;
        _129 = <RepInterp<&FieldName> as ToTokens>::to_tokens(_130, _131) -> [return: bb63, unwind: bb105];
    }

    bb63: {
        _127 = move _128;
        _124 = push_group(_125, move _126, move _127) -> [return: bb119, unwind: bb106];
    }

    bb64: {
        _90 = move _91;
        _87 = push_group(_88, move _89, move _90) -> [return: bb65, unwind: bb108];
    }

    bb65: {
        _133 = &mut _37;
        _132 = push_semi(_133) -> [return: bb66, unwind: bb108];
    }

    bb66: {
        _135 = &mut _37;
        _136 = const "let";
        _134 = push_ident(_135, _136) -> [return: bb67, unwind: bb108];
    }

    bb67: {
        _138 = &mut _37;
        _139 = const "_error";
        _137 = push_ident(_138, _139) -> [return: bb68, unwind: bb108];
    }

    bb68: {
        _141 = &mut _37;
        _140 = push_eq(_141) -> [return: bb69, unwind: bb108];
    }

    bb69: {
        _213 = const _;
        _143 = &mut _37;
        _142 = <StaticPath as ToTokens>::to_tokens(_213, _143) -> [return: bb70, unwind: bb108];
    }

    bb70: {
        _145 = &mut _37;
        _144 = push_colon2(_145) -> [return: bb71, unwind: bb108];
    }

    bb71: {
        _147 = &mut _37;
        _148 = const "Error";
        _146 = push_ident(_147, _148) -> [return: bb72, unwind: bb108];
    }

    bb72: {
        _150 = &mut _37;
        _149 = push_colon2(_150) -> [return: bb73, unwind: bb108];
    }

    bb73: {
        _152 = &mut _37;
        _153 = const "from";
        _151 = push_ident(_152, _153) -> [return: bb74, unwind: bb108];
    }

    bb74: {
        _155 = &mut _37;
        _156 = proc_macro2::Delimiter::Parenthesis;
        _158 = TokenStream2::new() -> [return: bb75, unwind: bb108];
    }

    bb75: {
        _160 = &mut _158;
        _161 = const "OPTS";
        _159 = push_ident(_160, _161) -> [return: bb76, unwind: bb104];
    }

    bb76: {
        _157 = move _158;
        _154 = push_group(_155, move _156, move _157) -> [return: bb77, unwind: bb108];
    }

    bb77: {
        _163 = &mut _37;
        _162 = push_dot(_163) -> [return: bb78, unwind: bb108];
    }

    bb78: {
        _165 = &mut _37;
        _166 = const "with_name";
        _164 = push_ident(_165, _166) -> [return: bb79, unwind: bb108];
    }

    bb79: {
        _168 = &mut _37;
        _169 = proc_macro2::Delimiter::Parenthesis;
        _171 = TokenStream2::new() -> [return: bb80, unwind: bb108];
    }

    bb80: {
        _173 = &mut _171;
        _174 = const "__f";
        _172 = push_ident(_173, _174) -> [return: bb81, unwind: bb103];
    }

    bb81: {
        _176 = &mut _171;
        _175 = push_dot(_176) -> [return: bb82, unwind: bb103];
    }

    bb82: {
        _178 = &mut _171;
        _179 = const "name";
        _177 = push_ident(_178, _179) -> [return: bb83, unwind: bb103];
    }

    bb83: {
        _170 = move _171;
        _167 = push_group(_168, move _169, move _170) -> [return: bb84, unwind: bb108];
    }

    bb84: {
        _181 = &mut _37;
        _180 = push_dot(_181) -> [return: bb85, unwind: bb108];
    }

    bb85: {
        _183 = &mut _37;
        _184 = const "with_value";
        _182 = push_ident(_183, _184) -> [return: bb86, unwind: bb108];
    }

    bb86: {
        _186 = &mut _37;
        _187 = proc_macro2::Delimiter::Parenthesis;
        _189 = TokenStream2::new() -> [return: bb87, unwind: bb108];
    }

    bb87: {
        _191 = &mut _189;
        _192 = const "__f";
        _190 = push_ident(_191, _192) -> [return: bb88, unwind: bb102];
    }

    bb88: {
        _194 = &mut _189;
        _193 = push_dot(_194) -> [return: bb89, unwind: bb102];
    }

    bb89: {
        _196 = &mut _189;
        _197 = const "value";
        _195 = push_ident(_196, _197) -> [return: bb90, unwind: bb102];
    }

    bb90: {
        _188 = move _189;
        _185 = push_group(_186, move _187, move _188) -> [return: bb91, unwind: bb108];
    }

    bb91: {
        _199 = &mut _37;
        _198 = push_semi(_199) -> [return: bb92, unwind: bb108];
    }

    bb92: {
        _212 = const _;
        _201 = &mut _37;
        _200 = <StaticPath as ToTokens>::to_tokens(_212, _201) -> [return: bb93, unwind: bb108];
    }

    bb93: {
        _203 = &mut _37;
        _204 = proc_macro2::Delimiter::Parenthesis;
        _206 = TokenStream2::new() -> [return: bb94, unwind: bb108];
    }

    bb94: {
        _208 = &mut _206;
        _209 = const "_error";
        _207 = push_ident(_208, _209) -> [return: bb95, unwind: bb101];
    }

    bb95: {
        _205 = move _206;
        _202 = push_group(_203, move _204, move _205) -> [return: bb96, unwind: bb108];
    }

    bb96: {
        _211 = &mut _37;
        _210 = push_question(_211) -> [return: bb97, unwind: bb108];
    }

    bb97: {
        _36 = move _37;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _36);
        drop(_21) -> [return: bb98, unwind: bb112];
    }

    bb98: {
        drop(_4) -> [return: bb100, unwind continue];
    }

    bb99: {
        drop(_4) -> [return: bb100, unwind continue];
    }

    bb100: {
        return;
    }

    bb101 (cleanup): {
        drop(_206) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        drop(_189) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        drop(_171) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb104 (cleanup): {
        drop(_158) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        drop(_128) -> [return: bb106, unwind terminate(cleanup)];
    }

    bb106 (cleanup): {
        drop(_91) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        drop(_68) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb108 (cleanup): {
        drop(_37) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        drop(_21) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        drop(_16) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_8) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_4) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        resume;
    }

    bb114: {
        goto -> bb99;
    }

    bb115: {
        goto -> bb26;
    }

    bb116: {
        goto -> bb26;
    }

    bb117: {
        goto -> bb50;
    }

    bb118: {
        goto -> bb57;
    }

    bb119: {
        goto -> bb50;
    }
}

promoted[0] in from_form_field::derive_from_form_field::{closure#3}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in from_form_field::derive_from_form_field::{closure#3}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in from_form_field::derive_from_form_field::{closure#3}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#3}::{closure#0}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:57:46: 57:49}, _2: Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<Vec<FieldName>, devise::Diagnostic> {
    debug v => _2;
    let mut _0: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _3: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;

    bb0: {
        _3 = &_2;
        _0 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as VariantExt>::form_field_values(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#3}::{closure#1}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:62:26: 62:29}, _2: Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug v => _2;
    debug mapper => (*((*_1).0: &mut &mut devise::MapperBuild));
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: &mut &mut devise::MapperBuild;
    let mut _4: &mut devise::MapperBuild;

    bb0: {
        _3 = deref_copy ((*_1).0: &mut &mut devise::MapperBuild);
        _4 = deref_copy (*_3);
        _0 = <devise::MapperBuild as devise::Mapper>::map_variant(_4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#4}(_1: &mut {closure@core/codegen/src/derive/from_form_field.rs:79:30: 79:42}, _2: &mut devise::MapperBuild, _3: Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug variant => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: proc_macro2::TokenStream;
    let mut _5: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<derive::form_field::FieldName>>;
    let mut _8: std::result::Result<std::vec::Vec<derive::form_field::FieldName>, devise::Diagnostic>;
    let mut _9: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _10: isize;
    let mut _13: proc_macro2::TokenStream;
    let mut _16: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let mut _22: (std::slice::Iter<'_, derive::form_field::FieldName>, quote::__private::HasIterator);
    let mut _23: &std::vec::Vec<derive::form_field::FieldName>;
    let mut _25: bool;
    let mut _27: std::option::Option<&derive::form_field::FieldName>;
    let mut _28: &mut std::slice::Iter<'_, derive::form_field::FieldName>;
    let mut _29: isize;
    let mut _31: bool;
    let mut _32: usize;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let mut _35: (usize, bool);
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: &str;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let mut _51: proc_macro2::Delimiter;
    let mut _52: proc_macro2::TokenStream;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let _56: &quote::__private::RepInterp<&derive::form_field::FieldName>;
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let mut _60: proc_macro2::Delimiter;
    let mut _61: proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: &str;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::Delimiter;
    let mut _71: proc_macro2::TokenStream;
    let _73: ();
    let _74: &proc_macro2::TokenStream;
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    scope 1 {
        debug builder => _4;
        let _6: std::vec::Vec<derive::form_field::FieldName>;
        let _11: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _12: std::vec::Vec<derive::form_field::FieldName>;
        scope 2 {
            debug value => _6;
            let mut _14: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _14;
                let _15: proc_macro2::Span;
                scope 8 {
                    debug _span => _15;
                    let mut _20: usize;
                    let mut _62: proc_macro2::TokenStream;
                    scope 9 {
                        debug _i => _20;
                        scope 10 {
                            debug has_iter => const ThereIsNoIteratorInRepetition;
                            scope 11 {
                                debug value => _21;
                                debug i => const HasIterator;
                                let _24: quote::__private::HasIterator;
                                scope 13 {
                                    debug has_iter => const HasIterator;
                                    scope 14 {
                                        let _26: quote::__private::RepInterp<&derive::form_field::FieldName>;
                                        let _30: &derive::form_field::FieldName;
                                        scope 15 {
                                            debug value => _26;
                                            scope 17 {
                                            }
                                        }
                                        scope 16 {
                                            debug _x => _30;
                                        }
                                    }
                                }
                            }
                            scope 12 {
                                let mut _21: std::slice::Iter<'_, derive::form_field::FieldName>;
                            }
                        }
                    }
                    scope 18 {
                        debug _s => _62;
                        scope 19 {
                            debug _span => _15;
                            let mut _72: proc_macro2::TokenStream;
                            let mut _78: &exports::StaticPath;
                            scope 20 {
                                debug _s => _72;
                                scope 21 {
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _5 = &_3;
        _4 = Derived::<'_, syn::Variant, Derived<'_, ItemEnum>>::builder::<{closure@core/codegen/src/derive/from_form_field.rs:80:47: 80:50}>(move _5, const ZeroSized: {closure@core/codegen/src/derive/from_form_field.rs:80:47: 80:50}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &_3;
        _8 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as VariantExt>::form_field_values(move _9) -> [return: bb2, unwind: bb42];
    }

    bb2: {
        _7 = <std::result::Result<Vec<FieldName>, devise::Diagnostic> as std::ops::Try>::branch(move _8) -> [return: bb3, unwind: bb42];
    }

    bb3: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _12 = move ((_7 as Continue).0: std::vec::Vec<derive::form_field::FieldName>);
        _6 = move _12;
        _14 = TokenStream2::new() -> [return: bb8, unwind: bb41];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _11 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _11) -> [return: bb7, unwind: bb42];
    }

    bb7: {
        drop(_4) -> [return: bb37, unwind continue];
    }

    bb8: {
        _16 = &_3;
        _15 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as devise::Spanned>::span(move _16) -> [return: bb9, unwind: bb40];
    }

    bb9: {
        _18 = &mut _14;
        _19 = const "if";
        _17 = push_ident_spanned(_18, _15, _19) -> [return: bb10, unwind: bb40];
    }

    bb10: {
        _20 = const 0_usize;
        _23 = &_6;
        _22 = <Vec<FieldName> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _23) -> [return: bb11, unwind: bb40];
    }

    bb11: {
        _21 = move (_22.0: std::slice::Iter<'_, derive::form_field::FieldName>);
        _24 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb44, unwind: bb40];
    }

    bb12: {
        _25 = const true;
        switchInt(move _25) -> [0: bb27, otherwise: bb13];
    }

    bb13: {
        _28 = &mut _21;
        _27 = <std::slice::Iter<'_, FieldName> as Iterator>::next(move _28) -> [return: bb14, unwind: bb40];
    }

    bb14: {
        _29 = discriminant(_27);
        switchInt(move _29) -> [0: bb27, 1: bb15, otherwise: bb5];
    }

    bb15: {
        _30 = ((_27 as Some).0: &derive::form_field::FieldName);
        _26 = RepInterp::<&FieldName>(_30);
        _32 = _20;
        _31 = Gt(move _32, const 0_usize);
        switchInt(move _31) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _34 = &mut _14;
        _33 = push_or_or_spanned(_34, _15) -> [return: bb45, unwind: bb40];
    }

    bb17: {
        _35 = CheckedAdd(_20, const 1_usize);
        assert(!move (_35.1: bool), "attempt to compute `{} + {}`, which would overflow", _20, const 1_usize) -> [success: bb18, unwind: bb40];
    }

    bb18: {
        _20 = move (_35.0: usize);
        _37 = &mut _14;
        _38 = const "__f";
        _36 = push_ident_spanned(_37, _15, _38) -> [return: bb19, unwind: bb40];
    }

    bb19: {
        _40 = &mut _14;
        _39 = push_dot_spanned(_40, _15) -> [return: bb20, unwind: bb40];
    }

    bb20: {
        _42 = &mut _14;
        _43 = const "value";
        _41 = push_ident_spanned(_42, _15, _43) -> [return: bb21, unwind: bb40];
    }

    bb21: {
        _45 = &mut _14;
        _44 = push_dot_spanned(_45, _15) -> [return: bb22, unwind: bb40];
    }

    bb22: {
        _47 = &mut _14;
        _48 = const "as_uncased";
        _46 = push_ident_spanned(_47, _15, _48) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        _50 = &mut _14;
        _51 = proc_macro2::Delimiter::Parenthesis;
        _52 = TokenStream2::new() -> [return: bb24, unwind: bb40];
    }

    bb24: {
        _49 = push_group_spanned(_50, _15, move _51, move _52) -> [return: bb25, unwind: bb40];
    }

    bb25: {
        _54 = &mut _14;
        _53 = push_eq_eq_spanned(_54, _15) -> [return: bb26, unwind: bb40];
    }

    bb26: {
        _56 = &_26;
        _57 = &mut _14;
        _55 = <RepInterp<&FieldName> as ToTokens>::to_tokens(_56, _57) -> [return: bb46, unwind: bb40];
    }

    bb27: {
        _59 = &mut _14;
        _60 = proc_macro2::Delimiter::Brace;
        _62 = TokenStream2::new() -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _64 = &mut _62;
        _65 = const "return";
        _63 = push_ident_spanned(_64, _15, _65) -> [return: bb29, unwind: bb39];
    }

    bb29: {
        _78 = const _;
        _67 = &mut _62;
        _66 = <StaticPath as ToTokens>::to_tokens(_78, _67) -> [return: bb30, unwind: bb39];
    }

    bb30: {
        _69 = &mut _62;
        _70 = proc_macro2::Delimiter::Parenthesis;
        _72 = TokenStream2::new() -> [return: bb31, unwind: bb39];
    }

    bb31: {
        _74 = &_4;
        _75 = &mut _72;
        _73 = <TokenStream2 as ToTokens>::to_tokens(_74, _75) -> [return: bb32, unwind: bb38];
    }

    bb32: {
        _71 = move _72;
        _68 = push_group_spanned(_69, _15, move _70, move _71) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        _77 = &mut _62;
        _76 = push_semi_spanned(_77, _15) -> [return: bb34, unwind: bb39];
    }

    bb34: {
        _61 = move _62;
        _58 = push_group_spanned(_59, _15, move _60, move _61) -> [return: bb35, unwind: bb40];
    }

    bb35: {
        _13 = move _14;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _13);
        drop(_6) -> [return: bb36, unwind: bb42];
    }

    bb36: {
        drop(_4) -> [return: bb37, unwind continue];
    }

    bb37: {
        return;
    }

    bb38 (cleanup): {
        drop(_72) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_62) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_14) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_6) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_4) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        resume;
    }

    bb44: {
        goto -> bb12;
    }

    bb45: {
        goto -> bb17;
    }

    bb46: {
        goto -> bb12;
    }
}

promoted[0] in from_form_field::derive_from_form_field::{closure#4}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn from_form_field::derive_from_form_field::{closure#4}::{closure#0}(_1: &{closure@core/codegen/src/derive/from_form_field.rs:80:47: 80:50}, _2: devise::Field<'_>) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let _3: !;
    let mut _4: &&str;

    bb0: {
        _4 = const _;
        _3 = core::panicking::unreachable_display::<&str>(_4) -> unwind continue;
    }
}

promoted[0] in from_form_field::derive_from_form_field::{closure#4}::{closure#0}: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "fieldless";
        _0 = &_1;
        return;
    }
}

fn responder::<impl at core/codegen/src/derive/responder.rs:12:10: 12:15>::fmt(_1: &ItemAttr, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<devise::SpanWrapped<std::string::String>>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&std::option::Option<devise::SpanWrapped<http_codegen::Status>>;
    let _13: &std::option::Option<devise::SpanWrapped<http_codegen::Status>>;

    bb0: {
        _3 = const "ItemAttr";
        _4 = const "bound";
        _6 = &((*_1).0: std::option::Option<devise::SpanWrapped<std::string::String>>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "content_type";
        _9 = &((*_1).1: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "status";
        _13 = &((*_1).2: std::option::Option<devise::SpanWrapped<http_codegen::Status>>);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn responder::<impl at core/codegen/src/derive/responder.rs:12:17: 12:24>::default() -> ItemAttr {
    let mut _0: derive::responder::ItemAttr;
    let mut _1: std::option::Option<devise::SpanWrapped<std::string::String>>;
    let mut _2: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
    let mut _3: std::option::Option<devise::SpanWrapped<http_codegen::Status>>;

    bb0: {
        _1 = <Option<devise::SpanWrapped<std::string::String>> as std::default::Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Option<devise::SpanWrapped<http_codegen::ContentType>> as std::default::Default>::default() -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _3 = <Option<devise::SpanWrapped<http_codegen::Status>> as std::default::Default>::default() -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = ItemAttr { bound: move _1, content_type: move _2, status: move _3 };
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

const responder::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta(_1: &devise::MetaItem) -> std::result::Result<ItemAttr, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<derive::responder::ItemAttr, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _12: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _13: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _15: std::option::Option<&devise::MetaItem>;
    let mut _16: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _17: isize;
    let mut _21: std::option::Option<&proc_macro2::Ident>;
    let mut _22: isize;
    let mut _24: devise::Diagnostic;
    let mut _25: bool;
    let mut _26: &&proc_macro2::Ident;
    let mut _27: bool;
    let mut _28: &std::option::Option<std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _29: devise::Diagnostic;
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 0];
    let _35: [core::fmt::rt::Argument<'_>; 0];
    let mut _36: std::option::Option<std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _37: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _38: std::result::Result<std::option::Option<devise::SpanWrapped<std::string::String>>, devise::Diagnostic>;
    let mut _39: isize;
    let mut _42: bool;
    let mut _43: &&proc_macro2::Ident;
    let mut _44: bool;
    let mut _45: &std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _46: devise::Diagnostic;
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 0];
    let _52: [core::fmt::rt::Argument<'_>; 0];
    let mut _53: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _54: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _55: std::result::Result<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>, devise::Diagnostic>;
    let mut _56: isize;
    let mut _59: bool;
    let mut _60: &&proc_macro2::Ident;
    let mut _61: bool;
    let mut _62: &std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _63: devise::Diagnostic;
    let mut _65: std::fmt::Arguments<'_>;
    let mut _66: &[&str];
    let mut _67: &[core::fmt::rt::Argument<'_>];
    let _68: &[core::fmt::rt::Argument<'_>; 0];
    let _69: [core::fmt::rt::Argument<'_>; 0];
    let mut _70: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _71: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _72: std::result::Result<std::option::Option<devise::SpanWrapped<http_codegen::Status>>, devise::Diagnostic>;
    let mut _73: isize;
    let mut _77: std::fmt::Arguments<'_>;
    let mut _78: &[&str];
    let mut _79: &[core::fmt::rt::Argument<'_>];
    let _80: &[core::fmt::rt::Argument<'_>; 1];
    let _81: [core::fmt::rt::Argument<'_>; 1];
    let mut _82: core::fmt::rt::Argument<'_>;
    let _83: &&proc_macro2::Ident;
    let mut _84: devise::Diagnostic;
    let mut _85: derive::responder::ItemAttr;
    let mut _86: std::option::Option<devise::SpanWrapped<std::string::String>>;
    let mut _87: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _88: std::result::Result<std::option::Option<devise::SpanWrapped<std::string::String>>, devise::Diagnostic>;
    let mut _89: std::option::Option<std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _90: std::option::Option<std::option::Option<devise::SpanWrapped<std::string::String>>>;
    let mut _91: {closure@core/codegen/src/derive/responder.rs:14:5: 14:10};
    let mut _92: &proc_macro2::Span;
    let mut _93: isize;
    let mut _96: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
    let mut _97: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _98: std::result::Result<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>, devise::Diagnostic>;
    let mut _99: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _100: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
    let mut _101: {closure@core/codegen/src/derive/responder.rs:15:5: 15:17};
    let mut _102: &proc_macro2::Span;
    let mut _103: isize;
    let mut _106: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _107: std::result::Result<std::option::Option<devise::SpanWrapped<http_codegen::Status>>, devise::Diagnostic>;
    let mut _108: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _109: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
    let mut _110: {closure@core/codegen/src/derive/responder.rs:16:5: 16:11};
    let mut _111: &proc_macro2::Span;
    let mut _112: isize;
    let mut _122: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _123: bool;
    let mut _124: bool;
    let mut _125: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug bound => _9;
                scope 9 {
                    debug content_type => _10;
                    scope 11 {
                        debug status => _11;
                        let mut _14: syn::punctuated::Iter<'_, devise::MetaItem>;
                        let _94: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _95: std::option::Option<devise::SpanWrapped<std::string::String>>;
                        let _104: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _105: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
                        let _113: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _114: std::option::Option<devise::SpanWrapped<http_codegen::Status>>;
                        scope 13 {
                            debug iter => _14;
                            let _18: &devise::MetaItem;
                            scope 14 {
                                debug __meta => _18;
                                let _19: proc_macro2::Span;
                                scope 15 {
                                    debug __span => _19;
                                    let _20: &proc_macro2::Ident;
                                    let _23: &proc_macro2::Ident;
                                    scope 16 {
                                        debug __name => _20;
                                        let _30: std::string::String;
                                        let _40: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                        let _41: std::option::Option<devise::SpanWrapped<std::string::String>>;
                                        let _47: std::string::String;
                                        let _57: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                        let _58: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
                                        let _64: std::string::String;
                                        let _74: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                        let _75: std::option::Option<devise::SpanWrapped<http_codegen::Status>>;
                                        let _76: std::string::String;
                                        let mut _115: &[&str; 1];
                                        let mut _116: &[&str; 1];
                                        let mut _117: &[&str; 1];
                                        let mut _118: &[&str; 2];
                                        let mut _119: &&str;
                                        let mut _120: &&str;
                                        let mut _121: &&str;
                                        scope 18 {
                                            debug res => _30;
                                        }
                                        scope 19 {
                                            debug residual => _40;
                                            scope 20 {
                                            }
                                        }
                                        scope 21 {
                                            debug val => _41;
                                            scope 22 {
                                            }
                                        }
                                        scope 23 {
                                            debug res => _47;
                                        }
                                        scope 24 {
                                            debug residual => _57;
                                            scope 25 {
                                            }
                                        }
                                        scope 26 {
                                            debug val => _58;
                                            scope 27 {
                                            }
                                        }
                                        scope 28 {
                                            debug res => _64;
                                        }
                                        scope 29 {
                                            debug residual => _74;
                                            scope 30 {
                                            }
                                        }
                                        scope 31 {
                                            debug val => _75;
                                            scope 32 {
                                            }
                                        }
                                        scope 33 {
                                            debug __msg => _76;
                                        }
                                        scope 34 {
                                            debug res => _76;
                                        }
                                    }
                                    scope 17 {
                                        debug __ident => _23;
                                    }
                                }
                            }
                        }
                        scope 35 {
                            debug residual => _94;
                            scope 36 {
                            }
                        }
                        scope 37 {
                            debug val => _95;
                            scope 38 {
                            }
                        }
                        scope 39 {
                            debug residual => _104;
                            scope 40 {
                            }
                        }
                        scope 41 {
                            debug val => _105;
                            scope 42 {
                            }
                        }
                        scope 43 {
                            debug residual => _113;
                            scope 44 {
                            }
                        }
                        scope 45 {
                            debug val => _114;
                            scope 46 {
                            }
                        }
                    }
                    scope 12 {
                        let mut _11: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::Status>>>;
                    }
                }
                scope 10 {
                    let mut _10: std::option::Option<std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>>;
                }
            }
            scope 8 {
                let mut _9: std::option::Option<std::option::Option<devise::SpanWrapped<std::string::String>>>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _125 = const false;
        _124 = const false;
        _123 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _122 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_122 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _125 = const true;
        _3 = move _8;
        _124 = const true;
        _9 = Option::<Option<devise::SpanWrapped<std::string::String>>>::None;
        _123 = const true;
        _10 = Option::<Option<devise::SpanWrapped<http_codegen::ContentType>>>::None;
        _11 = Option::<Option<devise::SpanWrapped<http_codegen::Status>>>::None;
        _125 = const false;
        _13 = move _3;
        _12 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _13) -> [return: bb7, unwind: bb102];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb94, unwind continue];
    }

    bb7: {
        _14 = move _12;
        goto -> bb8;
    }

    bb8: {
        _16 = &mut _14;
        _15 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_16) -> [return: bb9, unwind: bb101];
    }

    bb9: {
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb11, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _18 = ((_15 as Some).0: &devise::MetaItem);
        _19 = <devise::MetaItem as devise::Spanned>::span(_18) -> [return: bb12, unwind: bb101];
    }

    bb11: {
        drop(_14) -> [return: bb67, unwind: bb102];
    }

    bb12: {
        _21 = devise::MetaItem::name(_18) -> [return: bb13, unwind: bb101];
    }

    bb13: {
        _22 = discriminant(_21);
        switchInt(move _22) -> [0: bb14, 1: bb15, otherwise: bb5];
    }

    bb14: {
        _24 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_19, const "expected key/value `key = value`") -> [return: bb16, unwind: bb101];
    }

    bb15: {
        _23 = ((_21 as Some).0: &proc_macro2::Ident);
        _20 = _23;
        _26 = &_20;
        _121 = const _;
        _25 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _26, _121) -> [return: bb17, unwind: bb101];
    }

    bb16: {
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Err(move _24);
        goto -> bb90;
    }

    bb17: {
        switchInt(move _25) -> [0: bb32, otherwise: bb18];
    }

    bb18: {
        _28 = &_9;
        _27 = Option::<Option<devise::SpanWrapped<std::string::String>>>::is_some(move _28) -> [return: bb19, unwind: bb101];
    }

    bb19: {
        switchInt(move _27) -> [0: bb25, otherwise: bb20];
    }

    bb20: {
        _115 = const _;
        _32 = _115 as &[&str] (PointerCoercion(Unsize));
        _35 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb101];
    }

    bb21: {
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = std::fmt::Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb22, unwind: bb101];
    }

    bb22: {
        _30 = format(move _31) -> [return: bb23, unwind: bb101];
    }

    bb23: {
        _29 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_19, move _30) -> [return: bb24, unwind: bb101];
    }

    bb24: {
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Err(move _29);
        goto -> bb90;
    }

    bb25: {
        _38 = <Option<devise::SpanWrapped<std::string::String>> as devise::FromMeta>::from_meta(_18) -> [return: bb26, unwind: bb101];
    }

    bb26: {
        _37 = <std::result::Result<Option<devise::SpanWrapped<std::string::String>>, devise::Diagnostic> as std::ops::Try>::branch(move _38) -> [return: bb27, unwind: bb101];
    }

    bb27: {
        _39 = discriminant(_37);
        switchInt(move _39) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        _41 = move ((_37 as Continue).0: std::option::Option<devise::SpanWrapped<std::string::String>>);
        _36 = Option::<Option<devise::SpanWrapped<std::string::String>>>::Some(move _41);
        drop(_9) -> [return: bb30, unwind: bb31];
    }

    bb29: {
        _40 = move ((_37 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _40) -> [return: bb110, unwind: bb101];
    }

    bb30: {
        _124 = const true;
        _9 = move _36;
        goto -> bb8;
    }

    bb31 (cleanup): {
        _124 = const true;
        _9 = move _36;
        goto -> bb101;
    }

    bb32: {
        _43 = &_20;
        _120 = const _;
        _42 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _43, _120) -> [return: bb33, unwind: bb101];
    }

    bb33: {
        switchInt(move _42) -> [0: bb48, otherwise: bb34];
    }

    bb34: {
        _45 = &_10;
        _44 = Option::<Option<devise::SpanWrapped<http_codegen::ContentType>>>::is_some(move _45) -> [return: bb35, unwind: bb101];
    }

    bb35: {
        switchInt(move _44) -> [0: bb41, otherwise: bb36];
    }

    bb36: {
        _116 = const _;
        _49 = _116 as &[&str] (PointerCoercion(Unsize));
        _52 = core::fmt::rt::Argument::<'_>::none() -> [return: bb37, unwind: bb101];
    }

    bb37: {
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = std::fmt::Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb38, unwind: bb101];
    }

    bb38: {
        _47 = format(move _48) -> [return: bb39, unwind: bb101];
    }

    bb39: {
        _46 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_19, move _47) -> [return: bb40, unwind: bb101];
    }

    bb40: {
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Err(move _46);
        goto -> bb90;
    }

    bb41: {
        _55 = <Option<devise::SpanWrapped<http_codegen::ContentType>> as devise::FromMeta>::from_meta(_18) -> [return: bb42, unwind: bb101];
    }

    bb42: {
        _54 = <std::result::Result<Option<devise::SpanWrapped<http_codegen::ContentType>>, devise::Diagnostic> as std::ops::Try>::branch(move _55) -> [return: bb43, unwind: bb101];
    }

    bb43: {
        _56 = discriminant(_54);
        switchInt(move _56) -> [0: bb44, 1: bb45, otherwise: bb5];
    }

    bb44: {
        _58 = move ((_54 as Continue).0: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>);
        _53 = Option::<Option<devise::SpanWrapped<http_codegen::ContentType>>>::Some(move _58);
        drop(_10) -> [return: bb46, unwind: bb47];
    }

    bb45: {
        _57 = move ((_54 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _57) -> [return: bb111, unwind: bb101];
    }

    bb46: {
        _123 = const true;
        _10 = move _53;
        goto -> bb8;
    }

    bb47 (cleanup): {
        _123 = const true;
        _10 = move _53;
        goto -> bb101;
    }

    bb48: {
        _60 = &_20;
        _119 = const _;
        _59 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _60, _119) -> [return: bb49, unwind: bb101];
    }

    bb49: {
        switchInt(move _59) -> [0: bb62, otherwise: bb50];
    }

    bb50: {
        _62 = &_11;
        _61 = Option::<Option<devise::SpanWrapped<http_codegen::Status>>>::is_some(move _62) -> [return: bb51, unwind: bb101];
    }

    bb51: {
        switchInt(move _61) -> [0: bb57, otherwise: bb52];
    }

    bb52: {
        _117 = const _;
        _66 = _117 as &[&str] (PointerCoercion(Unsize));
        _69 = core::fmt::rt::Argument::<'_>::none() -> [return: bb53, unwind: bb101];
    }

    bb53: {
        _68 = &_69;
        _67 = _68 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _65 = std::fmt::Arguments::<'_>::new_v1(move _66, move _67) -> [return: bb54, unwind: bb101];
    }

    bb54: {
        _64 = format(move _65) -> [return: bb55, unwind: bb101];
    }

    bb55: {
        _63 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_19, move _64) -> [return: bb56, unwind: bb101];
    }

    bb56: {
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Err(move _63);
        goto -> bb90;
    }

    bb57: {
        _72 = <Option<devise::SpanWrapped<http_codegen::Status>> as devise::FromMeta>::from_meta(_18) -> [return: bb58, unwind: bb101];
    }

    bb58: {
        _71 = <std::result::Result<Option<devise::SpanWrapped<http_codegen::Status>>, devise::Diagnostic> as std::ops::Try>::branch(move _72) -> [return: bb59, unwind: bb101];
    }

    bb59: {
        _73 = discriminant(_71);
        switchInt(move _73) -> [0: bb60, 1: bb61, otherwise: bb5];
    }

    bb60: {
        _75 = move ((_71 as Continue).0: std::option::Option<devise::SpanWrapped<http_codegen::Status>>);
        _70 = Option::<Option<devise::SpanWrapped<http_codegen::Status>>>::Some(move _75);
        _11 = move _70;
        goto -> bb8;
    }

    bb61: {
        _74 = move ((_71 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _74) -> [return: bb112, unwind: bb101];
    }

    bb62: {
        _118 = const _;
        _78 = _118 as &[&str] (PointerCoercion(Unsize));
        _83 = &_20;
        _82 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_83) -> [return: bb63, unwind: bb101];
    }

    bb63: {
        _81 = [move _82];
        _80 = &_81;
        _79 = _80 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _77 = std::fmt::Arguments::<'_>::new_v1(move _78, move _79) -> [return: bb64, unwind: bb101];
    }

    bb64: {
        _76 = format(move _77) -> [return: bb65, unwind: bb101];
    }

    bb65: {
        _84 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_19, move _76) -> [return: bb66, unwind: bb101];
    }

    bb66: {
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Err(move _84);
        goto -> bb90;
    }

    bb67: {
        _124 = const false;
        _90 = move _9;
        _89 = Option::<Option<devise::SpanWrapped<std::string::String>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<std::string::String>>> {<Option<devise::SpanWrapped<std::string::String>> as devise::FromMeta>::default}>(move _90, <Option<devise::SpanWrapped<std::string::String>> as devise::FromMeta>::default) -> [return: bb68, unwind: bb102];
    }

    bb68: {
        _92 = &_2;
        _91 = {closure@core/codegen/src/derive/responder.rs:14:5: 14:10} { __span: move _92 };
        _88 = Option::<Option<devise::SpanWrapped<std::string::String>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/responder.rs:14:5: 14:10}>(move _89, move _91) -> [return: bb69, unwind: bb102];
    }

    bb69: {
        _87 = <std::result::Result<Option<devise::SpanWrapped<std::string::String>>, devise::Diagnostic> as std::ops::Try>::branch(move _88) -> [return: bb70, unwind: bb102];
    }

    bb70: {
        _93 = discriminant(_87);
        switchInt(move _93) -> [0: bb71, 1: bb72, otherwise: bb5];
    }

    bb71: {
        _95 = move ((_87 as Continue).0: std::option::Option<devise::SpanWrapped<std::string::String>>);
        _86 = move _95;
        _123 = const false;
        _100 = move _10;
        _99 = Option::<Option<devise::SpanWrapped<http_codegen::ContentType>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<http_codegen::ContentType>>> {<Option<devise::SpanWrapped<http_codegen::ContentType>> as devise::FromMeta>::default}>(move _100, <Option<devise::SpanWrapped<http_codegen::ContentType>> as devise::FromMeta>::default) -> [return: bb74, unwind: bb100];
    }

    bb72: {
        _94 = move ((_87 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _94) -> [return: bb73, unwind: bb105];
    }

    bb73: {
        drop(_10) -> [return: bb89, unwind continue];
    }

    bb74: {
        _102 = &_2;
        _101 = {closure@core/codegen/src/derive/responder.rs:15:5: 15:17} { __span: move _102 };
        _98 = Option::<Option<devise::SpanWrapped<http_codegen::ContentType>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/responder.rs:15:5: 15:17}>(move _99, move _101) -> [return: bb75, unwind: bb100];
    }

    bb75: {
        _97 = <std::result::Result<Option<devise::SpanWrapped<http_codegen::ContentType>>, devise::Diagnostic> as std::ops::Try>::branch(move _98) -> [return: bb76, unwind: bb100];
    }

    bb76: {
        _103 = discriminant(_97);
        switchInt(move _103) -> [0: bb77, 1: bb78, otherwise: bb5];
    }

    bb77: {
        _105 = move ((_97 as Continue).0: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>);
        _96 = move _105;
        _109 = move _11;
        _108 = Option::<Option<devise::SpanWrapped<http_codegen::Status>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<http_codegen::Status>>> {<Option<devise::SpanWrapped<http_codegen::Status>> as devise::FromMeta>::default}>(move _109, <Option<devise::SpanWrapped<http_codegen::Status>> as devise::FromMeta>::default) -> [return: bb80, unwind: bb98];
    }

    bb78: {
        _104 = move ((_97 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _104) -> [return: bb79, unwind: bb99];
    }

    bb79: {
        drop(_86) -> [return: bb88, unwind continue];
    }

    bb80: {
        _111 = &_2;
        _110 = {closure@core/codegen/src/derive/responder.rs:16:5: 16:11} { __span: move _111 };
        _107 = Option::<Option<devise::SpanWrapped<http_codegen::Status>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/responder.rs:16:5: 16:11}>(move _108, move _110) -> [return: bb81, unwind: bb98];
    }

    bb81: {
        _106 = <std::result::Result<Option<devise::SpanWrapped<http_codegen::Status>>, devise::Diagnostic> as std::ops::Try>::branch(move _107) -> [return: bb82, unwind: bb98];
    }

    bb82: {
        _112 = discriminant(_106);
        switchInt(move _112) -> [0: bb83, 1: bb84, otherwise: bb5];
    }

    bb83: {
        _114 = move ((_106 as Continue).0: std::option::Option<devise::SpanWrapped<http_codegen::Status>>);
        _85 = ItemAttr { bound: move _86, content_type: move _96, status: move _114 };
        _0 = std::result::Result::<ItemAttr, devise::Diagnostic>::Ok(move _85);
        _123 = const false;
        _124 = const false;
        _125 = const false;
        goto -> bb95;
    }

    bb84: {
        _113 = move ((_106 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<ItemAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _113) -> [return: bb85, unwind: bb96];
    }

    bb85: {
        drop(_96) -> [return: bb86, unwind: bb97];
    }

    bb86: {
        drop(_86) -> [return: bb87, unwind continue];
    }

    bb87: {
        _123 = const false;
        _124 = const false;
        _125 = const false;
        goto -> bb95;
    }

    bb88: {
        _123 = const false;
        _124 = const false;
        _125 = const false;
        goto -> bb95;
    }

    bb89: {
        _123 = const false;
        _124 = const false;
        _125 = const false;
        goto -> bb95;
    }

    bb90: {
        drop(_14) -> [return: bb91, unwind: bb102];
    }

    bb91: {
        drop(_10) -> [return: bb92, unwind: bb107];
    }

    bb92: {
        _123 = const false;
        drop(_9) -> [return: bb93, unwind: bb109];
    }

    bb93: {
        _124 = const false;
        goto -> bb94;
    }

    bb94: {
        _125 = const false;
        goto -> bb95;
    }

    bb95: {
        return;
    }

    bb96 (cleanup): {
        drop(_96) -> [return: bb97, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        drop(_86) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        drop(_96) -> [return: bb99, unwind terminate(cleanup)];
    }

    bb99 (cleanup): {
        drop(_86) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        drop(_86) -> [return: bb105, unwind terminate(cleanup)];
    }

    bb101 (cleanup): {
        drop(_14) -> [return: bb102, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        drop(_10) -> [return: bb107, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        resume;
    }

    bb104 (cleanup): {
        drop(_10) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        switchInt(_123) -> [0: bb103, otherwise: bb104];
    }

    bb106 (cleanup): {
        drop(_9) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        switchInt(_124) -> [0: bb109, otherwise: bb106];
    }

    bb108 (cleanup): {
        drop(_3) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        switchInt(_125) -> [0: bb103, otherwise: bb108];
    }

    bb110: {
        goto -> bb90;
    }

    bb111: {
        goto -> bb90;
    }

    bb112: {
        goto -> bb90;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: bound"];
        _0 = &_1;
        return;
    }
}

promoted[1] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: content_type"];
        _0 = &_1;
        return;
    }
}

promoted[2] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: status"];
        _0 = &_1;
        return;
    }
}

promoted[3] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[4] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "status";
        _0 = &_1;
        return;
    }
}

promoted[5] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "content_type";
        _0 = &_1;
        return;
    }
}

promoted[6] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "bound";
        _0 = &_1;
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#0}(_1: {closure@core/codegen/src/derive/responder.rs:14:5: 14:10}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `bound`"];
        _0 = &_1;
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#1}(_1: {closure@core/codegen/src/derive/responder.rs:15:5: 15:17}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `content_type`"];
        _0 = &_1;
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#2}(_1: {closure@core/codegen/src/derive/responder.rs:16:5: 16:11}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:12:26: 12:34>::from_meta::{closure#2}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `status`"];
        _0 = &_1;
        return;
    }
}

fn responder::<impl at core/codegen/src/derive/responder.rs:19:10: 19:17>::default() -> responder::FieldAttr {
    let mut _0: derive::responder::FieldAttr;
    let mut _1: bool;

    bb0: {
        _1 = <bool as std::default::Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = responder::FieldAttr { ignore: move _1 };
        return;
    }
}

const responder::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta(_1: &devise::MetaItem) -> std::result::Result<responder::FieldAttr, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<derive::responder::FieldAttr, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _10: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _11: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _13: std::option::Option<&devise::MetaItem>;
    let mut _14: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _15: isize;
    let mut _19: std::option::Option<&proc_macro2::Ident>;
    let mut _20: isize;
    let mut _22: devise::Diagnostic;
    let mut _23: bool;
    let mut _24: &&proc_macro2::Ident;
    let mut _25: bool;
    let mut _26: &std::option::Option<bool>;
    let mut _27: devise::Diagnostic;
    let mut _29: std::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 0];
    let _33: [core::fmt::rt::Argument<'_>; 0];
    let mut _34: std::option::Option<bool>;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, bool>;
    let mut _36: std::result::Result<bool, devise::Diagnostic>;
    let mut _37: isize;
    let mut _41: std::fmt::Arguments<'_>;
    let mut _42: &[&str];
    let mut _43: &[core::fmt::rt::Argument<'_>];
    let _44: &[core::fmt::rt::Argument<'_>; 1];
    let _45: [core::fmt::rt::Argument<'_>; 1];
    let mut _46: core::fmt::rt::Argument<'_>;
    let _47: &&proc_macro2::Ident;
    let mut _48: devise::Diagnostic;
    let mut _49: derive::responder::FieldAttr;
    let mut _50: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, bool>;
    let mut _51: std::result::Result<bool, devise::Diagnostic>;
    let mut _52: std::option::Option<bool>;
    let mut _53: std::option::Option<bool>;
    let mut _54: {closure@core/codegen/src/derive/responder.rs:21:5: 21:11};
    let mut _55: &proc_macro2::Span;
    let mut _56: isize;
    let mut _62: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _63: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug ignore => _9;
                let mut _12: syn::punctuated::Iter<'_, devise::MetaItem>;
                let _57: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _58: bool;
                scope 9 {
                    debug iter => _12;
                    let _16: &devise::MetaItem;
                    scope 10 {
                        debug __meta => _16;
                        let _17: proc_macro2::Span;
                        scope 11 {
                            debug __span => _17;
                            let _18: &proc_macro2::Ident;
                            let _21: &proc_macro2::Ident;
                            scope 12 {
                                debug __name => _18;
                                let _28: std::string::String;
                                let _38: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _39: bool;
                                let _40: std::string::String;
                                let mut _59: &[&str; 1];
                                let mut _60: &[&str; 2];
                                let mut _61: &&str;
                                scope 14 {
                                    debug res => _28;
                                }
                                scope 15 {
                                    debug residual => _38;
                                    scope 16 {
                                    }
                                }
                                scope 17 {
                                    debug val => _39;
                                    scope 18 {
                                    }
                                }
                                scope 19 {
                                    debug __msg => _40;
                                }
                                scope 20 {
                                    debug res => _40;
                                }
                            }
                            scope 13 {
                                debug __ident => _21;
                            }
                        }
                    }
                }
                scope 21 {
                    debug residual => _57;
                    scope 22 {
                    }
                }
                scope 23 {
                    debug val => _58;
                    scope 24 {
                    }
                }
            }
            scope 8 {
                let mut _9: std::option::Option<bool>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _63 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _62 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_62 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _63 = const true;
        _3 = move _8;
        _9 = Option::<bool>::None;
        _63 = const false;
        _11 = move _3;
        _10 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _11) -> [return: bb7, unwind: bb48];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<responder::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb43, unwind continue];
    }

    bb7: {
        _12 = move _10;
        goto -> bb8;
    }

    bb8: {
        _14 = &mut _12;
        _13 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_14) -> [return: bb9, unwind: bb45];
    }

    bb9: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb11, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _16 = ((_13 as Some).0: &devise::MetaItem);
        _17 = <devise::MetaItem as devise::Spanned>::span(_16) -> [return: bb12, unwind: bb45];
    }

    bb11: {
        drop(_12) -> [return: bb35, unwind: bb48];
    }

    bb12: {
        _19 = devise::MetaItem::name(_16) -> [return: bb13, unwind: bb45];
    }

    bb13: {
        _20 = discriminant(_19);
        switchInt(move _20) -> [0: bb14, 1: bb15, otherwise: bb5];
    }

    bb14: {
        _22 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_17, const "expected key/value `key = value`") -> [return: bb16, unwind: bb45];
    }

    bb15: {
        _21 = ((_19 as Some).0: &proc_macro2::Ident);
        _18 = _21;
        _24 = &_18;
        _61 = const _;
        _23 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _24, _61) -> [return: bb17, unwind: bb45];
    }

    bb16: {
        _0 = std::result::Result::<responder::FieldAttr, devise::Diagnostic>::Err(move _22);
        goto -> bb42;
    }

    bb17: {
        switchInt(move _23) -> [0: bb30, otherwise: bb18];
    }

    bb18: {
        _26 = &_9;
        _25 = Option::<bool>::is_some(move _26) -> [return: bb19, unwind: bb45];
    }

    bb19: {
        switchInt(move _25) -> [0: bb25, otherwise: bb20];
    }

    bb20: {
        _59 = const _;
        _30 = _59 as &[&str] (PointerCoercion(Unsize));
        _33 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb45];
    }

    bb21: {
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _29 = std::fmt::Arguments::<'_>::new_v1(move _30, move _31) -> [return: bb22, unwind: bb45];
    }

    bb22: {
        _28 = format(move _29) -> [return: bb23, unwind: bb45];
    }

    bb23: {
        _27 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_17, move _28) -> [return: bb24, unwind: bb45];
    }

    bb24: {
        _0 = std::result::Result::<responder::FieldAttr, devise::Diagnostic>::Err(move _27);
        goto -> bb42;
    }

    bb25: {
        _36 = <bool as devise::FromMeta>::from_meta(_16) -> [return: bb26, unwind: bb45];
    }

    bb26: {
        _35 = <std::result::Result<bool, devise::Diagnostic> as std::ops::Try>::branch(move _36) -> [return: bb27, unwind: bb45];
    }

    bb27: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        _39 = ((_35 as Continue).0: bool);
        _34 = Option::<bool>::Some(_39);
        _9 = move _34;
        goto -> bb8;
    }

    bb29: {
        _38 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<responder::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _38) -> [return: bb49, unwind: bb45];
    }

    bb30: {
        _60 = const _;
        _42 = _60 as &[&str] (PointerCoercion(Unsize));
        _47 = &_18;
        _46 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_47) -> [return: bb31, unwind: bb45];
    }

    bb31: {
        _45 = [move _46];
        _44 = &_45;
        _43 = _44 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _41 = std::fmt::Arguments::<'_>::new_v1(move _42, move _43) -> [return: bb32, unwind: bb45];
    }

    bb32: {
        _40 = format(move _41) -> [return: bb33, unwind: bb45];
    }

    bb33: {
        _48 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_17, move _40) -> [return: bb34, unwind: bb45];
    }

    bb34: {
        _0 = std::result::Result::<responder::FieldAttr, devise::Diagnostic>::Err(move _48);
        goto -> bb42;
    }

    bb35: {
        _53 = _9;
        _52 = Option::<bool>::or_else::<fn() -> Option<bool> {<bool as devise::FromMeta>::default}>(move _53, <bool as devise::FromMeta>::default) -> [return: bb36, unwind: bb48];
    }

    bb36: {
        _55 = &_2;
        _54 = {closure@core/codegen/src/derive/responder.rs:21:5: 21:11} { __span: move _55 };
        _51 = Option::<bool>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/derive/responder.rs:21:5: 21:11}>(move _52, move _54) -> [return: bb37, unwind: bb48];
    }

    bb37: {
        _50 = <std::result::Result<bool, devise::Diagnostic> as std::ops::Try>::branch(move _51) -> [return: bb38, unwind: bb48];
    }

    bb38: {
        _56 = discriminant(_50);
        switchInt(move _56) -> [0: bb39, 1: bb40, otherwise: bb5];
    }

    bb39: {
        _58 = ((_50 as Continue).0: bool);
        _49 = responder::FieldAttr { ignore: _58 };
        _0 = std::result::Result::<responder::FieldAttr, devise::Diagnostic>::Ok(move _49);
        _63 = const false;
        goto -> bb44;
    }

    bb40: {
        _57 = move ((_50 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<responder::FieldAttr, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _57) -> [return: bb41, unwind continue];
    }

    bb41: {
        _63 = const false;
        goto -> bb44;
    }

    bb42: {
        drop(_12) -> [return: bb43, unwind: bb48];
    }

    bb43: {
        _63 = const false;
        goto -> bb44;
    }

    bb44: {
        return;
    }

    bb45 (cleanup): {
        drop(_12) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        resume;
    }

    bb47 (cleanup): {
        drop(_3) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_63) -> [0: bb46, otherwise: bb47];
    }

    bb49: {
        goto -> bb42;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: ignore"];
        _0 = &_1;
        return;
    }
}

promoted[1] in responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[2] in responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ignore";
        _0 = &_1;
        return;
    }
}

fn responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta::{closure#0}(_1: {closure@core/codegen/src/derive/responder.rs:21:5: 21:11}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in responder::_::<impl at core/codegen/src/derive/responder.rs:19:19: 19:27>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `ignore`"];
        _0 = &_1;
        return;
    }
}

fn responder::derive_responder(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let _4: ();
    let mut _5: &mut proc_macro2::TokenStream;
    let _6: &str;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: &str;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &str;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: &str;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let mut _51: &mut devise::DeriveGenerator;
    let mut _52: &mut devise::DeriveGenerator;
    let mut _53: &mut devise::DeriveGenerator;
    let mut _54: &mut devise::DeriveGenerator;
    let mut _55: &mut devise::DeriveGenerator;
    let mut _56: &mut devise::DeriveGenerator;
    let mut _57: devise::DeriveGenerator;
    let mut _58: proc_macro::TokenStream;
    let mut _59: devise::Support;
    let mut _60: devise::Support;
    let mut _61: devise::Support;
    let mut _62: devise::MapperBuild;
    let mut _63: devise::MapperBuild;
    let mut _64: devise::ValidatorBuild;
    let mut _65: devise::ValidatorBuild;
    let mut _66: devise::ValidatorBuild;
    let mut _67: devise::MapperBuild;
    let mut _68: devise::MapperBuild;
    let mut _69: devise::MapperBuild;
    let mut _70: bool;
    scope 1 {
        debug impl_tokens => _2;
    }
    scope 2 {
        debug _s => _3;
    }

    bb0: {
        _70 = const false;
        _70 = const true;
        _3 = TokenStream2::new() -> [return: bb1, unwind: bb44];
    }

    bb1: {
        _5 = &mut _3;
        _6 = const "impl";
        _4 = push_ident(_5, _6) -> [return: bb2, unwind: bb41];
    }

    bb2: {
        _8 = &mut _3;
        _7 = push_lt(_8) -> [return: bb3, unwind: bb41];
    }

    bb3: {
        _10 = &mut _3;
        _11 = const "'r";
        _9 = push_lifetime(_10, _11) -> [return: bb4, unwind: bb41];
    }

    bb4: {
        _13 = &mut _3;
        _12 = push_comma(_13) -> [return: bb5, unwind: bb41];
    }

    bb5: {
        _15 = &mut _3;
        _16 = const "'o";
        _14 = push_lifetime(_15, _16) -> [return: bb6, unwind: bb41];
    }

    bb6: {
        _18 = &mut _3;
        _17 = push_colon(_18) -> [return: bb7, unwind: bb41];
    }

    bb7: {
        _20 = &mut _3;
        _21 = const "'r";
        _19 = push_lifetime(_20, _21) -> [return: bb8, unwind: bb41];
    }

    bb8: {
        _23 = &mut _3;
        _22 = push_gt(_23) -> [return: bb9, unwind: bb41];
    }

    bb9: {
        _25 = &mut _3;
        _24 = push_colon2(_25) -> [return: bb10, unwind: bb41];
    }

    bb10: {
        _27 = &mut _3;
        _28 = const "rocket";
        _26 = push_ident(_27, _28) -> [return: bb11, unwind: bb41];
    }

    bb11: {
        _30 = &mut _3;
        _29 = push_colon2(_30) -> [return: bb12, unwind: bb41];
    }

    bb12: {
        _32 = &mut _3;
        _33 = const "response";
        _31 = push_ident(_32, _33) -> [return: bb13, unwind: bb41];
    }

    bb13: {
        _35 = &mut _3;
        _34 = push_colon2(_35) -> [return: bb14, unwind: bb41];
    }

    bb14: {
        _37 = &mut _3;
        _38 = const "Responder";
        _36 = push_ident(_37, _38) -> [return: bb15, unwind: bb41];
    }

    bb15: {
        _40 = &mut _3;
        _39 = push_lt(_40) -> [return: bb16, unwind: bb41];
    }

    bb16: {
        _42 = &mut _3;
        _43 = const "'r";
        _41 = push_lifetime(_42, _43) -> [return: bb17, unwind: bb41];
    }

    bb17: {
        _45 = &mut _3;
        _44 = push_comma(_45) -> [return: bb18, unwind: bb41];
    }

    bb18: {
        _47 = &mut _3;
        _48 = const "'o";
        _46 = push_lifetime(_47, _48) -> [return: bb19, unwind: bb41];
    }

    bb19: {
        _50 = &mut _3;
        _49 = push_gt(_50) -> [return: bb20, unwind: bb41];
    }

    bb20: {
        _2 = move _3;
        _70 = const false;
        _58 = move _1;
        _57 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _58, move _2) -> [return: bb21, unwind: bb44];
    }

    bb21: {
        _56 = &mut _57;
        _61 = <devise::Support as std::ops::BitOr>::bitor(const _, const _) -> [return: bb22, unwind: bb40];
    }

    bb22: {
        _60 = <devise::Support as std::ops::BitOr>::bitor(move _61, const _) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        _59 = <devise::Support as std::ops::BitOr>::bitor(move _60, const _) -> [return: bb24, unwind: bb40];
    }

    bb24: {
        _55 = devise::DeriveGenerator::support(move _56, move _59) -> [return: bb25, unwind: bb40];
    }

    bb25: {
        _54 = devise::DeriveGenerator::replace_generic(_55, const 1_usize, const 0_usize) -> [return: bb26, unwind: bb40];
    }

    bb26: {
        _63 = devise::MapperBuild::new() -> [return: bb27, unwind: bb40];
    }

    bb27: {
        _62 = devise::MapperBuild::try_input_map::<{closure@core/codegen/src/derive/responder.rs:30:28: 30:38}>(move _63, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:30:28: 30:38}) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _53 = devise::DeriveGenerator::type_bound_mapper::<devise::MapperBuild>(_54, move _62) -> [return: bb29, unwind: bb40];
    }

    bb29: {
        _66 = devise::ValidatorBuild::new() -> [return: bb30, unwind: bb40];
    }

    bb30: {
        _65 = devise::ValidatorBuild::input_validate::<{closure@core/codegen/src/derive/responder.rs:47:29: 47:35}>(move _66, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:47:29: 47:35}) -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _64 = devise::ValidatorBuild::fields_validate::<{closure@core/codegen/src/derive/responder.rs:51:30: 51:41}>(move _65, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:51:30: 51:41}) -> [return: bb32, unwind: bb40];
    }

    bb32: {
        _52 = devise::DeriveGenerator::validator::<devise::ValidatorBuild>(_53, move _64) -> [return: bb33, unwind: bb40];
    }

    bb33: {
        _69 = devise::MapperBuild::new() -> [return: bb34, unwind: bb40];
    }

    bb34: {
        _68 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/responder.rs:57:26: 57:37}>(move _69, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:57:26: 57:37}) -> [return: bb35, unwind: bb40];
    }

    bb35: {
        _67 = devise::MapperBuild::try_fields_map::<{closure@core/codegen/src/derive/responder.rs:62:29: 62:40}>(move _68, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:62:29: 62:40}) -> [return: bb36, unwind: bb40];
    }

    bb36: {
        _51 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_52, move _67) -> [return: bb37, unwind: bb40];
    }

    bb37: {
        _0 = devise::DeriveGenerator::to_tokens::<TokenStream2>(_51) -> [return: bb38, unwind: bb40];
    }

    bb38: {
        drop(_57) -> [return: bb39, unwind: bb44];
    }

    bb39: {
        return;
    }

    bb40 (cleanup): {
        drop(_57) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_3) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        resume;
    }

    bb43 (cleanup): {
        drop(_1) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        switchInt(_70) -> [0: bb42, otherwise: bb43];
    }
}

fn responder::derive_responder::{closure#0}(_1: &mut {closure@core/codegen/src/derive/responder.rs:30:28: 30:38}, _2: &mut devise::MapperBuild, _3: devise::Input<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _4: std::option::Option<std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>>;
    let mut _5: std::option::Option<devise::SpanWrapped<std::string::String>>;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<derive::responder::ItemAttr>>;
    let mut _7: std::result::Result<std::option::Option<derive::responder::ItemAttr>, devise::Diagnostic>;
    let _8: &str;
    let _9: &[syn::Attribute];
    let _10: &devise::ItemInput;
    let mut _11: &devise::Input<'_>;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _14: std::option::Option<derive::responder::ItemAttr>;
    let mut _15: {closure@core/codegen/src/derive/responder.rs:39:37: 39:39};
    let mut _16: &devise::Input<'_>;
    scope 1 {
        debug residual => _13;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _14;
        scope 4 {
        }
    }

    bb0: {
        _8 = const "response";
        _11 = &_3;
        _10 = <devise::Input<'_> as std::ops::Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ItemInput::attrs(_10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = <ItemAttr as devise::FromMeta>::one_from_attrs(_8, _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <std::result::Result<Option<ItemAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_6);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _14 = move ((_6 as Continue).0: std::option::Option<derive::responder::ItemAttr>);
        _5 = Option::<ItemAttr>::and_then::<devise::SpanWrapped<std::string::String>, {closure@core/codegen/src/derive/responder.rs:32:31: 32:37}>(move _14, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:32:31: 32:37}) -> [return: bb8, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _13) -> [return: bb10, unwind continue];
    }

    bb8: {
        _4 = Option::<devise::SpanWrapped<std::string::String>>::map::<std::result::Result<TokenStream2, devise::Diagnostic>, {closure@core/codegen/src/derive/responder.rs:33:26: 33:33}>(move _5, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:33:26: 33:33}) -> [return: bb9, unwind continue];
    }

    bb9: {
        _16 = &_3;
        _15 = {closure@core/codegen/src/derive/responder.rs:39:37: 39:39} { input: move _16 };
        _0 = Option::<std::result::Result<TokenStream2, devise::Diagnostic>>::unwrap_or_else::<{closure@core/codegen/src/derive/responder.rs:39:37: 39:39}>(move _4, move _15) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn responder::derive_responder::{closure#0}::{closure#0}(_1: {closure@core/codegen/src/derive/responder.rs:32:31: 32:37}, _2: ItemAttr) -> Option<devise::SpanWrapped<std::string::String>> {
    debug attr => _2;
    let mut _0: std::option::Option<devise::SpanWrapped<std::string::String>>;

    bb0: {
        _0 = move (_2.0: std::option::Option<devise::SpanWrapped<std::string::String>>);
        drop((_2.1: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>)) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn responder::derive_responder::{closure#0}::{closure#1}(_1: {closure@core/codegen/src/derive/responder.rs:33:26: 33:33}, _2: devise::SpanWrapped<std::string::String>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug bound => _2;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _3: proc_macro2::Span;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>>;
    let mut _6: std::result::Result<syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>, devise::Diagnostic>;
    let mut _7: std::result::Result<syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>, syn::Error>;
    let _8: &str;
    let _9: &std::string::String;
    let _10: &devise::SpanWrapped<std::string::String>;
    let mut _11: {closure@core/codegen/src/derive/responder.rs:36:38: 36:41};
    let mut _12: &proc_macro2::Span;
    let mut _13: isize;
    let mut _16: proc_macro2::TokenStream;
    let _19: ();
    let _20: &syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
    let mut _21: &mut proc_macro2::TokenStream;
    let mut _22: &proc_macro2::TokenStream;
    let mut _23: proc_macro2::Span;
    scope 1 {
        debug span => _3;
        let _4: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
        let _14: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _15: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
        scope 2 {
            debug bounds => _4;
            let _17: proc_macro2::TokenStream;
            let mut _18: proc_macro2::TokenStream;
            scope 7 {
                debug tokens => _17;
            }
            scope 8 {
                debug _s => _18;
                scope 9 {
                }
            }
        }
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = (_2.0: proc_macro2::Span);
        _10 = &_2;
        _9 = <devise::SpanWrapped<std::string::String> as std::ops::Deref>::deref(_10) -> [return: bb1, unwind: bb19];
    }

    bb1: {
        _8 = <std::string::String as std::ops::Deref>::deref(_9) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _7 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>, syn::Error> {syn::punctuated::Punctuated::<WherePredicate, syn::token::Comma>::parse_terminated} as Parser>::parse_str(syn::punctuated::Punctuated::<WherePredicate, syn::token::Comma>::parse_terminated, _8) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _12 = &_3;
        _11 = {closure@core/codegen/src/derive/responder.rs:36:38: 36:41} { span: move _12 };
        _6 = std::result::Result::<syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>, syn::Error>::map_err::<devise::Diagnostic, {closure@core/codegen/src/derive/responder.rs:36:38: 36:41}>(move _7, move _11) -> [return: bb4, unwind: bb19];
    }

    bb4: {
        _5 = <std::result::Result<syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _13 = discriminant(_5);
        switchInt(move _13) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _15 = move ((_5 as Continue).0: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>);
        _4 = move _15;
        _18 = TokenStream2::new() -> [return: bb10, unwind: bb18];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _14 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _14) -> [return: bb9, unwind: bb19];
    }

    bb9: {
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb10: {
        _20 = &_4;
        _21 = &mut _18;
        _19 = <syn::punctuated::Punctuated<WherePredicate, syn::token::Comma> as ToTokens>::to_tokens(_20, _21) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _17 = move _18;
        _22 = &_17;
        _23 = _3;
        _16 = <TokenStream2 as AstItemExt>::respanned_tokens(move _22, move _23) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        drop(_17) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _16);
        drop(_4) -> [return: bb14, unwind: bb19];
    }

    bb14: {
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_17) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_18) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_4) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_2) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }
}

fn responder::derive_responder::{closure#0}::{closure#1}::{closure#0}(_1: {closure@core/codegen/src/derive/responder.rs:36:38: 36:41}, _2: syn::Error) -> devise::Diagnostic {
    debug e => _2;
    debug span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _3: proc_macro2::Span;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &syn::Error;
    let mut _12: &[&str; 1];
    let mut _13: &proc_macro2::Span;
    scope 1 {
        debug res => _4;
    }

    bb0: {
        _13 = deref_copy (_1.0: &proc_macro2::Span);
        _3 = (*_13);
        _12 = const _;
        _6 = _12 as &[&str] (PointerCoercion(Unsize));
        _11 = &_2;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<syn::Error>(_11) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = format(move _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _3, move _4) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

promoted[0] in responder::derive_responder::{closure#0}::{closure#1}::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "invalid bound syntax: "];
        _0 = &_1;
        return;
    }
}

fn responder::derive_responder::{closure#0}::{closure#2}(_1: {closure@core/codegen/src/derive/responder.rs:39:37: 39:39}) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => (*(_1.0: &devise::Input<'_>));
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let _4: ();
    let mut _5: &mut proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>>;
    let mut _33: std::result::Result<syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>, devise::Diagnostic>;
    let _34: &syn::Generics;
    let _35: &devise::ItemInput;
    let mut _36: proc_macro2::TokenStream;
    let mut _37: isize;
    let mut _40: proc_macro2::TokenStream;
    let _42: ();
    let _43: &syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
    let mut _44: &mut proc_macro2::TokenStream;
    let mut _45: &devise::Input<'_>;
    let mut _46: bool;
    scope 1 {
        debug bound => _2;
        let _31: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
        let _38: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _39: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>;
        scope 3 {
            debug preds => _31;
            let mut _41: proc_macro2::TokenStream;
            scope 8 {
                debug _s => _41;
            }
        }
        scope 4 {
            debug residual => _38;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _39;
            scope 7 {
            }
        }
    }
    scope 2 {
        debug _s => _3;
    }

    bb0: {
        _46 = const false;
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _3;
        _4 = push_colon2(_5) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        _7 = &mut _3;
        _8 = const "rocket";
        _6 = push_ident(_7, _8) -> [return: bb3, unwind: bb27];
    }

    bb3: {
        _10 = &mut _3;
        _9 = push_colon2(_10) -> [return: bb4, unwind: bb27];
    }

    bb4: {
        _12 = &mut _3;
        _13 = const "response";
        _11 = push_ident(_12, _13) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _15 = &mut _3;
        _14 = push_colon2(_15) -> [return: bb6, unwind: bb27];
    }

    bb6: {
        _17 = &mut _3;
        _18 = const "Responder";
        _16 = push_ident(_17, _18) -> [return: bb7, unwind: bb27];
    }

    bb7: {
        _20 = &mut _3;
        _19 = push_lt(_20) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _22 = &mut _3;
        _23 = const "'r";
        _21 = push_lifetime(_22, _23) -> [return: bb9, unwind: bb27];
    }

    bb9: {
        _25 = &mut _3;
        _24 = push_comma(_25) -> [return: bb10, unwind: bb27];
    }

    bb10: {
        _27 = &mut _3;
        _28 = const "'o";
        _26 = push_lifetime(_27, _28) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _30 = &mut _3;
        _29 = push_gt(_30) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _46 = const true;
        _2 = move _3;
        _45 = deref_copy (_1.0: &devise::Input<'_>);
        _35 = <devise::Input<'_> as std::ops::Deref>::deref(_45) -> [return: bb13, unwind: bb30];
    }

    bb13: {
        _34 = ItemInput::generics(_35) -> [return: bb14, unwind: bb30];
    }

    bb14: {
        _46 = const false;
        _36 = move _2;
        _33 = <Generics as GenericsExt>::parsed_bounded_types(_34, move _36) -> [return: bb15, unwind: bb30];
    }

    bb15: {
        _32 = <std::result::Result<syn::punctuated::Punctuated<WherePredicate, syn::token::Comma>, devise::Diagnostic> as std::ops::Try>::branch(move _33) -> [return: bb16, unwind: bb30];
    }

    bb16: {
        _37 = discriminant(_32);
        switchInt(move _37) -> [0: bb17, 1: bb19, otherwise: bb18];
    }

    bb17: {
        _39 = move ((_32 as Continue).0: syn::punctuated::Punctuated<syn::WherePredicate, syn::token::Comma>);
        _31 = move _39;
        _41 = TokenStream2::new() -> [return: bb21, unwind: bb26];
    }

    bb18: {
        unreachable;
    }

    bb19: {
        _38 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _38) -> [return: bb20, unwind: bb30];
    }

    bb20: {
        _46 = const false;
        goto -> bb24;
    }

    bb21: {
        _43 = &_31;
        _44 = &mut _41;
        _42 = <syn::punctuated::Punctuated<WherePredicate, syn::token::Comma> as ToTokens>::to_tokens(_43, _44) -> [return: bb22, unwind: bb25];
    }

    bb22: {
        _40 = move _41;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _40);
        drop(_31) -> [return: bb23, unwind: bb30];
    }

    bb23: {
        _46 = const false;
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_41) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_31) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29 (cleanup): {
        drop(_2) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_46) -> [0: bb28, otherwise: bb29];
    }
}

fn responder::derive_responder::{closure#1}(_1: &mut {closure@core/codegen/src/derive/responder.rs:47:29: 47:35}, _2: &mut devise::ValidatorBuild, _3: devise::Input<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug i => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: usize;
    let mut _6: syn::generics::Lifetimes<'_>;
    let _7: &syn::Generics;
    let _8: &devise::ItemInput;
    let mut _9: &devise::Input<'_>;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let _12: &syn::Generics;
    let _13: &devise::ItemInput;
    let mut _14: &devise::Input<'_>;

    bb0: {
        _9 = &_3;
        _8 = <devise::Input<'_> as std::ops::Deref>::deref(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = ItemInput::generics(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = Generics::lifetimes(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <syn::generics::Lifetimes<'_> as Iterator>::count(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = Gt(move _5, const 1_usize);
        switchInt(_4) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb11;
    }

    bb6: {
        _14 = &_3;
        _13 = <devise::Input<'_> as std::ops::Deref>::deref(move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = ItemInput::generics(_13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = <Generics as devise::Spanned>::span(_12) -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _11, const "only one lifetime is supported") -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn responder::derive_responder::{closure#2}(_1: &mut {closure@core/codegen/src/derive/responder.rs:51:30: 51:41}, _2: &mut devise::ValidatorBuild, _3: devise::Fields<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: devise::Fields<'_>;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro2::Span;
    let mut _8: &devise::Fields<'_>;

    bb0: {
        _5 = _3;
        _4 = devise::Fields::<'_>::is_empty(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(_4) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb6;
    }

    bb3: {
        _8 = &_3;
        _7 = <devise::Fields<'_> as devise::Spanned>::span(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _7, const "need at least one field") -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _6);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn responder::derive_responder::{closure#3}(_1: &mut {closure@core/codegen/src/derive/responder.rs:57:26: 57:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: &str;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let mut _58: proc_macro2::Delimiter;
    let mut _59: proc_macro2::TokenStream;
    let _61: ();
    let _62: &proc_macro2::TokenStream;
    let mut _63: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _60: proc_macro2::TokenStream;
        let mut _64: &exports::StaticPath;
        scope 2 {
            debug _s => _15;
            let mut _65: &exports::StaticPath;
        }
        scope 3 {
            debug _s => _60;
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb29];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "respond_to";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb29];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb29];
    }

    bb4: {
        _17 = &mut _15;
        _18 = const "self";
        _16 = push_ident(_17, _18) -> [return: bb5, unwind: bb28];
    }

    bb5: {
        _20 = &mut _15;
        _19 = push_comma(_20) -> [return: bb6, unwind: bb28];
    }

    bb6: {
        _22 = &mut _15;
        _23 = const "__req";
        _21 = push_ident(_22, _23) -> [return: bb7, unwind: bb28];
    }

    bb7: {
        _25 = &mut _15;
        _24 = push_colon(_25) -> [return: bb8, unwind: bb28];
    }

    bb8: {
        _27 = &mut _15;
        _26 = push_and(_27) -> [return: bb9, unwind: bb28];
    }

    bb9: {
        _29 = &mut _15;
        _30 = const "'r";
        _28 = push_lifetime(_29, _30) -> [return: bb10, unwind: bb28];
    }

    bb10: {
        _65 = const _;
        _32 = &mut _15;
        _31 = <StaticPath as ToTokens>::to_tokens(_65, _32) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _34 = &mut _15;
        _33 = push_lt(_34) -> [return: bb12, unwind: bb28];
    }

    bb12: {
        _36 = &mut _15;
        _37 = const "'_";
        _35 = push_lifetime(_36, _37) -> [return: bb13, unwind: bb28];
    }

    bb13: {
        _39 = &mut _15;
        _38 = push_gt(_39) -> [return: bb14, unwind: bb28];
    }

    bb14: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb15, unwind: bb29];
    }

    bb15: {
        _41 = &mut _4;
        _40 = push_rarrow(_41) -> [return: bb16, unwind: bb29];
    }

    bb16: {
        _64 = const _;
        _43 = &mut _4;
        _42 = <StaticPath as ToTokens>::to_tokens(_64, _43) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _45 = &mut _4;
        _44 = push_colon2(_45) -> [return: bb18, unwind: bb29];
    }

    bb18: {
        _47 = &mut _4;
        _48 = const "Result";
        _46 = push_ident(_47, _48) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _50 = &mut _4;
        _49 = push_lt(_50) -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _52 = &mut _4;
        _53 = const "'o";
        _51 = push_lifetime(_52, _53) -> [return: bb21, unwind: bb29];
    }

    bb21: {
        _55 = &mut _4;
        _54 = push_gt(_55) -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _57 = &mut _4;
        _58 = proc_macro2::Delimiter::Brace;
        _60 = TokenStream2::new() -> [return: bb23, unwind: bb29];
    }

    bb23: {
        _62 = &_3;
        _63 = &mut _60;
        _61 = <TokenStream2 as ToTokens>::to_tokens(_62, _63) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        _59 = move _60;
        _56 = push_group(_57, move _58, move _59) -> [return: bb25, unwind: bb29];
    }

    bb25: {
        _0 = move _4;
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_60) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_15) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_4) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_3) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        resume;
    }
}

promoted[0] in responder::derive_responder::{closure#3}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in responder::derive_responder::{closure#3}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn responder::derive_responder::{closure#4}(_1: &mut {closure@core/codegen/src/derive/responder.rs:62:29: 62:40}, _2: &mut devise::MapperBuild, _3: devise::Fields<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: derive::responder::ItemAttr;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<derive::responder::ItemAttr>>;
    let mut _6: std::result::Result<std::option::Option<derive::responder::ItemAttr>, devise::Diagnostic>;
    let _7: &str;
    let _8: &[syn::Attribute];
    let mut _9: &devise::FieldParent<'_>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _12: std::option::Option<derive::responder::ItemAttr>;
    let mut _14: std::option::Option<proc_macro2::TokenStream>;
    let mut _15: std::option::Option<devise::Field<'_>>;
    let mut _16: &mut std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _17: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _18: devise::Fields<'_>;
    let _19: &str;
    let mut _21: std::iter::Skip<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>>;
    let mut _22: std::iter::Skip<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>>;
    let mut _23: std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>;
    let mut _24: devise::Fields<'_>;
    let mut _26: std::option::Option<devise::Field<'_>>;
    let mut _27: &mut std::iter::Skip<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>>;
    let mut _28: isize;
    let mut _31: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<derive::responder::FieldAttr>>;
    let mut _32: std::result::Result<std::option::Option<derive::responder::FieldAttr>, devise::Diagnostic>;
    let _33: &str;
    let _34: &[syn::Attribute];
    let _35: &std::vec::Vec<syn::Attribute>;
    let _36: &syn::Field;
    let _37: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _38: &devise::Field<'_>;
    let mut _39: isize;
    let mut _42: bool;
    let _43: ();
    let mut _44: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _45: proc_macro2::TokenStream;
    let mut _46: proc_macro2::TokenStream;
    let mut _47: &devise::Field<'_>;
    let mut _49: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>;
    let mut _51: std::option::Option<devise::SpanWrapped<http_codegen::Status>>;
    let mut _52: proc_macro2::TokenStream;
    let _54: ();
    let _55: &proc_macro2::TokenStream;
    let mut _56: &mut proc_macro2::TokenStream;
    let mut _58: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _59: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _61: bool;
    let mut _63: std::option::Option<&proc_macro2::TokenStream>;
    let mut _64: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _65: isize;
    let _67: ();
    let _68: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let _71: &std::option::Option<proc_macro2::TokenStream>;
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: ();
    let _74: &std::option::Option<proc_macro2::TokenStream>;
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let mut _80: proc_macro2::Delimiter;
    let mut _81: proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: &str;
    let mut _87: bool;
    scope 1 {
        debug attr => _4;
        let _13: proc_macro2::TokenStream;
        scope 6 {
            debug responder => _13;
            let mut _20: std::vec::Vec<proc_macro2::TokenStream>;
            scope 7 {
                debug headers => _20;
                let mut _25: std::iter::Skip<std::iter::Map<std::iter::Enumerate<std::iter::FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>>;
                let _48: std::option::Option<proc_macro2::TokenStream>;
                scope 8 {
                    debug iter => _25;
                    let _29: devise::Field<'_>;
                    scope 9 {
                        debug field => _29;
                        let _30: derive::responder::FieldAttr;
                        let _40: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _41: std::option::Option<derive::responder::FieldAttr>;
                        scope 10 {
                            debug attr => _30;
                        }
                        scope 11 {
                            debug residual => _40;
                            scope 12 {
                            }
                        }
                        scope 13 {
                            debug val => _41;
                            scope 14 {
                            }
                        }
                    }
                }
                scope 15 {
                    debug content_type => _48;
                    let _50: std::option::Option<proc_macro2::TokenStream>;
                    scope 16 {
                        debug status => _50;
                        let mut _53: proc_macro2::TokenStream;
                        scope 17 {
                            debug _s => _53;
                            let mut _82: proc_macro2::TokenStream;
                            let mut _86: &exports::StaticPath;
                            scope 18 {
                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                scope 19 {
                                    debug headers => _57;
                                    debug i => const HasIterator;
                                    let _60: quote::__private::HasIterator;
                                    scope 21 {
                                        debug has_iter => const HasIterator;
                                        scope 22 {
                                            let _62: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                            let _66: &proc_macro2::TokenStream;
                                            scope 23 {
                                                debug headers => _62;
                                            }
                                            scope 24 {
                                                debug _x => _66;
                                            }
                                        }
                                    }
                                }
                                scope 20 {
                                    let mut _57: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                }
                            }
                            scope 25 {
                                debug _s => _82;
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _11;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _87 = const false;
        _7 = const "response";
        _9 = &(_3.0: devise::FieldParent<'_>);
        _8 = FieldParent::<'_>::attrs(move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <ItemAttr as devise::FromMeta>::one_from_attrs(_7, _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = <std::result::Result<Option<ItemAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _12 = move ((_5 as Continue).0: std::option::Option<derive::responder::ItemAttr>);
        _4 = Option::<ItemAttr>::unwrap_or_default(move _12) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _11 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _11) -> [return: bb57, unwind continue];
    }

    bb7: {
        _87 = const true;
        _18 = _3;
        _17 = devise::Fields::<'_>::iter(move _18) -> [return: bb8, unwind: bb71];
    }

    bb8: {
        _16 = &mut _17;
        _15 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::next(move _16) -> [return: bb9, unwind: bb66];
    }

    bb9: {
        _14 = Option::<devise::Field<'_>>::map::<TokenStream2, {closure@core/codegen/src/derive/responder.rs:70:58: 70:61}>(move _15, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:70:58: 70:61}) -> [return: bb10, unwind: bb66];
    }

    bb10: {
        _19 = const "have at least one field";
        _13 = Option::<TokenStream2>::expect(move _14, _19) -> [return: bb11, unwind: bb66];
    }

    bb11: {
        drop(_17) -> [return: bb12, unwind: bb65];
    }

    bb12: {
        _20 = Vec::<TokenStream2>::new() -> [return: bb13, unwind: bb65];
    }

    bb13: {
        _24 = _3;
        _23 = devise::Fields::<'_>::iter(move _24) -> [return: bb14, unwind: bb64];
    }

    bb14: {
        _22 = <Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}> as Iterator>::skip(move _23, const 1_usize) -> [return: bb15, unwind: bb64];
    }

    bb15: {
        _21 = <Skip<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>> as IntoIterator>::into_iter(move _22) -> [return: bb16, unwind: bb64];
    }

    bb16: {
        _25 = move _21;
        goto -> bb17;
    }

    bb17: {
        _27 = &mut _25;
        _26 = <Skip<Map<Enumerate<FlatMap<std::option::IntoIter<&syn::punctuated::Punctuated<syn::Field, syn::token::Comma>>, syn::punctuated::Iter<'_, syn::Field>, {closure@devise::Fields<'_>::iter::{closure#0}}>>, {closure@devise::Fields<'_>::iter::{closure#1}}>> as Iterator>::next(_27) -> [return: bb18, unwind: bb63];
    }

    bb18: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb20, 1: bb19, otherwise: bb5];
    }

    bb19: {
        _29 = ((_26 as Some).0: devise::Field<'_>);
        _33 = const "response";
        _38 = &_29;
        _37 = <devise::Field<'_> as std::ops::Deref>::deref(move _38) -> [return: bb21, unwind: bb63];
    }

    bb20: {
        drop(_25) -> [return: bb33, unwind: bb64];
    }

    bb21: {
        _36 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_37) -> [return: bb22, unwind: bb63];
    }

    bb22: {
        _35 = &((*_36).0: std::vec::Vec<syn::Attribute>);
        _34 = <Vec<syn::Attribute> as std::ops::Deref>::deref(_35) -> [return: bb23, unwind: bb63];
    }

    bb23: {
        _32 = <responder::FieldAttr as devise::FromMeta>::one_from_attrs(_33, _34) -> [return: bb24, unwind: bb63];
    }

    bb24: {
        _31 = <std::result::Result<Option<responder::FieldAttr>, devise::Diagnostic> as std::ops::Try>::branch(move _32) -> [return: bb25, unwind: bb63];
    }

    bb25: {
        _39 = discriminant(_31);
        switchInt(move _39) -> [0: bb26, 1: bb27, otherwise: bb5];
    }

    bb26: {
        _41 = move ((_31 as Continue).0: std::option::Option<derive::responder::FieldAttr>);
        _30 = Option::<responder::FieldAttr>::unwrap_or_default(move _41) -> [return: bb29, unwind: bb63];
    }

    bb27: {
        _40 = move ((_31 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _40) -> [return: bb28, unwind: bb63];
    }

    bb28: {
        drop(_25) -> [return: bb54, unwind: bb64];
    }

    bb29: {
        _42 = (_30.0: bool);
        switchInt(move _42) -> [0: bb30, otherwise: bb17];
    }

    bb30: {
        _44 = &mut _20;
        _47 = &_29;
        _46 = devise::Field::<'_>::accessor(move _47) -> [return: bb31, unwind: bb63];
    }

    bb31: {
        _45 = set_header_tokens::<TokenStream2>(move _46) -> [return: bb32, unwind: bb63];
    }

    bb32: {
        _43 = Vec::<TokenStream2>::push(move _44, move _45) -> [return: bb72, unwind: bb63];
    }

    bb33: {
        _87 = const false;
        _49 = move (_4.1: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>);
        _48 = Option::<devise::SpanWrapped<http_codegen::ContentType>>::map::<TokenStream2, fn(devise::SpanWrapped<http_codegen::ContentType>) -> TokenStream2 {set_header_tokens::<devise::SpanWrapped<http_codegen::ContentType>>}>(move _49, set_header_tokens::<devise::SpanWrapped<http_codegen::ContentType>>) -> [return: bb34, unwind: bb64];
    }

    bb34: {
        _51 = move (_4.2: std::option::Option<devise::SpanWrapped<http_codegen::Status>>);
        _50 = Option::<devise::SpanWrapped<http_codegen::Status>>::map::<TokenStream2, {closure@core/codegen/src/derive/responder.rs:90:46: 90:54}>(move _51, const ZeroSized: {closure@core/codegen/src/derive/responder.rs:90:46: 90:54}) -> [return: bb35, unwind: bb62];
    }

    bb35: {
        _53 = TokenStream2::new() -> [return: bb36, unwind: bb61];
    }

    bb36: {
        _55 = &_13;
        _56 = &mut _53;
        _54 = <TokenStream2 as ToTokens>::to_tokens(_55, _56) -> [return: bb37, unwind: bb60];
    }

    bb37: {
        _59 = &_20;
        _58 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _59) -> [return: bb38, unwind: bb60];
    }

    bb38: {
        _57 = move (_58.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _60 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb73, unwind: bb60];
    }

    bb39: {
        _61 = const true;
        switchInt(move _61) -> [0: bb43, otherwise: bb40];
    }

    bb40: {
        _64 = &mut _57;
        _63 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _64) -> [return: bb41, unwind: bb60];
    }

    bb41: {
        _65 = discriminant(_63);
        switchInt(move _65) -> [0: bb43, 1: bb42, otherwise: bb5];
    }

    bb42: {
        _66 = ((_63 as Some).0: &proc_macro2::TokenStream);
        _62 = RepInterp::<&TokenStream2>(_66);
        _68 = &_62;
        _69 = &mut _53;
        _67 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_68, _69) -> [return: bb74, unwind: bb60];
    }

    bb43: {
        _71 = &_48;
        _72 = &mut _53;
        _70 = <Option<TokenStream2> as ToTokens>::to_tokens(_71, _72) -> [return: bb44, unwind: bb60];
    }

    bb44: {
        _74 = &_50;
        _75 = &mut _53;
        _73 = <Option<TokenStream2> as ToTokens>::to_tokens(_74, _75) -> [return: bb45, unwind: bb60];
    }

    bb45: {
        _86 = const _;
        _77 = &mut _53;
        _76 = <StaticPath as ToTokens>::to_tokens(_86, _77) -> [return: bb46, unwind: bb60];
    }

    bb46: {
        _79 = &mut _53;
        _80 = proc_macro2::Delimiter::Parenthesis;
        _82 = TokenStream2::new() -> [return: bb47, unwind: bb60];
    }

    bb47: {
        _84 = &mut _82;
        _85 = const "__res";
        _83 = push_ident(_84, _85) -> [return: bb48, unwind: bb59];
    }

    bb48: {
        _81 = move _82;
        _78 = push_group(_79, move _80, move _81) -> [return: bb49, unwind: bb60];
    }

    bb49: {
        _52 = move _53;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _52);
        drop(_50) -> [return: bb50, unwind: bb62];
    }

    bb50: {
        drop(_48) -> [return: bb51, unwind: bb64];
    }

    bb51: {
        drop(_20) -> [return: bb52, unwind: bb65];
    }

    bb52: {
        drop(_13) -> [return: bb53, unwind: bb71];
    }

    bb53: {
        drop((_4.0: std::option::Option<devise::SpanWrapped<std::string::String>>)) -> [return: bb68, unwind continue];
    }

    bb54: {
        drop(_20) -> [return: bb55, unwind: bb65];
    }

    bb55: {
        drop(_13) -> [return: bb56, unwind: bb71];
    }

    bb56: {
        drop(_4) -> [return: bb57, unwind continue];
    }

    bb57: {
        _87 = const false;
        goto -> bb58;
    }

    bb58: {
        return;
    }

    bb59 (cleanup): {
        drop(_82) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_53) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_50) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_48) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_25) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_20) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_13) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_17) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        resume;
    }

    bb68: {
        _87 = const false;
        goto -> bb58;
    }

    bb69 (cleanup): {
        switchInt(_87) -> [0: bb67, otherwise: bb70];
    }

    bb70 (cleanup): {
        drop((_4.1: std::option::Option<devise::SpanWrapped<http_codegen::ContentType>>)) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        drop((_4.0: std::option::Option<devise::SpanWrapped<std::string::String>>)) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb72: {
        goto -> bb17;
    }

    bb73: {
        goto -> bb39;
    }

    bb74: {
        goto -> bb39;
    }
}

promoted[0] in responder::derive_responder::{closure#4}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn set_header_tokens(_1: T) -> TokenStream2 {
    debug item => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _4: proc_macro2::Span;
    let mut _5: &T;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::Delimiter;
    let mut _17: proc_macro2::TokenStream;
    let _19: ();
    let _20: &T;
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _2;
        let _3: proc_macro2::Span;
        scope 2 {
            debug _span => _3;
            let mut _18: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _18;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind: bb14];
    }

    bb1: {
        _5 = &_1;
        _4 = <T as devise::Spanned>::span(move _5) -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _3 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _4) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _7 = &mut _2;
        _8 = const "__res";
        _6 = push_ident_spanned(_7, _3, _8) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _10 = &mut _2;
        _9 = push_dot_spanned(_10, _3) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _12 = &mut _2;
        _13 = const "set_header";
        _11 = push_ident_spanned(_12, _3, _13) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _15 = &mut _2;
        _16 = proc_macro2::Delimiter::Parenthesis;
        _18 = TokenStream2::new() -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _20 = &_1;
        _21 = &mut _18;
        _19 = <T as ToTokens>::to_tokens(_20, _21) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _17 = move _18;
        _14 = push_group_spanned(_15, _3, move _16, move _17) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _23 = &mut _2;
        _22 = push_semi_spanned(_23, _3) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        _0 = move _2;
        drop(_1) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_18) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        drop(_1) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }
}

fn responder::derive_responder::{closure#4}::{closure#0}(_1: {closure@core/codegen/src/derive/responder.rs:70:58: 70:61}, _2: devise::Field<'_>) -> TokenStream2 {
    debug f => _2;
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let _4: syn::Type;
    let mut _5: (proc_macro2::TokenStream, syn::Type);
    let mut _6: proc_macro2::TokenStream;
    let mut _7: &devise::Field<'_>;
    let mut _8: syn::Type;
    let mut _9: &syn::Type;
    let _10: &syn::Field;
    let _11: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _12: &devise::Field<'_>;
    let mut _15: proc_macro2::Span;
    let mut _16: &devise::Field<'_>;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &str;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let _31: &syn::Type;
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let mut _60: proc_macro2::Delimiter;
    let mut _61: proc_macro2::TokenStream;
    let _63: ();
    let _64: &proc_macro2::TokenStream;
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: &str;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    scope 1 {
        debug accessor => _3;
        debug ty => _4;
        let mut _13: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _13;
            let _14: proc_macro2::Span;
            scope 3 {
                debug _span => _14;
                let mut _62: proc_macro2::TokenStream;
                scope 4 {
                    debug _s => _62;
                    scope 5 {
                        debug _span => _14;
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_2;
        _6 = devise::Field::<'_>::accessor(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _12 = &_2;
        _11 = <devise::Field<'_> as std::ops::Deref>::deref(move _12) -> [return: bb2, unwind: bb37];
    }

    bb2: {
        _10 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_11) -> [return: bb3, unwind: bb37];
    }

    bb3: {
        _9 = &((*_10).4: syn::Type);
        _8 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(move _9) -> [return: bb4, unwind: bb37];
    }

    bb4: {
        _5 = (move _6, move _8);
        _3 = move (_5.0: proc_macro2::TokenStream);
        _4 = move (_5.1: syn::Type);
        _13 = TokenStream2::new() -> [return: bb5, unwind: bb35];
    }

    bb5: {
        _16 = &_2;
        _15 = <devise::Field<'_> as devise::Spanned>::span(move _16) -> [return: bb6, unwind: bb34];
    }

    bb6: {
        _14 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _15) -> [return: bb7, unwind: bb34];
    }

    bb7: {
        _18 = &mut _13;
        _19 = const "let";
        _17 = push_ident_spanned(_18, _14, _19) -> [return: bb8, unwind: bb34];
    }

    bb8: {
        _21 = &mut _13;
        _22 = const "mut";
        _20 = push_ident_spanned(_21, _14, _22) -> [return: bb9, unwind: bb34];
    }

    bb9: {
        _24 = &mut _13;
        _25 = const "__res";
        _23 = push_ident_spanned(_24, _14, _25) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _27 = &mut _13;
        _26 = push_eq_spanned(_27, _14) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _29 = &mut _13;
        _28 = push_lt_spanned(_29, _14) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _31 = &_4;
        _32 = &mut _13;
        _30 = <syn::Type as ToTokens>::to_tokens(_31, _32) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _34 = &mut _13;
        _35 = const "as";
        _33 = push_ident_spanned(_34, _14, _35) -> [return: bb14, unwind: bb34];
    }

    bb14: {
        _37 = &mut _13;
        _36 = push_colon2_spanned(_37, _14) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _39 = &mut _13;
        _40 = const "rocket";
        _38 = push_ident_spanned(_39, _14, _40) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _42 = &mut _13;
        _41 = push_colon2_spanned(_42, _14) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _44 = &mut _13;
        _45 = const "response";
        _43 = push_ident_spanned(_44, _14, _45) -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _47 = &mut _13;
        _46 = push_colon2_spanned(_47, _14) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _49 = &mut _13;
        _50 = const "Responder";
        _48 = push_ident_spanned(_49, _14, _50) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _52 = &mut _13;
        _51 = push_gt_spanned(_52, _14) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _54 = &mut _13;
        _53 = push_colon2_spanned(_54, _14) -> [return: bb22, unwind: bb34];
    }

    bb22: {
        _56 = &mut _13;
        _57 = const "respond_to";
        _55 = push_ident_spanned(_56, _14, _57) -> [return: bb23, unwind: bb34];
    }

    bb23: {
        _59 = &mut _13;
        _60 = proc_macro2::Delimiter::Parenthesis;
        _62 = TokenStream2::new() -> [return: bb24, unwind: bb34];
    }

    bb24: {
        _64 = &_3;
        _65 = &mut _62;
        _63 = <TokenStream2 as ToTokens>::to_tokens(_64, _65) -> [return: bb25, unwind: bb33];
    }

    bb25: {
        _67 = &mut _62;
        _66 = push_comma_spanned(_67, _14) -> [return: bb26, unwind: bb33];
    }

    bb26: {
        _69 = &mut _62;
        _70 = const "__req";
        _68 = push_ident_spanned(_69, _14, _70) -> [return: bb27, unwind: bb33];
    }

    bb27: {
        _61 = move _62;
        _58 = push_group_spanned(_59, _14, move _60, move _61) -> [return: bb28, unwind: bb34];
    }

    bb28: {
        _72 = &mut _13;
        _71 = push_question_spanned(_72, _14) -> [return: bb29, unwind: bb34];
    }

    bb29: {
        _74 = &mut _13;
        _73 = push_semi_spanned(_74, _14) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        _0 = move _13;
        drop(_4) -> [return: bb31, unwind: bb36];
    }

    bb31: {
        drop(_3) -> [return: bb32, unwind continue];
    }

    bb32: {
        return;
    }

    bb33 (cleanup): {
        drop(_62) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_13) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_4) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_3) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_6) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        resume;
    }
}

fn responder::derive_responder::{closure#4}::{closure#1}(_1: {closure@core/codegen/src/derive/responder.rs:90:46: 90:54}, _2: devise::SpanWrapped<http_codegen::Status>) -> TokenStream2 {
    debug status => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _5: proc_macro2::Span;
    let mut _6: &devise::SpanWrapped<http_codegen::Status>;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: &str;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let mut _17: proc_macro2::Delimiter;
    let mut _18: proc_macro2::TokenStream;
    let _20: ();
    let _21: &devise::SpanWrapped<http_codegen::Status>;
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug _span => _4;
            let mut _19: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _19;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_2;
        _5 = <devise::SpanWrapped<http_codegen::Status> as devise::Spanned>::span(move _6) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _4 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _5) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _8 = &mut _3;
        _9 = const "__res";
        _7 = push_ident_spanned(_8, _4, _9) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _11 = &mut _3;
        _10 = push_dot_spanned(_11, _4) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _13 = &mut _3;
        _14 = const "set_status";
        _12 = push_ident_spanned(_13, _4, _14) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _16 = &mut _3;
        _17 = proc_macro2::Delimiter::Parenthesis;
        _19 = TokenStream2::new() -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _21 = &_2;
        _22 = &mut _19;
        _20 = <devise::SpanWrapped<http_codegen::Status> as ToTokens>::to_tokens(_21, _22) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _18 = move _19;
        _15 = push_group_spanned(_16, _4, move _17, move _18) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _24 = &mut _3;
        _23 = push_semi_spanned(_24, _4) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        _0 = move _3;
        return;
    }

    bb11 (cleanup): {
        drop(_19) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

const NO_EMPTY_FIELDS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "fieldless structs are not supported";
        return;
    }
}

const NO_NULLARY: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "nullary items are not supported";
        return;
    }
}

const NO_EMPTY_ENUMS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "empty enums are not supported";
        return;
    }
}

const ONLY_ONE_UNNAMED: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "tuple structs or variants must have exactly one field";
        return;
    }
}

const EXACTLY_ONE_FIELD: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "struct must have exactly one field";
        return;
    }
}

fn uri_display::derive_uri_display_query(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: &mut devise::DeriveGenerator;
    let mut _4: &mut devise::DeriveGenerator;
    let mut _5: &mut devise::DeriveGenerator;
    let mut _6: &mut devise::DeriveGenerator;
    let mut _7: &mut devise::DeriveGenerator;
    let mut _8: devise::DeriveGenerator;
    let mut _9: proc_macro::TokenStream;
    let mut _10: &proc_macro::TokenStream;
    let mut _11: proc_macro2::TokenStream;
    let mut _12: proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let mut _18: devise::Support;
    let mut _19: devise::Support;
    let mut _20: devise::Support;
    let mut _21: devise::ValidatorBuild;
    let mut _22: devise::ValidatorBuild;
    let mut _23: devise::ValidatorBuild;
    let mut _24: devise::ValidatorBuild;
    let mut _25: devise::MapperBuild;
    let mut _26: devise::MapperBuild;
    let mut _27: devise::MapperBuild;
    let mut _28: devise::MapperBuild;
    let mut _30: isize;
    let mut _34: proc_macro::TokenStream;
    let mut _35: &proc_macro::TokenStream;
    let mut _36: proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let mut _42: proc_macro::TokenStream;
    let mut _43: &proc_macro::TokenStream;
    let mut _44: proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let mut _55: proc_macro::TokenStream;
    let mut _56: &proc_macro::TokenStream;
    let mut _57: proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: &str;
    let _67: ();
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: &str;
    let mut _71: proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let mut _74: proc_macro2::TokenStream;
    let mut _75: proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let mut _78: proc_macro2::TokenStream;
    let mut _79: proc_macro2::TokenStream;
    let _80: ();
    let mut _81: &mut proc_macro2::TokenStream;
    let mut _82: proc_macro2::TokenStream;
    let mut _83: proc_macro2::TokenStream;
    let mut _84: proc_macro2::TokenStream;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: isize;
    scope 1 {
        debug uri_display => _2;
        let _29: proc_macro2::TokenStream;
        let _31: proc_macro2::TokenStream;
        let _32: devise::Diagnostic;
        scope 3 {
            debug uri_display => _29;
            let _33: proc_macro2::TokenStream;
            let mut _37: proc_macro2::TokenStream;
            scope 6 {
                debug from_self => _33;
                let _41: proc_macro2::TokenStream;
                let mut _45: proc_macro2::TokenStream;
                scope 8 {
                    debug from_ref => _41;
                    let _54: proc_macro2::TokenStream;
                    let mut _58: proc_macro2::TokenStream;
                    scope 10 {
                        debug from_mut => _54;
                        let mut _70: proc_macro2::TokenStream;
                        scope 12 {
                            debug ts => _70;
                        }
                    }
                    scope 11 {
                        debug _s => _58;
                    }
                }
                scope 9 {
                    debug _s => _45;
                }
            }
            scope 7 {
                debug _s => _37;
            }
        }
        scope 4 {
            debug tokens => _31;
        }
        scope 5 {
            debug diag => _32;
        }
    }
    scope 2 {
        debug _s => _12;
        let mut _85: &exports::StaticTokens;
    }

    bb0: {
        _96 = const false;
        _93 = const false;
        _91 = const false;
        _92 = const false;
        _89 = const false;
        _90 = const false;
        _87 = const false;
        _88 = const false;
        _86 = const false;
        _95 = const false;
        _94 = const false;
        _10 = &_1;
        _9 = <proc_macro::TokenStream as Clone>::clone(move _10) -> [return: bb1, unwind: bb59];
    }

    bb1: {
        _96 = const true;
        _12 = TokenStream2::new() -> [return: bb2, unwind: bb82];
    }

    bb2: {
        _14 = &mut _12;
        _15 = const "impl";
        _13 = push_ident(_14, _15) -> [return: bb3, unwind: bb58];
    }

    bb3: {
        _85 = const _;
        _17 = &mut _12;
        _16 = <exports::StaticTokens as ToTokens>::to_tokens(_85, _17) -> [return: bb4, unwind: bb58];
    }

    bb4: {
        _11 = move _12;
        _96 = const false;
        _8 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _9, move _11) -> [return: bb5, unwind: bb82];
    }

    bb5: {
        _7 = &mut _8;
        _96 = const false;
        _20 = <devise::Support as std::ops::BitOr>::bitor(const _, const _) -> [return: bb6, unwind: bb57];
    }

    bb6: {
        _19 = <devise::Support as std::ops::BitOr>::bitor(move _20, const _) -> [return: bb7, unwind: bb57];
    }

    bb7: {
        _18 = <devise::Support as std::ops::BitOr>::bitor(move _19, const _) -> [return: bb8, unwind: bb57];
    }

    bb8: {
        _6 = devise::DeriveGenerator::support(move _7, move _18) -> [return: bb9, unwind: bb57];
    }

    bb9: {
        _24 = devise::ValidatorBuild::new() -> [return: bb10, unwind: bb57];
    }

    bb10: {
        _23 = devise::ValidatorBuild::enum_validate::<{closure@core/codegen/src/derive/uri_display.rs:22:28: 22:37}>(move _24, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:22:28: 22:37}) -> [return: bb11, unwind: bb57];
    }

    bb11: {
        _22 = devise::ValidatorBuild::struct_validate::<{closure@core/codegen/src/derive/uri_display.rs:29:30: 29:39}>(move _23, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:29:30: 29:39}) -> [return: bb12, unwind: bb57];
    }

    bb12: {
        _21 = devise::ValidatorBuild::fields_validate::<{closure@core/codegen/src/derive/uri_display.rs:39:30: 39:41}>(move _22, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:39:30: 39:41}) -> [return: bb13, unwind: bb57];
    }

    bb13: {
        _5 = devise::DeriveGenerator::validator::<devise::ValidatorBuild>(_6, move _21) -> [return: bb14, unwind: bb57];
    }

    bb14: {
        _4 = devise::DeriveGenerator::type_bound::<exports::StaticTokens>(_5, const _) -> [return: bb15, unwind: bb57];
    }

    bb15: {
        _28 = devise::MapperBuild::new() -> [return: bb16, unwind: bb57];
    }

    bb16: {
        _27 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/uri_display.rs:49:26: 49:37}>(move _28, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:49:26: 49:37}) -> [return: bb17, unwind: bb57];
    }

    bb17: {
        _26 = devise::MapperBuild::try_variant_map::<{closure@core/codegen/src/derive/uri_display.rs:55:30: 55:47}>(move _27, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:55:30: 55:47}) -> [return: bb18, unwind: bb57];
    }

    bb18: {
        _25 = devise::MapperBuild::try_field_map::<{closure@core/codegen/src/derive/uri_display.rs:65:28: 65:38}>(move _26, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:65:28: 65:38}) -> [return: bb19, unwind: bb57];
    }

    bb19: {
        _3 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_4, move _25) -> [return: bb20, unwind: bb57];
    }

    bb20: {
        _2 = devise::DeriveGenerator::try_to_tokens::<TokenStream2>(_3) -> [return: bb21, unwind: bb57];
    }

    bb21: {
        _94 = const true;
        _95 = const true;
        drop(_8) -> [return: bb22, unwind: bb80];
    }

    bb22: {
        _30 = discriminant(_2);
        switchInt(move _30) -> [0: bb25, 1: bb23, otherwise: bb24];
    }

    bb23: {
        _95 = const false;
        _32 = move ((_2 as Err).0: devise::Diagnostic);
        _0 = devise::Diagnostic::emit_as_item_tokens(move _32) -> [return: bb26, unwind: bb80];
    }

    bb24: {
        unreachable;
    }

    bb25: {
        _94 = const false;
        _31 = move ((_2 as Ok).0: proc_macro2::TokenStream);
        _93 = const true;
        _29 = move _31;
        _35 = &_1;
        _34 = <proc_macro::TokenStream as Clone>::clone(move _35) -> [return: bb27, unwind: bb56];
    }

    bb26: {
        _93 = const false;
        _94 = const false;
        _95 = const false;
        drop(_1) -> [return: bb52, unwind continue];
    }

    bb27: {
        _92 = const true;
        _37 = TokenStream2::new() -> [return: bb28, unwind: bb74];
    }

    bb28: {
        _39 = &mut _37;
        _40 = const "Self";
        _38 = push_ident(_39, _40) -> [return: bb29, unwind: bb55];
    }

    bb29: {
        _36 = move _37;
        _92 = const false;
        _33 = uri_display::from_uri_param::<rocket_http::uri::fmt::Query>(move _34, move _36) -> [return: bb30, unwind: bb74];
    }

    bb30: {
        _91 = const true;
        _92 = const false;
        _43 = &_1;
        _42 = <proc_macro::TokenStream as Clone>::clone(move _43) -> [return: bb31, unwind: bb72];
    }

    bb31: {
        _90 = const true;
        _45 = TokenStream2::new() -> [return: bb32, unwind: bb70];
    }

    bb32: {
        _47 = &mut _45;
        _46 = push_and(_47) -> [return: bb33, unwind: bb54];
    }

    bb33: {
        _49 = &mut _45;
        _50 = const "'__r";
        _48 = push_lifetime(_49, _50) -> [return: bb34, unwind: bb54];
    }

    bb34: {
        _52 = &mut _45;
        _53 = const "Self";
        _51 = push_ident(_52, _53) -> [return: bb35, unwind: bb54];
    }

    bb35: {
        _44 = move _45;
        _90 = const false;
        _41 = uri_display::from_uri_param::<rocket_http::uri::fmt::Query>(move _42, move _44) -> [return: bb36, unwind: bb70];
    }

    bb36: {
        _89 = const true;
        _90 = const false;
        _56 = &_1;
        _55 = <proc_macro::TokenStream as Clone>::clone(move _56) -> [return: bb37, unwind: bb68];
    }

    bb37: {
        _88 = const true;
        _58 = TokenStream2::new() -> [return: bb38, unwind: bb66];
    }

    bb38: {
        _60 = &mut _58;
        _59 = push_and(_60) -> [return: bb39, unwind: bb53];
    }

    bb39: {
        _62 = &mut _58;
        _63 = const "'__r";
        _61 = push_lifetime(_62, _63) -> [return: bb40, unwind: bb53];
    }

    bb40: {
        _65 = &mut _58;
        _66 = const "mut";
        _64 = push_ident(_65, _66) -> [return: bb41, unwind: bb53];
    }

    bb41: {
        _68 = &mut _58;
        _69 = const "Self";
        _67 = push_ident(_68, _69) -> [return: bb42, unwind: bb53];
    }

    bb42: {
        _57 = move _58;
        _88 = const false;
        _54 = uri_display::from_uri_param::<rocket_http::uri::fmt::Query>(move _55, move _57) -> [return: bb43, unwind: bb66];
    }

    bb43: {
        _87 = const true;
        _88 = const false;
        _93 = const false;
        _71 = move _29;
        _70 = <TokenStream2 as From<TokenStream2>>::from(move _71) -> [return: bb44, unwind: bb64];
    }

    bb44: {
        _86 = const true;
        _73 = &mut _70;
        _91 = const false;
        _75 = move _33;
        _74 = <TokenStream2 as From<TokenStream2>>::from(move _75) -> [return: bb45, unwind: bb62];
    }

    bb45: {
        _72 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _73, move _74) -> [return: bb46, unwind: bb62];
    }

    bb46: {
        _77 = &mut _70;
        _89 = const false;
        _79 = move _41;
        _78 = <TokenStream2 as From<TokenStream2>>::from(move _79) -> [return: bb47, unwind: bb62];
    }

    bb47: {
        _76 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _77, move _78) -> [return: bb48, unwind: bb62];
    }

    bb48: {
        _81 = &mut _70;
        _87 = const false;
        _83 = move _54;
        _82 = <TokenStream2 as From<TokenStream2>>::from(move _83) -> [return: bb49, unwind: bb62];
    }

    bb49: {
        _80 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _81, move _82) -> [return: bb50, unwind: bb62];
    }

    bb50: {
        _86 = const false;
        _84 = move _70;
        _0 = <TokenStream2 as Into<TokenStream2>>::into(move _84) -> [return: bb51, unwind: bb62];
    }

    bb51: {
        _86 = const false;
        _87 = const false;
        _89 = const false;
        _91 = const false;
        _93 = const false;
        _94 = const false;
        _95 = const false;
        drop(_1) -> [return: bb52, unwind continue];
    }

    bb52: {
        return;
    }

    bb53 (cleanup): {
        drop(_58) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_45) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_37) -> [return: bb74, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        switchInt(_93) -> [0: bb80, otherwise: bb75];
    }

    bb57 (cleanup): {
        drop(_8) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_12) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_1) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        resume;
    }

    bb61 (cleanup): {
        drop(_70) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        switchInt(_86) -> [0: bb64, otherwise: bb61];
    }

    bb63 (cleanup): {
        drop(_54) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        switchInt(_87) -> [0: bb68, otherwise: bb63];
    }

    bb65 (cleanup): {
        drop(_55) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        switchInt(_88) -> [0: bb68, otherwise: bb65];
    }

    bb67 (cleanup): {
        drop(_41) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        switchInt(_89) -> [0: bb72, otherwise: bb67];
    }

    bb69 (cleanup): {
        drop(_42) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        switchInt(_90) -> [0: bb72, otherwise: bb69];
    }

    bb71 (cleanup): {
        drop(_33) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        switchInt(_91) -> [0: bb56, otherwise: bb71];
    }

    bb73 (cleanup): {
        drop(_34) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        switchInt(_92) -> [0: bb56, otherwise: bb73];
    }

    bb75 (cleanup): {
        drop(_29) -> [return: bb80, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        switchInt(_94) -> [0: bb59, otherwise: bb77];
    }

    bb77 (cleanup): {
        drop(((_2 as Ok).0: proc_macro2::TokenStream)) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb78 (cleanup): {
        switchInt(_95) -> [0: bb59, otherwise: bb79];
    }

    bb79 (cleanup): {
        drop(((_2 as Err).0: devise::Diagnostic)) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb80 (cleanup): {
        _97 = discriminant(_2);
        switchInt(move _97) -> [0: bb76, otherwise: bb78];
    }

    bb81 (cleanup): {
        drop(_9) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        switchInt(_96) -> [0: bb59, otherwise: bb81];
    }
}

promoted[0] in uri_display::derive_uri_display_query: &exports::StaticTokens = {
    let mut _0: &exports::StaticTokens;
    let mut _1: exports::StaticTokens;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const uri_display::derive_uri_display_query::URI_DISPLAY: exports::StaticTokens = {
    let mut _0: exports::StaticTokens;
    let mut _1: fn() -> proc_macro2::TokenStream;
    let mut _2: {closure@core/codegen/src/exports.rs:12:39: 12:41};

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = {closure@core/codegen/src/exports.rs:12:39: 12:41};
        _1 = move _2 as fn() -> proc_macro2::TokenStream (PointerCoercion(ClosureFnPointer(Normal)));
        StorageDead(_2);
        _0 = exports::StaticTokens(move _1);
        StorageDead(_1);
        return;
    }
}

fn uri_display::derive_uri_display_query::URI_DISPLAY::{closure#0}(_1: &{closure@core/codegen/src/exports.rs:12:39: 12:41}) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _2;
        let mut _21: &exports::StaticPath;
        let mut _22: &exports::StaticPath;
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const _;
        _4 = &mut _2;
        _3 = <StaticPath as ToTokens>::to_tokens(_22, _4) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = &mut _2;
        _5 = push_colon2(_6) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _8 = &mut _2;
        _9 = const "UriDisplay";
        _7 = push_ident(_8, _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = &mut _2;
        _10 = push_lt(_11) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _21 = const _;
        _13 = &mut _2;
        _12 = <StaticPath as ToTokens>::to_tokens(_21, _13) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _15 = &mut _2;
        _14 = push_colon2(_15) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _17 = &mut _2;
        _18 = const "Query";
        _16 = push_ident(_17, _18) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _20 = &mut _2;
        _19 = push_gt(_20) -> [return: bb9, unwind: bb10];
    }

    bb9: {
        _0 = move _2;
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_query::URI_DISPLAY::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in uri_display::derive_uri_display_query::URI_DISPLAY::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const uri_display::derive_uri_display_query::FORMATTER: exports::StaticTokens = {
    let mut _0: exports::StaticTokens;
    let mut _1: fn() -> proc_macro2::TokenStream;
    let mut _2: {closure@core/codegen/src/exports.rs:12:39: 12:41};

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = {closure@core/codegen/src/exports.rs:12:39: 12:41};
        _1 = move _2 as fn() -> proc_macro2::TokenStream (PointerCoercion(ClosureFnPointer(Normal)));
        StorageDead(_2);
        _0 = exports::StaticTokens(move _1);
        StorageDead(_1);
        return;
    }
}

fn uri_display::derive_uri_display_query::FORMATTER::{closure#0}(_1: &{closure@core/codegen/src/exports.rs:12:39: 12:41}) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _2;
        let mut _21: &exports::StaticPath;
        let mut _22: &exports::StaticPath;
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const _;
        _4 = &mut _2;
        _3 = <StaticPath as ToTokens>::to_tokens(_22, _4) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = &mut _2;
        _5 = push_colon2(_6) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _8 = &mut _2;
        _9 = const "Formatter";
        _7 = push_ident(_8, _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = &mut _2;
        _10 = push_lt(_11) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _21 = const _;
        _13 = &mut _2;
        _12 = <StaticPath as ToTokens>::to_tokens(_21, _13) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _15 = &mut _2;
        _14 = push_colon2(_15) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _17 = &mut _2;
        _18 = const "Query";
        _16 = push_ident(_17, _18) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _20 = &mut _2;
        _19 = push_gt(_20) -> [return: bb9, unwind: bb10];
    }

    bb9: {
        _0 = move _2;
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_query::FORMATTER::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in uri_display::derive_uri_display_query::FORMATTER::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn uri_display::derive_uri_display_query::{closure#0}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:22:28: 22:37}, _2: &mut devise::ValidatorBuild, _3: Derived<'_, ItemEnum>) -> std::result::Result<(), devise::Diagnostic> {
    debug data => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: usize;
    let mut _5: std::iter::Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@devise::Derived<'_, syn::ItemEnum>::variants::{closure#0}}>;
    let mut _6: devise::Derived<'_, syn::ItemEnum>;
    let mut _7: devise::Diagnostic;
    let mut _8: proc_macro2::Span;
    let mut _9: &syn::ItemEnum;
    let mut _10: &devise::Derived<'_, syn::ItemEnum>;

    bb0: {
        _6 = _3;
        _5 = Derived::<'_, ItemEnum>::variants(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Map<syn::punctuated::Iter<'_, syn::Variant>, {closure@Derived<'_, ItemEnum>::variants::{closure#0}}> as Iterator>::count(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb3, otherwise: bb6];
    }

    bb3: {
        _10 = &_3;
        _9 = <Derived<'_, ItemEnum> as std::ops::Deref>::deref(move _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = (((*_9).5: syn::token::Brace).0: proc_macro2::Span);
        _7 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _8, const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _7);
        goto -> bb7;
    }

    bb6: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn uri_display::derive_uri_display_query::{closure#1}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:29:30: 29:39}, _2: &mut devise::ValidatorBuild, _3: Derived<'_, ItemStruct>) -> std::result::Result<(), devise::Diagnostic> {
    debug data => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let _4: devise::Fields<'_>;
    let mut _5: devise::Derived<'_, syn::ItemStruct>;
    let mut _6: bool;
    let mut _7: devise::Diagnostic;
    let mut _8: proc_macro2::Span;
    let mut _9: &devise::Derived<'_, syn::ItemStruct>;
    let mut _10: bool;
    let mut _11: devise::Diagnostic;
    let mut _12: proc_macro2::Span;
    let mut _13: &devise::Derived<'_, syn::ItemStruct>;
    scope 1 {
        debug fields => _4;
    }

    bb0: {
        _5 = _3;
        _4 = Derived::<'_, ItemStruct>::fields(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = devise::Fields::<'_>::is_empty(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _6) -> [0: bb6, otherwise: bb3];
    }

    bb3: {
        _9 = &_3;
        _8 = <Derived<'_, ItemStruct> as devise::Spanned>::span(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _8, const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _7);
        goto -> bb12;
    }

    bb6: {
        _10 = devise::Fields::<'_>::are_unit(_4) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _10) -> [0: bb11, otherwise: bb8];
    }

    bb8: {
        _13 = &_3;
        _12 = <Derived<'_, ItemStruct> as devise::Spanned>::span(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _12, const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _11);
        goto -> bb12;
    }

    bb11: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn uri_display::derive_uri_display_query::{closure#2}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:39:30: 39:41}, _2: &mut devise::ValidatorBuild, _3: devise::Fields<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: devise::Fields<'_>;
    let mut _6: bool;
    let mut _7: usize;
    let mut _8: devise::Fields<'_>;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: &devise::Fields<'_>;

    bb0: {
        _5 = _3;
        _4 = devise::Fields::<'_>::are_unnamed(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _8 = _3;
        _7 = devise::Fields::<'_>::count(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = Gt(move _7, const 1_usize);
        switchInt(move _6) -> [0: bb7, otherwise: bb4];
    }

    bb4: {
        _11 = &_3;
        _10 = <devise::Fields<'_> as devise::Spanned>::span(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _10, const _) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _9);
        goto -> bb8;
    }

    bb7: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn uri_display::derive_uri_display_query::{closure#3}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:49:26: 49:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: &str;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: &str;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &str;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let mut _54: proc_macro2::Delimiter;
    let mut _55: proc_macro2::TokenStream;
    let _57: ();
    let _58: &proc_macro2::TokenStream;
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: &str;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let mut _65: proc_macro2::Delimiter;
    let mut _66: proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::Delimiter;
    let mut _71: proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _56: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _15;
            let mut _72: &exports::StaticTokens;
        }
        scope 3 {
            debug _s => _56;
            let mut _67: proc_macro2::TokenStream;
            scope 4 {
                debug _s => _67;
            }
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb34];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb33];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "fmt";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb33];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb33];
    }

    bb4: {
        _17 = &mut _15;
        _16 = push_and(_17) -> [return: bb5, unwind: bb32];
    }

    bb5: {
        _19 = &mut _15;
        _20 = const "self";
        _18 = push_ident(_19, _20) -> [return: bb6, unwind: bb32];
    }

    bb6: {
        _22 = &mut _15;
        _21 = push_comma(_22) -> [return: bb7, unwind: bb32];
    }

    bb7: {
        _24 = &mut _15;
        _25 = const "f";
        _23 = push_ident(_24, _25) -> [return: bb8, unwind: bb32];
    }

    bb8: {
        _27 = &mut _15;
        _26 = push_colon(_27) -> [return: bb9, unwind: bb32];
    }

    bb9: {
        _29 = &mut _15;
        _28 = push_and(_29) -> [return: bb10, unwind: bb32];
    }

    bb10: {
        _31 = &mut _15;
        _32 = const "mut";
        _30 = push_ident(_31, _32) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _72 = const _;
        _34 = &mut _15;
        _33 = <exports::StaticTokens as ToTokens>::to_tokens(_72, _34) -> [return: bb12, unwind: bb32];
    }

    bb12: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb13, unwind: bb33];
    }

    bb13: {
        _36 = &mut _4;
        _35 = push_rarrow(_36) -> [return: bb14, unwind: bb33];
    }

    bb14: {
        _38 = &mut _4;
        _37 = push_colon2(_38) -> [return: bb15, unwind: bb33];
    }

    bb15: {
        _40 = &mut _4;
        _41 = const "std";
        _39 = push_ident(_40, _41) -> [return: bb16, unwind: bb33];
    }

    bb16: {
        _43 = &mut _4;
        _42 = push_colon2(_43) -> [return: bb17, unwind: bb33];
    }

    bb17: {
        _45 = &mut _4;
        _46 = const "fmt";
        _44 = push_ident(_45, _46) -> [return: bb18, unwind: bb33];
    }

    bb18: {
        _48 = &mut _4;
        _47 = push_colon2(_48) -> [return: bb19, unwind: bb33];
    }

    bb19: {
        _50 = &mut _4;
        _51 = const "Result";
        _49 = push_ident(_50, _51) -> [return: bb20, unwind: bb33];
    }

    bb20: {
        _53 = &mut _4;
        _54 = proc_macro2::Delimiter::Brace;
        _56 = TokenStream2::new() -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _58 = &_3;
        _59 = &mut _56;
        _57 = <TokenStream2 as ToTokens>::to_tokens(_58, _59) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _61 = &mut _56;
        _62 = const "Ok";
        _60 = push_ident(_61, _62) -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _64 = &mut _56;
        _65 = proc_macro2::Delimiter::Parenthesis;
        _67 = TokenStream2::new() -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _69 = &mut _67;
        _70 = proc_macro2::Delimiter::Parenthesis;
        _71 = TokenStream2::new() -> [return: bb25, unwind: bb30];
    }

    bb25: {
        _68 = push_group(_69, move _70, move _71) -> [return: bb26, unwind: bb30];
    }

    bb26: {
        _66 = move _67;
        _63 = push_group(_64, move _65, move _66) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _55 = move _56;
        _52 = push_group(_53, move _54, move _55) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        _0 = move _4;
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_67) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_56) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_15) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_4) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_3) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_query::{closure#3}: &exports::StaticTokens = {
    let mut _0: &exports::StaticTokens;
    let mut _1: exports::StaticTokens;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn uri_display::derive_uri_display_query::{closure#4}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:55:30: 55:47}, _2: &mut devise::MapperBuild, _3: Derived<'_, syn::Variant, Derived<'_, ItemEnum>>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug mapper => _2;
    debug variant => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _4: bool;
    let mut _5: devise::Fields<'_>;
    let mut _6: devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _7: devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let _8: derive::form_field::FieldName;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, derive::form_field::FieldName>;
    let mut _10: std::result::Result<derive::form_field::FieldName, devise::Diagnostic>;
    let mut _11: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _14: derive::form_field::FieldName;
    let mut _15: proc_macro2::TokenStream;
    let mut _18: &devise::Derived<'_, syn::Variant, devise::Derived<'_, syn::ItemEnum>>;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &str;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let mut _29: proc_macro2::Delimiter;
    let mut _30: proc_macro2::TokenStream;
    let _32: ();
    let _33: &derive::form_field::FieldName;
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    scope 1 {
        debug value => _8;
        let mut _16: proc_macro2::TokenStream;
        scope 6 {
            debug _s => _16;
            let _17: proc_macro2::Span;
            scope 7 {
                debug _span => _17;
                let mut _31: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _31;
                    scope 9 {
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _6 = _3;
        _5 = Derived::<'_, syn::Variant, Derived<'_, ItemEnum>>::fields(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = devise::Fields::<'_>::is_empty(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _11 = &_3;
        _10 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as VariantExt>::first_form_field_value(move _11) -> [return: bb5, unwind continue];
    }

    bb4: {
        _7 = _3;
        _0 = devise::mapper::variant_default::<&mut devise::MapperBuild>(move _2, move _7) -> [return: bb20, unwind continue];
    }

    bb5: {
        _9 = <std::result::Result<FieldName, devise::Diagnostic> as std::ops::Try>::branch(move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _14 = move ((_9 as Continue).0: derive::form_field::FieldName);
        _8 = move _14;
        _16 = TokenStream2::new() -> [return: bb10, unwind: bb23];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _13) -> [return: bb20, unwind continue];
    }

    bb10: {
        _18 = &_3;
        _17 = <Derived<'_, syn::Variant, Derived<'_, ItemEnum>> as devise::Spanned>::span(move _18) -> [return: bb11, unwind: bb22];
    }

    bb11: {
        _20 = &mut _16;
        _21 = const "f";
        _19 = push_ident_spanned(_20, _17, _21) -> [return: bb12, unwind: bb22];
    }

    bb12: {
        _23 = &mut _16;
        _22 = push_dot_spanned(_23, _17) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _25 = &mut _16;
        _26 = const "write_value";
        _24 = push_ident_spanned(_25, _17, _26) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _28 = &mut _16;
        _29 = proc_macro2::Delimiter::Parenthesis;
        _31 = TokenStream2::new() -> [return: bb15, unwind: bb22];
    }

    bb15: {
        _33 = &_8;
        _34 = &mut _31;
        _32 = <FieldName as ToTokens>::to_tokens(_33, _34) -> [return: bb16, unwind: bb21];
    }

    bb16: {
        _30 = move _31;
        _27 = push_group_spanned(_28, _17, move _29, move _30) -> [return: bb17, unwind: bb22];
    }

    bb17: {
        _36 = &mut _16;
        _35 = push_question_spanned(_36, _17) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _38 = &mut _16;
        _37 = push_semi_spanned(_38, _17) -> [return: bb19, unwind: bb22];
    }

    bb19: {
        _15 = move _16;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _15);
        drop(_8) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        drop(_31) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_16) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_8) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        resume;
    }
}

fn uri_display::derive_uri_display_query::{closure#5}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:65:28: 65:38}, _2: &mut devise::MapperBuild, _3: devise::Field<'_>) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug field => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: proc_macro2::Span;
    let mut _5: proc_macro2::Span;
    let mut _6: &devise::Field<'_>;
    let mut _8: &devise::Field<'_>;
    let mut _10: bool;
    let mut _11: &std::option::Option<proc_macro2::Ident>;
    let _12: &syn::Field;
    let _13: &devise::Derived<'_, syn::Field, devise::FieldParent<'_>>;
    let mut _14: &devise::Field<'_>;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, derive::form_field::FieldName>;
    let mut _17: std::result::Result<derive::form_field::FieldName, devise::Diagnostic>;
    let mut _18: &devise::Field<'_>;
    let mut _19: isize;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _33: proc_macro2::Delimiter;
    let mut _34: proc_macro2::TokenStream;
    let _36: ();
    let _37: &derive::form_field::FieldName;
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let _44: &proc_macro2::TokenStream;
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: &str;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let mut _61: proc_macro2::Delimiter;
    let mut _62: proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let _67: &proc_macro2::TokenStream;
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let mut _73: proc_macro2::TokenStream;
    scope 1 {
        debug span => _4;
        let _7: proc_macro2::TokenStream;
        scope 2 {
            debug accessor => _7;
            let _9: proc_macro2::TokenStream;
            let _15: derive::form_field::FieldName;
            let _20: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
            let _21: derive::form_field::FieldName;
            let mut _50: proc_macro2::TokenStream;
            scope 3 {
                debug tokens => _9;
            }
            scope 4 {
                debug name => _15;
                let mut _22: proc_macro2::TokenStream;
                scope 9 {
                    debug _s => _22;
                    scope 10 {
                        debug _span => _4;
                        let mut _35: proc_macro2::TokenStream;
                        scope 11 {
                            debug _s => _35;
                            scope 12 {
                                debug _span => _4;
                            }
                        }
                    }
                }
            }
            scope 5 {
                debug residual => _20;
                scope 6 {
                }
            }
            scope 7 {
                debug val => _21;
                scope 8 {
                }
            }
            scope 13 {
                debug _s => _50;
                scope 14 {
                    debug _span => _4;
                    let mut _63: proc_macro2::TokenStream;
                    scope 15 {
                        debug _s => _63;
                        scope 16 {
                            debug _span => _4;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _6 = &_3;
        _5 = <devise::Field<'_> as devise::Spanned>::span(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &_3;
        _7 = devise::Field::<'_>::accessor(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _14 = &_3;
        _13 = <devise::Field<'_> as std::ops::Deref>::deref(move _14) -> [return: bb4, unwind: bb44];
    }

    bb4: {
        _12 = <Derived<'_, syn::Field, FieldParent<'_>> as std::ops::Deref>::deref(_13) -> [return: bb5, unwind: bb44];
    }

    bb5: {
        _11 = &((*_12).2: std::option::Option<proc_macro2::Ident>);
        _10 = Option::<proc_macro2::Ident>::is_some(move _11) -> [return: bb6, unwind: bb44];
    }

    bb6: {
        switchInt(move _10) -> [0: bb26, otherwise: bb7];
    }

    bb7: {
        _18 = &_3;
        _17 = <devise::Field<'_> as form_field::FieldExt>::first_field_name(move _18) -> [return: bb8, unwind: bb44];
    }

    bb8: {
        _16 = <std::result::Result<FieldName, devise::Diagnostic> as std::ops::Try>::branch(move _17) -> [return: bb9, unwind: bb44];
    }

    bb9: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb10, 1: bb12, otherwise: bb11];
    }

    bb10: {
        _21 = move ((_16 as Continue).0: derive::form_field::FieldName);
        _15 = move _21;
        _22 = TokenStream2::new() -> [return: bb14, unwind: bb43];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _20 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _20) -> [return: bb13, unwind: bb44];
    }

    bb13: {
        drop(_7) -> [return: bb38, unwind continue];
    }

    bb14: {
        _24 = &mut _22;
        _25 = const "f";
        _23 = push_ident_spanned(_24, _4, _25) -> [return: bb15, unwind: bb42];
    }

    bb15: {
        _27 = &mut _22;
        _26 = push_dot_spanned(_27, _4) -> [return: bb16, unwind: bb42];
    }

    bb16: {
        _29 = &mut _22;
        _30 = const "write_named_value";
        _28 = push_ident_spanned(_29, _4, _30) -> [return: bb17, unwind: bb42];
    }

    bb17: {
        _32 = &mut _22;
        _33 = proc_macro2::Delimiter::Parenthesis;
        _35 = TokenStream2::new() -> [return: bb18, unwind: bb42];
    }

    bb18: {
        _37 = &_15;
        _38 = &mut _35;
        _36 = <FieldName as ToTokens>::to_tokens(_37, _38) -> [return: bb19, unwind: bb41];
    }

    bb19: {
        _40 = &mut _35;
        _39 = push_comma_spanned(_40, _4) -> [return: bb20, unwind: bb41];
    }

    bb20: {
        _42 = &mut _35;
        _41 = push_and_spanned(_42, _4) -> [return: bb21, unwind: bb41];
    }

    bb21: {
        _44 = &_7;
        _45 = &mut _35;
        _43 = <TokenStream2 as ToTokens>::to_tokens(_44, _45) -> [return: bb22, unwind: bb41];
    }

    bb22: {
        _34 = move _35;
        _31 = push_group_spanned(_32, _4, move _33, move _34) -> [return: bb23, unwind: bb42];
    }

    bb23: {
        _47 = &mut _22;
        _46 = push_question_spanned(_47, _4) -> [return: bb24, unwind: bb42];
    }

    bb24: {
        _49 = &mut _22;
        _48 = push_semi_spanned(_49, _4) -> [return: bb25, unwind: bb42];
    }

    bb25: {
        _9 = move _22;
        drop(_15) -> [return: bb37, unwind: bb44];
    }

    bb26: {
        _50 = TokenStream2::new() -> [return: bb27, unwind: bb44];
    }

    bb27: {
        _52 = &mut _50;
        _53 = const "f";
        _51 = push_ident_spanned(_52, _4, _53) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _55 = &mut _50;
        _54 = push_dot_spanned(_55, _4) -> [return: bb29, unwind: bb40];
    }

    bb29: {
        _57 = &mut _50;
        _58 = const "write_value";
        _56 = push_ident_spanned(_57, _4, _58) -> [return: bb30, unwind: bb40];
    }

    bb30: {
        _60 = &mut _50;
        _61 = proc_macro2::Delimiter::Parenthesis;
        _63 = TokenStream2::new() -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _65 = &mut _63;
        _64 = push_and_spanned(_65, _4) -> [return: bb32, unwind: bb39];
    }

    bb32: {
        _67 = &_7;
        _68 = &mut _63;
        _66 = <TokenStream2 as ToTokens>::to_tokens(_67, _68) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        _62 = move _63;
        _59 = push_group_spanned(_60, _4, move _61, move _62) -> [return: bb34, unwind: bb40];
    }

    bb34: {
        _70 = &mut _50;
        _69 = push_question_spanned(_70, _4) -> [return: bb35, unwind: bb40];
    }

    bb35: {
        _72 = &mut _50;
        _71 = push_semi_spanned(_72, _4) -> [return: bb36, unwind: bb40];
    }

    bb36: {
        _9 = move _50;
        goto -> bb37;
    }

    bb37: {
        _73 = move _9;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _73);
        drop(_7) -> [return: bb38, unwind continue];
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_63) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_50) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_35) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_22) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_15) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_7) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        resume;
    }
}

fn uri_display::derive_uri_display_path(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: &mut devise::DeriveGenerator;
    let mut _4: &mut devise::DeriveGenerator;
    let mut _5: &mut devise::DeriveGenerator;
    let mut _6: &mut devise::DeriveGenerator;
    let mut _7: &mut devise::DeriveGenerator;
    let mut _8: devise::DeriveGenerator;
    let mut _9: proc_macro::TokenStream;
    let mut _10: &proc_macro::TokenStream;
    let mut _11: proc_macro2::TokenStream;
    let mut _12: proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let mut _18: devise::Support;
    let mut _19: devise::Support;
    let mut _20: devise::ValidatorBuild;
    let mut _21: devise::ValidatorBuild;
    let mut _22: devise::MapperBuild;
    let mut _23: devise::MapperBuild;
    let mut _24: devise::MapperBuild;
    let mut _26: isize;
    let mut _30: proc_macro::TokenStream;
    let mut _31: &proc_macro::TokenStream;
    let mut _32: proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: &str;
    let mut _38: proc_macro::TokenStream;
    let mut _39: &proc_macro::TokenStream;
    let mut _40: proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let mut _51: proc_macro::TokenStream;
    let mut _52: &proc_macro::TokenStream;
    let mut _53: proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: &str;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: &str;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: &str;
    let mut _67: proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::TokenStream;
    let mut _71: proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let mut _74: proc_macro2::TokenStream;
    let mut _75: proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let mut _78: proc_macro2::TokenStream;
    let mut _79: proc_macro2::TokenStream;
    let mut _80: proc_macro2::TokenStream;
    let mut _82: bool;
    let mut _83: bool;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: isize;
    scope 1 {
        debug uri_display => _2;
        let _25: proc_macro2::TokenStream;
        let _27: proc_macro2::TokenStream;
        let _28: devise::Diagnostic;
        scope 3 {
            debug uri_display => _25;
            let _29: proc_macro2::TokenStream;
            let mut _33: proc_macro2::TokenStream;
            scope 6 {
                debug from_self => _29;
                let _37: proc_macro2::TokenStream;
                let mut _41: proc_macro2::TokenStream;
                scope 8 {
                    debug from_ref => _37;
                    let _50: proc_macro2::TokenStream;
                    let mut _54: proc_macro2::TokenStream;
                    scope 10 {
                        debug from_mut => _50;
                        let mut _66: proc_macro2::TokenStream;
                        scope 12 {
                            debug ts => _66;
                        }
                    }
                    scope 11 {
                        debug _s => _54;
                    }
                }
                scope 9 {
                    debug _s => _41;
                }
            }
            scope 7 {
                debug _s => _33;
            }
        }
        scope 4 {
            debug tokens => _27;
        }
        scope 5 {
            debug diag => _28;
        }
    }
    scope 2 {
        debug _s => _12;
        let mut _81: &exports::StaticTokens;
    }

    bb0: {
        _92 = const false;
        _89 = const false;
        _87 = const false;
        _88 = const false;
        _85 = const false;
        _86 = const false;
        _83 = const false;
        _84 = const false;
        _82 = const false;
        _91 = const false;
        _90 = const false;
        _10 = &_1;
        _9 = <proc_macro::TokenStream as Clone>::clone(move _10) -> [return: bb1, unwind: bb55];
    }

    bb1: {
        _92 = const true;
        _12 = TokenStream2::new() -> [return: bb2, unwind: bb78];
    }

    bb2: {
        _14 = &mut _12;
        _15 = const "impl";
        _13 = push_ident(_14, _15) -> [return: bb3, unwind: bb54];
    }

    bb3: {
        _81 = const _;
        _17 = &mut _12;
        _16 = <exports::StaticTokens as ToTokens>::to_tokens(_81, _17) -> [return: bb4, unwind: bb54];
    }

    bb4: {
        _11 = move _12;
        _92 = const false;
        _8 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _9, move _11) -> [return: bb5, unwind: bb78];
    }

    bb5: {
        _7 = &mut _8;
        _92 = const false;
        _19 = <devise::Support as std::ops::BitOr>::bitor(const _, const _) -> [return: bb6, unwind: bb53];
    }

    bb6: {
        _18 = <devise::Support as std::ops::BitOr>::bitor(move _19, const _) -> [return: bb7, unwind: bb53];
    }

    bb7: {
        _6 = devise::DeriveGenerator::support(move _7, move _18) -> [return: bb8, unwind: bb53];
    }

    bb8: {
        _5 = devise::DeriveGenerator::type_bound::<exports::StaticTokens>(_6, const _) -> [return: bb9, unwind: bb53];
    }

    bb9: {
        _21 = devise::ValidatorBuild::new() -> [return: bb10, unwind: bb53];
    }

    bb10: {
        _20 = devise::ValidatorBuild::fields_validate::<{closure@core/codegen/src/derive/uri_display.rs:105:30: 105:41}>(move _21, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:105:30: 105:41}) -> [return: bb11, unwind: bb53];
    }

    bb11: {
        _4 = devise::DeriveGenerator::validator::<devise::ValidatorBuild>(_5, move _20) -> [return: bb12, unwind: bb53];
    }

    bb12: {
        _24 = devise::MapperBuild::new() -> [return: bb13, unwind: bb53];
    }

    bb13: {
        _23 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/uri_display.rs:111:26: 111:37}>(move _24, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:111:26: 111:37}) -> [return: bb14, unwind: bb53];
    }

    bb14: {
        _22 = devise::MapperBuild::field_map::<{closure@core/codegen/src/derive/uri_display.rs:117:24: 117:34}>(move _23, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:117:24: 117:34}) -> [return: bb15, unwind: bb53];
    }

    bb15: {
        _3 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_4, move _22) -> [return: bb16, unwind: bb53];
    }

    bb16: {
        _2 = devise::DeriveGenerator::try_to_tokens::<TokenStream2>(_3) -> [return: bb17, unwind: bb53];
    }

    bb17: {
        _90 = const true;
        _91 = const true;
        drop(_8) -> [return: bb18, unwind: bb76];
    }

    bb18: {
        _26 = discriminant(_2);
        switchInt(move _26) -> [0: bb21, 1: bb19, otherwise: bb20];
    }

    bb19: {
        _91 = const false;
        _28 = move ((_2 as Err).0: devise::Diagnostic);
        _0 = devise::Diagnostic::emit_as_item_tokens(move _28) -> [return: bb22, unwind: bb76];
    }

    bb20: {
        unreachable;
    }

    bb21: {
        _90 = const false;
        _27 = move ((_2 as Ok).0: proc_macro2::TokenStream);
        _89 = const true;
        _25 = move _27;
        _31 = &_1;
        _30 = <proc_macro::TokenStream as Clone>::clone(move _31) -> [return: bb23, unwind: bb52];
    }

    bb22: {
        _89 = const false;
        _90 = const false;
        _91 = const false;
        drop(_1) -> [return: bb48, unwind continue];
    }

    bb23: {
        _88 = const true;
        _33 = TokenStream2::new() -> [return: bb24, unwind: bb70];
    }

    bb24: {
        _35 = &mut _33;
        _36 = const "Self";
        _34 = push_ident(_35, _36) -> [return: bb25, unwind: bb51];
    }

    bb25: {
        _32 = move _33;
        _88 = const false;
        _29 = uri_display::from_uri_param::<rocket_http::uri::fmt::Path>(move _30, move _32) -> [return: bb26, unwind: bb70];
    }

    bb26: {
        _87 = const true;
        _88 = const false;
        _39 = &_1;
        _38 = <proc_macro::TokenStream as Clone>::clone(move _39) -> [return: bb27, unwind: bb68];
    }

    bb27: {
        _86 = const true;
        _41 = TokenStream2::new() -> [return: bb28, unwind: bb66];
    }

    bb28: {
        _43 = &mut _41;
        _42 = push_and(_43) -> [return: bb29, unwind: bb50];
    }

    bb29: {
        _45 = &mut _41;
        _46 = const "'__r";
        _44 = push_lifetime(_45, _46) -> [return: bb30, unwind: bb50];
    }

    bb30: {
        _48 = &mut _41;
        _49 = const "Self";
        _47 = push_ident(_48, _49) -> [return: bb31, unwind: bb50];
    }

    bb31: {
        _40 = move _41;
        _86 = const false;
        _37 = uri_display::from_uri_param::<rocket_http::uri::fmt::Path>(move _38, move _40) -> [return: bb32, unwind: bb66];
    }

    bb32: {
        _85 = const true;
        _86 = const false;
        _52 = &_1;
        _51 = <proc_macro::TokenStream as Clone>::clone(move _52) -> [return: bb33, unwind: bb64];
    }

    bb33: {
        _84 = const true;
        _54 = TokenStream2::new() -> [return: bb34, unwind: bb62];
    }

    bb34: {
        _56 = &mut _54;
        _55 = push_and(_56) -> [return: bb35, unwind: bb49];
    }

    bb35: {
        _58 = &mut _54;
        _59 = const "'__r";
        _57 = push_lifetime(_58, _59) -> [return: bb36, unwind: bb49];
    }

    bb36: {
        _61 = &mut _54;
        _62 = const "mut";
        _60 = push_ident(_61, _62) -> [return: bb37, unwind: bb49];
    }

    bb37: {
        _64 = &mut _54;
        _65 = const "Self";
        _63 = push_ident(_64, _65) -> [return: bb38, unwind: bb49];
    }

    bb38: {
        _53 = move _54;
        _84 = const false;
        _50 = uri_display::from_uri_param::<rocket_http::uri::fmt::Path>(move _51, move _53) -> [return: bb39, unwind: bb62];
    }

    bb39: {
        _83 = const true;
        _84 = const false;
        _89 = const false;
        _67 = move _25;
        _66 = <TokenStream2 as From<TokenStream2>>::from(move _67) -> [return: bb40, unwind: bb60];
    }

    bb40: {
        _82 = const true;
        _69 = &mut _66;
        _87 = const false;
        _71 = move _29;
        _70 = <TokenStream2 as From<TokenStream2>>::from(move _71) -> [return: bb41, unwind: bb58];
    }

    bb41: {
        _68 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _69, move _70) -> [return: bb42, unwind: bb58];
    }

    bb42: {
        _73 = &mut _66;
        _85 = const false;
        _75 = move _37;
        _74 = <TokenStream2 as From<TokenStream2>>::from(move _75) -> [return: bb43, unwind: bb58];
    }

    bb43: {
        _72 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _73, move _74) -> [return: bb44, unwind: bb58];
    }

    bb44: {
        _77 = &mut _66;
        _83 = const false;
        _79 = move _50;
        _78 = <TokenStream2 as From<TokenStream2>>::from(move _79) -> [return: bb45, unwind: bb58];
    }

    bb45: {
        _76 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _77, move _78) -> [return: bb46, unwind: bb58];
    }

    bb46: {
        _82 = const false;
        _80 = move _66;
        _0 = <TokenStream2 as Into<TokenStream2>>::into(move _80) -> [return: bb47, unwind: bb58];
    }

    bb47: {
        _82 = const false;
        _83 = const false;
        _85 = const false;
        _87 = const false;
        _89 = const false;
        _90 = const false;
        _91 = const false;
        drop(_1) -> [return: bb48, unwind continue];
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_54) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_41) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_33) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        switchInt(_89) -> [0: bb76, otherwise: bb71];
    }

    bb53 (cleanup): {
        drop(_8) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_12) -> [return: bb78, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_1) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        resume;
    }

    bb57 (cleanup): {
        drop(_66) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        switchInt(_82) -> [0: bb60, otherwise: bb57];
    }

    bb59 (cleanup): {
        drop(_50) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        switchInt(_83) -> [0: bb64, otherwise: bb59];
    }

    bb61 (cleanup): {
        drop(_51) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        switchInt(_84) -> [0: bb64, otherwise: bb61];
    }

    bb63 (cleanup): {
        drop(_37) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        switchInt(_85) -> [0: bb68, otherwise: bb63];
    }

    bb65 (cleanup): {
        drop(_38) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        switchInt(_86) -> [0: bb68, otherwise: bb65];
    }

    bb67 (cleanup): {
        drop(_29) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        switchInt(_87) -> [0: bb52, otherwise: bb67];
    }

    bb69 (cleanup): {
        drop(_30) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        switchInt(_88) -> [0: bb52, otherwise: bb69];
    }

    bb71 (cleanup): {
        drop(_25) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        switchInt(_90) -> [0: bb55, otherwise: bb73];
    }

    bb73 (cleanup): {
        drop(((_2 as Ok).0: proc_macro2::TokenStream)) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        switchInt(_91) -> [0: bb55, otherwise: bb75];
    }

    bb75 (cleanup): {
        drop(((_2 as Err).0: devise::Diagnostic)) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        _93 = discriminant(_2);
        switchInt(move _93) -> [0: bb72, otherwise: bb74];
    }

    bb77 (cleanup): {
        drop(_9) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb78 (cleanup): {
        switchInt(_92) -> [0: bb55, otherwise: bb77];
    }
}

promoted[0] in uri_display::derive_uri_display_path: &exports::StaticTokens = {
    let mut _0: &exports::StaticTokens;
    let mut _1: exports::StaticTokens;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const uri_display::derive_uri_display_path::URI_DISPLAY: exports::StaticTokens = {
    let mut _0: exports::StaticTokens;
    let mut _1: fn() -> proc_macro2::TokenStream;
    let mut _2: {closure@core/codegen/src/exports.rs:12:39: 12:41};

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = {closure@core/codegen/src/exports.rs:12:39: 12:41};
        _1 = move _2 as fn() -> proc_macro2::TokenStream (PointerCoercion(ClosureFnPointer(Normal)));
        StorageDead(_2);
        _0 = exports::StaticTokens(move _1);
        StorageDead(_1);
        return;
    }
}

fn uri_display::derive_uri_display_path::URI_DISPLAY::{closure#0}(_1: &{closure@core/codegen/src/exports.rs:12:39: 12:41}) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _2;
        let mut _21: &exports::StaticPath;
        let mut _22: &exports::StaticPath;
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const _;
        _4 = &mut _2;
        _3 = <StaticPath as ToTokens>::to_tokens(_22, _4) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = &mut _2;
        _5 = push_colon2(_6) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _8 = &mut _2;
        _9 = const "UriDisplay";
        _7 = push_ident(_8, _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = &mut _2;
        _10 = push_lt(_11) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _21 = const _;
        _13 = &mut _2;
        _12 = <StaticPath as ToTokens>::to_tokens(_21, _13) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _15 = &mut _2;
        _14 = push_colon2(_15) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _17 = &mut _2;
        _18 = const "Path";
        _16 = push_ident(_17, _18) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _20 = &mut _2;
        _19 = push_gt(_20) -> [return: bb9, unwind: bb10];
    }

    bb9: {
        _0 = move _2;
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_path::URI_DISPLAY::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in uri_display::derive_uri_display_path::URI_DISPLAY::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

const uri_display::derive_uri_display_path::FORMATTER: exports::StaticTokens = {
    let mut _0: exports::StaticTokens;
    let mut _1: fn() -> proc_macro2::TokenStream;
    let mut _2: {closure@core/codegen/src/exports.rs:12:39: 12:41};

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = {closure@core/codegen/src/exports.rs:12:39: 12:41};
        _1 = move _2 as fn() -> proc_macro2::TokenStream (PointerCoercion(ClosureFnPointer(Normal)));
        StorageDead(_2);
        _0 = exports::StaticTokens(move _1);
        StorageDead(_1);
        return;
    }
}

fn uri_display::derive_uri_display_path::FORMATTER::{closure#0}(_1: &{closure@core/codegen/src/exports.rs:12:39: 12:41}) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _2;
        let mut _21: &exports::StaticPath;
        let mut _22: &exports::StaticPath;
    }

    bb0: {
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const _;
        _4 = &mut _2;
        _3 = <StaticPath as ToTokens>::to_tokens(_22, _4) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _6 = &mut _2;
        _5 = push_colon2(_6) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _8 = &mut _2;
        _9 = const "Formatter";
        _7 = push_ident(_8, _9) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _11 = &mut _2;
        _10 = push_lt(_11) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _21 = const _;
        _13 = &mut _2;
        _12 = <StaticPath as ToTokens>::to_tokens(_21, _13) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _15 = &mut _2;
        _14 = push_colon2(_15) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _17 = &mut _2;
        _18 = const "Path";
        _16 = push_ident(_17, _18) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _20 = &mut _2;
        _19 = push_gt(_20) -> [return: bb9, unwind: bb10];
    }

    bb9: {
        _0 = move _2;
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_path::FORMATTER::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in uri_display::derive_uri_display_path::FORMATTER::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn uri_display::derive_uri_display_path::{closure#0}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:105:30: 105:41}, _2: &mut devise::ValidatorBuild, _3: devise::Fields<'_>) -> std::result::Result<(), devise::Diagnostic> {
    debug fields => _3;
    let mut _0: std::result::Result<(), devise::Diagnostic>;
    let mut _4: usize;
    let mut _5: devise::Fields<'_>;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro2::Span;
    let mut _8: &devise::Fields<'_>;

    bb0: {
        _5 = _3;
        _4 = devise::Fields::<'_>::count(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(_4) -> [1: bb3, otherwise: bb2];
    }

    bb2: {
        _8 = &_3;
        _7 = <devise::Fields<'_> as devise::Spanned>::span(move _8) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Ok(const ());
        goto -> bb6;
    }

    bb4: {
        _6 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _7, const _) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<(), devise::Diagnostic>::Err(move _6);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn uri_display::derive_uri_display_path::{closure#1}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:111:26: 111:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug output => _3;
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: &str;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: &str;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: &str;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &str;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let mut _54: proc_macro2::Delimiter;
    let mut _55: proc_macro2::TokenStream;
    let _57: ();
    let _58: &proc_macro2::TokenStream;
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: &str;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let mut _65: proc_macro2::Delimiter;
    let mut _66: proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::Delimiter;
    let mut _71: proc_macro2::TokenStream;
    scope 1 {
        debug _s => _4;
        let mut _15: proc_macro2::TokenStream;
        let mut _56: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _15;
            let mut _72: &exports::StaticTokens;
        }
        scope 3 {
            debug _s => _56;
            let mut _67: proc_macro2::TokenStream;
            scope 4 {
                debug _s => _67;
            }
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb34];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "fn";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb33];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "fmt";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb33];
    }

    bb3: {
        _12 = &mut _4;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb4, unwind: bb33];
    }

    bb4: {
        _17 = &mut _15;
        _16 = push_and(_17) -> [return: bb5, unwind: bb32];
    }

    bb5: {
        _19 = &mut _15;
        _20 = const "self";
        _18 = push_ident(_19, _20) -> [return: bb6, unwind: bb32];
    }

    bb6: {
        _22 = &mut _15;
        _21 = push_comma(_22) -> [return: bb7, unwind: bb32];
    }

    bb7: {
        _24 = &mut _15;
        _25 = const "f";
        _23 = push_ident(_24, _25) -> [return: bb8, unwind: bb32];
    }

    bb8: {
        _27 = &mut _15;
        _26 = push_colon(_27) -> [return: bb9, unwind: bb32];
    }

    bb9: {
        _29 = &mut _15;
        _28 = push_and(_29) -> [return: bb10, unwind: bb32];
    }

    bb10: {
        _31 = &mut _15;
        _32 = const "mut";
        _30 = push_ident(_31, _32) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _72 = const _;
        _34 = &mut _15;
        _33 = <exports::StaticTokens as ToTokens>::to_tokens(_72, _34) -> [return: bb12, unwind: bb32];
    }

    bb12: {
        _14 = move _15;
        _11 = push_group(_12, move _13, move _14) -> [return: bb13, unwind: bb33];
    }

    bb13: {
        _36 = &mut _4;
        _35 = push_rarrow(_36) -> [return: bb14, unwind: bb33];
    }

    bb14: {
        _38 = &mut _4;
        _37 = push_colon2(_38) -> [return: bb15, unwind: bb33];
    }

    bb15: {
        _40 = &mut _4;
        _41 = const "std";
        _39 = push_ident(_40, _41) -> [return: bb16, unwind: bb33];
    }

    bb16: {
        _43 = &mut _4;
        _42 = push_colon2(_43) -> [return: bb17, unwind: bb33];
    }

    bb17: {
        _45 = &mut _4;
        _46 = const "fmt";
        _44 = push_ident(_45, _46) -> [return: bb18, unwind: bb33];
    }

    bb18: {
        _48 = &mut _4;
        _47 = push_colon2(_48) -> [return: bb19, unwind: bb33];
    }

    bb19: {
        _50 = &mut _4;
        _51 = const "Result";
        _49 = push_ident(_50, _51) -> [return: bb20, unwind: bb33];
    }

    bb20: {
        _53 = &mut _4;
        _54 = proc_macro2::Delimiter::Brace;
        _56 = TokenStream2::new() -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _58 = &_3;
        _59 = &mut _56;
        _57 = <TokenStream2 as ToTokens>::to_tokens(_58, _59) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _61 = &mut _56;
        _62 = const "Ok";
        _60 = push_ident(_61, _62) -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _64 = &mut _56;
        _65 = proc_macro2::Delimiter::Parenthesis;
        _67 = TokenStream2::new() -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _69 = &mut _67;
        _70 = proc_macro2::Delimiter::Parenthesis;
        _71 = TokenStream2::new() -> [return: bb25, unwind: bb30];
    }

    bb25: {
        _68 = push_group(_69, move _70, move _71) -> [return: bb26, unwind: bb30];
    }

    bb26: {
        _66 = move _67;
        _63 = push_group(_64, move _65, move _66) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _55 = move _56;
        _52 = push_group(_53, move _54, move _55) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        _0 = move _4;
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_67) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_56) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_15) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_4) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_3) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }
}

promoted[0] in uri_display::derive_uri_display_path::{closure#1}: &exports::StaticTokens = {
    let mut _0: &exports::StaticTokens;
    let mut _1: exports::StaticTokens;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn uri_display::derive_uri_display_path::{closure#2}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:117:24: 117:34}, _2: &mut devise::MapperBuild, _3: devise::Field<'_>) -> TokenStream2 {
    debug field => _3;
    let mut _0: proc_macro2::TokenStream;
    let _4: proc_macro2::TokenStream;
    let mut _5: &devise::Field<'_>;
    let mut _8: &devise::Field<'_>;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: &str;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let mut _19: proc_macro2::Delimiter;
    let mut _20: proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let _25: &proc_macro2::TokenStream;
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    scope 1 {
        debug accessor => _4;
        let mut _6: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _6;
            let _7: proc_macro2::Span;
            scope 3 {
                debug _span => _7;
                let mut _21: proc_macro2::TokenStream;
                scope 4 {
                    debug _s => _21;
                    scope 5 {
                        debug _span => _7;
                    }
                }
            }
        }
    }

    bb0: {
        _5 = &_3;
        _4 = devise::Field::<'_>::accessor(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = TokenStream2::new() -> [return: bb2, unwind: bb16];
    }

    bb2: {
        _8 = &_3;
        _7 = <devise::Field<'_> as devise::Spanned>::span(move _8) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _10 = &mut _6;
        _11 = const "f";
        _9 = push_ident_spanned(_10, _7, _11) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _13 = &mut _6;
        _12 = push_dot_spanned(_13, _7) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _15 = &mut _6;
        _16 = const "write_value";
        _14 = push_ident_spanned(_15, _7, _16) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _18 = &mut _6;
        _19 = proc_macro2::Delimiter::Parenthesis;
        _21 = TokenStream2::new() -> [return: bb7, unwind: bb15];
    }

    bb7: {
        _23 = &mut _21;
        _22 = push_and_spanned(_23, _7) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _25 = &_4;
        _26 = &mut _21;
        _24 = <TokenStream2 as ToTokens>::to_tokens(_25, _26) -> [return: bb9, unwind: bb14];
    }

    bb9: {
        _20 = move _21;
        _17 = push_group_spanned(_18, _7, move _19, move _20) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _28 = &mut _6;
        _27 = push_question_spanned(_28, _7) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _30 = &mut _6;
        _29 = push_semi_spanned(_30, _7) -> [return: bb12, unwind: bb15];
    }

    bb12: {
        _0 = move _6;
        drop(_4) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_21) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_6) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_4) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn uri_display::from_uri_param(_1: proc_macro::TokenStream, _2: TokenStream2) -> TokenStream2 {
    debug input => _1;
    debug ty => _2;
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::uri::fmt::Kind;
    let mut _5: isize;
    let mut _6: proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let mut _14: proc_macro2::TokenStream;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &str;
    let mut _23: std::result::Result<syn::Type, syn::Error>;
    let mut _24: proc_macro2::TokenStream;
    let _25: &str;
    let mut _27: isize;
    let mut _29: std::option::Option<&syn::Lifetime>;
    let mut _30: &std::option::Option<syn::Lifetime>;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let _37: &std::option::Option<proc_macro2::TokenStream>;
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let _49: &proc_macro2::TokenStream;
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let _54: &syn::Type;
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let mut _58: &mut devise::DeriveGenerator;
    let mut _59: &mut devise::DeriveGenerator;
    let mut _60: &mut devise::DeriveGenerator;
    let mut _61: &mut devise::DeriveGenerator;
    let mut _62: devise::DeriveGenerator;
    let mut _63: proc_macro::TokenStream;
    let mut _64: proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: ();
    let _76: &proc_macro2::TokenStream;
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let mut _80: devise::MapperBuild;
    let mut _81: devise::MapperBuild;
    let mut _82: {closure@core/codegen/src/derive/uri_display.rs:157:26: 157:37};
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    scope 1 {
        debug part => _3;
        let _22: syn::Type;
        scope 4 {
            debug ty => _22;
            let _26: std::option::Option<proc_macro2::TokenStream>;
            let _28: &syn::TypeReference;
            scope 5 {
                debug gen => _26;
                let _31: proc_macro2::TokenStream;
                let mut _32: proc_macro2::TokenStream;
                scope 7 {
                    debug param_trait => _31;
                    let mut _65: proc_macro2::TokenStream;
                    scope 9 {
                        debug _s => _65;
                        let mut _83: &exports::StaticPath;
                    }
                }
                scope 8 {
                    debug _s => _32;
                    let mut _84: &exports::StaticPath;
                }
            }
            scope 6 {
                debug r => _28;
            }
        }
    }
    scope 2 {
        debug _s => _6;
        let mut _86: &exports::StaticPath;
    }
    scope 3 {
        debug _s => _14;
        let mut _85: &exports::StaticPath;
    }

    bb0: {
        _89 = const false;
        _88 = const false;
        _87 = const false;
        _89 = const true;
        _88 = const true;
        _4 = const _;
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _14 = TokenStream2::new() -> [return: bb8, unwind: bb62];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _6 = TokenStream2::new() -> [return: bb4, unwind: bb62];
    }

    bb4: {
        _86 = const _;
        _8 = &mut _6;
        _7 = <StaticPath as ToTokens>::to_tokens(_86, _8) -> [return: bb5, unwind: bb56];
    }

    bb5: {
        _10 = &mut _6;
        _9 = push_colon2(_10) -> [return: bb6, unwind: bb56];
    }

    bb6: {
        _12 = &mut _6;
        _13 = const "Path";
        _11 = push_ident(_12, _13) -> [return: bb7, unwind: bb56];
    }

    bb7: {
        _3 = move _6;
        goto -> bb12;
    }

    bb8: {
        _85 = const _;
        _16 = &mut _14;
        _15 = <StaticPath as ToTokens>::to_tokens(_85, _16) -> [return: bb9, unwind: bb55];
    }

    bb9: {
        _18 = &mut _14;
        _17 = push_colon2(_18) -> [return: bb10, unwind: bb55];
    }

    bb10: {
        _20 = &mut _14;
        _21 = const "Query";
        _19 = push_ident(_20, _21) -> [return: bb11, unwind: bb55];
    }

    bb11: {
        _3 = move _14;
        goto -> bb12;
    }

    bb12: {
        _88 = const false;
        _24 = move _2;
        _23 = syn::parse2::<syn::Type>(move _24) -> [return: bb13, unwind: bb54];
    }

    bb13: {
        _25 = const "valid type";
        _22 = std::result::Result::<syn::Type, syn::Error>::expect(move _23, _25) -> [return: bb14, unwind: bb54];
    }

    bb14: {
        _87 = const true;
        _27 = discriminant(_22);
        switchInt(move _27) -> [10: bb16, otherwise: bb15];
    }

    bb15: {
        _26 = Option::<TokenStream2>::None;
        goto -> bb18;
    }

    bb16: {
        _28 = &((_22 as Reference).0: syn::TypeReference);
        _30 = &((*_28).1: std::option::Option<syn::Lifetime>);
        _29 = Option::<syn::Lifetime>::as_ref(move _30) -> [return: bb17, unwind: bb53];
    }

    bb17: {
        _26 = Option::<&syn::Lifetime>::map::<TokenStream2, {closure@core/codegen/src/derive/uri_display.rs:148:64: 148:67}>(move _29, const ZeroSized: {closure@core/codegen/src/derive/uri_display.rs:148:64: 148:67}) -> [return: bb64, unwind: bb53];
    }

    bb18: {
        _32 = TokenStream2::new() -> [return: bb19, unwind: bb52];
    }

    bb19: {
        _34 = &mut _32;
        _35 = const "impl";
        _33 = push_ident(_34, _35) -> [return: bb20, unwind: bb51];
    }

    bb20: {
        _37 = &_26;
        _38 = &mut _32;
        _36 = <Option<TokenStream2> as ToTokens>::to_tokens(_37, _38) -> [return: bb21, unwind: bb51];
    }

    bb21: {
        _84 = const _;
        _40 = &mut _32;
        _39 = <StaticPath as ToTokens>::to_tokens(_84, _40) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        _42 = &mut _32;
        _41 = push_colon2(_42) -> [return: bb23, unwind: bb51];
    }

    bb23: {
        _44 = &mut _32;
        _45 = const "FromUriParam";
        _43 = push_ident(_44, _45) -> [return: bb24, unwind: bb51];
    }

    bb24: {
        _47 = &mut _32;
        _46 = push_lt(_47) -> [return: bb25, unwind: bb51];
    }

    bb25: {
        _49 = &_3;
        _50 = &mut _32;
        _48 = <TokenStream2 as ToTokens>::to_tokens(_49, _50) -> [return: bb26, unwind: bb51];
    }

    bb26: {
        _52 = &mut _32;
        _51 = push_comma(_52) -> [return: bb27, unwind: bb51];
    }

    bb27: {
        _54 = &_22;
        _55 = &mut _32;
        _53 = <syn::Type as ToTokens>::to_tokens(_54, _55) -> [return: bb28, unwind: bb51];
    }

    bb28: {
        _57 = &mut _32;
        _56 = push_gt(_57) -> [return: bb29, unwind: bb51];
    }

    bb29: {
        _31 = move _32;
        _89 = const false;
        _63 = move _1;
        _62 = devise::DeriveGenerator::build_for::<proc_macro::TokenStream, TokenStream2>(move _63, move _31) -> [return: bb30, unwind: bb52];
    }

    bb30: {
        _61 = &mut _62;
        _60 = devise::DeriveGenerator::support(move _61, const _) -> [return: bb31, unwind: bb48];
    }

    bb31: {
        _65 = TokenStream2::new() -> [return: bb32, unwind: bb48];
    }

    bb32: {
        _83 = const _;
        _67 = &mut _65;
        _66 = <StaticPath as ToTokens>::to_tokens(_83, _67) -> [return: bb33, unwind: bb47];
    }

    bb33: {
        _69 = &mut _65;
        _68 = push_colon2(_69) -> [return: bb34, unwind: bb47];
    }

    bb34: {
        _71 = &mut _65;
        _72 = const "UriDisplay";
        _70 = push_ident(_71, _72) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _74 = &mut _65;
        _73 = push_lt(_74) -> [return: bb36, unwind: bb47];
    }

    bb36: {
        _76 = &_3;
        _77 = &mut _65;
        _75 = <TokenStream2 as ToTokens>::to_tokens(_76, _77) -> [return: bb37, unwind: bb47];
    }

    bb37: {
        _79 = &mut _65;
        _78 = push_gt(_79) -> [return: bb38, unwind: bb47];
    }

    bb38: {
        _64 = move _65;
        _59 = devise::DeriveGenerator::type_bound::<TokenStream2>(_60, move _64) -> [return: bb39, unwind: bb48];
    }

    bb39: {
        _81 = devise::MapperBuild::new() -> [return: bb40, unwind: bb48];
    }

    bb40: {
        _87 = const false;
        _82 = {closure@core/codegen/src/derive/uri_display.rs:157:26: 157:37} { ty: move _22 };
        _80 = devise::MapperBuild::with_output::<{closure@core/codegen/src/derive/uri_display.rs:157:26: 157:37}>(move _81, move _82) -> [return: bb41, unwind: bb48];
    }

    bb41: {
        _58 = devise::DeriveGenerator::inner_mapper::<devise::MapperBuild>(_59, move _80) -> [return: bb42, unwind: bb48];
    }

    bb42: {
        _0 = devise::DeriveGenerator::to_tokens::<TokenStream2>(_58) -> [return: bb43, unwind: bb48];
    }

    bb43: {
        drop(_26) -> [return: bb44, unwind: bb60];
    }

    bb44: {
        _87 = const false;
        drop(_3) -> [return: bb45, unwind: bb50];
    }

    bb45: {
        drop(_62) -> [return: bb46, unwind: bb62];
    }

    bb46: {
        return;
    }

    bb47 (cleanup): {
        drop(_65) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        drop(_26) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_3) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_62) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_32) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_26) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_22) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_3) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_14) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_6) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        switchInt(_89) -> [0: bb58, otherwise: bb63];
    }

    bb58 (cleanup): {
        resume;
    }

    bb59 (cleanup): {
        drop(_22) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        switchInt(_87) -> [0: bb49, otherwise: bb59];
    }

    bb61 (cleanup): {
        drop(_2) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        switchInt(_88) -> [0: bb57, otherwise: bb61];
    }

    bb63 (cleanup): {
        drop(_1) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb64: {
        goto -> bb18;
    }
}

promoted[0] in uri_display::from_uri_param: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in uri_display::from_uri_param: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in uri_display::from_uri_param: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in uri_display::from_uri_param: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn uri_display::from_uri_param::{closure#0}(_1: {closure@core/codegen/src/derive/uri_display.rs:148:64: 148:67}, _2: &syn::Lifetime) -> TokenStream2 {
    debug l => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let _4: ();
    let mut _5: &mut proc_macro2::TokenStream;
    let _6: ();
    let _7: &&syn::Lifetime;
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _3;
        _4 = push_lt(_5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = &_2;
        _8 = &mut _3;
        _6 = <&syn::Lifetime as ToTokens>::to_tokens(_7, _8) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _10 = &mut _3;
        _9 = push_gt(_10) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = move _3;
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn uri_display::from_uri_param::{closure#1}(_1: &mut {closure@core/codegen/src/derive/uri_display.rs:157:26: 157:37}, _2: &mut devise::MapperBuild, _3: TokenStream2) -> TokenStream2 {
    debug ty => ((*_1).0: syn::Type);
    let mut _0: proc_macro2::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let _5: ();
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: &str;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let _14: &syn::Type;
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let mut _22: proc_macro2::Delimiter;
    let mut _23: proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let mut _30: proc_macro2::Delimiter;
    let mut _31: proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: &str;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let mut _44: proc_macro2::Delimiter;
    let mut _45: proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let _53: &syn::Type;
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let _58: &syn::Type;
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: proc_macro2::Delimiter;
    let mut _63: proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    scope 1 {
        debug _s => _4;
        let mut _24: proc_macro2::TokenStream;
        let mut _46: proc_macro2::TokenStream;
        let mut _64: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _24;
            let mut _32: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _32;
            }
        }
        scope 4 {
            debug _s => _46;
        }
        scope 5 {
            debug _s => _64;
        }
    }

    bb0: {
        _4 = TokenStream2::new() -> [return: bb1, unwind: bb32];
    }

    bb1: {
        _6 = &mut _4;
        _7 = const "type";
        _5 = push_ident(_6, _7) -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _9 = &mut _4;
        _10 = const "Target";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _12 = &mut _4;
        _11 = push_eq(_12) -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _14 = &((*_1).0: syn::Type);
        _15 = &mut _4;
        _13 = <syn::Type as ToTokens>::to_tokens(_14, _15) -> [return: bb5, unwind: bb31];
    }

    bb5: {
        _17 = &mut _4;
        _16 = push_semi(_17) -> [return: bb6, unwind: bb31];
    }

    bb6: {
        _19 = &mut _4;
        _18 = push_pound(_19) -> [return: bb7, unwind: bb31];
    }

    bb7: {
        _21 = &mut _4;
        _22 = proc_macro2::Delimiter::Bracket;
        _24 = TokenStream2::new() -> [return: bb8, unwind: bb31];
    }

    bb8: {
        _26 = &mut _24;
        _27 = const "inline";
        _25 = push_ident(_26, _27) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _29 = &mut _24;
        _30 = proc_macro2::Delimiter::Parenthesis;
        _32 = TokenStream2::new() -> [return: bb10, unwind: bb30];
    }

    bb10: {
        _34 = &mut _32;
        _35 = const "always";
        _33 = push_ident(_34, _35) -> [return: bb11, unwind: bb29];
    }

    bb11: {
        _31 = move _32;
        _28 = push_group(_29, move _30, move _31) -> [return: bb12, unwind: bb30];
    }

    bb12: {
        _23 = move _24;
        _20 = push_group(_21, move _22, move _23) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _37 = &mut _4;
        _38 = const "fn";
        _36 = push_ident(_37, _38) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _40 = &mut _4;
        _41 = const "from_uri_param";
        _39 = push_ident(_40, _41) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _43 = &mut _4;
        _44 = proc_macro2::Delimiter::Parenthesis;
        _46 = TokenStream2::new() -> [return: bb16, unwind: bb31];
    }

    bb16: {
        _48 = &mut _46;
        _49 = const "_p";
        _47 = push_ident(_48, _49) -> [return: bb17, unwind: bb28];
    }

    bb17: {
        _51 = &mut _46;
        _50 = push_colon(_51) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _53 = &((*_1).0: syn::Type);
        _54 = &mut _46;
        _52 = <syn::Type as ToTokens>::to_tokens(_53, _54) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _45 = move _46;
        _42 = push_group(_43, move _44, move _45) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _56 = &mut _4;
        _55 = push_rarrow(_56) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        _58 = &((*_1).0: syn::Type);
        _59 = &mut _4;
        _57 = <syn::Type as ToTokens>::to_tokens(_58, _59) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _61 = &mut _4;
        _62 = proc_macro2::Delimiter::Brace;
        _64 = TokenStream2::new() -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _66 = &mut _64;
        _67 = const "_p";
        _65 = push_ident(_66, _67) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        _63 = move _64;
        _60 = push_group(_61, move _62, move _63) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _0 = move _4;
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_64) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_46) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_32) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_24) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_4) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_3) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }
}

const main::<impl at core/codegen/src/attribute/entry/main.rs:10:1: 10:24>::REQUIRES_ASYNC: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn main::<impl at core/codegen/src/attribute/entry/main.rs:10:1: 10:24>::function(_1: &mut ItemFn) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: &std::vec::Vec<syn::Attribute>;
    let _3: &syn::Visibility;
    let _4: &std::boxed::Box<syn::Block>;
    let _5: &mut syn::Signature;
    let mut _6: (&std::vec::Vec<syn::Attribute>, &syn::Visibility, &std::boxed::Box<syn::Block>, &mut syn::Signature);
    let mut _7: &std::vec::Vec<syn::Attribute>;
    let mut _8: &syn::Visibility;
    let mut _9: &std::boxed::Box<syn::Block>;
    let mut _10: &mut syn::Signature;
    let mut _11: bool;
    let mut _12: &proc_macro2::Ident;
    let _13: proc_macro2::TokenStream;
    let mut _14: devise::Diagnostic;
    let mut _15: devise::Diagnostic;
    let mut _16: proc_macro2::Span;
    let mut _17: proc_macro2::Span;
    let mut _18: &proc_macro2::Ident;
    let mut _19: std::option::Option<syn::token::Async>;
    let mut _20: proc_macro2::TokenStream;
    let mut _23: proc_macro2::Span;
    let mut _24: &std::boxed::Box<syn::Block>;
    let mut _26: (std::slice::Iter<'_, syn::Attribute>, quote::__private::HasIterator);
    let mut _28: bool;
    let mut _30: std::option::Option<&syn::Attribute>;
    let mut _31: &mut std::slice::Iter<'_, syn::Attribute>;
    let mut _32: isize;
    let _34: ();
    let _35: &quote::__private::RepInterp<&syn::Attribute>;
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let _38: &&syn::Visibility;
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let _41: &&mut syn::Signature;
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let mut _45: proc_macro2::Delimiter;
    let mut _46: proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: &str;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let mut _60: proc_macro2::Delimiter;
    let mut _61: proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: &str;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let _70: &&std::boxed::Box<syn::Block>;
    let mut _71: &mut proc_macro2::TokenStream;
    let mut _73: bool;
    scope 1 {
        debug attrs => _2;
        debug vis => _3;
        debug block => _4;
        debug sig => _5;
        let mut _21: proc_macro2::TokenStream;
        let mut _72: &&str;
        scope 2 {
            debug _s => _21;
            let _22: proc_macro2::Span;
            scope 3 {
                debug _span => _22;
                let mut _47: proc_macro2::TokenStream;
                scope 4 {
                    debug has_iter => const ThereIsNoIteratorInRepetition;
                    scope 5 {
                        debug attrs => _25;
                        debug i => const HasIterator;
                        let _27: quote::__private::HasIterator;
                        scope 7 {
                            debug has_iter => const HasIterator;
                            scope 8 {
                                let _29: quote::__private::RepInterp<&syn::Attribute>;
                                let _33: &syn::Attribute;
                                scope 9 {
                                    debug attrs => _29;
                                }
                                scope 10 {
                                    debug _x => _33;
                                }
                            }
                        }
                    }
                    scope 6 {
                        let mut _25: std::slice::Iter<'_, syn::Attribute>;
                    }
                }
                scope 11 {
                    debug _s => _47;
                    scope 12 {
                        debug _span => _22;
                        let mut _62: proc_macro2::TokenStream;
                        scope 13 {
                            debug _s => _62;
                            scope 14 {
                                debug _span => _22;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _73 = const false;
        _7 = &((*_1).0: std::vec::Vec<syn::Attribute>);
        _8 = &((*_1).1: syn::Visibility);
        _9 = &((*_1).3: std::boxed::Box<syn::Block>);
        _10 = &mut ((*_1).2: syn::Signature);
        _6 = (move _7, move _8, move _9, move _10);
        _2 = (_6.0: &std::vec::Vec<syn::Attribute>);
        _3 = (_6.1: &syn::Visibility);
        _4 = (_6.2: &std::boxed::Box<syn::Block>);
        _5 = move (_6.3: &mut syn::Signature);
        _12 = &((*_5).5: proc_macro2::Ident);
        _72 = const _;
        _11 = <proc_macro2::Ident as PartialEq<&str>>::ne(move _12, _72) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _11) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _16 = proc_macro2::Span::call_site() -> [return: bb3, unwind continue];
    }

    bb3: {
        _73 = const true;
        _15 = <proc_macro2::Span as SpanDiagnosticExt>::warning::<&str>(move _16, const "attribute is typically applied to `main` function") -> [return: bb4, unwind continue];
    }

    bb4: {
        _18 = &((*_5).5: proc_macro2::Ident);
        _17 = proc_macro2::Ident::span(move _18) -> [return: bb5, unwind: bb37];
    }

    bb5: {
        _73 = const false;
        _14 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _15, move _17, const "this function is not `main`") -> [return: bb6, unwind: bb37];
    }

    bb6: {
        _73 = const false;
        _13 = devise::Diagnostic::emit_as_item_tokens(move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        drop(_13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _19 = Option::<syn::token::Async>::None;
        ((*_5).1: std::option::Option<syn::token::Async>) = move _19;
        _21 = TokenStream2::new() -> [return: bb9, unwind continue];
    }

    bb9: {
        _24 = _4;
        _23 = <std::boxed::Box<syn::Block> as devise::Spanned>::span(move _24) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _22 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _23) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _26 = <Vec<syn::Attribute> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(_2) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _25 = move (_26.0: std::slice::Iter<'_, syn::Attribute>);
        _27 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb38, unwind: bb34];
    }

    bb13: {
        _28 = const true;
        switchInt(move _28) -> [0: bb18, otherwise: bb14];
    }

    bb14: {
        _31 = &mut _25;
        _30 = <std::slice::Iter<'_, syn::Attribute> as Iterator>::next(move _31) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb18, 1: bb17, otherwise: bb16];
    }

    bb16: {
        unreachable;
    }

    bb17: {
        _33 = ((_30 as Some).0: &syn::Attribute);
        _29 = RepInterp::<&syn::Attribute>(_33);
        _35 = &_29;
        _36 = &mut _21;
        _34 = <RepInterp<&syn::Attribute> as ToTokens>::to_tokens(_35, _36) -> [return: bb39, unwind: bb34];
    }

    bb18: {
        _38 = &_3;
        _39 = &mut _21;
        _37 = <&Visibility as ToTokens>::to_tokens(_38, _39) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _41 = &_5;
        _42 = &mut _21;
        _40 = <&mut Signature as ToTokens>::to_tokens(_41, _42) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _44 = &mut _21;
        _45 = proc_macro2::Delimiter::Brace;
        _47 = TokenStream2::new() -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _49 = &mut _47;
        _48 = push_colon2_spanned(_49, _22) -> [return: bb22, unwind: bb33];
    }

    bb22: {
        _51 = &mut _47;
        _52 = const "rocket";
        _50 = push_ident_spanned(_51, _22, _52) -> [return: bb23, unwind: bb33];
    }

    bb23: {
        _54 = &mut _47;
        _53 = push_colon2_spanned(_54, _22) -> [return: bb24, unwind: bb33];
    }

    bb24: {
        _56 = &mut _47;
        _57 = const "async_main";
        _55 = push_ident_spanned(_56, _22, _57) -> [return: bb25, unwind: bb33];
    }

    bb25: {
        _59 = &mut _47;
        _60 = proc_macro2::Delimiter::Parenthesis;
        _62 = TokenStream2::new() -> [return: bb26, unwind: bb33];
    }

    bb26: {
        _64 = &mut _62;
        _65 = const "async";
        _63 = push_ident_spanned(_64, _22, _65) -> [return: bb27, unwind: bb32];
    }

    bb27: {
        _67 = &mut _62;
        _68 = const "move";
        _66 = push_ident_spanned(_67, _22, _68) -> [return: bb28, unwind: bb32];
    }

    bb28: {
        _70 = &_4;
        _71 = &mut _62;
        _69 = <&std::boxed::Box<syn::Block> as ToTokens>::to_tokens(_70, _71) -> [return: bb29, unwind: bb32];
    }

    bb29: {
        _61 = move _62;
        _58 = push_group_spanned(_59, _22, move _60, move _61) -> [return: bb30, unwind: bb33];
    }

    bb30: {
        _46 = move _47;
        _43 = push_group_spanned(_44, _22, move _45, move _46) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        _20 = move _21;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _20);
        return;
    }

    bb32 (cleanup): {
        drop(_62) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_47) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_21) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36 (cleanup): {
        drop(_15) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        switchInt(_73) -> [0: bb35, otherwise: bb36];
    }

    bb38: {
        goto -> bb13;
    }

    bb39: {
        goto -> bb13;
    }
}

promoted[0] in main::<impl at core/codegen/src/attribute/entry/main.rs:10:1: 10:24>::function: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "main";
        _0 = &_1;
        return;
    }
}

const launch::<impl at core/codegen/src/attribute/entry/launch.rs:12:1: 12:26>::REQUIRES_ASYNC: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn launch::<impl at core/codegen/src/attribute/entry/launch.rs:12:1: 12:26>::function(_1: &mut ItemFn) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _2: bool;
    let mut _3: &proc_macro2::Ident;
    let mut _4: devise::Diagnostic;
    let mut _5: devise::Diagnostic;
    let mut _6: devise::Diagnostic;
    let mut _7: proc_macro2::Span;
    let mut _8: proc_macro2::Span;
    let mut _9: &proc_macro2::Ident;
    let mut _10: &mut syn::ReturnType;
    let mut _11: isize;
    let mut _13: &mut syn::Type;
    let mut _14: isize;
    let mut _18: &&mut std::boxed::Box<syn::Type>;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let mut _43: std::boxed::Box<syn::Type>;
    let mut _44: std::result::Result<std::boxed::Box<syn::Type>, syn::Error>;
    let _45: &str;
    let _46: &std::boxed::Box<syn::Type>;
    let mut _47: &syn::ReturnType;
    let mut _48: isize;
    let _49: &std::boxed::Box<syn::Type>;
    let mut _50: devise::Diagnostic;
    let mut _51: devise::Diagnostic;
    let mut _52: proc_macro2::Span;
    let mut _53: proc_macro2::Span;
    let mut _54: &syn::Signature;
    let mut _59: proc_macro2::Span;
    let mut _60: &std::boxed::Box<syn::Type>;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let mut _63: proc_macro2::Delimiter;
    let mut _64: proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: &str;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let _75: &&std::boxed::Box<syn::Type>;
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let _80: &&std::boxed::Box<syn::Block>;
    let mut _81: &mut proc_macro2::TokenStream;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: &str;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: &str;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: &str;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: ();
    let mut _100: &mut proc_macro2::TokenStream;
    let _101: &str;
    let _102: ();
    let mut _103: &mut proc_macro2::TokenStream;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: ();
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: &str;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: &str;
    let _114: ();
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: &str;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: &str;
    let mut _128: (&syn::Visibility, syn::Signature);
    let mut _129: &syn::Visibility;
    let mut _130: syn::Signature;
    let mut _131: &syn::Signature;
    let mut _132: proc_macro2::Ident;
    let _133: &str;
    let mut _134: proc_macro2::Span;
    let mut _135: &proc_macro2::Ident;
    let mut _136: syn::ReturnType;
    let mut _137: std::option::Option<syn::token::Async>;
    let mut _138: proc_macro2::TokenStream;
    let mut _141: proc_macro2::Span;
    let mut _142: &std::boxed::Box<syn::Block>;
    let _143: ();
    let mut _144: &mut proc_macro2::TokenStream;
    let _145: ();
    let mut _146: &mut proc_macro2::TokenStream;
    let mut _147: proc_macro2::Delimiter;
    let mut _148: proc_macro2::TokenStream;
    let _150: ();
    let mut _151: &mut proc_macro2::TokenStream;
    let _152: &str;
    let _153: ();
    let mut _154: &mut proc_macro2::TokenStream;
    let mut _155: proc_macro2::Delimiter;
    let mut _156: proc_macro2::TokenStream;
    let _158: ();
    let mut _159: &mut proc_macro2::TokenStream;
    let _160: &str;
    let _161: ();
    let _162: &&mut syn::ItemFn;
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: ();
    let _165: &&syn::Visibility;
    let mut _166: &mut proc_macro2::TokenStream;
    let _167: ();
    let _168: &syn::Signature;
    let mut _169: &mut proc_macro2::TokenStream;
    let _170: ();
    let mut _171: &mut proc_macro2::TokenStream;
    let mut _172: proc_macro2::Delimiter;
    let mut _173: proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: &str;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let _182: ();
    let mut _183: &mut proc_macro2::TokenStream;
    let _184: &str;
    let _185: ();
    let mut _186: &mut proc_macro2::TokenStream;
    let mut _187: proc_macro2::Delimiter;
    let mut _188: proc_macro2::TokenStream;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let _192: &str;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: &str;
    let _196: ();
    let mut _197: &mut proc_macro2::TokenStream;
    let mut _198: proc_macro2::Delimiter;
    let mut _199: proc_macro2::TokenStream;
    let _201: ();
    let mut _202: &mut proc_macro2::TokenStream;
    let _203: &str;
    let _204: ();
    let mut _205: &mut proc_macro2::TokenStream;
    let _206: &str;
    let _207: ();
    let mut _208: &mut proc_macro2::TokenStream;
    let _209: ();
    let _210: &proc_macro2::TokenStream;
    let mut _211: &mut proc_macro2::TokenStream;
    let _212: ();
    let mut _213: &mut proc_macro2::TokenStream;
    let _214: ();
    let mut _215: &mut proc_macro2::TokenStream;
    let _216: &str;
    let _217: ();
    let mut _218: &mut proc_macro2::TokenStream;
    let mut _219: proc_macro2::Delimiter;
    let mut _220: proc_macro2::TokenStream;
    let _221: ();
    let mut _222: &mut proc_macro2::TokenStream;
    let _223: ();
    let mut _224: &mut proc_macro2::TokenStream;
    let _225: &str;
    let _226: ();
    let mut _227: &mut proc_macro2::TokenStream;
    let mut _228: &&str;
    let mut _229: std::boxed::Box<syn::Type>;
    let mut _230: bool;
    let mut _231: bool;
    let mut _232: *const syn::Type;
    scope 1 {
        debug ty => _12;
        let _12: &mut std::boxed::Box<syn::Type>;
        scope 2 {
            let _15: proc_macro2::TokenStream;
            let mut _16: proc_macro2::TokenStream;
            scope 3 {
                debug new => _15;
            }
            scope 4 {
                debug _s => _16;
                let _17: proc_macro2::Span;
                scope 5 {
                    debug _span => _17;
                }
            }
        }
    }
    scope 6 {
        debug ty => _46;
        let _55: &std::boxed::Box<syn::Block>;
        scope 8 {
            debug block => _55;
            let _56: proc_macro2::TokenStream;
            let mut _57: proc_macro2::TokenStream;
            scope 9 {
                debug rocket => _56;
                let _126: &syn::Visibility;
                let mut _127: syn::Signature;
                scope 14 {
                    debug vis => _126;
                    debug sig => _127;
                    let mut _139: proc_macro2::TokenStream;
                    scope 15 {
                        debug _s => _139;
                        let _140: proc_macro2::Span;
                        scope 16 {
                            debug _span => _140;
                            let mut _149: proc_macro2::TokenStream;
                            let mut _174: proc_macro2::TokenStream;
                            scope 17 {
                                debug _s => _149;
                                scope 18 {
                                    debug _span => _140;
                                    let mut _157: proc_macro2::TokenStream;
                                    scope 19 {
                                        debug _s => _157;
                                        scope 20 {
                                            debug _span => _140;
                                        }
                                    }
                                }
                            }
                            scope 21 {
                                debug _s => _174;
                                scope 22 {
                                    debug _span => _140;
                                    let mut _189: proc_macro2::TokenStream;
                                    scope 23 {
                                        debug _s => _189;
                                        scope 24 {
                                            debug _span => _140;
                                            let mut _200: proc_macro2::TokenStream;
                                            scope 25 {
                                                debug _s => _200;
                                                scope 26 {
                                                    debug _span => _140;
                                                    scope 27 {
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 10 {
                debug _s => _57;
                let _58: proc_macro2::Span;
                scope 11 {
                    debug _span => _58;
                    let mut _65: proc_macro2::TokenStream;
                    scope 12 {
                        debug _s => _65;
                        scope 13 {
                            debug _span => _58;
                        }
                    }
                }
            }
        }
    }
    scope 7 {
        debug ty => _49;
    }

    bb0: {
        _231 = const false;
        _230 = const false;
        _3 = &(((*_1).2: syn::Signature).5: proc_macro2::Ident);
        _228 = const _;
        _2 = <proc_macro2::Ident as PartialEq<&str>>::eq(move _3, _228) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _7 = proc_macro2::Span::call_site() -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _7, const "attribute cannot be applied to `main` function") -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = devise::Diagnostic::note::<&str>(move _6, const "this attribute generates a `main` function") -> [return: bb5, unwind continue];
    }

    bb5: {
        _231 = const true;
        _9 = &(((*_1).2: syn::Signature).5: proc_macro2::Ident);
        _8 = proc_macro2::Ident::span(move _9) -> [return: bb6, unwind: bb123];
    }

    bb6: {
        _231 = const false;
        _4 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _5, move _8, const "this function cannot be `main`") -> [return: bb7, unwind: bb123];
    }

    bb7: {
        _231 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _4);
        goto -> bb107;
    }

    bb8: {
        _10 = &mut (((*_1).2: syn::Signature).10: syn::ReturnType);
        _11 = discriminant((*_10));
        switchInt(move _11) -> [1: bb9, otherwise: bb27];
    }

    bb9: {
        _12 = &mut (((*_10) as Type).1: std::boxed::Box<syn::Type>);
        _229 = deref_copy (*_12);
        _232 = (((_229.0: std::ptr::Unique<syn::Type>).0: std::ptr::NonNull<syn::Type>).0: *const syn::Type);
        _13 = &mut (*_232);
        _14 = discriminant((*_13));
        switchInt(move _14) -> [4: bb10, otherwise: bb27];
    }

    bb10: {
        _16 = TokenStream2::new() -> [return: bb11, unwind continue];
    }

    bb11: {
        _18 = &_12;
        _17 = <&mut std::boxed::Box<syn::Type> as devise::Spanned>::span(move _18) -> [return: bb12, unwind: bb118];
    }

    bb12: {
        _20 = &mut _16;
        _19 = push_colon2_spanned(_20, _17) -> [return: bb13, unwind: bb118];
    }

    bb13: {
        _22 = &mut _16;
        _23 = const "rocket";
        _21 = push_ident_spanned(_22, _17, _23) -> [return: bb14, unwind: bb118];
    }

    bb14: {
        _25 = &mut _16;
        _24 = push_colon2_spanned(_25, _17) -> [return: bb15, unwind: bb118];
    }

    bb15: {
        _27 = &mut _16;
        _28 = const "Rocket";
        _26 = push_ident_spanned(_27, _17, _28) -> [return: bb16, unwind: bb118];
    }

    bb16: {
        _30 = &mut _16;
        _29 = push_lt_spanned(_30, _17) -> [return: bb17, unwind: bb118];
    }

    bb17: {
        _32 = &mut _16;
        _31 = push_colon2_spanned(_32, _17) -> [return: bb18, unwind: bb118];
    }

    bb18: {
        _34 = &mut _16;
        _35 = const "rocket";
        _33 = push_ident_spanned(_34, _17, _35) -> [return: bb19, unwind: bb118];
    }

    bb19: {
        _37 = &mut _16;
        _36 = push_colon2_spanned(_37, _17) -> [return: bb20, unwind: bb118];
    }

    bb20: {
        _39 = &mut _16;
        _40 = const "Build";
        _38 = push_ident_spanned(_39, _17, _40) -> [return: bb21, unwind: bb118];
    }

    bb21: {
        _42 = &mut _16;
        _41 = push_gt_spanned(_42, _17) -> [return: bb22, unwind: bb118];
    }

    bb22: {
        _15 = move _16;
        _44 = syn::parse2::<std::boxed::Box<syn::Type>>(move _15) -> [return: bb23, unwind continue];
    }

    bb23: {
        _45 = const "path is type";
        _43 = std::result::Result::<std::boxed::Box<syn::Type>, syn::Error>::expect(move _44, _45) -> [return: bb24, unwind continue];
    }

    bb24: {
        drop((*_12)) -> [return: bb25, unwind: bb26];
    }

    bb25: {
        (*_12) = move _43;
        goto -> bb27;
    }

    bb26 (cleanup): {
        (*_12) = move _43;
        goto -> bb119;
    }

    bb27: {
        _47 = &(((*_1).2: syn::Signature).10: syn::ReturnType);
        _48 = discriminant((*_47));
        switchInt(move _48) -> [1: bb29, otherwise: bb28];
    }

    bb28: {
        _52 = proc_macro2::Span::call_site() -> [return: bb30, unwind continue];
    }

    bb29: {
        _49 = &(((*_47) as Type).1: std::boxed::Box<syn::Type>);
        _46 = _49;
        _55 = &((*_1).3: std::boxed::Box<syn::Block>);
        _57 = TokenStream2::new() -> [return: bb34, unwind continue];
    }

    bb30: {
        _230 = const true;
        _51 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _52, const "attribute can only be applied to functions that return a value") -> [return: bb31, unwind continue];
    }

    bb31: {
        _54 = &((*_1).2: syn::Signature);
        _53 = <Signature as devise::Spanned>::span(move _54) -> [return: bb32, unwind: bb121];
    }

    bb32: {
        _230 = const false;
        _50 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _51, move _53, const "this function must return a value") -> [return: bb33, unwind: bb121];
    }

    bb33: {
        _230 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _50);
        goto -> bb107;
    }

    bb34: {
        _60 = _46;
        _59 = <std::boxed::Box<syn::Type> as devise::Spanned>::span(move _60) -> [return: bb35, unwind: bb117];
    }

    bb35: {
        _58 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _59) -> [return: bb36, unwind: bb117];
    }

    bb36: {
        _62 = &mut _57;
        _63 = proc_macro2::Delimiter::Brace;
        _65 = TokenStream2::new() -> [return: bb37, unwind: bb117];
    }

    bb37: {
        _67 = &mut _65;
        _68 = const "let";
        _66 = push_ident_spanned(_67, _58, _68) -> [return: bb38, unwind: bb116];
    }

    bb38: {
        _70 = &mut _65;
        _71 = const "___rocket";
        _69 = push_ident_spanned(_70, _58, _71) -> [return: bb39, unwind: bb116];
    }

    bb39: {
        _73 = &mut _65;
        _72 = push_colon_spanned(_73, _58) -> [return: bb40, unwind: bb116];
    }

    bb40: {
        _75 = &_46;
        _76 = &mut _65;
        _74 = <&std::boxed::Box<syn::Type> as ToTokens>::to_tokens(_75, _76) -> [return: bb41, unwind: bb116];
    }

    bb41: {
        _78 = &mut _65;
        _77 = push_eq_spanned(_78, _58) -> [return: bb42, unwind: bb116];
    }

    bb42: {
        _80 = &_55;
        _81 = &mut _65;
        _79 = <&std::boxed::Box<syn::Block> as ToTokens>::to_tokens(_80, _81) -> [return: bb43, unwind: bb116];
    }

    bb43: {
        _83 = &mut _65;
        _82 = push_semi_spanned(_83, _58) -> [return: bb44, unwind: bb116];
    }

    bb44: {
        _85 = &mut _65;
        _86 = const "let";
        _84 = push_ident_spanned(_85, _58, _86) -> [return: bb45, unwind: bb116];
    }

    bb45: {
        _88 = &mut _65;
        _89 = const "___rocket";
        _87 = push_ident_spanned(_88, _58, _89) -> [return: bb46, unwind: bb116];
    }

    bb46: {
        _91 = &mut _65;
        _90 = push_colon_spanned(_91, _58) -> [return: bb47, unwind: bb116];
    }

    bb47: {
        _93 = &mut _65;
        _92 = push_colon2_spanned(_93, _58) -> [return: bb48, unwind: bb116];
    }

    bb48: {
        _95 = &mut _65;
        _96 = const "rocket";
        _94 = push_ident_spanned(_95, _58, _96) -> [return: bb49, unwind: bb116];
    }

    bb49: {
        _98 = &mut _65;
        _97 = push_colon2_spanned(_98, _58) -> [return: bb50, unwind: bb116];
    }

    bb50: {
        _100 = &mut _65;
        _101 = const "Rocket";
        _99 = push_ident_spanned(_100, _58, _101) -> [return: bb51, unwind: bb116];
    }

    bb51: {
        _103 = &mut _65;
        _102 = push_lt_spanned(_103, _58) -> [return: bb52, unwind: bb116];
    }

    bb52: {
        _105 = &mut _65;
        _104 = push_colon2_spanned(_105, _58) -> [return: bb53, unwind: bb116];
    }

    bb53: {
        _107 = &mut _65;
        _108 = const "rocket";
        _106 = push_ident_spanned(_107, _58, _108) -> [return: bb54, unwind: bb116];
    }

    bb54: {
        _110 = &mut _65;
        _109 = push_colon2_spanned(_110, _58) -> [return: bb55, unwind: bb116];
    }

    bb55: {
        _112 = &mut _65;
        _113 = const "Build";
        _111 = push_ident_spanned(_112, _58, _113) -> [return: bb56, unwind: bb116];
    }

    bb56: {
        _115 = &mut _65;
        _114 = push_gt_spanned(_115, _58) -> [return: bb57, unwind: bb116];
    }

    bb57: {
        _117 = &mut _65;
        _116 = push_eq_spanned(_117, _58) -> [return: bb58, unwind: bb116];
    }

    bb58: {
        _119 = &mut _65;
        _120 = const "___rocket";
        _118 = push_ident_spanned(_119, _58, _120) -> [return: bb59, unwind: bb116];
    }

    bb59: {
        _122 = &mut _65;
        _121 = push_semi_spanned(_122, _58) -> [return: bb60, unwind: bb116];
    }

    bb60: {
        _124 = &mut _65;
        _125 = const "___rocket";
        _123 = push_ident_spanned(_124, _58, _125) -> [return: bb61, unwind: bb116];
    }

    bb61: {
        _64 = move _65;
        _61 = push_group_spanned(_62, _58, move _63, move _64) -> [return: bb62, unwind: bb117];
    }

    bb62: {
        _56 = move _57;
        _129 = &((*_1).1: syn::Visibility);
        _131 = &((*_1).2: syn::Signature);
        _130 = <Signature as Clone>::clone(move _131) -> [return: bb63, unwind: bb115];
    }

    bb63: {
        _128 = (move _129, move _130);
        _126 = (_128.0: &syn::Visibility);
        _127 = move (_128.1: syn::Signature);
        _133 = const "main";
        _135 = &(_127.5: proc_macro2::Ident);
        _134 = proc_macro2::Ident::span(move _135) -> [return: bb64, unwind: bb114];
    }

    bb64: {
        _132 = proc_macro2::Ident::new(_133, move _134) -> [return: bb65, unwind: bb114];
    }

    bb65: {
        drop((_127.5: proc_macro2::Ident)) -> [return: bb66, unwind: bb67];
    }

    bb66: {
        (_127.5: proc_macro2::Ident) = move _132;
        _136 = syn::ReturnType::Default;
        drop((_127.10: syn::ReturnType)) -> [return: bb68, unwind: bb69];
    }

    bb67 (cleanup): {
        (_127.5: proc_macro2::Ident) = move _132;
        goto -> bb114;
    }

    bb68: {
        (_127.10: syn::ReturnType) = move _136;
        _137 = Option::<syn::token::Async>::None;
        (_127.1: std::option::Option<syn::token::Async>) = move _137;
        _139 = TokenStream2::new() -> [return: bb70, unwind: bb114];
    }

    bb69 (cleanup): {
        (_127.10: syn::ReturnType) = move _136;
        goto -> bb114;
    }

    bb70: {
        _142 = _55;
        _141 = <std::boxed::Box<syn::Block> as devise::Spanned>::span(move _142) -> [return: bb71, unwind: bb113];
    }

    bb71: {
        _140 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _141) -> [return: bb72, unwind: bb113];
    }

    bb72: {
        _144 = &mut _139;
        _143 = push_pound_spanned(_144, _140) -> [return: bb73, unwind: bb113];
    }

    bb73: {
        _146 = &mut _139;
        _147 = proc_macro2::Delimiter::Bracket;
        _149 = TokenStream2::new() -> [return: bb74, unwind: bb113];
    }

    bb74: {
        _151 = &mut _149;
        _152 = const "allow";
        _150 = push_ident_spanned(_151, _140, _152) -> [return: bb75, unwind: bb112];
    }

    bb75: {
        _154 = &mut _149;
        _155 = proc_macro2::Delimiter::Parenthesis;
        _157 = TokenStream2::new() -> [return: bb76, unwind: bb112];
    }

    bb76: {
        _159 = &mut _157;
        _160 = const "dead_code";
        _158 = push_ident_spanned(_159, _140, _160) -> [return: bb77, unwind: bb111];
    }

    bb77: {
        _156 = move _157;
        _153 = push_group_spanned(_154, _140, move _155, move _156) -> [return: bb78, unwind: bb112];
    }

    bb78: {
        _148 = move _149;
        _145 = push_group_spanned(_146, _140, move _147, move _148) -> [return: bb79, unwind: bb113];
    }

    bb79: {
        _162 = &_1;
        _163 = &mut _139;
        _161 = <&mut ItemFn as ToTokens>::to_tokens(_162, _163) -> [return: bb80, unwind: bb113];
    }

    bb80: {
        _165 = &_126;
        _166 = &mut _139;
        _164 = <&Visibility as ToTokens>::to_tokens(_165, _166) -> [return: bb81, unwind: bb113];
    }

    bb81: {
        _168 = &_127;
        _169 = &mut _139;
        _167 = <Signature as ToTokens>::to_tokens(_168, _169) -> [return: bb82, unwind: bb113];
    }

    bb82: {
        _171 = &mut _139;
        _172 = proc_macro2::Delimiter::Brace;
        _174 = TokenStream2::new() -> [return: bb83, unwind: bb113];
    }

    bb83: {
        _176 = &mut _174;
        _175 = push_colon2_spanned(_176, _140) -> [return: bb84, unwind: bb110];
    }

    bb84: {
        _178 = &mut _174;
        _179 = const "rocket";
        _177 = push_ident_spanned(_178, _140, _179) -> [return: bb85, unwind: bb110];
    }

    bb85: {
        _181 = &mut _174;
        _180 = push_colon2_spanned(_181, _140) -> [return: bb86, unwind: bb110];
    }

    bb86: {
        _183 = &mut _174;
        _184 = const "async_main";
        _182 = push_ident_spanned(_183, _140, _184) -> [return: bb87, unwind: bb110];
    }

    bb87: {
        _186 = &mut _174;
        _187 = proc_macro2::Delimiter::Parenthesis;
        _189 = TokenStream2::new() -> [return: bb88, unwind: bb110];
    }

    bb88: {
        _191 = &mut _189;
        _192 = const "async";
        _190 = push_ident_spanned(_191, _140, _192) -> [return: bb89, unwind: bb109];
    }

    bb89: {
        _194 = &mut _189;
        _195 = const "move";
        _193 = push_ident_spanned(_194, _140, _195) -> [return: bb90, unwind: bb109];
    }

    bb90: {
        _197 = &mut _189;
        _198 = proc_macro2::Delimiter::Brace;
        _200 = TokenStream2::new() -> [return: bb91, unwind: bb109];
    }

    bb91: {
        _202 = &mut _200;
        _203 = const "let";
        _201 = push_ident_spanned(_202, _140, _203) -> [return: bb92, unwind: bb108];
    }

    bb92: {
        _205 = &mut _200;
        _206 = const "_res";
        _204 = push_ident_spanned(_205, _140, _206) -> [return: bb93, unwind: bb108];
    }

    bb93: {
        _208 = &mut _200;
        _207 = push_eq_spanned(_208, _140) -> [return: bb94, unwind: bb108];
    }

    bb94: {
        _210 = &_56;
        _211 = &mut _200;
        _209 = <TokenStream2 as ToTokens>::to_tokens(_210, _211) -> [return: bb95, unwind: bb108];
    }

    bb95: {
        _213 = &mut _200;
        _212 = push_dot_spanned(_213, _140) -> [return: bb96, unwind: bb108];
    }

    bb96: {
        _215 = &mut _200;
        _216 = const "launch";
        _214 = push_ident_spanned(_215, _140, _216) -> [return: bb97, unwind: bb108];
    }

    bb97: {
        _218 = &mut _200;
        _219 = proc_macro2::Delimiter::Parenthesis;
        _220 = TokenStream2::new() -> [return: bb98, unwind: bb108];
    }

    bb98: {
        _217 = push_group_spanned(_218, _140, move _219, move _220) -> [return: bb99, unwind: bb108];
    }

    bb99: {
        _222 = &mut _200;
        _221 = push_dot_spanned(_222, _140) -> [return: bb100, unwind: bb108];
    }

    bb100: {
        _224 = &mut _200;
        _225 = const "await";
        _223 = push_ident_spanned(_224, _140, _225) -> [return: bb101, unwind: bb108];
    }

    bb101: {
        _227 = &mut _200;
        _226 = push_semi_spanned(_227, _140) -> [return: bb102, unwind: bb108];
    }

    bb102: {
        _199 = move _200;
        _196 = push_group_spanned(_197, _140, move _198, move _199) -> [return: bb103, unwind: bb109];
    }

    bb103: {
        _188 = move _189;
        _185 = push_group_spanned(_186, _140, move _187, move _188) -> [return: bb104, unwind: bb110];
    }

    bb104: {
        _173 = move _174;
        _170 = push_group_spanned(_171, _140, move _172, move _173) -> [return: bb105, unwind: bb113];
    }

    bb105: {
        _138 = move _139;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _138);
        drop(_127) -> [return: bb106, unwind: bb115];
    }

    bb106: {
        drop(_56) -> [return: bb107, unwind continue];
    }

    bb107: {
        return;
    }

    bb108 (cleanup): {
        drop(_200) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        drop(_189) -> [return: bb110, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        drop(_174) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_157) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_149) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_139) -> [return: bb114, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_127) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_56) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_65) -> [return: bb117, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        drop(_57) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        drop(_16) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb119 (cleanup): {
        resume;
    }

    bb120 (cleanup): {
        drop(_51) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb121 (cleanup): {
        switchInt(_230) -> [0: bb119, otherwise: bb120];
    }

    bb122 (cleanup): {
        drop(_5) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        switchInt(_231) -> [0: bb119, otherwise: bb122];
    }
}

promoted[0] in launch::<impl at core/codegen/src/attribute/entry/launch.rs:12:1: 12:26>::function: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "main";
        _0 = &_1;
        return;
    }
}

const test::<impl at core/codegen/src/attribute/entry/test.rs:9:1: 9:24>::REQUIRES_ASYNC: bool = {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn test::<impl at core/codegen/src/attribute/entry/test.rs:9:1: 9:24>::function(_1: &mut ItemFn) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug f => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: &std::vec::Vec<syn::Attribute>;
    let _3: &syn::Visibility;
    let _4: &std::boxed::Box<syn::Block>;
    let _5: &mut syn::Signature;
    let mut _6: (&std::vec::Vec<syn::Attribute>, &syn::Visibility, &std::boxed::Box<syn::Block>, &mut syn::Signature);
    let mut _7: &std::vec::Vec<syn::Attribute>;
    let mut _8: &syn::Visibility;
    let mut _9: &std::boxed::Box<syn::Block>;
    let mut _10: &mut syn::Signature;
    let mut _11: std::option::Option<syn::token::Async>;
    let mut _12: proc_macro2::TokenStream;
    let mut _15: proc_macro2::Span;
    let mut _16: &std::boxed::Box<syn::Block>;
    let mut _18: (std::slice::Iter<'_, syn::Attribute>, quote::__private::HasIterator);
    let mut _20: bool;
    let mut _22: std::option::Option<&syn::Attribute>;
    let mut _23: &mut std::slice::Iter<'_, syn::Attribute>;
    let mut _24: isize;
    let _26: ();
    let _27: &quote::__private::RepInterp<&syn::Attribute>;
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _33: proc_macro2::Delimiter;
    let mut _34: proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let _40: &&syn::Visibility;
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let _43: &&mut syn::Signature;
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let mut _47: proc_macro2::Delimiter;
    let mut _48: proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: &str;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: proc_macro2::Delimiter;
    let mut _63: proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: &str;
    let _71: ();
    let _72: &&std::boxed::Box<syn::Block>;
    let mut _73: &mut proc_macro2::TokenStream;
    scope 1 {
        debug attrs => _2;
        debug vis => _3;
        debug block => _4;
        debug sig => _5;
        let mut _13: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _13;
            let _14: proc_macro2::Span;
            scope 3 {
                debug _span => _14;
                let mut _35: proc_macro2::TokenStream;
                let mut _49: proc_macro2::TokenStream;
                scope 4 {
                    debug has_iter => const ThereIsNoIteratorInRepetition;
                    scope 5 {
                        debug attrs => _17;
                        debug i => const HasIterator;
                        let _19: quote::__private::HasIterator;
                        scope 7 {
                            debug has_iter => const HasIterator;
                            scope 8 {
                                let _21: quote::__private::RepInterp<&syn::Attribute>;
                                let _25: &syn::Attribute;
                                scope 9 {
                                    debug attrs => _21;
                                }
                                scope 10 {
                                    debug _x => _25;
                                }
                            }
                        }
                    }
                    scope 6 {
                        let mut _17: std::slice::Iter<'_, syn::Attribute>;
                    }
                }
                scope 11 {
                    debug _s => _35;
                    scope 12 {
                        debug _span => _14;
                    }
                }
                scope 13 {
                    debug _s => _49;
                    scope 14 {
                        debug _span => _14;
                        let mut _64: proc_macro2::TokenStream;
                        scope 15 {
                            debug _s => _64;
                            scope 16 {
                                debug _span => _14;
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &((*_1).0: std::vec::Vec<syn::Attribute>);
        _8 = &((*_1).1: syn::Visibility);
        _9 = &((*_1).3: std::boxed::Box<syn::Block>);
        _10 = &mut ((*_1).2: syn::Signature);
        _6 = (move _7, move _8, move _9, move _10);
        _2 = (_6.0: &std::vec::Vec<syn::Attribute>);
        _3 = (_6.1: &syn::Visibility);
        _4 = (_6.2: &std::boxed::Box<syn::Block>);
        _5 = move (_6.3: &mut syn::Signature);
        _11 = Option::<syn::token::Async>::None;
        ((*_5).1: std::option::Option<syn::token::Async>) = move _11;
        _13 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = _4;
        _15 = <std::boxed::Box<syn::Block> as devise::Spanned>::span(move _16) -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _14 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _15) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _18 = <Vec<syn::Attribute> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(_2) -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _17 = move (_18.0: std::slice::Iter<'_, syn::Attribute>);
        _19 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb33, unwind: bb31];
    }

    bb5: {
        _20 = const true;
        switchInt(move _20) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _23 = &mut _17;
        _22 = <std::slice::Iter<'_, syn::Attribute> as Iterator>::next(move _23) -> [return: bb7, unwind: bb31];
    }

    bb7: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [0: bb10, 1: bb9, otherwise: bb8];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _25 = ((_22 as Some).0: &syn::Attribute);
        _21 = RepInterp::<&syn::Attribute>(_25);
        _27 = &_21;
        _28 = &mut _13;
        _26 = <RepInterp<&syn::Attribute> as ToTokens>::to_tokens(_27, _28) -> [return: bb34, unwind: bb31];
    }

    bb10: {
        _30 = &mut _13;
        _29 = push_pound_spanned(_30, _14) -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _32 = &mut _13;
        _33 = proc_macro2::Delimiter::Bracket;
        _35 = TokenStream2::new() -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _37 = &mut _35;
        _38 = const "test";
        _36 = push_ident_spanned(_37, _14, _38) -> [return: bb13, unwind: bb30];
    }

    bb13: {
        _34 = move _35;
        _31 = push_group_spanned(_32, _14, move _33, move _34) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _40 = &_3;
        _41 = &mut _13;
        _39 = <&Visibility as ToTokens>::to_tokens(_40, _41) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _43 = &_5;
        _44 = &mut _13;
        _42 = <&mut Signature as ToTokens>::to_tokens(_43, _44) -> [return: bb16, unwind: bb31];
    }

    bb16: {
        _46 = &mut _13;
        _47 = proc_macro2::Delimiter::Brace;
        _49 = TokenStream2::new() -> [return: bb17, unwind: bb31];
    }

    bb17: {
        _51 = &mut _49;
        _50 = push_colon2_spanned(_51, _14) -> [return: bb18, unwind: bb29];
    }

    bb18: {
        _53 = &mut _49;
        _54 = const "rocket";
        _52 = push_ident_spanned(_53, _14, _54) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _56 = &mut _49;
        _55 = push_colon2_spanned(_56, _14) -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _58 = &mut _49;
        _59 = const "async_test";
        _57 = push_ident_spanned(_58, _14, _59) -> [return: bb21, unwind: bb29];
    }

    bb21: {
        _61 = &mut _49;
        _62 = proc_macro2::Delimiter::Parenthesis;
        _64 = TokenStream2::new() -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _66 = &mut _64;
        _67 = const "async";
        _65 = push_ident_spanned(_66, _14, _67) -> [return: bb23, unwind: bb28];
    }

    bb23: {
        _69 = &mut _64;
        _70 = const "move";
        _68 = push_ident_spanned(_69, _14, _70) -> [return: bb24, unwind: bb28];
    }

    bb24: {
        _72 = &_4;
        _73 = &mut _64;
        _71 = <&std::boxed::Box<syn::Block> as ToTokens>::to_tokens(_72, _73) -> [return: bb25, unwind: bb28];
    }

    bb25: {
        _63 = move _64;
        _60 = push_group_spanned(_61, _14, move _62, move _63) -> [return: bb26, unwind: bb29];
    }

    bb26: {
        _48 = move _49;
        _45 = push_group_spanned(_46, _14, move _47, move _48) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _12 = move _13;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _12);
        return;
    }

    bb28 (cleanup): {
        drop(_64) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_49) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_35) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_13) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        goto -> bb5;
    }

    bb34: {
        goto -> bb5;
    }
}

fn _async_entry(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug _args => _1;
    debug input => _2;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: syn::ItemFn;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::ItemFn>;
    let mut _5: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _6: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _7: std::result::Result<syn::ItemFn, syn::Error>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _10: syn::ItemFn;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: &std::option::Option<syn::token::Async>;
    let mut _14: devise::Diagnostic;
    let mut _15: devise::Diagnostic;
    let mut _16: proc_macro2::Span;
    let mut _17: proc_macro2::Span;
    let mut _18: &syn::Signature;
    let mut _19: bool;
    let mut _20: &syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>;
    let mut _21: devise::Diagnostic;
    let mut _22: devise::Diagnostic;
    let mut _23: proc_macro2::Span;
    let mut _24: proc_macro2::Span;
    let mut _25: &syn::Signature;
    let mut _26: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _27: &mut syn::ItemFn;
    let mut _28: bool;
    let mut _29: bool;
    scope 1 {
        debug function => _3;
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _29 = const false;
        _28 = const false;
        _7 = syn::parse::<ItemFn>(move _2) -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _6 = std::result::Result::<ItemFn, syn::Error>::map_err::<devise::Diagnostic, fn(syn::Error) -> devise::Diagnostic {<devise::Diagnostic as From<syn::Error>>::from}>(move _7, <devise::Diagnostic as From<syn::Error>>::from) -> [return: bb2, unwind: bb30];
    }

    bb2: {
        _5 = std::result::Result::<ItemFn, devise::Diagnostic>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/entry/mod.rs:24:18: 24:21}>(move _6, const ZeroSized: {closure@core/codegen/src/attribute/entry/mod.rs:24:18: 24:21}) -> [return: bb3, unwind: bb30];
    }

    bb3: {
        _4 = <std::result::Result<ItemFn, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind: bb30];
    }

    bb4: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_4 as Continue).0: syn::ItemFn);
        _3 = move _10;
        _11 = const _;
        switchInt(move _11) -> [0: bb15, otherwise: bb8];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _9) -> [return: bb36, unwind: bb30];
    }

    bb8: {
        _13 = &((_3.2: syn::Signature).1: std::option::Option<syn::token::Async>);
        _12 = Option::<syn::token::Async>::is_none(move _13) -> [return: bb9, unwind: bb29];
    }

    bb9: {
        switchInt(move _12) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        _16 = proc_macro2::Span::call_site() -> [return: bb11, unwind: bb29];
    }

    bb11: {
        _15 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _16, const "attribute can only be applied to `async` functions") -> [return: bb12, unwind: bb29];
    }

    bb12: {
        _29 = const true;
        _18 = &(_3.2: syn::Signature);
        _17 = <Signature as devise::Spanned>::span(move _18) -> [return: bb13, unwind: bb35];
    }

    bb13: {
        _29 = const false;
        _14 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _15, move _17, const "this function must be `async`") -> [return: bb14, unwind: bb35];
    }

    bb14: {
        _29 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _14);
        goto -> bb26;
    }

    bb15: {
        _20 = &((_3.2: syn::Signature).8: syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>);
        _19 = syn::punctuated::Punctuated::<syn::FnArg, syn::token::Comma>::is_empty(move _20) -> [return: bb16, unwind: bb29];
    }

    bb16: {
        switchInt(move _19) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _27 = &mut _3;
        _26 = <A as EntryAttr>::function(_27) -> [return: bb23, unwind: bb29];
    }

    bb18: {
        _23 = proc_macro2::Span::call_site() -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _22 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _23, const "attribute can only be applied to functions without arguments") -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _28 = const true;
        _25 = &(_3.2: syn::Signature);
        _24 = <Signature as devise::Spanned>::span(move _25) -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _28 = const false;
        _21 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _22, move _24, const "this function must take no arguments") -> [return: bb22, unwind: bb33];
    }

    bb22: {
        _28 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _21);
        goto -> bb26;
    }

    bb23: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::map::<TokenStream2, {closure@core/codegen/src/attribute/entry/mod.rs:38:36: 38:39}>(move _26, const ZeroSized: {closure@core/codegen/src/attribute/entry/mod.rs:38:36: 38:39}) -> [return: bb24, unwind: bb29];
    }

    bb24: {
        drop(_3) -> [return: bb25, unwind: bb30];
    }

    bb25: {
        drop(_1) -> [return: bb28, unwind continue];
    }

    bb26: {
        drop(_3) -> [return: bb27, unwind: bb30];
    }

    bb27: {
        drop(_1) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_3) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_1) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        resume;
    }

    bb32 (cleanup): {
        drop(_22) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        switchInt(_28) -> [0: bb29, otherwise: bb32];
    }

    bb34 (cleanup): {
        drop(_15) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        switchInt(_29) -> [0: bb29, otherwise: bb34];
    }

    bb36: {
        goto -> bb27;
    }
}

fn _async_entry::{closure#0}(_1: {closure@core/codegen/src/attribute/entry/mod.rs:24:18: 24:21}, _2: devise::Diagnostic) -> devise::Diagnostic {
    debug d => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = devise::Diagnostic::help::<&str>(move _2, const "attribute can only be applied to functions") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _async_entry::{closure#1}(_1: {closure@core/codegen/src/attribute/entry/mod.rs:38:36: 38:39}, _2: TokenStream2) -> TokenStream2 {
    debug t => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = <TokenStream2 as Into<TokenStream2>>::into(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn async_test_attribute(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> TokenStream2 {
    debug a => _1;
    debug i => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _3 = _async_entry::<Test>(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn async_test_attribute::{closure#0}(_1: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}, _2: devise::Diagnostic) -> TokenStream2 {
    debug d => _2;
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let _6: ();
    let _7: &proc_macro2::TokenStream;
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let _10: &proc_macro2::TokenStream;
    let mut _11: &mut proc_macro2::TokenStream;
    scope 1 {
        debug d => _3;
        let _4: proc_macro2::TokenStream;
        scope 2 {
            debug default => _4;
            let mut _5: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _5;
            }
        }
    }

    bb0: {
        _3 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = TokenStream2::new() -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _5 = TokenStream2::new() -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _7 = &_3;
        _8 = &mut _5;
        _6 = <TokenStream2 as ToTokens>::to_tokens(_7, _8) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _10 = &_4;
        _11 = &mut _5;
        _9 = <TokenStream2 as ToTokens>::to_tokens(_10, _11) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = move _5;
        drop(_4) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn main_attribute(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> TokenStream2 {
    debug a => _1;
    debug i => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _3 = _async_entry::<Main>(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn main_attribute::{closure#0}(_1: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}, _2: devise::Diagnostic) -> TokenStream2 {
    debug d => _2;
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::Delimiter;
    let mut _15: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let mut _18: proc_macro2::Delimiter;
    let mut _19: proc_macro2::TokenStream;
    let _21: ();
    let _22: &proc_macro2::TokenStream;
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let _25: &proc_macro2::TokenStream;
    let mut _26: &mut proc_macro2::TokenStream;
    scope 1 {
        debug d => _3;
        let _4: proc_macro2::TokenStream;
        let mut _5: proc_macro2::TokenStream;
        scope 2 {
            debug default => _4;
            let mut _20: proc_macro2::TokenStream;
            scope 4 {
                debug _s => _20;
            }
        }
        scope 3 {
            debug _s => _5;
        }
    }

    bb0: {
        _3 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = TokenStream2::new() -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _7 = &mut _5;
        _8 = const "fn";
        _6 = push_ident(_7, _8) -> [return: bb3, unwind: bb16];
    }

    bb3: {
        _10 = &mut _5;
        _11 = const "main";
        _9 = push_ident(_10, _11) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _13 = &mut _5;
        _14 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _12 = push_group(_13, move _14, move _15) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _17 = &mut _5;
        _18 = proc_macro2::Delimiter::Brace;
        _19 = TokenStream2::new() -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _16 = push_group(_17, move _18, move _19) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _4 = move _5;
        _20 = TokenStream2::new() -> [return: bb9, unwind: bb15];
    }

    bb9: {
        _22 = &_3;
        _23 = &mut _20;
        _21 = <TokenStream2 as ToTokens>::to_tokens(_22, _23) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        _25 = &_4;
        _26 = &mut _20;
        _24 = <TokenStream2 as ToTokens>::to_tokens(_25, _26) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _0 = move _20;
        drop(_4) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        drop(_3) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_20) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_4) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_5) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }
}

fn launch_attribute(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> TokenStream2 {
    debug a => _1;
    debug i => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _3 = _async_entry::<Launch>(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn launch_attribute::{closure#0}(_1: {closure@core/codegen/src/attribute/entry/mod.rs:44:56: 44:59}, _2: devise::Diagnostic) -> TokenStream2 {
    debug d => _2;
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::Delimiter;
    let mut _15: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let mut _18: proc_macro2::Delimiter;
    let mut _19: proc_macro2::TokenStream;
    let _21: ();
    let _22: &proc_macro2::TokenStream;
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let _25: &proc_macro2::TokenStream;
    let mut _26: &mut proc_macro2::TokenStream;
    scope 1 {
        debug d => _3;
        let _4: proc_macro2::TokenStream;
        let mut _5: proc_macro2::TokenStream;
        scope 2 {
            debug default => _4;
            let mut _20: proc_macro2::TokenStream;
            scope 4 {
                debug _s => _20;
            }
        }
        scope 3 {
            debug _s => _5;
        }
    }

    bb0: {
        _3 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = TokenStream2::new() -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _7 = &mut _5;
        _8 = const "fn";
        _6 = push_ident(_7, _8) -> [return: bb3, unwind: bb16];
    }

    bb3: {
        _10 = &mut _5;
        _11 = const "main";
        _9 = push_ident(_10, _11) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _13 = &mut _5;
        _14 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _12 = push_group(_13, move _14, move _15) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _17 = &mut _5;
        _18 = proc_macro2::Delimiter::Brace;
        _19 = TokenStream2::new() -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _16 = push_group(_17, move _18, move _19) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _4 = move _5;
        _20 = TokenStream2::new() -> [return: bb9, unwind: bb15];
    }

    bb9: {
        _22 = &_3;
        _23 = &mut _20;
        _21 = <TokenStream2 as ToTokens>::to_tokens(_22, _23) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        _25 = &_4;
        _26 = &mut _20;
        _24 = <TokenStream2 as ToTokens>::to_tokens(_25, _26) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _0 = move _20;
        drop(_4) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        drop(_3) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_20) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_4) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_5) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }
}

const catch::parse::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn catch::parse::_::<impl at core/codegen/src/attribute/catch/parse.rs:16:10: 16:18>::from_meta(_1: &devise::MetaItem) -> std::result::Result<catch::parse::Meta, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<attribute::catch::parse::Meta, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _10: std::option::Option<&devise::MetaItem>;
    let mut _11: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _12: isize;
    let mut _15: bool;
    let mut _16: std::option::Option<attribute::catch::parse::Code>;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::catch::parse::Code>;
    let mut _18: std::result::Result<attribute::catch::parse::Code, devise::Diagnostic>;
    let mut _19: isize;
    let mut _23: devise::Diagnostic;
    let mut _24: proc_macro2::Span;
    let mut _25: devise::Diagnostic;
    let mut _26: proc_macro2::Span;
    let mut _28: std::fmt::Arguments<'_>;
    let mut _29: &[&str];
    let mut _30: &[core::fmt::rt::Argument<'_>];
    let _31: &[core::fmt::rt::Argument<'_>; 0];
    let _32: [core::fmt::rt::Argument<'_>; 0];
    let mut _33: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _34: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _36: std::option::Option<&devise::MetaItem>;
    let mut _37: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _38: isize;
    let mut _42: std::option::Option<&proc_macro2::Ident>;
    let mut _43: isize;
    let mut _45: devise::Diagnostic;
    let mut _47: std::fmt::Arguments<'_>;
    let mut _48: &[&str];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 1];
    let _51: [core::fmt::rt::Argument<'_>; 1];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &&proc_macro2::Ident;
    let mut _54: devise::Diagnostic;
    let mut _55: attribute::catch::parse::Meta;
    let mut _56: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::catch::parse::Code>;
    let mut _57: std::result::Result<attribute::catch::parse::Code, devise::Diagnostic>;
    let mut _58: std::option::Option<attribute::catch::parse::Code>;
    let mut _59: std::option::Option<attribute::catch::parse::Code>;
    let mut _60: {closure@core/codegen/src/attribute/catch/parse.rs:18:5: 18:6};
    let mut _61: &proc_macro2::Span;
    let mut _62: isize;
    let mut _67: &devise::MetaItem;
    let mut _68: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _69: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug code => _9;
                let _13: &devise::MetaItem;
                let _14: &&devise::MetaItem;
                let _22: &devise::MetaItem;
                let _27: std::string::String;
                let mut _35: syn::punctuated::Iter<'_, devise::MetaItem>;
                let _63: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _64: attribute::catch::parse::Code;
                let mut _65: &[&str; 1];
                scope 9 {
                    debug __i => _13;
                    debug __i => _14;
                    let _20: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                    let _21: attribute::catch::parse::Code;
                    scope 10 {
                        debug residual => _20;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _21;
                        scope 13 {
                        }
                    }
                }
                scope 14 {
                    debug __i => _22;
                }
                scope 15 {
                    debug res => _27;
                }
                scope 16 {
                    debug iter => _35;
                    let _39: &devise::MetaItem;
                    scope 17 {
                        debug __meta => _39;
                        let _40: proc_macro2::Span;
                        scope 18 {
                            debug __span => _40;
                            let _41: &proc_macro2::Ident;
                            let _44: &proc_macro2::Ident;
                            scope 19 {
                                debug __name => _41;
                                let _46: std::string::String;
                                let mut _66: &[&str; 2];
                                scope 21 {
                                    debug __msg => _46;
                                }
                                scope 22 {
                                    debug res => _46;
                                }
                            }
                            scope 20 {
                                debug __ident => _44;
                            }
                        }
                    }
                }
                scope 23 {
                    debug residual => _63;
                    scope 24 {
                    }
                }
                scope 25 {
                    debug val => _64;
                    scope 26 {
                    }
                }
            }
            scope 8 {
                let mut _9: std::option::Option<attribute::catch::parse::Code>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _69 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _68 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_68 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _69 = const true;
        _3 = move _8;
        _9 = Option::<Code>::None;
        _11 = &mut _3;
        _10 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(move _11) -> [return: bb7, unwind: bb51];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<catch::parse::Meta, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb45, unwind continue];
    }

    bb7: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb5];
    }

    bb8: {
        _26 = _2;
        _65 = const _;
        _29 = _65 as &[&str] (PointerCoercion(Unsize));
        _32 = core::fmt::rt::Argument::<'_>::none() -> [return: bb19, unwind: bb51];
    }

    bb9: {
        _14 = &((_10 as Some).0: &devise::MetaItem);
        _67 = deref_copy (*_14);
        _15 = devise::MetaItem::is_bare(_67) -> [return: bb10, unwind: bb51];
    }

    bb10: {
        switchInt(move _15) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _13 = ((_10 as Some).0: &devise::MetaItem);
        _18 = <Code as devise::FromMeta>::from_meta(_13) -> [return: bb13, unwind: bb51];
    }

    bb12: {
        _22 = ((_10 as Some).0: &devise::MetaItem);
        _24 = <devise::MetaItem as devise::Spanned>::span(_22) -> [return: bb17, unwind: bb51];
    }

    bb13: {
        _17 = <std::result::Result<Code, devise::Diagnostic> as std::ops::Try>::branch(move _18) -> [return: bb14, unwind: bb51];
    }

    bb14: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb15, 1: bb16, otherwise: bb5];
    }

    bb15: {
        _21 = move ((_17 as Continue).0: attribute::catch::parse::Code);
        _16 = Option::<Code>::Some(move _21);
        _9 = move _16;
        _69 = const false;
        _34 = move _3;
        _33 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _34) -> [return: bb23, unwind: bb51];
    }

    bb16: {
        _20 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<catch::parse::Meta, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _20) -> [return: bb52, unwind: bb51];
    }

    bb17: {
        _23 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _24, const "unexpected keyed parameter: expected literal or identifier") -> [return: bb18, unwind: bb51];
    }

    bb18: {
        _0 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::Err(move _23);
        goto -> bb44;
    }

    bb19: {
        _31 = &_32;
        _30 = _31 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _28 = std::fmt::Arguments::<'_>::new_v1(move _29, move _30) -> [return: bb20, unwind: bb51];
    }

    bb20: {
        _27 = format(move _28) -> [return: bb21, unwind: bb51];
    }

    bb21: {
        _25 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _26, move _27) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        _0 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::Err(move _25);
        goto -> bb44;
    }

    bb23: {
        _35 = move _33;
        _37 = &mut _35;
        _36 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_37) -> [return: bb24, unwind: bb47];
    }

    bb24: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb26, 1: bb25, otherwise: bb5];
    }

    bb25: {
        _39 = ((_36 as Some).0: &devise::MetaItem);
        _40 = <devise::MetaItem as devise::Spanned>::span(_39) -> [return: bb27, unwind: bb47];
    }

    bb26: {
        drop(_35) -> [return: bb36, unwind: bb51];
    }

    bb27: {
        _42 = devise::MetaItem::name(_39) -> [return: bb28, unwind: bb47];
    }

    bb28: {
        _43 = discriminant(_42);
        switchInt(move _43) -> [0: bb29, 1: bb30, otherwise: bb5];
    }

    bb29: {
        _45 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_40, const "expected key/value `key = value`") -> [return: bb31, unwind: bb47];
    }

    bb30: {
        _44 = ((_42 as Some).0: &proc_macro2::Ident);
        _41 = _44;
        _66 = const _;
        _48 = _66 as &[&str] (PointerCoercion(Unsize));
        _53 = &_41;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_53) -> [return: bb32, unwind: bb47];
    }

    bb31: {
        _0 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::Err(move _45);
        goto -> bb43;
    }

    bb32: {
        _51 = [move _52];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _47 = std::fmt::Arguments::<'_>::new_v1(move _48, move _49) -> [return: bb33, unwind: bb47];
    }

    bb33: {
        _46 = format(move _47) -> [return: bb34, unwind: bb47];
    }

    bb34: {
        _54 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_40, move _46) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _0 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::Err(move _54);
        goto -> bb43;
    }

    bb36: {
        _59 = move _9;
        _58 = Option::<Code>::or_else::<fn() -> Option<Code> {<Code as devise::FromMeta>::default}>(move _59, <Code as devise::FromMeta>::default) -> [return: bb37, unwind: bb51];
    }

    bb37: {
        _61 = &_2;
        _60 = {closure@core/codegen/src/attribute/catch/parse.rs:18:5: 18:6} { __span: move _61 };
        _57 = Option::<Code>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/catch/parse.rs:18:5: 18:6}>(move _58, move _60) -> [return: bb38, unwind: bb51];
    }

    bb38: {
        _56 = <std::result::Result<Code, devise::Diagnostic> as std::ops::Try>::branch(move _57) -> [return: bb39, unwind: bb51];
    }

    bb39: {
        _62 = discriminant(_56);
        switchInt(move _62) -> [0: bb40, 1: bb41, otherwise: bb5];
    }

    bb40: {
        _64 = move ((_56 as Continue).0: attribute::catch::parse::Code);
        _55 = catch::parse::Meta { code: move _64 };
        _0 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::Ok(move _55);
        _69 = const false;
        goto -> bb46;
    }

    bb41: {
        _63 = move ((_56 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<catch::parse::Meta, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _63) -> [return: bb42, unwind continue];
    }

    bb42: {
        _69 = const false;
        goto -> bb46;
    }

    bb43: {
        drop(_35) -> [return: bb44, unwind: bb51];
    }

    bb44: {
        switchInt(_69) -> [0: bb45, otherwise: bb49];
    }

    bb45: {
        _69 = const false;
        goto -> bb46;
    }

    bb46: {
        return;
    }

    bb47 (cleanup): {
        drop(_35) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        resume;
    }

    bb49: {
        drop(_3) -> [return: bb45, unwind continue];
    }

    bb50 (cleanup): {
        drop(_3) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        switchInt(_69) -> [0: bb48, otherwise: bb50];
    }

    bb52: {
        goto -> bb44;
    }
}

promoted[0] in catch::parse::_::<impl at core/codegen/src/attribute/catch/parse.rs:16:10: 16:18>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing expected parameter: `code`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in catch::parse::_::<impl at core/codegen/src/attribute/catch/parse.rs:16:10: 16:18>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

fn catch::parse::_::<impl at core/codegen/src/attribute/catch/parse.rs:16:10: 16:18>::from_meta::{closure#0}(_1: {closure@core/codegen/src/attribute/catch/parse.rs:18:5: 18:6}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in catch::parse::_::<impl at core/codegen/src/attribute/catch/parse.rs:16:10: 16:18>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `code`"];
        _0 = &_1;
        return;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:23:10: 23:15>::fmt(_1: &Code, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&std::option::Option<rocket_http::Status>;
    let _6: &std::option::Option<rocket_http::Status>;

    bb0: {
        _3 = const "Code";
        _6 = &((*_1).0: std::option::Option<rocket_http::Status>);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:26:1: 26:23>::from_meta(_1: &devise::MetaItem) -> std::result::Result<Code, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<attribute::catch::parse::Code, devise::Diagnostic>;
    let mut _2: bool;
    let mut _3: &std::result::Result<usize, devise::Diagnostic>;
    let _4: std::result::Result<usize, devise::Diagnostic>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, http_codegen::Status>;
    let mut _6: std::result::Result<http_codegen::Status, devise::Diagnostic>;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _9: http_codegen::Status;
    let mut _10: attribute::catch::parse::Code;
    let mut _11: std::option::Option<rocket_http::Status>;
    let mut _12: rocket_http::Status;
    let mut _13: isize;
    let mut _15: bool;
    let _16: &str;
    let mut _17: attribute::catch::parse::Code;
    let mut _18: std::option::Option<rocket_http::Status>;
    let mut _19: devise::Diagnostic;
    let mut _20: proc_macro2::Span;
    let _21: std::string::String;
    let _22: std::string::String;
    let mut _23: std::fmt::Arguments<'_>;
    let mut _24: &[&str];
    let mut _25: &[core::fmt::rt::Argument<'_>];
    let _26: &[core::fmt::rt::Argument<'_>; 1];
    let _27: [core::fmt::rt::Argument<'_>; 1];
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &&str;
    let _30: &str;
    let mut _31: devise::Diagnostic;
    let mut _32: proc_macro2::Span;
    let mut _33: std::string::String;
    let mut _34: &[&str; 1];
    let mut _35: bool;
    scope 1 {
        debug status => _9;
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }
    scope 6 {
        debug path => _14;
        let _14: &syn::Path;
    }
    scope 7 {
        debug msg => _21;
    }
    scope 8 {
        debug res => _22;
    }

    bb0: {
        _35 = const false;
        _4 = <usize as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _2 = std::result::Result::<usize, devise::Diagnostic>::is_ok(move _3) -> [return: bb2, unwind: bb26];
    }

    bb2: {
        switchInt(move _2) -> [0: bb10, otherwise: bb3];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = <http_codegen::Status as devise::FromMeta>::from_meta(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = <std::result::Result<http_codegen::Status, devise::Diagnostic> as std::ops::Try>::branch(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _9 = move ((_5 as Continue).0: http_codegen::Status);
        _12 = (_9.0: rocket_http::Status);
        _11 = Option::<rocket_http::Status>::Some(move _12);
        _10 = Code(move _11);
        _0 = std::result::Result::<Code, devise::Diagnostic>::Ok(move _10);
        goto -> bb25;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<Code, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _8) -> [return: bb25, unwind continue];
    }

    bb10: {
        drop(_4) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = discriminant((*_1));
        switchInt(move _13) -> [0: bb12, otherwise: bb18];
    }

    bb12: {
        _14 = &(((*_1) as Path).0: syn::Path);
        _16 = const "default";
        _15 = syn::path::parsing::<impl syn::Path>::is_ident::<str>(_14, _16) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _15) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _18 = Option::<rocket_http::Status>::None;
        _17 = Code(move _18);
        _0 = std::result::Result::<Code, devise::Diagnostic>::Ok(move _17);
        goto -> bb25;
    }

    bb15: {
        _20 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb16, unwind continue];
    }

    bb16: {
        _19 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _20, const "expected `default`") -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = std::result::Result::<Code, devise::Diagnostic>::Err(move _19);
        goto -> bb25;
    }

    bb18: {
        _34 = const _;
        _24 = _34 as &[&str] (PointerCoercion(Unsize));
        _30 = devise::MetaItem::description(_1) -> [return: bb19, unwind continue];
    }

    bb19: {
        _29 = &_30;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_29) -> [return: bb20, unwind continue];
    }

    bb20: {
        _27 = [move _28];
        _26 = &_27;
        _25 = _26 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _23 = std::fmt::Arguments::<'_>::new_v1(move _24, move _25) -> [return: bb21, unwind continue];
    }

    bb21: {
        _22 = format(move _23) -> [return: bb22, unwind continue];
    }

    bb22: {
        _35 = const true;
        _21 = move _22;
        _32 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        _35 = const false;
        _33 = move _21;
        _31 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _32, move _33) -> [return: bb24, unwind: bb29];
    }

    bb24: {
        _0 = std::result::Result::<Code, devise::Diagnostic>::Err(move _31);
        _35 = const false;
        goto -> bb25;
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        drop(_4) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }

    bb28 (cleanup): {
        drop(_21) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        switchInt(_35) -> [0: bb27, otherwise: bb28];
    }
}

promoted[0] in catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:26:1: 26:23>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "expected integer or `default`, found "];
        _0 = &_1;
        return;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:44:1: 44:15>::parse(_1: TokenStream2, _2: proc_macro::TokenStream) -> std::result::Result<catch::parse::Attribute, devise::Diagnostic> {
    debug args => _1;
    debug input => _2;
    let mut _0: std::result::Result<attribute::catch::parse::Attribute, devise::Diagnostic>;
    let _3: syn::ItemFn;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::ItemFn>;
    let mut _5: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _6: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _7: std::result::Result<syn::ItemFn, syn::Error>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _10: syn::ItemFn;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, devise::MetaItem>;
    let mut _13: std::result::Result<devise::MetaItem, syn::Error>;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let mut _21: proc_macro2::Delimiter;
    let mut _22: proc_macro2::TokenStream;
    let _24: ();
    let _25: &proc_macro2::TokenStream;
    let mut _26: &mut proc_macro2::TokenStream;
    let mut _27: isize;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<rocket_http::Status>>;
    let mut _31: std::result::Result<std::option::Option<rocket_http::Status>, devise::Diagnostic>;
    let mut _32: std::result::Result<std::option::Option<rocket_http::Status>, devise::Diagnostic>;
    let mut _33: std::result::Result<attribute::catch::parse::Meta, devise::Diagnostic>;
    let _34: &devise::MetaItem;
    let mut _35: isize;
    let mut _38: attribute::catch::parse::Attribute;
    let mut _39: syn::ItemFn;
    let mut _40: bool;
    scope 1 {
        debug function => _3;
        let _11: devise::MetaItem;
        let mut _15: proc_macro2::TokenStream;
        let _28: std::result::Result<std::convert::Infallible, syn::Error>;
        let _29: devise::MetaItem;
        scope 6 {
            debug attr => _11;
            let _36: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
            let _37: std::option::Option<rocket_http::Status>;
            scope 13 {
                debug status => _37;
            }
            scope 14 {
                debug residual => _36;
                scope 15 {
                }
            }
            scope 16 {
                debug val => _37;
                scope 17 {
                }
            }
        }
        scope 7 {
            debug _s => _15;
            let mut _23: proc_macro2::TokenStream;
            scope 8 {
                debug _s => _23;
            }
        }
        scope 9 {
            debug residual => _28;
            scope 10 {
            }
        }
        scope 11 {
            debug val => _29;
            scope 12 {
            }
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _40 = const false;
        _7 = syn::parse::<ItemFn>(move _2) -> [return: bb1, unwind: bb31];
    }

    bb1: {
        _6 = std::result::Result::<ItemFn, syn::Error>::map_err::<devise::Diagnostic, fn(syn::Error) -> devise::Diagnostic {<devise::Diagnostic as From<syn::Error>>::from}>(move _7, <devise::Diagnostic as From<syn::Error>>::from) -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _5 = std::result::Result::<ItemFn, devise::Diagnostic>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/catch/parse.rs:48:22: 48:28}>(move _6, const ZeroSized: {closure@core/codegen/src/attribute/catch/parse.rs:48:22: 48:28}) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _4 = <std::result::Result<ItemFn, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_4 as Continue).0: syn::ItemFn);
        _40 = const true;
        _3 = move _10;
        _15 = TokenStream2::new() -> [return: bb8, unwind: bb34];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<catch::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _9) -> [return: bb35, unwind: bb31];
    }

    bb8: {
        _17 = &mut _15;
        _18 = const "catch";
        _16 = push_ident(_17, _18) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _20 = &mut _15;
        _21 = proc_macro2::Delimiter::Parenthesis;
        _23 = TokenStream2::new() -> [return: bb10, unwind: bb30];
    }

    bb10: {
        _25 = &_1;
        _26 = &mut _23;
        _24 = <TokenStream2 as ToTokens>::to_tokens(_25, _26) -> [return: bb11, unwind: bb29];
    }

    bb11: {
        _22 = move _23;
        _19 = push_group(_20, move _21, move _22) -> [return: bb12, unwind: bb30];
    }

    bb12: {
        _14 = move _15;
        _13 = syn::parse2::<devise::MetaItem>(move _14) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _12 = <std::result::Result<devise::MetaItem, syn::Error> as std::ops::Try>::branch(move _13) -> [return: bb14, unwind: bb34];
    }

    bb14: {
        _27 = discriminant(_12);
        switchInt(move _27) -> [0: bb15, 1: bb16, otherwise: bb6];
    }

    bb15: {
        _29 = move ((_12 as Continue).0: devise::MetaItem);
        _11 = move _29;
        _34 = &_11;
        _33 = <catch::parse::Meta as devise::FromMeta>::from_meta(_34) -> [return: bb17, unwind: bb28];
    }

    bb16: {
        _28 = move ((_12 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<catch::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _28) -> [return: bb36, unwind: bb34];
    }

    bb17: {
        _32 = std::result::Result::<catch::parse::Meta, devise::Diagnostic>::map::<Option<rocket_http::Status>, {closure@core/codegen/src/attribute/catch/parse.rs:52:18: 52:24}>(move _33, const ZeroSized: {closure@core/codegen/src/attribute/catch/parse.rs:52:18: 52:24}) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _31 = std::result::Result::<Option<rocket_http::Status>, devise::Diagnostic>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/catch/parse.rs:53:22: 53:28}>(move _32, const ZeroSized: {closure@core/codegen/src/attribute/catch/parse.rs:53:22: 53:28}) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _30 = <std::result::Result<Option<rocket_http::Status>, devise::Diagnostic> as std::ops::Try>::branch(move _31) -> [return: bb20, unwind: bb28];
    }

    bb20: {
        _35 = discriminant(_30);
        switchInt(move _35) -> [0: bb21, 1: bb22, otherwise: bb6];
    }

    bb21: {
        _37 = ((_30 as Continue).0: std::option::Option<rocket_http::Status>);
        _40 = const false;
        _39 = move _3;
        _38 = catch::parse::Attribute { status: _37, function: move _39 };
        _0 = std::result::Result::<catch::parse::Attribute, devise::Diagnostic>::Ok(move _38);
        drop(_11) -> [return: bb24, unwind: bb34];
    }

    bb22: {
        _36 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<catch::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _36) -> [return: bb23, unwind: bb28];
    }

    bb23: {
        drop(_11) -> [return: bb25, unwind: bb34];
    }

    bb24: {
        _40 = const false;
        drop(_1) -> [return: bb27, unwind continue];
    }

    bb25: {
        drop(_3) -> [return: bb26, unwind: bb31];
    }

    bb26: {
        _40 = const false;
        drop(_1) -> [return: bb27, unwind continue];
    }

    bb27: {
        return;
    }

    bb28 (cleanup): {
        drop(_11) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_23) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_15) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_1) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33 (cleanup): {
        drop(_3) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        switchInt(_40) -> [0: bb31, otherwise: bb33];
    }

    bb35: {
        goto -> bb26;
    }

    bb36: {
        goto -> bb25;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:44:1: 44:15>::parse::{closure#0}(_1: {closure@core/codegen/src/attribute/catch/parse.rs:48:22: 48:28}, _2: devise::Diagnostic) -> devise::Diagnostic {
    debug diag => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = devise::Diagnostic::help::<&str>(move _2, const "`#[catch]` can only be used on functions") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:44:1: 44:15>::parse::{closure#1}(_1: {closure@core/codegen/src/attribute/catch/parse.rs:52:18: 52:24}, _2: catch::parse::Meta) -> Option<rocket_http::Status> {
    debug meta => _2;
    let mut _0: std::option::Option<rocket_http::Status>;

    bb0: {
        _0 = ((_2.0: attribute::catch::parse::Code).0: std::option::Option<rocket_http::Status>);
        return;
    }
}

fn catch::parse::<impl at core/codegen/src/attribute/catch/parse.rs:44:1: 44:15>::parse::{closure#2}(_1: {closure@core/codegen/src/attribute/catch/parse.rs:53:22: 53:28}, _2: devise::Diagnostic) -> devise::Diagnostic {
    debug diag => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = devise::Diagnostic::help::<&str>(move _2, const "`#[catch]` expects a status code int or `default`: `#[catch(404)]` or `#[catch(default)]`") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _catch(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug args => _1;
    debug input => _2;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _3: attribute::catch::parse::Attribute;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::catch::parse::Attribute>;
    let mut _5: std::result::Result<attribute::catch::parse::Attribute, devise::Diagnostic>;
    let mut _6: proc_macro2::TokenStream;
    let mut _7: proc_macro::TokenStream;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _10: attribute::catch::parse::Attribute;
    let mut _15: std::option::Option<u16>;
    let mut _16: std::option::Option<rocket_http::Status>;
    let mut _17: bool;
    let mut _18: usize;
    let mut _19: &syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>;
    let mut _20: devise::Diagnostic;
    let mut _21: devise::Diagnostic;
    let mut _22: proc_macro2::Span;
    let mut _24: std::option::Option<proc_macro2::Span>;
    let mut _25: std::option::Option<&syn::Type>;
    let mut _26: &syn::ReturnType;
    let mut _27: proc_macro2::Span;
    let mut _28: proc_macro2::Span;
    let mut _30: std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>;
    let mut _31: std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>;
    let mut _32: std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>;
    let mut _33: syn::punctuated::Iter<'_, syn::FnArg>;
    let mut _34: &syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>;
    let mut _35: std::slice::Iter<'_, exports::StaticPath>;
    let mut _37: std::option::Option<syn::token::Async>;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let mut _42: proc_macro2::Delimiter;
    let mut _43: proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let _54: &&proc_macro2::Ident;
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let mut _58: proc_macro2::Delimiter;
    let mut _59: proc_macro2::TokenStream;
    let mut _63: (std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>, quote::__private::HasIterator);
    let mut _64: std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>;
    let mut _66: bool;
    let mut _68: std::option::Option<exports::StaticPath>;
    let mut _69: &mut std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>;
    let mut _70: isize;
    let mut _72: bool;
    let mut _73: usize;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let mut _76: (usize, bool);
    let _77: ();
    let _78: &quote::__private::RepInterp<exports::StaticPath>;
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: ();
    let _81: &std::option::Option<proc_macro2::TokenStream>;
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: &str;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: &str;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let mut _99: proc_macro2::Delimiter;
    let mut _100: proc_macro2::TokenStream;
    let _102: ();
    let mut _103: &mut proc_macro2::TokenStream;
    let _104: &str;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let mut _111: proc_macro2::TokenStream;
    let _113: ();
    let _114: &&syn::ItemFn;
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let mut _120: proc_macro2::Delimiter;
    let mut _121: proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: &str;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let mut _128: proc_macro2::Delimiter;
    let mut _129: proc_macro2::TokenStream;
    let _131: ();
    let mut _132: &mut proc_macro2::TokenStream;
    let _133: &str;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: ();
    let mut _137: &mut proc_macro2::TokenStream;
    let mut _138: proc_macro2::Delimiter;
    let mut _139: proc_macro2::TokenStream;
    let _141: ();
    let mut _142: &mut proc_macro2::TokenStream;
    let _143: &str;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let mut _146: proc_macro2::Delimiter;
    let mut _147: proc_macro2::TokenStream;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: &str;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let mut _156: proc_macro2::Delimiter;
    let mut _157: proc_macro2::TokenStream;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: &str;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: ();
    let mut _165: &mut proc_macro2::TokenStream;
    let _166: &str;
    let _167: ();
    let _168: &&syn::Visibility;
    let mut _169: &mut proc_macro2::TokenStream;
    let _170: ();
    let mut _171: &mut proc_macro2::TokenStream;
    let _172: &str;
    let _173: ();
    let _174: &&proc_macro2::Ident;
    let mut _175: &mut proc_macro2::TokenStream;
    let _176: ();
    let mut _177: &mut proc_macro2::TokenStream;
    let mut _178: proc_macro2::Delimiter;
    let mut _179: proc_macro2::TokenStream;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let _182: ();
    let mut _183: &mut proc_macro2::TokenStream;
    let mut _184: proc_macro2::Delimiter;
    let mut _185: proc_macro2::TokenStream;
    let _187: ();
    let mut _188: &mut proc_macro2::TokenStream;
    let _189: &str;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let _192: ();
    let mut _193: &mut proc_macro2::TokenStream;
    let _194: &str;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: &str;
    let _198: ();
    let _199: &&proc_macro2::Ident;
    let mut _200: &mut proc_macro2::TokenStream;
    let _201: ();
    let mut _202: &mut proc_macro2::TokenStream;
    let mut _203: proc_macro2::Delimiter;
    let mut _204: proc_macro2::TokenStream;
    let _206: ();
    let mut _207: &mut proc_macro2::TokenStream;
    let _208: &str;
    let _209: ();
    let mut _210: &mut proc_macro2::TokenStream;
    let _211: &str;
    let _212: ();
    let mut _213: &mut proc_macro2::TokenStream;
    let mut _214: proc_macro2::Delimiter;
    let mut _215: proc_macro2::TokenStream;
    let _217: ();
    let mut _218: &mut proc_macro2::TokenStream;
    let _219: &str;
    let _220: ();
    let mut _221: &mut proc_macro2::TokenStream;
    let _222: ();
    let mut _223: &mut proc_macro2::TokenStream;
    let _224: ();
    let mut _225: &mut proc_macro2::TokenStream;
    let _226: ();
    let mut _227: &mut proc_macro2::TokenStream;
    let _228: &str;
    let _229: ();
    let mut _230: &mut proc_macro2::TokenStream;
    let mut _231: proc_macro2::Delimiter;
    let mut _232: proc_macro2::TokenStream;
    let _234: ();
    let mut _235: &mut proc_macro2::TokenStream;
    let _236: &str;
    let _237: ();
    let mut _238: &mut proc_macro2::TokenStream;
    let _239: &str;
    let _240: ();
    let mut _241: &mut proc_macro2::TokenStream;
    let _242: ();
    let mut _243: &mut proc_macro2::TokenStream;
    let _244: &str;
    let _245: ();
    let mut _246: &mut proc_macro2::TokenStream;
    let _247: ();
    let mut _248: &mut proc_macro2::TokenStream;
    let mut _249: proc_macro2::Delimiter;
    let mut _250: proc_macro2::TokenStream;
    let _252: ();
    let mut _253: &mut proc_macro2::TokenStream;
    let _254: ();
    let mut _255: &mut proc_macro2::TokenStream;
    let _256: ();
    let mut _257: &mut proc_macro2::TokenStream;
    let _258: ();
    let mut _259: &mut proc_macro2::TokenStream;
    let _260: ();
    let mut _261: &mut proc_macro2::TokenStream;
    let _262: ();
    let mut _263: &mut proc_macro2::TokenStream;
    let _264: ();
    let mut _265: &mut proc_macro2::TokenStream;
    let _266: ();
    let mut _267: &mut proc_macro2::TokenStream;
    let _268: &str;
    let _269: ();
    let mut _270: &mut proc_macro2::TokenStream;
    let _271: ();
    let mut _272: &mut proc_macro2::TokenStream;
    let _273: ();
    let mut _274: &mut proc_macro2::TokenStream;
    let _275: &str;
    let _276: ();
    let mut _277: &mut proc_macro2::TokenStream;
    let _278: ();
    let mut _279: &mut proc_macro2::TokenStream;
    let _280: ();
    let mut _281: &mut proc_macro2::TokenStream;
    let _282: ();
    let mut _283: &mut proc_macro2::TokenStream;
    let _284: ();
    let mut _285: &mut proc_macro2::TokenStream;
    let _286: &str;
    let _287: ();
    let mut _288: &mut proc_macro2::TokenStream;
    let _289: ();
    let mut _290: &mut proc_macro2::TokenStream;
    let _291: &str;
    let _292: ();
    let mut _293: &mut proc_macro2::TokenStream;
    let _294: ();
    let mut _295: &mut proc_macro2::TokenStream;
    let mut _296: proc_macro2::Delimiter;
    let mut _297: proc_macro2::TokenStream;
    let _299: ();
    let mut _300: &mut proc_macro2::TokenStream;
    let _301: ();
    let mut _302: &mut proc_macro2::TokenStream;
    let _303: ();
    let mut _304: &mut proc_macro2::TokenStream;
    let _305: &str;
    let _306: ();
    let mut _307: &mut proc_macro2::TokenStream;
    let mut _308: proc_macro2::Delimiter;
    let mut _309: proc_macro2::TokenStream;
    let _311: ();
    let mut _312: &mut proc_macro2::TokenStream;
    let _313: &str;
    let _314: ();
    let mut _315: &mut proc_macro2::TokenStream;
    let _316: &str;
    let _317: ();
    let mut _318: &mut proc_macro2::TokenStream;
    let mut _319: proc_macro2::Delimiter;
    let mut _320: proc_macro2::TokenStream;
    let _322: ();
    let mut _323: &mut proc_macro2::TokenStream;
    let _324: &str;
    let _325: ();
    let mut _326: &mut proc_macro2::TokenStream;
    let _327: &str;
    let _328: ();
    let mut _329: &mut proc_macro2::TokenStream;
    let _330: ();
    let _331: &proc_macro2::TokenStream;
    let mut _332: &mut proc_macro2::TokenStream;
    let _333: ();
    let mut _334: &mut proc_macro2::TokenStream;
    let _335: ();
    let mut _336: &mut proc_macro2::TokenStream;
    let _337: ();
    let mut _338: &mut proc_macro2::TokenStream;
    let _339: ();
    let mut _340: &mut proc_macro2::TokenStream;
    let _341: &str;
    let _342: ();
    let mut _343: &mut proc_macro2::TokenStream;
    let mut _344: proc_macro2::Delimiter;
    let mut _345: proc_macro2::TokenStream;
    let _346: ();
    let mut _347: &mut proc_macro2::TokenStream;
    let _348: ();
    let mut _349: &mut proc_macro2::TokenStream;
    let _350: &str;
    let _351: ();
    let mut _352: &mut proc_macro2::TokenStream;
    let mut _353: proc_macro2::Delimiter;
    let mut _354: proc_macro2::TokenStream;
    let _356: ();
    let mut _357: &mut proc_macro2::TokenStream;
    let _358: ();
    let mut _359: &mut proc_macro2::TokenStream;
    let _360: ();
    let mut _361: &mut proc_macro2::TokenStream;
    let _362: &str;
    let _363: ();
    let mut _364: &mut proc_macro2::TokenStream;
    let mut _365: proc_macro2::Delimiter;
    let mut _366: proc_macro2::TokenStream;
    let _368: ();
    let mut _369: &mut proc_macro2::TokenStream;
    let _370: &str;
    let _371: ();
    let mut _372: &mut proc_macro2::TokenStream;
    let _373: ();
    let mut _374: &mut proc_macro2::TokenStream;
    let _375: &str;
    let _376: ();
    let mut _377: &mut proc_macro2::TokenStream;
    let mut _378: proc_macro2::Delimiter;
    let mut _379: proc_macro2::TokenStream;
    let _380: ();
    let mut _381: &mut proc_macro2::TokenStream;
    let _382: ();
    let mut _383: &mut proc_macro2::TokenStream;
    let _384: ();
    let mut _385: &mut proc_macro2::TokenStream;
    let _386: &str;
    let _387: ();
    let mut _388: &mut proc_macro2::TokenStream;
    let mut _389: proc_macro2::Delimiter;
    let mut _390: proc_macro2::TokenStream;
    let _392: ();
    let mut _393: &mut proc_macro2::TokenStream;
    let _394: &str;
    let _395: ();
    let mut _396: &mut proc_macro2::TokenStream;
    let _397: ();
    let mut _398: &mut proc_macro2::TokenStream;
    let _399: &str;
    let _400: ();
    let mut _401: &mut proc_macro2::TokenStream;
    let _402: ();
    let mut _403: &mut proc_macro2::TokenStream;
    let mut _404: proc_macro2::Delimiter;
    let mut _405: proc_macro2::TokenStream;
    let _407: ();
    let _408: &&proc_macro2::Ident;
    let mut _409: &mut proc_macro2::TokenStream;
    let _410: ();
    let mut _411: &mut proc_macro2::TokenStream;
    let _412: ();
    let mut _413: &mut proc_macro2::TokenStream;
    let _414: &str;
    let _415: ();
    let mut _416: &mut proc_macro2::TokenStream;
    let _417: ();
    let _418: &http_codegen::Optional<u16>;
    let mut _419: &mut proc_macro2::TokenStream;
    let _420: ();
    let mut _421: &mut proc_macro2::TokenStream;
    let _422: ();
    let mut _423: &mut proc_macro2::TokenStream;
    let _424: &str;
    let _425: ();
    let mut _426: &mut proc_macro2::TokenStream;
    let _427: ();
    let mut _428: &mut proc_macro2::TokenStream;
    let _429: &str;
    let _430: ();
    let mut _431: &mut proc_macro2::TokenStream;
    let _432: ();
    let mut _433: &mut proc_macro2::TokenStream;
    let _434: ();
    let mut _435: &mut proc_macro2::TokenStream;
    let mut _436: proc_macro2::Delimiter;
    let mut _437: proc_macro2::TokenStream;
    let _439: ();
    let mut _440: &mut proc_macro2::TokenStream;
    let _441: &str;
    let _442: ();
    let mut _443: &mut proc_macro2::TokenStream;
    let mut _444: proc_macro2::Delimiter;
    let mut _445: proc_macro2::TokenStream;
    let _447: ();
    let mut _448: &mut proc_macro2::TokenStream;
    let _449: &str;
    let _450: ();
    let mut _451: &mut proc_macro2::TokenStream;
    let _452: &str;
    let _453: ();
    let mut _454: &mut proc_macro2::TokenStream;
    let _455: &str;
    let _456: ();
    let mut _457: &mut proc_macro2::TokenStream;
    let _458: &str;
    let _459: ();
    let mut _460: &mut proc_macro2::TokenStream;
    let mut _461: proc_macro2::Delimiter;
    let mut _462: proc_macro2::TokenStream;
    let _464: ();
    let mut _465: &mut proc_macro2::TokenStream;
    let _466: &str;
    let _467: ();
    let mut _468: &mut proc_macro2::TokenStream;
    let _469: ();
    let mut _470: &mut proc_macro2::TokenStream;
    let _471: ();
    let mut _472: &mut proc_macro2::TokenStream;
    let mut _473: proc_macro2::Delimiter;
    let mut _474: proc_macro2::TokenStream;
    let _476: ();
    let mut _477: &mut proc_macro2::TokenStream;
    let _478: &str;
    let _479: ();
    let mut _480: &mut proc_macro2::TokenStream;
    let _481: ();
    let mut _482: &mut proc_macro2::TokenStream;
    let _483: &str;
    let _484: ();
    let mut _485: &mut proc_macro2::TokenStream;
    let mut _486: proc_macro2::Delimiter;
    let mut _487: proc_macro2::TokenStream;
    let _488: ();
    let mut _489: &mut proc_macro2::TokenStream;
    let _490: ();
    let mut _491: &mut proc_macro2::TokenStream;
    let _492: &str;
    let _493: ();
    let mut _494: &mut proc_macro2::TokenStream;
    let mut _495: proc_macro2::Delimiter;
    let mut _496: proc_macro2::TokenStream;
    let mut _511: bool;
    let mut _512: bool;
    let mut _513: bool;
    scope 1 {
        debug catch => _3;
        let _11: &syn::ItemFn;
        scope 6 {
            debug user_catcher_fn => _11;
            let _12: &proc_macro2::Ident;
            scope 7 {
                debug user_catcher_fn_name => _12;
                let _13: &syn::Visibility;
                scope 8 {
                    debug vis => _13;
                    let _14: http_codegen::Optional<u16>;
                    scope 9 {
                        debug status_code => _14;
                        let _23: proc_macro2::Span;
                        scope 10 {
                            debug return_type_span => _23;
                            let mut _510: &[exports::StaticPath; 2];
                            scope 11 {
                                debug codegen_args => const _;
                                let _29: std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>;
                                scope 12 {
                                    debug inputs => _29;
                                    let _36: std::option::Option<proc_macro2::TokenStream>;
                                    scope 13 {
                                        debug dot_await => _36;
                                        let _38: proc_macro2::TokenStream;
                                        let mut _39: proc_macro2::TokenStream;
                                        scope 14 {
                                            debug catcher_response => _38;
                                            let mut _112: proc_macro2::TokenStream;
                                            scope 31 {
                                                debug _s => _112;
                                                let mut _122: proc_macro2::TokenStream;
                                                let mut _140: proc_macro2::TokenStream;
                                                let mut _158: proc_macro2::TokenStream;
                                                let mut _186: proc_macro2::TokenStream;
                                                let mut _205: proc_macro2::TokenStream;
                                                scope 32 {
                                                    debug _s => _122;
                                                    let mut _130: proc_macro2::TokenStream;
                                                    scope 33 {
                                                        debug _s => _130;
                                                    }
                                                }
                                                scope 34 {
                                                    debug _s => _140;
                                                    let mut _148: proc_macro2::TokenStream;
                                                    scope 35 {
                                                        debug _s => _148;
                                                    }
                                                }
                                                scope 36 {
                                                    debug _s => _158;
                                                }
                                                scope 37 {
                                                    debug _s => _186;
                                                }
                                                scope 38 {
                                                    debug _s => _205;
                                                    let mut _216: proc_macro2::TokenStream;
                                                    let mut _233: proc_macro2::TokenStream;
                                                    let mut _438: proc_macro2::TokenStream;
                                                    let mut _463: proc_macro2::TokenStream;
                                                    let mut _475: proc_macro2::TokenStream;
                                                    let mut _497: &exports::StaticPath;
                                                    let mut _507: &exports::StaticPath;
                                                    scope 39 {
                                                        debug _s => _216;
                                                    }
                                                    scope 40 {
                                                        debug _s => _233;
                                                        let mut _251: proc_macro2::TokenStream;
                                                        let mut _298: proc_macro2::TokenStream;
                                                        let mut _391: proc_macro2::TokenStream;
                                                        let mut _498: &exports::StaticPath;
                                                        let mut _502: &exports::StaticPath;
                                                        scope 41 {
                                                            debug _s => _251;
                                                            let mut _503: &exports::StaticPath;
                                                            let mut _504: &exports::StaticPath;
                                                            let mut _505: &exports::StaticPath;
                                                            let mut _506: &exports::StaticPath;
                                                        }
                                                        scope 42 {
                                                            debug _s => _298;
                                                            let mut _310: proc_macro2::TokenStream;
                                                            let mut _501: &exports::StaticPath;
                                                            scope 43 {
                                                                debug _s => _310;
                                                                let mut _321: proc_macro2::TokenStream;
                                                                scope 44 {
                                                                    debug _s => _321;
                                                                    let mut _355: proc_macro2::TokenStream;
                                                                    let mut _367: proc_macro2::TokenStream;
                                                                    let mut _500: &exports::StaticPath;
                                                                    scope 45 {
                                                                        debug _s => _355;
                                                                        let mut _499: &exports::StaticPath;
                                                                    }
                                                                    scope 46 {
                                                                        debug _s => _367;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 47 {
                                                            debug _s => _391;
                                                            let mut _406: proc_macro2::TokenStream;
                                                            scope 48 {
                                                                debug _s => _406;
                                                            }
                                                        }
                                                    }
                                                    scope 49 {
                                                        debug _s => _438;
                                                        let mut _446: proc_macro2::TokenStream;
                                                        scope 50 {
                                                            debug _s => _446;
                                                        }
                                                    }
                                                    scope 51 {
                                                        debug _s => _463;
                                                    }
                                                    scope 52 {
                                                        debug _s => _475;
                                                    }
                                                }
                                            }
                                        }
                                        scope 15 {
                                            debug _s => _39;
                                            scope 16 {
                                                debug _span => _23;
                                                let mut _44: proc_macro2::TokenStream;
                                                scope 17 {
                                                    debug _s => _44;
                                                    scope 18 {
                                                        debug _span => _23;
                                                        let mut _60: proc_macro2::TokenStream;
                                                        let mut _101: proc_macro2::TokenStream;
                                                        let mut _509: &exports::StaticPath;
                                                        scope 19 {
                                                            debug _s => _60;
                                                            scope 20 {
                                                                debug _span => _23;
                                                                let mut _61: usize;
                                                                scope 21 {
                                                                    debug _i => _61;
                                                                    scope 22 {
                                                                        debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                        scope 23 {
                                                                            debug inputs => _62;
                                                                            debug i => const HasIterator;
                                                                            let _65: quote::__private::HasIterator;
                                                                            scope 25 {
                                                                                debug has_iter => const HasIterator;
                                                                                scope 26 {
                                                                                    let _67: quote::__private::RepInterp<exports::StaticPath>;
                                                                                    let _71: exports::StaticPath;
                                                                                    scope 27 {
                                                                                        debug inputs => _67;
                                                                                    }
                                                                                    scope 28 {
                                                                                        debug _x => _71;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                        scope 24 {
                                                                            let mut _62: std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 29 {
                                                            debug _s => _101;
                                                            scope 30 {
                                                                debug _span => _23;
                                                                let mut _508: &exports::StaticPath;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _513 = const false;
        _511 = const false;
        _512 = const false;
        _513 = const true;
        _6 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _1) -> [return: bb1, unwind: bb252];
    }

    bb1: {
        _513 = const false;
        _7 = move _2;
        _5 = catch::parse::Attribute::parse(move _6, move _7) -> [return: bb2, unwind: bb252];
    }

    bb2: {
        _4 = <std::result::Result<catch::parse::Attribute, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind: bb252];
    }

    bb3: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _10 = move ((_4 as Continue).0: attribute::catch::parse::Attribute);
        _3 = move _10;
        _11 = &(_3.1: syn::ItemFn);
        _12 = &(((_3.1: syn::ItemFn).2: syn::Signature).5: proc_macro2::Ident);
        _13 = &((_3.1: syn::ItemFn).1: syn::Visibility);
        _16 = (_3.0: std::option::Option<rocket_http::Status>);
        _15 = Option::<rocket_http::Status>::map::<u16, {closure@core/codegen/src/attribute/catch/mod.rs:22:49: 22:52}>(move _16, const ZeroSized: {closure@core/codegen/src/attribute/catch/mod.rs:22:49: 22:52}) -> [return: bb7, unwind: bb245];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _9) -> [return: bb253, unwind: bb252];
    }

    bb7: {
        _14 = Optional::<u16>(move _15);
        _19 = &(((_3.1: syn::ItemFn).2: syn::Signature).8: syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>);
        _18 = syn::punctuated::Punctuated::<syn::FnArg, syn::token::Comma>::len(move _19) -> [return: bb8, unwind: bb245];
    }

    bb8: {
        _17 = Gt(move _18, const 2_usize);
        switchInt(move _17) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _22 = ((((_3.1: syn::ItemFn).2: syn::Signature).7: syn::token::Paren).0: proc_macro2::Span);
        _21 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _22, const "invalid number of arguments: must be zero, one, or two") -> [return: bb10, unwind: bb245];
    }

    bb10: {
        _20 = devise::Diagnostic::help::<&str>(move _21, const "catchers optionally take `&Request` or `Status, &Request`") -> [return: bb11, unwind: bb245];
    }

    bb11: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _20);
        drop(_3) -> [return: bb215, unwind: bb252];
    }

    bb12: {
        _26 = &(((_3.1: syn::ItemFn).2: syn::Signature).10: syn::ReturnType);
        _25 = <ReturnType as ReturnTypeExt>::ty(move _26) -> [return: bb13, unwind: bb245];
    }

    bb13: {
        _24 = Option::<&syn::Type>::map::<proc_macro2::Span, {closure@core/codegen/src/attribute/catch/mod.rs:33:14: 33:18}>(move _25, const ZeroSized: {closure@core/codegen/src/attribute/catch/mod.rs:33:14: 33:18}) -> [return: bb14, unwind: bb245];
    }

    bb14: {
        _28 = proc_macro2::Span::call_site() -> [return: bb15, unwind: bb245];
    }

    bb15: {
        _27 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _28) -> [return: bb16, unwind: bb245];
    }

    bb16: {
        _23 = Option::<proc_macro2::Span>::unwrap_or(move _24, move _27) -> [return: bb17, unwind: bb245];
    }

    bb17: {
        _510 = const _;
        _34 = &(((_3.1: syn::ItemFn).2: syn::Signature).8: syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>);
        _33 = syn::punctuated::Punctuated::<syn::FnArg, syn::token::Comma>::iter(move _34) -> [return: bb18, unwind: bb245];
    }

    bb18: {
        _32 = <syn::punctuated::Iter<'_, syn::FnArg> as Iterator>::rev(move _33) -> [return: bb19, unwind: bb245];
    }

    bb19: {
        _512 = const true;
        _35 = <&[StaticPath; 2] as IntoIterator>::into_iter(_510) -> [return: bb20, unwind: bb250];
    }

    bb20: {
        _512 = const false;
        _31 = <Rev<syn::punctuated::Iter<'_, syn::FnArg>> as Iterator>::zip::<std::slice::Iter<'_, StaticPath>>(move _32, move _35) -> [return: bb21, unwind: bb250];
    }

    bb21: {
        _512 = const false;
        _30 = <Zip<Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, StaticPath>> as Iterator>::map::<StaticPath, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>(move _31, const ZeroSized: {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}) -> [return: bb22, unwind: bb245];
    }

    bb22: {
        _29 = <Map<Zip<Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}> as Iterator>::rev(move _30) -> [return: bb23, unwind: bb245];
    }

    bb23: {
        _511 = const true;
        _37 = (((_3.1: syn::ItemFn).2: syn::Signature).1: std::option::Option<syn::token::Async>);
        _36 = Option::<syn::token::Async>::map::<TokenStream2, {closure@core/codegen/src/attribute/catch/mod.rs:48:14: 48:17}>(move _37, const ZeroSized: {closure@core/codegen/src/attribute/catch/mod.rs:48:14: 48:17}) -> [return: bb24, unwind: bb248];
    }

    bb24: {
        _39 = TokenStream2::new() -> [return: bb25, unwind: bb244];
    }

    bb25: {
        _41 = &mut _39;
        _42 = proc_macro2::Delimiter::Brace;
        _44 = TokenStream2::new() -> [return: bb26, unwind: bb243];
    }

    bb26: {
        _46 = &mut _44;
        _47 = const "let";
        _45 = push_ident_spanned(_46, _23, _47) -> [return: bb27, unwind: bb242];
    }

    bb27: {
        _49 = &mut _44;
        _50 = const "___responder";
        _48 = push_ident_spanned(_49, _23, _50) -> [return: bb28, unwind: bb242];
    }

    bb28: {
        _52 = &mut _44;
        _51 = push_eq_spanned(_52, _23) -> [return: bb29, unwind: bb242];
    }

    bb29: {
        _54 = &_12;
        _55 = &mut _44;
        _53 = <&proc_macro2::Ident as ToTokens>::to_tokens(_54, _55) -> [return: bb30, unwind: bb242];
    }

    bb30: {
        _57 = &mut _44;
        _58 = proc_macro2::Delimiter::Parenthesis;
        _60 = TokenStream2::new() -> [return: bb31, unwind: bb242];
    }

    bb31: {
        _61 = const 0_usize;
        _511 = const false;
        _64 = move _29;
        _63 = <Rev<Map<Zip<Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _64) -> [return: bb32, unwind: bb241];
    }

    bb32: {
        _62 = move (_63.0: std::iter::Rev<std::iter::Map<std::iter::Zip<std::iter::Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, exports::StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>>);
        _65 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb254, unwind: bb240];
    }

    bb33: {
        _66 = const true;
        switchInt(move _66) -> [0: bb40, otherwise: bb34];
    }

    bb34: {
        _69 = &mut _62;
        _68 = <Rev<Map<Zip<Rev<syn::punctuated::Iter<'_, syn::FnArg>>, std::slice::Iter<'_, StaticPath>>, {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}>> as Iterator>::next(move _69) -> [return: bb35, unwind: bb240];
    }

    bb35: {
        _70 = discriminant(_68);
        switchInt(move _70) -> [0: bb40, 1: bb36, otherwise: bb5];
    }

    bb36: {
        _71 = ((_68 as Some).0: exports::StaticPath);
        _67 = RepInterp::<StaticPath>(_71);
        _73 = _61;
        _72 = Gt(move _73, const 0_usize);
        switchInt(move _72) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _75 = &mut _60;
        _74 = push_comma_spanned(_75, _23) -> [return: bb255, unwind: bb240];
    }

    bb38: {
        _76 = CheckedAdd(_61, const 1_usize);
        assert(!move (_76.1: bool), "attempt to compute `{} + {}`, which would overflow", _61, const 1_usize) -> [success: bb39, unwind: bb240];
    }

    bb39: {
        _61 = move (_76.0: usize);
        _78 = &_67;
        _79 = &mut _60;
        _77 = <RepInterp<StaticPath> as ToTokens>::to_tokens(_78, _79) -> [return: bb256, unwind: bb240];
    }

    bb40: {
        drop(_62) -> [return: bb41, unwind: bb241];
    }

    bb41: {
        _59 = move _60;
        _56 = push_group_spanned(_57, _23, move _58, move _59) -> [return: bb42, unwind: bb242];
    }

    bb42: {
        _81 = &_36;
        _82 = &mut _44;
        _80 = <Option<TokenStream2> as ToTokens>::to_tokens(_81, _82) -> [return: bb43, unwind: bb242];
    }

    bb43: {
        _84 = &mut _44;
        _83 = push_semi_spanned(_84, _23) -> [return: bb44, unwind: bb242];
    }

    bb44: {
        _509 = const _;
        _86 = &mut _44;
        _85 = <StaticPath as ToTokens>::to_tokens(_509, _86) -> [return: bb45, unwind: bb242];
    }

    bb45: {
        _88 = &mut _44;
        _87 = push_colon2_spanned(_88, _23) -> [return: bb46, unwind: bb242];
    }

    bb46: {
        _90 = &mut _44;
        _91 = const "Responder";
        _89 = push_ident_spanned(_90, _23, _91) -> [return: bb47, unwind: bb242];
    }

    bb47: {
        _93 = &mut _44;
        _92 = push_colon2_spanned(_93, _23) -> [return: bb48, unwind: bb242];
    }

    bb48: {
        _95 = &mut _44;
        _96 = const "respond_to";
        _94 = push_ident_spanned(_95, _23, _96) -> [return: bb49, unwind: bb242];
    }

    bb49: {
        _98 = &mut _44;
        _99 = proc_macro2::Delimiter::Parenthesis;
        _101 = TokenStream2::new() -> [return: bb50, unwind: bb242];
    }

    bb50: {
        _103 = &mut _101;
        _104 = const "___responder";
        _102 = push_ident_spanned(_103, _23, _104) -> [return: bb51, unwind: bb239];
    }

    bb51: {
        _106 = &mut _101;
        _105 = push_comma_spanned(_106, _23) -> [return: bb52, unwind: bb239];
    }

    bb52: {
        _508 = const _;
        _108 = &mut _101;
        _107 = <StaticPath as ToTokens>::to_tokens(_508, _108) -> [return: bb53, unwind: bb239];
    }

    bb53: {
        _100 = move _101;
        _97 = push_group_spanned(_98, _23, move _99, move _100) -> [return: bb54, unwind: bb242];
    }

    bb54: {
        _110 = &mut _44;
        _109 = push_question_spanned(_110, _23) -> [return: bb55, unwind: bb242];
    }

    bb55: {
        _43 = move _44;
        _40 = push_group_spanned(_41, _23, move _42, move _43) -> [return: bb56, unwind: bb243];
    }

    bb56: {
        _38 = move _39;
        _112 = TokenStream2::new() -> [return: bb57, unwind: bb238];
    }

    bb57: {
        _114 = &_11;
        _115 = &mut _112;
        _113 = <&ItemFn as ToTokens>::to_tokens(_114, _115) -> [return: bb58, unwind: bb237];
    }

    bb58: {
        _117 = &mut _112;
        _116 = push_pound(_117) -> [return: bb59, unwind: bb237];
    }

    bb59: {
        _119 = &mut _112;
        _120 = proc_macro2::Delimiter::Bracket;
        _122 = TokenStream2::new() -> [return: bb60, unwind: bb237];
    }

    bb60: {
        _124 = &mut _122;
        _125 = const "doc";
        _123 = push_ident(_124, _125) -> [return: bb61, unwind: bb236];
    }

    bb61: {
        _127 = &mut _122;
        _128 = proc_macro2::Delimiter::Parenthesis;
        _130 = TokenStream2::new() -> [return: bb62, unwind: bb236];
    }

    bb62: {
        _132 = &mut _130;
        _133 = const "hidden";
        _131 = push_ident(_132, _133) -> [return: bb63, unwind: bb235];
    }

    bb63: {
        _129 = move _130;
        _126 = push_group(_127, move _128, move _129) -> [return: bb64, unwind: bb236];
    }

    bb64: {
        _121 = move _122;
        _118 = push_group(_119, move _120, move _121) -> [return: bb65, unwind: bb237];
    }

    bb65: {
        _135 = &mut _112;
        _134 = push_pound(_135) -> [return: bb66, unwind: bb237];
    }

    bb66: {
        _137 = &mut _112;
        _138 = proc_macro2::Delimiter::Bracket;
        _140 = TokenStream2::new() -> [return: bb67, unwind: bb237];
    }

    bb67: {
        _142 = &mut _140;
        _143 = const "allow";
        _141 = push_ident(_142, _143) -> [return: bb68, unwind: bb234];
    }

    bb68: {
        _145 = &mut _140;
        _146 = proc_macro2::Delimiter::Parenthesis;
        _148 = TokenStream2::new() -> [return: bb69, unwind: bb234];
    }

    bb69: {
        _150 = &mut _148;
        _151 = const "non_camel_case_types";
        _149 = push_ident(_150, _151) -> [return: bb70, unwind: bb233];
    }

    bb70: {
        _147 = move _148;
        _144 = push_group(_145, move _146, move _147) -> [return: bb71, unwind: bb234];
    }

    bb71: {
        _139 = move _140;
        _136 = push_group(_137, move _138, move _139) -> [return: bb72, unwind: bb237];
    }

    bb72: {
        _153 = &mut _112;
        _152 = push_pound(_153) -> [return: bb73, unwind: bb237];
    }

    bb73: {
        _155 = &mut _112;
        _156 = proc_macro2::Delimiter::Bracket;
        _158 = TokenStream2::new() -> [return: bb74, unwind: bb237];
    }

    bb74: {
        _160 = &mut _158;
        _161 = const "doc";
        _159 = push_ident(_160, _161) -> [return: bb75, unwind: bb232];
    }

    bb75: {
        _163 = &mut _158;
        _162 = push_eq(_163) -> [return: bb76, unwind: bb232];
    }

    bb76: {
        _165 = &mut _158;
        _166 = const "r\" Rocket code generated proxy structure.\"";
        _164 = quote::__private::parse(_165, _166) -> [return: bb77, unwind: bb232];
    }

    bb77: {
        _157 = move _158;
        _154 = push_group(_155, move _156, move _157) -> [return: bb78, unwind: bb237];
    }

    bb78: {
        _168 = &_13;
        _169 = &mut _112;
        _167 = <&Visibility as ToTokens>::to_tokens(_168, _169) -> [return: bb79, unwind: bb237];
    }

    bb79: {
        _171 = &mut _112;
        _172 = const "struct";
        _170 = push_ident(_171, _172) -> [return: bb80, unwind: bb237];
    }

    bb80: {
        _174 = &_12;
        _175 = &mut _112;
        _173 = <&proc_macro2::Ident as ToTokens>::to_tokens(_174, _175) -> [return: bb81, unwind: bb237];
    }

    bb81: {
        _177 = &mut _112;
        _178 = proc_macro2::Delimiter::Brace;
        _179 = TokenStream2::new() -> [return: bb82, unwind: bb237];
    }

    bb82: {
        _176 = push_group(_177, move _178, move _179) -> [return: bb83, unwind: bb237];
    }

    bb83: {
        _181 = &mut _112;
        _180 = push_pound(_181) -> [return: bb84, unwind: bb237];
    }

    bb84: {
        _183 = &mut _112;
        _184 = proc_macro2::Delimiter::Bracket;
        _186 = TokenStream2::new() -> [return: bb85, unwind: bb237];
    }

    bb85: {
        _188 = &mut _186;
        _189 = const "doc";
        _187 = push_ident(_188, _189) -> [return: bb86, unwind: bb231];
    }

    bb86: {
        _191 = &mut _186;
        _190 = push_eq(_191) -> [return: bb87, unwind: bb231];
    }

    bb87: {
        _193 = &mut _186;
        _194 = const "r\" Rocket code generated proxy static conversion implementations.\"";
        _192 = quote::__private::parse(_193, _194) -> [return: bb88, unwind: bb231];
    }

    bb88: {
        _185 = move _186;
        _182 = push_group(_183, move _184, move _185) -> [return: bb89, unwind: bb237];
    }

    bb89: {
        _196 = &mut _112;
        _197 = const "impl";
        _195 = push_ident(_196, _197) -> [return: bb90, unwind: bb237];
    }

    bb90: {
        _199 = &_12;
        _200 = &mut _112;
        _198 = <&proc_macro2::Ident as ToTokens>::to_tokens(_199, _200) -> [return: bb91, unwind: bb237];
    }

    bb91: {
        _202 = &mut _112;
        _203 = proc_macro2::Delimiter::Brace;
        _205 = TokenStream2::new() -> [return: bb92, unwind: bb237];
    }

    bb92: {
        _207 = &mut _205;
        _208 = const "fn";
        _206 = push_ident(_207, _208) -> [return: bb93, unwind: bb230];
    }

    bb93: {
        _210 = &mut _205;
        _211 = const "into_info";
        _209 = push_ident(_210, _211) -> [return: bb94, unwind: bb230];
    }

    bb94: {
        _213 = &mut _205;
        _214 = proc_macro2::Delimiter::Parenthesis;
        _216 = TokenStream2::new() -> [return: bb95, unwind: bb230];
    }

    bb95: {
        _218 = &mut _216;
        _219 = const "self";
        _217 = push_ident(_218, _219) -> [return: bb96, unwind: bb229];
    }

    bb96: {
        _215 = move _216;
        _212 = push_group(_213, move _214, move _215) -> [return: bb97, unwind: bb230];
    }

    bb97: {
        _221 = &mut _205;
        _220 = push_rarrow(_221) -> [return: bb98, unwind: bb230];
    }

    bb98: {
        _507 = const _;
        _223 = &mut _205;
        _222 = <StaticPath as ToTokens>::to_tokens(_507, _223) -> [return: bb99, unwind: bb230];
    }

    bb99: {
        _225 = &mut _205;
        _224 = push_colon2(_225) -> [return: bb100, unwind: bb230];
    }

    bb100: {
        _227 = &mut _205;
        _228 = const "StaticInfo";
        _226 = push_ident(_227, _228) -> [return: bb101, unwind: bb230];
    }

    bb101: {
        _230 = &mut _205;
        _231 = proc_macro2::Delimiter::Brace;
        _233 = TokenStream2::new() -> [return: bb102, unwind: bb230];
    }

    bb102: {
        _235 = &mut _233;
        _236 = const "fn";
        _234 = push_ident(_235, _236) -> [return: bb103, unwind: bb228];
    }

    bb103: {
        _238 = &mut _233;
        _239 = const "monomorphized_function";
        _237 = push_ident(_238, _239) -> [return: bb104, unwind: bb228];
    }

    bb104: {
        _241 = &mut _233;
        _240 = push_lt(_241) -> [return: bb105, unwind: bb228];
    }

    bb105: {
        _243 = &mut _233;
        _244 = const "'__r";
        _242 = push_lifetime(_243, _244) -> [return: bb106, unwind: bb228];
    }

    bb106: {
        _246 = &mut _233;
        _245 = push_gt(_246) -> [return: bb107, unwind: bb228];
    }

    bb107: {
        _248 = &mut _233;
        _249 = proc_macro2::Delimiter::Parenthesis;
        _251 = TokenStream2::new() -> [return: bb108, unwind: bb228];
    }

    bb108: {
        _506 = const _;
        _253 = &mut _251;
        _252 = <StaticPath as ToTokens>::to_tokens(_506, _253) -> [return: bb109, unwind: bb227];
    }

    bb109: {
        _255 = &mut _251;
        _254 = push_colon(_255) -> [return: bb110, unwind: bb227];
    }

    bb110: {
        _505 = const _;
        _257 = &mut _251;
        _256 = <StaticPath as ToTokens>::to_tokens(_505, _257) -> [return: bb111, unwind: bb227];
    }

    bb111: {
        _259 = &mut _251;
        _258 = push_comma(_259) -> [return: bb112, unwind: bb227];
    }

    bb112: {
        _504 = const _;
        _261 = &mut _251;
        _260 = <StaticPath as ToTokens>::to_tokens(_504, _261) -> [return: bb113, unwind: bb227];
    }

    bb113: {
        _263 = &mut _251;
        _262 = push_colon(_263) -> [return: bb114, unwind: bb227];
    }

    bb114: {
        _265 = &mut _251;
        _264 = push_and(_265) -> [return: bb115, unwind: bb227];
    }

    bb115: {
        _267 = &mut _251;
        _268 = const "'__r";
        _266 = push_lifetime(_267, _268) -> [return: bb116, unwind: bb227];
    }

    bb116: {
        _503 = const _;
        _270 = &mut _251;
        _269 = <StaticPath as ToTokens>::to_tokens(_503, _270) -> [return: bb117, unwind: bb227];
    }

    bb117: {
        _272 = &mut _251;
        _271 = push_lt(_272) -> [return: bb118, unwind: bb227];
    }

    bb118: {
        _274 = &mut _251;
        _275 = const "'_";
        _273 = push_lifetime(_274, _275) -> [return: bb119, unwind: bb227];
    }

    bb119: {
        _277 = &mut _251;
        _276 = push_gt(_277) -> [return: bb120, unwind: bb227];
    }

    bb120: {
        _250 = move _251;
        _247 = push_group(_248, move _249, move _250) -> [return: bb121, unwind: bb228];
    }

    bb121: {
        _279 = &mut _233;
        _278 = push_rarrow(_279) -> [return: bb122, unwind: bb228];
    }

    bb122: {
        _502 = const _;
        _281 = &mut _233;
        _280 = <StaticPath as ToTokens>::to_tokens(_502, _281) -> [return: bb123, unwind: bb228];
    }

    bb123: {
        _283 = &mut _233;
        _282 = push_colon2(_283) -> [return: bb124, unwind: bb228];
    }

    bb124: {
        _285 = &mut _233;
        _286 = const "BoxFuture";
        _284 = push_ident(_285, _286) -> [return: bb125, unwind: bb228];
    }

    bb125: {
        _288 = &mut _233;
        _287 = push_lt(_288) -> [return: bb126, unwind: bb228];
    }

    bb126: {
        _290 = &mut _233;
        _291 = const "'__r";
        _289 = push_lifetime(_290, _291) -> [return: bb127, unwind: bb228];
    }

    bb127: {
        _293 = &mut _233;
        _292 = push_gt(_293) -> [return: bb128, unwind: bb228];
    }

    bb128: {
        _295 = &mut _233;
        _296 = proc_macro2::Delimiter::Brace;
        _298 = TokenStream2::new() -> [return: bb129, unwind: bb228];
    }

    bb129: {
        _501 = const _;
        _300 = &mut _298;
        _299 = <StaticPath as ToTokens>::to_tokens(_501, _300) -> [return: bb130, unwind: bb226];
    }

    bb130: {
        _302 = &mut _298;
        _301 = push_colon2(_302) -> [return: bb131, unwind: bb226];
    }

    bb131: {
        _304 = &mut _298;
        _305 = const "pin";
        _303 = push_ident(_304, _305) -> [return: bb132, unwind: bb226];
    }

    bb132: {
        _307 = &mut _298;
        _308 = proc_macro2::Delimiter::Parenthesis;
        _310 = TokenStream2::new() -> [return: bb133, unwind: bb226];
    }

    bb133: {
        _312 = &mut _310;
        _313 = const "async";
        _311 = push_ident(_312, _313) -> [return: bb134, unwind: bb225];
    }

    bb134: {
        _315 = &mut _310;
        _316 = const "move";
        _314 = push_ident(_315, _316) -> [return: bb135, unwind: bb225];
    }

    bb135: {
        _318 = &mut _310;
        _319 = proc_macro2::Delimiter::Brace;
        _321 = TokenStream2::new() -> [return: bb136, unwind: bb225];
    }

    bb136: {
        _323 = &mut _321;
        _324 = const "let";
        _322 = push_ident(_323, _324) -> [return: bb137, unwind: bb224];
    }

    bb137: {
        _326 = &mut _321;
        _327 = const "__response";
        _325 = push_ident(_326, _327) -> [return: bb138, unwind: bb224];
    }

    bb138: {
        _329 = &mut _321;
        _328 = push_eq(_329) -> [return: bb139, unwind: bb224];
    }

    bb139: {
        _331 = &_38;
        _332 = &mut _321;
        _330 = <TokenStream2 as ToTokens>::to_tokens(_331, _332) -> [return: bb140, unwind: bb224];
    }

    bb140: {
        _334 = &mut _321;
        _333 = push_semi(_334) -> [return: bb141, unwind: bb224];
    }

    bb141: {
        _500 = const _;
        _336 = &mut _321;
        _335 = <StaticPath as ToTokens>::to_tokens(_500, _336) -> [return: bb142, unwind: bb224];
    }

    bb142: {
        _338 = &mut _321;
        _337 = push_colon2(_338) -> [return: bb143, unwind: bb224];
    }

    bb143: {
        _340 = &mut _321;
        _341 = const "build";
        _339 = push_ident(_340, _341) -> [return: bb144, unwind: bb224];
    }

    bb144: {
        _343 = &mut _321;
        _344 = proc_macro2::Delimiter::Parenthesis;
        _345 = TokenStream2::new() -> [return: bb145, unwind: bb224];
    }

    bb145: {
        _342 = push_group(_343, move _344, move _345) -> [return: bb146, unwind: bb224];
    }

    bb146: {
        _347 = &mut _321;
        _346 = push_dot(_347) -> [return: bb147, unwind: bb224];
    }

    bb147: {
        _349 = &mut _321;
        _350 = const "status";
        _348 = push_ident(_349, _350) -> [return: bb148, unwind: bb224];
    }

    bb148: {
        _352 = &mut _321;
        _353 = proc_macro2::Delimiter::Parenthesis;
        _355 = TokenStream2::new() -> [return: bb149, unwind: bb224];
    }

    bb149: {
        _499 = const _;
        _357 = &mut _355;
        _356 = <StaticPath as ToTokens>::to_tokens(_499, _357) -> [return: bb150, unwind: bb223];
    }

    bb150: {
        _354 = move _355;
        _351 = push_group(_352, move _353, move _354) -> [return: bb151, unwind: bb224];
    }

    bb151: {
        _359 = &mut _321;
        _358 = push_dot(_359) -> [return: bb152, unwind: bb224];
    }

    bb152: {
        _361 = &mut _321;
        _362 = const "merge";
        _360 = push_ident(_361, _362) -> [return: bb153, unwind: bb224];
    }

    bb153: {
        _364 = &mut _321;
        _365 = proc_macro2::Delimiter::Parenthesis;
        _367 = TokenStream2::new() -> [return: bb154, unwind: bb224];
    }

    bb154: {
        _369 = &mut _367;
        _370 = const "__response";
        _368 = push_ident(_369, _370) -> [return: bb155, unwind: bb222];
    }

    bb155: {
        _366 = move _367;
        _363 = push_group(_364, move _365, move _366) -> [return: bb156, unwind: bb224];
    }

    bb156: {
        _372 = &mut _321;
        _371 = push_dot(_372) -> [return: bb157, unwind: bb224];
    }

    bb157: {
        _374 = &mut _321;
        _375 = const "ok";
        _373 = push_ident(_374, _375) -> [return: bb158, unwind: bb224];
    }

    bb158: {
        _377 = &mut _321;
        _378 = proc_macro2::Delimiter::Parenthesis;
        _379 = TokenStream2::new() -> [return: bb159, unwind: bb224];
    }

    bb159: {
        _376 = push_group(_377, move _378, move _379) -> [return: bb160, unwind: bb224];
    }

    bb160: {
        _320 = move _321;
        _317 = push_group(_318, move _319, move _320) -> [return: bb161, unwind: bb225];
    }

    bb161: {
        _309 = move _310;
        _306 = push_group(_307, move _308, move _309) -> [return: bb162, unwind: bb226];
    }

    bb162: {
        _297 = move _298;
        _294 = push_group(_295, move _296, move _297) -> [return: bb163, unwind: bb228];
    }

    bb163: {
        _498 = const _;
        _381 = &mut _233;
        _380 = <StaticPath as ToTokens>::to_tokens(_498, _381) -> [return: bb164, unwind: bb228];
    }

    bb164: {
        _383 = &mut _233;
        _382 = push_colon2(_383) -> [return: bb165, unwind: bb228];
    }

    bb165: {
        _385 = &mut _233;
        _386 = const "StaticInfo";
        _384 = push_ident(_385, _386) -> [return: bb166, unwind: bb228];
    }

    bb166: {
        _388 = &mut _233;
        _389 = proc_macro2::Delimiter::Brace;
        _391 = TokenStream2::new() -> [return: bb167, unwind: bb228];
    }

    bb167: {
        _393 = &mut _391;
        _394 = const "name";
        _392 = push_ident(_393, _394) -> [return: bb168, unwind: bb221];
    }

    bb168: {
        _396 = &mut _391;
        _395 = push_colon(_396) -> [return: bb169, unwind: bb221];
    }

    bb169: {
        _398 = &mut _391;
        _399 = const "stringify";
        _397 = push_ident(_398, _399) -> [return: bb170, unwind: bb221];
    }

    bb170: {
        _401 = &mut _391;
        _400 = push_bang(_401) -> [return: bb171, unwind: bb221];
    }

    bb171: {
        _403 = &mut _391;
        _404 = proc_macro2::Delimiter::Parenthesis;
        _406 = TokenStream2::new() -> [return: bb172, unwind: bb221];
    }

    bb172: {
        _408 = &_12;
        _409 = &mut _406;
        _407 = <&proc_macro2::Ident as ToTokens>::to_tokens(_408, _409) -> [return: bb173, unwind: bb220];
    }

    bb173: {
        _405 = move _406;
        _402 = push_group(_403, move _404, move _405) -> [return: bb174, unwind: bb221];
    }

    bb174: {
        _411 = &mut _391;
        _410 = push_comma(_411) -> [return: bb175, unwind: bb221];
    }

    bb175: {
        _413 = &mut _391;
        _414 = const "code";
        _412 = push_ident(_413, _414) -> [return: bb176, unwind: bb221];
    }

    bb176: {
        _416 = &mut _391;
        _415 = push_colon(_416) -> [return: bb177, unwind: bb221];
    }

    bb177: {
        _418 = &_14;
        _419 = &mut _391;
        _417 = <Optional<u16> as ToTokens>::to_tokens(_418, _419) -> [return: bb178, unwind: bb221];
    }

    bb178: {
        _421 = &mut _391;
        _420 = push_comma(_421) -> [return: bb179, unwind: bb221];
    }

    bb179: {
        _423 = &mut _391;
        _424 = const "handler";
        _422 = push_ident(_423, _424) -> [return: bb180, unwind: bb221];
    }

    bb180: {
        _426 = &mut _391;
        _425 = push_colon(_426) -> [return: bb181, unwind: bb221];
    }

    bb181: {
        _428 = &mut _391;
        _429 = const "monomorphized_function";
        _427 = push_ident(_428, _429) -> [return: bb182, unwind: bb221];
    }

    bb182: {
        _431 = &mut _391;
        _430 = push_comma(_431) -> [return: bb183, unwind: bb221];
    }

    bb183: {
        _390 = move _391;
        _387 = push_group(_388, move _389, move _390) -> [return: bb184, unwind: bb228];
    }

    bb184: {
        _232 = move _233;
        _229 = push_group(_230, move _231, move _232) -> [return: bb185, unwind: bb230];
    }

    bb185: {
        _433 = &mut _205;
        _432 = push_pound(_433) -> [return: bb186, unwind: bb230];
    }

    bb186: {
        _435 = &mut _205;
        _436 = proc_macro2::Delimiter::Bracket;
        _438 = TokenStream2::new() -> [return: bb187, unwind: bb230];
    }

    bb187: {
        _440 = &mut _438;
        _441 = const "doc";
        _439 = push_ident(_440, _441) -> [return: bb188, unwind: bb219];
    }

    bb188: {
        _443 = &mut _438;
        _444 = proc_macro2::Delimiter::Parenthesis;
        _446 = TokenStream2::new() -> [return: bb189, unwind: bb219];
    }

    bb189: {
        _448 = &mut _446;
        _449 = const "hidden";
        _447 = push_ident(_448, _449) -> [return: bb190, unwind: bb218];
    }

    bb190: {
        _445 = move _446;
        _442 = push_group(_443, move _444, move _445) -> [return: bb191, unwind: bb219];
    }

    bb191: {
        _437 = move _438;
        _434 = push_group(_435, move _436, move _437) -> [return: bb192, unwind: bb230];
    }

    bb192: {
        _451 = &mut _205;
        _452 = const "pub";
        _450 = push_ident(_451, _452) -> [return: bb193, unwind: bb230];
    }

    bb193: {
        _454 = &mut _205;
        _455 = const "fn";
        _453 = push_ident(_454, _455) -> [return: bb194, unwind: bb230];
    }

    bb194: {
        _457 = &mut _205;
        _458 = const "into_catcher";
        _456 = push_ident(_457, _458) -> [return: bb195, unwind: bb230];
    }

    bb195: {
        _460 = &mut _205;
        _461 = proc_macro2::Delimiter::Parenthesis;
        _463 = TokenStream2::new() -> [return: bb196, unwind: bb230];
    }

    bb196: {
        _465 = &mut _463;
        _466 = const "self";
        _464 = push_ident(_465, _466) -> [return: bb197, unwind: bb217];
    }

    bb197: {
        _462 = move _463;
        _459 = push_group(_460, move _461, move _462) -> [return: bb198, unwind: bb230];
    }

    bb198: {
        _468 = &mut _205;
        _467 = push_rarrow(_468) -> [return: bb199, unwind: bb230];
    }

    bb199: {
        _497 = const _;
        _470 = &mut _205;
        _469 = <StaticPath as ToTokens>::to_tokens(_497, _470) -> [return: bb200, unwind: bb230];
    }

    bb200: {
        _472 = &mut _205;
        _473 = proc_macro2::Delimiter::Brace;
        _475 = TokenStream2::new() -> [return: bb201, unwind: bb230];
    }

    bb201: {
        _477 = &mut _475;
        _478 = const "self";
        _476 = push_ident(_477, _478) -> [return: bb202, unwind: bb216];
    }

    bb202: {
        _480 = &mut _475;
        _479 = push_dot(_480) -> [return: bb203, unwind: bb216];
    }

    bb203: {
        _482 = &mut _475;
        _483 = const "into_info";
        _481 = push_ident(_482, _483) -> [return: bb204, unwind: bb216];
    }

    bb204: {
        _485 = &mut _475;
        _486 = proc_macro2::Delimiter::Parenthesis;
        _487 = TokenStream2::new() -> [return: bb205, unwind: bb216];
    }

    bb205: {
        _484 = push_group(_485, move _486, move _487) -> [return: bb206, unwind: bb216];
    }

    bb206: {
        _489 = &mut _475;
        _488 = push_dot(_489) -> [return: bb207, unwind: bb216];
    }

    bb207: {
        _491 = &mut _475;
        _492 = const "into";
        _490 = push_ident(_491, _492) -> [return: bb208, unwind: bb216];
    }

    bb208: {
        _494 = &mut _475;
        _495 = proc_macro2::Delimiter::Parenthesis;
        _496 = TokenStream2::new() -> [return: bb209, unwind: bb216];
    }

    bb209: {
        _493 = push_group(_494, move _495, move _496) -> [return: bb210, unwind: bb216];
    }

    bb210: {
        _474 = move _475;
        _471 = push_group(_472, move _473, move _474) -> [return: bb211, unwind: bb230];
    }

    bb211: {
        _204 = move _205;
        _201 = push_group(_202, move _203, move _204) -> [return: bb212, unwind: bb237];
    }

    bb212: {
        _111 = move _112;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _111);
        drop(_38) -> [return: bb213, unwind: bb244];
    }

    bb213: {
        drop(_36) -> [return: bb214, unwind: bb248];
    }

    bb214: {
        _511 = const false;
        drop(_3) -> [return: bb215, unwind: bb252];
    }

    bb215: {
        return;
    }

    bb216 (cleanup): {
        drop(_475) -> [return: bb230, unwind terminate(cleanup)];
    }

    bb217 (cleanup): {
        drop(_463) -> [return: bb230, unwind terminate(cleanup)];
    }

    bb218 (cleanup): {
        drop(_446) -> [return: bb219, unwind terminate(cleanup)];
    }

    bb219 (cleanup): {
        drop(_438) -> [return: bb230, unwind terminate(cleanup)];
    }

    bb220 (cleanup): {
        drop(_406) -> [return: bb221, unwind terminate(cleanup)];
    }

    bb221 (cleanup): {
        drop(_391) -> [return: bb228, unwind terminate(cleanup)];
    }

    bb222 (cleanup): {
        drop(_367) -> [return: bb224, unwind terminate(cleanup)];
    }

    bb223 (cleanup): {
        drop(_355) -> [return: bb224, unwind terminate(cleanup)];
    }

    bb224 (cleanup): {
        drop(_321) -> [return: bb225, unwind terminate(cleanup)];
    }

    bb225 (cleanup): {
        drop(_310) -> [return: bb226, unwind terminate(cleanup)];
    }

    bb226 (cleanup): {
        drop(_298) -> [return: bb228, unwind terminate(cleanup)];
    }

    bb227 (cleanup): {
        drop(_251) -> [return: bb228, unwind terminate(cleanup)];
    }

    bb228 (cleanup): {
        drop(_233) -> [return: bb230, unwind terminate(cleanup)];
    }

    bb229 (cleanup): {
        drop(_216) -> [return: bb230, unwind terminate(cleanup)];
    }

    bb230 (cleanup): {
        drop(_205) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb231 (cleanup): {
        drop(_186) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb232 (cleanup): {
        drop(_158) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb233 (cleanup): {
        drop(_148) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb234 (cleanup): {
        drop(_140) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb235 (cleanup): {
        drop(_130) -> [return: bb236, unwind terminate(cleanup)];
    }

    bb236 (cleanup): {
        drop(_122) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb237 (cleanup): {
        drop(_112) -> [return: bb238, unwind terminate(cleanup)];
    }

    bb238 (cleanup): {
        drop(_38) -> [return: bb244, unwind terminate(cleanup)];
    }

    bb239 (cleanup): {
        drop(_101) -> [return: bb242, unwind terminate(cleanup)];
    }

    bb240 (cleanup): {
        drop(_62) -> [return: bb241, unwind terminate(cleanup)];
    }

    bb241 (cleanup): {
        drop(_60) -> [return: bb242, unwind terminate(cleanup)];
    }

    bb242 (cleanup): {
        drop(_44) -> [return: bb243, unwind terminate(cleanup)];
    }

    bb243 (cleanup): {
        drop(_39) -> [return: bb244, unwind terminate(cleanup)];
    }

    bb244 (cleanup): {
        drop(_36) -> [return: bb248, unwind terminate(cleanup)];
    }

    bb245 (cleanup): {
        drop(_3) -> [return: bb252, unwind terminate(cleanup)];
    }

    bb246 (cleanup): {
        resume;
    }

    bb247 (cleanup): {
        drop(_29) -> [return: bb245, unwind terminate(cleanup)];
    }

    bb248 (cleanup): {
        switchInt(_511) -> [0: bb245, otherwise: bb247];
    }

    bb249 (cleanup): {
        drop(_32) -> [return: bb245, unwind terminate(cleanup)];
    }

    bb250 (cleanup): {
        switchInt(_512) -> [0: bb245, otherwise: bb249];
    }

    bb251 (cleanup): {
        drop(_2) -> [return: bb246, unwind terminate(cleanup)];
    }

    bb252 (cleanup): {
        switchInt(_513) -> [0: bb246, otherwise: bb251];
    }

    bb253: {
        goto -> bb215;
    }

    bb254: {
        goto -> bb33;
    }

    bb255: {
        goto -> bb38;
    }

    bb256: {
        goto -> bb33;
    }
}

promoted[0] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[9] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[10] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[11] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[12] in _catch: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[13] in _catch: &[StaticPath; 2] = {
    let mut _0: &[exports::StaticPath; 2];
    let mut _1: [exports::StaticPath; 2];

    bb0: {
        _1 = [const _, const _];
        _0 = &_1;
        return;
    }
}

fn _catch::{closure#0}(_1: {closure@core/codegen/src/attribute/catch/mod.rs:22:49: 22:52}, _2: rocket_http::Status) -> u16 {
    debug s => _2;
    let mut _0: u16;

    bb0: {
        _0 = (_2.0: u16);
        return;
    }
}

fn _catch::{closure#1}(_1: {closure@core/codegen/src/attribute/catch/mod.rs:33:14: 33:18}, _2: &syn::Type) -> proc_macro2::Span {
    debug ty => _2;
    let mut _0: proc_macro2::Span;
    let mut _3: proc_macro2::Span;

    bb0: {
        _3 = <syn::Type as devise::Spanned>::span(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn _catch::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/catch/mod.rs:41:14: 41:37}, _2: (&syn::FnArg, &StaticPath)) -> StaticPath {
    let mut _0: exports::StaticPath;
    let _3: &syn::FnArg;
    let _4: &exports::StaticPath;
    let mut _5: isize;
    let mut _6: exports::StaticPath;
    let mut _7: proc_macro2::Span;
    let mut _9: exports::StaticPath;
    let mut _10: proc_macro2::Span;
    let mut _11: &std::boxed::Box<syn::Type>;
    scope 1 {
        debug fn_arg => _3;
        debug codegen_arg => _4;
        let _8: &syn::PatType;
        scope 2 {
            debug a => _8;
        }
    }

    bb0: {
        _3 = (_2.0: &syn::FnArg);
        _4 = (_2.1: &exports::StaticPath);
        _5 = discriminant((*_3));
        switchInt(move _5) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_3) as Typed).0: syn::PatType);
        _9 = (*_4);
        _11 = &((*_8).3: std::boxed::Box<syn::Type>);
        _10 = <std::boxed::Box<syn::Type> as devise::Spanned>::span(move _11) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _6 = (*_4);
        _7 = <syn::FnArg as devise::Spanned>::span(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = StaticPath::respanned(move _6, move _7) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = StaticPath::respanned(move _9, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn _catch::{closure#3}(_1: {closure@core/codegen/src/attribute/catch/mod.rs:48:14: 48:17}, _2: syn::token::Async) -> TokenStream2 {
    debug a => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _5: proc_macro2::Span;
    let mut _6: &syn::token::Async;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    scope 1 {
        debug _s => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug _span => _4;
        }
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_2;
        _5 = <syn::token::Async as devise::Spanned>::span(move _6) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _8 = &mut _3;
        _7 = push_dot_spanned(_8, _4) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _10 = &mut _3;
        _11 = const "await";
        _9 = push_ident_spanned(_10, _4, _11) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = move _3;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn catch_attribute(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> TokenStream2 {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _3 = _catch(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/attribute/catch/mod.rs:99:40: 99:43}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/catch/mod.rs:99:40: 99:43}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn catch_attribute::{closure#0}(_1: {closure@core/codegen/src/attribute/catch/mod.rs:99:40: 99:43}, _2: devise::Diagnostic) -> TokenStream2 {
    debug d => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:15:10: 15:15>::fmt(_1: &route::parse::Route, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 7];
    let _5: [&dyn std::fmt::Debug; 7];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &attribute::route::parse::Attribute;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::vec::Vec<attribute::param::Parameter>;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &std::vec::Vec<attribute::param::Parameter>;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &std::option::Option<attribute::param::Guard>;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::vec::Vec<attribute::param::Guard>;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &syn::ItemFn;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&attribute::route::parse::Arguments;
    let _20: &attribute::route::parse::Arguments;
    let _21: &str;
    let mut _22: &[&str];
    let mut _23: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _23 = const _;
        _7 = &((*_1).0: attribute::route::parse::Attribute);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: std::vec::Vec<attribute::param::Parameter>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: std::option::Option<attribute::param::Guard>);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: std::vec::Vec<attribute::param::Guard>);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: syn::ItemFn);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _20 = &((*_1).6: attribute::route::parse::Arguments);
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _21 = const "Route";
        _22 = _23 as &[&str] (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_fields_finish(_2, _21, move _22, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:15:10: 15:15>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "path_params";
        _2 = &(*_3);
        _5 = const "query_params";
        _4 = &(*_5);
        _7 = const "data_guard";
        _6 = &(*_7);
        _9 = const "request_guards";
        _8 = &(*_9);
        _11 = const "handler";
        _10 = &(*_11);
        _13 = const "arguments";
        _12 = &(*_13);
        _1 = [const "attr", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:35:10: 35:15>::fmt(_1: &route::parse::Arguments, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &proc_macro2::Span;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let _10: &indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;

    bb0: {
        _3 = const "Arguments";
        _4 = const "span";
        _6 = &((*_1).0: proc_macro2::Span);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "map";
        _10 = &((*_1).1: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:42:10: 42:15>::fmt(_1: &route::parse::Attribute, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &devise::SpanWrapped<http_codegen::Method>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &attribute::route::parse::RouteUri;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::option::Option<http_codegen::MediaType>;
    let _16: &str;
    let mut _17: &dyn std::fmt::Debug;
    let _18: &&std::option::Option<isize>;
    let _19: &std::option::Option<isize>;

    bb0: {
        _3 = const "Attribute";
        _4 = const "method";
        _6 = &((*_1).0: devise::SpanWrapped<http_codegen::Method>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "uri";
        _9 = &((*_1).1: attribute::route::parse::RouteUri);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "data";
        _12 = &((*_1).2: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "format";
        _15 = &((*_1).3: std::option::Option<http_codegen::MediaType>);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _16 = const "rank";
        _19 = &((*_1).4: std::option::Option<isize>);
        _18 = &_19;
        _17 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field5_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14, _16, move _17) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const route::parse::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta(_1: &devise::MetaItem) -> std::result::Result<route::parse::Attribute, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<attribute::route::parse::Attribute, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _14: std::option::Option<&devise::MetaItem>;
    let mut _15: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _16: isize;
    let mut _19: bool;
    let mut _20: std::option::Option<devise::SpanWrapped<http_codegen::Method>>;
    let mut _21: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, devise::SpanWrapped<http_codegen::Method>>;
    let mut _22: std::result::Result<devise::SpanWrapped<http_codegen::Method>, devise::Diagnostic>;
    let mut _23: isize;
    let mut _27: devise::Diagnostic;
    let mut _28: proc_macro2::Span;
    let mut _29: devise::Diagnostic;
    let mut _30: proc_macro2::Span;
    let mut _32: std::fmt::Arguments<'_>;
    let mut _33: &[&str];
    let mut _34: &[core::fmt::rt::Argument<'_>];
    let _35: &[core::fmt::rt::Argument<'_>; 0];
    let _36: [core::fmt::rt::Argument<'_>; 0];
    let mut _37: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _38: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _40: std::option::Option<&devise::MetaItem>;
    let mut _41: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _42: isize;
    let mut _46: std::option::Option<&proc_macro2::Ident>;
    let mut _47: isize;
    let mut _49: devise::Diagnostic;
    let mut _50: bool;
    let mut _51: &&proc_macro2::Ident;
    let mut _52: bool;
    let mut _53: &std::option::Option<attribute::route::parse::RouteUri>;
    let mut _54: devise::Diagnostic;
    let mut _56: std::fmt::Arguments<'_>;
    let mut _57: &[&str];
    let mut _58: &[core::fmt::rt::Argument<'_>];
    let _59: &[core::fmt::rt::Argument<'_>; 0];
    let _60: [core::fmt::rt::Argument<'_>; 0];
    let mut _61: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _62: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::RouteUri>;
    let mut _63: std::result::Result<attribute::route::parse::RouteUri, devise::Diagnostic>;
    let mut _64: isize;
    let mut _67: bool;
    let mut _68: &&proc_macro2::Ident;
    let mut _69: bool;
    let mut _70: &std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _71: devise::Diagnostic;
    let mut _73: std::fmt::Arguments<'_>;
    let mut _74: &[&str];
    let mut _75: &[core::fmt::rt::Argument<'_>];
    let _76: &[core::fmt::rt::Argument<'_>; 0];
    let _77: [core::fmt::rt::Argument<'_>; 0];
    let mut _78: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _79: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _80: std::result::Result<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>, devise::Diagnostic>;
    let mut _81: isize;
    let mut _84: bool;
    let mut _85: &&proc_macro2::Ident;
    let mut _86: bool;
    let mut _87: &std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _88: devise::Diagnostic;
    let mut _90: std::fmt::Arguments<'_>;
    let mut _91: &[&str];
    let mut _92: &[core::fmt::rt::Argument<'_>];
    let _93: &[core::fmt::rt::Argument<'_>; 0];
    let _94: [core::fmt::rt::Argument<'_>; 0];
    let mut _95: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _96: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<http_codegen::MediaType>>;
    let mut _97: std::result::Result<std::option::Option<http_codegen::MediaType>, devise::Diagnostic>;
    let mut _98: isize;
    let mut _101: bool;
    let mut _102: &&proc_macro2::Ident;
    let mut _103: bool;
    let mut _104: &std::option::Option<std::option::Option<isize>>;
    let mut _105: devise::Diagnostic;
    let mut _107: std::fmt::Arguments<'_>;
    let mut _108: &[&str];
    let mut _109: &[core::fmt::rt::Argument<'_>];
    let _110: &[core::fmt::rt::Argument<'_>; 0];
    let _111: [core::fmt::rt::Argument<'_>; 0];
    let mut _112: std::option::Option<std::option::Option<isize>>;
    let mut _113: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<isize>>;
    let mut _114: std::result::Result<std::option::Option<isize>, devise::Diagnostic>;
    let mut _115: isize;
    let mut _119: std::fmt::Arguments<'_>;
    let mut _120: &[&str];
    let mut _121: &[core::fmt::rt::Argument<'_>];
    let _122: &[core::fmt::rt::Argument<'_>; 1];
    let _123: [core::fmt::rt::Argument<'_>; 1];
    let mut _124: core::fmt::rt::Argument<'_>;
    let _125: &&proc_macro2::Ident;
    let mut _126: devise::Diagnostic;
    let mut _127: attribute::route::parse::Attribute;
    let mut _128: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, devise::SpanWrapped<http_codegen::Method>>;
    let mut _129: std::result::Result<devise::SpanWrapped<http_codegen::Method>, devise::Diagnostic>;
    let mut _130: std::option::Option<devise::SpanWrapped<http_codegen::Method>>;
    let mut _131: std::option::Option<devise::SpanWrapped<http_codegen::Method>>;
    let mut _132: {closure@core/codegen/src/attribute/route/parse.rs:44:5: 44:6};
    let mut _133: &proc_macro2::Span;
    let mut _134: isize;
    let mut _137: attribute::route::parse::RouteUri;
    let mut _138: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::RouteUri>;
    let mut _139: std::result::Result<attribute::route::parse::RouteUri, devise::Diagnostic>;
    let mut _140: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _141: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _142: {closure@core/codegen/src/attribute/route/parse.rs:46:5: 46:8};
    let mut _143: &proc_macro2::Span;
    let mut _144: isize;
    let mut _147: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let mut _148: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _149: std::result::Result<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>, devise::Diagnostic>;
    let mut _150: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _151: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _152: {closure@core/codegen/src/attribute/route/parse.rs:47:5: 47:8};
    let mut _153: &proc_macro2::Span;
    let mut _154: isize;
    let mut _157: std::option::Option<http_codegen::MediaType>;
    let mut _158: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<http_codegen::MediaType>>;
    let mut _159: std::result::Result<std::option::Option<http_codegen::MediaType>, devise::Diagnostic>;
    let mut _160: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _161: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _162: {closure@core/codegen/src/attribute/route/parse.rs:48:5: 48:8};
    let mut _163: &proc_macro2::Span;
    let mut _164: isize;
    let mut _167: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<isize>>;
    let mut _168: std::result::Result<std::option::Option<isize>, devise::Diagnostic>;
    let mut _169: std::option::Option<std::option::Option<isize>>;
    let mut _170: std::option::Option<std::option::Option<isize>>;
    let mut _171: {closure@core/codegen/src/attribute/route/parse.rs:49:5: 49:8};
    let mut _172: &proc_macro2::Span;
    let mut _173: isize;
    let mut _186: &devise::MetaItem;
    let mut _187: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _188: bool;
    let mut _189: bool;
    let mut _190: bool;
    let mut _191: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug method => _9;
                scope 9 {
                    debug uri => _10;
                    scope 11 {
                        debug data => _11;
                        scope 13 {
                            debug format => _12;
                            scope 15 {
                                debug rank => _13;
                                let _17: &devise::MetaItem;
                                let _18: &&devise::MetaItem;
                                let _26: &devise::MetaItem;
                                let _31: std::string::String;
                                let mut _39: syn::punctuated::Iter<'_, devise::MetaItem>;
                                let _135: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _136: devise::SpanWrapped<http_codegen::Method>;
                                let _145: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _146: attribute::route::parse::RouteUri;
                                let _155: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _156: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
                                let _165: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _166: std::option::Option<http_codegen::MediaType>;
                                let _174: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _175: std::option::Option<isize>;
                                let mut _176: &[&str; 1];
                                scope 17 {
                                    debug __i => _17;
                                    debug __i => _18;
                                    let _24: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                    let _25: devise::SpanWrapped<http_codegen::Method>;
                                    scope 18 {
                                        debug residual => _24;
                                        scope 19 {
                                        }
                                    }
                                    scope 20 {
                                        debug val => _25;
                                        scope 21 {
                                        }
                                    }
                                }
                                scope 22 {
                                    debug __i => _26;
                                }
                                scope 23 {
                                    debug res => _31;
                                }
                                scope 24 {
                                    debug iter => _39;
                                    let _43: &devise::MetaItem;
                                    scope 25 {
                                        debug __meta => _43;
                                        let _44: proc_macro2::Span;
                                        scope 26 {
                                            debug __span => _44;
                                            let _45: &proc_macro2::Ident;
                                            let _48: &proc_macro2::Ident;
                                            scope 27 {
                                                debug __name => _45;
                                                let _55: std::string::String;
                                                let _65: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                                let _66: attribute::route::parse::RouteUri;
                                                let _72: std::string::String;
                                                let _82: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                                let _83: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
                                                let _89: std::string::String;
                                                let _99: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                                let _100: std::option::Option<http_codegen::MediaType>;
                                                let _106: std::string::String;
                                                let _116: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                                let _117: std::option::Option<isize>;
                                                let _118: std::string::String;
                                                let mut _177: &[&str; 1];
                                                let mut _178: &[&str; 1];
                                                let mut _179: &[&str; 1];
                                                let mut _180: &[&str; 1];
                                                let mut _181: &[&str; 2];
                                                let mut _182: &&str;
                                                let mut _183: &&str;
                                                let mut _184: &&str;
                                                let mut _185: &&str;
                                                scope 29 {
                                                    debug res => _55;
                                                }
                                                scope 30 {
                                                    debug residual => _65;
                                                    scope 31 {
                                                    }
                                                }
                                                scope 32 {
                                                    debug val => _66;
                                                    scope 33 {
                                                    }
                                                }
                                                scope 34 {
                                                    debug res => _72;
                                                }
                                                scope 35 {
                                                    debug residual => _82;
                                                    scope 36 {
                                                    }
                                                }
                                                scope 37 {
                                                    debug val => _83;
                                                    scope 38 {
                                                    }
                                                }
                                                scope 39 {
                                                    debug res => _89;
                                                }
                                                scope 40 {
                                                    debug residual => _99;
                                                    scope 41 {
                                                    }
                                                }
                                                scope 42 {
                                                    debug val => _100;
                                                    scope 43 {
                                                    }
                                                }
                                                scope 44 {
                                                    debug res => _106;
                                                }
                                                scope 45 {
                                                    debug residual => _116;
                                                    scope 46 {
                                                    }
                                                }
                                                scope 47 {
                                                    debug val => _117;
                                                    scope 48 {
                                                    }
                                                }
                                                scope 49 {
                                                    debug __msg => _118;
                                                }
                                                scope 50 {
                                                    debug res => _118;
                                                }
                                            }
                                            scope 28 {
                                                debug __ident => _48;
                                            }
                                        }
                                    }
                                }
                                scope 51 {
                                    debug residual => _135;
                                    scope 52 {
                                    }
                                }
                                scope 53 {
                                    debug val => _136;
                                    scope 54 {
                                    }
                                }
                                scope 55 {
                                    debug residual => _145;
                                    scope 56 {
                                    }
                                }
                                scope 57 {
                                    debug val => _146;
                                    scope 58 {
                                    }
                                }
                                scope 59 {
                                    debug residual => _155;
                                    scope 60 {
                                    }
                                }
                                scope 61 {
                                    debug val => _156;
                                    scope 62 {
                                    }
                                }
                                scope 63 {
                                    debug residual => _165;
                                    scope 64 {
                                    }
                                }
                                scope 65 {
                                    debug val => _166;
                                    scope 66 {
                                    }
                                }
                                scope 67 {
                                    debug residual => _174;
                                    scope 68 {
                                    }
                                }
                                scope 69 {
                                    debug val => _175;
                                    scope 70 {
                                    }
                                }
                            }
                            scope 16 {
                                let mut _13: std::option::Option<std::option::Option<isize>>;
                            }
                        }
                        scope 14 {
                            let mut _12: std::option::Option<std::option::Option<http_codegen::MediaType>>;
                        }
                    }
                    scope 12 {
                        let mut _11: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
                    }
                }
                scope 10 {
                    let mut _10: std::option::Option<attribute::route::parse::RouteUri>;
                }
            }
            scope 8 {
                let mut _9: std::option::Option<devise::SpanWrapped<http_codegen::Method>>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _188 = const false;
        _191 = const false;
        _190 = const false;
        _189 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _187 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_187 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _188 = const true;
        _3 = move _8;
        _9 = Option::<devise::SpanWrapped<http_codegen::Method>>::None;
        _191 = const true;
        _10 = Option::<RouteUri>::None;
        _190 = const true;
        _11 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::None;
        _189 = const true;
        _12 = Option::<Option<http_codegen::MediaType>>::None;
        _13 = Option::<Option<isize>>::None;
        _15 = &mut _3;
        _14 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(move _15) -> [return: bb7, unwind: bb162];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb147, unwind continue];
    }

    bb7: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [0: bb8, 1: bb9, otherwise: bb5];
    }

    bb8: {
        _30 = _2;
        _176 = const _;
        _33 = _176 as &[&str] (PointerCoercion(Unsize));
        _36 = core::fmt::rt::Argument::<'_>::none() -> [return: bb19, unwind: bb162];
    }

    bb9: {
        _18 = &((_14 as Some).0: &devise::MetaItem);
        _186 = deref_copy (*_18);
        _19 = devise::MetaItem::is_bare(_186) -> [return: bb10, unwind: bb162];
    }

    bb10: {
        switchInt(move _19) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _17 = ((_14 as Some).0: &devise::MetaItem);
        _22 = <devise::SpanWrapped<http_codegen::Method> as devise::FromMeta>::from_meta(_17) -> [return: bb13, unwind: bb162];
    }

    bb12: {
        _26 = ((_14 as Some).0: &devise::MetaItem);
        _28 = <devise::MetaItem as devise::Spanned>::span(_26) -> [return: bb17, unwind: bb162];
    }

    bb13: {
        _21 = <std::result::Result<devise::SpanWrapped<http_codegen::Method>, devise::Diagnostic> as std::ops::Try>::branch(move _22) -> [return: bb14, unwind: bb162];
    }

    bb14: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb15, 1: bb16, otherwise: bb5];
    }

    bb15: {
        _25 = ((_21 as Continue).0: devise::SpanWrapped<http_codegen::Method>);
        _20 = Option::<devise::SpanWrapped<http_codegen::Method>>::Some(_25);
        _9 = move _20;
        _188 = const false;
        _38 = move _3;
        _37 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _38) -> [return: bb23, unwind: bb162];
    }

    bb16: {
        _24 = move ((_21 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _24) -> [return: bb175, unwind: bb162];
    }

    bb17: {
        _27 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _28, const "unexpected keyed parameter: expected literal or identifier") -> [return: bb18, unwind: bb162];
    }

    bb18: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _27);
        goto -> bb143;
    }

    bb19: {
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _32 = std::fmt::Arguments::<'_>::new_v1(move _33, move _34) -> [return: bb20, unwind: bb162];
    }

    bb20: {
        _31 = format(move _32) -> [return: bb21, unwind: bb162];
    }

    bb21: {
        _29 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _30, move _31) -> [return: bb22, unwind: bb162];
    }

    bb22: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _29);
        goto -> bb143;
    }

    bb23: {
        _39 = move _37;
        goto -> bb24;
    }

    bb24: {
        _41 = &mut _39;
        _40 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_41) -> [return: bb25, unwind: bb161];
    }

    bb25: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb27, 1: bb26, otherwise: bb5];
    }

    bb26: {
        _43 = ((_40 as Some).0: &devise::MetaItem);
        _44 = <devise::MetaItem as devise::Spanned>::span(_43) -> [return: bb28, unwind: bb161];
    }

    bb27: {
        drop(_39) -> [return: bb99, unwind: bb162];
    }

    bb28: {
        _46 = devise::MetaItem::name(_43) -> [return: bb29, unwind: bb161];
    }

    bb29: {
        _47 = discriminant(_46);
        switchInt(move _47) -> [0: bb30, 1: bb31, otherwise: bb5];
    }

    bb30: {
        _49 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_44, const "expected key/value `key = value`") -> [return: bb32, unwind: bb161];
    }

    bb31: {
        _48 = ((_46 as Some).0: &proc_macro2::Ident);
        _45 = _48;
        _51 = &_45;
        _185 = const _;
        _50 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _51, _185) -> [return: bb33, unwind: bb161];
    }

    bb32: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _49);
        goto -> bb142;
    }

    bb33: {
        switchInt(move _50) -> [0: bb48, otherwise: bb34];
    }

    bb34: {
        _53 = &_10;
        _52 = Option::<RouteUri>::is_some(move _53) -> [return: bb35, unwind: bb161];
    }

    bb35: {
        switchInt(move _52) -> [0: bb41, otherwise: bb36];
    }

    bb36: {
        _177 = const _;
        _57 = _177 as &[&str] (PointerCoercion(Unsize));
        _60 = core::fmt::rt::Argument::<'_>::none() -> [return: bb37, unwind: bb161];
    }

    bb37: {
        _59 = &_60;
        _58 = _59 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _56 = std::fmt::Arguments::<'_>::new_v1(move _57, move _58) -> [return: bb38, unwind: bb161];
    }

    bb38: {
        _55 = format(move _56) -> [return: bb39, unwind: bb161];
    }

    bb39: {
        _54 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_44, move _55) -> [return: bb40, unwind: bb161];
    }

    bb40: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _54);
        goto -> bb142;
    }

    bb41: {
        _63 = <RouteUri as devise::FromMeta>::from_meta(_43) -> [return: bb42, unwind: bb161];
    }

    bb42: {
        _62 = <std::result::Result<RouteUri, devise::Diagnostic> as std::ops::Try>::branch(move _63) -> [return: bb43, unwind: bb161];
    }

    bb43: {
        _64 = discriminant(_62);
        switchInt(move _64) -> [0: bb44, 1: bb45, otherwise: bb5];
    }

    bb44: {
        _66 = move ((_62 as Continue).0: attribute::route::parse::RouteUri);
        _61 = Option::<RouteUri>::Some(move _66);
        drop(_10) -> [return: bb46, unwind: bb47];
    }

    bb45: {
        _65 = move ((_62 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _65) -> [return: bb176, unwind: bb161];
    }

    bb46: {
        _191 = const true;
        _10 = move _61;
        goto -> bb24;
    }

    bb47 (cleanup): {
        _191 = const true;
        _10 = move _61;
        goto -> bb161;
    }

    bb48: {
        _68 = &_45;
        _184 = const _;
        _67 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _68, _184) -> [return: bb49, unwind: bb161];
    }

    bb49: {
        switchInt(move _67) -> [0: bb64, otherwise: bb50];
    }

    bb50: {
        _70 = &_11;
        _69 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::is_some(move _70) -> [return: bb51, unwind: bb161];
    }

    bb51: {
        switchInt(move _69) -> [0: bb57, otherwise: bb52];
    }

    bb52: {
        _178 = const _;
        _74 = _178 as &[&str] (PointerCoercion(Unsize));
        _77 = core::fmt::rt::Argument::<'_>::none() -> [return: bb53, unwind: bb161];
    }

    bb53: {
        _76 = &_77;
        _75 = _76 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _73 = std::fmt::Arguments::<'_>::new_v1(move _74, move _75) -> [return: bb54, unwind: bb161];
    }

    bb54: {
        _72 = format(move _73) -> [return: bb55, unwind: bb161];
    }

    bb55: {
        _71 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_44, move _72) -> [return: bb56, unwind: bb161];
    }

    bb56: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _71);
        goto -> bb142;
    }

    bb57: {
        _80 = <Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::from_meta(_43) -> [return: bb58, unwind: bb161];
    }

    bb58: {
        _79 = <std::result::Result<Option<devise::SpanWrapped<param::Dynamic>>, devise::Diagnostic> as std::ops::Try>::branch(move _80) -> [return: bb59, unwind: bb161];
    }

    bb59: {
        _81 = discriminant(_79);
        switchInt(move _81) -> [0: bb60, 1: bb61, otherwise: bb5];
    }

    bb60: {
        _83 = move ((_79 as Continue).0: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _78 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::Some(move _83);
        drop(_11) -> [return: bb62, unwind: bb63];
    }

    bb61: {
        _82 = move ((_79 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _82) -> [return: bb177, unwind: bb161];
    }

    bb62: {
        _190 = const true;
        _11 = move _78;
        goto -> bb24;
    }

    bb63 (cleanup): {
        _190 = const true;
        _11 = move _78;
        goto -> bb161;
    }

    bb64: {
        _85 = &_45;
        _183 = const _;
        _84 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _85, _183) -> [return: bb65, unwind: bb161];
    }

    bb65: {
        switchInt(move _84) -> [0: bb80, otherwise: bb66];
    }

    bb66: {
        _87 = &_12;
        _86 = Option::<Option<http_codegen::MediaType>>::is_some(move _87) -> [return: bb67, unwind: bb161];
    }

    bb67: {
        switchInt(move _86) -> [0: bb73, otherwise: bb68];
    }

    bb68: {
        _179 = const _;
        _91 = _179 as &[&str] (PointerCoercion(Unsize));
        _94 = core::fmt::rt::Argument::<'_>::none() -> [return: bb69, unwind: bb161];
    }

    bb69: {
        _93 = &_94;
        _92 = _93 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _90 = std::fmt::Arguments::<'_>::new_v1(move _91, move _92) -> [return: bb70, unwind: bb161];
    }

    bb70: {
        _89 = format(move _90) -> [return: bb71, unwind: bb161];
    }

    bb71: {
        _88 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_44, move _89) -> [return: bb72, unwind: bb161];
    }

    bb72: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _88);
        goto -> bb142;
    }

    bb73: {
        _97 = <Option<http_codegen::MediaType> as devise::FromMeta>::from_meta(_43) -> [return: bb74, unwind: bb161];
    }

    bb74: {
        _96 = <std::result::Result<Option<http_codegen::MediaType>, devise::Diagnostic> as std::ops::Try>::branch(move _97) -> [return: bb75, unwind: bb161];
    }

    bb75: {
        _98 = discriminant(_96);
        switchInt(move _98) -> [0: bb76, 1: bb77, otherwise: bb5];
    }

    bb76: {
        _100 = move ((_96 as Continue).0: std::option::Option<http_codegen::MediaType>);
        _95 = Option::<Option<http_codegen::MediaType>>::Some(move _100);
        drop(_12) -> [return: bb78, unwind: bb79];
    }

    bb77: {
        _99 = move ((_96 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _99) -> [return: bb178, unwind: bb161];
    }

    bb78: {
        _189 = const true;
        _12 = move _95;
        goto -> bb24;
    }

    bb79 (cleanup): {
        _189 = const true;
        _12 = move _95;
        goto -> bb161;
    }

    bb80: {
        _102 = &_45;
        _182 = const _;
        _101 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _102, _182) -> [return: bb81, unwind: bb161];
    }

    bb81: {
        switchInt(move _101) -> [0: bb94, otherwise: bb82];
    }

    bb82: {
        _104 = &_13;
        _103 = Option::<Option<isize>>::is_some(move _104) -> [return: bb83, unwind: bb161];
    }

    bb83: {
        switchInt(move _103) -> [0: bb89, otherwise: bb84];
    }

    bb84: {
        _180 = const _;
        _108 = _180 as &[&str] (PointerCoercion(Unsize));
        _111 = core::fmt::rt::Argument::<'_>::none() -> [return: bb85, unwind: bb161];
    }

    bb85: {
        _110 = &_111;
        _109 = _110 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _107 = std::fmt::Arguments::<'_>::new_v1(move _108, move _109) -> [return: bb86, unwind: bb161];
    }

    bb86: {
        _106 = format(move _107) -> [return: bb87, unwind: bb161];
    }

    bb87: {
        _105 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_44, move _106) -> [return: bb88, unwind: bb161];
    }

    bb88: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _105);
        goto -> bb142;
    }

    bb89: {
        _114 = <Option<isize> as devise::FromMeta>::from_meta(_43) -> [return: bb90, unwind: bb161];
    }

    bb90: {
        _113 = <std::result::Result<Option<isize>, devise::Diagnostic> as std::ops::Try>::branch(move _114) -> [return: bb91, unwind: bb161];
    }

    bb91: {
        _115 = discriminant(_113);
        switchInt(move _115) -> [0: bb92, 1: bb93, otherwise: bb5];
    }

    bb92: {
        _117 = ((_113 as Continue).0: std::option::Option<isize>);
        _112 = Option::<Option<isize>>::Some(_117);
        _13 = move _112;
        goto -> bb24;
    }

    bb93: {
        _116 = move ((_113 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _116) -> [return: bb179, unwind: bb161];
    }

    bb94: {
        _181 = const _;
        _120 = _181 as &[&str] (PointerCoercion(Unsize));
        _125 = &_45;
        _124 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_125) -> [return: bb95, unwind: bb161];
    }

    bb95: {
        _123 = [move _124];
        _122 = &_123;
        _121 = _122 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _119 = std::fmt::Arguments::<'_>::new_v1(move _120, move _121) -> [return: bb96, unwind: bb161];
    }

    bb96: {
        _118 = format(move _119) -> [return: bb97, unwind: bb161];
    }

    bb97: {
        _126 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_44, move _118) -> [return: bb98, unwind: bb161];
    }

    bb98: {
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Err(move _126);
        goto -> bb142;
    }

    bb99: {
        _131 = _9;
        _130 = Option::<devise::SpanWrapped<http_codegen::Method>>::or_else::<fn() -> Option<devise::SpanWrapped<http_codegen::Method>> {<devise::SpanWrapped<http_codegen::Method> as devise::FromMeta>::default}>(move _131, <devise::SpanWrapped<http_codegen::Method> as devise::FromMeta>::default) -> [return: bb100, unwind: bb162];
    }

    bb100: {
        _133 = &_2;
        _132 = {closure@core/codegen/src/attribute/route/parse.rs:44:5: 44:6} { __span: move _133 };
        _129 = Option::<devise::SpanWrapped<http_codegen::Method>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:44:5: 44:6}>(move _130, move _132) -> [return: bb101, unwind: bb162];
    }

    bb101: {
        _128 = <std::result::Result<devise::SpanWrapped<http_codegen::Method>, devise::Diagnostic> as std::ops::Try>::branch(move _129) -> [return: bb102, unwind: bb162];
    }

    bb102: {
        _134 = discriminant(_128);
        switchInt(move _134) -> [0: bb103, 1: bb104, otherwise: bb5];
    }

    bb103: {
        _136 = ((_128 as Continue).0: devise::SpanWrapped<http_codegen::Method>);
        _191 = const false;
        _141 = move _10;
        _140 = Option::<RouteUri>::or_else::<fn() -> Option<RouteUri> {<RouteUri as devise::FromMeta>::default}>(move _141, <RouteUri as devise::FromMeta>::default) -> [return: bb106, unwind: bb159];
    }

    bb104: {
        _135 = move ((_128 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _135) -> [return: bb105, unwind: bb159];
    }

    bb105: {
        drop(_12) -> [return: bb139, unwind: bb160];
    }

    bb106: {
        _143 = &_2;
        _142 = {closure@core/codegen/src/attribute/route/parse.rs:46:5: 46:8} { __span: move _143 };
        _139 = Option::<RouteUri>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:46:5: 46:8}>(move _140, move _142) -> [return: bb107, unwind: bb159];
    }

    bb107: {
        _138 = <std::result::Result<RouteUri, devise::Diagnostic> as std::ops::Try>::branch(move _139) -> [return: bb108, unwind: bb159];
    }

    bb108: {
        _144 = discriminant(_138);
        switchInt(move _144) -> [0: bb109, 1: bb110, otherwise: bb5];
    }

    bb109: {
        _146 = move ((_138 as Continue).0: attribute::route::parse::RouteUri);
        _137 = move _146;
        _190 = const false;
        _151 = move _11;
        _150 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<param::Dynamic>>> {<Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::default}>(move _151, <Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::default) -> [return: bb112, unwind: bb157];
    }

    bb110: {
        _145 = move ((_138 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _145) -> [return: bb111, unwind: bb158];
    }

    bb111: {
        drop(_12) -> [return: bb137, unwind: bb170];
    }

    bb112: {
        _153 = &_2;
        _152 = {closure@core/codegen/src/attribute/route/parse.rs:47:5: 47:8} { __span: move _153 };
        _149 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:47:5: 47:8}>(move _150, move _152) -> [return: bb113, unwind: bb157];
    }

    bb113: {
        _148 = <std::result::Result<Option<devise::SpanWrapped<param::Dynamic>>, devise::Diagnostic> as std::ops::Try>::branch(move _149) -> [return: bb114, unwind: bb157];
    }

    bb114: {
        _154 = discriminant(_148);
        switchInt(move _154) -> [0: bb115, 1: bb116, otherwise: bb5];
    }

    bb115: {
        _156 = move ((_148 as Continue).0: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _147 = move _156;
        _189 = const false;
        _161 = move _12;
        _160 = Option::<Option<http_codegen::MediaType>>::or_else::<fn() -> Option<Option<http_codegen::MediaType>> {<Option<http_codegen::MediaType> as devise::FromMeta>::default}>(move _161, <Option<http_codegen::MediaType> as devise::FromMeta>::default) -> [return: bb118, unwind: bb155];
    }

    bb116: {
        _155 = move ((_148 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _155) -> [return: bb117, unwind: bb156];
    }

    bb117: {
        drop(_137) -> [return: bb135, unwind: bb168];
    }

    bb118: {
        _163 = &_2;
        _162 = {closure@core/codegen/src/attribute/route/parse.rs:48:5: 48:8} { __span: move _163 };
        _159 = Option::<Option<http_codegen::MediaType>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:48:5: 48:8}>(move _160, move _162) -> [return: bb119, unwind: bb155];
    }

    bb119: {
        _158 = <std::result::Result<Option<http_codegen::MediaType>, devise::Diagnostic> as std::ops::Try>::branch(move _159) -> [return: bb120, unwind: bb155];
    }

    bb120: {
        _164 = discriminant(_158);
        switchInt(move _164) -> [0: bb121, 1: bb122, otherwise: bb5];
    }

    bb121: {
        _166 = move ((_158 as Continue).0: std::option::Option<http_codegen::MediaType>);
        _157 = move _166;
        _170 = _13;
        _169 = Option::<Option<isize>>::or_else::<fn() -> Option<Option<isize>> {<Option<isize> as devise::FromMeta>::default}>(move _170, <Option<isize> as devise::FromMeta>::default) -> [return: bb124, unwind: bb152];
    }

    bb122: {
        _165 = move ((_158 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _165) -> [return: bb123, unwind: bb153];
    }

    bb123: {
        drop(_147) -> [return: bb133, unwind: bb154];
    }

    bb124: {
        _172 = &_2;
        _171 = {closure@core/codegen/src/attribute/route/parse.rs:49:5: 49:8} { __span: move _172 };
        _168 = Option::<Option<isize>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:49:5: 49:8}>(move _169, move _171) -> [return: bb125, unwind: bb152];
    }

    bb125: {
        _167 = <std::result::Result<Option<isize>, devise::Diagnostic> as std::ops::Try>::branch(move _168) -> [return: bb126, unwind: bb152];
    }

    bb126: {
        _173 = discriminant(_167);
        switchInt(move _173) -> [0: bb127, 1: bb128, otherwise: bb5];
    }

    bb127: {
        _175 = ((_167 as Continue).0: std::option::Option<isize>);
        _127 = route::parse::Attribute { method: _136, uri: move _137, data: move _147, format: move _157, rank: _175 };
        _0 = std::result::Result::<route::parse::Attribute, devise::Diagnostic>::Ok(move _127);
        _189 = const false;
        _190 = const false;
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb128: {
        _174 = move ((_167 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _174) -> [return: bb129, unwind: bb149];
    }

    bb129: {
        drop(_157) -> [return: bb130, unwind: bb150];
    }

    bb130: {
        drop(_147) -> [return: bb131, unwind: bb151];
    }

    bb131: {
        drop(_137) -> [return: bb132, unwind continue];
    }

    bb132: {
        _189 = const false;
        _190 = const false;
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb133: {
        drop(_137) -> [return: bb134, unwind continue];
    }

    bb134: {
        _189 = const false;
        _190 = const false;
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb135: {
        drop(_12) -> [return: bb136, unwind continue];
    }

    bb136: {
        _189 = const false;
        _190 = const false;
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb137: {
        _189 = const false;
        drop(_11) -> [return: bb138, unwind continue];
    }

    bb138: {
        _190 = const false;
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb139: {
        _189 = const false;
        drop(_11) -> [return: bb140, unwind: bb172];
    }

    bb140: {
        _190 = const false;
        drop(_10) -> [return: bb141, unwind continue];
    }

    bb141: {
        _191 = const false;
        _188 = const false;
        goto -> bb148;
    }

    bb142: {
        drop(_39) -> [return: bb143, unwind: bb162];
    }

    bb143: {
        drop(_12) -> [return: bb144, unwind: bb163];
    }

    bb144: {
        _189 = const false;
        drop(_11) -> [return: bb145, unwind: bb164];
    }

    bb145: {
        _190 = const false;
        drop(_10) -> [return: bb146, unwind: bb174];
    }

    bb146: {
        _191 = const false;
        switchInt(_188) -> [0: bb147, otherwise: bb166];
    }

    bb147: {
        _188 = const false;
        goto -> bb148;
    }

    bb148: {
        return;
    }

    bb149 (cleanup): {
        drop(_157) -> [return: bb150, unwind terminate(cleanup)];
    }

    bb150 (cleanup): {
        drop(_147) -> [return: bb151, unwind terminate(cleanup)];
    }

    bb151 (cleanup): {
        drop(_137) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb152 (cleanup): {
        drop(_157) -> [return: bb153, unwind terminate(cleanup)];
    }

    bb153 (cleanup): {
        drop(_147) -> [return: bb154, unwind terminate(cleanup)];
    }

    bb154 (cleanup): {
        drop(_137) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb155 (cleanup): {
        drop(_147) -> [return: bb156, unwind terminate(cleanup)];
    }

    bb156 (cleanup): {
        drop(_137) -> [return: bb168, unwind terminate(cleanup)];
    }

    bb157 (cleanup): {
        drop(_137) -> [return: bb158, unwind terminate(cleanup)];
    }

    bb158 (cleanup): {
        drop(_12) -> [return: bb170, unwind terminate(cleanup)];
    }

    bb159 (cleanup): {
        drop(_12) -> [return: bb160, unwind terminate(cleanup)];
    }

    bb160 (cleanup): {
        drop(_11) -> [return: bb172, unwind terminate(cleanup)];
    }

    bb161 (cleanup): {
        drop(_39) -> [return: bb162, unwind terminate(cleanup)];
    }

    bb162 (cleanup): {
        drop(_12) -> [return: bb163, unwind terminate(cleanup)];
    }

    bb163 (cleanup): {
        drop(_11) -> [return: bb164, unwind terminate(cleanup)];
    }

    bb164 (cleanup): {
        drop(_10) -> [return: bb174, unwind terminate(cleanup)];
    }

    bb165 (cleanup): {
        resume;
    }

    bb166: {
        drop(_3) -> [return: bb147, unwind continue];
    }

    bb167 (cleanup): {
        drop(_12) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb168 (cleanup): {
        switchInt(_189) -> [0: bb165, otherwise: bb167];
    }

    bb169 (cleanup): {
        drop(_11) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb170 (cleanup): {
        switchInt(_190) -> [0: bb165, otherwise: bb169];
    }

    bb171 (cleanup): {
        drop(_10) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb172 (cleanup): {
        switchInt(_191) -> [0: bb165, otherwise: bb171];
    }

    bb173 (cleanup): {
        drop(_3) -> [return: bb165, unwind terminate(cleanup)];
    }

    bb174 (cleanup): {
        switchInt(_188) -> [0: bb165, otherwise: bb173];
    }

    bb175: {
        goto -> bb143;
    }

    bb176: {
        goto -> bb142;
    }

    bb177: {
        goto -> bb142;
    }

    bb178: {
        goto -> bb142;
    }

    bb179: {
        goto -> bb142;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing expected parameter: `method`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: uri"];
        _0 = &_1;
        return;
    }
}

promoted[2] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: data"];
        _0 = &_1;
        return;
    }
}

promoted[3] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: format"];
        _0 = &_1;
        return;
    }
}

promoted[4] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: rank"];
        _0 = &_1;
        return;
    }
}

promoted[5] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[6] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "rank";
        _0 = &_1;
        return;
    }
}

promoted[7] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "format";
        _0 = &_1;
        return;
    }
}

promoted[8] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "data";
        _0 = &_1;
        return;
    }
}

promoted[9] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "uri";
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:44:5: 44:6}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `method`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#1}(_1: {closure@core/codegen/src/attribute/route/parse.rs:46:5: 46:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `uri`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#2}(_1: {closure@core/codegen/src/attribute/route/parse.rs:47:5: 47:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#2}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `data`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#3}(_1: {closure@core/codegen/src/attribute/route/parse.rs:48:5: 48:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#3}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `format`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#4}(_1: {closure@core/codegen/src/attribute/route/parse.rs:49:5: 49:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:42:17: 42:25>::from_meta::{closure#4}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `rank`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:53:10: 53:15>::fmt(_1: &MethodAttribute, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &attribute::route::parse::RouteUri;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &std::option::Option<http_codegen::MediaType>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&std::option::Option<isize>;
    let _16: &std::option::Option<isize>;

    bb0: {
        _3 = const "MethodAttribute";
        _4 = const "uri";
        _6 = &((*_1).0: attribute::route::parse::RouteUri);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "data";
        _9 = &((*_1).1: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "format";
        _12 = &((*_1).2: std::option::Option<http_codegen::MediaType>);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "rank";
        _16 = &((*_1).3: std::option::Option<isize>);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const route::parse::_: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta(_1: &devise::MetaItem) -> std::result::Result<MethodAttribute, devise::Diagnostic> {
    debug __meta => _1;
    let mut _0: std::result::Result<attribute::route::parse::MethodAttribute, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::punctuated::Iter<'_, devise::MetaItem>>;
    let mut _5: std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic>;
    let mut _6: isize;
    let mut _13: std::option::Option<&devise::MetaItem>;
    let mut _14: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _15: isize;
    let mut _18: bool;
    let mut _19: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::RouteUri>;
    let mut _21: std::result::Result<attribute::route::parse::RouteUri, devise::Diagnostic>;
    let mut _22: isize;
    let mut _26: devise::Diagnostic;
    let mut _27: proc_macro2::Span;
    let mut _28: devise::Diagnostic;
    let mut _29: proc_macro2::Span;
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 0];
    let _35: [core::fmt::rt::Argument<'_>; 0];
    let mut _36: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _37: syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _39: std::option::Option<&devise::MetaItem>;
    let mut _40: &mut syn::punctuated::Iter<'_, devise::MetaItem>;
    let mut _41: isize;
    let mut _45: std::option::Option<&proc_macro2::Ident>;
    let mut _46: isize;
    let mut _48: devise::Diagnostic;
    let mut _49: bool;
    let mut _50: &&proc_macro2::Ident;
    let mut _51: bool;
    let mut _52: &std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _53: devise::Diagnostic;
    let mut _55: std::fmt::Arguments<'_>;
    let mut _56: &[&str];
    let mut _57: &[core::fmt::rt::Argument<'_>];
    let _58: &[core::fmt::rt::Argument<'_>; 0];
    let _59: [core::fmt::rt::Argument<'_>; 0];
    let mut _60: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _61: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _62: std::result::Result<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>, devise::Diagnostic>;
    let mut _63: isize;
    let mut _66: bool;
    let mut _67: &&proc_macro2::Ident;
    let mut _68: bool;
    let mut _69: &std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _70: devise::Diagnostic;
    let mut _72: std::fmt::Arguments<'_>;
    let mut _73: &[&str];
    let mut _74: &[core::fmt::rt::Argument<'_>];
    let _75: &[core::fmt::rt::Argument<'_>; 0];
    let _76: [core::fmt::rt::Argument<'_>; 0];
    let mut _77: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _78: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<http_codegen::MediaType>>;
    let mut _79: std::result::Result<std::option::Option<http_codegen::MediaType>, devise::Diagnostic>;
    let mut _80: isize;
    let mut _83: bool;
    let mut _84: &&proc_macro2::Ident;
    let mut _85: bool;
    let mut _86: &std::option::Option<std::option::Option<isize>>;
    let mut _87: devise::Diagnostic;
    let mut _89: std::fmt::Arguments<'_>;
    let mut _90: &[&str];
    let mut _91: &[core::fmt::rt::Argument<'_>];
    let _92: &[core::fmt::rt::Argument<'_>; 0];
    let _93: [core::fmt::rt::Argument<'_>; 0];
    let mut _94: std::option::Option<std::option::Option<isize>>;
    let mut _95: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<isize>>;
    let mut _96: std::result::Result<std::option::Option<isize>, devise::Diagnostic>;
    let mut _97: isize;
    let mut _101: std::fmt::Arguments<'_>;
    let mut _102: &[&str];
    let mut _103: &[core::fmt::rt::Argument<'_>];
    let _104: &[core::fmt::rt::Argument<'_>; 1];
    let _105: [core::fmt::rt::Argument<'_>; 1];
    let mut _106: core::fmt::rt::Argument<'_>;
    let _107: &&proc_macro2::Ident;
    let mut _108: devise::Diagnostic;
    let mut _109: attribute::route::parse::MethodAttribute;
    let mut _110: attribute::route::parse::RouteUri;
    let mut _111: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::RouteUri>;
    let mut _112: std::result::Result<attribute::route::parse::RouteUri, devise::Diagnostic>;
    let mut _113: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _114: std::option::Option<attribute::route::parse::RouteUri>;
    let mut _115: {closure@core/codegen/src/attribute/route/parse.rs:55:5: 55:6};
    let mut _116: &proc_macro2::Span;
    let mut _117: isize;
    let mut _120: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let mut _121: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _122: std::result::Result<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>, devise::Diagnostic>;
    let mut _123: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _124: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
    let mut _125: {closure@core/codegen/src/attribute/route/parse.rs:57:5: 57:8};
    let mut _126: &proc_macro2::Span;
    let mut _127: isize;
    let mut _130: std::option::Option<http_codegen::MediaType>;
    let mut _131: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<http_codegen::MediaType>>;
    let mut _132: std::result::Result<std::option::Option<http_codegen::MediaType>, devise::Diagnostic>;
    let mut _133: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _134: std::option::Option<std::option::Option<http_codegen::MediaType>>;
    let mut _135: {closure@core/codegen/src/attribute/route/parse.rs:58:5: 58:8};
    let mut _136: &proc_macro2::Span;
    let mut _137: isize;
    let mut _140: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::option::Option<isize>>;
    let mut _141: std::result::Result<std::option::Option<isize>, devise::Diagnostic>;
    let mut _142: std::option::Option<std::option::Option<isize>>;
    let mut _143: std::option::Option<std::option::Option<isize>>;
    let mut _144: {closure@core/codegen/src/attribute/route/parse.rs:59:5: 59:8};
    let mut _145: &proc_macro2::Span;
    let mut _146: isize;
    let mut _157: &devise::MetaItem;
    let mut _158: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone;
    let mut _159: bool;
    let mut _160: bool;
    let mut _161: bool;
    let mut _162: bool;
    scope 1 {
        debug __span => _2;
        let mut _3: syn::punctuated::Iter<'_, devise::MetaItem>;
        let _7: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _8: syn::punctuated::Iter<'_, devise::MetaItem>;
        scope 2 {
            debug __list => _3;
            scope 7 {
                debug uri => _9;
                scope 9 {
                    debug data => _10;
                    scope 11 {
                        debug format => _11;
                        scope 13 {
                            debug rank => _12;
                            let _16: &devise::MetaItem;
                            let _17: &&devise::MetaItem;
                            let _25: &devise::MetaItem;
                            let _30: std::string::String;
                            let mut _38: syn::punctuated::Iter<'_, devise::MetaItem>;
                            let _118: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _119: attribute::route::parse::RouteUri;
                            let _128: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _129: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
                            let _138: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _139: std::option::Option<http_codegen::MediaType>;
                            let _147: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                            let _148: std::option::Option<isize>;
                            let mut _149: &[&str; 1];
                            scope 15 {
                                debug __i => _16;
                                debug __i => _17;
                                let _23: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _24: attribute::route::parse::RouteUri;
                                scope 16 {
                                    debug residual => _23;
                                    scope 17 {
                                    }
                                }
                                scope 18 {
                                    debug val => _24;
                                    scope 19 {
                                    }
                                }
                            }
                            scope 20 {
                                debug __i => _25;
                            }
                            scope 21 {
                                debug res => _30;
                            }
                            scope 22 {
                                debug iter => _38;
                                let _42: &devise::MetaItem;
                                scope 23 {
                                    debug __meta => _42;
                                    let _43: proc_macro2::Span;
                                    scope 24 {
                                        debug __span => _43;
                                        let _44: &proc_macro2::Ident;
                                        let _47: &proc_macro2::Ident;
                                        scope 25 {
                                            debug __name => _44;
                                            let _54: std::string::String;
                                            let _64: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _65: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
                                            let _71: std::string::String;
                                            let _81: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _82: std::option::Option<http_codegen::MediaType>;
                                            let _88: std::string::String;
                                            let _98: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                            let _99: std::option::Option<isize>;
                                            let _100: std::string::String;
                                            let mut _150: &[&str; 1];
                                            let mut _151: &[&str; 1];
                                            let mut _152: &[&str; 1];
                                            let mut _153: &[&str; 2];
                                            let mut _154: &&str;
                                            let mut _155: &&str;
                                            let mut _156: &&str;
                                            scope 27 {
                                                debug res => _54;
                                            }
                                            scope 28 {
                                                debug residual => _64;
                                                scope 29 {
                                                }
                                            }
                                            scope 30 {
                                                debug val => _65;
                                                scope 31 {
                                                }
                                            }
                                            scope 32 {
                                                debug res => _71;
                                            }
                                            scope 33 {
                                                debug residual => _81;
                                                scope 34 {
                                                }
                                            }
                                            scope 35 {
                                                debug val => _82;
                                                scope 36 {
                                                }
                                            }
                                            scope 37 {
                                                debug res => _88;
                                            }
                                            scope 38 {
                                                debug residual => _98;
                                                scope 39 {
                                                }
                                            }
                                            scope 40 {
                                                debug val => _99;
                                                scope 41 {
                                                }
                                            }
                                            scope 42 {
                                                debug __msg => _100;
                                            }
                                            scope 43 {
                                                debug res => _100;
                                            }
                                        }
                                        scope 26 {
                                            debug __ident => _47;
                                        }
                                    }
                                }
                            }
                            scope 44 {
                                debug residual => _118;
                                scope 45 {
                                }
                            }
                            scope 46 {
                                debug val => _119;
                                scope 47 {
                                }
                            }
                            scope 48 {
                                debug residual => _128;
                                scope 49 {
                                }
                            }
                            scope 50 {
                                debug val => _129;
                                scope 51 {
                                }
                            }
                            scope 52 {
                                debug residual => _138;
                                scope 53 {
                                }
                            }
                            scope 54 {
                                debug val => _139;
                                scope 55 {
                                }
                            }
                            scope 56 {
                                debug residual => _147;
                                scope 57 {
                                }
                            }
                            scope 58 {
                                debug val => _148;
                                scope 59 {
                                }
                            }
                        }
                        scope 14 {
                            let mut _12: std::option::Option<std::option::Option<isize>>;
                        }
                    }
                    scope 12 {
                        let mut _11: std::option::Option<std::option::Option<http_codegen::MediaType>>;
                    }
                }
                scope 10 {
                    let mut _10: std::option::Option<std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>>;
                }
            }
            scope 8 {
                let mut _9: std::option::Option<attribute::route::parse::RouteUri>;
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
    }

    bb0: {
        _159 = const false;
        _162 = const false;
        _161 = const false;
        _160 = const false;
        _2 = <devise::MetaItem as devise::Spanned>::span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = devise::MetaItem::list(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <std::result::Result<syn::punctuated::Iter<'_, devise::MetaItem>, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _158 = move ((_4 as Continue).0: impl std::iter::Iterator<Item = &devise::MetaItem> + std::clone::Clone);
        _8 = move (_158 as subtype syn::punctuated::Iter<'_, devise::MetaItem>);
        _159 = const true;
        _3 = move _8;
        _162 = const true;
        _9 = Option::<RouteUri>::None;
        _161 = const true;
        _10 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::None;
        _160 = const true;
        _11 = Option::<Option<http_codegen::MediaType>>::None;
        _12 = Option::<Option<isize>>::None;
        _14 = &mut _3;
        _13 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(move _14) -> [return: bb7, unwind: bb137];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _7) -> [return: bb124, unwind continue];
    }

    bb7: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb8, 1: bb9, otherwise: bb5];
    }

    bb8: {
        _29 = _2;
        _149 = const _;
        _32 = _149 as &[&str] (PointerCoercion(Unsize));
        _35 = core::fmt::rt::Argument::<'_>::none() -> [return: bb21, unwind: bb137];
    }

    bb9: {
        _17 = &((_13 as Some).0: &devise::MetaItem);
        _157 = deref_copy (*_17);
        _18 = devise::MetaItem::is_bare(_157) -> [return: bb10, unwind: bb137];
    }

    bb10: {
        switchInt(move _18) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _16 = ((_13 as Some).0: &devise::MetaItem);
        _21 = <RouteUri as devise::FromMeta>::from_meta(_16) -> [return: bb13, unwind: bb137];
    }

    bb12: {
        _25 = ((_13 as Some).0: &devise::MetaItem);
        _27 = <devise::MetaItem as devise::Spanned>::span(_25) -> [return: bb19, unwind: bb137];
    }

    bb13: {
        _20 = <std::result::Result<RouteUri, devise::Diagnostic> as std::ops::Try>::branch(move _21) -> [return: bb14, unwind: bb137];
    }

    bb14: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb15, 1: bb16, otherwise: bb5];
    }

    bb15: {
        _24 = move ((_20 as Continue).0: attribute::route::parse::RouteUri);
        _19 = Option::<RouteUri>::Some(move _24);
        drop(_9) -> [return: bb17, unwind: bb18];
    }

    bb16: {
        _23 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _23) -> [return: bb149, unwind: bb137];
    }

    bb17: {
        _162 = const true;
        _9 = move _19;
        _159 = const false;
        _37 = move _3;
        _36 = <syn::punctuated::Iter<'_, devise::MetaItem> as IntoIterator>::into_iter(move _37) -> [return: bb25, unwind: bb137];
    }

    bb18 (cleanup): {
        _162 = const true;
        _9 = move _19;
        goto -> bb137;
    }

    bb19: {
        _26 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _27, const "unexpected keyed parameter: expected literal or identifier") -> [return: bb20, unwind: bb137];
    }

    bb20: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _26);
        goto -> bb120;
    }

    bb21: {
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = std::fmt::Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb22, unwind: bb137];
    }

    bb22: {
        _30 = format(move _31) -> [return: bb23, unwind: bb137];
    }

    bb23: {
        _28 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _29, move _30) -> [return: bb24, unwind: bb137];
    }

    bb24: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _28);
        goto -> bb120;
    }

    bb25: {
        _38 = move _36;
        goto -> bb26;
    }

    bb26: {
        _40 = &mut _38;
        _39 = <syn::punctuated::Iter<'_, devise::MetaItem> as Iterator>::next(_40) -> [return: bb27, unwind: bb136];
    }

    bb27: {
        _41 = discriminant(_39);
        switchInt(move _41) -> [0: bb29, 1: bb28, otherwise: bb5];
    }

    bb28: {
        _42 = ((_39 as Some).0: &devise::MetaItem);
        _43 = <devise::MetaItem as devise::Spanned>::span(_42) -> [return: bb30, unwind: bb136];
    }

    bb29: {
        drop(_38) -> [return: bb85, unwind: bb137];
    }

    bb30: {
        _45 = devise::MetaItem::name(_42) -> [return: bb31, unwind: bb136];
    }

    bb31: {
        _46 = discriminant(_45);
        switchInt(move _46) -> [0: bb32, 1: bb33, otherwise: bb5];
    }

    bb32: {
        _48 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_43, const "expected key/value `key = value`") -> [return: bb34, unwind: bb136];
    }

    bb33: {
        _47 = ((_45 as Some).0: &proc_macro2::Ident);
        _44 = _47;
        _50 = &_44;
        _156 = const _;
        _49 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _50, _156) -> [return: bb35, unwind: bb136];
    }

    bb34: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _48);
        goto -> bb119;
    }

    bb35: {
        switchInt(move _49) -> [0: bb50, otherwise: bb36];
    }

    bb36: {
        _52 = &_10;
        _51 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::is_some(move _52) -> [return: bb37, unwind: bb136];
    }

    bb37: {
        switchInt(move _51) -> [0: bb43, otherwise: bb38];
    }

    bb38: {
        _150 = const _;
        _56 = _150 as &[&str] (PointerCoercion(Unsize));
        _59 = core::fmt::rt::Argument::<'_>::none() -> [return: bb39, unwind: bb136];
    }

    bb39: {
        _58 = &_59;
        _57 = _58 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _55 = std::fmt::Arguments::<'_>::new_v1(move _56, move _57) -> [return: bb40, unwind: bb136];
    }

    bb40: {
        _54 = format(move _55) -> [return: bb41, unwind: bb136];
    }

    bb41: {
        _53 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_43, move _54) -> [return: bb42, unwind: bb136];
    }

    bb42: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _53);
        goto -> bb119;
    }

    bb43: {
        _62 = <Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::from_meta(_42) -> [return: bb44, unwind: bb136];
    }

    bb44: {
        _61 = <std::result::Result<Option<devise::SpanWrapped<param::Dynamic>>, devise::Diagnostic> as std::ops::Try>::branch(move _62) -> [return: bb45, unwind: bb136];
    }

    bb45: {
        _63 = discriminant(_61);
        switchInt(move _63) -> [0: bb46, 1: bb47, otherwise: bb5];
    }

    bb46: {
        _65 = move ((_61 as Continue).0: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _60 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::Some(move _65);
        drop(_10) -> [return: bb48, unwind: bb49];
    }

    bb47: {
        _64 = move ((_61 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _64) -> [return: bb150, unwind: bb136];
    }

    bb48: {
        _161 = const true;
        _10 = move _60;
        goto -> bb26;
    }

    bb49 (cleanup): {
        _161 = const true;
        _10 = move _60;
        goto -> bb136;
    }

    bb50: {
        _67 = &_44;
        _155 = const _;
        _66 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _67, _155) -> [return: bb51, unwind: bb136];
    }

    bb51: {
        switchInt(move _66) -> [0: bb66, otherwise: bb52];
    }

    bb52: {
        _69 = &_11;
        _68 = Option::<Option<http_codegen::MediaType>>::is_some(move _69) -> [return: bb53, unwind: bb136];
    }

    bb53: {
        switchInt(move _68) -> [0: bb59, otherwise: bb54];
    }

    bb54: {
        _151 = const _;
        _73 = _151 as &[&str] (PointerCoercion(Unsize));
        _76 = core::fmt::rt::Argument::<'_>::none() -> [return: bb55, unwind: bb136];
    }

    bb55: {
        _75 = &_76;
        _74 = _75 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _72 = std::fmt::Arguments::<'_>::new_v1(move _73, move _74) -> [return: bb56, unwind: bb136];
    }

    bb56: {
        _71 = format(move _72) -> [return: bb57, unwind: bb136];
    }

    bb57: {
        _70 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_43, move _71) -> [return: bb58, unwind: bb136];
    }

    bb58: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _70);
        goto -> bb119;
    }

    bb59: {
        _79 = <Option<http_codegen::MediaType> as devise::FromMeta>::from_meta(_42) -> [return: bb60, unwind: bb136];
    }

    bb60: {
        _78 = <std::result::Result<Option<http_codegen::MediaType>, devise::Diagnostic> as std::ops::Try>::branch(move _79) -> [return: bb61, unwind: bb136];
    }

    bb61: {
        _80 = discriminant(_78);
        switchInt(move _80) -> [0: bb62, 1: bb63, otherwise: bb5];
    }

    bb62: {
        _82 = move ((_78 as Continue).0: std::option::Option<http_codegen::MediaType>);
        _77 = Option::<Option<http_codegen::MediaType>>::Some(move _82);
        drop(_11) -> [return: bb64, unwind: bb65];
    }

    bb63: {
        _81 = move ((_78 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _81) -> [return: bb151, unwind: bb136];
    }

    bb64: {
        _160 = const true;
        _11 = move _77;
        goto -> bb26;
    }

    bb65 (cleanup): {
        _160 = const true;
        _11 = move _77;
        goto -> bb136;
    }

    bb66: {
        _84 = &_44;
        _154 = const _;
        _83 = <&proc_macro2::Ident as PartialEq<&str>>::eq(move _84, _154) -> [return: bb67, unwind: bb136];
    }

    bb67: {
        switchInt(move _83) -> [0: bb80, otherwise: bb68];
    }

    bb68: {
        _86 = &_12;
        _85 = Option::<Option<isize>>::is_some(move _86) -> [return: bb69, unwind: bb136];
    }

    bb69: {
        switchInt(move _85) -> [0: bb75, otherwise: bb70];
    }

    bb70: {
        _152 = const _;
        _90 = _152 as &[&str] (PointerCoercion(Unsize));
        _93 = core::fmt::rt::Argument::<'_>::none() -> [return: bb71, unwind: bb136];
    }

    bb71: {
        _92 = &_93;
        _91 = _92 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _89 = std::fmt::Arguments::<'_>::new_v1(move _90, move _91) -> [return: bb72, unwind: bb136];
    }

    bb72: {
        _88 = format(move _89) -> [return: bb73, unwind: bb136];
    }

    bb73: {
        _87 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_43, move _88) -> [return: bb74, unwind: bb136];
    }

    bb74: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _87);
        goto -> bb119;
    }

    bb75: {
        _96 = <Option<isize> as devise::FromMeta>::from_meta(_42) -> [return: bb76, unwind: bb136];
    }

    bb76: {
        _95 = <std::result::Result<Option<isize>, devise::Diagnostic> as std::ops::Try>::branch(move _96) -> [return: bb77, unwind: bb136];
    }

    bb77: {
        _97 = discriminant(_95);
        switchInt(move _97) -> [0: bb78, 1: bb79, otherwise: bb5];
    }

    bb78: {
        _99 = ((_95 as Continue).0: std::option::Option<isize>);
        _94 = Option::<Option<isize>>::Some(_99);
        _12 = move _94;
        goto -> bb26;
    }

    bb79: {
        _98 = move ((_95 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _98) -> [return: bb152, unwind: bb136];
    }

    bb80: {
        _153 = const _;
        _102 = _153 as &[&str] (PointerCoercion(Unsize));
        _107 = &_44;
        _106 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_107) -> [return: bb81, unwind: bb136];
    }

    bb81: {
        _105 = [move _106];
        _104 = &_105;
        _103 = _104 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _101 = std::fmt::Arguments::<'_>::new_v1(move _102, move _103) -> [return: bb82, unwind: bb136];
    }

    bb82: {
        _100 = format(move _101) -> [return: bb83, unwind: bb136];
    }

    bb83: {
        _108 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_43, move _100) -> [return: bb84, unwind: bb136];
    }

    bb84: {
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Err(move _108);
        goto -> bb119;
    }

    bb85: {
        _162 = const false;
        _114 = move _9;
        _113 = Option::<RouteUri>::or_else::<fn() -> Option<RouteUri> {<RouteUri as devise::FromMeta>::default}>(move _114, <RouteUri as devise::FromMeta>::default) -> [return: bb86, unwind: bb137];
    }

    bb86: {
        _116 = &_2;
        _115 = {closure@core/codegen/src/attribute/route/parse.rs:55:5: 55:6} { __span: move _116 };
        _112 = Option::<RouteUri>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:55:5: 55:6}>(move _113, move _115) -> [return: bb87, unwind: bb137];
    }

    bb87: {
        _111 = <std::result::Result<RouteUri, devise::Diagnostic> as std::ops::Try>::branch(move _112) -> [return: bb88, unwind: bb137];
    }

    bb88: {
        _117 = discriminant(_111);
        switchInt(move _117) -> [0: bb89, 1: bb90, otherwise: bb5];
    }

    bb89: {
        _119 = move ((_111 as Continue).0: attribute::route::parse::RouteUri);
        _110 = move _119;
        _161 = const false;
        _124 = move _10;
        _123 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::or_else::<fn() -> Option<Option<devise::SpanWrapped<param::Dynamic>>> {<Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::default}>(move _124, <Option<devise::SpanWrapped<param::Dynamic>> as devise::FromMeta>::default) -> [return: bb92, unwind: bb134];
    }

    bb90: {
        _118 = move ((_111 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _118) -> [return: bb91, unwind: bb135];
    }

    bb91: {
        drop(_11) -> [return: bb117, unwind: bb144];
    }

    bb92: {
        _126 = &_2;
        _125 = {closure@core/codegen/src/attribute/route/parse.rs:57:5: 57:8} { __span: move _126 };
        _122 = Option::<Option<devise::SpanWrapped<param::Dynamic>>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:57:5: 57:8}>(move _123, move _125) -> [return: bb93, unwind: bb134];
    }

    bb93: {
        _121 = <std::result::Result<Option<devise::SpanWrapped<param::Dynamic>>, devise::Diagnostic> as std::ops::Try>::branch(move _122) -> [return: bb94, unwind: bb134];
    }

    bb94: {
        _127 = discriminant(_121);
        switchInt(move _127) -> [0: bb95, 1: bb96, otherwise: bb5];
    }

    bb95: {
        _129 = move ((_121 as Continue).0: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _120 = move _129;
        _160 = const false;
        _134 = move _11;
        _133 = Option::<Option<http_codegen::MediaType>>::or_else::<fn() -> Option<Option<http_codegen::MediaType>> {<Option<http_codegen::MediaType> as devise::FromMeta>::default}>(move _134, <Option<http_codegen::MediaType> as devise::FromMeta>::default) -> [return: bb98, unwind: bb132];
    }

    bb96: {
        _128 = move ((_121 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _128) -> [return: bb97, unwind: bb133];
    }

    bb97: {
        drop(_110) -> [return: bb115, unwind: bb142];
    }

    bb98: {
        _136 = &_2;
        _135 = {closure@core/codegen/src/attribute/route/parse.rs:58:5: 58:8} { __span: move _136 };
        _132 = Option::<Option<http_codegen::MediaType>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:58:5: 58:8}>(move _133, move _135) -> [return: bb99, unwind: bb132];
    }

    bb99: {
        _131 = <std::result::Result<Option<http_codegen::MediaType>, devise::Diagnostic> as std::ops::Try>::branch(move _132) -> [return: bb100, unwind: bb132];
    }

    bb100: {
        _137 = discriminant(_131);
        switchInt(move _137) -> [0: bb101, 1: bb102, otherwise: bb5];
    }

    bb101: {
        _139 = move ((_131 as Continue).0: std::option::Option<http_codegen::MediaType>);
        _130 = move _139;
        _143 = _12;
        _142 = Option::<Option<isize>>::or_else::<fn() -> Option<Option<isize>> {<Option<isize> as devise::FromMeta>::default}>(move _143, <Option<isize> as devise::FromMeta>::default) -> [return: bb104, unwind: bb129];
    }

    bb102: {
        _138 = move ((_131 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _138) -> [return: bb103, unwind: bb130];
    }

    bb103: {
        drop(_120) -> [return: bb113, unwind: bb131];
    }

    bb104: {
        _145 = &_2;
        _144 = {closure@core/codegen/src/attribute/route/parse.rs:59:5: 59:8} { __span: move _145 };
        _141 = Option::<Option<isize>>::ok_or_else::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:59:5: 59:8}>(move _142, move _144) -> [return: bb105, unwind: bb129];
    }

    bb105: {
        _140 = <std::result::Result<Option<isize>, devise::Diagnostic> as std::ops::Try>::branch(move _141) -> [return: bb106, unwind: bb129];
    }

    bb106: {
        _146 = discriminant(_140);
        switchInt(move _146) -> [0: bb107, 1: bb108, otherwise: bb5];
    }

    bb107: {
        _148 = ((_140 as Continue).0: std::option::Option<isize>);
        _109 = MethodAttribute { uri: move _110, data: move _120, format: move _130, rank: _148 };
        _0 = std::result::Result::<MethodAttribute, devise::Diagnostic>::Ok(move _109);
        _160 = const false;
        _161 = const false;
        _162 = const false;
        _159 = const false;
        goto -> bb125;
    }

    bb108: {
        _147 = move ((_140 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<MethodAttribute, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _147) -> [return: bb109, unwind: bb126];
    }

    bb109: {
        drop(_130) -> [return: bb110, unwind: bb127];
    }

    bb110: {
        drop(_120) -> [return: bb111, unwind: bb128];
    }

    bb111: {
        drop(_110) -> [return: bb112, unwind continue];
    }

    bb112: {
        _160 = const false;
        _161 = const false;
        _162 = const false;
        _159 = const false;
        goto -> bb125;
    }

    bb113: {
        drop(_110) -> [return: bb114, unwind continue];
    }

    bb114: {
        _160 = const false;
        _161 = const false;
        _162 = const false;
        _159 = const false;
        goto -> bb125;
    }

    bb115: {
        drop(_11) -> [return: bb116, unwind continue];
    }

    bb116: {
        _160 = const false;
        _161 = const false;
        _162 = const false;
        _159 = const false;
        goto -> bb125;
    }

    bb117: {
        _160 = const false;
        drop(_10) -> [return: bb118, unwind continue];
    }

    bb118: {
        _161 = const false;
        _162 = const false;
        _159 = const false;
        goto -> bb125;
    }

    bb119: {
        drop(_38) -> [return: bb120, unwind: bb137];
    }

    bb120: {
        drop(_11) -> [return: bb121, unwind: bb138];
    }

    bb121: {
        _160 = const false;
        drop(_10) -> [return: bb122, unwind: bb146];
    }

    bb122: {
        _161 = const false;
        drop(_9) -> [return: bb123, unwind: bb148];
    }

    bb123: {
        _162 = const false;
        switchInt(_159) -> [0: bb124, otherwise: bb140];
    }

    bb124: {
        _159 = const false;
        goto -> bb125;
    }

    bb125: {
        return;
    }

    bb126 (cleanup): {
        drop(_130) -> [return: bb127, unwind terminate(cleanup)];
    }

    bb127 (cleanup): {
        drop(_120) -> [return: bb128, unwind terminate(cleanup)];
    }

    bb128 (cleanup): {
        drop(_110) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb129 (cleanup): {
        drop(_130) -> [return: bb130, unwind terminate(cleanup)];
    }

    bb130 (cleanup): {
        drop(_120) -> [return: bb131, unwind terminate(cleanup)];
    }

    bb131 (cleanup): {
        drop(_110) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb132 (cleanup): {
        drop(_120) -> [return: bb133, unwind terminate(cleanup)];
    }

    bb133 (cleanup): {
        drop(_110) -> [return: bb142, unwind terminate(cleanup)];
    }

    bb134 (cleanup): {
        drop(_110) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb135 (cleanup): {
        drop(_11) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb136 (cleanup): {
        drop(_38) -> [return: bb137, unwind terminate(cleanup)];
    }

    bb137 (cleanup): {
        drop(_11) -> [return: bb138, unwind terminate(cleanup)];
    }

    bb138 (cleanup): {
        drop(_10) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb139 (cleanup): {
        resume;
    }

    bb140: {
        drop(_3) -> [return: bb124, unwind continue];
    }

    bb141 (cleanup): {
        drop(_11) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb142 (cleanup): {
        switchInt(_160) -> [0: bb139, otherwise: bb141];
    }

    bb143 (cleanup): {
        drop(_10) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb144 (cleanup): {
        switchInt(_161) -> [0: bb139, otherwise: bb143];
    }

    bb145 (cleanup): {
        drop(_9) -> [return: bb148, unwind terminate(cleanup)];
    }

    bb146 (cleanup): {
        switchInt(_162) -> [0: bb148, otherwise: bb145];
    }

    bb147 (cleanup): {
        drop(_3) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb148 (cleanup): {
        switchInt(_159) -> [0: bb139, otherwise: bb147];
    }

    bb149: {
        goto -> bb120;
    }

    bb150: {
        goto -> bb119;
    }

    bb151: {
        goto -> bb119;
    }

    bb152: {
        goto -> bb119;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing expected parameter: `uri`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: data"];
        _0 = &_1;
        return;
    }
}

promoted[2] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: format"];
        _0 = &_1;
        return;
    }
}

promoted[3] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "duplicate attribute parameter: rank"];
        _0 = &_1;
        return;
    }
}

promoted[4] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unexpected attribute parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[5] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "rank";
        _0 = &_1;
        return;
    }
}

promoted[6] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "format";
        _0 = &_1;
        return;
    }
}

promoted[7] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "data";
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:55:5: 55:6}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `uri`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#1}(_1: {closure@core/codegen/src/attribute/route/parse.rs:57:5: 57:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `data`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#2}(_1: {closure@core/codegen/src/attribute/route/parse.rs:58:5: 58:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#2}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `format`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#3}(_1: {closure@core/codegen/src/attribute/route/parse.rs:59:5: 59:8}) -> devise::Diagnostic {
    debug __span => (*(_1.0: &proc_macro2::Span));
    let mut _0: devise::Diagnostic;
    let mut _2: proc_macro2::Span;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 0];
    let _8: [core::fmt::rt::Argument<'_>; 0];
    let mut _9: &[&str; 1];
    let mut _10: &proc_macro2::Span;
    scope 1 {
        debug res => _3;
    }

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro2::Span);
        _2 = (*_10);
        _9 = const _;
        _5 = _9 as &[&str] (PointerCoercion(Unsize));
        _8 = core::fmt::rt::Argument::<'_>::none() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = std::fmt::Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = format(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in route::parse::_::<impl at core/codegen/src/attribute/route/parse.rs:53:17: 53:25>::from_meta::{closure#3}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "missing required attribute parameter: `rank`"];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:62:10: 62:15>::fmt(_1: &RouteUri, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &rocket_http::uri::Origin<'_>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &proc_macro2::Span;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&std::option::Option<proc_macro2::Span>;
    let _13: &std::option::Option<proc_macro2::Span>;

    bb0: {
        _3 = const "RouteUri";
        _4 = const "origin";
        _6 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "path_span";
        _9 = &((*_1).1: proc_macro2::Span);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "query_span";
        _13 = &((*_1).2: std::option::Option<proc_macro2::Span>);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta(_1: &devise::MetaItem) -> std::result::Result<RouteUri, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<attribute::route::parse::RouteUri, devise::Diagnostic>;
    let _2: proc_macro_ext::StringLit;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, proc_macro_ext::StringLit>;
    let mut _4: std::result::Result<proc_macro_ext::StringLit, devise::Diagnostic>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _7: proc_macro_ext::StringLit;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, rocket_http::uri::Origin<'_>>;
    let mut _10: std::result::Result<rocket_http::uri::Origin<'_>, devise::Diagnostic>;
    let mut _11: std::result::Result<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>;
    let _12: &str;
    let _13: &proc_macro_ext::StringLit;
    let mut _14: {closure@core/codegen/src/attribute/route/parse.rs:74:22: 74:25};
    let mut _15: &proc_macro_ext::StringLit;
    let mut _16: isize;
    let mut _19: bool;
    let mut _20: &rocket_http::uri::Origin<'_>;
    let mut _22: rocket_http::uri::Origin<'_>;
    let mut _23: &rocket_http::uri::Origin<'_>;
    let mut _25: std::option::Option<proc_macro2::Span>;
    let mut _26: std::option::Option<usize>;
    let mut _27: std::option::Option<usize>;
    let _28: &rocket_http::RawStr;
    let mut _29: &rocket_http::uri::Path<'_>;
    let _30: rocket_http::uri::Path<'_>;
    let mut _31: &rocket_http::uri::Origin<'_>;
    let mut _32: {closure@core/codegen/src/attribute/route/parse.rs:83:26: 83:28};
    let mut _33: &rocket_http::uri::Origin<'_>;
    let mut _34: {closure@core/codegen/src/attribute/route/parse.rs:86:22: 86:25};
    let mut _35: &proc_macro_ext::StringLit;
    let mut _36: proc_macro2::Span;
    let mut _37: &proc_macro_ext::StringLit;
    let mut _38: devise::Diagnostic;
    let mut _39: devise::Diagnostic;
    let mut _41: std::fmt::Arguments<'_>;
    let mut _42: &[&str];
    let mut _43: &[core::fmt::rt::Argument<'_>];
    let _44: &[core::fmt::rt::Argument<'_>; 2];
    let _45: [core::fmt::rt::Argument<'_>; 2];
    let mut _46: core::fmt::rt::Argument<'_>;
    let _47: &rocket_http::uri::Origin<'_>;
    let mut _48: core::fmt::rt::Argument<'_>;
    let _49: &rocket_http::uri::Origin<'_>;
    let mut _51: &proc_macro_ext::StringLit;
    let mut _52: std::ops::Range<usize>;
    let mut _53: usize;
    let mut _54: usize;
    let _55: &rocket_http::RawStr;
    let mut _56: &rocket_http::uri::Path<'_>;
    let _57: rocket_http::uri::Path<'_>;
    let mut _58: &rocket_http::uri::Origin<'_>;
    let mut _59: (usize, bool);
    let mut _61: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _62: &rocket_http::uri::Origin<'_>;
    let mut _63: {closure@core/codegen/src/attribute/route/parse.rs:94:45: 94:48};
    let mut _64: &rocket_http::uri::Origin<'_>;
    let mut _65: &proc_macro_ext::StringLit;
    let mut _66: attribute::route::parse::RouteUri;
    let mut _67: rocket_http::uri::Origin<'_>;
    let mut _68: rocket_http::uri::Origin<'_>;
    let mut _70: bool;
    let mut _71: bool;
    scope 1 {
        debug string => _2;
        let _8: rocket_http::uri::Origin<'_>;
        let _17: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _18: rocket_http::uri::Origin<'_>;
        scope 6 {
            debug origin => _8;
            let _21: rocket_http::uri::Origin<'_>;
            let _50: proc_macro2::Span;
            scope 11 {
                debug normalized => _21;
                let _24: proc_macro2::Span;
                scope 12 {
                    debug span => _24;
                    let _40: std::string::String;
                    let mut _69: &[&str; 3];
                    scope 13 {
                        debug res => _40;
                    }
                }
            }
            scope 14 {
                debug path_span => _50;
                let _60: std::option::Option<proc_macro2::Span>;
                scope 15 {
                    debug query_span => _60;
                }
            }
        }
        scope 7 {
            debug residual => _17;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _18;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _71 = const false;
        _70 = const false;
        _4 = <StringLit as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<StringLit, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: proc_macro_ext::StringLit);
        _2 = move _7;
        _13 = &_2;
        _12 = <StringLit as std::ops::Deref>::deref(_13) -> [return: bb6, unwind: bb42];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<RouteUri, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _6) -> [return: bb40, unwind continue];
    }

    bb6: {
        _11 = rocket_http::uri::Origin::<'_>::parse_route(_12) -> [return: bb7, unwind: bb42];
    }

    bb7: {
        _15 = &_2;
        _14 = {closure@core/codegen/src/attribute/route/parse.rs:74:22: 74:25} { string: move _15 };
        _10 = std::result::Result::<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/parse.rs:74:22: 74:25}>(move _11, move _14) -> [return: bb8, unwind: bb42];
    }

    bb8: {
        _9 = <std::result::Result<rocket_http::uri::Origin<'_>, devise::Diagnostic> as std::ops::Try>::branch(move _10) -> [return: bb9, unwind: bb42];
    }

    bb9: {
        _16 = discriminant(_9);
        switchInt(move _16) -> [0: bb10, 1: bb11, otherwise: bb4];
    }

    bb10: {
        _18 = move ((_9 as Continue).0: rocket_http::uri::Origin<'_>);
        _71 = const true;
        _8 = move _18;
        _20 = &_8;
        _19 = rocket_http::uri::Origin::<'_>::is_normalized(move _20) -> [return: bb12, unwind: bb47];
    }

    bb11: {
        _17 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<RouteUri, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _17) -> [return: bb48, unwind: bb42];
    }

    bb12: {
        switchInt(move _19) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _51 = &_2;
        _58 = &_8;
        _57 = rocket_http::uri::Origin::<'_>::path(move _58) -> [return: bb30, unwind: bb47];
    }

    bb14: {
        _23 = &_8;
        _22 = <rocket_http::uri::Origin<'_> as Clone>::clone(move _23) -> [return: bb15, unwind: bb47];
    }

    bb15: {
        _21 = rocket_http::uri::Origin::<'_>::into_normalized(move _22) -> [return: bb16, unwind: bb47];
    }

    bb16: {
        _31 = &_8;
        _30 = rocket_http::uri::Origin::<'_>::path(move _31) -> [return: bb17, unwind: bb41];
    }

    bb17: {
        _29 = &_30;
        _28 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _29) -> [return: bb18, unwind: bb41];
    }

    bb18: {
        _27 = RawStr::find::<'_, &str>(_28, const "//") -> [return: bb19, unwind: bb41];
    }

    bb19: {
        _33 = &_8;
        _32 = {closure@core/codegen/src/attribute/route/parse.rs:83:26: 83:28} { origin: move _33 };
        _26 = Option::<usize>::or_else::<{closure@core/codegen/src/attribute/route/parse.rs:83:26: 83:28}>(move _27, move _32) -> [return: bb20, unwind: bb41];
    }

    bb20: {
        _35 = &_2;
        _34 = {closure@core/codegen/src/attribute/route/parse.rs:86:22: 86:25} { string: move _35 };
        _25 = Option::<usize>::map::<proc_macro2::Span, {closure@core/codegen/src/attribute/route/parse.rs:86:22: 86:25}>(move _26, move _34) -> [return: bb21, unwind: bb41];
    }

    bb21: {
        _37 = &_2;
        _36 = StringLit::span(move _37) -> [return: bb22, unwind: bb41];
    }

    bb22: {
        _24 = Option::<proc_macro2::Span>::unwrap_or(move _25, move _36) -> [return: bb23, unwind: bb41];
    }

    bb23: {
        _39 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_24, const "route URIs cannot contain empty segments") -> [return: bb24, unwind: bb41];
    }

    bb24: {
        _70 = const true;
        _69 = const _;
        _42 = _69 as &[&str] (PointerCoercion(Unsize));
        _47 = &_21;
        _46 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Origin<'_>>(_47) -> [return: bb25, unwind: bb45];
    }

    bb25: {
        _49 = &_8;
        _48 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Origin<'_>>(_49) -> [return: bb26, unwind: bb45];
    }

    bb26: {
        _45 = [move _46, move _48];
        _44 = &_45;
        _43 = _44 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _41 = std::fmt::Arguments::<'_>::new_v1(move _42, move _43) -> [return: bb27, unwind: bb45];
    }

    bb27: {
        _40 = format(move _41) -> [return: bb28, unwind: bb45];
    }

    bb28: {
        _70 = const false;
        _38 = devise::Diagnostic::note::<std::string::String>(move _39, move _40) -> [return: bb29, unwind: bb45];
    }

    bb29: {
        _70 = const false;
        _0 = std::result::Result::<RouteUri, devise::Diagnostic>::Err(move _38);
        drop(_21) -> [return: bb38, unwind: bb47];
    }

    bb30: {
        _56 = &_57;
        _55 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _56) -> [return: bb31, unwind: bb47];
    }

    bb31: {
        _54 = RawStr::len(_55) -> [return: bb32, unwind: bb47];
    }

    bb32: {
        _59 = CheckedAdd(_54, const 1_usize);
        assert(!move (_59.1: bool), "attempt to compute `{} + {}`, which would overflow", move _54, const 1_usize) -> [success: bb33, unwind: bb47];
    }

    bb33: {
        _53 = move (_59.0: usize);
        _52 = std::ops::Range::<usize> { start: const 1_usize, end: move _53 };
        _50 = StringLit::subspan::<std::ops::Range<usize>>(move _51, move _52) -> [return: bb34, unwind: bb47];
    }

    bb34: {
        _62 = &_8;
        _61 = rocket_http::uri::Origin::<'_>::query(move _62) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _64 = &_8;
        _65 = &_2;
        _63 = {closure@core/codegen/src/attribute/route/parse.rs:94:45: 94:48} { origin: move _64, string: move _65 };
        _60 = Option::<rocket_http::uri::Query<'_>>::map::<proc_macro2::Span, {closure@core/codegen/src/attribute/route/parse.rs:94:45: 94:48}>(move _61, move _63) -> [return: bb36, unwind: bb47];
    }

    bb36: {
        _71 = const false;
        _68 = move _8;
        _67 = <rocket_http::uri::Origin<'_> as IntoOwned>::into_owned(move _68) -> [return: bb37, unwind: bb47];
    }

    bb37: {
        _66 = RouteUri { origin: move _67, path_span: _50, query_span: _60 };
        _0 = std::result::Result::<RouteUri, devise::Diagnostic>::Ok(move _66);
        _71 = const false;
        drop(_2) -> [return: bb40, unwind continue];
    }

    bb38: {
        drop(_8) -> [return: bb39, unwind: bb42];
    }

    bb39: {
        _71 = const false;
        drop(_2) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_21) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_2) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        resume;
    }

    bb44 (cleanup): {
        drop(_39) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_70) -> [0: bb41, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_8) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_71) -> [0: bb42, otherwise: bb46];
    }

    bb48: {
        goto -> bb39;
    }
}

promoted[0] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "expected \"", const "\", found \"", const "\""];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:74:22: 74:25}, _2: rocket_http::uri::Error<'_>) -> devise::Diagnostic {
    debug e => _2;
    debug string => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: devise::Diagnostic;
    let _3: proc_macro2::Span;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: &rocket_http::uri::Error<'_>;
    let mut _8: (usize, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &rocket_http::uri::Error<'_>;
    let mut _12: (usize, bool);
    let mut _13: devise::Diagnostic;
    let mut _15: std::fmt::Arguments<'_>;
    let mut _16: &[&str];
    let mut _17: &[core::fmt::rt::Argument<'_>];
    let _18: &[core::fmt::rt::Argument<'_>; 1];
    let _19: [core::fmt::rt::Argument<'_>; 1];
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &rocket_http::uri::Error<'_>;
    let mut _23: &proc_macro_ext::StringLit;
    scope 1 {
        debug span => _3;
        let _14: std::string::String;
        let mut _22: &[&str; 1];
        scope 2 {
            debug res => _14;
        }
    }

    bb0: {
        _23 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _7 = &_2;
        _6 = rocket_http::uri::Error::<'_>::index(move _7) -> [return: bb1, unwind: bb12];
    }

    bb1: {
        _8 = CheckedAdd(_6, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, const 1_usize) -> [success: bb2, unwind: bb12];
    }

    bb2: {
        _5 = move (_8.0: usize);
        _11 = &_2;
        _10 = rocket_http::uri::Error::<'_>::index(move _11) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _12 = CheckedAdd(_10, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _10, const 2_usize) -> [success: bb4, unwind: bb12];
    }

    bb4: {
        _9 = move (_12.0: usize);
        _4 = std::ops::Range::<usize> { start: move _5, end: move _9 };
        _3 = StringLit::subspan::<std::ops::Range<usize>>(_23, move _4) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _22 = const _;
        _16 = _22 as &[&str] (PointerCoercion(Unsize));
        _21 = &_2;
        _20 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Error<'_>>(_21) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _19 = [move _20];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _15 = std::fmt::Arguments::<'_>::new_v1(move _16, move _17) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _14 = format(move _15) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _13 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(_3, move _14) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _0 = devise::Diagnostic::help::<&str>(move _13, const "expected URI in origin form: \"/path/<param>\"") -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_2) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_2) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

promoted[0] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "invalid route URI: "];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#1}(_1: {closure@core/codegen/src/attribute/route/parse.rs:83:26: 83:28}) -> Option<usize> {
    debug origin => (*(_1.0: &rocket_http::uri::Origin<'_>));
    let mut _0: std::option::Option<usize>;
    let mut _2: std::option::Option<usize>;
    let mut _3: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _4: {closure@core/codegen/src/attribute/route/parse.rs:85:26: 85:29};
    let mut _5: &rocket_http::uri::Origin<'_>;
    let mut _6: &rocket_http::uri::Origin<'_>;

    bb0: {
        _5 = deref_copy (_1.0: &rocket_http::uri::Origin<'_>);
        _3 = rocket_http::uri::Origin::<'_>::query(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<rocket_http::uri::Query<'_>>::and_then::<usize, {closure@core/codegen/src/attribute/route/parse.rs:84:31: 84:34}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:84:31: 84:34}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = deref_copy (_1.0: &rocket_http::uri::Origin<'_>);
        _4 = {closure@core/codegen/src/attribute/route/parse.rs:85:26: 85:29} { origin: _6 };
        _0 = Option::<usize>::map::<usize, {closure@core/codegen/src/attribute/route/parse.rs:85:26: 85:29}>(move _2, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#1}::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:84:31: 84:34}, _2: rocket_http::uri::Query<'_>) -> Option<usize> {
    debug q => _2;
    let mut _0: std::option::Option<usize>;
    let _3: &rocket_http::RawStr;
    let mut _4: &rocket_http::uri::Query<'_>;

    bb0: {
        _4 = &_2;
        _3 = <rocket_http::uri::Query<'_> as std::ops::Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = RawStr::find::<'_, &str>(_3, const "&&") -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#1}::{closure#1}(_1: {closure@core/codegen/src/attribute/route/parse.rs:85:26: 85:29}, _2: usize) -> usize {
    debug i => _2;
    debug origin => (*(_1.0: &rocket_http::uri::Origin<'_>));
    let mut _0: usize;
    let mut _3: usize;
    let mut _4: usize;
    let _5: &rocket_http::RawStr;
    let mut _6: &rocket_http::uri::Path<'_>;
    let _7: rocket_http::uri::Path<'_>;
    let mut _8: (usize, bool);
    let mut _9: (usize, bool);
    let mut _10: &rocket_http::uri::Origin<'_>;

    bb0: {
        _10 = deref_copy (_1.0: &rocket_http::uri::Origin<'_>);
        _7 = rocket_http::uri::Origin::<'_>::path(_10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_7;
        _5 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RawStr::len(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = CheckedAdd(_4, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 1_usize) -> [success: bb4, unwind continue];
    }

    bb4: {
        _3 = move (_8.0: usize);
        _9 = CheckedAdd(_3, _2);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, _2) -> [success: bb5, unwind continue];
    }

    bb5: {
        _0 = move (_9.0: usize);
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#2}(_1: {closure@core/codegen/src/attribute/route/parse.rs:86:22: 86:25}, _2: usize) -> proc_macro2::Span {
    debug i => _2;
    debug string => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: proc_macro2::Span;
    let mut _3: std::ops::Range<usize>;
    let mut _4: usize;
    let mut _5: (usize, bool);
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: (usize, bool);
    let mut _9: (usize, bool);
    let mut _10: &proc_macro_ext::StringLit;

    bb0: {
        _10 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _5 = CheckedAdd(const 1_usize, _2);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, _2) -> [success: bb1, unwind continue];
    }

    bb1: {
        _4 = move (_5.0: usize);
        _8 = CheckedAdd(const 1_usize, _2);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, _2) -> [success: bb2, unwind continue];
    }

    bb2: {
        _7 = move (_8.0: usize);
        _9 = CheckedAdd(_7, const 2_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _7, const 2_usize) -> [success: bb3, unwind continue];
    }

    bb3: {
        _6 = move (_9.0: usize);
        _3 = std::ops::Range::<usize> { start: move _4, end: move _6 };
        _0 = StringLit::subspan::<std::ops::Range<usize>>(_10, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:69:1: 69:27>::from_meta::{closure#3}(_1: {closure@core/codegen/src/attribute/route/parse.rs:94:45: 94:48}, _2: rocket_http::uri::Query<'_>) -> proc_macro2::Span {
    debug q => _2;
    debug origin => (*(_1.0: &rocket_http::uri::Origin<'_>));
    debug string => (*(_1.1: &proc_macro_ext::StringLit));
    let mut _0: proc_macro2::Span;
    let _3: usize;
    let mut _4: usize;
    let mut _5: usize;
    let _6: &rocket_http::RawStr;
    let mut _7: &rocket_http::uri::Path<'_>;
    let _8: rocket_http::uri::Path<'_>;
    let mut _9: (usize, bool);
    let mut _10: (usize, bool);
    let mut _12: usize;
    let _13: &rocket_http::RawStr;
    let mut _14: &rocket_http::uri::Query<'_>;
    let mut _15: (usize, bool);
    let mut _16: std::ops::Range<usize>;
    let mut _17: &rocket_http::uri::Origin<'_>;
    let mut _18: &proc_macro_ext::StringLit;
    scope 1 {
        debug len_to_q => _3;
        let _11: usize;
        scope 2 {
            debug end_of_q => _11;
        }
    }

    bb0: {
        _17 = deref_copy (_1.0: &rocket_http::uri::Origin<'_>);
        _8 = rocket_http::uri::Origin::<'_>::path(_17) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RawStr::len(_6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = CheckedAdd(const 1_usize, _5);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, move _5) -> [success: bb4, unwind continue];
    }

    bb4: {
        _4 = move (_9.0: usize);
        _10 = CheckedAdd(_4, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 1_usize) -> [success: bb5, unwind continue];
    }

    bb5: {
        _3 = move (_10.0: usize);
        _14 = &_2;
        _13 = <rocket_http::uri::Query<'_> as std::ops::Deref>::deref(move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = RawStr::len(_13) -> [return: bb7, unwind continue];
    }

    bb7: {
        _15 = CheckedAdd(_3, _12);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, move _12) -> [success: bb8, unwind continue];
    }

    bb8: {
        _11 = move (_15.0: usize);
        _18 = deref_copy (_1.1: &proc_macro_ext::StringLit);
        _16 = std::ops::Range::<usize> { start: _3, end: _11 };
        _0 = StringLit::subspan::<std::ops::Range<usize>>(_18, move _16) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::upgrade_param(_1: Parameter, _2: &route::parse::Arguments) -> std::result::Result<Parameter, devise::Diagnostic> {
    debug param => _1;
    debug args => _2;
    let mut _0: std::result::Result<attribute::param::Parameter, devise::Diagnostic>;
    let mut _3: bool;
    let mut _4: &std::option::Option<&attribute::param::Dynamic>;
    let _5: std::option::Option<&attribute::param::Dynamic>;
    let mut _6: &attribute::param::Parameter;
    let mut _7: attribute::param::Parameter;
    let _8: attribute::param::Dynamic;
    let mut _9: std::option::Option<attribute::param::Dynamic>;
    let mut _10: attribute::param::Parameter;
    let _11: &str;
    let mut _12: std::result::Result<attribute::param::Guard, devise::Diagnostic>;
    let mut _13: bool;
    scope 1 {
        debug param => _8;
    }

    bb0: {
        _13 = const false;
        _13 = const true;
        _6 = &_1;
        _5 = Parameter::dynamic(move _6) -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _4 = &_5;
        _3 = Option::<&param::Dynamic>::is_some(move _4) -> [return: bb2, unwind: bb11];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _13 = const false;
        _10 = move _1;
        _9 = Parameter::take_dynamic(move _10) -> [return: bb5, unwind: bb11];
    }

    bb4: {
        _13 = const false;
        _7 = move _1;
        _0 = std::result::Result::<Parameter, devise::Diagnostic>::Ok(move _7);
        goto -> bb8;
    }

    bb5: {
        _11 = const "dynamic() => take_dynamic()";
        _8 = Option::<param::Dynamic>::expect(move _9, _11) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _12 = route::parse::Route::upgrade_dynamic(move _8, _2) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _0 = std::result::Result::<Guard, devise::Diagnostic>::map::<Parameter, fn(Guard) -> Parameter {Parameter::Guard}>(move _12, Parameter::Guard) -> [return: bb12, unwind: bb11];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_1) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        switchInt(_13) -> [0: bb9, otherwise: bb10];
    }

    bb12: {
        goto -> bb8;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::upgrade_dynamic(_1: param::Dynamic, _2: &route::parse::Arguments) -> std::result::Result<Guard, devise::Diagnostic> {
    debug param => _1;
    debug args => _2;
    let mut _0: std::result::Result<attribute::param::Guard, devise::Diagnostic>;
    let mut _3: std::option::Option<&(proc_macro2::Ident, syn::Type)>;
    let mut _4: &indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let _5: &name::Name;
    let mut _6: isize;
    let mut _9: attribute::param::Guard;
    let mut _10: attribute::param::Dynamic;
    let mut _11: proc_macro2::Ident;
    let mut _12: syn::Type;
    let _13: std::string::String;
    let _14: std::string::String;
    let mut _15: std::fmt::Arguments<'_>;
    let mut _16: &[&str];
    let mut _17: &[core::fmt::rt::Argument<'_>];
    let _18: &[core::fmt::rt::Argument<'_>; 1];
    let _19: [core::fmt::rt::Argument<'_>; 1];
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &name::Name;
    let mut _23: devise::Diagnostic;
    let mut _24: proc_macro2::Span;
    let _25: &name::Name;
    let mut _26: &attribute::param::Dynamic;
    let mut _27: proc_macro2::Span;
    let mut _28: std::string::String;
    let mut _29: &[&str; 2];
    let mut _30: &(proc_macro2::Ident, syn::Type);
    let mut _31: &(proc_macro2::Ident, syn::Type);
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    scope 1 {
        debug ident => _7;
        debug ty => _8;
        let _7: &proc_macro2::Ident;
        let _8: &syn::Type;
    }
    scope 2 {
        debug msg => _13;
        let _22: devise::Diagnostic;
        scope 4 {
            debug diag => _22;
        }
    }
    scope 3 {
        debug res => _14;
    }

    bb0: {
        _32 = const false;
        _35 = const false;
        _34 = const false;
        _33 = const false;
        _32 = const true;
        _4 = &((*_2).1: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>);
        _5 = &(_1.0: name::Name);
        _3 = IndexMap::<name::Name, (proc_macro2::Ident, syn::Type)>::get::<name::Name>(move _4, _5) -> [return: bb1, unwind: bb25];
    }

    bb1: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [1: bb2, otherwise: bb6];
    }

    bb2: {
        _30 = deref_copy ((_3 as Some).0: &(proc_macro2::Ident, syn::Type));
        _7 = &((*_30).0: proc_macro2::Ident);
        _31 = deref_copy ((_3 as Some).0: &(proc_macro2::Ident, syn::Type));
        _8 = &((*_31).1: syn::Type);
        _32 = const false;
        _35 = const true;
        _10 = move _1;
        _11 = <proc_macro2::Ident as Clone>::clone(_7) -> [return: bb3, unwind: bb23];
    }

    bb3: {
        _34 = const true;
        _12 = <syn::Type as Clone>::clone(_8) -> [return: bb4, unwind: bb21];
    }

    bb4: {
        _35 = const false;
        _34 = const false;
        _9 = Guard::from(move _10, move _11, move _12) -> [return: bb5, unwind: bb21];
    }

    bb5: {
        _34 = const false;
        _35 = const false;
        _0 = std::result::Result::<Guard, devise::Diagnostic>::Ok(move _9);
        goto -> bb14;
    }

    bb6: {
        _29 = const _;
        _16 = _29 as &[&str] (PointerCoercion(Unsize));
        _21 = &(_1.0: name::Name);
        _20 = core::fmt::rt::Argument::<'_>::new_display::<name::Name>(_21) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _19 = [move _20];
        _18 = &_19;
        _17 = _18 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _15 = std::fmt::Arguments::<'_>::new_v1(move _16, move _17) -> [return: bb8, unwind: bb25];
    }

    bb8: {
        _14 = format(move _15) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _33 = const true;
        _13 = move _14;
        _26 = &_1;
        _25 = <param::Dynamic as std::ops::Deref>::deref(move _26) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _24 = name::Name::span(_25) -> [return: bb11, unwind: bb19];
    }

    bb11: {
        _23 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _24, const "unused parameter") -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _27 = ((*_2).0: proc_macro2::Span);
        _33 = const false;
        _28 = move _13;
        _22 = devise::Diagnostic::span_note::<proc_macro2::Span, std::string::String>(move _23, move _27, move _28) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _0 = std::result::Result::<Guard, devise::Diagnostic>::Err(move _22);
        _33 = const false;
        goto -> bb14;
    }

    bb14: {
        switchInt(_32) -> [0: bb15, otherwise: bb17];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        resume;
    }

    bb17: {
        drop(_1) -> [return: bb15, unwind continue];
    }

    bb18 (cleanup): {
        drop(_13) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_33) -> [0: bb25, otherwise: bb18];
    }

    bb20 (cleanup): {
        drop(_11) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        switchInt(_34) -> [0: bb23, otherwise: bb20];
    }

    bb22 (cleanup): {
        drop(_10) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_35) -> [0: bb25, otherwise: bb22];
    }

    bb24 (cleanup): {
        drop(_1) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        switchInt(_32) -> [0: bb16, otherwise: bb24];
    }
}

promoted[0] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::upgrade_dynamic: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "expected argument named `", const "` here"];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from(_1: route::parse::Attribute, _2: ItemFn) -> std::result::Result<route::parse::Route, devise::Diagnostic> {
    debug attr => _1;
    debug handler => _2;
    let mut _0: std::result::Result<attribute::route::parse::Route, devise::Diagnostic>;
    let mut _3: proc_macro_ext::Diagnostics;
    let mut _4: isize;
    let mut _6: bool;
    let mut _7: rocket_http::Method;
    let mut _8: &http_codegen::Method;
    let mut _9: &devise::SpanWrapped<http_codegen::Method>;
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &rocket_http::Method;
    let _19: &http_codegen::Method;
    let mut _20: &devise::SpanWrapped<http_codegen::Method>;
    let _21: proc_macro2::TokenStream;
    let mut _22: devise::Diagnostic;
    let mut _23: devise::Diagnostic;
    let mut _24: proc_macro2::Span;
    let mut _25: proc_macro2::Span;
    let mut _26: std::string::String;
    let mut _29: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _30: syn::punctuated::Iter<'_, syn::FnArg>;
    let mut _31: &syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>;
    let mut _33: std::option::Option<&syn::FnArg>;
    let mut _34: &mut syn::punctuated::Iter<'_, syn::FnArg>;
    let mut _35: isize;
    let mut _37: std::option::Option<(&proc_macro2::Ident, &syn::Type)>;
    let mut _38: isize;
    let mut _42: proc_macro2::Ident;
    let mut _43: syn::Type;
    let _44: std::option::Option<(proc_macro2::Ident, syn::Type)>;
    let mut _45: &mut indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _46: name::Name;
    let mut _47: (proc_macro2::Ident, syn::Type);
    let mut _50: bool;
    let mut _51: &std::option::Option<&syn::PatWild>;
    let _52: std::option::Option<&syn::PatWild>;
    let mut _53: devise::Diagnostic;
    let _54: ();
    let mut _55: &mut proc_macro_ext::Diagnostics;
    let mut _56: devise::Diagnostic;
    let mut _59: (rocket_http::uri::Path<'_>, proc_macro2::Span);
    let mut _60: rocket_http::uri::Path<'_>;
    let _61: &rocket_http::uri::Origin<'_>;
    let mut _62: &attribute::route::parse::RouteUri;
    let mut _63: proc_macro2::Span;
    let mut _65: std::iter::FilterMap<std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}>, {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28}>;
    let mut _66: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}>;
    let mut _67: std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>;
    let _68: &str;
    let mut _69: &rocket_http::uri::Path<'_>;
    let mut _70: {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21};
    let mut _71: &attribute::route::parse::Arguments;
    let mut _72: {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28};
    let mut _73: &mut proc_macro_ext::Diagnostics;
    let mut _75: (std::option::Option<rocket_http::uri::Query<'_>>, std::option::Option<proc_macro2::Span>);
    let mut _76: std::option::Option<rocket_http::uri::Query<'_>>;
    let _77: &rocket_http::uri::Origin<'_>;
    let mut _78: &attribute::route::parse::RouteUri;
    let mut _79: std::option::Option<proc_macro2::Span>;
    let mut _80: isize;
    let mut _81: isize;
    let mut _84: std::iter::FilterMap<std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}>, {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32}>;
    let mut _85: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}>;
    let mut _86: std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>;
    let _87: &str;
    let mut _88: &rocket_http::uri::Query<'_>;
    let mut _89: {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25};
    let mut _90: &attribute::route::parse::Arguments;
    let mut _91: {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32};
    let mut _92: &mut proc_macro_ext::Diagnostics;
    let mut _94: std::option::Option<std::result::Result<attribute::param::Guard, devise::Diagnostic>>;
    let mut _95: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let mut _96: &std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let mut _97: {closure@core/codegen/src/attribute/route/parse.rs:177:18: 177:21};
    let mut _98: &attribute::route::parse::Arguments;
    let mut _99: {closure@core/codegen/src/attribute/route/parse.rs:178:23: 178:26};
    let mut _100: &mut proc_macro_ext::Diagnostics;
    let mut _102: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>;
    let mut _103: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>;
    let mut _104: std::slice::Iter<'_, attribute::param::Parameter>;
    let _105: &[attribute::param::Parameter];
    let mut _106: &std::vec::Vec<attribute::param::Parameter>;
    let mut _107: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>;
    let mut _108: std::slice::Iter<'_, attribute::param::Parameter>;
    let _109: &[attribute::param::Parameter];
    let mut _110: &std::vec::Vec<attribute::param::Parameter>;
    let mut _111: std::option::IntoIter<&attribute::param::Dynamic>;
    let mut _112: std::option::Option<&attribute::param::Dynamic>;
    let mut _113: std::option::Option<&attribute::param::Guard>;
    let mut _114: &std::option::Option<attribute::param::Guard>;
    let mut _116: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&attribute::param::Dynamic>>;
    let _118: ();
    let mut _119: std::option::Option<&attribute::param::Dynamic>;
    let mut _120: &mut std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&attribute::param::Dynamic>>;
    let mut _121: isize;
    let mut _123: std::option::Option<&attribute::param::Dynamic>;
    let mut _124: &mut indexmap::IndexSet<&attribute::param::Dynamic>;
    let mut _125: isize;
    let mut _127: &mut proc_macro_ext::Diagnostics;
    let mut _128: devise::Diagnostic;
    let mut _129: devise::Diagnostic;
    let mut _130: proc_macro2::Span;
    let _131: &name::Name;
    let mut _133: std::fmt::Arguments<'_>;
    let mut _134: &[&str];
    let mut _135: &[core::fmt::rt::Argument<'_>];
    let _136: &[core::fmt::rt::Argument<'_>; 1];
    let _137: [core::fmt::rt::Argument<'_>; 1];
    let mut _138: core::fmt::rt::Argument<'_>;
    let _139: &name::Name;
    let mut _140: proc_macro2::Span;
    let _141: &name::Name;
    let mut _143: std::iter::Map<std::iter::Enumerate<std::iter::Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>>, {closure@core/codegen/src/attribute/route/parse.rs:204:18: 204:48}>;
    let mut _144: std::iter::Enumerate<std::iter::Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>>;
    let mut _145: std::iter::Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>;
    let mut _146: indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _147: &indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _148: {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32};
    let mut _149: &std::vec::Vec<attribute::param::Parameter>;
    let mut _150: &std::vec::Vec<attribute::param::Parameter>;
    let mut _151: &std::option::Option<attribute::param::Guard>;
    let mut _152: proc_macro_ext::Diagnostics;
    let mut _153: attribute::route::parse::Route;
    let mut _154: attribute::route::parse::Attribute;
    let mut _155: std::vec::Vec<attribute::param::Parameter>;
    let mut _156: std::vec::Vec<attribute::param::Parameter>;
    let mut _157: std::option::Option<attribute::param::Guard>;
    let mut _158: syn::ItemFn;
    let mut _159: attribute::route::parse::Arguments;
    let mut _162: bool;
    let mut _163: bool;
    let mut _164: bool;
    let mut _165: bool;
    let mut _166: bool;
    let mut _167: bool;
    let mut _168: bool;
    let mut _169: bool;
    let mut _170: bool;
    let mut _171: bool;
    scope 1 {
        debug diags => _3;
        let _27: proc_macro2::Span;
        scope 2 {
            debug data => _5;
            let _5: &devise::SpanWrapped<attribute::param::Dynamic>;
            let _10: std::string::String;
            let _11: std::string::String;
            let mut _161: &[&str; 2];
            scope 3 {
                debug msg => _10;
            }
            scope 4 {
                debug res => _11;
            }
        }
        scope 5 {
            debug span => _27;
            let mut _28: attribute::route::parse::Arguments;
            scope 6 {
                debug arguments => _28;
                let mut _32: syn::punctuated::Iter<'_, syn::FnArg>;
                let _57: rocket_http::uri::Path<'_>;
                let _58: proc_macro2::Span;
                scope 7 {
                    debug iter => _32;
                    let _36: &syn::FnArg;
                    scope 8 {
                        debug arg => _36;
                        let _48: proc_macro2::Span;
                        scope 9 {
                            debug ident => _39;
                            debug ty => _40;
                            let _39: &proc_macro2::Ident;
                            let _40: &syn::Type;
                            let _41: (proc_macro2::Ident, syn::Type);
                            scope 10 {
                                debug value => _41;
                            }
                        }
                        scope 11 {
                            debug span => _48;
                            let _49: devise::Diagnostic;
                            scope 12 {
                                debug diag => _49;
                            }
                        }
                    }
                }
                scope 13 {
                    debug source => _57;
                    debug span => _58;
                    let _64: std::vec::Vec<attribute::param::Parameter>;
                    scope 14 {
                        debug path_params => _64;
                        let _74: std::vec::Vec<attribute::param::Parameter>;
                        let _82: rocket_http::uri::Query<'_>;
                        let _83: proc_macro2::Span;
                        scope 15 {
                            debug query_params => _74;
                            let _93: std::option::Option<attribute::param::Guard>;
                            scope 17 {
                                debug data_guard => _93;
                                let _101: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&attribute::param::Dynamic>>;
                                scope 18 {
                                    debug all_dyn_params => _101;
                                    let mut _115: indexmap::IndexSet<&attribute::param::Dynamic>;
                                    scope 19 {
                                        debug dyn_params => _115;
                                        let mut _117: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&attribute::param::Dynamic>>;
                                        let _142: std::vec::Vec<attribute::param::Guard>;
                                        scope 20 {
                                            debug iter => _117;
                                            let _122: &attribute::param::Dynamic;
                                            scope 21 {
                                                debug p => _122;
                                                scope 22 {
                                                    debug prev => _126;
                                                    let _126: &attribute::param::Dynamic;
                                                    let _132: std::string::String;
                                                    let mut _160: &[&str; 2];
                                                    scope 23 {
                                                        debug res => _132;
                                                    }
                                                }
                                            }
                                        }
                                        scope 24 {
                                            debug request_guards => _142;
                                        }
                                    }
                                }
                            }
                        }
                        scope 16 {
                            debug q => _82;
                            debug span => _83;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _171 = const false;
        _170 = const false;
        _169 = const false;
        _168 = const false;
        _167 = const false;
        _166 = const false;
        _165 = const false;
        _164 = const false;
        _163 = const false;
        _162 = const false;
        _171 = const true;
        _170 = const true;
        _3 = Diagnostics::new() -> [return: bb1, unwind: bb117];
    }

    bb1: {
        _169 = const true;
        _4 = discriminant((_1.2: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>));
        switchInt(move _4) -> [1: bb2, otherwise: bb14];
    }

    bb2: {
        _5 = &(((_1.2: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>) as Some).0: devise::SpanWrapped<attribute::param::Dynamic>);
        _9 = &(_1.0: devise::SpanWrapped<http_codegen::Method>);
        _8 = <devise::SpanWrapped<http_codegen::Method> as std::ops::Deref>::deref(move _9) -> [return: bb3, unwind: bb115];
    }

    bb3: {
        _7 = ((*_8).0: rocket_http::Method);
        _6 = rocket_http::Method::supports_payload(move _7) -> [return: bb4, unwind: bb115];
    }

    bb4: {
        switchInt(move _6) -> [0: bb5, otherwise: bb14];
    }

    bb5: {
        _161 = const _;
        _13 = _161 as &[&str] (PointerCoercion(Unsize));
        _20 = &(_1.0: devise::SpanWrapped<http_codegen::Method>);
        _19 = <devise::SpanWrapped<http_codegen::Method> as std::ops::Deref>::deref(move _20) -> [return: bb6, unwind: bb115];
    }

    bb6: {
        _18 = &((*_19).0: rocket_http::Method);
        _17 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::Method>(_18) -> [return: bb7, unwind: bb115];
    }

    bb7: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _12 = std::fmt::Arguments::<'_>::new_v1(move _13, move _14) -> [return: bb8, unwind: bb115];
    }

    bb8: {
        _11 = format(move _12) -> [return: bb9, unwind: bb115];
    }

    bb9: {
        _168 = const true;
        _10 = move _11;
        _24 = ((*_5).2: proc_macro2::Span);
        _23 = <proc_macro2::Span as SpanDiagnosticExt>::warning::<&str>(move _24, const "`data` used with non-payload-supporting method") -> [return: bb10, unwind: bb113];
    }

    bb10: {
        _25 = ((_1.0: devise::SpanWrapped<http_codegen::Method>).0: proc_macro2::Span);
        _168 = const false;
        _26 = move _10;
        _22 = devise::Diagnostic::span_note::<proc_macro2::Span, std::string::String>(move _23, move _25, move _26) -> [return: bb11, unwind: bb113];
    }

    bb11: {
        _21 = devise::Diagnostic::emit_as_item_tokens(move _22) -> [return: bb12, unwind: bb113];
    }

    bb12: {
        drop(_21) -> [return: bb13, unwind: bb113];
    }

    bb13: {
        _168 = const false;
        goto -> bb14;
    }

    bb14: {
        _27 = (((_2.2: syn::Signature).7: syn::token::Paren).0: proc_macro2::Span);
        _29 = IndexMap::<name::Name, (proc_macro2::Ident, syn::Type)>::new() -> [return: bb15, unwind: bb115];
    }

    bb15: {
        _167 = const true;
        _28 = route::parse::Arguments { span: _27, map: move _29 };
        _31 = &((_2.2: syn::Signature).8: syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma>);
        _30 = <&syn::punctuated::Punctuated<syn::FnArg, syn::token::Comma> as IntoIterator>::into_iter(move _31) -> [return: bb16, unwind: bb111];
    }

    bb16: {
        _32 = move _30;
        goto -> bb17;
    }

    bb17: {
        _34 = &mut _32;
        _33 = <syn::punctuated::Iter<'_, syn::FnArg> as Iterator>::next(_34) -> [return: bb18, unwind: bb96];
    }

    bb18: {
        _35 = discriminant(_33);
        switchInt(move _35) -> [0: bb21, 1: bb19, otherwise: bb20];
    }

    bb19: {
        _36 = ((_33 as Some).0: &syn::FnArg);
        _37 = <syn::FnArg as FnArgExt>::typed(_36) -> [return: bb22, unwind: bb96];
    }

    bb20: {
        unreachable;
    }

    bb21: {
        drop(_32) -> [return: bb37, unwind: bb111];
    }

    bb22: {
        _38 = discriminant(_37);
        switchInt(move _38) -> [1: bb23, otherwise: bb29];
    }

    bb23: {
        _39 = (((_37 as Some).0: (&proc_macro2::Ident, &syn::Type)).0: &proc_macro2::Ident);
        _40 = (((_37 as Some).0: (&proc_macro2::Ident, &syn::Type)).1: &syn::Type);
        _42 = <proc_macro2::Ident as Clone>::clone(_39) -> [return: bb24, unwind: bb96];
    }

    bb24: {
        _43 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(_40) -> [return: bb25, unwind: bb95];
    }

    bb25: {
        _166 = const true;
        _41 = (move _42, move _43);
        _45 = &mut (_28.1: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>);
        _46 = <name::Name as From<&proc_macro2::Ident>>::from(_39) -> [return: bb26, unwind: bb109];
    }

    bb26: {
        _166 = const false;
        _47 = move _41;
        _44 = IndexMap::<name::Name, (proc_macro2::Ident, syn::Type)>::insert(move _45, move _46, move _47) -> [return: bb27, unwind: bb109];
    }

    bb27: {
        drop(_44) -> [return: bb28, unwind: bb109];
    }

    bb28: {
        _166 = const false;
        goto -> bb17;
    }

    bb29: {
        _48 = <syn::FnArg as devise::Spanned>::span(_36) -> [return: bb30, unwind: bb96];
    }

    bb30: {
        _52 = <syn::FnArg as FnArgExt>::wild(_36) -> [return: bb31, unwind: bb96];
    }

    bb31: {
        _51 = &_52;
        _50 = Option::<&PatWild>::is_some(move _51) -> [return: bb32, unwind: bb96];
    }

    bb32: {
        switchInt(move _50) -> [0: bb35, otherwise: bb33];
    }

    bb33: {
        _53 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_48, const "handler arguments must be named") -> [return: bb34, unwind: bb96];
    }

    bb34: {
        _49 = devise::Diagnostic::help::<&str>(move _53, const "to name an ignored handler argument, use `_name`") -> [return: bb119, unwind: bb96];
    }

    bb35: {
        _49 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(_48, const "handler arguments must be of the form `ident: Type`") -> [return: bb120, unwind: bb96];
    }

    bb36: {
        _55 = &mut _3;
        _56 = move _49;
        _54 = Diagnostics::push(move _55, move _56) -> [return: bb121, unwind: bb96];
    }

    bb37: {
        _62 = &(_1.1: attribute::route::parse::RouteUri);
        _61 = <RouteUri as std::ops::Deref>::deref(move _62) -> [return: bb38, unwind: bb111];
    }

    bb38: {
        _60 = rocket_http::uri::Origin::<'_>::path(_61) -> [return: bb39, unwind: bb111];
    }

    bb39: {
        _63 = ((_1.1: attribute::route::parse::RouteUri).1: proc_macro2::Span);
        _59 = (move _60, move _63);
        _57 = (_59.0: rocket_http::uri::Path<'_>);
        _58 = (_59.1: proc_macro2::Span);
        _69 = &_57;
        _68 = rocket_http::uri::Path::<'_>::as_str(move _69) -> [return: bb40, unwind: bb111];
    }

    bb40: {
        _67 = param::parse::<impl Parameter>::parse_many::<rocket_http::uri::fmt::Path>(_68, _58) -> [return: bb41, unwind: bb111];
    }

    bb41: {
        _71 = &_28;
        _70 = {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21} { arguments: move _71 };
        _66 = <Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}> as Iterator>::map::<std::result::Result<Parameter, devise::Diagnostic>, {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}>(move _67, move _70) -> [return: bb42, unwind: bb111];
    }

    bb42: {
        _73 = &mut _3;
        _72 = {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28} { diags: move _73 };
        _65 = <Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}> as Iterator>::filter_map::<Parameter, {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28}>(move _66, move _72) -> [return: bb43, unwind: bb111];
    }

    bb43: {
        _64 = <FilterMap<Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}>, {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28}> as Iterator>::collect::<Vec<Parameter>>(move _65) -> [return: bb44, unwind: bb111];
    }

    bb44: {
        _165 = const true;
        _78 = &(_1.1: attribute::route::parse::RouteUri);
        _77 = <RouteUri as std::ops::Deref>::deref(move _78) -> [return: bb45, unwind: bb107];
    }

    bb45: {
        _76 = rocket_http::uri::Origin::<'_>::query(_77) -> [return: bb46, unwind: bb107];
    }

    bb46: {
        _79 = ((_1.1: attribute::route::parse::RouteUri).2: std::option::Option<proc_macro2::Span>);
        _75 = (move _76, move _79);
        _81 = discriminant((_75.0: std::option::Option<rocket_http::uri::Query<'_>>));
        switchInt(move _81) -> [1: bb48, otherwise: bb47];
    }

    bb47: {
        _74 = Vec::<Parameter>::new() -> [return: bb99, unwind: bb107];
    }

    bb48: {
        _80 = discriminant((_75.1: std::option::Option<proc_macro2::Span>));
        switchInt(move _80) -> [1: bb49, otherwise: bb47];
    }

    bb49: {
        _82 = (((_75.0: std::option::Option<rocket_http::uri::Query<'_>>) as Some).0: rocket_http::uri::Query<'_>);
        _83 = (((_75.1: std::option::Option<proc_macro2::Span>) as Some).0: proc_macro2::Span);
        _88 = &_82;
        _87 = rocket_http::uri::Query::<'_>::as_str(move _88) -> [return: bb50, unwind: bb107];
    }

    bb50: {
        _86 = param::parse::<impl Parameter>::parse_many::<rocket_http::uri::fmt::Query>(_87, _83) -> [return: bb51, unwind: bb107];
    }

    bb51: {
        _90 = &_28;
        _89 = {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25} { arguments: move _90 };
        _85 = <Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}> as Iterator>::map::<std::result::Result<Parameter, devise::Diagnostic>, {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}>(move _86, move _89) -> [return: bb52, unwind: bb107];
    }

    bb52: {
        _92 = &mut _3;
        _91 = {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32} { diags: move _92 };
        _84 = <Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}> as Iterator>::filter_map::<Parameter, {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32}>(move _85, move _91) -> [return: bb53, unwind: bb107];
    }

    bb53: {
        _74 = <FilterMap<Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}>, {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32}> as Iterator>::collect::<Vec<Parameter>>(move _84) -> [return: bb54, unwind: bb107];
    }

    bb54: {
        _164 = const true;
        goto -> bb55;
    }

    bb55: {
        _96 = &(_1.2: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _95 = <Option<devise::SpanWrapped<param::Dynamic>> as Clone>::clone(move _96) -> [return: bb56, unwind: bb105];
    }

    bb56: {
        _98 = &_28;
        _97 = {closure@core/codegen/src/attribute/route/parse.rs:177:18: 177:21} { arguments: move _98 };
        _94 = Option::<devise::SpanWrapped<param::Dynamic>>::map::<std::result::Result<Guard, devise::Diagnostic>, {closure@core/codegen/src/attribute/route/parse.rs:177:18: 177:21}>(move _95, move _97) -> [return: bb57, unwind: bb105];
    }

    bb57: {
        _100 = &mut _3;
        _99 = {closure@core/codegen/src/attribute/route/parse.rs:178:23: 178:26} { diags: move _100 };
        _93 = Option::<std::result::Result<Guard, devise::Diagnostic>>::and_then::<Guard, {closure@core/codegen/src/attribute/route/parse.rs:178:23: 178:26}>(move _94, move _99) -> [return: bb58, unwind: bb105];
    }

    bb58: {
        _163 = const true;
        _106 = &_64;
        _105 = <Vec<Parameter> as std::ops::Deref>::deref(move _106) -> [return: bb59, unwind: bb103];
    }

    bb59: {
        _104 = core::slice::<impl [Parameter]>::iter(_105) -> [return: bb60, unwind: bb103];
    }

    bb60: {
        _103 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&param::Dynamic, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>(move _104, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}) -> [return: bb61, unwind: bb103];
    }

    bb61: {
        _110 = &_74;
        _109 = <Vec<Parameter> as std::ops::Deref>::deref(move _110) -> [return: bb62, unwind: bb103];
    }

    bb62: {
        _108 = core::slice::<impl [Parameter]>::iter(_109) -> [return: bb63, unwind: bb103];
    }

    bb63: {
        _107 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&param::Dynamic, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>(move _108, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}) -> [return: bb64, unwind: bb103];
    }

    bb64: {
        _102 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}> as Iterator>::chain::<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>(move _103, move _107) -> [return: bb65, unwind: bb103];
    }

    bb65: {
        _114 = &_93;
        _113 = Option::<Guard>::as_ref(move _114) -> [return: bb66, unwind: bb103];
    }

    bb66: {
        _112 = Option::<&Guard>::map::<&param::Dynamic, {closure@core/codegen/src/attribute/route/parse.rs:183:44: 183:47}>(move _113, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:183:44: 183:47}) -> [return: bb67, unwind: bb103];
    }

    bb67: {
        _111 = <Option<&param::Dynamic> as IntoIterator>::into_iter(move _112) -> [return: bb68, unwind: bb103];
    }

    bb68: {
        _101 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>> as Iterator>::chain::<std::option::IntoIter<&param::Dynamic>>(move _102, move _111) -> [return: bb69, unwind: bb103];
    }

    bb69: {
        _115 = IndexSet::<&param::Dynamic>::new() -> [return: bb70, unwind: bb103];
    }

    bb70: {
        _116 = <std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&param::Dynamic>> as IntoIterator>::into_iter(move _101) -> [return: bb71, unwind: bb94];
    }

    bb71: {
        _117 = move _116;
        goto -> bb72;
    }

    bb72: {
        _120 = &mut _117;
        _119 = <std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}>>, std::option::IntoIter<&param::Dynamic>> as Iterator>::next(_120) -> [return: bb73, unwind: bb94];
    }

    bb73: {
        _121 = discriminant(_119);
        switchInt(move _121) -> [0: bb75, 1: bb74, otherwise: bb20];
    }

    bb74: {
        _122 = ((_119 as Some).0: &attribute::param::Dynamic);
        _124 = &mut _115;
        _123 = IndexSet::<&param::Dynamic>::replace(move _124, _122) -> [return: bb76, unwind: bb94];
    }

    bb75: {
        _147 = &(_28.1: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>);
        _146 = IndexMap::<name::Name, (proc_macro2::Ident, syn::Type)>::iter(move _147) -> [return: bb87, unwind: bb94];
    }

    bb76: {
        _125 = discriminant(_123);
        switchInt(move _125) -> [1: bb77, otherwise: bb72];
    }

    bb77: {
        _126 = ((_123 as Some).0: &attribute::param::Dynamic);
        _127 = &mut _3;
        _131 = <param::Dynamic as std::ops::Deref>::deref(_122) -> [return: bb78, unwind: bb94];
    }

    bb78: {
        _130 = name::Name::span(_131) -> [return: bb79, unwind: bb94];
    }

    bb79: {
        _160 = const _;
        _134 = _160 as &[&str] (PointerCoercion(Unsize));
        _139 = &((*_122).0: name::Name);
        _138 = core::fmt::rt::Argument::<'_>::new_display::<name::Name>(_139) -> [return: bb80, unwind: bb94];
    }

    bb80: {
        _137 = [move _138];
        _136 = &_137;
        _135 = _136 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _133 = std::fmt::Arguments::<'_>::new_v1(move _134, move _135) -> [return: bb81, unwind: bb94];
    }

    bb81: {
        _132 = format(move _133) -> [return: bb82, unwind: bb94];
    }

    bb82: {
        _129 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _130, move _132) -> [return: bb83, unwind: bb94];
    }

    bb83: {
        _162 = const true;
        _141 = <param::Dynamic as std::ops::Deref>::deref(_126) -> [return: bb84, unwind: bb101];
    }

    bb84: {
        _140 = name::Name::span(_141) -> [return: bb85, unwind: bb101];
    }

    bb85: {
        _162 = const false;
        _128 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _129, move _140, const "previous parameter with the same name here") -> [return: bb86, unwind: bb101];
    }

    bb86: {
        _162 = const false;
        _118 = Diagnostics::push(move _127, move _128) -> [return: bb122, unwind: bb94];
    }

    bb87: {
        _149 = &_64;
        _150 = &_74;
        _151 = &_93;
        _148 = {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32} { path_params: move _149, query_params: move _150, data_guard: move _151 };
        _145 = <indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)> as Iterator>::filter::<{closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>(move _146, move _148) -> [return: bb88, unwind: bb94];
    }

    bb88: {
        _144 = <Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}> as Iterator>::enumerate(move _145) -> [return: bb89, unwind: bb94];
    }

    bb89: {
        _143 = <Enumerate<Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>> as Iterator>::map::<Guard, {closure@core/codegen/src/attribute/route/parse.rs:204:18: 204:48}>(move _144, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:204:18: 204:48}) -> [return: bb90, unwind: bb94];
    }

    bb90: {
        _142 = <Map<Enumerate<Filter<indexmap::map::Iter<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}>>, {closure@core/codegen/src/attribute/route/parse.rs:204:18: 204:48}> as Iterator>::collect::<Vec<Guard>>(move _143) -> [return: bb91, unwind: bb94];
    }

    bb91: {
        _169 = const false;
        _152 = move _3;
        _171 = const false;
        _154 = move _1;
        _165 = const false;
        _155 = move _64;
        _164 = const false;
        _156 = move _74;
        _163 = const false;
        _157 = move _93;
        _170 = const false;
        _158 = move _2;
        _167 = const false;
        _159 = move _28;
        _153 = route::parse::Route { attr: move _154, path_params: move _155, query_params: move _156, data_guard: move _157, request_guards: move _142, handler: move _158, arguments: move _159 };
        _0 = Diagnostics::head_err_or::<route::parse::Route>(move _152, move _153) -> [return: bb92, unwind: bb94];
    }

    bb92: {
        drop(_115) -> [return: bb93, unwind: bb103];
    }

    bb93: {
        _163 = const false;
        _164 = const false;
        _165 = const false;
        _167 = const false;
        _169 = const false;
        return;
    }

    bb94 (cleanup): {
        drop(_115) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb95 (cleanup): {
        drop(_42) -> [return: bb96, unwind terminate(cleanup)];
    }

    bb96 (cleanup): {
        drop(_32) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        switchInt(_171) -> [0: bb98, otherwise: bb118];
    }

    bb98 (cleanup): {
        resume;
    }

    bb99: {
        _164 = const true;
        goto -> bb55;
    }

    bb100 (cleanup): {
        drop(_129) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb101 (cleanup): {
        switchInt(_162) -> [0: bb94, otherwise: bb100];
    }

    bb102 (cleanup): {
        drop(_93) -> [return: bb105, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        switchInt(_163) -> [0: bb105, otherwise: bb102];
    }

    bb104 (cleanup): {
        drop(_74) -> [return: bb107, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        switchInt(_164) -> [0: bb107, otherwise: bb104];
    }

    bb106 (cleanup): {
        drop(_64) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        switchInt(_165) -> [0: bb111, otherwise: bb106];
    }

    bb108 (cleanup): {
        drop(_41) -> [return: bb96, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        switchInt(_166) -> [0: bb96, otherwise: bb108];
    }

    bb110 (cleanup): {
        drop(_28) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        switchInt(_167) -> [0: bb115, otherwise: bb110];
    }

    bb112 (cleanup): {
        drop(_10) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        switchInt(_168) -> [0: bb115, otherwise: bb112];
    }

    bb114 (cleanup): {
        drop(_3) -> [return: bb117, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        switchInt(_169) -> [0: bb117, otherwise: bb114];
    }

    bb116 (cleanup): {
        drop(_2) -> [return: bb97, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        switchInt(_170) -> [0: bb97, otherwise: bb116];
    }

    bb118 (cleanup): {
        drop(_1) -> [return: bb98, unwind terminate(cleanup)];
    }

    bb119: {
        goto -> bb36;
    }

    bb120: {
        goto -> bb36;
    }

    bb121: {
        goto -> bb17;
    }

    bb122: {
        goto -> bb72;
    }
}

promoted[0] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "duplicate parameter: `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "'", const "' does not typically support payloads"];
        _0 = &_1;
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:162:18: 162:21}, _2: std::result::Result<Parameter, param::parse::Error<'_>>) -> std::result::Result<Parameter, devise::Diagnostic> {
    debug p => _2;
    debug arguments => (*((*_1).0: &attribute::route::parse::Arguments));
    let mut _0: std::result::Result<attribute::param::Parameter, devise::Diagnostic>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>, attribute::param::Parameter>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>;
    let _6: attribute::param::Parameter;
    let mut _7: &attribute::route::parse::Arguments;
    scope 1 {
        debug residual => _5;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _6;
        scope 4 {
        }
    }

    bb0: {
        _3 = <std::result::Result<Parameter, param::parse::Error<'_>> as std::ops::Try>::branch(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Continue).0: attribute::param::Parameter);
        _7 = deref_copy ((*_1).0: &attribute::route::parse::Arguments);
        _0 = route::parse::Route::upgrade_param(move _6, _7) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>);
        _0 = <std::result::Result<Parameter, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, param::parse::Error<'_>>>>::from_residual(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:163:25: 163:28}, _2: std::result::Result<Parameter, devise::Diagnostic>) -> Option<Parameter> {
    debug p => _2;
    debug diags => (*((*_1).0: &mut proc_macro_ext::Diagnostics));
    let mut _0: std::option::Option<attribute::param::Parameter>;
    let mut _3: std::result::Result<attribute::param::Parameter, ()>;
    let mut _4: {closure@core/codegen/src/attribute/route/parse.rs:163:39: 163:42};
    let mut _5: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _5 = deref_copy ((*_1).0: &mut proc_macro_ext::Diagnostics);
        _4 = {closure@core/codegen/src/attribute/route/parse.rs:163:39: 163:42} { diags: _5 };
        _3 = std::result::Result::<Parameter, devise::Diagnostic>::map_err::<(), {closure@core/codegen/src/attribute/route/parse.rs:163:39: 163:42}>(move _2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<Parameter, ()>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#1}::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:163:39: 163:42}, _2: devise::Diagnostic) -> () {
    debug e => _2;
    debug diags => (*(_1.0: &mut proc_macro_ext::Diagnostics));
    let mut _0: ();
    let mut _3: devise::Diagnostic;
    let mut _4: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _4 = deref_copy (_1.0: &mut proc_macro_ext::Diagnostics);
        _3 = <devise::Diagnostic as Into<devise::Diagnostic>>::into(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Diagnostics::push(_4, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:169:22: 169:25}, _2: std::result::Result<Parameter, param::parse::Error<'_>>) -> std::result::Result<Parameter, devise::Diagnostic> {
    debug p => _2;
    debug arguments => (*((*_1).0: &attribute::route::parse::Arguments));
    let mut _0: std::result::Result<attribute::param::Parameter, devise::Diagnostic>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>, attribute::param::Parameter>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>;
    let _6: attribute::param::Parameter;
    let mut _7: &attribute::route::parse::Arguments;
    scope 1 {
        debug residual => _5;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _6;
        scope 4 {
        }
    }

    bb0: {
        _3 = <std::result::Result<Parameter, param::parse::Error<'_>> as std::ops::Try>::branch(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Continue).0: attribute::param::Parameter);
        _7 = deref_copy ((*_1).0: &attribute::route::parse::Arguments);
        _0 = route::parse::Route::upgrade_param(move _6, _7) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>);
        _0 = <std::result::Result<Parameter, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, param::parse::Error<'_>>>>::from_residual(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#3}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:170:29: 170:32}, _2: std::result::Result<Parameter, devise::Diagnostic>) -> Option<Parameter> {
    debug p => _2;
    debug diags => (*((*_1).0: &mut proc_macro_ext::Diagnostics));
    let mut _0: std::option::Option<attribute::param::Parameter>;
    let mut _3: std::result::Result<attribute::param::Parameter, ()>;
    let mut _4: {closure@core/codegen/src/attribute/route/parse.rs:170:43: 170:46};
    let mut _5: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _5 = deref_copy ((*_1).0: &mut proc_macro_ext::Diagnostics);
        _4 = {closure@core/codegen/src/attribute/route/parse.rs:170:43: 170:46} { diags: _5 };
        _3 = std::result::Result::<Parameter, devise::Diagnostic>::map_err::<(), {closure@core/codegen/src/attribute/route/parse.rs:170:43: 170:46}>(move _2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<Parameter, ()>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#3}::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:170:43: 170:46}, _2: devise::Diagnostic) -> () {
    debug e => _2;
    debug diags => (*(_1.0: &mut proc_macro_ext::Diagnostics));
    let mut _0: ();
    let mut _3: devise::Diagnostic;
    let mut _4: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _4 = deref_copy (_1.0: &mut proc_macro_ext::Diagnostics);
        _3 = <devise::Diagnostic as Into<devise::Diagnostic>>::into(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Diagnostics::push(_4, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#4}(_1: {closure@core/codegen/src/attribute/route/parse.rs:177:18: 177:21}, _2: devise::SpanWrapped<param::Dynamic>) -> std::result::Result<Guard, devise::Diagnostic> {
    debug p => _2;
    debug arguments => (*(_1.0: &attribute::route::parse::Arguments));
    let mut _0: std::result::Result<attribute::param::Guard, devise::Diagnostic>;
    let mut _3: attribute::param::Dynamic;
    let mut _4: &attribute::route::parse::Arguments;

    bb0: {
        _3 = move (_2.3: attribute::param::Dynamic);
        _4 = deref_copy (_1.0: &attribute::route::parse::Arguments);
        _0 = route::parse::Route::upgrade_dynamic(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#5}(_1: {closure@core/codegen/src/attribute/route/parse.rs:178:23: 178:26}, _2: std::result::Result<Guard, devise::Diagnostic>) -> Option<Guard> {
    debug p => _2;
    debug diags => (*(_1.0: &mut proc_macro_ext::Diagnostics));
    let mut _0: std::option::Option<attribute::param::Guard>;
    let mut _3: std::result::Result<attribute::param::Guard, ()>;
    let mut _4: {closure@core/codegen/src/attribute/route/parse.rs:178:37: 178:40};
    let mut _5: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _5 = deref_copy (_1.0: &mut proc_macro_ext::Diagnostics);
        _4 = {closure@core/codegen/src/attribute/route/parse.rs:178:37: 178:40} { diags: _5 };
        _3 = std::result::Result::<Guard, devise::Diagnostic>::map_err::<(), {closure@core/codegen/src/attribute/route/parse.rs:178:37: 178:40}>(move _2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<Guard, ()>::ok(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#5}::{closure#0}(_1: {closure@core/codegen/src/attribute/route/parse.rs:178:37: 178:40}, _2: devise::Diagnostic) -> () {
    debug e => _2;
    debug diags => (*(_1.0: &mut proc_macro_ext::Diagnostics));
    let mut _0: ();
    let mut _3: devise::Diagnostic;
    let mut _4: &mut proc_macro_ext::Diagnostics;

    bb0: {
        _4 = deref_copy (_1.0: &mut proc_macro_ext::Diagnostics);
        _3 = <devise::Diagnostic as Into<devise::Diagnostic>>::into(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Diagnostics::push(_4, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#6}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:181:60: 181:63}, _2: &Parameter) -> Option<&param::Dynamic> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;

    bb0: {
        _0 = Parameter::dynamic(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#7}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:182:51: 182:54}, _2: &Parameter) -> Option<&param::Dynamic> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;

    bb0: {
        _0 = Parameter::dynamic(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#8}(_1: {closure@core/codegen/src/attribute/route/parse.rs:183:44: 183:47}, _2: &Guard) -> &param::Dynamic {
    debug g => _2;
    let mut _0: &attribute::param::Dynamic;

    bb0: {
        _0 = &((*_2).0: attribute::param::Dynamic);
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#9}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:196:21: 196:32}, _2: &(&name::Name, &(proc_macro2::Ident, syn::Type))) -> bool {
    debug path_params => (*((*_1).0: &std::vec::Vec<attribute::param::Parameter>));
    debug query_params => (*((*_1).1: &std::vec::Vec<attribute::param::Parameter>));
    debug data_guard => (*((*_1).2: &std::option::Option<attribute::param::Guard>));
    let mut _0: bool;
    let _3: &&name::Name;
    let mut _5: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>>;
    let mut _6: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>;
    let mut _7: std::slice::Iter<'_, attribute::param::Parameter>;
    let _8: &[attribute::param::Parameter];
    let mut _9: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>;
    let mut _10: std::slice::Iter<'_, attribute::param::Parameter>;
    let _11: &[attribute::param::Parameter];
    let mut _12: std::option::IntoIter<&attribute::param::Guard>;
    let mut _13: std::option::Option<&attribute::param::Guard>;
    let mut _14: &mut std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>>, std::option::IntoIter<&attribute::param::Guard>>;
    let mut _15: {closure@core/codegen/src/attribute/route/parse.rs:201:38: 201:41};
    let mut _16: &&&name::Name;
    let mut _17: &std::vec::Vec<attribute::param::Parameter>;
    let mut _18: &std::vec::Vec<attribute::param::Parameter>;
    let mut _19: &std::option::Option<attribute::param::Guard>;
    scope 1 {
        debug name => _3;
        let mut _4: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>>, std::option::IntoIter<&attribute::param::Guard>>;
        scope 2 {
            debug all_other_guards => _4;
        }
    }

    bb0: {
        _3 = &((*_2).0: &name::Name);
        _17 = deref_copy ((*_1).0: &std::vec::Vec<attribute::param::Parameter>);
        _8 = <Vec<Parameter> as std::ops::Deref>::deref(_17) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = core::slice::<impl [Parameter]>::iter(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&Guard, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>(move _7, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _18 = deref_copy ((*_1).1: &std::vec::Vec<attribute::param::Parameter>);
        _11 = <Vec<Parameter> as std::ops::Deref>::deref(_18) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = core::slice::<impl [Parameter]>::iter(_11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&Guard, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>(move _10, const ZeroSized: {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}) -> [return: bb6, unwind continue];
    }

    bb6: {
        _5 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}> as Iterator>::chain::<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>>(move _6, move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _19 = deref_copy ((*_1).2: &std::option::Option<attribute::param::Guard>);
        _13 = Option::<Guard>::as_ref(_19) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = <Option<&Guard> as IntoIterator>::into_iter(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _4 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>> as Iterator>::chain::<std::option::IntoIter<&Guard>>(move _5, move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        _14 = &mut _4;
        _16 = &_3;
        _15 = {closure@core/codegen/src/attribute/route/parse.rs:201:38: 201:41} { name: move _16 };
        _0 = <std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}>>, std::option::IntoIter<&Guard>> as Iterator>::all::<{closure@core/codegen/src/attribute/route/parse.rs:201:38: 201:41}>(move _14, move _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#9}::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:197:74: 197:77}, _2: &Parameter) -> Option<&Guard> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Guard>;

    bb0: {
        _0 = Parameter::guard(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#9}::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:198:59: 198:62}, _2: &Parameter) -> Option<&Guard> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Guard>;

    bb0: {
        _0 = Parameter::guard(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#9}::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:201:38: 201:41}, _2: &Guard) -> bool {
    debug g => _2;
    debug name => (*((*_1).0: &&&name::Name));
    let mut _0: bool;
    let mut _3: &&name::Name;
    let _4: &name::Name;
    let _5: &attribute::param::Dynamic;
    let mut _6: &&&name::Name;
    let mut _7: &&name::Name;

    bb0: {
        _5 = <Guard as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &((*_5).0: name::Name);
        _3 = &_4;
        _6 = deref_copy ((*_1).0: &&&name::Name);
        _7 = deref_copy (*_6);
        _0 = <&name::Name as PartialEq>::ne(move _3, _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:104:1: 104:11>::from::{closure#10}(_1: &mut {closure@core/codegen/src/attribute/route/parse.rs:204:18: 204:48}, _2: (usize, (&name::Name, &(proc_macro2::Ident, syn::Type)))) -> Guard {
    let mut _0: attribute::param::Guard;
    let _3: usize;
    let _4: &name::Name;
    let _5: &proc_macro2::Ident;
    let _6: &syn::Type;
    let mut _7: attribute::param::Dynamic;
    let mut _8: name::Name;
    let mut _9: proc_macro2::Ident;
    let mut _10: syn::Type;
    let mut _11: &(proc_macro2::Ident, syn::Type);
    let mut _12: &(proc_macro2::Ident, syn::Type);
    scope 1 {
        debug index => _3;
        debug name => _4;
        debug ident => _5;
        debug ty => _6;
    }

    bb0: {
        _11 = deref_copy ((_2.1: (&name::Name, &(proc_macro2::Ident, syn::Type))).1: &(proc_macro2::Ident, syn::Type));
        _5 = &((*_11).0: proc_macro2::Ident);
        _12 = deref_copy ((_2.1: (&name::Name, &(proc_macro2::Ident, syn::Type))).1: &(proc_macro2::Ident, syn::Type));
        _6 = &((*_12).1: syn::Type);
        _4 = ((_2.1: (&name::Name, &(proc_macro2::Ident, syn::Type))).0: &name::Name);
        _3 = (_2.0: usize);
        _8 = <name::Name as Clone>::clone(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = param::Dynamic { name: move _8, index: _3, trailing: const false };
        _9 = <proc_macro2::Ident as Clone>::clone(_5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _10 = <syn::Type as Clone>::clone(_6) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = Guard { source: move _7, fn_ident: move _9, ty: move _10 };
        return;
    }

    bb4 (cleanup): {
        drop(_9) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_7) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn route::parse::<impl at core/codegen/src/attribute/route/parse.rs:218:1: 218:34>::deref(_1: &RouteUri) -> &rocket_http::uri::Origin<'_> {
    debug self => _1;
    let mut _0: &rocket_http::uri::Origin<'_>;

    bb0: {
        _0 = &((*_1).0: rocket_http::uri::Origin<'_>);
        return;
    }
}

fn route::<impl at core/codegen/src/attribute/route/mod.rs:16:1: 16:11>::guards(_1: &route::parse::Route) -> std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>> {
    debug self => _1;
    let mut _0: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>;
    let mut _2: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>;
    let mut _3: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>;
    let mut _4: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _5: std::slice::Iter<'_, attribute::param::Guard>;
    let _6: &[attribute::param::Guard];
    let mut _7: &std::vec::Vec<attribute::param::Guard>;

    bb0: {
        _3 = route::<impl route::parse::Route>::param_guards(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = route::<impl route::parse::Route>::query_guards(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}> as Iterator>::chain::<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>(move _3, move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &((*_1).4: std::vec::Vec<attribute::param::Guard>);
        _6 = <Vec<Guard> as std::ops::Deref>::deref(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = core::slice::<impl [Guard]>::iter(_6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>> as Iterator>::chain::<std::slice::Iter<'_, Guard>>(move _2, move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn route::<impl at core/codegen/src/attribute/route/mod.rs:16:1: 16:11>::param_guards(_1: &route::parse::Route) -> FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}> {
    debug self => _1;
    let mut _0: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>;
    let mut _2: std::slice::Iter<'_, attribute::param::Parameter>;
    let _3: &[attribute::param::Parameter];
    let mut _4: &std::vec::Vec<attribute::param::Parameter>;

    bb0: {
        _4 = &((*_1).1: std::vec::Vec<attribute::param::Parameter>);
        _3 = <Vec<Parameter> as std::ops::Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = core::slice::<impl [Parameter]>::iter(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&Guard, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>(move _2, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn route::<impl at core/codegen/src/attribute/route/mod.rs:16:1: 16:11>::param_guards::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}, _2: &Parameter) -> Option<&Guard> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Guard>;

    bb0: {
        _0 = Parameter::guard(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn route::<impl at core/codegen/src/attribute/route/mod.rs:16:1: 16:11>::query_guards(_1: &route::parse::Route) -> FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}> {
    debug self => _1;
    let mut _0: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _2: std::slice::Iter<'_, attribute::param::Parameter>;
    let _3: &[attribute::param::Parameter];
    let mut _4: &std::vec::Vec<attribute::param::Parameter>;

    bb0: {
        _4 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _3 = <Vec<Parameter> as std::ops::Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = core::slice::<impl [Parameter]>::iter(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&Guard, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>(move _2, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn route::<impl at core/codegen/src/attribute/route/mod.rs:16:1: 16:11>::query_guards::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}, _2: &Parameter) -> Option<&Guard> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Guard>;

    bb0: {
        _0 = Parameter::guard(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn query_decls(_1: &route::parse::Route) -> Option<TokenStream2> {
    debug route => _1;
    let mut _0: std::option::Option<proc_macro2::TokenStream>;
    let mut _2: bool;
    let mut _3: &std::vec::Vec<attribute::param::Parameter>;
    let mut _4: bool;
    let mut _5: &std::option::Option<&attribute::param::Guard>;
    let _6: std::option::Option<&attribute::param::Guard>;
    let mut _7: &mut std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _8: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _10: std::option::Option<proc_macro2::Span>;
    let mut _11: proc_macro2::Span;
    let mut _13: std::option::Option<proc_macro2::Span>;
    let mut _14: proc_macro2::Span;
    let mut _16: std::option::Option<proc_macro2::Span>;
    let mut _17: proc_macro2::Span;
    let mut _19: std::option::Option<proc_macro2::Span>;
    let mut _20: proc_macro2::Span;
    let mut _22: std::option::Option<proc_macro2::Span>;
    let mut _23: proc_macro2::Span;
    let mut _25: std::option::Option<proc_macro2::Span>;
    let mut _26: proc_macro2::Span;
    let mut _28: std::option::Option<proc_macro2::Span>;
    let mut _29: proc_macro2::Span;
    let mut _31: std::option::Option<proc_macro2::Span>;
    let mut _32: proc_macro2::Span;
    let mut _34: std::option::Option<proc_macro2::Span>;
    let mut _35: proc_macro2::Span;
    let mut _38: (std::vec::Vec<&str>, std::vec::Vec<&str>);
    let mut _39: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}>, {closure@core/codegen/src/attribute/route/mod.rs:46:14: 46:20}>;
    let mut _40: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}>;
    let mut _41: std::slice::Iter<'_, attribute::param::Parameter>;
    let _42: &[attribute::param::Parameter];
    let mut _43: &std::vec::Vec<attribute::param::Parameter>;
    let mut _50: (std::vec::Vec<&name::Name>, std::vec::Vec<proc_macro2::TokenStream>, std::vec::Vec<proc_macro2::Ident>, std::vec::Vec<proc_macro2::TokenStream>, std::vec::Vec<proc_macro2::TokenStream>, std::vec::Vec<proc_macro2::TokenStream>);
    let mut _51: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>, {closure@core/codegen/src/attribute/route/mod.rs:54:14: 54:21}>;
    let mut _52: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _53: proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: &str;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let _67: &exports::StaticPath;
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: &str;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let mut _81: proc_macro2::Delimiter;
    let mut _82: proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let mut _86: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _87: &std::vec::Vec<proc_macro2::Ident>;
    let mut _90: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _91: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _93: bool;
    let mut _95: std::option::Option<&proc_macro2::Ident>;
    let mut _96: &mut std::slice::Iter<'_, proc_macro2::Ident>;
    let mut _97: isize;
    let mut _100: std::option::Option<&proc_macro2::TokenStream>;
    let mut _101: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _102: isize;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: &str;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: &str;
    let _110: ();
    let _111: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: ();
    let _116: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: &str;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: &str;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let _128: &str;
    let _129: ();
    let _130: &exports::StaticPath;
    let mut _131: &mut proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: &str;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let mut _139: proc_macro2::Delimiter;
    let mut _140: proc_macro2::TokenStream;
    let _141: ();
    let mut _142: &mut proc_macro2::TokenStream;
    let mut _143: proc_macro2::Delimiter;
    let mut _144: proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: &str;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let mut _156: proc_macro2::Delimiter;
    let mut _157: proc_macro2::TokenStream;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: &str;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: ();
    let mut _165: &mut proc_macro2::TokenStream;
    let _166: &str;
    let _167: ();
    let mut _168: &mut proc_macro2::TokenStream;
    let _169: ();
    let mut _170: &mut proc_macro2::TokenStream;
    let _171: &str;
    let _172: ();
    let mut _173: &mut proc_macro2::TokenStream;
    let mut _174: proc_macro2::Delimiter;
    let mut _175: proc_macro2::TokenStream;
    let _176: ();
    let mut _177: &mut proc_macro2::TokenStream;
    let _178: ();
    let mut _179: &mut proc_macro2::TokenStream;
    let _180: &str;
    let _181: ();
    let mut _182: &mut proc_macro2::TokenStream;
    let mut _183: proc_macro2::Delimiter;
    let mut _184: proc_macro2::TokenStream;
    let _185: ();
    let mut _186: &mut proc_macro2::TokenStream;
    let _187: ();
    let mut _188: &mut proc_macro2::TokenStream;
    let _189: &str;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let _192: ();
    let mut _193: &mut proc_macro2::TokenStream;
    let _194: &str;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: ();
    let mut _198: &mut proc_macro2::TokenStream;
    let _199: &str;
    let _200: ();
    let mut _201: &mut proc_macro2::TokenStream;
    let _202: &str;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let _205: ();
    let mut _206: &mut proc_macro2::TokenStream;
    let _207: &str;
    let _208: ();
    let mut _209: &mut proc_macro2::TokenStream;
    let _210: ();
    let mut _211: &mut proc_macro2::TokenStream;
    let _212: &str;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: ();
    let mut _216: &mut proc_macro2::TokenStream;
    let _217: &str;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let mut _220: proc_macro2::Delimiter;
    let mut _221: proc_macro2::TokenStream;
    let _222: ();
    let mut _223: &mut proc_macro2::TokenStream;
    let _224: ();
    let mut _225: &mut proc_macro2::TokenStream;
    let _226: &str;
    let _227: ();
    let mut _228: &mut proc_macro2::TokenStream;
    let mut _229: proc_macro2::Delimiter;
    let mut _230: proc_macro2::TokenStream;
    let _231: ();
    let mut _232: &mut proc_macro2::TokenStream;
    let _233: ();
    let mut _234: &mut proc_macro2::TokenStream;
    let _235: &str;
    let _236: ();
    let mut _237: &mut proc_macro2::TokenStream;
    let mut _238: proc_macro2::Delimiter;
    let mut _239: proc_macro2::TokenStream;
    let _241: ();
    let mut _242: &mut proc_macro2::TokenStream;
    let _243: &str;
    let _244: ();
    let mut _245: &mut proc_macro2::TokenStream;
    let _246: ();
    let mut _247: &mut proc_macro2::TokenStream;
    let _248: &str;
    let _249: ();
    let mut _250: &mut proc_macro2::TokenStream;
    let mut _251: proc_macro2::Delimiter;
    let mut _252: proc_macro2::TokenStream;
    let mut _255: (std::slice::Iter<'_, &str>, quote::__private::HasIterator);
    let mut _256: &std::vec::Vec<&str>;
    let mut _259: (std::slice::Iter<'_, &str>, quote::__private::HasIterator);
    let mut _260: &std::vec::Vec<&str>;
    let mut _262: bool;
    let mut _264: std::option::Option<&&str>;
    let mut _265: &mut std::slice::Iter<'_, &str>;
    let mut _266: isize;
    let mut _269: std::option::Option<&&str>;
    let mut _270: &mut std::slice::Iter<'_, &str>;
    let mut _271: isize;
    let _273: ();
    let mut _274: &mut proc_macro2::TokenStream;
    let mut _275: proc_macro2::Delimiter;
    let mut _276: proc_macro2::TokenStream;
    let _278: ();
    let mut _279: &mut proc_macro2::TokenStream;
    let mut _280: proc_macro2::Delimiter;
    let mut _281: proc_macro2::TokenStream;
    let _283: ();
    let _284: &quote::__private::RepInterp<&&str>;
    let mut _285: &mut proc_macro2::TokenStream;
    let _286: ();
    let mut _287: &mut proc_macro2::TokenStream;
    let _288: ();
    let _289: &quote::__private::RepInterp<&&str>;
    let mut _290: &mut proc_macro2::TokenStream;
    let _291: ();
    let mut _292: &mut proc_macro2::TokenStream;
    let _293: ();
    let mut _294: &mut proc_macro2::TokenStream;
    let _295: ();
    let mut _296: &mut proc_macro2::TokenStream;
    let _297: ();
    let mut _298: &mut proc_macro2::TokenStream;
    let mut _299: proc_macro2::Delimiter;
    let mut _300: proc_macro2::TokenStream;
    let _301: ();
    let mut _302: &mut proc_macro2::TokenStream;
    let mut _304: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _305: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _308: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _309: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _311: bool;
    let mut _313: std::option::Option<&proc_macro2::TokenStream>;
    let mut _314: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _315: isize;
    let mut _318: std::option::Option<&proc_macro2::TokenStream>;
    let mut _319: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _320: isize;
    let _322: ();
    let mut _323: &mut proc_macro2::TokenStream;
    let mut _324: proc_macro2::Delimiter;
    let mut _325: proc_macro2::TokenStream;
    let _327: ();
    let mut _328: &mut proc_macro2::TokenStream;
    let _329: ();
    let mut _330: &mut proc_macro2::TokenStream;
    let _331: ();
    let _332: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _333: &mut proc_macro2::TokenStream;
    let _334: ();
    let mut _335: &mut proc_macro2::TokenStream;
    let _336: ();
    let _337: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _338: &mut proc_macro2::TokenStream;
    let _339: ();
    let mut _340: &mut proc_macro2::TokenStream;
    let _341: ();
    let mut _342: &mut proc_macro2::TokenStream;
    let _343: ();
    let mut _344: &mut proc_macro2::TokenStream;
    let _345: ();
    let mut _346: &mut proc_macro2::TokenStream;
    let mut _347: proc_macro2::Delimiter;
    let mut _348: proc_macro2::TokenStream;
    let _349: ();
    let mut _350: &mut proc_macro2::TokenStream;
    let mut _352: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _353: &std::vec::Vec<proc_macro2::Ident>;
    let mut _356: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _357: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _360: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _361: &exports::StaticPath;
    let mut _364: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _365: &exports::StaticPath;
    let mut _368: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _369: &exports::StaticPath;
    let mut _372: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _373: &exports::StaticPath;
    let mut _376: (std::slice::Iter<'_, &name::Name>, quote::__private::HasIterator);
    let mut _377: &std::vec::Vec<&name::Name>;
    let mut _380: (&exports::StaticPath, quote::__private::ThereIsNoIteratorInRepetition);
    let mut _381: &exports::StaticPath;
    let mut _383: bool;
    let mut _385: std::option::Option<&proc_macro2::Ident>;
    let mut _386: &mut std::slice::Iter<'_, proc_macro2::Ident>;
    let mut _387: isize;
    let mut _390: std::option::Option<&proc_macro2::TokenStream>;
    let mut _391: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _392: isize;
    let mut _395: std::option::Option<&exports::StaticPath>;
    let mut _396: isize;
    let mut _399: std::option::Option<&exports::StaticPath>;
    let mut _400: isize;
    let mut _403: std::option::Option<&exports::StaticPath>;
    let mut _404: isize;
    let mut _407: std::option::Option<&exports::StaticPath>;
    let mut _408: isize;
    let mut _411: std::option::Option<&&name::Name>;
    let mut _412: &mut std::slice::Iter<'_, &name::Name>;
    let mut _413: isize;
    let mut _416: std::option::Option<&exports::StaticPath>;
    let mut _417: isize;
    let _419: ();
    let mut _420: &mut proc_macro2::TokenStream;
    let _421: &str;
    let _422: ();
    let _423: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _424: &mut proc_macro2::TokenStream;
    let _425: ();
    let mut _426: &mut proc_macro2::TokenStream;
    let _427: ();
    let mut _428: &mut proc_macro2::TokenStream;
    let _429: &str;
    let _430: ();
    let _431: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _432: &mut proc_macro2::TokenStream;
    let _433: ();
    let mut _434: &mut proc_macro2::TokenStream;
    let mut _435: proc_macro2::Delimiter;
    let mut _436: proc_macro2::TokenStream;
    let _438: ();
    let _439: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _440: &mut proc_macro2::TokenStream;
    let _441: ();
    let mut _442: &mut proc_macro2::TokenStream;
    let mut _443: proc_macro2::Delimiter;
    let mut _444: proc_macro2::TokenStream;
    let _446: ();
    let mut _447: &mut proc_macro2::TokenStream;
    let _448: &str;
    let _449: ();
    let mut _450: &mut proc_macro2::TokenStream;
    let _451: ();
    let _452: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _453: &mut proc_macro2::TokenStream;
    let _454: ();
    let mut _455: &mut proc_macro2::TokenStream;
    let mut _456: proc_macro2::Delimiter;
    let mut _457: proc_macro2::TokenStream;
    let _459: ();
    let mut _460: &mut proc_macro2::TokenStream;
    let _461: &str;
    let _462: ();
    let mut _463: &mut proc_macro2::TokenStream;
    let _464: ();
    let _465: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _466: &mut proc_macro2::TokenStream;
    let _467: ();
    let mut _468: &mut proc_macro2::TokenStream;
    let mut _469: proc_macro2::Delimiter;
    let mut _470: proc_macro2::TokenStream;
    let _472: ();
    let mut _473: &mut proc_macro2::TokenStream;
    let _474: &str;
    let _475: ();
    let mut _476: &mut proc_macro2::TokenStream;
    let _477: ();
    let mut _478: &mut proc_macro2::TokenStream;
    let mut _479: proc_macro2::Delimiter;
    let mut _480: proc_macro2::TokenStream;
    let _482: ();
    let mut _483: &mut proc_macro2::TokenStream;
    let _484: &str;
    let _485: ();
    let mut _486: &mut proc_macro2::TokenStream;
    let _487: ();
    let mut _488: &mut proc_macro2::TokenStream;
    let _489: &str;
    let _490: ();
    let mut _491: &mut proc_macro2::TokenStream;
    let mut _492: proc_macro2::Delimiter;
    let mut _493: proc_macro2::TokenStream;
    let _495: ();
    let mut _496: &mut proc_macro2::TokenStream;
    let _497: &str;
    let _498: ();
    let mut _499: &mut proc_macro2::TokenStream;
    let _500: ();
    let mut _501: &mut proc_macro2::TokenStream;
    let _502: &str;
    let _503: ();
    let mut _504: &mut proc_macro2::TokenStream;
    let mut _505: proc_macro2::Delimiter;
    let mut _506: proc_macro2::TokenStream;
    let _508: ();
    let _509: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _510: &mut proc_macro2::TokenStream;
    let _511: ();
    let mut _512: &mut proc_macro2::TokenStream;
    let _513: ();
    let mut _514: &mut proc_macro2::TokenStream;
    let _515: &str;
    let _516: ();
    let mut _517: &mut proc_macro2::TokenStream;
    let _518: ();
    let mut _519: &mut proc_macro2::TokenStream;
    let _520: &str;
    let _521: ();
    let mut _522: &mut proc_macro2::TokenStream;
    let mut _523: proc_macro2::Delimiter;
    let mut _524: proc_macro2::TokenStream;
    let _526: ();
    let _527: &quote::__private::RepInterp<&&name::Name>;
    let mut _528: &mut proc_macro2::TokenStream;
    let _529: ();
    let mut _530: &mut proc_macro2::TokenStream;
    let _531: ();
    let _532: &quote::__private::RepInterp<&exports::StaticPath>;
    let mut _533: &mut proc_macro2::TokenStream;
    let _534: ();
    let mut _535: &mut proc_macro2::TokenStream;
    let _536: ();
    let mut _537: &mut proc_macro2::TokenStream;
    let _538: ();
    let mut _539: &mut proc_macro2::TokenStream;
    let _540: &str;
    let _541: ();
    let mut _542: &mut proc_macro2::TokenStream;
    let _543: ();
    let mut _544: &mut proc_macro2::TokenStream;
    let _545: &str;
    let _546: ();
    let mut _547: &mut proc_macro2::TokenStream;
    let _548: ();
    let mut _549: &mut proc_macro2::TokenStream;
    let _550: &str;
    let _551: ();
    let mut _552: &mut proc_macro2::TokenStream;
    let mut _553: proc_macro2::Delimiter;
    let mut _554: proc_macro2::TokenStream;
    let _555: ();
    let mut _556: &mut proc_macro2::TokenStream;
    let mut _557: proc_macro2::Delimiter;
    let mut _558: proc_macro2::TokenStream;
    let _560: ();
    let _561: &exports::StaticPath;
    let mut _562: &mut proc_macro2::TokenStream;
    let _563: ();
    let mut _564: &mut proc_macro2::TokenStream;
    let _565: ();
    let mut _566: &mut proc_macro2::TokenStream;
    let _567: &str;
    let _568: ();
    let mut _569: &mut proc_macro2::TokenStream;
    let _570: ();
    let mut _571: &mut proc_macro2::TokenStream;
    let mut _572: proc_macro2::Delimiter;
    let mut _573: proc_macro2::TokenStream;
    let _575: ();
    let mut _576: &mut proc_macro2::TokenStream;
    let _577: &str;
    let _578: ();
    let mut _579: &mut proc_macro2::TokenStream;
    let _580: ();
    let mut _581: &mut proc_macro2::TokenStream;
    let _582: &str;
    let _583: ();
    let mut _584: &mut proc_macro2::TokenStream;
    let _585: &str;
    let _586: ();
    let mut _587: &mut proc_macro2::TokenStream;
    let _588: &str;
    let _589: ();
    let mut _590: &mut proc_macro2::TokenStream;
    let _591: &str;
    let _592: ();
    let mut _593: &mut proc_macro2::TokenStream;
    let mut _594: proc_macro2::Delimiter;
    let mut _595: proc_macro2::TokenStream;
    let _597: ();
    let _598: &exports::StaticPath;
    let mut _599: &mut proc_macro2::TokenStream;
    let _600: ();
    let mut _601: &mut proc_macro2::TokenStream;
    let _602: ();
    let mut _603: &mut proc_macro2::TokenStream;
    let _604: &str;
    let _605: ();
    let mut _606: &mut proc_macro2::TokenStream;
    let _607: ();
    let mut _608: &mut proc_macro2::TokenStream;
    let mut _609: proc_macro2::Delimiter;
    let mut _610: proc_macro2::TokenStream;
    let _612: ();
    let mut _613: &mut proc_macro2::TokenStream;
    let _614: &str;
    let _615: ();
    let mut _616: &mut proc_macro2::TokenStream;
    let _617: ();
    let mut _618: &mut proc_macro2::TokenStream;
    let _619: &str;
    let _620: ();
    let mut _621: &mut proc_macro2::TokenStream;
    let _622: ();
    let mut _623: &mut proc_macro2::TokenStream;
    let _624: &str;
    let _625: ();
    let _626: &exports::StaticPath;
    let mut _627: &mut proc_macro2::TokenStream;
    let _628: ();
    let mut _629: &mut proc_macro2::TokenStream;
    let _630: ();
    let mut _631: &mut proc_macro2::TokenStream;
    let _632: &str;
    let _633: ();
    let mut _634: &mut proc_macro2::TokenStream;
    let mut _635: proc_macro2::Delimiter;
    let mut _636: proc_macro2::TokenStream;
    let _638: ();
    let _639: &exports::StaticPath;
    let mut _640: &mut proc_macro2::TokenStream;
    let _641: ();
    let mut _642: &mut proc_macro2::TokenStream;
    let mut _644: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _645: &std::vec::Vec<proc_macro2::Ident>;
    let mut _648: (std::slice::Iter<'_, proc_macro2::Ident>, quote::__private::HasIterator);
    let mut _650: bool;
    let mut _652: std::option::Option<&proc_macro2::Ident>;
    let mut _653: &mut std::slice::Iter<'_, proc_macro2::Ident>;
    let mut _654: isize;
    let mut _657: std::option::Option<&proc_macro2::Ident>;
    let mut _658: isize;
    let _660: ();
    let mut _661: &mut proc_macro2::TokenStream;
    let _662: &str;
    let _663: ();
    let _664: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _665: &mut proc_macro2::TokenStream;
    let _666: ();
    let mut _667: &mut proc_macro2::TokenStream;
    let _668: ();
    let _669: &quote::__private::RepInterp<&proc_macro2::Ident>;
    let mut _670: &mut proc_macro2::TokenStream;
    let _671: ();
    let mut _672: &mut proc_macro2::TokenStream;
    let _673: ();
    let mut _674: &mut proc_macro2::TokenStream;
    let _675: &str;
    let _676: ();
    let mut _677: &mut proc_macro2::TokenStream;
    let mut _678: proc_macro2::Delimiter;
    let mut _679: proc_macro2::TokenStream;
    let _680: ();
    let mut _681: &mut proc_macro2::TokenStream;
    scope 1 {
        debug __req => _9;
        scope 3 {
            debug __data => _12;
            scope 5 {
                debug _log => _15;
                scope 7 {
                    debug _form => _18;
                    scope 9 {
                        debug Outcome => _21;
                        scope 11 {
                            debug _Ok => _24;
                            scope 13 {
                                debug _Err => _27;
                                scope 15 {
                                    debug _Some => _30;
                                    scope 17 {
                                        debug _None => _33;
                                        let _36: std::vec::Vec<&str>;
                                        let _37: std::vec::Vec<&str>;
                                        scope 19 {
                                            debug raw_name => _36;
                                            debug raw_value => _37;
                                            let _44: std::vec::Vec<&name::Name>;
                                            let _45: std::vec::Vec<proc_macro2::TokenStream>;
                                            let _46: std::vec::Vec<proc_macro2::Ident>;
                                            let _47: std::vec::Vec<proc_macro2::TokenStream>;
                                            let _48: std::vec::Vec<proc_macro2::TokenStream>;
                                            let _49: std::vec::Vec<proc_macro2::TokenStream>;
                                            scope 20 {
                                                debug name => _44;
                                                debug matcher => _45;
                                                debug ident => _46;
                                                debug init_expr => _47;
                                                debug push_expr => _48;
                                                debug finalize_expr => _49;
                                                scope 21 {
                                                    let mut _54: proc_macro2::TokenStream;
                                                    scope 22 {
                                                        debug _s => _54;
                                                        let mut _145: proc_macro2::TokenStream;
                                                        let mut _559: proc_macro2::TokenStream;
                                                        scope 23 {
                                                            debug has_iter => const ThereIsNoIteratorInRepetition;
                                                            scope 24 {
                                                                debug ident => _85;
                                                                debug i => const HasIterator;
                                                                let _88: quote::__private::HasIterator;
                                                                scope 26 {
                                                                    debug has_iter => const HasIterator;
                                                                    scope 27 {
                                                                        debug init_expr => _89;
                                                                        debug i => const HasIterator;
                                                                        let _92: quote::__private::HasIterator;
                                                                        scope 29 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 30 {
                                                                                let _94: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                let _98: &proc_macro2::Ident;
                                                                                scope 31 {
                                                                                    debug ident => _94;
                                                                                    let _99: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                                    let _103: &proc_macro2::TokenStream;
                                                                                    scope 33 {
                                                                                        debug init_expr => _99;
                                                                                    }
                                                                                    scope 34 {
                                                                                        debug _x => _103;
                                                                                    }
                                                                                }
                                                                                scope 32 {
                                                                                    debug _x => _98;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 28 {
                                                                        let mut _89: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                                                    }
                                                                }
                                                            }
                                                            scope 25 {
                                                                let mut _85: std::slice::Iter<'_, proc_macro2::Ident>;
                                                            }
                                                        }
                                                        scope 35 {
                                                            debug _s => _145;
                                                            let mut _158: proc_macro2::TokenStream;
                                                            let mut _240: proc_macro2::TokenStream;
                                                            let mut _253: proc_macro2::TokenStream;
                                                            scope 36 {
                                                                debug _s => _158;
                                                            }
                                                            scope 37 {
                                                                debug _s => _240;
                                                            }
                                                            scope 38 {
                                                                debug _s => _253;
                                                                scope 39 {
                                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                    scope 40 {
                                                                        debug raw_name => _254;
                                                                        debug i => const HasIterator;
                                                                        let _257: quote::__private::HasIterator;
                                                                        scope 42 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 43 {
                                                                                debug raw_value => _258;
                                                                                debug i => const HasIterator;
                                                                                let _261: quote::__private::HasIterator;
                                                                                scope 45 {
                                                                                    debug has_iter => const HasIterator;
                                                                                    scope 46 {
                                                                                        let _263: quote::__private::RepInterp<&&str>;
                                                                                        let _267: &&str;
                                                                                        scope 47 {
                                                                                            debug raw_name => _263;
                                                                                            let _268: quote::__private::RepInterp<&&str>;
                                                                                            let _272: &&str;
                                                                                            scope 49 {
                                                                                                debug raw_value => _268;
                                                                                                let mut _277: proc_macro2::TokenStream;
                                                                                                scope 51 {
                                                                                                    debug _s => _277;
                                                                                                    let mut _282: proc_macro2::TokenStream;
                                                                                                    scope 52 {
                                                                                                        debug _s => _282;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            scope 50 {
                                                                                                debug _x => _272;
                                                                                            }
                                                                                        }
                                                                                        scope 48 {
                                                                                            debug _x => _267;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            scope 44 {
                                                                                let mut _258: std::slice::Iter<'_, &str>;
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 41 {
                                                                        let mut _254: std::slice::Iter<'_, &str>;
                                                                    }
                                                                }
                                                                scope 53 {
                                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                    scope 54 {
                                                                        debug matcher => _303;
                                                                        debug i => const HasIterator;
                                                                        let _306: quote::__private::HasIterator;
                                                                        scope 56 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 57 {
                                                                                debug push_expr => _307;
                                                                                debug i => const HasIterator;
                                                                                let _310: quote::__private::HasIterator;
                                                                                scope 59 {
                                                                                    debug has_iter => const HasIterator;
                                                                                    scope 60 {
                                                                                        let _312: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                                        let _316: &proc_macro2::TokenStream;
                                                                                        scope 61 {
                                                                                            debug matcher => _312;
                                                                                            let _317: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                                            let _321: &proc_macro2::TokenStream;
                                                                                            scope 63 {
                                                                                                debug push_expr => _317;
                                                                                                let mut _326: proc_macro2::TokenStream;
                                                                                                scope 65 {
                                                                                                    debug _s => _326;
                                                                                                }
                                                                                            }
                                                                                            scope 64 {
                                                                                                debug _x => _321;
                                                                                            }
                                                                                        }
                                                                                        scope 62 {
                                                                                            debug _x => _316;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            scope 58 {
                                                                                let mut _307: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 55 {
                                                                        let mut _303: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 66 {
                                                            debug has_iter => const ThereIsNoIteratorInRepetition;
                                                            scope 67 {
                                                                debug ident => _351;
                                                                debug i => const HasIterator;
                                                                let _354: quote::__private::HasIterator;
                                                                scope 69 {
                                                                    debug has_iter => const HasIterator;
                                                                    scope 70 {
                                                                        debug finalize_expr => _355;
                                                                        debug i => const HasIterator;
                                                                        let _358: quote::__private::HasIterator;
                                                                        scope 72 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 73 {
                                                                                debug _Ok => _359;
                                                                                debug i => const ThereIsNoIteratorInRepetition;
                                                                                let _362: quote::__private::HasIterator;
                                                                                scope 75 {
                                                                                    debug has_iter => const HasIterator;
                                                                                    scope 76 {
                                                                                        debug _Some => _363;
                                                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                                                        let _366: quote::__private::HasIterator;
                                                                                        scope 78 {
                                                                                            debug has_iter => const HasIterator;
                                                                                            scope 79 {
                                                                                                debug _Err => _367;
                                                                                                debug i => const ThereIsNoIteratorInRepetition;
                                                                                                let _370: quote::__private::HasIterator;
                                                                                                scope 81 {
                                                                                                    debug has_iter => const HasIterator;
                                                                                                    scope 82 {
                                                                                                        debug _form => _371;
                                                                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                                                                        let _374: quote::__private::HasIterator;
                                                                                                        scope 84 {
                                                                                                            debug has_iter => const HasIterator;
                                                                                                            scope 85 {
                                                                                                                debug name => _375;
                                                                                                                debug i => const HasIterator;
                                                                                                                let _378: quote::__private::HasIterator;
                                                                                                                scope 87 {
                                                                                                                    debug has_iter => const HasIterator;
                                                                                                                    scope 88 {
                                                                                                                        debug _None => _379;
                                                                                                                        debug i => const ThereIsNoIteratorInRepetition;
                                                                                                                        let _382: quote::__private::HasIterator;
                                                                                                                        scope 90 {
                                                                                                                            debug has_iter => const HasIterator;
                                                                                                                            scope 91 {
                                                                                                                                let _384: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                                                                let _388: &proc_macro2::Ident;
                                                                                                                                scope 92 {
                                                                                                                                    debug ident => _384;
                                                                                                                                    let _389: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                                                                                    let _393: &proc_macro2::TokenStream;
                                                                                                                                    scope 94 {
                                                                                                                                        debug finalize_expr => _389;
                                                                                                                                        let _394: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                        let _397: &exports::StaticPath;
                                                                                                                                        scope 96 {
                                                                                                                                            debug _Ok => _394;
                                                                                                                                            let _398: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                            let _401: &exports::StaticPath;
                                                                                                                                            scope 98 {
                                                                                                                                                debug _Some => _398;
                                                                                                                                                let _402: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                                let _405: &exports::StaticPath;
                                                                                                                                                scope 100 {
                                                                                                                                                    debug _Err => _402;
                                                                                                                                                    let _406: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                                    let _409: &exports::StaticPath;
                                                                                                                                                    scope 102 {
                                                                                                                                                        debug _form => _406;
                                                                                                                                                        let _410: quote::__private::RepInterp<&&name::Name>;
                                                                                                                                                        let _414: &&name::Name;
                                                                                                                                                        scope 104 {
                                                                                                                                                            debug name => _410;
                                                                                                                                                            let _415: quote::__private::RepInterp<&exports::StaticPath>;
                                                                                                                                                            let _418: &exports::StaticPath;
                                                                                                                                                            scope 106 {
                                                                                                                                                                debug _None => _415;
                                                                                                                                                                let mut _437: proc_macro2::TokenStream;
                                                                                                                                                                scope 108 {
                                                                                                                                                                    debug _s => _437;
                                                                                                                                                                    let mut _445: proc_macro2::TokenStream;
                                                                                                                                                                    let mut _458: proc_macro2::TokenStream;
                                                                                                                                                                    let mut _471: proc_macro2::TokenStream;
                                                                                                                                                                    let mut _481: proc_macro2::TokenStream;
                                                                                                                                                                    scope 109 {
                                                                                                                                                                        debug _s => _445;
                                                                                                                                                                    }
                                                                                                                                                                    scope 110 {
                                                                                                                                                                        debug _s => _458;
                                                                                                                                                                    }
                                                                                                                                                                    scope 111 {
                                                                                                                                                                        debug _s => _471;
                                                                                                                                                                    }
                                                                                                                                                                    scope 112 {
                                                                                                                                                                        debug _s => _481;
                                                                                                                                                                        let mut _494: proc_macro2::TokenStream;
                                                                                                                                                                        scope 113 {
                                                                                                                                                                            debug _s => _494;
                                                                                                                                                                            let mut _507: proc_macro2::TokenStream;
                                                                                                                                                                            scope 114 {
                                                                                                                                                                                debug _s => _507;
                                                                                                                                                                                let mut _525: proc_macro2::TokenStream;
                                                                                                                                                                                scope 115 {
                                                                                                                                                                                    debug _s => _525;
                                                                                                                                                                                }
                                                                                                                                                                            }
                                                                                                                                                                        }
                                                                                                                                                                    }
                                                                                                                                                                }
                                                                                                                                                            }
                                                                                                                                                            scope 107 {
                                                                                                                                                                debug _x => _418;
                                                                                                                                                            }
                                                                                                                                                        }
                                                                                                                                                        scope 105 {
                                                                                                                                                            debug _x => _414;
                                                                                                                                                        }
                                                                                                                                                    }
                                                                                                                                                    scope 103 {
                                                                                                                                                        debug _x => _409;
                                                                                                                                                    }
                                                                                                                                                }
                                                                                                                                                scope 101 {
                                                                                                                                                    debug _x => _405;
                                                                                                                                                }
                                                                                                                                            }
                                                                                                                                            scope 99 {
                                                                                                                                                debug _x => _401;
                                                                                                                                            }
                                                                                                                                        }
                                                                                                                                        scope 97 {
                                                                                                                                            debug _x => _397;
                                                                                                                                        }
                                                                                                                                    }
                                                                                                                                    scope 95 {
                                                                                                                                        debug _x => _393;
                                                                                                                                    }
                                                                                                                                }
                                                                                                                                scope 93 {
                                                                                                                                    debug _x => _388;
                                                                                                                                }
                                                                                                                            }
                                                                                                                        }
                                                                                                                    }
                                                                                                                    scope 89 {
                                                                                                                        let mut _379: &exports::StaticPath;
                                                                                                                    }
                                                                                                                }
                                                                                                            }
                                                                                                            scope 86 {
                                                                                                                let mut _375: std::slice::Iter<'_, &name::Name>;
                                                                                                            }
                                                                                                        }
                                                                                                    }
                                                                                                    scope 83 {
                                                                                                        let mut _371: &exports::StaticPath;
                                                                                                    }
                                                                                                }
                                                                                            }
                                                                                            scope 80 {
                                                                                                let mut _367: &exports::StaticPath;
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 77 {
                                                                                        let mut _363: &exports::StaticPath;
                                                                                    }
                                                                                }
                                                                            }
                                                                            scope 74 {
                                                                                let mut _359: &exports::StaticPath;
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 71 {
                                                                        let mut _355: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                                                    }
                                                                }
                                                            }
                                                            scope 68 {
                                                                let mut _351: std::slice::Iter<'_, proc_macro2::Ident>;
                                                            }
                                                        }
                                                        scope 116 {
                                                            debug _s => _559;
                                                            let mut _574: proc_macro2::TokenStream;
                                                            let mut _596: proc_macro2::TokenStream;
                                                            let mut _637: proc_macro2::TokenStream;
                                                            scope 117 {
                                                                debug _s => _574;
                                                            }
                                                            scope 118 {
                                                                debug _s => _596;
                                                                let mut _611: proc_macro2::TokenStream;
                                                                scope 119 {
                                                                    debug _s => _611;
                                                                }
                                                            }
                                                            scope 120 {
                                                                debug _s => _637;
                                                            }
                                                        }
                                                        scope 121 {
                                                            debug has_iter => const ThereIsNoIteratorInRepetition;
                                                            scope 122 {
                                                                debug ident => _643;
                                                                debug i => const HasIterator;
                                                                let _646: quote::__private::HasIterator;
                                                                scope 124 {
                                                                    debug has_iter => const HasIterator;
                                                                    scope 125 {
                                                                        debug ident => _647;
                                                                        debug i => const HasIterator;
                                                                        let _649: quote::__private::HasIterator;
                                                                        scope 127 {
                                                                            debug has_iter => const HasIterator;
                                                                            scope 128 {
                                                                                let _651: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                let _655: &proc_macro2::Ident;
                                                                                scope 129 {
                                                                                    debug ident => _651;
                                                                                    let _656: quote::__private::RepInterp<&proc_macro2::Ident>;
                                                                                    let _659: &proc_macro2::Ident;
                                                                                    scope 131 {
                                                                                        debug ident => _656;
                                                                                    }
                                                                                    scope 132 {
                                                                                        debug _x => _659;
                                                                                    }
                                                                                }
                                                                                scope 130 {
                                                                                    debug _x => _655;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 126 {
                                                                        let mut _647: std::slice::Iter<'_, proc_macro2::Ident>;
                                                                    }
                                                                }
                                                            }
                                                            scope 123 {
                                                                let mut _643: std::slice::Iter<'_, proc_macro2::Ident>;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    scope 18 {
                                        let _33: exports::StaticPath;
                                    }
                                }
                                scope 16 {
                                    let _30: exports::StaticPath;
                                }
                            }
                            scope 14 {
                                let _27: exports::StaticPath;
                            }
                        }
                        scope 12 {
                            let _24: exports::StaticPath;
                        }
                    }
                    scope 10 {
                        let _21: exports::StaticPath;
                    }
                }
                scope 8 {
                    let _18: exports::StaticPath;
                }
            }
            scope 6 {
                let _15: exports::StaticPath;
            }
        }
        scope 4 {
            let _12: exports::StaticPath;
        }
    }
    scope 2 {
        let _9: exports::StaticPath;
    }

    bb0: {
        _3 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _2 = Vec::<Parameter>::is_empty(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb7, otherwise: bb2];
    }

    bb2: {
        _8 = route::<impl route::parse::Route>::query_guards(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &mut _8;
        _6 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}> as Iterator>::next(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = &_6;
        _4 = Option::<&Guard>::is_none(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _4) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Option::<TokenStream2>::None;
        goto -> bb297;
    }

    bb7: {
        _11 = proc_macro2::Span::call_site() -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Option::<proc_macro2::Span>::Some(move _11);
        _9 = StaticPath(move _10, const "__req");
        _14 = proc_macro2::Span::call_site() -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = Option::<proc_macro2::Span>::Some(move _14);
        _12 = StaticPath(move _13, const "__data");
        _17 = proc_macro2::Span::call_site() -> [return: bb10, unwind continue];
    }

    bb10: {
        _16 = Option::<proc_macro2::Span>::Some(move _17);
        _15 = StaticPath(move _16, const "::rocket::log");
        _20 = proc_macro2::Span::call_site() -> [return: bb11, unwind continue];
    }

    bb11: {
        _19 = Option::<proc_macro2::Span>::Some(move _20);
        _18 = StaticPath(move _19, const "::rocket::form::prelude");
        _23 = proc_macro2::Span::call_site() -> [return: bb12, unwind continue];
    }

    bb12: {
        _22 = Option::<proc_macro2::Span>::Some(move _23);
        _21 = StaticPath(move _22, const "::rocket::outcome::Outcome");
        _26 = proc_macro2::Span::call_site() -> [return: bb13, unwind continue];
    }

    bb13: {
        _25 = Option::<proc_macro2::Span>::Some(move _26);
        _24 = StaticPath(move _25, const "::std::result::Result::Ok");
        _29 = proc_macro2::Span::call_site() -> [return: bb14, unwind continue];
    }

    bb14: {
        _28 = Option::<proc_macro2::Span>::Some(move _29);
        _27 = StaticPath(move _28, const "::std::result::Result::Err");
        _32 = proc_macro2::Span::call_site() -> [return: bb15, unwind continue];
    }

    bb15: {
        _31 = Option::<proc_macro2::Span>::Some(move _32);
        _30 = StaticPath(move _31, const "::std::option::Option::Some");
        _35 = proc_macro2::Span::call_site() -> [return: bb16, unwind continue];
    }

    bb16: {
        _34 = Option::<proc_macro2::Span>::Some(move _35);
        _33 = StaticPath(move _34, const "::std::option::Option::None");
        _43 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _42 = <Vec<Parameter> as std::ops::Deref>::deref(move _43) -> [return: bb17, unwind continue];
    }

    bb17: {
        _41 = core::slice::<impl [Parameter]>::iter(_42) -> [return: bb18, unwind continue];
    }

    bb18: {
        _40 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&name::Name, {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}>(move _41, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}) -> [return: bb19, unwind continue];
    }

    bb19: {
        _39 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}> as Iterator>::map::<(&str, &str), {closure@core/codegen/src/attribute/route/mod.rs:46:14: 46:20}>(move _40, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:46:14: 46:20}) -> [return: bb20, unwind continue];
    }

    bb20: {
        _38 = <Map<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}>, {closure@core/codegen/src/attribute/route/mod.rs:46:14: 46:20}> as Split2<&str, &str>>::split2(move _39) -> [return: bb21, unwind continue];
    }

    bb21: {
        _36 = move (_38.0: std::vec::Vec<&str>);
        _37 = move (_38.1: std::vec::Vec<&str>);
        _52 = route::<impl route::parse::Route>::query_guards(_1) -> [return: bb22, unwind: bb325];
    }

    bb22: {
        _51 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}> as Iterator>::map::<(&name::Name, TokenStream2, proc_macro2::Ident, TokenStream2, TokenStream2, TokenStream2), {closure@core/codegen/src/attribute/route/mod.rs:54:14: 54:21}>(move _52, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:54:14: 54:21}) -> [return: bb23, unwind: bb325];
    }

    bb23: {
        _50 = <Map<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>, {closure@core/codegen/src/attribute/route/mod.rs:54:14: 54:21}> as Split6<&name::Name, TokenStream2, proc_macro2::Ident, TokenStream2, TokenStream2, TokenStream2>>::split6(move _51) -> [return: bb24, unwind: bb325];
    }

    bb24: {
        _44 = move (_50.0: std::vec::Vec<&name::Name>);
        _45 = move (_50.1: std::vec::Vec<proc_macro2::TokenStream>);
        _46 = move (_50.2: std::vec::Vec<proc_macro2::Ident>);
        _47 = move (_50.3: std::vec::Vec<proc_macro2::TokenStream>);
        _48 = move (_50.4: std::vec::Vec<proc_macro2::TokenStream>);
        _49 = move (_50.5: std::vec::Vec<proc_macro2::TokenStream>);
        _54 = TokenStream2::new() -> [return: bb25, unwind: bb319];
    }

    bb25: {
        _56 = &mut _54;
        _57 = const "let";
        _55 = push_ident(_56, _57) -> [return: bb26, unwind: bb318];
    }

    bb26: {
        _59 = &mut _54;
        _60 = const "mut";
        _58 = push_ident(_59, _60) -> [return: bb27, unwind: bb318];
    }

    bb27: {
        _62 = &mut _54;
        _63 = const "__e";
        _61 = push_ident(_62, _63) -> [return: bb28, unwind: bb318];
    }

    bb28: {
        _65 = &mut _54;
        _64 = push_eq(_65) -> [return: bb29, unwind: bb318];
    }

    bb29: {
        _67 = &_18;
        _68 = &mut _54;
        _66 = <StaticPath as ToTokens>::to_tokens(_67, _68) -> [return: bb30, unwind: bb318];
    }

    bb30: {
        _70 = &mut _54;
        _69 = push_colon2(_70) -> [return: bb31, unwind: bb318];
    }

    bb31: {
        _72 = &mut _54;
        _73 = const "Errors";
        _71 = push_ident(_72, _73) -> [return: bb32, unwind: bb318];
    }

    bb32: {
        _75 = &mut _54;
        _74 = push_colon2(_75) -> [return: bb33, unwind: bb318];
    }

    bb33: {
        _77 = &mut _54;
        _78 = const "new";
        _76 = push_ident(_77, _78) -> [return: bb34, unwind: bb318];
    }

    bb34: {
        _80 = &mut _54;
        _81 = proc_macro2::Delimiter::Parenthesis;
        _82 = TokenStream2::new() -> [return: bb35, unwind: bb318];
    }

    bb35: {
        _79 = push_group(_80, move _81, move _82) -> [return: bb36, unwind: bb318];
    }

    bb36: {
        _84 = &mut _54;
        _83 = push_semi(_84) -> [return: bb37, unwind: bb318];
    }

    bb37: {
        _87 = &_46;
        _86 = <Vec<proc_macro2::Ident> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _87) -> [return: bb38, unwind: bb318];
    }

    bb38: {
        _85 = move (_86.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _88 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb39, unwind: bb318];
    }

    bb39: {
        _91 = &_47;
        _90 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _91) -> [return: bb40, unwind: bb318];
    }

    bb40: {
        _89 = move (_90.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _92 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb328, unwind: bb318];
    }

    bb41: {
        _93 = const true;
        switchInt(move _93) -> [0: bb53, otherwise: bb42];
    }

    bb42: {
        _96 = &mut _85;
        _95 = <std::slice::Iter<'_, proc_macro2::Ident> as Iterator>::next(move _96) -> [return: bb43, unwind: bb318];
    }

    bb43: {
        _97 = discriminant(_95);
        switchInt(move _97) -> [0: bb53, 1: bb45, otherwise: bb44];
    }

    bb44: {
        unreachable;
    }

    bb45: {
        _98 = ((_95 as Some).0: &proc_macro2::Ident);
        _94 = RepInterp::<&proc_macro2::Ident>(_98);
        _101 = &mut _89;
        _100 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _101) -> [return: bb46, unwind: bb318];
    }

    bb46: {
        _102 = discriminant(_100);
        switchInt(move _102) -> [0: bb53, 1: bb47, otherwise: bb44];
    }

    bb47: {
        _103 = ((_100 as Some).0: &proc_macro2::TokenStream);
        _99 = RepInterp::<&TokenStream2>(_103);
        _105 = &mut _54;
        _106 = const "let";
        _104 = push_ident(_105, _106) -> [return: bb48, unwind: bb318];
    }

    bb48: {
        _108 = &mut _54;
        _109 = const "mut";
        _107 = push_ident(_108, _109) -> [return: bb49, unwind: bb318];
    }

    bb49: {
        _111 = &_94;
        _112 = &mut _54;
        _110 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_111, _112) -> [return: bb50, unwind: bb318];
    }

    bb50: {
        _114 = &mut _54;
        _113 = push_eq(_114) -> [return: bb51, unwind: bb318];
    }

    bb51: {
        _116 = &_99;
        _117 = &mut _54;
        _115 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_116, _117) -> [return: bb52, unwind: bb318];
    }

    bb52: {
        _119 = &mut _54;
        _118 = push_semi(_119) -> [return: bb329, unwind: bb318];
    }

    bb53: {
        _121 = &mut _54;
        _122 = const "for";
        _120 = push_ident(_121, _122) -> [return: bb54, unwind: bb318];
    }

    bb54: {
        _124 = &mut _54;
        _125 = const "_f";
        _123 = push_ident(_124, _125) -> [return: bb55, unwind: bb318];
    }

    bb55: {
        _127 = &mut _54;
        _128 = const "in";
        _126 = push_ident(_127, _128) -> [return: bb56, unwind: bb318];
    }

    bb56: {
        _130 = &_9;
        _131 = &mut _54;
        _129 = <StaticPath as ToTokens>::to_tokens(_130, _131) -> [return: bb57, unwind: bb318];
    }

    bb57: {
        _133 = &mut _54;
        _132 = push_dot(_133) -> [return: bb58, unwind: bb318];
    }

    bb58: {
        _135 = &mut _54;
        _136 = const "query_fields";
        _134 = push_ident(_135, _136) -> [return: bb59, unwind: bb318];
    }

    bb59: {
        _138 = &mut _54;
        _139 = proc_macro2::Delimiter::Parenthesis;
        _140 = TokenStream2::new() -> [return: bb60, unwind: bb318];
    }

    bb60: {
        _137 = push_group(_138, move _139, move _140) -> [return: bb61, unwind: bb318];
    }

    bb61: {
        _142 = &mut _54;
        _143 = proc_macro2::Delimiter::Brace;
        _145 = TokenStream2::new() -> [return: bb62, unwind: bb318];
    }

    bb62: {
        _147 = &mut _145;
        _148 = const "let";
        _146 = push_ident(_147, _148) -> [return: bb63, unwind: bb317];
    }

    bb63: {
        _150 = &mut _145;
        _151 = const "_raw";
        _149 = push_ident(_150, _151) -> [return: bb64, unwind: bb317];
    }

    bb64: {
        _153 = &mut _145;
        _152 = push_eq(_153) -> [return: bb65, unwind: bb317];
    }

    bb65: {
        _155 = &mut _145;
        _156 = proc_macro2::Delimiter::Parenthesis;
        _158 = TokenStream2::new() -> [return: bb66, unwind: bb317];
    }

    bb66: {
        _160 = &mut _158;
        _161 = const "_f";
        _159 = push_ident(_160, _161) -> [return: bb67, unwind: bb316];
    }

    bb67: {
        _163 = &mut _158;
        _162 = push_dot(_163) -> [return: bb68, unwind: bb316];
    }

    bb68: {
        _165 = &mut _158;
        _166 = const "name";
        _164 = push_ident(_165, _166) -> [return: bb69, unwind: bb316];
    }

    bb69: {
        _168 = &mut _158;
        _167 = push_dot(_168) -> [return: bb70, unwind: bb316];
    }

    bb70: {
        _170 = &mut _158;
        _171 = const "source";
        _169 = push_ident(_170, _171) -> [return: bb71, unwind: bb316];
    }

    bb71: {
        _173 = &mut _158;
        _174 = proc_macro2::Delimiter::Parenthesis;
        _175 = TokenStream2::new() -> [return: bb72, unwind: bb316];
    }

    bb72: {
        _172 = push_group(_173, move _174, move _175) -> [return: bb73, unwind: bb316];
    }

    bb73: {
        _177 = &mut _158;
        _176 = push_dot(_177) -> [return: bb74, unwind: bb316];
    }

    bb74: {
        _179 = &mut _158;
        _180 = const "as_str";
        _178 = push_ident(_179, _180) -> [return: bb75, unwind: bb316];
    }

    bb75: {
        _182 = &mut _158;
        _183 = proc_macro2::Delimiter::Parenthesis;
        _184 = TokenStream2::new() -> [return: bb76, unwind: bb316];
    }

    bb76: {
        _181 = push_group(_182, move _183, move _184) -> [return: bb77, unwind: bb316];
    }

    bb77: {
        _186 = &mut _158;
        _185 = push_comma(_186) -> [return: bb78, unwind: bb316];
    }

    bb78: {
        _188 = &mut _158;
        _189 = const "_f";
        _187 = push_ident(_188, _189) -> [return: bb79, unwind: bb316];
    }

    bb79: {
        _191 = &mut _158;
        _190 = push_dot(_191) -> [return: bb80, unwind: bb316];
    }

    bb80: {
        _193 = &mut _158;
        _194 = const "value";
        _192 = push_ident(_193, _194) -> [return: bb81, unwind: bb316];
    }

    bb81: {
        _157 = move _158;
        _154 = push_group(_155, move _156, move _157) -> [return: bb82, unwind: bb317];
    }

    bb82: {
        _196 = &mut _145;
        _195 = push_semi(_196) -> [return: bb83, unwind: bb317];
    }

    bb83: {
        _198 = &mut _145;
        _199 = const "let";
        _197 = push_ident(_198, _199) -> [return: bb84, unwind: bb317];
    }

    bb84: {
        _201 = &mut _145;
        _202 = const "_key";
        _200 = push_ident(_201, _202) -> [return: bb85, unwind: bb317];
    }

    bb85: {
        _204 = &mut _145;
        _203 = push_eq(_204) -> [return: bb86, unwind: bb317];
    }

    bb86: {
        _206 = &mut _145;
        _207 = const "_f";
        _205 = push_ident(_206, _207) -> [return: bb87, unwind: bb317];
    }

    bb87: {
        _209 = &mut _145;
        _208 = push_dot(_209) -> [return: bb88, unwind: bb317];
    }

    bb88: {
        _211 = &mut _145;
        _212 = const "name";
        _210 = push_ident(_211, _212) -> [return: bb89, unwind: bb317];
    }

    bb89: {
        _214 = &mut _145;
        _213 = push_dot(_214) -> [return: bb90, unwind: bb317];
    }

    bb90: {
        _216 = &mut _145;
        _217 = const "key_lossy";
        _215 = push_ident(_216, _217) -> [return: bb91, unwind: bb317];
    }

    bb91: {
        _219 = &mut _145;
        _220 = proc_macro2::Delimiter::Parenthesis;
        _221 = TokenStream2::new() -> [return: bb92, unwind: bb317];
    }

    bb92: {
        _218 = push_group(_219, move _220, move _221) -> [return: bb93, unwind: bb317];
    }

    bb93: {
        _223 = &mut _145;
        _222 = push_dot(_223) -> [return: bb94, unwind: bb317];
    }

    bb94: {
        _225 = &mut _145;
        _226 = const "as_str";
        _224 = push_ident(_225, _226) -> [return: bb95, unwind: bb317];
    }

    bb95: {
        _228 = &mut _145;
        _229 = proc_macro2::Delimiter::Parenthesis;
        _230 = TokenStream2::new() -> [return: bb96, unwind: bb317];
    }

    bb96: {
        _227 = push_group(_228, move _229, move _230) -> [return: bb97, unwind: bb317];
    }

    bb97: {
        _232 = &mut _145;
        _231 = push_semi(_232) -> [return: bb98, unwind: bb317];
    }

    bb98: {
        _234 = &mut _145;
        _235 = const "match";
        _233 = push_ident(_234, _235) -> [return: bb99, unwind: bb317];
    }

    bb99: {
        _237 = &mut _145;
        _238 = proc_macro2::Delimiter::Parenthesis;
        _240 = TokenStream2::new() -> [return: bb100, unwind: bb317];
    }

    bb100: {
        _242 = &mut _240;
        _243 = const "_raw";
        _241 = push_ident(_242, _243) -> [return: bb101, unwind: bb315];
    }

    bb101: {
        _245 = &mut _240;
        _244 = push_comma(_245) -> [return: bb102, unwind: bb315];
    }

    bb102: {
        _247 = &mut _240;
        _248 = const "_key";
        _246 = push_ident(_247, _248) -> [return: bb103, unwind: bb315];
    }

    bb103: {
        _239 = move _240;
        _236 = push_group(_237, move _238, move _239) -> [return: bb104, unwind: bb317];
    }

    bb104: {
        _250 = &mut _145;
        _251 = proc_macro2::Delimiter::Brace;
        _253 = TokenStream2::new() -> [return: bb105, unwind: bb317];
    }

    bb105: {
        _256 = &_36;
        _255 = <Vec<&str> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _256) -> [return: bb106, unwind: bb314];
    }

    bb106: {
        _254 = move (_255.0: std::slice::Iter<'_, &str>);
        _257 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb107, unwind: bb314];
    }

    bb107: {
        _260 = &_37;
        _259 = <Vec<&str> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _260) -> [return: bb108, unwind: bb314];
    }

    bb108: {
        _258 = move (_259.0: std::slice::Iter<'_, &str>);
        _261 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb330, unwind: bb314];
    }

    bb109: {
        _262 = const true;
        switchInt(move _262) -> [0: bb127, otherwise: bb110];
    }

    bb110: {
        _265 = &mut _254;
        _264 = <std::slice::Iter<'_, &str> as Iterator>::next(move _265) -> [return: bb111, unwind: bb314];
    }

    bb111: {
        _266 = discriminant(_264);
        switchInt(move _266) -> [0: bb127, 1: bb112, otherwise: bb44];
    }

    bb112: {
        _267 = ((_264 as Some).0: &&str);
        _263 = RepInterp::<&&str>(_267);
        _270 = &mut _258;
        _269 = <std::slice::Iter<'_, &str> as Iterator>::next(move _270) -> [return: bb113, unwind: bb314];
    }

    bb113: {
        _271 = discriminant(_269);
        switchInt(move _271) -> [0: bb127, 1: bb114, otherwise: bb44];
    }

    bb114: {
        _272 = ((_269 as Some).0: &&str);
        _268 = RepInterp::<&&str>(_272);
        _274 = &mut _253;
        _275 = proc_macro2::Delimiter::Parenthesis;
        _277 = TokenStream2::new() -> [return: bb115, unwind: bb314];
    }

    bb115: {
        _279 = &mut _277;
        _280 = proc_macro2::Delimiter::Parenthesis;
        _282 = TokenStream2::new() -> [return: bb116, unwind: bb313];
    }

    bb116: {
        _284 = &_263;
        _285 = &mut _282;
        _283 = <RepInterp<&&str> as ToTokens>::to_tokens(_284, _285) -> [return: bb117, unwind: bb312];
    }

    bb117: {
        _287 = &mut _282;
        _286 = push_comma(_287) -> [return: bb118, unwind: bb312];
    }

    bb118: {
        _289 = &_268;
        _290 = &mut _282;
        _288 = <RepInterp<&&str> as ToTokens>::to_tokens(_289, _290) -> [return: bb119, unwind: bb312];
    }

    bb119: {
        _281 = move _282;
        _278 = push_group(_279, move _280, move _281) -> [return: bb120, unwind: bb313];
    }

    bb120: {
        _292 = &mut _277;
        _291 = push_comma(_292) -> [return: bb121, unwind: bb313];
    }

    bb121: {
        _294 = &mut _277;
        _293 = push_underscore(_294) -> [return: bb122, unwind: bb313];
    }

    bb122: {
        _276 = move _277;
        _273 = push_group(_274, move _275, move _276) -> [return: bb123, unwind: bb314];
    }

    bb123: {
        _296 = &mut _253;
        _295 = push_fat_arrow(_296) -> [return: bb124, unwind: bb314];
    }

    bb124: {
        _298 = &mut _253;
        _299 = proc_macro2::Delimiter::Brace;
        _300 = TokenStream2::new() -> [return: bb125, unwind: bb314];
    }

    bb125: {
        _297 = push_group(_298, move _299, move _300) -> [return: bb126, unwind: bb314];
    }

    bb126: {
        _302 = &mut _253;
        _301 = push_comma(_302) -> [return: bb331, unwind: bb314];
    }

    bb127: {
        _305 = &_45;
        _304 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _305) -> [return: bb128, unwind: bb314];
    }

    bb128: {
        _303 = move (_304.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _306 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb129, unwind: bb314];
    }

    bb129: {
        _309 = &_48;
        _308 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _309) -> [return: bb130, unwind: bb314];
    }

    bb130: {
        _307 = move (_308.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _310 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb332, unwind: bb314];
    }

    bb131: {
        _311 = const true;
        switchInt(move _311) -> [0: bb144, otherwise: bb132];
    }

    bb132: {
        _314 = &mut _303;
        _313 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _314) -> [return: bb133, unwind: bb314];
    }

    bb133: {
        _315 = discriminant(_313);
        switchInt(move _315) -> [0: bb144, 1: bb134, otherwise: bb44];
    }

    bb134: {
        _316 = ((_313 as Some).0: &proc_macro2::TokenStream);
        _312 = RepInterp::<&TokenStream2>(_316);
        _319 = &mut _307;
        _318 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _319) -> [return: bb135, unwind: bb314];
    }

    bb135: {
        _320 = discriminant(_318);
        switchInt(move _320) -> [0: bb144, 1: bb136, otherwise: bb44];
    }

    bb136: {
        _321 = ((_318 as Some).0: &proc_macro2::TokenStream);
        _317 = RepInterp::<&TokenStream2>(_321);
        _323 = &mut _253;
        _324 = proc_macro2::Delimiter::Parenthesis;
        _326 = TokenStream2::new() -> [return: bb137, unwind: bb314];
    }

    bb137: {
        _328 = &mut _326;
        _327 = push_underscore(_328) -> [return: bb138, unwind: bb311];
    }

    bb138: {
        _330 = &mut _326;
        _329 = push_comma(_330) -> [return: bb139, unwind: bb311];
    }

    bb139: {
        _332 = &_312;
        _333 = &mut _326;
        _331 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_332, _333) -> [return: bb140, unwind: bb311];
    }

    bb140: {
        _325 = move _326;
        _322 = push_group(_323, move _324, move _325) -> [return: bb141, unwind: bb314];
    }

    bb141: {
        _335 = &mut _253;
        _334 = push_fat_arrow(_335) -> [return: bb142, unwind: bb314];
    }

    bb142: {
        _337 = &_317;
        _338 = &mut _253;
        _336 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_337, _338) -> [return: bb143, unwind: bb314];
    }

    bb143: {
        _340 = &mut _253;
        _339 = push_comma(_340) -> [return: bb333, unwind: bb314];
    }

    bb144: {
        _342 = &mut _253;
        _341 = push_underscore(_342) -> [return: bb145, unwind: bb314];
    }

    bb145: {
        _344 = &mut _253;
        _343 = push_fat_arrow(_344) -> [return: bb146, unwind: bb314];
    }

    bb146: {
        _346 = &mut _253;
        _347 = proc_macro2::Delimiter::Brace;
        _348 = TokenStream2::new() -> [return: bb147, unwind: bb314];
    }

    bb147: {
        _345 = push_group(_346, move _347, move _348) -> [return: bb148, unwind: bb314];
    }

    bb148: {
        _350 = &mut _253;
        _349 = push_comma(_350) -> [return: bb149, unwind: bb314];
    }

    bb149: {
        _252 = move _253;
        _249 = push_group(_250, move _251, move _252) -> [return: bb150, unwind: bb317];
    }

    bb150: {
        _144 = move _145;
        _141 = push_group(_142, move _143, move _144) -> [return: bb151, unwind: bb318];
    }

    bb151: {
        _353 = &_46;
        _352 = <Vec<proc_macro2::Ident> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _353) -> [return: bb152, unwind: bb318];
    }

    bb152: {
        _351 = move (_352.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _354 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb153, unwind: bb318];
    }

    bb153: {
        _357 = &_49;
        _356 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _357) -> [return: bb154, unwind: bb318];
    }

    bb154: {
        _355 = move (_356.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _358 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb155, unwind: bb318];
    }

    bb155: {
        _361 = &_24;
        _360 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _361) -> [return: bb156, unwind: bb318];
    }

    bb156: {
        _359 = (_360.0: &exports::StaticPath);
        _362 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb157, unwind: bb318];
    }

    bb157: {
        _365 = &_30;
        _364 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _365) -> [return: bb158, unwind: bb318];
    }

    bb158: {
        _363 = (_364.0: &exports::StaticPath);
        _366 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb159, unwind: bb318];
    }

    bb159: {
        _369 = &_27;
        _368 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _369) -> [return: bb160, unwind: bb318];
    }

    bb160: {
        _367 = (_368.0: &exports::StaticPath);
        _370 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb161, unwind: bb318];
    }

    bb161: {
        _373 = &_18;
        _372 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _373) -> [return: bb162, unwind: bb318];
    }

    bb162: {
        _371 = (_372.0: &exports::StaticPath);
        _374 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb163, unwind: bb318];
    }

    bb163: {
        _377 = &_44;
        _376 = <Vec<&name::Name> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _377) -> [return: bb164, unwind: bb318];
    }

    bb164: {
        _375 = move (_376.0: std::slice::Iter<'_, &name::Name>);
        _378 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb165, unwind: bb318];
    }

    bb165: {
        _381 = &_33;
        _380 = <StaticPath as quote::__private::ext::RepToTokensExt>::quote_into_iter(move _381) -> [return: bb166, unwind: bb318];
    }

    bb166: {
        _379 = (_380.0: &exports::StaticPath);
        _382 = <HasIterator as std::ops::BitOr<ThereIsNoIteratorInRepetition>>::bitor(const HasIterator, const ThereIsNoIteratorInRepetition) -> [return: bb334, unwind: bb318];
    }

    bb167: {
        _383 = const true;
        switchInt(move _383) -> [0: bb230, otherwise: bb168];
    }

    bb168: {
        _386 = &mut _351;
        _385 = <std::slice::Iter<'_, proc_macro2::Ident> as Iterator>::next(move _386) -> [return: bb169, unwind: bb318];
    }

    bb169: {
        _387 = discriminant(_385);
        switchInt(move _387) -> [0: bb230, 1: bb170, otherwise: bb44];
    }

    bb170: {
        _388 = ((_385 as Some).0: &proc_macro2::Ident);
        _384 = RepInterp::<&proc_macro2::Ident>(_388);
        _391 = &mut _355;
        _390 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _391) -> [return: bb171, unwind: bb318];
    }

    bb171: {
        _392 = discriminant(_390);
        switchInt(move _392) -> [0: bb230, 1: bb172, otherwise: bb44];
    }

    bb172: {
        _393 = ((_390 as Some).0: &proc_macro2::TokenStream);
        _389 = RepInterp::<&TokenStream2>(_393);
        _395 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_359) -> [return: bb173, unwind: bb318];
    }

    bb173: {
        _396 = discriminant(_395);
        switchInt(move _396) -> [0: bb230, 1: bb174, otherwise: bb44];
    }

    bb174: {
        _397 = ((_395 as Some).0: &exports::StaticPath);
        _394 = RepInterp::<&StaticPath>(_397);
        _399 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_363) -> [return: bb175, unwind: bb318];
    }

    bb175: {
        _400 = discriminant(_399);
        switchInt(move _400) -> [0: bb230, 1: bb176, otherwise: bb44];
    }

    bb176: {
        _401 = ((_399 as Some).0: &exports::StaticPath);
        _398 = RepInterp::<&StaticPath>(_401);
        _403 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_367) -> [return: bb177, unwind: bb318];
    }

    bb177: {
        _404 = discriminant(_403);
        switchInt(move _404) -> [0: bb230, 1: bb178, otherwise: bb44];
    }

    bb178: {
        _405 = ((_403 as Some).0: &exports::StaticPath);
        _402 = RepInterp::<&StaticPath>(_405);
        _407 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_371) -> [return: bb179, unwind: bb318];
    }

    bb179: {
        _408 = discriminant(_407);
        switchInt(move _408) -> [0: bb230, 1: bb180, otherwise: bb44];
    }

    bb180: {
        _409 = ((_407 as Some).0: &exports::StaticPath);
        _406 = RepInterp::<&StaticPath>(_409);
        _412 = &mut _375;
        _411 = <std::slice::Iter<'_, &name::Name> as Iterator>::next(move _412) -> [return: bb181, unwind: bb318];
    }

    bb181: {
        _413 = discriminant(_411);
        switchInt(move _413) -> [0: bb230, 1: bb182, otherwise: bb44];
    }

    bb182: {
        _414 = ((_411 as Some).0: &&name::Name);
        _410 = RepInterp::<&&name::Name>(_414);
        _416 = <StaticPath as quote::__private::ext::RepToTokensExt>::next(_379) -> [return: bb183, unwind: bb318];
    }

    bb183: {
        _417 = discriminant(_416);
        switchInt(move _417) -> [0: bb230, 1: bb184, otherwise: bb44];
    }

    bb184: {
        _418 = ((_416 as Some).0: &exports::StaticPath);
        _415 = RepInterp::<&StaticPath>(_418);
        _420 = &mut _54;
        _421 = const "let";
        _419 = push_ident(_420, _421) -> [return: bb185, unwind: bb318];
    }

    bb185: {
        _423 = &_384;
        _424 = &mut _54;
        _422 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_423, _424) -> [return: bb186, unwind: bb318];
    }

    bb186: {
        _426 = &mut _54;
        _425 = push_eq(_426) -> [return: bb187, unwind: bb318];
    }

    bb187: {
        _428 = &mut _54;
        _429 = const "match";
        _427 = push_ident(_428, _429) -> [return: bb188, unwind: bb318];
    }

    bb188: {
        _431 = &_389;
        _432 = &mut _54;
        _430 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_431, _432) -> [return: bb189, unwind: bb318];
    }

    bb189: {
        _434 = &mut _54;
        _435 = proc_macro2::Delimiter::Brace;
        _437 = TokenStream2::new() -> [return: bb190, unwind: bb318];
    }

    bb190: {
        _439 = &_394;
        _440 = &mut _437;
        _438 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_439, _440) -> [return: bb191, unwind: bb310];
    }

    bb191: {
        _442 = &mut _437;
        _443 = proc_macro2::Delimiter::Parenthesis;
        _445 = TokenStream2::new() -> [return: bb192, unwind: bb310];
    }

    bb192: {
        _447 = &mut _445;
        _448 = const "_v";
        _446 = push_ident(_447, _448) -> [return: bb193, unwind: bb309];
    }

    bb193: {
        _444 = move _445;
        _441 = push_group(_442, move _443, move _444) -> [return: bb194, unwind: bb310];
    }

    bb194: {
        _450 = &mut _437;
        _449 = push_fat_arrow(_450) -> [return: bb195, unwind: bb310];
    }

    bb195: {
        _452 = &_398;
        _453 = &mut _437;
        _451 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_452, _453) -> [return: bb196, unwind: bb310];
    }

    bb196: {
        _455 = &mut _437;
        _456 = proc_macro2::Delimiter::Parenthesis;
        _458 = TokenStream2::new() -> [return: bb197, unwind: bb310];
    }

    bb197: {
        _460 = &mut _458;
        _461 = const "_v";
        _459 = push_ident(_460, _461) -> [return: bb198, unwind: bb308];
    }

    bb198: {
        _457 = move _458;
        _454 = push_group(_455, move _456, move _457) -> [return: bb199, unwind: bb310];
    }

    bb199: {
        _463 = &mut _437;
        _462 = push_comma(_463) -> [return: bb200, unwind: bb310];
    }

    bb200: {
        _465 = &_402;
        _466 = &mut _437;
        _464 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_465, _466) -> [return: bb201, unwind: bb310];
    }

    bb201: {
        _468 = &mut _437;
        _469 = proc_macro2::Delimiter::Parenthesis;
        _471 = TokenStream2::new() -> [return: bb202, unwind: bb310];
    }

    bb202: {
        _473 = &mut _471;
        _474 = const "_err";
        _472 = push_ident(_473, _474) -> [return: bb203, unwind: bb307];
    }

    bb203: {
        _470 = move _471;
        _467 = push_group(_468, move _469, move _470) -> [return: bb204, unwind: bb310];
    }

    bb204: {
        _476 = &mut _437;
        _475 = push_fat_arrow(_476) -> [return: bb205, unwind: bb310];
    }

    bb205: {
        _478 = &mut _437;
        _479 = proc_macro2::Delimiter::Brace;
        _481 = TokenStream2::new() -> [return: bb206, unwind: bb310];
    }

    bb206: {
        _483 = &mut _481;
        _484 = const "__e";
        _482 = push_ident(_483, _484) -> [return: bb207, unwind: bb306];
    }

    bb207: {
        _486 = &mut _481;
        _485 = push_dot(_486) -> [return: bb208, unwind: bb306];
    }

    bb208: {
        _488 = &mut _481;
        _489 = const "extend";
        _487 = push_ident(_488, _489) -> [return: bb209, unwind: bb306];
    }

    bb209: {
        _491 = &mut _481;
        _492 = proc_macro2::Delimiter::Parenthesis;
        _494 = TokenStream2::new() -> [return: bb210, unwind: bb306];
    }

    bb210: {
        _496 = &mut _494;
        _497 = const "_err";
        _495 = push_ident(_496, _497) -> [return: bb211, unwind: bb305];
    }

    bb211: {
        _499 = &mut _494;
        _498 = push_dot(_499) -> [return: bb212, unwind: bb305];
    }

    bb212: {
        _501 = &mut _494;
        _502 = const "with_name";
        _500 = push_ident(_501, _502) -> [return: bb213, unwind: bb305];
    }

    bb213: {
        _504 = &mut _494;
        _505 = proc_macro2::Delimiter::Parenthesis;
        _507 = TokenStream2::new() -> [return: bb214, unwind: bb305];
    }

    bb214: {
        _509 = &_406;
        _510 = &mut _507;
        _508 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_509, _510) -> [return: bb215, unwind: bb304];
    }

    bb215: {
        _512 = &mut _507;
        _511 = push_colon2(_512) -> [return: bb216, unwind: bb304];
    }

    bb216: {
        _514 = &mut _507;
        _515 = const "NameView";
        _513 = push_ident(_514, _515) -> [return: bb217, unwind: bb304];
    }

    bb217: {
        _517 = &mut _507;
        _516 = push_colon2(_517) -> [return: bb218, unwind: bb304];
    }

    bb218: {
        _519 = &mut _507;
        _520 = const "new";
        _518 = push_ident(_519, _520) -> [return: bb219, unwind: bb304];
    }

    bb219: {
        _522 = &mut _507;
        _523 = proc_macro2::Delimiter::Parenthesis;
        _525 = TokenStream2::new() -> [return: bb220, unwind: bb304];
    }

    bb220: {
        _527 = &_410;
        _528 = &mut _525;
        _526 = <RepInterp<&&name::Name> as ToTokens>::to_tokens(_527, _528) -> [return: bb221, unwind: bb303];
    }

    bb221: {
        _524 = move _525;
        _521 = push_group(_522, move _523, move _524) -> [return: bb222, unwind: bb304];
    }

    bb222: {
        _506 = move _507;
        _503 = push_group(_504, move _505, move _506) -> [return: bb223, unwind: bb305];
    }

    bb223: {
        _493 = move _494;
        _490 = push_group(_491, move _492, move _493) -> [return: bb224, unwind: bb306];
    }

    bb224: {
        _530 = &mut _481;
        _529 = push_semi(_530) -> [return: bb225, unwind: bb306];
    }

    bb225: {
        _532 = &_415;
        _533 = &mut _481;
        _531 = <RepInterp<&StaticPath> as ToTokens>::to_tokens(_532, _533) -> [return: bb226, unwind: bb306];
    }

    bb226: {
        _480 = move _481;
        _477 = push_group(_478, move _479, move _480) -> [return: bb227, unwind: bb310];
    }

    bb227: {
        _535 = &mut _437;
        _534 = push_comma(_535) -> [return: bb228, unwind: bb310];
    }

    bb228: {
        _436 = move _437;
        _433 = push_group(_434, move _435, move _436) -> [return: bb229, unwind: bb318];
    }

    bb229: {
        _537 = &mut _54;
        _536 = push_semi(_537) -> [return: bb335, unwind: bb318];
    }

    bb230: {
        _539 = &mut _54;
        _540 = const "if";
        _538 = push_ident(_539, _540) -> [return: bb231, unwind: bb318];
    }

    bb231: {
        _542 = &mut _54;
        _541 = push_bang(_542) -> [return: bb232, unwind: bb318];
    }

    bb232: {
        _544 = &mut _54;
        _545 = const "__e";
        _543 = push_ident(_544, _545) -> [return: bb233, unwind: bb318];
    }

    bb233: {
        _547 = &mut _54;
        _546 = push_dot(_547) -> [return: bb234, unwind: bb318];
    }

    bb234: {
        _549 = &mut _54;
        _550 = const "is_empty";
        _548 = push_ident(_549, _550) -> [return: bb235, unwind: bb318];
    }

    bb235: {
        _552 = &mut _54;
        _553 = proc_macro2::Delimiter::Parenthesis;
        _554 = TokenStream2::new() -> [return: bb236, unwind: bb318];
    }

    bb236: {
        _551 = push_group(_552, move _553, move _554) -> [return: bb237, unwind: bb318];
    }

    bb237: {
        _556 = &mut _54;
        _557 = proc_macro2::Delimiter::Brace;
        _559 = TokenStream2::new() -> [return: bb238, unwind: bb318];
    }

    bb238: {
        _561 = &_15;
        _562 = &mut _559;
        _560 = <StaticPath as ToTokens>::to_tokens(_561, _562) -> [return: bb239, unwind: bb302];
    }

    bb239: {
        _564 = &mut _559;
        _563 = push_colon2(_564) -> [return: bb240, unwind: bb302];
    }

    bb240: {
        _566 = &mut _559;
        _567 = const "warn_";
        _565 = push_ident(_566, _567) -> [return: bb241, unwind: bb302];
    }

    bb241: {
        _569 = &mut _559;
        _568 = push_bang(_569) -> [return: bb242, unwind: bb302];
    }

    bb242: {
        _571 = &mut _559;
        _572 = proc_macro2::Delimiter::Parenthesis;
        _574 = TokenStream2::new() -> [return: bb243, unwind: bb302];
    }

    bb243: {
        _576 = &mut _574;
        _577 = const "\"query string failed to match declared route\"";
        _575 = quote::__private::parse(_576, _577) -> [return: bb244, unwind: bb301];
    }

    bb244: {
        _573 = move _574;
        _570 = push_group(_571, move _572, move _573) -> [return: bb245, unwind: bb302];
    }

    bb245: {
        _579 = &mut _559;
        _578 = push_semi(_579) -> [return: bb246, unwind: bb302];
    }

    bb246: {
        _581 = &mut _559;
        _582 = const "for";
        _580 = push_ident(_581, _582) -> [return: bb247, unwind: bb302];
    }

    bb247: {
        _584 = &mut _559;
        _585 = const "_err";
        _583 = push_ident(_584, _585) -> [return: bb248, unwind: bb302];
    }

    bb248: {
        _587 = &mut _559;
        _588 = const "in";
        _586 = push_ident(_587, _588) -> [return: bb249, unwind: bb302];
    }

    bb249: {
        _590 = &mut _559;
        _591 = const "__e";
        _589 = push_ident(_590, _591) -> [return: bb250, unwind: bb302];
    }

    bb250: {
        _593 = &mut _559;
        _594 = proc_macro2::Delimiter::Brace;
        _596 = TokenStream2::new() -> [return: bb251, unwind: bb302];
    }

    bb251: {
        _598 = &_15;
        _599 = &mut _596;
        _597 = <StaticPath as ToTokens>::to_tokens(_598, _599) -> [return: bb252, unwind: bb300];
    }

    bb252: {
        _601 = &mut _596;
        _600 = push_colon2(_601) -> [return: bb253, unwind: bb300];
    }

    bb253: {
        _603 = &mut _596;
        _604 = const "warn_";
        _602 = push_ident(_603, _604) -> [return: bb254, unwind: bb300];
    }

    bb254: {
        _606 = &mut _596;
        _605 = push_bang(_606) -> [return: bb255, unwind: bb300];
    }

    bb255: {
        _608 = &mut _596;
        _609 = proc_macro2::Delimiter::Parenthesis;
        _611 = TokenStream2::new() -> [return: bb256, unwind: bb300];
    }

    bb256: {
        _613 = &mut _611;
        _614 = const "\"{}\"";
        _612 = quote::__private::parse(_613, _614) -> [return: bb257, unwind: bb299];
    }

    bb257: {
        _616 = &mut _611;
        _615 = push_comma(_616) -> [return: bb258, unwind: bb299];
    }

    bb258: {
        _618 = &mut _611;
        _619 = const "_err";
        _617 = push_ident(_618, _619) -> [return: bb259, unwind: bb299];
    }

    bb259: {
        _610 = move _611;
        _607 = push_group(_608, move _609, move _610) -> [return: bb260, unwind: bb300];
    }

    bb260: {
        _621 = &mut _596;
        _620 = push_semi(_621) -> [return: bb261, unwind: bb300];
    }

    bb261: {
        _595 = move _596;
        _592 = push_group(_593, move _594, move _595) -> [return: bb262, unwind: bb302];
    }

    bb262: {
        _623 = &mut _559;
        _624 = const "return";
        _622 = push_ident(_623, _624) -> [return: bb263, unwind: bb302];
    }

    bb263: {
        _626 = &_21;
        _627 = &mut _559;
        _625 = <StaticPath as ToTokens>::to_tokens(_626, _627) -> [return: bb264, unwind: bb302];
    }

    bb264: {
        _629 = &mut _559;
        _628 = push_colon2(_629) -> [return: bb265, unwind: bb302];
    }

    bb265: {
        _631 = &mut _559;
        _632 = const "Forward";
        _630 = push_ident(_631, _632) -> [return: bb266, unwind: bb302];
    }

    bb266: {
        _634 = &mut _559;
        _635 = proc_macro2::Delimiter::Parenthesis;
        _637 = TokenStream2::new() -> [return: bb267, unwind: bb302];
    }

    bb267: {
        _639 = &_12;
        _640 = &mut _637;
        _638 = <StaticPath as ToTokens>::to_tokens(_639, _640) -> [return: bb268, unwind: bb298];
    }

    bb268: {
        _636 = move _637;
        _633 = push_group(_634, move _635, move _636) -> [return: bb269, unwind: bb302];
    }

    bb269: {
        _642 = &mut _559;
        _641 = push_semi(_642) -> [return: bb270, unwind: bb302];
    }

    bb270: {
        _558 = move _559;
        _555 = push_group(_556, move _557, move _558) -> [return: bb271, unwind: bb318];
    }

    bb271: {
        _645 = &_46;
        _644 = <Vec<proc_macro2::Ident> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _645) -> [return: bb272, unwind: bb318];
    }

    bb272: {
        _643 = move (_644.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _646 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb273, unwind: bb318];
    }

    bb273: {
        _648 = <std::slice::Iter<'_, proc_macro2::Ident> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _643) -> [return: bb274, unwind: bb318];
    }

    bb274: {
        _647 = move (_648.0: std::slice::Iter<'_, proc_macro2::Ident>);
        _649 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb336, unwind: bb318];
    }

    bb275: {
        _650 = const true;
        switchInt(move _650) -> [0: bb289, otherwise: bb276];
    }

    bb276: {
        _653 = &mut _647;
        _652 = <std::slice::Iter<'_, proc_macro2::Ident> as Iterator>::next(move _653) -> [return: bb277, unwind: bb318];
    }

    bb277: {
        _654 = discriminant(_652);
        switchInt(move _654) -> [0: bb289, 1: bb278, otherwise: bb44];
    }

    bb278: {
        _655 = ((_652 as Some).0: &proc_macro2::Ident);
        _651 = RepInterp::<&proc_macro2::Ident>(_655);
        _657 = RepInterp::<&proc_macro2::Ident>::next(_651) -> [return: bb279, unwind: bb318];
    }

    bb279: {
        _658 = discriminant(_657);
        switchInt(move _658) -> [0: bb289, 1: bb280, otherwise: bb44];
    }

    bb280: {
        _659 = ((_657 as Some).0: &proc_macro2::Ident);
        _656 = RepInterp::<&proc_macro2::Ident>(_659);
        _661 = &mut _54;
        _662 = const "let";
        _660 = push_ident(_661, _662) -> [return: bb281, unwind: bb318];
    }

    bb281: {
        _664 = &_656;
        _665 = &mut _54;
        _663 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_664, _665) -> [return: bb282, unwind: bb318];
    }

    bb282: {
        _667 = &mut _54;
        _666 = push_eq(_667) -> [return: bb283, unwind: bb318];
    }

    bb283: {
        _669 = &_656;
        _670 = &mut _54;
        _668 = <RepInterp<&proc_macro2::Ident> as ToTokens>::to_tokens(_669, _670) -> [return: bb284, unwind: bb318];
    }

    bb284: {
        _672 = &mut _54;
        _671 = push_dot(_672) -> [return: bb285, unwind: bb318];
    }

    bb285: {
        _674 = &mut _54;
        _675 = const "unwrap";
        _673 = push_ident(_674, _675) -> [return: bb286, unwind: bb318];
    }

    bb286: {
        _677 = &mut _54;
        _678 = proc_macro2::Delimiter::Parenthesis;
        _679 = TokenStream2::new() -> [return: bb287, unwind: bb318];
    }

    bb287: {
        _676 = push_group(_677, move _678, move _679) -> [return: bb288, unwind: bb318];
    }

    bb288: {
        _681 = &mut _54;
        _680 = push_semi(_681) -> [return: bb337, unwind: bb318];
    }

    bb289: {
        _53 = move _54;
        _0 = Option::<TokenStream2>::Some(move _53);
        drop(_49) -> [return: bb290, unwind: bb320];
    }

    bb290: {
        drop(_48) -> [return: bb291, unwind: bb321];
    }

    bb291: {
        drop(_47) -> [return: bb292, unwind: bb322];
    }

    bb292: {
        drop(_46) -> [return: bb293, unwind: bb323];
    }

    bb293: {
        drop(_45) -> [return: bb294, unwind: bb324];
    }

    bb294: {
        drop(_44) -> [return: bb295, unwind: bb325];
    }

    bb295: {
        drop(_37) -> [return: bb296, unwind: bb326];
    }

    bb296: {
        drop(_36) -> [return: bb297, unwind continue];
    }

    bb297: {
        return;
    }

    bb298 (cleanup): {
        drop(_637) -> [return: bb302, unwind terminate(cleanup)];
    }

    bb299 (cleanup): {
        drop(_611) -> [return: bb300, unwind terminate(cleanup)];
    }

    bb300 (cleanup): {
        drop(_596) -> [return: bb302, unwind terminate(cleanup)];
    }

    bb301 (cleanup): {
        drop(_574) -> [return: bb302, unwind terminate(cleanup)];
    }

    bb302 (cleanup): {
        drop(_559) -> [return: bb318, unwind terminate(cleanup)];
    }

    bb303 (cleanup): {
        drop(_525) -> [return: bb304, unwind terminate(cleanup)];
    }

    bb304 (cleanup): {
        drop(_507) -> [return: bb305, unwind terminate(cleanup)];
    }

    bb305 (cleanup): {
        drop(_494) -> [return: bb306, unwind terminate(cleanup)];
    }

    bb306 (cleanup): {
        drop(_481) -> [return: bb310, unwind terminate(cleanup)];
    }

    bb307 (cleanup): {
        drop(_471) -> [return: bb310, unwind terminate(cleanup)];
    }

    bb308 (cleanup): {
        drop(_458) -> [return: bb310, unwind terminate(cleanup)];
    }

    bb309 (cleanup): {
        drop(_445) -> [return: bb310, unwind terminate(cleanup)];
    }

    bb310 (cleanup): {
        drop(_437) -> [return: bb318, unwind terminate(cleanup)];
    }

    bb311 (cleanup): {
        drop(_326) -> [return: bb314, unwind terminate(cleanup)];
    }

    bb312 (cleanup): {
        drop(_282) -> [return: bb313, unwind terminate(cleanup)];
    }

    bb313 (cleanup): {
        drop(_277) -> [return: bb314, unwind terminate(cleanup)];
    }

    bb314 (cleanup): {
        drop(_253) -> [return: bb317, unwind terminate(cleanup)];
    }

    bb315 (cleanup): {
        drop(_240) -> [return: bb317, unwind terminate(cleanup)];
    }

    bb316 (cleanup): {
        drop(_158) -> [return: bb317, unwind terminate(cleanup)];
    }

    bb317 (cleanup): {
        drop(_145) -> [return: bb318, unwind terminate(cleanup)];
    }

    bb318 (cleanup): {
        drop(_54) -> [return: bb319, unwind terminate(cleanup)];
    }

    bb319 (cleanup): {
        drop(_49) -> [return: bb320, unwind terminate(cleanup)];
    }

    bb320 (cleanup): {
        drop(_48) -> [return: bb321, unwind terminate(cleanup)];
    }

    bb321 (cleanup): {
        drop(_47) -> [return: bb322, unwind terminate(cleanup)];
    }

    bb322 (cleanup): {
        drop(_46) -> [return: bb323, unwind terminate(cleanup)];
    }

    bb323 (cleanup): {
        drop(_45) -> [return: bb324, unwind terminate(cleanup)];
    }

    bb324 (cleanup): {
        drop(_44) -> [return: bb325, unwind terminate(cleanup)];
    }

    bb325 (cleanup): {
        drop(_37) -> [return: bb326, unwind terminate(cleanup)];
    }

    bb326 (cleanup): {
        drop(_36) -> [return: bb327, unwind terminate(cleanup)];
    }

    bb327 (cleanup): {
        resume;
    }

    bb328: {
        goto -> bb41;
    }

    bb329: {
        goto -> bb41;
    }

    bb330: {
        goto -> bb109;
    }

    bb331: {
        goto -> bb109;
    }

    bb332: {
        goto -> bb131;
    }

    bb333: {
        goto -> bb131;
    }

    bb334: {
        goto -> bb167;
    }

    bb335: {
        goto -> bb167;
    }

    bb336: {
        goto -> bb275;
    }

    bb337: {
        goto -> bb275;
    }
}

fn query_decls::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:45:21: 45:24}, _2: &Parameter) -> Option<&name::Name> {
    debug s => _2;
    let mut _0: std::option::Option<&name::Name>;

    bb0: {
        _0 = Parameter::r#static(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn query_decls::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:46:14: 46:20}, _2: &name::Name) -> (&str, &str) {
    debug name => _2;
    let mut _0: (&str, &str);
    let mut _3: std::option::Option<usize>;
    let _4: &str;
    let mut _5: isize;
    let _6: usize;
    let _7: &str;
    let _8: &str;
    let mut _9: std::ops::RangeTo<usize>;
    let _10: &str;
    let _11: &str;
    let mut _12: std::ops::RangeFrom<usize>;
    let mut _13: usize;
    let mut _14: (usize, bool);
    let mut _15: &str;
    scope 1 {
        debug i => _6;
    }

    bb0: {
        _4 = <name::Name as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = core::str::<impl str>::find::<'_, char>(_4, const '=') -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _15 = name::Name::as_str(_2) -> [return: bb11, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = ((_3 as Some).0: usize);
        _8 = <name::Name as std::ops::Deref>::deref(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = RangeTo::<usize> { end: _6 };
        _7 = <str as std::ops::Index<RangeTo<usize>>>::index(_8, move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = <name::Name as std::ops::Deref>::deref(_2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _14 = CheckedAdd(_6, const 1_usize);
        assert(!move (_14.1: bool), "attempt to compute `{} + {}`, which would overflow", _6, const 1_usize) -> [success: bb9, unwind continue];
    }

    bb9: {
        _13 = move (_14.0: usize);
        _12 = RangeFrom::<usize> { start: move _13 };
        _10 = <str as std::ops::Index<RangeFrom<usize>>>::index(_11, move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = (_7, _10);
        goto -> bb12;
    }

    bb11: {
        _0 = (move _15, const "");
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn query_decls::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:54:14: 54:21}, _2: &Guard) -> (&name::Name, TokenStream2, proc_macro2::Ident, TokenStream2, TokenStream2, TokenStream2) {
    debug guard => _2;
    let mut _0: (&name::Name, proc_macro2::TokenStream, proc_macro2::Ident, proc_macro2::TokenStream, proc_macro2::TokenStream, proc_macro2::TokenStream);
    let _3: &name::Name;
    let _4: &syn::Type;
    let mut _5: (&name::Name, &syn::Type);
    let mut _6: &name::Name;
    let _7: &attribute::param::Dynamic;
    let mut _8: &syn::Type;
    let mut _10: proc_macro2::Ident;
    let mut _11: &proc_macro2::Ident;
    let mut _12: proc_macro2::Span;
    let mut _13: &syn::Type;
    let mut _15: &attribute::param::Dynamic;
    let mut _18: &name::Name;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _22: ();
    let _23: &&name::Name;
    let mut _24: &mut proc_macro2::TokenStream;
    let mut _26: std::option::Option<proc_macro2::Span>;
    let mut _27: proc_macro2::Span;
    let mut _28: &syn::Type;
    let mut _30: std::option::Option<proc_macro2::Span>;
    let mut _31: proc_macro2::Span;
    let mut _32: &syn::Type;
    let mut _36: &syn::Type;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let _40: &&syn::Type;
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: &str;
    let _45: ();
    let _46: &exports::StaticPath;
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let mut _53: &proc_macro2::TokenStream;
    let _54: ();
    let _55: &proc_macro2::TokenStream;
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: &str;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let mut _64: proc_macro2::Delimiter;
    let mut _65: proc_macro2::TokenStream;
    let _67: ();
    let _68: &exports::StaticPath;
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: &str;
    let _75: ();
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: &str;
    let mut _83: &proc_macro2::TokenStream;
    let _84: ();
    let _85: &proc_macro2::TokenStream;
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: &str;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let mut _94: proc_macro2::Delimiter;
    let mut _95: proc_macro2::TokenStream;
    let _97: ();
    let _98: &proc_macro2::Ident;
    let mut _99: &mut proc_macro2::TokenStream;
    let mut _101: &attribute::param::Dynamic;
    let mut _104: &proc_macro2::TokenStream;
    let _105: ();
    let _106: &proc_macro2::TokenStream;
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: ();
    let mut _109: &mut proc_macro2::TokenStream;
    let _110: ();
    let mut _111: &mut proc_macro2::TokenStream;
    let _112: &str;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let mut _115: proc_macro2::Delimiter;
    let mut _116: proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: &str;
    let _123: ();
    let _124: &proc_macro2::Ident;
    let mut _125: &mut proc_macro2::TokenStream;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let _128: ();
    let mut _129: &mut proc_macro2::TokenStream;
    let _130: &str;
    let mut _133: &proc_macro2::TokenStream;
    let _134: ();
    let _135: &proc_macro2::TokenStream;
    let mut _136: &mut proc_macro2::TokenStream;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: ();
    let mut _140: &mut proc_macro2::TokenStream;
    let _141: &str;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let mut _144: proc_macro2::Delimiter;
    let mut _145: proc_macro2::TokenStream;
    let _147: ();
    let mut _148: &mut proc_macro2::TokenStream;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: &str;
    let _152: ();
    let _153: &proc_macro2::Ident;
    let mut _154: &mut proc_macro2::TokenStream;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let _159: &str;
    let _160: ();
    let mut _161: &mut proc_macro2::TokenStream;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: &str;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let mut _167: proc_macro2::Delimiter;
    let mut _168: proc_macro2::TokenStream;
    let mut _169: &name::Name;
    let mut _170: proc_macro2::TokenStream;
    let mut _171: proc_macro2::Ident;
    let mut _172: proc_macro2::TokenStream;
    let mut _173: proc_macro2::TokenStream;
    let mut _174: proc_macro2::TokenStream;
    let mut _175: bool;
    let mut _176: bool;
    let mut _177: bool;
    scope 1 {
        debug name => _3;
        debug ty => _4;
        let _9: proc_macro2::Ident;
        scope 2 {
            debug ident => _9;
            let _14: proc_macro2::TokenStream;
            let mut _16: proc_macro2::TokenStream;
            let mut _21: proc_macro2::TokenStream;
            scope 3 {
                debug matcher => _14;
                scope 7 {
                    debug FromForm => _25;
                    scope 9 {
                        debug _form => _29;
                        let _33: proc_macro2::TokenStream;
                        let mut _34: proc_macro2::TokenStream;
                        scope 11 {
                            debug ty => _33;
                            let _50: proc_macro2::TokenStream;
                            let mut _51: proc_macro2::TokenStream;
                            scope 14 {
                                debug init => _50;
                                let _80: proc_macro2::TokenStream;
                                let mut _81: proc_macro2::TokenStream;
                                scope 19 {
                                    debug finalize => _80;
                                    let _100: proc_macro2::TokenStream;
                                    let mut _102: proc_macro2::TokenStream;
                                    let mut _131: proc_macro2::TokenStream;
                                    scope 24 {
                                        debug push => _100;
                                    }
                                    scope 25 {
                                        debug _s => _102;
                                        let _103: proc_macro2::Span;
                                        scope 26 {
                                            debug _span => _103;
                                            let mut _117: proc_macro2::TokenStream;
                                            scope 27 {
                                                debug _s => _117;
                                                scope 28 {
                                                    debug _span => _103;
                                                }
                                            }
                                        }
                                    }
                                    scope 29 {
                                        debug _s => _131;
                                        let _132: proc_macro2::Span;
                                        scope 30 {
                                            debug _span => _132;
                                            let mut _146: proc_macro2::TokenStream;
                                            scope 31 {
                                                debug _s => _146;
                                                scope 32 {
                                                    debug _span => _132;
                                                    scope 33 {
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                scope 20 {
                                    debug _s => _81;
                                    let _82: proc_macro2::Span;
                                    scope 21 {
                                        debug _span => _82;
                                        let mut _96: proc_macro2::TokenStream;
                                        scope 22 {
                                            debug _s => _96;
                                            scope 23 {
                                            }
                                        }
                                    }
                                }
                            }
                            scope 15 {
                                debug _s => _51;
                                let _52: proc_macro2::Span;
                                scope 16 {
                                    debug _span => _52;
                                    let mut _66: proc_macro2::TokenStream;
                                    scope 17 {
                                        debug _s => _66;
                                        scope 18 {
                                            debug _span => _52;
                                        }
                                    }
                                }
                            }
                        }
                        scope 12 {
                            debug _s => _34;
                            let _35: proc_macro2::Span;
                            scope 13 {
                                debug _span => _35;
                            }
                        }
                    }
                    scope 10 {
                        let _29: exports::StaticPath;
                    }
                }
                scope 8 {
                    let _25: exports::StaticPath;
                }
            }
            scope 4 {
                debug _s => _16;
                let _17: proc_macro2::Span;
                scope 5 {
                    debug _span => _17;
                }
            }
            scope 6 {
                debug _s => _21;
            }
        }
    }

    bb0: {
        _176 = const false;
        _177 = const false;
        _175 = const false;
        _7 = <Guard as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &((*_7).0: name::Name);
        _8 = &((*_2).2: syn::Type);
        _5 = (move _6, move _8);
        _3 = (_5.0: &name::Name);
        _4 = (_5.1: &syn::Type);
        _11 = &((*_2).1: proc_macro2::Ident);
        _177 = const true;
        _10 = <proc_macro2::Ident as syn_ext::IdentExt>::rocketized(move _11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = _4;
        _12 = <syn::Type as devise::Spanned>::span(move _13) -> [return: bb3, unwind: bb96];
    }

    bb3: {
        _177 = const false;
        _9 = <proc_macro2::Ident as syn_ext::IdentExt>::with_span(move _10, move _12) -> [return: bb4, unwind: bb96];
    }

    bb4: {
        _176 = const true;
        _177 = const false;
        _15 = <Guard as std::ops::Deref>::deref(_2) -> [return: bb5, unwind: bb94];
    }

    bb5: {
        switchInt(((*_15).2: bool)) -> [0: bb6, otherwise: bb7];
    }

    bb6: {
        _21 = TokenStream2::new() -> [return: bb11, unwind: bb94];
    }

    bb7: {
        _16 = TokenStream2::new() -> [return: bb8, unwind: bb94];
    }

    bb8: {
        _18 = _3;
        _17 = name::Name::span(move _18) -> [return: bb9, unwind: bb89];
    }

    bb9: {
        _20 = &mut _16;
        _19 = push_underscore_spanned(_20, _17) -> [return: bb10, unwind: bb89];
    }

    bb10: {
        _175 = const true;
        _14 = move _16;
        goto -> bb13;
    }

    bb11: {
        _23 = &_3;
        _24 = &mut _21;
        _22 = <&name::Name as ToTokens>::to_tokens(_23, _24) -> [return: bb12, unwind: bb88];
    }

    bb12: {
        _175 = const true;
        _14 = move _21;
        goto -> bb13;
    }

    bb13: {
        _28 = _4;
        _27 = <syn::Type as devise::Spanned>::span(move _28) -> [return: bb14, unwind: bb92];
    }

    bb14: {
        _26 = Option::<proc_macro2::Span>::Some(move _27);
        _25 = StaticPath(move _26, const "::rocket::form::FromForm");
        _32 = _4;
        _31 = <syn::Type as devise::Spanned>::span(move _32) -> [return: bb15, unwind: bb92];
    }

    bb15: {
        _30 = Option::<proc_macro2::Span>::Some(move _31);
        _29 = StaticPath(move _30, const "::rocket::form::prelude");
        _34 = TokenStream2::new() -> [return: bb16, unwind: bb92];
    }

    bb16: {
        _36 = _4;
        _35 = <syn::Type as devise::Spanned>::span(move _36) -> [return: bb17, unwind: bb87];
    }

    bb17: {
        _38 = &mut _34;
        _37 = push_lt_spanned(_38, _35) -> [return: bb18, unwind: bb87];
    }

    bb18: {
        _40 = &_4;
        _41 = &mut _34;
        _39 = <&syn::Type as ToTokens>::to_tokens(_40, _41) -> [return: bb19, unwind: bb87];
    }

    bb19: {
        _43 = &mut _34;
        _44 = const "as";
        _42 = push_ident_spanned(_43, _35, _44) -> [return: bb20, unwind: bb87];
    }

    bb20: {
        _46 = &_25;
        _47 = &mut _34;
        _45 = <StaticPath as ToTokens>::to_tokens(_46, _47) -> [return: bb21, unwind: bb87];
    }

    bb21: {
        _49 = &mut _34;
        _48 = push_gt_spanned(_49, _35) -> [return: bb22, unwind: bb87];
    }

    bb22: {
        _33 = move _34;
        _51 = TokenStream2::new() -> [return: bb23, unwind: bb86];
    }

    bb23: {
        _53 = &_33;
        _52 = <TokenStream2 as devise::Spanned>::span(move _53) -> [return: bb24, unwind: bb85];
    }

    bb24: {
        _55 = &_33;
        _56 = &mut _51;
        _54 = <TokenStream2 as ToTokens>::to_tokens(_55, _56) -> [return: bb25, unwind: bb85];
    }

    bb25: {
        _58 = &mut _51;
        _57 = push_colon2_spanned(_58, _52) -> [return: bb26, unwind: bb85];
    }

    bb26: {
        _60 = &mut _51;
        _61 = const "init";
        _59 = push_ident_spanned(_60, _52, _61) -> [return: bb27, unwind: bb85];
    }

    bb27: {
        _63 = &mut _51;
        _64 = proc_macro2::Delimiter::Parenthesis;
        _66 = TokenStream2::new() -> [return: bb28, unwind: bb85];
    }

    bb28: {
        _68 = &_29;
        _69 = &mut _66;
        _67 = <StaticPath as ToTokens>::to_tokens(_68, _69) -> [return: bb29, unwind: bb84];
    }

    bb29: {
        _71 = &mut _66;
        _70 = push_colon2_spanned(_71, _52) -> [return: bb30, unwind: bb84];
    }

    bb30: {
        _73 = &mut _66;
        _74 = const "Options";
        _72 = push_ident_spanned(_73, _52, _74) -> [return: bb31, unwind: bb84];
    }

    bb31: {
        _76 = &mut _66;
        _75 = push_colon2_spanned(_76, _52) -> [return: bb32, unwind: bb84];
    }

    bb32: {
        _78 = &mut _66;
        _79 = const "Lenient";
        _77 = push_ident_spanned(_78, _52, _79) -> [return: bb33, unwind: bb84];
    }

    bb33: {
        _65 = move _66;
        _62 = push_group_spanned(_63, _52, move _64, move _65) -> [return: bb34, unwind: bb85];
    }

    bb34: {
        _50 = move _51;
        _81 = TokenStream2::new() -> [return: bb35, unwind: bb83];
    }

    bb35: {
        _83 = &_33;
        _82 = <TokenStream2 as devise::Spanned>::span(move _83) -> [return: bb36, unwind: bb82];
    }

    bb36: {
        _85 = &_33;
        _86 = &mut _81;
        _84 = <TokenStream2 as ToTokens>::to_tokens(_85, _86) -> [return: bb37, unwind: bb82];
    }

    bb37: {
        _88 = &mut _81;
        _87 = push_colon2_spanned(_88, _82) -> [return: bb38, unwind: bb82];
    }

    bb38: {
        _90 = &mut _81;
        _91 = const "finalize";
        _89 = push_ident_spanned(_90, _82, _91) -> [return: bb39, unwind: bb82];
    }

    bb39: {
        _93 = &mut _81;
        _94 = proc_macro2::Delimiter::Parenthesis;
        _96 = TokenStream2::new() -> [return: bb40, unwind: bb82];
    }

    bb40: {
        _98 = &_9;
        _99 = &mut _96;
        _97 = <proc_macro2::Ident as ToTokens>::to_tokens(_98, _99) -> [return: bb41, unwind: bb81];
    }

    bb41: {
        _95 = move _96;
        _92 = push_group_spanned(_93, _82, move _94, move _95) -> [return: bb42, unwind: bb82];
    }

    bb42: {
        _80 = move _81;
        _101 = <Guard as std::ops::Deref>::deref(_2) -> [return: bb43, unwind: bb80];
    }

    bb43: {
        switchInt(((*_101).2: bool)) -> [0: bb44, otherwise: bb45];
    }

    bb44: {
        _131 = TokenStream2::new() -> [return: bb58, unwind: bb80];
    }

    bb45: {
        _102 = TokenStream2::new() -> [return: bb46, unwind: bb80];
    }

    bb46: {
        _104 = &_33;
        _103 = <TokenStream2 as devise::Spanned>::span(move _104) -> [return: bb47, unwind: bb79];
    }

    bb47: {
        _106 = &_33;
        _107 = &mut _102;
        _105 = <TokenStream2 as ToTokens>::to_tokens(_106, _107) -> [return: bb48, unwind: bb79];
    }

    bb48: {
        _109 = &mut _102;
        _108 = push_colon2_spanned(_109, _103) -> [return: bb49, unwind: bb79];
    }

    bb49: {
        _111 = &mut _102;
        _112 = const "push_value";
        _110 = push_ident_spanned(_111, _103, _112) -> [return: bb50, unwind: bb79];
    }

    bb50: {
        _114 = &mut _102;
        _115 = proc_macro2::Delimiter::Parenthesis;
        _117 = TokenStream2::new() -> [return: bb51, unwind: bb79];
    }

    bb51: {
        _119 = &mut _117;
        _118 = push_and_spanned(_119, _103) -> [return: bb52, unwind: bb78];
    }

    bb52: {
        _121 = &mut _117;
        _122 = const "mut";
        _120 = push_ident_spanned(_121, _103, _122) -> [return: bb53, unwind: bb78];
    }

    bb53: {
        _124 = &_9;
        _125 = &mut _117;
        _123 = <proc_macro2::Ident as ToTokens>::to_tokens(_124, _125) -> [return: bb54, unwind: bb78];
    }

    bb54: {
        _127 = &mut _117;
        _126 = push_comma_spanned(_127, _103) -> [return: bb55, unwind: bb78];
    }

    bb55: {
        _129 = &mut _117;
        _130 = const "_f";
        _128 = push_ident_spanned(_129, _103, _130) -> [return: bb56, unwind: bb78];
    }

    bb56: {
        _116 = move _117;
        _113 = push_group_spanned(_114, _103, move _115, move _116) -> [return: bb57, unwind: bb79];
    }

    bb57: {
        _100 = move _102;
        goto -> bb74;
    }

    bb58: {
        _133 = &_33;
        _132 = <TokenStream2 as devise::Spanned>::span(move _133) -> [return: bb59, unwind: bb77];
    }

    bb59: {
        _135 = &_33;
        _136 = &mut _131;
        _134 = <TokenStream2 as ToTokens>::to_tokens(_135, _136) -> [return: bb60, unwind: bb77];
    }

    bb60: {
        _138 = &mut _131;
        _137 = push_colon2_spanned(_138, _132) -> [return: bb61, unwind: bb77];
    }

    bb61: {
        _140 = &mut _131;
        _141 = const "push_value";
        _139 = push_ident_spanned(_140, _132, _141) -> [return: bb62, unwind: bb77];
    }

    bb62: {
        _143 = &mut _131;
        _144 = proc_macro2::Delimiter::Parenthesis;
        _146 = TokenStream2::new() -> [return: bb63, unwind: bb77];
    }

    bb63: {
        _148 = &mut _146;
        _147 = push_and_spanned(_148, _132) -> [return: bb64, unwind: bb76];
    }

    bb64: {
        _150 = &mut _146;
        _151 = const "mut";
        _149 = push_ident_spanned(_150, _132, _151) -> [return: bb65, unwind: bb76];
    }

    bb65: {
        _153 = &_9;
        _154 = &mut _146;
        _152 = <proc_macro2::Ident as ToTokens>::to_tokens(_153, _154) -> [return: bb66, unwind: bb76];
    }

    bb66: {
        _156 = &mut _146;
        _155 = push_comma_spanned(_156, _132) -> [return: bb67, unwind: bb76];
    }

    bb67: {
        _158 = &mut _146;
        _159 = const "_f";
        _157 = push_ident_spanned(_158, _132, _159) -> [return: bb68, unwind: bb76];
    }

    bb68: {
        _161 = &mut _146;
        _160 = push_dot_spanned(_161, _132) -> [return: bb69, unwind: bb76];
    }

    bb69: {
        _163 = &mut _146;
        _164 = const "shift";
        _162 = push_ident_spanned(_163, _132, _164) -> [return: bb70, unwind: bb76];
    }

    bb70: {
        _166 = &mut _146;
        _167 = proc_macro2::Delimiter::Parenthesis;
        _168 = TokenStream2::new() -> [return: bb71, unwind: bb76];
    }

    bb71: {
        _165 = push_group_spanned(_166, _132, move _167, move _168) -> [return: bb72, unwind: bb76];
    }

    bb72: {
        _145 = move _146;
        _142 = push_group_spanned(_143, _132, move _144, move _145) -> [return: bb73, unwind: bb77];
    }

    bb73: {
        _100 = move _131;
        goto -> bb74;
    }

    bb74: {
        _169 = _3;
        _175 = const false;
        _170 = move _14;
        _176 = const false;
        _171 = move _9;
        _172 = move _50;
        _173 = move _100;
        _174 = move _80;
        _0 = (move _169, move _170, move _171, move _172, move _173, move _174);
        drop(_33) -> [return: bb75, unwind: bb92];
    }

    bb75: {
        _175 = const false;
        _176 = const false;
        return;
    }

    bb76 (cleanup): {
        drop(_146) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        drop(_131) -> [return: bb80, unwind terminate(cleanup)];
    }

    bb78 (cleanup): {
        drop(_117) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        drop(_102) -> [return: bb80, unwind terminate(cleanup)];
    }

    bb80 (cleanup): {
        drop(_80) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        drop(_96) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        drop(_81) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        drop(_50) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb84 (cleanup): {
        drop(_66) -> [return: bb85, unwind terminate(cleanup)];
    }

    bb85 (cleanup): {
        drop(_51) -> [return: bb86, unwind terminate(cleanup)];
    }

    bb86 (cleanup): {
        drop(_33) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb87 (cleanup): {
        drop(_34) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb88 (cleanup): {
        drop(_21) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb89 (cleanup): {
        drop(_16) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        resume;
    }

    bb91 (cleanup): {
        drop(_14) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        switchInt(_175) -> [0: bb94, otherwise: bb91];
    }

    bb93 (cleanup): {
        drop(_9) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb94 (cleanup): {
        switchInt(_176) -> [0: bb90, otherwise: bb93];
    }

    bb95 (cleanup): {
        drop(_10) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb96 (cleanup): {
        switchInt(_177) -> [0: bb90, otherwise: bb95];
    }
}

fn request_guard_decl(_1: &Guard) -> TokenStream2 {
    debug guard => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: proc_macro2::Ident;
    let _3: &syn::Type;
    let mut _4: (proc_macro2::Ident, &syn::Type);
    let mut _5: proc_macro2::Ident;
    let mut _6: &proc_macro2::Ident;
    let mut _7: &syn::Type;
    let mut _9: std::option::Option<proc_macro2::Span>;
    let mut _10: proc_macro2::Span;
    let mut _11: &syn::Type;
    let mut _13: std::option::Option<proc_macro2::Span>;
    let mut _14: proc_macro2::Span;
    let mut _15: &syn::Type;
    let mut _17: std::option::Option<proc_macro2::Span>;
    let mut _18: proc_macro2::Span;
    let mut _19: &syn::Type;
    let mut _21: std::option::Option<proc_macro2::Span>;
    let mut _22: proc_macro2::Span;
    let mut _23: &syn::Type;
    let mut _25: std::option::Option<proc_macro2::Span>;
    let mut _26: proc_macro2::Span;
    let mut _27: &syn::Type;
    let mut _29: std::option::Option<proc_macro2::Span>;
    let mut _30: proc_macro2::Span;
    let mut _31: &syn::Type;
    let mut _34: &syn::Type;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: &str;
    let _38: ();
    let _39: &proc_macro2::Ident;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let _44: &&syn::Type;
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let _53: ();
    let _54: &&syn::Type;
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let _60: &exports::StaticPath;
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let mut _71: proc_macro2::Delimiter;
    let mut _72: proc_macro2::TokenStream;
    let _74: ();
    let _75: &exports::StaticPath;
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: &str;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let mut _84: proc_macro2::Delimiter;
    let mut _85: proc_macro2::TokenStream;
    let _87: ();
    let _88: &exports::StaticPath;
    let mut _89: &mut proc_macro2::TokenStream;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: &str;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let mut _97: proc_macro2::Delimiter;
    let mut _98: proc_macro2::TokenStream;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let _102: &str;
    let _103: ();
    let mut _104: &mut proc_macro2::TokenStream;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: &str;
    let _108: ();
    let mut _109: &mut proc_macro2::TokenStream;
    let _110: ();
    let _111: &exports::StaticPath;
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: &str;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let mut _120: proc_macro2::Delimiter;
    let mut _121: proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: ();
    let mut _126: &mut proc_macro2::TokenStream;
    let _127: ();
    let mut _128: &mut proc_macro2::TokenStream;
    let mut _129: proc_macro2::Delimiter;
    let mut _130: proc_macro2::TokenStream;
    let _132: ();
    let _133: &exports::StaticPath;
    let mut _134: &mut proc_macro2::TokenStream;
    let _135: ();
    let mut _136: &mut proc_macro2::TokenStream;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: &str;
    let _140: ();
    let mut _141: &mut proc_macro2::TokenStream;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let mut _144: proc_macro2::Delimiter;
    let mut _145: proc_macro2::TokenStream;
    let _147: ();
    let mut _148: &mut proc_macro2::TokenStream;
    let _149: &str;
    let _150: ();
    let mut _151: &mut proc_macro2::TokenStream;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: &str;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let mut _159: proc_macro2::Delimiter;
    let mut _160: proc_macro2::TokenStream;
    let _162: ();
    let _163: &&syn::Type;
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let _167: ();
    let mut _168: &mut proc_macro2::TokenStream;
    let _169: &str;
    let _170: ();
    let _171: &exports::StaticPath;
    let mut _172: &mut proc_macro2::TokenStream;
    let _173: ();
    let mut _174: &mut proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: &str;
    let _178: ();
    let mut _179: &mut proc_macro2::TokenStream;
    let mut _180: proc_macro2::Delimiter;
    let mut _181: proc_macro2::TokenStream;
    let _183: ();
    let _184: &exports::StaticPath;
    let mut _185: &mut proc_macro2::TokenStream;
    let _186: ();
    let mut _187: &mut proc_macro2::TokenStream;
    let _188: ();
    let mut _189: &mut proc_macro2::TokenStream;
    let _190: ();
    let _191: &exports::StaticPath;
    let mut _192: &mut proc_macro2::TokenStream;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: &str;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let mut _200: proc_macro2::Delimiter;
    let mut _201: proc_macro2::TokenStream;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let mut _205: proc_macro2::Delimiter;
    let mut _206: proc_macro2::TokenStream;
    let _208: ();
    let mut _209: &mut proc_macro2::TokenStream;
    let _210: &str;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: &str;
    let _216: ();
    let mut _217: &mut proc_macro2::TokenStream;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let mut _220: proc_macro2::Delimiter;
    let mut _221: proc_macro2::TokenStream;
    let _223: ();
    let _224: &exports::StaticPath;
    let mut _225: &mut proc_macro2::TokenStream;
    let _226: ();
    let mut _227: &mut proc_macro2::TokenStream;
    let _228: ();
    let mut _229: &mut proc_macro2::TokenStream;
    let _230: &str;
    let _231: ();
    let mut _232: &mut proc_macro2::TokenStream;
    let _233: ();
    let mut _234: &mut proc_macro2::TokenStream;
    let mut _235: proc_macro2::Delimiter;
    let mut _236: proc_macro2::TokenStream;
    let _238: ();
    let mut _239: &mut proc_macro2::TokenStream;
    let _240: &str;
    let _241: ();
    let mut _242: &mut proc_macro2::TokenStream;
    let _243: ();
    let mut _244: &mut proc_macro2::TokenStream;
    let _245: &str;
    let _246: ();
    let mut _247: &mut proc_macro2::TokenStream;
    let _248: ();
    let mut _249: &mut proc_macro2::TokenStream;
    let mut _250: proc_macro2::Delimiter;
    let mut _251: proc_macro2::TokenStream;
    let _253: ();
    let _254: &&syn::Type;
    let mut _255: &mut proc_macro2::TokenStream;
    let _256: ();
    let mut _257: &mut proc_macro2::TokenStream;
    let _258: ();
    let mut _259: &mut proc_macro2::TokenStream;
    let _260: &str;
    let _261: ();
    let mut _262: &mut proc_macro2::TokenStream;
    let _263: ();
    let mut _264: &mut proc_macro2::TokenStream;
    let _265: &str;
    let _266: ();
    let _267: &exports::StaticPath;
    let mut _268: &mut proc_macro2::TokenStream;
    let _269: ();
    let mut _270: &mut proc_macro2::TokenStream;
    let _271: ();
    let mut _272: &mut proc_macro2::TokenStream;
    let _273: &str;
    let _274: ();
    let mut _275: &mut proc_macro2::TokenStream;
    let mut _276: proc_macro2::Delimiter;
    let mut _277: proc_macro2::TokenStream;
    let _279: ();
    let mut _280: &mut proc_macro2::TokenStream;
    let _281: &str;
    let _282: ();
    let mut _283: &mut proc_macro2::TokenStream;
    let _284: ();
    let mut _285: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ident => _2;
        debug ty => _3;
        scope 2 {
            debug __req => _8;
            scope 4 {
                debug __data => _12;
                scope 6 {
                    debug _request => _16;
                    scope 8 {
                        debug _log => _20;
                        scope 10 {
                            debug FromRequest => _24;
                            scope 12 {
                                debug Outcome => _28;
                                let mut _32: proc_macro2::TokenStream;
                                scope 14 {
                                    debug _s => _32;
                                    let _33: proc_macro2::Span;
                                    scope 15 {
                                        debug _span => _33;
                                        let mut _73: proc_macro2::TokenStream;
                                        let mut _86: proc_macro2::TokenStream;
                                        scope 16 {
                                            debug _s => _73;
                                            scope 17 {
                                            }
                                        }
                                        scope 18 {
                                            debug _s => _86;
                                            scope 19 {
                                                debug _span => _33;
                                                let mut _99: proc_macro2::TokenStream;
                                                let mut _122: proc_macro2::TokenStream;
                                                let mut _131: proc_macro2::TokenStream;
                                                let mut _202: proc_macro2::TokenStream;
                                                let mut _222: proc_macro2::TokenStream;
                                                scope 20 {
                                                    debug _s => _99;
                                                    scope 21 {
                                                        debug _span => _33;
                                                    }
                                                }
                                                scope 22 {
                                                    debug _s => _122;
                                                    scope 23 {
                                                        debug _span => _33;
                                                    }
                                                }
                                                scope 24 {
                                                    debug _s => _131;
                                                    scope 25 {
                                                        debug _span => _33;
                                                        let mut _146: proc_macro2::TokenStream;
                                                        let mut _182: proc_macro2::TokenStream;
                                                        scope 26 {
                                                            debug _s => _146;
                                                            scope 27 {
                                                                debug _span => _33;
                                                                let mut _161: proc_macro2::TokenStream;
                                                                scope 28 {
                                                                    debug _s => _161;
                                                                    scope 29 {
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 30 {
                                                            debug _s => _182;
                                                            scope 31 {
                                                            }
                                                        }
                                                    }
                                                }
                                                scope 32 {
                                                    debug _s => _202;
                                                    scope 33 {
                                                        debug _span => _33;
                                                        let mut _207: proc_macro2::TokenStream;
                                                        scope 34 {
                                                            debug _s => _207;
                                                            scope 35 {
                                                                debug _span => _33;
                                                            }
                                                        }
                                                    }
                                                }
                                                scope 36 {
                                                    debug _s => _222;
                                                    scope 37 {
                                                        debug _span => _33;
                                                        let mut _237: proc_macro2::TokenStream;
                                                        let mut _278: proc_macro2::TokenStream;
                                                        scope 38 {
                                                            debug _s => _237;
                                                            scope 39 {
                                                                debug _span => _33;
                                                                let mut _252: proc_macro2::TokenStream;
                                                                scope 40 {
                                                                    debug _s => _252;
                                                                    scope 41 {
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 42 {
                                                            debug _s => _278;
                                                            scope 43 {
                                                                debug _span => _33;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            scope 13 {
                                let _28: exports::StaticPath;
                            }
                        }
                        scope 11 {
                            let _24: exports::StaticPath;
                        }
                    }
                    scope 9 {
                        let _20: exports::StaticPath;
                    }
                }
                scope 7 {
                    let _16: exports::StaticPath;
                }
            }
            scope 5 {
                let _12: exports::StaticPath;
            }
        }
        scope 3 {
            let _8: exports::StaticPath;
        }
    }

    bb0: {
        _6 = &((*_1).1: proc_macro2::Ident);
        _5 = <proc_macro2::Ident as syn_ext::IdentExt>::rocketized(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &((*_1).2: syn::Type);
        _4 = (move _5, move _7);
        _2 = move (_4.0: proc_macro2::Ident);
        _3 = (_4.1: &syn::Type);
        _11 = _3;
        _10 = <syn::Type as devise::Spanned>::span(move _11) -> [return: bb2, unwind: bb125];
    }

    bb2: {
        _9 = Option::<proc_macro2::Span>::Some(move _10);
        _8 = StaticPath(move _9, const "__req");
        _15 = _3;
        _14 = <syn::Type as devise::Spanned>::span(move _15) -> [return: bb3, unwind: bb125];
    }

    bb3: {
        _13 = Option::<proc_macro2::Span>::Some(move _14);
        _12 = StaticPath(move _13, const "__data");
        _19 = _3;
        _18 = <syn::Type as devise::Spanned>::span(move _19) -> [return: bb4, unwind: bb125];
    }

    bb4: {
        _17 = Option::<proc_macro2::Span>::Some(move _18);
        _16 = StaticPath(move _17, const "::rocket::request");
        _23 = _3;
        _22 = <syn::Type as devise::Spanned>::span(move _23) -> [return: bb5, unwind: bb125];
    }

    bb5: {
        _21 = Option::<proc_macro2::Span>::Some(move _22);
        _20 = StaticPath(move _21, const "::rocket::log");
        _27 = _3;
        _26 = <syn::Type as devise::Spanned>::span(move _27) -> [return: bb6, unwind: bb125];
    }

    bb6: {
        _25 = Option::<proc_macro2::Span>::Some(move _26);
        _24 = StaticPath(move _25, const "::rocket::request::FromRequest");
        _31 = _3;
        _30 = <syn::Type as devise::Spanned>::span(move _31) -> [return: bb7, unwind: bb125];
    }

    bb7: {
        _29 = Option::<proc_macro2::Span>::Some(move _30);
        _28 = StaticPath(move _29, const "::rocket::outcome::Outcome");
        _32 = TokenStream2::new() -> [return: bb8, unwind: bb125];
    }

    bb8: {
        _34 = _3;
        _33 = <syn::Type as devise::Spanned>::span(move _34) -> [return: bb9, unwind: bb124];
    }

    bb9: {
        _36 = &mut _32;
        _37 = const "let";
        _35 = push_ident_spanned(_36, _33, _37) -> [return: bb10, unwind: bb124];
    }

    bb10: {
        _39 = &_2;
        _40 = &mut _32;
        _38 = <proc_macro2::Ident as ToTokens>::to_tokens(_39, _40) -> [return: bb11, unwind: bb124];
    }

    bb11: {
        _42 = &mut _32;
        _41 = push_colon_spanned(_42, _33) -> [return: bb12, unwind: bb124];
    }

    bb12: {
        _44 = &_3;
        _45 = &mut _32;
        _43 = <&syn::Type as ToTokens>::to_tokens(_44, _45) -> [return: bb13, unwind: bb124];
    }

    bb13: {
        _47 = &mut _32;
        _46 = push_eq_spanned(_47, _33) -> [return: bb14, unwind: bb124];
    }

    bb14: {
        _49 = &mut _32;
        _50 = const "match";
        _48 = push_ident_spanned(_49, _33, _50) -> [return: bb15, unwind: bb124];
    }

    bb15: {
        _52 = &mut _32;
        _51 = push_lt_spanned(_52, _33) -> [return: bb16, unwind: bb124];
    }

    bb16: {
        _54 = &_3;
        _55 = &mut _32;
        _53 = <&syn::Type as ToTokens>::to_tokens(_54, _55) -> [return: bb17, unwind: bb124];
    }

    bb17: {
        _57 = &mut _32;
        _58 = const "as";
        _56 = push_ident_spanned(_57, _33, _58) -> [return: bb18, unwind: bb124];
    }

    bb18: {
        _60 = &_24;
        _61 = &mut _32;
        _59 = <StaticPath as ToTokens>::to_tokens(_60, _61) -> [return: bb19, unwind: bb124];
    }

    bb19: {
        _63 = &mut _32;
        _62 = push_gt_spanned(_63, _33) -> [return: bb20, unwind: bb124];
    }

    bb20: {
        _65 = &mut _32;
        _64 = push_colon2_spanned(_65, _33) -> [return: bb21, unwind: bb124];
    }

    bb21: {
        _67 = &mut _32;
        _68 = const "from_request";
        _66 = push_ident_spanned(_67, _33, _68) -> [return: bb22, unwind: bb124];
    }

    bb22: {
        _70 = &mut _32;
        _71 = proc_macro2::Delimiter::Parenthesis;
        _73 = TokenStream2::new() -> [return: bb23, unwind: bb124];
    }

    bb23: {
        _75 = &_8;
        _76 = &mut _73;
        _74 = <StaticPath as ToTokens>::to_tokens(_75, _76) -> [return: bb24, unwind: bb123];
    }

    bb24: {
        _72 = move _73;
        _69 = push_group_spanned(_70, _33, move _71, move _72) -> [return: bb25, unwind: bb124];
    }

    bb25: {
        _78 = &mut _32;
        _77 = push_dot_spanned(_78, _33) -> [return: bb26, unwind: bb124];
    }

    bb26: {
        _80 = &mut _32;
        _81 = const "await";
        _79 = push_ident_spanned(_80, _33, _81) -> [return: bb27, unwind: bb124];
    }

    bb27: {
        _83 = &mut _32;
        _84 = proc_macro2::Delimiter::Brace;
        _86 = TokenStream2::new() -> [return: bb28, unwind: bb124];
    }

    bb28: {
        _88 = &_28;
        _89 = &mut _86;
        _87 = <StaticPath as ToTokens>::to_tokens(_88, _89) -> [return: bb29, unwind: bb122];
    }

    bb29: {
        _91 = &mut _86;
        _90 = push_colon2_spanned(_91, _33) -> [return: bb30, unwind: bb122];
    }

    bb30: {
        _93 = &mut _86;
        _94 = const "Success";
        _92 = push_ident_spanned(_93, _33, _94) -> [return: bb31, unwind: bb122];
    }

    bb31: {
        _96 = &mut _86;
        _97 = proc_macro2::Delimiter::Parenthesis;
        _99 = TokenStream2::new() -> [return: bb32, unwind: bb122];
    }

    bb32: {
        _101 = &mut _99;
        _102 = const "__v";
        _100 = push_ident_spanned(_101, _33, _102) -> [return: bb33, unwind: bb121];
    }

    bb33: {
        _98 = move _99;
        _95 = push_group_spanned(_96, _33, move _97, move _98) -> [return: bb34, unwind: bb122];
    }

    bb34: {
        _104 = &mut _86;
        _103 = push_fat_arrow_spanned(_104, _33) -> [return: bb35, unwind: bb122];
    }

    bb35: {
        _106 = &mut _86;
        _107 = const "__v";
        _105 = push_ident_spanned(_106, _33, _107) -> [return: bb36, unwind: bb122];
    }

    bb36: {
        _109 = &mut _86;
        _108 = push_comma_spanned(_109, _33) -> [return: bb37, unwind: bb122];
    }

    bb37: {
        _111 = &_28;
        _112 = &mut _86;
        _110 = <StaticPath as ToTokens>::to_tokens(_111, _112) -> [return: bb38, unwind: bb122];
    }

    bb38: {
        _114 = &mut _86;
        _113 = push_colon2_spanned(_114, _33) -> [return: bb39, unwind: bb122];
    }

    bb39: {
        _116 = &mut _86;
        _117 = const "Forward";
        _115 = push_ident_spanned(_116, _33, _117) -> [return: bb40, unwind: bb122];
    }

    bb40: {
        _119 = &mut _86;
        _120 = proc_macro2::Delimiter::Parenthesis;
        _122 = TokenStream2::new() -> [return: bb41, unwind: bb122];
    }

    bb41: {
        _124 = &mut _122;
        _123 = push_underscore_spanned(_124, _33) -> [return: bb42, unwind: bb120];
    }

    bb42: {
        _121 = move _122;
        _118 = push_group_spanned(_119, _33, move _120, move _121) -> [return: bb43, unwind: bb122];
    }

    bb43: {
        _126 = &mut _86;
        _125 = push_fat_arrow_spanned(_126, _33) -> [return: bb44, unwind: bb122];
    }

    bb44: {
        _128 = &mut _86;
        _129 = proc_macro2::Delimiter::Brace;
        _131 = TokenStream2::new() -> [return: bb45, unwind: bb122];
    }

    bb45: {
        _133 = &_20;
        _134 = &mut _131;
        _132 = <StaticPath as ToTokens>::to_tokens(_133, _134) -> [return: bb46, unwind: bb119];
    }

    bb46: {
        _136 = &mut _131;
        _135 = push_colon2_spanned(_136, _33) -> [return: bb47, unwind: bb119];
    }

    bb47: {
        _138 = &mut _131;
        _139 = const "warn_";
        _137 = push_ident_spanned(_138, _33, _139) -> [return: bb48, unwind: bb119];
    }

    bb48: {
        _141 = &mut _131;
        _140 = push_bang_spanned(_141, _33) -> [return: bb49, unwind: bb119];
    }

    bb49: {
        _143 = &mut _131;
        _144 = proc_macro2::Delimiter::Parenthesis;
        _146 = TokenStream2::new() -> [return: bb50, unwind: bb119];
    }

    bb50: {
        _148 = &mut _146;
        _149 = const "\"`{}` request guard is forwarding.\"";
        _147 = parse_spanned(_148, _33, _149) -> [return: bb51, unwind: bb118];
    }

    bb51: {
        _151 = &mut _146;
        _150 = push_comma_spanned(_151, _33) -> [return: bb52, unwind: bb118];
    }

    bb52: {
        _153 = &mut _146;
        _154 = const "stringify";
        _152 = push_ident_spanned(_153, _33, _154) -> [return: bb53, unwind: bb118];
    }

    bb53: {
        _156 = &mut _146;
        _155 = push_bang_spanned(_156, _33) -> [return: bb54, unwind: bb118];
    }

    bb54: {
        _158 = &mut _146;
        _159 = proc_macro2::Delimiter::Parenthesis;
        _161 = TokenStream2::new() -> [return: bb55, unwind: bb118];
    }

    bb55: {
        _163 = &_3;
        _164 = &mut _161;
        _162 = <&syn::Type as ToTokens>::to_tokens(_163, _164) -> [return: bb56, unwind: bb117];
    }

    bb56: {
        _160 = move _161;
        _157 = push_group_spanned(_158, _33, move _159, move _160) -> [return: bb57, unwind: bb118];
    }

    bb57: {
        _145 = move _146;
        _142 = push_group_spanned(_143, _33, move _144, move _145) -> [return: bb58, unwind: bb119];
    }

    bb58: {
        _166 = &mut _131;
        _165 = push_semi_spanned(_166, _33) -> [return: bb59, unwind: bb119];
    }

    bb59: {
        _168 = &mut _131;
        _169 = const "return";
        _167 = push_ident_spanned(_168, _33, _169) -> [return: bb60, unwind: bb119];
    }

    bb60: {
        _171 = &_28;
        _172 = &mut _131;
        _170 = <StaticPath as ToTokens>::to_tokens(_171, _172) -> [return: bb61, unwind: bb119];
    }

    bb61: {
        _174 = &mut _131;
        _173 = push_colon2_spanned(_174, _33) -> [return: bb62, unwind: bb119];
    }

    bb62: {
        _176 = &mut _131;
        _177 = const "Forward";
        _175 = push_ident_spanned(_176, _33, _177) -> [return: bb63, unwind: bb119];
    }

    bb63: {
        _179 = &mut _131;
        _180 = proc_macro2::Delimiter::Parenthesis;
        _182 = TokenStream2::new() -> [return: bb64, unwind: bb119];
    }

    bb64: {
        _184 = &_12;
        _185 = &mut _182;
        _183 = <StaticPath as ToTokens>::to_tokens(_184, _185) -> [return: bb65, unwind: bb116];
    }

    bb65: {
        _181 = move _182;
        _178 = push_group_spanned(_179, _33, move _180, move _181) -> [return: bb66, unwind: bb119];
    }

    bb66: {
        _187 = &mut _131;
        _186 = push_semi_spanned(_187, _33) -> [return: bb67, unwind: bb119];
    }

    bb67: {
        _130 = move _131;
        _127 = push_group_spanned(_128, _33, move _129, move _130) -> [return: bb68, unwind: bb122];
    }

    bb68: {
        _189 = &mut _86;
        _188 = push_comma_spanned(_189, _33) -> [return: bb69, unwind: bb122];
    }

    bb69: {
        _191 = &_28;
        _192 = &mut _86;
        _190 = <StaticPath as ToTokens>::to_tokens(_191, _192) -> [return: bb70, unwind: bb122];
    }

    bb70: {
        _194 = &mut _86;
        _193 = push_colon2_spanned(_194, _33) -> [return: bb71, unwind: bb122];
    }

    bb71: {
        _196 = &mut _86;
        _197 = const "Failure";
        _195 = push_ident_spanned(_196, _33, _197) -> [return: bb72, unwind: bb122];
    }

    bb72: {
        _199 = &mut _86;
        _200 = proc_macro2::Delimiter::Parenthesis;
        _202 = TokenStream2::new() -> [return: bb73, unwind: bb122];
    }

    bb73: {
        _204 = &mut _202;
        _205 = proc_macro2::Delimiter::Parenthesis;
        _207 = TokenStream2::new() -> [return: bb74, unwind: bb115];
    }

    bb74: {
        _209 = &mut _207;
        _210 = const "__c";
        _208 = push_ident_spanned(_209, _33, _210) -> [return: bb75, unwind: bb114];
    }

    bb75: {
        _212 = &mut _207;
        _211 = push_comma_spanned(_212, _33) -> [return: bb76, unwind: bb114];
    }

    bb76: {
        _214 = &mut _207;
        _215 = const "__e";
        _213 = push_ident_spanned(_214, _33, _215) -> [return: bb77, unwind: bb114];
    }

    bb77: {
        _206 = move _207;
        _203 = push_group_spanned(_204, _33, move _205, move _206) -> [return: bb78, unwind: bb115];
    }

    bb78: {
        _201 = move _202;
        _198 = push_group_spanned(_199, _33, move _200, move _201) -> [return: bb79, unwind: bb122];
    }

    bb79: {
        _217 = &mut _86;
        _216 = push_fat_arrow_spanned(_217, _33) -> [return: bb80, unwind: bb122];
    }

    bb80: {
        _219 = &mut _86;
        _220 = proc_macro2::Delimiter::Brace;
        _222 = TokenStream2::new() -> [return: bb81, unwind: bb122];
    }

    bb81: {
        _224 = &_20;
        _225 = &mut _222;
        _223 = <StaticPath as ToTokens>::to_tokens(_224, _225) -> [return: bb82, unwind: bb113];
    }

    bb82: {
        _227 = &mut _222;
        _226 = push_colon2_spanned(_227, _33) -> [return: bb83, unwind: bb113];
    }

    bb83: {
        _229 = &mut _222;
        _230 = const "warn_";
        _228 = push_ident_spanned(_229, _33, _230) -> [return: bb84, unwind: bb113];
    }

    bb84: {
        _232 = &mut _222;
        _231 = push_bang_spanned(_232, _33) -> [return: bb85, unwind: bb113];
    }

    bb85: {
        _234 = &mut _222;
        _235 = proc_macro2::Delimiter::Parenthesis;
        _237 = TokenStream2::new() -> [return: bb86, unwind: bb113];
    }

    bb86: {
        _239 = &mut _237;
        _240 = const "\"`{}` request guard failed: {:?}.\"";
        _238 = parse_spanned(_239, _33, _240) -> [return: bb87, unwind: bb112];
    }

    bb87: {
        _242 = &mut _237;
        _241 = push_comma_spanned(_242, _33) -> [return: bb88, unwind: bb112];
    }

    bb88: {
        _244 = &mut _237;
        _245 = const "stringify";
        _243 = push_ident_spanned(_244, _33, _245) -> [return: bb89, unwind: bb112];
    }

    bb89: {
        _247 = &mut _237;
        _246 = push_bang_spanned(_247, _33) -> [return: bb90, unwind: bb112];
    }

    bb90: {
        _249 = &mut _237;
        _250 = proc_macro2::Delimiter::Parenthesis;
        _252 = TokenStream2::new() -> [return: bb91, unwind: bb112];
    }

    bb91: {
        _254 = &_3;
        _255 = &mut _252;
        _253 = <&syn::Type as ToTokens>::to_tokens(_254, _255) -> [return: bb92, unwind: bb111];
    }

    bb92: {
        _251 = move _252;
        _248 = push_group_spanned(_249, _33, move _250, move _251) -> [return: bb93, unwind: bb112];
    }

    bb93: {
        _257 = &mut _237;
        _256 = push_comma_spanned(_257, _33) -> [return: bb94, unwind: bb112];
    }

    bb94: {
        _259 = &mut _237;
        _260 = const "__e";
        _258 = push_ident_spanned(_259, _33, _260) -> [return: bb95, unwind: bb112];
    }

    bb95: {
        _236 = move _237;
        _233 = push_group_spanned(_234, _33, move _235, move _236) -> [return: bb96, unwind: bb113];
    }

    bb96: {
        _262 = &mut _222;
        _261 = push_semi_spanned(_262, _33) -> [return: bb97, unwind: bb113];
    }

    bb97: {
        _264 = &mut _222;
        _265 = const "return";
        _263 = push_ident_spanned(_264, _33, _265) -> [return: bb98, unwind: bb113];
    }

    bb98: {
        _267 = &_28;
        _268 = &mut _222;
        _266 = <StaticPath as ToTokens>::to_tokens(_267, _268) -> [return: bb99, unwind: bb113];
    }

    bb99: {
        _270 = &mut _222;
        _269 = push_colon2_spanned(_270, _33) -> [return: bb100, unwind: bb113];
    }

    bb100: {
        _272 = &mut _222;
        _273 = const "Failure";
        _271 = push_ident_spanned(_272, _33, _273) -> [return: bb101, unwind: bb113];
    }

    bb101: {
        _275 = &mut _222;
        _276 = proc_macro2::Delimiter::Parenthesis;
        _278 = TokenStream2::new() -> [return: bb102, unwind: bb113];
    }

    bb102: {
        _280 = &mut _278;
        _281 = const "__c";
        _279 = push_ident_spanned(_280, _33, _281) -> [return: bb103, unwind: bb110];
    }

    bb103: {
        _277 = move _278;
        _274 = push_group_spanned(_275, _33, move _276, move _277) -> [return: bb104, unwind: bb113];
    }

    bb104: {
        _283 = &mut _222;
        _282 = push_semi_spanned(_283, _33) -> [return: bb105, unwind: bb113];
    }

    bb105: {
        _221 = move _222;
        _218 = push_group_spanned(_219, _33, move _220, move _221) -> [return: bb106, unwind: bb122];
    }

    bb106: {
        _85 = move _86;
        _82 = push_group_spanned(_83, _33, move _84, move _85) -> [return: bb107, unwind: bb124];
    }

    bb107: {
        _285 = &mut _32;
        _284 = push_semi_spanned(_285, _33) -> [return: bb108, unwind: bb124];
    }

    bb108: {
        _0 = move _32;
        drop(_2) -> [return: bb109, unwind continue];
    }

    bb109: {
        return;
    }

    bb110 (cleanup): {
        drop(_278) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_252) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_237) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_222) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_207) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_202) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_182) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        drop(_161) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        drop(_146) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb119 (cleanup): {
        drop(_131) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb120 (cleanup): {
        drop(_122) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb121 (cleanup): {
        drop(_99) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb122 (cleanup): {
        drop(_86) -> [return: bb124, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        drop(_73) -> [return: bb124, unwind terminate(cleanup)];
    }

    bb124 (cleanup): {
        drop(_32) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        drop(_2) -> [return: bb126, unwind terminate(cleanup)];
    }

    bb126 (cleanup): {
        resume;
    }
}

fn param_guard_decl(_1: &Guard) -> TokenStream2 {
    debug guard => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: usize;
    let _3: &name::Name;
    let _4: &syn::Type;
    let mut _5: (usize, &name::Name, &syn::Type);
    let mut _6: usize;
    let mut _7: &attribute::param::Dynamic;
    let mut _8: &name::Name;
    let _9: &attribute::param::Dynamic;
    let mut _10: &syn::Type;
    let mut _12: std::option::Option<proc_macro2::Span>;
    let mut _13: proc_macro2::Span;
    let mut _14: &syn::Type;
    let mut _16: std::option::Option<proc_macro2::Span>;
    let mut _17: proc_macro2::Span;
    let mut _18: &syn::Type;
    let mut _20: std::option::Option<proc_macro2::Span>;
    let mut _21: proc_macro2::Span;
    let mut _22: &syn::Type;
    let mut _24: std::option::Option<proc_macro2::Span>;
    let mut _25: proc_macro2::Span;
    let mut _26: &syn::Type;
    let mut _28: std::option::Option<proc_macro2::Span>;
    let mut _29: proc_macro2::Span;
    let mut _30: &syn::Type;
    let mut _32: std::option::Option<proc_macro2::Span>;
    let mut _33: proc_macro2::Span;
    let mut _34: &syn::Type;
    let mut _36: std::option::Option<proc_macro2::Span>;
    let mut _37: proc_macro2::Span;
    let mut _38: &syn::Type;
    let mut _40: std::option::Option<proc_macro2::Span>;
    let mut _41: proc_macro2::Span;
    let mut _42: &syn::Type;
    let mut _44: std::option::Option<proc_macro2::Span>;
    let mut _45: proc_macro2::Span;
    let mut _46: &syn::Type;
    let mut _48: std::option::Option<proc_macro2::Span>;
    let mut _49: proc_macro2::Span;
    let mut _50: &syn::Type;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let mut _55: proc_macro2::Delimiter;
    let mut _56: proc_macro2::TokenStream;
    let _58: ();
    let _59: &exports::StaticPath;
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: &str;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::Delimiter;
    let mut _71: proc_macro2::TokenStream;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: &str;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let _79: &&name::Name;
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: &str;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let mut _90: proc_macro2::Delimiter;
    let mut _91: proc_macro2::TokenStream;
    let _93: ();
    let _94: &&syn::Type;
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: ();
    let mut _97: &mut proc_macro2::TokenStream;
    let _98: ();
    let mut _99: &mut proc_macro2::TokenStream;
    let _100: &str;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: ();
    let _104: &exports::StaticPath;
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: ();
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: ();
    let mut _109: &mut proc_macro2::TokenStream;
    let _110: &str;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let mut _113: proc_macro2::Delimiter;
    let mut _114: proc_macro2::TokenStream;
    let _116: ();
    let _117: &exports::StaticPath;
    let mut _118: &mut proc_macro2::TokenStream;
    let mut _120: &attribute::param::Dynamic;
    let mut _123: &syn::Type;
    let _124: ();
    let mut _125: &mut proc_macro2::TokenStream;
    let _126: &str;
    let _127: ();
    let _128: &exports::StaticPath;
    let mut _129: &mut proc_macro2::TokenStream;
    let _130: ();
    let mut _131: &mut proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: &str;
    let _135: ();
    let mut _136: &mut proc_macro2::TokenStream;
    let mut _137: proc_macro2::Delimiter;
    let mut _138: proc_macro2::TokenStream;
    let _140: ();
    let _141: &usize;
    let mut _142: &mut proc_macro2::TokenStream;
    let _143: ();
    let mut _144: &mut proc_macro2::TokenStream;
    let mut _145: proc_macro2::Delimiter;
    let mut _146: proc_macro2::TokenStream;
    let _148: ();
    let _149: &exports::StaticPath;
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: ();
    let mut _152: &mut proc_macro2::TokenStream;
    let mut _153: proc_macro2::Delimiter;
    let mut _154: proc_macro2::TokenStream;
    let _156: ();
    let mut _157: &mut proc_macro2::TokenStream;
    let _158: &str;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: ();
    let mut _162: &mut proc_macro2::TokenStream;
    let _163: &str;
    let _164: ();
    let mut _165: &mut proc_macro2::TokenStream;
    let _166: ();
    let _167: &&syn::Type;
    let mut _168: &mut proc_macro2::TokenStream;
    let _169: ();
    let mut _170: &mut proc_macro2::TokenStream;
    let _171: &str;
    let _172: ();
    let _173: &exports::StaticPath;
    let mut _174: &mut proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: ();
    let mut _180: &mut proc_macro2::TokenStream;
    let _181: &str;
    let _182: ();
    let mut _183: &mut proc_macro2::TokenStream;
    let mut _184: proc_macro2::Delimiter;
    let mut _185: proc_macro2::TokenStream;
    let _187: ();
    let mut _188: &mut proc_macro2::TokenStream;
    let _189: &str;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let mut _192: proc_macro2::Delimiter;
    let mut _193: proc_macro2::TokenStream;
    let _195: ();
    let _196: &exports::StaticPath;
    let mut _197: &mut proc_macro2::TokenStream;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let mut _200: proc_macro2::Delimiter;
    let mut _201: proc_macro2::TokenStream;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let _205: &str;
    let _206: ();
    let mut _207: &mut proc_macro2::TokenStream;
    let _208: ();
    let mut _209: &mut proc_macro2::TokenStream;
    let _210: &str;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let _213: ();
    let _214: &exports::StaticPath;
    let mut _215: &mut proc_macro2::TokenStream;
    let _216: ();
    let mut _217: &mut proc_macro2::TokenStream;
    let mut _218: proc_macro2::Delimiter;
    let mut _219: proc_macro2::TokenStream;
    let _221: ();
    let mut _222: &mut proc_macro2::TokenStream;
    let _223: &str;
    let _224: ();
    let mut _225: &mut proc_macro2::TokenStream;
    let _226: ();
    let mut _227: &mut proc_macro2::TokenStream;
    let _228: &str;
    let _229: ();
    let _230: &proc_macro2::TokenStream;
    let mut _231: &mut proc_macro2::TokenStream;
    let _232: ();
    let mut _233: &mut proc_macro2::TokenStream;
    let _234: ();
    let mut _235: &mut proc_macro2::TokenStream;
    let _236: ();
    let _237: &exports::StaticPath;
    let mut _238: &mut proc_macro2::TokenStream;
    let _239: ();
    let mut _240: &mut proc_macro2::TokenStream;
    let _241: ();
    let mut _242: &mut proc_macro2::TokenStream;
    let mut _243: proc_macro2::Delimiter;
    let mut _244: proc_macro2::TokenStream;
    let _246: ();
    let _247: &exports::StaticPath;
    let mut _248: &mut proc_macro2::TokenStream;
    let _249: ();
    let mut _250: &mut proc_macro2::TokenStream;
    let _251: ();
    let mut _252: &mut proc_macro2::TokenStream;
    let _253: &str;
    let _254: ();
    let mut _255: &mut proc_macro2::TokenStream;
    let _256: ();
    let mut _257: &mut proc_macro2::TokenStream;
    let mut _258: proc_macro2::Delimiter;
    let mut _259: proc_macro2::TokenStream;
    let _261: ();
    let mut _262: &mut proc_macro2::TokenStream;
    let _263: &str;
    let _264: ();
    let mut _265: &mut proc_macro2::TokenStream;
    let _266: ();
    let _267: &exports::StaticPath;
    let mut _268: &mut proc_macro2::TokenStream;
    let _269: ();
    let mut _270: &mut proc_macro2::TokenStream;
    let _271: ();
    let mut _272: &mut proc_macro2::TokenStream;
    let _273: &str;
    let _274: ();
    let mut _275: &mut proc_macro2::TokenStream;
    let _276: ();
    let mut _277: &mut proc_macro2::TokenStream;
    let mut _278: proc_macro2::Delimiter;
    let mut _279: proc_macro2::TokenStream;
    let _281: ();
    let mut _282: &mut proc_macro2::TokenStream;
    let _283: &str;
    let _284: ();
    let mut _285: &mut proc_macro2::TokenStream;
    let _286: ();
    let _287: &exports::StaticPath;
    let mut _288: &mut proc_macro2::TokenStream;
    let _289: ();
    let mut _290: &mut proc_macro2::TokenStream;
    let _291: ();
    let mut _292: &mut proc_macro2::TokenStream;
    let _293: &str;
    let _294: ();
    let mut _295: &mut proc_macro2::TokenStream;
    let _296: ();
    let mut _297: &mut proc_macro2::TokenStream;
    let mut _298: proc_macro2::Delimiter;
    let mut _299: proc_macro2::TokenStream;
    let _301: ();
    let mut _302: &mut proc_macro2::TokenStream;
    let _303: &str;
    let _304: ();
    let mut _305: &mut proc_macro2::TokenStream;
    let _306: ();
    let mut _307: &mut proc_macro2::TokenStream;
    let _308: &str;
    let _309: ();
    let _310: &exports::StaticPath;
    let mut _311: &mut proc_macro2::TokenStream;
    let _312: ();
    let mut _313: &mut proc_macro2::TokenStream;
    let _314: ();
    let mut _315: &mut proc_macro2::TokenStream;
    let _316: &str;
    let _317: ();
    let mut _318: &mut proc_macro2::TokenStream;
    let mut _319: proc_macro2::Delimiter;
    let mut _320: proc_macro2::TokenStream;
    let _322: ();
    let _323: &exports::StaticPath;
    let mut _324: &mut proc_macro2::TokenStream;
    let _325: ();
    let mut _326: &mut proc_macro2::TokenStream;
    let mut _329: &syn::Type;
    let _330: ();
    let mut _331: &mut proc_macro2::TokenStream;
    let _332: &str;
    let _333: ();
    let mut _334: &mut proc_macro2::TokenStream;
    let _335: ();
    let _336: &&syn::Type;
    let mut _337: &mut proc_macro2::TokenStream;
    let _338: ();
    let mut _339: &mut proc_macro2::TokenStream;
    let _340: &str;
    let _341: ();
    let _342: &exports::StaticPath;
    let mut _343: &mut proc_macro2::TokenStream;
    let _344: ();
    let mut _345: &mut proc_macro2::TokenStream;
    let _346: ();
    let mut _347: &mut proc_macro2::TokenStream;
    let _348: ();
    let mut _349: &mut proc_macro2::TokenStream;
    let _350: &str;
    let _351: ();
    let mut _352: &mut proc_macro2::TokenStream;
    let mut _353: proc_macro2::Delimiter;
    let mut _354: proc_macro2::TokenStream;
    let _356: ();
    let _357: &exports::StaticPath;
    let mut _358: &mut proc_macro2::TokenStream;
    let _359: ();
    let mut _360: &mut proc_macro2::TokenStream;
    let _361: ();
    let mut _362: &mut proc_macro2::TokenStream;
    let _363: &str;
    let _364: ();
    let mut _365: &mut proc_macro2::TokenStream;
    let mut _366: proc_macro2::Delimiter;
    let mut _367: proc_macro2::TokenStream;
    let _369: ();
    let _370: &usize;
    let mut _371: &mut proc_macro2::TokenStream;
    let _372: ();
    let mut _373: &mut proc_macro2::TokenStream;
    let _374: ();
    let mut _375: &mut proc_macro2::TokenStream;
    let mut _376: proc_macro2::Delimiter;
    let mut _377: proc_macro2::TokenStream;
    let _379: ();
    let _380: &exports::StaticPath;
    let mut _381: &mut proc_macro2::TokenStream;
    let _382: ();
    let mut _383: &mut proc_macro2::TokenStream;
    let mut _384: proc_macro2::Delimiter;
    let mut _385: proc_macro2::TokenStream;
    let _387: ();
    let mut _388: &mut proc_macro2::TokenStream;
    let _389: &str;
    let _390: ();
    let mut _391: &mut proc_macro2::TokenStream;
    let _392: ();
    let mut _393: &mut proc_macro2::TokenStream;
    let _394: &str;
    let _395: ();
    let mut _396: &mut proc_macro2::TokenStream;
    let _397: ();
    let _398: &exports::StaticPath;
    let mut _399: &mut proc_macro2::TokenStream;
    let _400: ();
    let mut _401: &mut proc_macro2::TokenStream;
    let mut _402: proc_macro2::Delimiter;
    let mut _403: proc_macro2::TokenStream;
    let _405: ();
    let mut _406: &mut proc_macro2::TokenStream;
    let _407: &str;
    let _408: ();
    let mut _409: &mut proc_macro2::TokenStream;
    let _410: ();
    let mut _411: &mut proc_macro2::TokenStream;
    let _412: &str;
    let _413: ();
    let _414: &proc_macro2::TokenStream;
    let mut _415: &mut proc_macro2::TokenStream;
    let _416: ();
    let mut _417: &mut proc_macro2::TokenStream;
    let mut _419: &proc_macro2::Ident;
    let _421: ();
    let mut _422: &mut proc_macro2::TokenStream;
    let _423: &str;
    let _424: ();
    let _425: &proc_macro2::Ident;
    let mut _426: &mut proc_macro2::TokenStream;
    let _427: ();
    let mut _428: &mut proc_macro2::TokenStream;
    let _429: ();
    let _430: &&syn::Type;
    let mut _431: &mut proc_macro2::TokenStream;
    let _432: ();
    let mut _433: &mut proc_macro2::TokenStream;
    let _434: ();
    let _435: &proc_macro2::TokenStream;
    let mut _436: &mut proc_macro2::TokenStream;
    let _437: ();
    let mut _438: &mut proc_macro2::TokenStream;
    scope 1 {
        debug i => _2;
        debug name => _3;
        debug ty => _4;
        scope 2 {
            debug __req => _11;
            scope 4 {
                debug __data => _15;
                scope 6 {
                    debug _log => _19;
                    scope 8 {
                        debug _None => _23;
                        scope 10 {
                            debug _Some => _27;
                            scope 12 {
                                debug _Ok => _31;
                                scope 14 {
                                    debug _Err => _35;
                                    scope 16 {
                                        debug Outcome => _39;
                                        scope 18 {
                                            debug FromSegments => _43;
                                            scope 20 {
                                                debug FromParam => _47;
                                                let _51: proc_macro2::TokenStream;
                                                let mut _52: proc_macro2::TokenStream;
                                                scope 22 {
                                                    debug parse_error => _51;
                                                    let _119: proc_macro2::TokenStream;
                                                    let mut _121: proc_macro2::TokenStream;
                                                    let mut _327: proc_macro2::TokenStream;
                                                    scope 28 {
                                                        debug expr => _119;
                                                        let _418: proc_macro2::Ident;
                                                        scope 67 {
                                                            debug ident => _418;
                                                            let mut _420: proc_macro2::TokenStream;
                                                            scope 68 {
                                                                debug _s => _420;
                                                            }
                                                        }
                                                    }
                                                    scope 29 {
                                                        debug _s => _121;
                                                        let _122: proc_macro2::Span;
                                                        scope 30 {
                                                            debug _span => _122;
                                                            let mut _139: proc_macro2::TokenStream;
                                                            let mut _147: proc_macro2::TokenStream;
                                                            scope 31 {
                                                                debug _s => _139;
                                                                scope 32 {
                                                                }
                                                            }
                                                            scope 33 {
                                                                debug _s => _147;
                                                                scope 34 {
                                                                    debug _span => _122;
                                                                    let mut _155: proc_macro2::TokenStream;
                                                                    let mut _186: proc_macro2::TokenStream;
                                                                    let mut _194: proc_macro2::TokenStream;
                                                                    let mut _245: proc_macro2::TokenStream;
                                                                    scope 35 {
                                                                        debug _s => _155;
                                                                        scope 36 {
                                                                            debug _span => _122;
                                                                        }
                                                                    }
                                                                    scope 37 {
                                                                        debug _s => _186;
                                                                        scope 38 {
                                                                            debug _span => _122;
                                                                        }
                                                                    }
                                                                    scope 39 {
                                                                        debug _s => _194;
                                                                        scope 40 {
                                                                            debug _span => _122;
                                                                            let mut _202: proc_macro2::TokenStream;
                                                                            let mut _220: proc_macro2::TokenStream;
                                                                            scope 41 {
                                                                                debug _s => _202;
                                                                                scope 42 {
                                                                                    debug _span => _122;
                                                                                }
                                                                            }
                                                                            scope 43 {
                                                                                debug _s => _220;
                                                                                scope 44 {
                                                                                    debug _span => _122;
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 45 {
                                                                        debug _s => _245;
                                                                        scope 46 {
                                                                            debug _span => _122;
                                                                            let mut _260: proc_macro2::TokenStream;
                                                                            let mut _280: proc_macro2::TokenStream;
                                                                            let mut _300: proc_macro2::TokenStream;
                                                                            let mut _321: proc_macro2::TokenStream;
                                                                            scope 47 {
                                                                                debug _s => _260;
                                                                                scope 48 {
                                                                                    debug _span => _122;
                                                                                }
                                                                            }
                                                                            scope 49 {
                                                                                debug _s => _280;
                                                                                scope 50 {
                                                                                    debug _span => _122;
                                                                                }
                                                                            }
                                                                            scope 51 {
                                                                                debug _s => _300;
                                                                                scope 52 {
                                                                                    debug _span => _122;
                                                                                }
                                                                            }
                                                                            scope 53 {
                                                                                debug _s => _321;
                                                                                scope 54 {
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 55 {
                                                        debug _s => _327;
                                                        let _328: proc_macro2::Span;
                                                        scope 56 {
                                                            debug _span => _328;
                                                            let mut _355: proc_macro2::TokenStream;
                                                            let mut _378: proc_macro2::TokenStream;
                                                            scope 57 {
                                                                debug _s => _355;
                                                                scope 58 {
                                                                    debug _span => _328;
                                                                    let mut _368: proc_macro2::TokenStream;
                                                                    scope 59 {
                                                                        debug _s => _368;
                                                                        scope 60 {
                                                                            debug _span => _328;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            scope 61 {
                                                                debug _s => _378;
                                                                scope 62 {
                                                                    debug _span => _328;
                                                                    let mut _386: proc_macro2::TokenStream;
                                                                    let mut _404: proc_macro2::TokenStream;
                                                                    scope 63 {
                                                                        debug _s => _386;
                                                                        scope 64 {
                                                                            debug _span => _328;
                                                                        }
                                                                    }
                                                                    scope 65 {
                                                                        debug _s => _404;
                                                                        scope 66 {
                                                                            debug _span => _328;
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                scope 23 {
                                                    debug _s => _52;
                                                    let mut _57: proc_macro2::TokenStream;
                                                    scope 24 {
                                                        debug _s => _57;
                                                        let mut _72: proc_macro2::TokenStream;
                                                        let mut _115: proc_macro2::TokenStream;
                                                        scope 25 {
                                                            debug _s => _72;
                                                            let mut _92: proc_macro2::TokenStream;
                                                            scope 26 {
                                                                debug _s => _92;
                                                            }
                                                        }
                                                        scope 27 {
                                                            debug _s => _115;
                                                        }
                                                    }
                                                }
                                            }
                                            scope 21 {
                                                let _47: exports::StaticPath;
                                            }
                                        }
                                        scope 19 {
                                            let _43: exports::StaticPath;
                                        }
                                    }
                                    scope 17 {
                                        let _39: exports::StaticPath;
                                    }
                                }
                                scope 15 {
                                    let _35: exports::StaticPath;
                                }
                            }
                            scope 13 {
                                let _31: exports::StaticPath;
                            }
                        }
                        scope 11 {
                            let _27: exports::StaticPath;
                        }
                    }
                    scope 9 {
                        let _23: exports::StaticPath;
                    }
                }
                scope 7 {
                    let _19: exports::StaticPath;
                }
            }
            scope 5 {
                let _15: exports::StaticPath;
            }
        }
        scope 3 {
            let _11: exports::StaticPath;
        }
    }

    bb0: {
        _7 = <Guard as std::ops::Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = ((*_7).1: usize);
        _9 = <Guard as std::ops::Deref>::deref(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &((*_9).0: name::Name);
        _10 = &((*_1).2: syn::Type);
        _5 = (move _6, move _8, move _10);
        _2 = (_5.0: usize);
        _3 = (_5.1: &name::Name);
        _4 = (_5.2: &syn::Type);
        _14 = _4;
        _13 = <syn::Type as devise::Spanned>::span(move _14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = Option::<proc_macro2::Span>::Some(move _13);
        _11 = StaticPath(move _12, const "__req");
        _18 = _4;
        _17 = <syn::Type as devise::Spanned>::span(move _18) -> [return: bb4, unwind continue];
    }

    bb4: {
        _16 = Option::<proc_macro2::Span>::Some(move _17);
        _15 = StaticPath(move _16, const "__data");
        _22 = _4;
        _21 = <syn::Type as devise::Spanned>::span(move _22) -> [return: bb5, unwind continue];
    }

    bb5: {
        _20 = Option::<proc_macro2::Span>::Some(move _21);
        _19 = StaticPath(move _20, const "::rocket::log");
        _26 = _4;
        _25 = <syn::Type as devise::Spanned>::span(move _26) -> [return: bb6, unwind continue];
    }

    bb6: {
        _24 = Option::<proc_macro2::Span>::Some(move _25);
        _23 = StaticPath(move _24, const "::std::option::Option::None");
        _30 = _4;
        _29 = <syn::Type as devise::Spanned>::span(move _30) -> [return: bb7, unwind continue];
    }

    bb7: {
        _28 = Option::<proc_macro2::Span>::Some(move _29);
        _27 = StaticPath(move _28, const "::std::option::Option::Some");
        _34 = _4;
        _33 = <syn::Type as devise::Spanned>::span(move _34) -> [return: bb8, unwind continue];
    }

    bb8: {
        _32 = Option::<proc_macro2::Span>::Some(move _33);
        _31 = StaticPath(move _32, const "::std::result::Result::Ok");
        _38 = _4;
        _37 = <syn::Type as devise::Spanned>::span(move _38) -> [return: bb9, unwind continue];
    }

    bb9: {
        _36 = Option::<proc_macro2::Span>::Some(move _37);
        _35 = StaticPath(move _36, const "::std::result::Result::Err");
        _42 = _4;
        _41 = <syn::Type as devise::Spanned>::span(move _42) -> [return: bb10, unwind continue];
    }

    bb10: {
        _40 = Option::<proc_macro2::Span>::Some(move _41);
        _39 = StaticPath(move _40, const "::rocket::outcome::Outcome");
        _46 = _4;
        _45 = <syn::Type as devise::Spanned>::span(move _46) -> [return: bb11, unwind continue];
    }

    bb11: {
        _44 = Option::<proc_macro2::Span>::Some(move _45);
        _43 = StaticPath(move _44, const "::rocket::request::FromSegments");
        _50 = _4;
        _49 = <syn::Type as devise::Spanned>::span(move _50) -> [return: bb12, unwind continue];
    }

    bb12: {
        _48 = Option::<proc_macro2::Span>::Some(move _49);
        _47 = StaticPath(move _48, const "::rocket::request::FromParam");
        _52 = TokenStream2::new() -> [return: bb13, unwind continue];
    }

    bb13: {
        _54 = &mut _52;
        _55 = proc_macro2::Delimiter::Brace;
        _57 = TokenStream2::new() -> [return: bb14, unwind: bb200];
    }

    bb14: {
        _59 = &_19;
        _60 = &mut _57;
        _58 = <StaticPath as ToTokens>::to_tokens(_59, _60) -> [return: bb15, unwind: bb199];
    }

    bb15: {
        _62 = &mut _57;
        _61 = push_colon2(_62) -> [return: bb16, unwind: bb199];
    }

    bb16: {
        _64 = &mut _57;
        _65 = const "warn_";
        _63 = push_ident(_64, _65) -> [return: bb17, unwind: bb199];
    }

    bb17: {
        _67 = &mut _57;
        _66 = push_bang(_67) -> [return: bb18, unwind: bb199];
    }

    bb18: {
        _69 = &mut _57;
        _70 = proc_macro2::Delimiter::Parenthesis;
        _72 = TokenStream2::new() -> [return: bb19, unwind: bb199];
    }

    bb19: {
        _74 = &mut _72;
        _75 = const "\"`{}: {}` param guard parsed forwarding with error {:?}\"";
        _73 = quote::__private::parse(_74, _75) -> [return: bb20, unwind: bb198];
    }

    bb20: {
        _77 = &mut _72;
        _76 = push_comma(_77) -> [return: bb21, unwind: bb198];
    }

    bb21: {
        _79 = &_3;
        _80 = &mut _72;
        _78 = <&name::Name as ToTokens>::to_tokens(_79, _80) -> [return: bb22, unwind: bb198];
    }

    bb22: {
        _82 = &mut _72;
        _81 = push_comma(_82) -> [return: bb23, unwind: bb198];
    }

    bb23: {
        _84 = &mut _72;
        _85 = const "stringify";
        _83 = push_ident(_84, _85) -> [return: bb24, unwind: bb198];
    }

    bb24: {
        _87 = &mut _72;
        _86 = push_bang(_87) -> [return: bb25, unwind: bb198];
    }

    bb25: {
        _89 = &mut _72;
        _90 = proc_macro2::Delimiter::Parenthesis;
        _92 = TokenStream2::new() -> [return: bb26, unwind: bb198];
    }

    bb26: {
        _94 = &_4;
        _95 = &mut _92;
        _93 = <&syn::Type as ToTokens>::to_tokens(_94, _95) -> [return: bb27, unwind: bb197];
    }

    bb27: {
        _91 = move _92;
        _88 = push_group(_89, move _90, move _91) -> [return: bb28, unwind: bb198];
    }

    bb28: {
        _97 = &mut _72;
        _96 = push_comma(_97) -> [return: bb29, unwind: bb198];
    }

    bb29: {
        _99 = &mut _72;
        _100 = const "__error";
        _98 = push_ident(_99, _100) -> [return: bb30, unwind: bb198];
    }

    bb30: {
        _71 = move _72;
        _68 = push_group(_69, move _70, move _71) -> [return: bb31, unwind: bb199];
    }

    bb31: {
        _102 = &mut _57;
        _101 = push_semi(_102) -> [return: bb32, unwind: bb199];
    }

    bb32: {
        _104 = &_39;
        _105 = &mut _57;
        _103 = <StaticPath as ToTokens>::to_tokens(_104, _105) -> [return: bb33, unwind: bb199];
    }

    bb33: {
        _107 = &mut _57;
        _106 = push_colon2(_107) -> [return: bb34, unwind: bb199];
    }

    bb34: {
        _109 = &mut _57;
        _110 = const "Forward";
        _108 = push_ident(_109, _110) -> [return: bb35, unwind: bb199];
    }

    bb35: {
        _112 = &mut _57;
        _113 = proc_macro2::Delimiter::Parenthesis;
        _115 = TokenStream2::new() -> [return: bb36, unwind: bb199];
    }

    bb36: {
        _117 = &_15;
        _118 = &mut _115;
        _116 = <StaticPath as ToTokens>::to_tokens(_117, _118) -> [return: bb37, unwind: bb196];
    }

    bb37: {
        _114 = move _115;
        _111 = push_group(_112, move _113, move _114) -> [return: bb38, unwind: bb199];
    }

    bb38: {
        _56 = move _57;
        _53 = push_group(_54, move _55, move _56) -> [return: bb39, unwind: bb200];
    }

    bb39: {
        _51 = move _52;
        _120 = <Guard as std::ops::Deref>::deref(_1) -> [return: bb40, unwind: bb195];
    }

    bb40: {
        switchInt(((*_120).2: bool)) -> [0: bb42, otherwise: bb41];
    }

    bb41: {
        _327 = TokenStream2::new() -> [return: bb124, unwind: bb195];
    }

    bb42: {
        _121 = TokenStream2::new() -> [return: bb43, unwind: bb195];
    }

    bb43: {
        _123 = _4;
        _122 = <syn::Type as devise::Spanned>::span(move _123) -> [return: bb44, unwind: bb194];
    }

    bb44: {
        _125 = &mut _121;
        _126 = const "match";
        _124 = push_ident_spanned(_125, _122, _126) -> [return: bb45, unwind: bb194];
    }

    bb45: {
        _128 = &_11;
        _129 = &mut _121;
        _127 = <StaticPath as ToTokens>::to_tokens(_128, _129) -> [return: bb46, unwind: bb194];
    }

    bb46: {
        _131 = &mut _121;
        _130 = push_dot_spanned(_131, _122) -> [return: bb47, unwind: bb194];
    }

    bb47: {
        _133 = &mut _121;
        _134 = const "routed_segment";
        _132 = push_ident_spanned(_133, _122, _134) -> [return: bb48, unwind: bb194];
    }

    bb48: {
        _136 = &mut _121;
        _137 = proc_macro2::Delimiter::Parenthesis;
        _139 = TokenStream2::new() -> [return: bb49, unwind: bb194];
    }

    bb49: {
        _141 = &_2;
        _142 = &mut _139;
        _140 = <usize as ToTokens>::to_tokens(_141, _142) -> [return: bb50, unwind: bb193];
    }

    bb50: {
        _138 = move _139;
        _135 = push_group_spanned(_136, _122, move _137, move _138) -> [return: bb51, unwind: bb194];
    }

    bb51: {
        _144 = &mut _121;
        _145 = proc_macro2::Delimiter::Brace;
        _147 = TokenStream2::new() -> [return: bb52, unwind: bb194];
    }

    bb52: {
        _149 = &_27;
        _150 = &mut _147;
        _148 = <StaticPath as ToTokens>::to_tokens(_149, _150) -> [return: bb53, unwind: bb192];
    }

    bb53: {
        _152 = &mut _147;
        _153 = proc_macro2::Delimiter::Parenthesis;
        _155 = TokenStream2::new() -> [return: bb54, unwind: bb192];
    }

    bb54: {
        _157 = &mut _155;
        _158 = const "__s";
        _156 = push_ident_spanned(_157, _122, _158) -> [return: bb55, unwind: bb191];
    }

    bb55: {
        _154 = move _155;
        _151 = push_group_spanned(_152, _122, move _153, move _154) -> [return: bb56, unwind: bb192];
    }

    bb56: {
        _160 = &mut _147;
        _159 = push_fat_arrow_spanned(_160, _122) -> [return: bb57, unwind: bb192];
    }

    bb57: {
        _162 = &mut _147;
        _163 = const "match";
        _161 = push_ident_spanned(_162, _122, _163) -> [return: bb58, unwind: bb192];
    }

    bb58: {
        _165 = &mut _147;
        _164 = push_lt_spanned(_165, _122) -> [return: bb59, unwind: bb192];
    }

    bb59: {
        _167 = &_4;
        _168 = &mut _147;
        _166 = <&syn::Type as ToTokens>::to_tokens(_167, _168) -> [return: bb60, unwind: bb192];
    }

    bb60: {
        _170 = &mut _147;
        _171 = const "as";
        _169 = push_ident_spanned(_170, _122, _171) -> [return: bb61, unwind: bb192];
    }

    bb61: {
        _173 = &_47;
        _174 = &mut _147;
        _172 = <StaticPath as ToTokens>::to_tokens(_173, _174) -> [return: bb62, unwind: bb192];
    }

    bb62: {
        _176 = &mut _147;
        _175 = push_gt_spanned(_176, _122) -> [return: bb63, unwind: bb192];
    }

    bb63: {
        _178 = &mut _147;
        _177 = push_colon2_spanned(_178, _122) -> [return: bb64, unwind: bb192];
    }

    bb64: {
        _180 = &mut _147;
        _181 = const "from_param";
        _179 = push_ident_spanned(_180, _122, _181) -> [return: bb65, unwind: bb192];
    }

    bb65: {
        _183 = &mut _147;
        _184 = proc_macro2::Delimiter::Parenthesis;
        _186 = TokenStream2::new() -> [return: bb66, unwind: bb192];
    }

    bb66: {
        _188 = &mut _186;
        _189 = const "__s";
        _187 = push_ident_spanned(_188, _122, _189) -> [return: bb67, unwind: bb190];
    }

    bb67: {
        _185 = move _186;
        _182 = push_group_spanned(_183, _122, move _184, move _185) -> [return: bb68, unwind: bb192];
    }

    bb68: {
        _191 = &mut _147;
        _192 = proc_macro2::Delimiter::Brace;
        _194 = TokenStream2::new() -> [return: bb69, unwind: bb192];
    }

    bb69: {
        _196 = &_31;
        _197 = &mut _194;
        _195 = <StaticPath as ToTokens>::to_tokens(_196, _197) -> [return: bb70, unwind: bb189];
    }

    bb70: {
        _199 = &mut _194;
        _200 = proc_macro2::Delimiter::Parenthesis;
        _202 = TokenStream2::new() -> [return: bb71, unwind: bb189];
    }

    bb71: {
        _204 = &mut _202;
        _205 = const "__v";
        _203 = push_ident_spanned(_204, _122, _205) -> [return: bb72, unwind: bb188];
    }

    bb72: {
        _201 = move _202;
        _198 = push_group_spanned(_199, _122, move _200, move _201) -> [return: bb73, unwind: bb189];
    }

    bb73: {
        _207 = &mut _194;
        _206 = push_fat_arrow_spanned(_207, _122) -> [return: bb74, unwind: bb189];
    }

    bb74: {
        _209 = &mut _194;
        _210 = const "__v";
        _208 = push_ident_spanned(_209, _122, _210) -> [return: bb75, unwind: bb189];
    }

    bb75: {
        _212 = &mut _194;
        _211 = push_comma_spanned(_212, _122) -> [return: bb76, unwind: bb189];
    }

    bb76: {
        _214 = &_35;
        _215 = &mut _194;
        _213 = <StaticPath as ToTokens>::to_tokens(_214, _215) -> [return: bb77, unwind: bb189];
    }

    bb77: {
        _217 = &mut _194;
        _218 = proc_macro2::Delimiter::Parenthesis;
        _220 = TokenStream2::new() -> [return: bb78, unwind: bb189];
    }

    bb78: {
        _222 = &mut _220;
        _223 = const "__error";
        _221 = push_ident_spanned(_222, _122, _223) -> [return: bb79, unwind: bb187];
    }

    bb79: {
        _219 = move _220;
        _216 = push_group_spanned(_217, _122, move _218, move _219) -> [return: bb80, unwind: bb189];
    }

    bb80: {
        _225 = &mut _194;
        _224 = push_fat_arrow_spanned(_225, _122) -> [return: bb81, unwind: bb189];
    }

    bb81: {
        _227 = &mut _194;
        _228 = const "return";
        _226 = push_ident_spanned(_227, _122, _228) -> [return: bb82, unwind: bb189];
    }

    bb82: {
        _230 = &_51;
        _231 = &mut _194;
        _229 = <TokenStream2 as ToTokens>::to_tokens(_230, _231) -> [return: bb83, unwind: bb189];
    }

    bb83: {
        _233 = &mut _194;
        _232 = push_comma_spanned(_233, _122) -> [return: bb84, unwind: bb189];
    }

    bb84: {
        _193 = move _194;
        _190 = push_group_spanned(_191, _122, move _192, move _193) -> [return: bb85, unwind: bb192];
    }

    bb85: {
        _235 = &mut _147;
        _234 = push_comma_spanned(_235, _122) -> [return: bb86, unwind: bb192];
    }

    bb86: {
        _237 = &_23;
        _238 = &mut _147;
        _236 = <StaticPath as ToTokens>::to_tokens(_237, _238) -> [return: bb87, unwind: bb192];
    }

    bb87: {
        _240 = &mut _147;
        _239 = push_fat_arrow_spanned(_240, _122) -> [return: bb88, unwind: bb192];
    }

    bb88: {
        _242 = &mut _147;
        _243 = proc_macro2::Delimiter::Brace;
        _245 = TokenStream2::new() -> [return: bb89, unwind: bb192];
    }

    bb89: {
        _247 = &_19;
        _248 = &mut _245;
        _246 = <StaticPath as ToTokens>::to_tokens(_247, _248) -> [return: bb90, unwind: bb186];
    }

    bb90: {
        _250 = &mut _245;
        _249 = push_colon2_spanned(_250, _122) -> [return: bb91, unwind: bb186];
    }

    bb91: {
        _252 = &mut _245;
        _253 = const "error_";
        _251 = push_ident_spanned(_252, _122, _253) -> [return: bb92, unwind: bb186];
    }

    bb92: {
        _255 = &mut _245;
        _254 = push_bang_spanned(_255, _122) -> [return: bb93, unwind: bb186];
    }

    bb93: {
        _257 = &mut _245;
        _258 = proc_macro2::Delimiter::Parenthesis;
        _260 = TokenStream2::new() -> [return: bb94, unwind: bb186];
    }

    bb94: {
        _262 = &mut _260;
        _263 = const "\"Internal invariant broken: dyn param not found.\"";
        _261 = parse_spanned(_262, _122, _263) -> [return: bb95, unwind: bb185];
    }

    bb95: {
        _259 = move _260;
        _256 = push_group_spanned(_257, _122, move _258, move _259) -> [return: bb96, unwind: bb186];
    }

    bb96: {
        _265 = &mut _245;
        _264 = push_semi_spanned(_265, _122) -> [return: bb97, unwind: bb186];
    }

    bb97: {
        _267 = &_19;
        _268 = &mut _245;
        _266 = <StaticPath as ToTokens>::to_tokens(_267, _268) -> [return: bb98, unwind: bb186];
    }

    bb98: {
        _270 = &mut _245;
        _269 = push_colon2_spanned(_270, _122) -> [return: bb99, unwind: bb186];
    }

    bb99: {
        _272 = &mut _245;
        _273 = const "error_";
        _271 = push_ident_spanned(_272, _122, _273) -> [return: bb100, unwind: bb186];
    }

    bb100: {
        _275 = &mut _245;
        _274 = push_bang_spanned(_275, _122) -> [return: bb101, unwind: bb186];
    }

    bb101: {
        _277 = &mut _245;
        _278 = proc_macro2::Delimiter::Parenthesis;
        _280 = TokenStream2::new() -> [return: bb102, unwind: bb186];
    }

    bb102: {
        _282 = &mut _280;
        _283 = const "\"Please report this to the Rocket issue tracker.\"";
        _281 = parse_spanned(_282, _122, _283) -> [return: bb103, unwind: bb184];
    }

    bb103: {
        _279 = move _280;
        _276 = push_group_spanned(_277, _122, move _278, move _279) -> [return: bb104, unwind: bb186];
    }

    bb104: {
        _285 = &mut _245;
        _284 = push_semi_spanned(_285, _122) -> [return: bb105, unwind: bb186];
    }

    bb105: {
        _287 = &_19;
        _288 = &mut _245;
        _286 = <StaticPath as ToTokens>::to_tokens(_287, _288) -> [return: bb106, unwind: bb186];
    }

    bb106: {
        _290 = &mut _245;
        _289 = push_colon2_spanned(_290, _122) -> [return: bb107, unwind: bb186];
    }

    bb107: {
        _292 = &mut _245;
        _293 = const "error_";
        _291 = push_ident_spanned(_292, _122, _293) -> [return: bb108, unwind: bb186];
    }

    bb108: {
        _295 = &mut _245;
        _294 = push_bang_spanned(_295, _122) -> [return: bb109, unwind: bb186];
    }

    bb109: {
        _297 = &mut _245;
        _298 = proc_macro2::Delimiter::Parenthesis;
        _300 = TokenStream2::new() -> [return: bb110, unwind: bb186];
    }

    bb110: {
        _302 = &mut _300;
        _303 = const "\"https://github.com/SergioBenitez/Rocket/issues\"";
        _301 = parse_spanned(_302, _122, _303) -> [return: bb111, unwind: bb183];
    }

    bb111: {
        _299 = move _300;
        _296 = push_group_spanned(_297, _122, move _298, move _299) -> [return: bb112, unwind: bb186];
    }

    bb112: {
        _305 = &mut _245;
        _304 = push_semi_spanned(_305, _122) -> [return: bb113, unwind: bb186];
    }

    bb113: {
        _307 = &mut _245;
        _308 = const "return";
        _306 = push_ident_spanned(_307, _122, _308) -> [return: bb114, unwind: bb186];
    }

    bb114: {
        _310 = &_39;
        _311 = &mut _245;
        _309 = <StaticPath as ToTokens>::to_tokens(_310, _311) -> [return: bb115, unwind: bb186];
    }

    bb115: {
        _313 = &mut _245;
        _312 = push_colon2_spanned(_313, _122) -> [return: bb116, unwind: bb186];
    }

    bb116: {
        _315 = &mut _245;
        _316 = const "Forward";
        _314 = push_ident_spanned(_315, _122, _316) -> [return: bb117, unwind: bb186];
    }

    bb117: {
        _318 = &mut _245;
        _319 = proc_macro2::Delimiter::Parenthesis;
        _321 = TokenStream2::new() -> [return: bb118, unwind: bb186];
    }

    bb118: {
        _323 = &_15;
        _324 = &mut _321;
        _322 = <StaticPath as ToTokens>::to_tokens(_323, _324) -> [return: bb119, unwind: bb182];
    }

    bb119: {
        _320 = move _321;
        _317 = push_group_spanned(_318, _122, move _319, move _320) -> [return: bb120, unwind: bb186];
    }

    bb120: {
        _326 = &mut _245;
        _325 = push_semi_spanned(_326, _122) -> [return: bb121, unwind: bb186];
    }

    bb121: {
        _244 = move _245;
        _241 = push_group_spanned(_242, _122, move _243, move _244) -> [return: bb122, unwind: bb192];
    }

    bb122: {
        _146 = move _147;
        _143 = push_group_spanned(_144, _122, move _145, move _146) -> [return: bb123, unwind: bb194];
    }

    bb123: {
        _119 = move _121;
        goto -> bb160;
    }

    bb124: {
        _329 = _4;
        _328 = <syn::Type as devise::Spanned>::span(move _329) -> [return: bb125, unwind: bb181];
    }

    bb125: {
        _331 = &mut _327;
        _332 = const "match";
        _330 = push_ident_spanned(_331, _328, _332) -> [return: bb126, unwind: bb181];
    }

    bb126: {
        _334 = &mut _327;
        _333 = push_lt_spanned(_334, _328) -> [return: bb127, unwind: bb181];
    }

    bb127: {
        _336 = &_4;
        _337 = &mut _327;
        _335 = <&syn::Type as ToTokens>::to_tokens(_336, _337) -> [return: bb128, unwind: bb181];
    }

    bb128: {
        _339 = &mut _327;
        _340 = const "as";
        _338 = push_ident_spanned(_339, _328, _340) -> [return: bb129, unwind: bb181];
    }

    bb129: {
        _342 = &_43;
        _343 = &mut _327;
        _341 = <StaticPath as ToTokens>::to_tokens(_342, _343) -> [return: bb130, unwind: bb181];
    }

    bb130: {
        _345 = &mut _327;
        _344 = push_gt_spanned(_345, _328) -> [return: bb131, unwind: bb181];
    }

    bb131: {
        _347 = &mut _327;
        _346 = push_colon2_spanned(_347, _328) -> [return: bb132, unwind: bb181];
    }

    bb132: {
        _349 = &mut _327;
        _350 = const "from_segments";
        _348 = push_ident_spanned(_349, _328, _350) -> [return: bb133, unwind: bb181];
    }

    bb133: {
        _352 = &mut _327;
        _353 = proc_macro2::Delimiter::Parenthesis;
        _355 = TokenStream2::new() -> [return: bb134, unwind: bb181];
    }

    bb134: {
        _357 = &_11;
        _358 = &mut _355;
        _356 = <StaticPath as ToTokens>::to_tokens(_357, _358) -> [return: bb135, unwind: bb180];
    }

    bb135: {
        _360 = &mut _355;
        _359 = push_dot_spanned(_360, _328) -> [return: bb136, unwind: bb180];
    }

    bb136: {
        _362 = &mut _355;
        _363 = const "routed_segments";
        _361 = push_ident_spanned(_362, _328, _363) -> [return: bb137, unwind: bb180];
    }

    bb137: {
        _365 = &mut _355;
        _366 = proc_macro2::Delimiter::Parenthesis;
        _368 = TokenStream2::new() -> [return: bb138, unwind: bb180];
    }

    bb138: {
        _370 = &_2;
        _371 = &mut _368;
        _369 = <usize as ToTokens>::to_tokens(_370, _371) -> [return: bb139, unwind: bb179];
    }

    bb139: {
        _373 = &mut _368;
        _372 = push_dot2_spanned(_373, _328) -> [return: bb140, unwind: bb179];
    }

    bb140: {
        _367 = move _368;
        _364 = push_group_spanned(_365, _328, move _366, move _367) -> [return: bb141, unwind: bb180];
    }

    bb141: {
        _354 = move _355;
        _351 = push_group_spanned(_352, _328, move _353, move _354) -> [return: bb142, unwind: bb181];
    }

    bb142: {
        _375 = &mut _327;
        _376 = proc_macro2::Delimiter::Brace;
        _378 = TokenStream2::new() -> [return: bb143, unwind: bb181];
    }

    bb143: {
        _380 = &_31;
        _381 = &mut _378;
        _379 = <StaticPath as ToTokens>::to_tokens(_380, _381) -> [return: bb144, unwind: bb178];
    }

    bb144: {
        _383 = &mut _378;
        _384 = proc_macro2::Delimiter::Parenthesis;
        _386 = TokenStream2::new() -> [return: bb145, unwind: bb178];
    }

    bb145: {
        _388 = &mut _386;
        _389 = const "__v";
        _387 = push_ident_spanned(_388, _328, _389) -> [return: bb146, unwind: bb177];
    }

    bb146: {
        _385 = move _386;
        _382 = push_group_spanned(_383, _328, move _384, move _385) -> [return: bb147, unwind: bb178];
    }

    bb147: {
        _391 = &mut _378;
        _390 = push_fat_arrow_spanned(_391, _328) -> [return: bb148, unwind: bb178];
    }

    bb148: {
        _393 = &mut _378;
        _394 = const "__v";
        _392 = push_ident_spanned(_393, _328, _394) -> [return: bb149, unwind: bb178];
    }

    bb149: {
        _396 = &mut _378;
        _395 = push_comma_spanned(_396, _328) -> [return: bb150, unwind: bb178];
    }

    bb150: {
        _398 = &_35;
        _399 = &mut _378;
        _397 = <StaticPath as ToTokens>::to_tokens(_398, _399) -> [return: bb151, unwind: bb178];
    }

    bb151: {
        _401 = &mut _378;
        _402 = proc_macro2::Delimiter::Parenthesis;
        _404 = TokenStream2::new() -> [return: bb152, unwind: bb178];
    }

    bb152: {
        _406 = &mut _404;
        _407 = const "__error";
        _405 = push_ident_spanned(_406, _328, _407) -> [return: bb153, unwind: bb176];
    }

    bb153: {
        _403 = move _404;
        _400 = push_group_spanned(_401, _328, move _402, move _403) -> [return: bb154, unwind: bb178];
    }

    bb154: {
        _409 = &mut _378;
        _408 = push_fat_arrow_spanned(_409, _328) -> [return: bb155, unwind: bb178];
    }

    bb155: {
        _411 = &mut _378;
        _412 = const "return";
        _410 = push_ident_spanned(_411, _328, _412) -> [return: bb156, unwind: bb178];
    }

    bb156: {
        _414 = &_51;
        _415 = &mut _378;
        _413 = <TokenStream2 as ToTokens>::to_tokens(_414, _415) -> [return: bb157, unwind: bb178];
    }

    bb157: {
        _417 = &mut _378;
        _416 = push_comma_spanned(_417, _328) -> [return: bb158, unwind: bb178];
    }

    bb158: {
        _377 = move _378;
        _374 = push_group_spanned(_375, _328, move _376, move _377) -> [return: bb159, unwind: bb181];
    }

    bb159: {
        _119 = move _327;
        goto -> bb160;
    }

    bb160: {
        _419 = &((*_1).1: proc_macro2::Ident);
        _418 = <proc_macro2::Ident as syn_ext::IdentExt>::rocketized(move _419) -> [return: bb161, unwind: bb175];
    }

    bb161: {
        _420 = TokenStream2::new() -> [return: bb162, unwind: bb174];
    }

    bb162: {
        _422 = &mut _420;
        _423 = const "let";
        _421 = push_ident(_422, _423) -> [return: bb163, unwind: bb173];
    }

    bb163: {
        _425 = &_418;
        _426 = &mut _420;
        _424 = <proc_macro2::Ident as ToTokens>::to_tokens(_425, _426) -> [return: bb164, unwind: bb173];
    }

    bb164: {
        _428 = &mut _420;
        _427 = push_colon(_428) -> [return: bb165, unwind: bb173];
    }

    bb165: {
        _430 = &_4;
        _431 = &mut _420;
        _429 = <&syn::Type as ToTokens>::to_tokens(_430, _431) -> [return: bb166, unwind: bb173];
    }

    bb166: {
        _433 = &mut _420;
        _432 = push_eq(_433) -> [return: bb167, unwind: bb173];
    }

    bb167: {
        _435 = &_119;
        _436 = &mut _420;
        _434 = <TokenStream2 as ToTokens>::to_tokens(_435, _436) -> [return: bb168, unwind: bb173];
    }

    bb168: {
        _438 = &mut _420;
        _437 = push_semi(_438) -> [return: bb169, unwind: bb173];
    }

    bb169: {
        _0 = move _420;
        drop(_418) -> [return: bb170, unwind: bb175];
    }

    bb170: {
        drop(_119) -> [return: bb171, unwind: bb195];
    }

    bb171: {
        drop(_51) -> [return: bb172, unwind continue];
    }

    bb172: {
        return;
    }

    bb173 (cleanup): {
        drop(_420) -> [return: bb174, unwind terminate(cleanup)];
    }

    bb174 (cleanup): {
        drop(_418) -> [return: bb175, unwind terminate(cleanup)];
    }

    bb175 (cleanup): {
        drop(_119) -> [return: bb195, unwind terminate(cleanup)];
    }

    bb176 (cleanup): {
        drop(_404) -> [return: bb178, unwind terminate(cleanup)];
    }

    bb177 (cleanup): {
        drop(_386) -> [return: bb178, unwind terminate(cleanup)];
    }

    bb178 (cleanup): {
        drop(_378) -> [return: bb181, unwind terminate(cleanup)];
    }

    bb179 (cleanup): {
        drop(_368) -> [return: bb180, unwind terminate(cleanup)];
    }

    bb180 (cleanup): {
        drop(_355) -> [return: bb181, unwind terminate(cleanup)];
    }

    bb181 (cleanup): {
        drop(_327) -> [return: bb195, unwind terminate(cleanup)];
    }

    bb182 (cleanup): {
        drop(_321) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb183 (cleanup): {
        drop(_300) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb184 (cleanup): {
        drop(_280) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb185 (cleanup): {
        drop(_260) -> [return: bb186, unwind terminate(cleanup)];
    }

    bb186 (cleanup): {
        drop(_245) -> [return: bb192, unwind terminate(cleanup)];
    }

    bb187 (cleanup): {
        drop(_220) -> [return: bb189, unwind terminate(cleanup)];
    }

    bb188 (cleanup): {
        drop(_202) -> [return: bb189, unwind terminate(cleanup)];
    }

    bb189 (cleanup): {
        drop(_194) -> [return: bb192, unwind terminate(cleanup)];
    }

    bb190 (cleanup): {
        drop(_186) -> [return: bb192, unwind terminate(cleanup)];
    }

    bb191 (cleanup): {
        drop(_155) -> [return: bb192, unwind terminate(cleanup)];
    }

    bb192 (cleanup): {
        drop(_147) -> [return: bb194, unwind terminate(cleanup)];
    }

    bb193 (cleanup): {
        drop(_139) -> [return: bb194, unwind terminate(cleanup)];
    }

    bb194 (cleanup): {
        drop(_121) -> [return: bb195, unwind terminate(cleanup)];
    }

    bb195 (cleanup): {
        drop(_51) -> [return: bb201, unwind terminate(cleanup)];
    }

    bb196 (cleanup): {
        drop(_115) -> [return: bb199, unwind terminate(cleanup)];
    }

    bb197 (cleanup): {
        drop(_92) -> [return: bb198, unwind terminate(cleanup)];
    }

    bb198 (cleanup): {
        drop(_72) -> [return: bb199, unwind terminate(cleanup)];
    }

    bb199 (cleanup): {
        drop(_57) -> [return: bb200, unwind terminate(cleanup)];
    }

    bb200 (cleanup): {
        drop(_52) -> [return: bb201, unwind terminate(cleanup)];
    }

    bb201 (cleanup): {
        resume;
    }
}

fn data_guard_decl(_1: &Guard) -> TokenStream2 {
    debug guard => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: proc_macro2::Ident;
    let _3: &syn::Type;
    let mut _4: (proc_macro2::Ident, &syn::Type);
    let mut _5: proc_macro2::Ident;
    let mut _6: &proc_macro2::Ident;
    let mut _7: &syn::Type;
    let mut _9: std::option::Option<proc_macro2::Span>;
    let mut _10: proc_macro2::Span;
    let mut _11: &syn::Type;
    let mut _13: std::option::Option<proc_macro2::Span>;
    let mut _14: proc_macro2::Span;
    let mut _15: &syn::Type;
    let mut _17: std::option::Option<proc_macro2::Span>;
    let mut _18: proc_macro2::Span;
    let mut _19: &syn::Type;
    let mut _21: std::option::Option<proc_macro2::Span>;
    let mut _22: proc_macro2::Span;
    let mut _23: &syn::Type;
    let mut _25: std::option::Option<proc_macro2::Span>;
    let mut _26: proc_macro2::Span;
    let mut _27: &syn::Type;
    let mut _30: &syn::Type;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let _35: &proc_macro2::Ident;
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let _40: &&syn::Type;
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let _50: &&syn::Type;
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let _56: &exports::StaticPath;
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let mut _67: proc_macro2::Delimiter;
    let mut _68: proc_macro2::TokenStream;
    let _70: ();
    let _71: &exports::StaticPath;
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: ();
    let _76: &exports::StaticPath;
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: ();
    let mut _81: &mut proc_macro2::TokenStream;
    let _82: &str;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let mut _85: proc_macro2::Delimiter;
    let mut _86: proc_macro2::TokenStream;
    let _88: ();
    let _89: &exports::StaticPath;
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: ();
    let mut _92: &mut proc_macro2::TokenStream;
    let _93: ();
    let mut _94: &mut proc_macro2::TokenStream;
    let _95: &str;
    let _96: ();
    let mut _97: &mut proc_macro2::TokenStream;
    let mut _98: proc_macro2::Delimiter;
    let mut _99: proc_macro2::TokenStream;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: &str;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: ();
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: &str;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: ();
    let _112: &exports::StaticPath;
    let mut _113: &mut proc_macro2::TokenStream;
    let _114: ();
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: &str;
    let _119: ();
    let mut _120: &mut proc_macro2::TokenStream;
    let mut _121: proc_macro2::Delimiter;
    let mut _122: proc_macro2::TokenStream;
    let _124: ();
    let mut _125: &mut proc_macro2::TokenStream;
    let _126: &str;
    let _127: ();
    let mut _128: &mut proc_macro2::TokenStream;
    let _129: ();
    let mut _130: &mut proc_macro2::TokenStream;
    let mut _131: proc_macro2::Delimiter;
    let mut _132: proc_macro2::TokenStream;
    let _134: ();
    let _135: &exports::StaticPath;
    let mut _136: &mut proc_macro2::TokenStream;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: ();
    let mut _140: &mut proc_macro2::TokenStream;
    let _141: &str;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let mut _146: proc_macro2::Delimiter;
    let mut _147: proc_macro2::TokenStream;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: &str;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let _156: &str;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let mut _161: proc_macro2::Delimiter;
    let mut _162: proc_macro2::TokenStream;
    let _164: ();
    let _165: &&syn::Type;
    let mut _166: &mut proc_macro2::TokenStream;
    let _167: ();
    let mut _168: &mut proc_macro2::TokenStream;
    let _169: ();
    let mut _170: &mut proc_macro2::TokenStream;
    let _171: &str;
    let _172: ();
    let _173: &exports::StaticPath;
    let mut _174: &mut proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: &str;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let mut _182: proc_macro2::Delimiter;
    let mut _183: proc_macro2::TokenStream;
    let _185: ();
    let mut _186: &mut proc_macro2::TokenStream;
    let _187: &str;
    let _188: ();
    let mut _189: &mut proc_macro2::TokenStream;
    let _190: ();
    let _191: &exports::StaticPath;
    let mut _192: &mut proc_macro2::TokenStream;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: &str;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let mut _200: proc_macro2::Delimiter;
    let mut _201: proc_macro2::TokenStream;
    let _203: ();
    let mut _204: &mut proc_macro2::TokenStream;
    let mut _205: proc_macro2::Delimiter;
    let mut _206: proc_macro2::TokenStream;
    let _208: ();
    let mut _209: &mut proc_macro2::TokenStream;
    let _210: &str;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: &str;
    let _216: ();
    let mut _217: &mut proc_macro2::TokenStream;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let mut _220: proc_macro2::Delimiter;
    let mut _221: proc_macro2::TokenStream;
    let _223: ();
    let _224: &exports::StaticPath;
    let mut _225: &mut proc_macro2::TokenStream;
    let _226: ();
    let mut _227: &mut proc_macro2::TokenStream;
    let _228: ();
    let mut _229: &mut proc_macro2::TokenStream;
    let _230: &str;
    let _231: ();
    let mut _232: &mut proc_macro2::TokenStream;
    let _233: ();
    let mut _234: &mut proc_macro2::TokenStream;
    let mut _235: proc_macro2::Delimiter;
    let mut _236: proc_macro2::TokenStream;
    let _238: ();
    let mut _239: &mut proc_macro2::TokenStream;
    let _240: &str;
    let _241: ();
    let mut _242: &mut proc_macro2::TokenStream;
    let _243: ();
    let mut _244: &mut proc_macro2::TokenStream;
    let _245: &str;
    let _246: ();
    let mut _247: &mut proc_macro2::TokenStream;
    let _248: ();
    let mut _249: &mut proc_macro2::TokenStream;
    let mut _250: proc_macro2::Delimiter;
    let mut _251: proc_macro2::TokenStream;
    let _253: ();
    let _254: &&syn::Type;
    let mut _255: &mut proc_macro2::TokenStream;
    let _256: ();
    let mut _257: &mut proc_macro2::TokenStream;
    let _258: ();
    let mut _259: &mut proc_macro2::TokenStream;
    let _260: &str;
    let _261: ();
    let mut _262: &mut proc_macro2::TokenStream;
    let _263: ();
    let mut _264: &mut proc_macro2::TokenStream;
    let _265: &str;
    let _266: ();
    let _267: &exports::StaticPath;
    let mut _268: &mut proc_macro2::TokenStream;
    let _269: ();
    let mut _270: &mut proc_macro2::TokenStream;
    let _271: ();
    let mut _272: &mut proc_macro2::TokenStream;
    let _273: &str;
    let _274: ();
    let mut _275: &mut proc_macro2::TokenStream;
    let mut _276: proc_macro2::Delimiter;
    let mut _277: proc_macro2::TokenStream;
    let _279: ();
    let mut _280: &mut proc_macro2::TokenStream;
    let _281: &str;
    let _282: ();
    let mut _283: &mut proc_macro2::TokenStream;
    let _284: ();
    let mut _285: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ident => _2;
        debug ty => _3;
        scope 2 {
            debug _log => _8;
            scope 4 {
                debug __req => _12;
                scope 6 {
                    debug __data => _16;
                    scope 8 {
                        debug FromData => _20;
                        scope 10 {
                            debug Outcome => _24;
                            let mut _28: proc_macro2::TokenStream;
                            scope 12 {
                                debug _s => _28;
                                let _29: proc_macro2::Span;
                                scope 13 {
                                    debug _span => _29;
                                    let mut _69: proc_macro2::TokenStream;
                                    let mut _87: proc_macro2::TokenStream;
                                    scope 14 {
                                        debug _s => _69;
                                        scope 15 {
                                            debug _span => _29;
                                        }
                                    }
                                    scope 16 {
                                        debug _s => _87;
                                        scope 17 {
                                            debug _span => _29;
                                            let mut _100: proc_macro2::TokenStream;
                                            let mut _123: proc_macro2::TokenStream;
                                            let mut _133: proc_macro2::TokenStream;
                                            let mut _202: proc_macro2::TokenStream;
                                            let mut _222: proc_macro2::TokenStream;
                                            scope 18 {
                                                debug _s => _100;
                                                scope 19 {
                                                    debug _span => _29;
                                                }
                                            }
                                            scope 20 {
                                                debug _s => _123;
                                                scope 21 {
                                                    debug _span => _29;
                                                }
                                            }
                                            scope 22 {
                                                debug _s => _133;
                                                scope 23 {
                                                    debug _span => _29;
                                                    let mut _148: proc_macro2::TokenStream;
                                                    let mut _184: proc_macro2::TokenStream;
                                                    scope 24 {
                                                        debug _s => _148;
                                                        scope 25 {
                                                            debug _span => _29;
                                                            let mut _163: proc_macro2::TokenStream;
                                                            scope 26 {
                                                                debug _s => _163;
                                                                scope 27 {
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 28 {
                                                        debug _s => _184;
                                                        scope 29 {
                                                            debug _span => _29;
                                                        }
                                                    }
                                                }
                                            }
                                            scope 30 {
                                                debug _s => _202;
                                                scope 31 {
                                                    debug _span => _29;
                                                    let mut _207: proc_macro2::TokenStream;
                                                    scope 32 {
                                                        debug _s => _207;
                                                        scope 33 {
                                                            debug _span => _29;
                                                        }
                                                    }
                                                }
                                            }
                                            scope 34 {
                                                debug _s => _222;
                                                scope 35 {
                                                    debug _span => _29;
                                                    let mut _237: proc_macro2::TokenStream;
                                                    let mut _278: proc_macro2::TokenStream;
                                                    scope 36 {
                                                        debug _s => _237;
                                                        scope 37 {
                                                            debug _span => _29;
                                                            let mut _252: proc_macro2::TokenStream;
                                                            scope 38 {
                                                                debug _s => _252;
                                                                scope 39 {
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 40 {
                                                        debug _s => _278;
                                                        scope 41 {
                                                            debug _span => _29;
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        scope 11 {
                            let _24: exports::StaticPath;
                        }
                    }
                    scope 9 {
                        let _20: exports::StaticPath;
                    }
                }
                scope 7 {
                    let _16: exports::StaticPath;
                }
            }
            scope 5 {
                let _12: exports::StaticPath;
            }
        }
        scope 3 {
            let _8: exports::StaticPath;
        }
    }

    bb0: {
        _6 = &((*_1).1: proc_macro2::Ident);
        _5 = <proc_macro2::Ident as syn_ext::IdentExt>::rocketized(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &((*_1).2: syn::Type);
        _4 = (move _5, move _7);
        _2 = move (_4.0: proc_macro2::Ident);
        _3 = (_4.1: &syn::Type);
        _11 = _3;
        _10 = <syn::Type as devise::Spanned>::span(move _11) -> [return: bb2, unwind: bb125];
    }

    bb2: {
        _9 = Option::<proc_macro2::Span>::Some(move _10);
        _8 = StaticPath(move _9, const "::rocket::log");
        _15 = _3;
        _14 = <syn::Type as devise::Spanned>::span(move _15) -> [return: bb3, unwind: bb125];
    }

    bb3: {
        _13 = Option::<proc_macro2::Span>::Some(move _14);
        _12 = StaticPath(move _13, const "__req");
        _19 = _3;
        _18 = <syn::Type as devise::Spanned>::span(move _19) -> [return: bb4, unwind: bb125];
    }

    bb4: {
        _17 = Option::<proc_macro2::Span>::Some(move _18);
        _16 = StaticPath(move _17, const "__data");
        _23 = _3;
        _22 = <syn::Type as devise::Spanned>::span(move _23) -> [return: bb5, unwind: bb125];
    }

    bb5: {
        _21 = Option::<proc_macro2::Span>::Some(move _22);
        _20 = StaticPath(move _21, const "::rocket::data::FromData");
        _27 = _3;
        _26 = <syn::Type as devise::Spanned>::span(move _27) -> [return: bb6, unwind: bb125];
    }

    bb6: {
        _25 = Option::<proc_macro2::Span>::Some(move _26);
        _24 = StaticPath(move _25, const "::rocket::outcome::Outcome");
        _28 = TokenStream2::new() -> [return: bb7, unwind: bb125];
    }

    bb7: {
        _30 = _3;
        _29 = <syn::Type as devise::Spanned>::span(move _30) -> [return: bb8, unwind: bb124];
    }

    bb8: {
        _32 = &mut _28;
        _33 = const "let";
        _31 = push_ident_spanned(_32, _29, _33) -> [return: bb9, unwind: bb124];
    }

    bb9: {
        _35 = &_2;
        _36 = &mut _28;
        _34 = <proc_macro2::Ident as ToTokens>::to_tokens(_35, _36) -> [return: bb10, unwind: bb124];
    }

    bb10: {
        _38 = &mut _28;
        _37 = push_colon_spanned(_38, _29) -> [return: bb11, unwind: bb124];
    }

    bb11: {
        _40 = &_3;
        _41 = &mut _28;
        _39 = <&syn::Type as ToTokens>::to_tokens(_40, _41) -> [return: bb12, unwind: bb124];
    }

    bb12: {
        _43 = &mut _28;
        _42 = push_eq_spanned(_43, _29) -> [return: bb13, unwind: bb124];
    }

    bb13: {
        _45 = &mut _28;
        _46 = const "match";
        _44 = push_ident_spanned(_45, _29, _46) -> [return: bb14, unwind: bb124];
    }

    bb14: {
        _48 = &mut _28;
        _47 = push_lt_spanned(_48, _29) -> [return: bb15, unwind: bb124];
    }

    bb15: {
        _50 = &_3;
        _51 = &mut _28;
        _49 = <&syn::Type as ToTokens>::to_tokens(_50, _51) -> [return: bb16, unwind: bb124];
    }

    bb16: {
        _53 = &mut _28;
        _54 = const "as";
        _52 = push_ident_spanned(_53, _29, _54) -> [return: bb17, unwind: bb124];
    }

    bb17: {
        _56 = &_20;
        _57 = &mut _28;
        _55 = <StaticPath as ToTokens>::to_tokens(_56, _57) -> [return: bb18, unwind: bb124];
    }

    bb18: {
        _59 = &mut _28;
        _58 = push_gt_spanned(_59, _29) -> [return: bb19, unwind: bb124];
    }

    bb19: {
        _61 = &mut _28;
        _60 = push_colon2_spanned(_61, _29) -> [return: bb20, unwind: bb124];
    }

    bb20: {
        _63 = &mut _28;
        _64 = const "from_data";
        _62 = push_ident_spanned(_63, _29, _64) -> [return: bb21, unwind: bb124];
    }

    bb21: {
        _66 = &mut _28;
        _67 = proc_macro2::Delimiter::Parenthesis;
        _69 = TokenStream2::new() -> [return: bb22, unwind: bb124];
    }

    bb22: {
        _71 = &_12;
        _72 = &mut _69;
        _70 = <StaticPath as ToTokens>::to_tokens(_71, _72) -> [return: bb23, unwind: bb123];
    }

    bb23: {
        _74 = &mut _69;
        _73 = push_comma_spanned(_74, _29) -> [return: bb24, unwind: bb123];
    }

    bb24: {
        _76 = &_16;
        _77 = &mut _69;
        _75 = <StaticPath as ToTokens>::to_tokens(_76, _77) -> [return: bb25, unwind: bb123];
    }

    bb25: {
        _68 = move _69;
        _65 = push_group_spanned(_66, _29, move _67, move _68) -> [return: bb26, unwind: bb124];
    }

    bb26: {
        _79 = &mut _28;
        _78 = push_dot_spanned(_79, _29) -> [return: bb27, unwind: bb124];
    }

    bb27: {
        _81 = &mut _28;
        _82 = const "await";
        _80 = push_ident_spanned(_81, _29, _82) -> [return: bb28, unwind: bb124];
    }

    bb28: {
        _84 = &mut _28;
        _85 = proc_macro2::Delimiter::Brace;
        _87 = TokenStream2::new() -> [return: bb29, unwind: bb124];
    }

    bb29: {
        _89 = &_24;
        _90 = &mut _87;
        _88 = <StaticPath as ToTokens>::to_tokens(_89, _90) -> [return: bb30, unwind: bb122];
    }

    bb30: {
        _92 = &mut _87;
        _91 = push_colon2_spanned(_92, _29) -> [return: bb31, unwind: bb122];
    }

    bb31: {
        _94 = &mut _87;
        _95 = const "Success";
        _93 = push_ident_spanned(_94, _29, _95) -> [return: bb32, unwind: bb122];
    }

    bb32: {
        _97 = &mut _87;
        _98 = proc_macro2::Delimiter::Parenthesis;
        _100 = TokenStream2::new() -> [return: bb33, unwind: bb122];
    }

    bb33: {
        _102 = &mut _100;
        _103 = const "__d";
        _101 = push_ident_spanned(_102, _29, _103) -> [return: bb34, unwind: bb121];
    }

    bb34: {
        _99 = move _100;
        _96 = push_group_spanned(_97, _29, move _98, move _99) -> [return: bb35, unwind: bb122];
    }

    bb35: {
        _105 = &mut _87;
        _104 = push_fat_arrow_spanned(_105, _29) -> [return: bb36, unwind: bb122];
    }

    bb36: {
        _107 = &mut _87;
        _108 = const "__d";
        _106 = push_ident_spanned(_107, _29, _108) -> [return: bb37, unwind: bb122];
    }

    bb37: {
        _110 = &mut _87;
        _109 = push_comma_spanned(_110, _29) -> [return: bb38, unwind: bb122];
    }

    bb38: {
        _112 = &_24;
        _113 = &mut _87;
        _111 = <StaticPath as ToTokens>::to_tokens(_112, _113) -> [return: bb39, unwind: bb122];
    }

    bb39: {
        _115 = &mut _87;
        _114 = push_colon2_spanned(_115, _29) -> [return: bb40, unwind: bb122];
    }

    bb40: {
        _117 = &mut _87;
        _118 = const "Forward";
        _116 = push_ident_spanned(_117, _29, _118) -> [return: bb41, unwind: bb122];
    }

    bb41: {
        _120 = &mut _87;
        _121 = proc_macro2::Delimiter::Parenthesis;
        _123 = TokenStream2::new() -> [return: bb42, unwind: bb122];
    }

    bb42: {
        _125 = &mut _123;
        _126 = const "__d";
        _124 = push_ident_spanned(_125, _29, _126) -> [return: bb43, unwind: bb120];
    }

    bb43: {
        _122 = move _123;
        _119 = push_group_spanned(_120, _29, move _121, move _122) -> [return: bb44, unwind: bb122];
    }

    bb44: {
        _128 = &mut _87;
        _127 = push_fat_arrow_spanned(_128, _29) -> [return: bb45, unwind: bb122];
    }

    bb45: {
        _130 = &mut _87;
        _131 = proc_macro2::Delimiter::Brace;
        _133 = TokenStream2::new() -> [return: bb46, unwind: bb122];
    }

    bb46: {
        _135 = &_8;
        _136 = &mut _133;
        _134 = <StaticPath as ToTokens>::to_tokens(_135, _136) -> [return: bb47, unwind: bb119];
    }

    bb47: {
        _138 = &mut _133;
        _137 = push_colon2_spanned(_138, _29) -> [return: bb48, unwind: bb119];
    }

    bb48: {
        _140 = &mut _133;
        _141 = const "warn_";
        _139 = push_ident_spanned(_140, _29, _141) -> [return: bb49, unwind: bb119];
    }

    bb49: {
        _143 = &mut _133;
        _142 = push_bang_spanned(_143, _29) -> [return: bb50, unwind: bb119];
    }

    bb50: {
        _145 = &mut _133;
        _146 = proc_macro2::Delimiter::Parenthesis;
        _148 = TokenStream2::new() -> [return: bb51, unwind: bb119];
    }

    bb51: {
        _150 = &mut _148;
        _151 = const "\"`{}` data guard is forwarding.\"";
        _149 = parse_spanned(_150, _29, _151) -> [return: bb52, unwind: bb118];
    }

    bb52: {
        _153 = &mut _148;
        _152 = push_comma_spanned(_153, _29) -> [return: bb53, unwind: bb118];
    }

    bb53: {
        _155 = &mut _148;
        _156 = const "stringify";
        _154 = push_ident_spanned(_155, _29, _156) -> [return: bb54, unwind: bb118];
    }

    bb54: {
        _158 = &mut _148;
        _157 = push_bang_spanned(_158, _29) -> [return: bb55, unwind: bb118];
    }

    bb55: {
        _160 = &mut _148;
        _161 = proc_macro2::Delimiter::Parenthesis;
        _163 = TokenStream2::new() -> [return: bb56, unwind: bb118];
    }

    bb56: {
        _165 = &_3;
        _166 = &mut _163;
        _164 = <&syn::Type as ToTokens>::to_tokens(_165, _166) -> [return: bb57, unwind: bb117];
    }

    bb57: {
        _162 = move _163;
        _159 = push_group_spanned(_160, _29, move _161, move _162) -> [return: bb58, unwind: bb118];
    }

    bb58: {
        _147 = move _148;
        _144 = push_group_spanned(_145, _29, move _146, move _147) -> [return: bb59, unwind: bb119];
    }

    bb59: {
        _168 = &mut _133;
        _167 = push_semi_spanned(_168, _29) -> [return: bb60, unwind: bb119];
    }

    bb60: {
        _170 = &mut _133;
        _171 = const "return";
        _169 = push_ident_spanned(_170, _29, _171) -> [return: bb61, unwind: bb119];
    }

    bb61: {
        _173 = &_24;
        _174 = &mut _133;
        _172 = <StaticPath as ToTokens>::to_tokens(_173, _174) -> [return: bb62, unwind: bb119];
    }

    bb62: {
        _176 = &mut _133;
        _175 = push_colon2_spanned(_176, _29) -> [return: bb63, unwind: bb119];
    }

    bb63: {
        _178 = &mut _133;
        _179 = const "Forward";
        _177 = push_ident_spanned(_178, _29, _179) -> [return: bb64, unwind: bb119];
    }

    bb64: {
        _181 = &mut _133;
        _182 = proc_macro2::Delimiter::Parenthesis;
        _184 = TokenStream2::new() -> [return: bb65, unwind: bb119];
    }

    bb65: {
        _186 = &mut _184;
        _187 = const "__d";
        _185 = push_ident_spanned(_186, _29, _187) -> [return: bb66, unwind: bb116];
    }

    bb66: {
        _183 = move _184;
        _180 = push_group_spanned(_181, _29, move _182, move _183) -> [return: bb67, unwind: bb119];
    }

    bb67: {
        _189 = &mut _133;
        _188 = push_semi_spanned(_189, _29) -> [return: bb68, unwind: bb119];
    }

    bb68: {
        _132 = move _133;
        _129 = push_group_spanned(_130, _29, move _131, move _132) -> [return: bb69, unwind: bb122];
    }

    bb69: {
        _191 = &_24;
        _192 = &mut _87;
        _190 = <StaticPath as ToTokens>::to_tokens(_191, _192) -> [return: bb70, unwind: bb122];
    }

    bb70: {
        _194 = &mut _87;
        _193 = push_colon2_spanned(_194, _29) -> [return: bb71, unwind: bb122];
    }

    bb71: {
        _196 = &mut _87;
        _197 = const "Failure";
        _195 = push_ident_spanned(_196, _29, _197) -> [return: bb72, unwind: bb122];
    }

    bb72: {
        _199 = &mut _87;
        _200 = proc_macro2::Delimiter::Parenthesis;
        _202 = TokenStream2::new() -> [return: bb73, unwind: bb122];
    }

    bb73: {
        _204 = &mut _202;
        _205 = proc_macro2::Delimiter::Parenthesis;
        _207 = TokenStream2::new() -> [return: bb74, unwind: bb115];
    }

    bb74: {
        _209 = &mut _207;
        _210 = const "__c";
        _208 = push_ident_spanned(_209, _29, _210) -> [return: bb75, unwind: bb114];
    }

    bb75: {
        _212 = &mut _207;
        _211 = push_comma_spanned(_212, _29) -> [return: bb76, unwind: bb114];
    }

    bb76: {
        _214 = &mut _207;
        _215 = const "__e";
        _213 = push_ident_spanned(_214, _29, _215) -> [return: bb77, unwind: bb114];
    }

    bb77: {
        _206 = move _207;
        _203 = push_group_spanned(_204, _29, move _205, move _206) -> [return: bb78, unwind: bb115];
    }

    bb78: {
        _201 = move _202;
        _198 = push_group_spanned(_199, _29, move _200, move _201) -> [return: bb79, unwind: bb122];
    }

    bb79: {
        _217 = &mut _87;
        _216 = push_fat_arrow_spanned(_217, _29) -> [return: bb80, unwind: bb122];
    }

    bb80: {
        _219 = &mut _87;
        _220 = proc_macro2::Delimiter::Brace;
        _222 = TokenStream2::new() -> [return: bb81, unwind: bb122];
    }

    bb81: {
        _224 = &_8;
        _225 = &mut _222;
        _223 = <StaticPath as ToTokens>::to_tokens(_224, _225) -> [return: bb82, unwind: bb113];
    }

    bb82: {
        _227 = &mut _222;
        _226 = push_colon2_spanned(_227, _29) -> [return: bb83, unwind: bb113];
    }

    bb83: {
        _229 = &mut _222;
        _230 = const "warn_";
        _228 = push_ident_spanned(_229, _29, _230) -> [return: bb84, unwind: bb113];
    }

    bb84: {
        _232 = &mut _222;
        _231 = push_bang_spanned(_232, _29) -> [return: bb85, unwind: bb113];
    }

    bb85: {
        _234 = &mut _222;
        _235 = proc_macro2::Delimiter::Parenthesis;
        _237 = TokenStream2::new() -> [return: bb86, unwind: bb113];
    }

    bb86: {
        _239 = &mut _237;
        _240 = const "\"`{}` data guard failed: {:?}.\"";
        _238 = parse_spanned(_239, _29, _240) -> [return: bb87, unwind: bb112];
    }

    bb87: {
        _242 = &mut _237;
        _241 = push_comma_spanned(_242, _29) -> [return: bb88, unwind: bb112];
    }

    bb88: {
        _244 = &mut _237;
        _245 = const "stringify";
        _243 = push_ident_spanned(_244, _29, _245) -> [return: bb89, unwind: bb112];
    }

    bb89: {
        _247 = &mut _237;
        _246 = push_bang_spanned(_247, _29) -> [return: bb90, unwind: bb112];
    }

    bb90: {
        _249 = &mut _237;
        _250 = proc_macro2::Delimiter::Parenthesis;
        _252 = TokenStream2::new() -> [return: bb91, unwind: bb112];
    }

    bb91: {
        _254 = &_3;
        _255 = &mut _252;
        _253 = <&syn::Type as ToTokens>::to_tokens(_254, _255) -> [return: bb92, unwind: bb111];
    }

    bb92: {
        _251 = move _252;
        _248 = push_group_spanned(_249, _29, move _250, move _251) -> [return: bb93, unwind: bb112];
    }

    bb93: {
        _257 = &mut _237;
        _256 = push_comma_spanned(_257, _29) -> [return: bb94, unwind: bb112];
    }

    bb94: {
        _259 = &mut _237;
        _260 = const "__e";
        _258 = push_ident_spanned(_259, _29, _260) -> [return: bb95, unwind: bb112];
    }

    bb95: {
        _236 = move _237;
        _233 = push_group_spanned(_234, _29, move _235, move _236) -> [return: bb96, unwind: bb113];
    }

    bb96: {
        _262 = &mut _222;
        _261 = push_semi_spanned(_262, _29) -> [return: bb97, unwind: bb113];
    }

    bb97: {
        _264 = &mut _222;
        _265 = const "return";
        _263 = push_ident_spanned(_264, _29, _265) -> [return: bb98, unwind: bb113];
    }

    bb98: {
        _267 = &_24;
        _268 = &mut _222;
        _266 = <StaticPath as ToTokens>::to_tokens(_267, _268) -> [return: bb99, unwind: bb113];
    }

    bb99: {
        _270 = &mut _222;
        _269 = push_colon2_spanned(_270, _29) -> [return: bb100, unwind: bb113];
    }

    bb100: {
        _272 = &mut _222;
        _273 = const "Failure";
        _271 = push_ident_spanned(_272, _29, _273) -> [return: bb101, unwind: bb113];
    }

    bb101: {
        _275 = &mut _222;
        _276 = proc_macro2::Delimiter::Parenthesis;
        _278 = TokenStream2::new() -> [return: bb102, unwind: bb113];
    }

    bb102: {
        _280 = &mut _278;
        _281 = const "__c";
        _279 = push_ident_spanned(_280, _29, _281) -> [return: bb103, unwind: bb110];
    }

    bb103: {
        _277 = move _278;
        _274 = push_group_spanned(_275, _29, move _276, move _277) -> [return: bb104, unwind: bb113];
    }

    bb104: {
        _283 = &mut _222;
        _282 = push_semi_spanned(_283, _29) -> [return: bb105, unwind: bb113];
    }

    bb105: {
        _221 = move _222;
        _218 = push_group_spanned(_219, _29, move _220, move _221) -> [return: bb106, unwind: bb122];
    }

    bb106: {
        _86 = move _87;
        _83 = push_group_spanned(_84, _29, move _85, move _86) -> [return: bb107, unwind: bb124];
    }

    bb107: {
        _285 = &mut _28;
        _284 = push_semi_spanned(_285, _29) -> [return: bb108, unwind: bb124];
    }

    bb108: {
        _0 = move _28;
        drop(_2) -> [return: bb109, unwind continue];
    }

    bb109: {
        return;
    }

    bb110 (cleanup): {
        drop(_278) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_252) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_237) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_222) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_207) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_202) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_184) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        drop(_163) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        drop(_148) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb119 (cleanup): {
        drop(_133) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb120 (cleanup): {
        drop(_123) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb121 (cleanup): {
        drop(_100) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb122 (cleanup): {
        drop(_87) -> [return: bb124, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        drop(_69) -> [return: bb124, unwind terminate(cleanup)];
    }

    bb124 (cleanup): {
        drop(_28) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        drop(_2) -> [return: bb126, unwind terminate(cleanup)];
    }

    bb126 (cleanup): {
        resume;
    }
}

fn internal_uri_macro_decl(_1: &route::parse::Route) -> TokenStream2 {
    debug route => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: std::iter::Map<std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>;
    let mut _3: std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>;
    let mut _4: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>;
    let mut _5: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>;
    let mut _6: &attribute::route::parse::Route;
    let mut _7: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>;
    let mut _8: &attribute::route::parse::Route;
    let mut _10: &proc_macro2::Ident;
    let _11: &&str;
    let mut _13: &proc_macro2::Ident;
    let mut _14: {closure@core/codegen/src/attribute/route/mod.rs:205:54: 205:66};
    let mut _15: &&attribute::route::parse::Route;
    let _17: &rocket_http::uri::Origin<'_>;
    let mut _18: &attribute::route::parse::RouteUri;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let mut _25: proc_macro2::Delimiter;
    let mut _26: proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _33: proc_macro2::Delimiter;
    let mut _34: proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: &str;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let mut _43: proc_macro2::Delimiter;
    let mut _44: proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let mut _53: proc_macro2::Delimiter;
    let mut _54: proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: &str;
    let _67: ();
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: ();
    let _70: &proc_macro2::Ident;
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let mut _74: proc_macro2::Delimiter;
    let mut _75: proc_macro2::TokenStream;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let mut _79: proc_macro2::Delimiter;
    let mut _80: proc_macro2::TokenStream;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: &str;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let mut _87: proc_macro2::Delimiter;
    let mut _88: proc_macro2::TokenStream;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: &str;
    let _93: ();
    let mut _94: &mut proc_macro2::TokenStream;
    let _95: &str;
    let _96: ();
    let mut _97: &mut proc_macro2::TokenStream;
    let _98: ();
    let mut _99: &mut proc_macro2::TokenStream;
    let _100: &str;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: ();
    let mut _104: &mut proc_macro2::TokenStream;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let mut _107: proc_macro2::Delimiter;
    let mut _108: proc_macro2::TokenStream;
    let _110: ();
    let mut _111: &mut proc_macro2::TokenStream;
    let mut _112: proc_macro2::Delimiter;
    let mut _113: proc_macro2::TokenStream;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: &str;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: &str;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: ();
    let mut _126: &mut proc_macro2::TokenStream;
    let mut _127: proc_macro2::Delimiter;
    let mut _128: proc_macro2::TokenStream;
    let _130: ();
    let _131: &std::string::String;
    let mut _132: &mut proc_macro2::TokenStream;
    let _133: ();
    let mut _134: &mut proc_macro2::TokenStream;
    let _135: ();
    let mut _136: &mut proc_macro2::TokenStream;
    let mut _137: proc_macro2::Delimiter;
    let mut _138: proc_macro2::TokenStream;
    let mut _142: (std::iter::Map<std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>, quote::__private::HasIterator);
    let mut _144: bool;
    let mut _146: std::option::Option<proc_macro2::TokenStream>;
    let mut _147: &mut std::iter::Map<std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>;
    let mut _148: isize;
    let mut _150: bool;
    let mut _151: usize;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let mut _154: (usize, bool);
    let _155: ();
    let _156: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _157: &mut proc_macro2::TokenStream;
    let _158: ();
    let mut _159: &mut proc_macro2::TokenStream;
    let _160: ();
    let mut _161: &mut proc_macro2::TokenStream;
    let _162: &str;
    let _163: ();
    let mut _164: &mut proc_macro2::TokenStream;
    let mut _165: proc_macro2::Delimiter;
    let mut _166: proc_macro2::TokenStream;
    let _168: ();
    let mut _169: &mut proc_macro2::TokenStream;
    let _170: &str;
    let _171: ();
    let mut _172: &mut proc_macro2::TokenStream;
    let _173: &str;
    let _174: ();
    let mut _175: &mut proc_macro2::TokenStream;
    let _176: ();
    let mut _177: &mut proc_macro2::TokenStream;
    let _178: ();
    let mut _179: &mut proc_macro2::TokenStream;
    let _180: ();
    let mut _181: &mut proc_macro2::TokenStream;
    let mut _182: proc_macro2::Delimiter;
    let mut _183: proc_macro2::TokenStream;
    let _185: ();
    let mut _186: &mut proc_macro2::TokenStream;
    let _187: &str;
    let _188: ();
    let mut _189: &mut proc_macro2::TokenStream;
    let mut _190: proc_macro2::Delimiter;
    let mut _191: proc_macro2::TokenStream;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: &str;
    let _196: ();
    let mut _197: &mut proc_macro2::TokenStream;
    let _198: &str;
    let _199: ();
    let mut _200: &mut proc_macro2::TokenStream;
    let _201: &str;
    let _202: ();
    let _203: &proc_macro2::Ident;
    let mut _204: &mut proc_macro2::TokenStream;
    let _205: ();
    let mut _206: &mut proc_macro2::TokenStream;
    let _207: &str;
    let _208: ();
    let _209: &proc_macro2::Ident;
    let mut _210: &mut proc_macro2::TokenStream;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let mut _213: &str;
    let mut _214: std::iter::Map<std::iter::Map<std::iter::Chain<impl std::iter::Iterator<Item = &attribute::param::Guard>, impl std::iter::Iterator<Item = &attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>;
    scope 1 {
        debug uri_args => _2;
        let _9: proc_macro2::Ident;
        scope 2 {
            debug macro_name => _9;
            let _12: proc_macro2::Ident;
            scope 3 {
                debug inner_macro_name => _12;
                let _16: std::string::String;
                scope 4 {
                    debug route_uri => _16;
                    let mut _19: proc_macro2::TokenStream;
                    scope 5 {
                        debug _s => _19;
                        let _20: proc_macro2::Span;
                        scope 6 {
                            debug _span => _20;
                            let mut _27: proc_macro2::TokenStream;
                            let mut _45: proc_macro2::TokenStream;
                            let mut _55: proc_macro2::TokenStream;
                            let mut _76: proc_macro2::TokenStream;
                            let mut _184: proc_macro2::TokenStream;
                            scope 7 {
                                debug _s => _27;
                                scope 8 {
                                    debug _span => _20;
                                    let mut _35: proc_macro2::TokenStream;
                                    scope 9 {
                                        debug _s => _35;
                                        scope 10 {
                                            debug _span => _20;
                                        }
                                    }
                                }
                            }
                            scope 11 {
                                debug _s => _45;
                                scope 12 {
                                    debug _span => _20;
                                }
                            }
                            scope 13 {
                                debug _s => _55;
                                scope 14 {
                                    debug _span => _20;
                                }
                            }
                            scope 15 {
                                debug _s => _76;
                                scope 16 {
                                    debug _span => _20;
                                    let mut _81: proc_macro2::TokenStream;
                                    let mut _109: proc_macro2::TokenStream;
                                    scope 17 {
                                        debug _s => _81;
                                        scope 18 {
                                            debug _span => _20;
                                            let mut _89: proc_macro2::TokenStream;
                                            scope 19 {
                                                debug _s => _89;
                                                scope 20 {
                                                    debug _span => _20;
                                                }
                                            }
                                        }
                                    }
                                    scope 21 {
                                        debug _s => _109;
                                        scope 22 {
                                            debug _span => _20;
                                            let mut _114: proc_macro2::TokenStream;
                                            scope 23 {
                                                debug _s => _114;
                                                scope 24 {
                                                    debug _span => _20;
                                                    let mut _129: proc_macro2::TokenStream;
                                                    scope 25 {
                                                        debug _s => _129;
                                                        scope 26 {
                                                            debug _span => _20;
                                                            let mut _139: proc_macro2::TokenStream;
                                                            let mut _167: proc_macro2::TokenStream;
                                                            scope 27 {
                                                                debug _s => _139;
                                                                scope 28 {
                                                                    debug _span => _20;
                                                                    let mut _140: usize;
                                                                    scope 29 {
                                                                        debug _i => _140;
                                                                        scope 30 {
                                                                            debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                            scope 31 {
                                                                                debug uri_args => _141;
                                                                                debug i => const HasIterator;
                                                                                let _143: quote::__private::HasIterator;
                                                                                scope 33 {
                                                                                    debug has_iter => const HasIterator;
                                                                                    scope 34 {
                                                                                        let _145: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                                                                        let _149: proc_macro2::TokenStream;
                                                                                        scope 35 {
                                                                                            debug uri_args => _145;
                                                                                        }
                                                                                        scope 36 {
                                                                                            debug _x => _149;
                                                                                        }
                                                                                    }
                                                                                }
                                                                            }
                                                                            scope 32 {
                                                                                let mut _141: std::iter::Map<std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>;
                                                                            }
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                            scope 37 {
                                                                debug _s => _167;
                                                                scope 38 {
                                                                    debug _span => _20;
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            scope 39 {
                                debug _s => _184;
                                scope 40 {
                                    debug _span => _20;
                                    let mut _192: proc_macro2::TokenStream;
                                    scope 41 {
                                        debug _s => _192;
                                        scope 42 {
                                            debug _span => _20;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _6 = _1;
        _5 = route::<impl route::parse::Route>::param_guards(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _1;
        _7 = route::<impl route::parse::Route>::query_guards(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}> as Iterator>::chain::<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>(move _5, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>> as Iterator>::map::<(&proc_macro2::Ident, &syn::Type), {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>(move _4, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = <Map<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>(move _3, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = &((((*_1).5: syn::ItemFn).2: syn::Signature).5: proc_macro2::Ident);
        _11 = const {alloc1: &&str};
        _213 = deref_copy (*_11);
        _9 = <proc_macro2::Ident as syn_ext::IdentExt>::prepend(move _10, _213) -> [return: bb6, unwind continue];
    }

    bb6: {
        _13 = &_9;
        _15 = &_1;
        _14 = {closure@core/codegen/src/attribute/route/mod.rs:205:54: 205:66} { route: move _15 };
        _12 = <proc_macro2::Ident as syn_ext::IdentExt>::uniqueify_with::<{closure@core/codegen/src/attribute/route/mod.rs:205:54: 205:66}>(move _13, move _14) -> [return: bb7, unwind: bb112];
    }

    bb7: {
        _18 = &(((*_1).0: attribute::route::parse::Attribute).1: attribute::route::parse::RouteUri);
        _17 = <RouteUri as std::ops::Deref>::deref(move _18) -> [return: bb8, unwind: bb111];
    }

    bb8: {
        _16 = <rocket_http::uri::Origin<'_> as ToString>::to_string(_17) -> [return: bb9, unwind: bb111];
    }

    bb9: {
        _19 = TokenStream2::new() -> [return: bb10, unwind: bb110];
    }

    bb10: {
        _20 = proc_macro2::Span::call_site() -> [return: bb11, unwind: bb109];
    }

    bb11: {
        _22 = &mut _19;
        _21 = push_pound_spanned(_22, _20) -> [return: bb12, unwind: bb109];
    }

    bb12: {
        _24 = &mut _19;
        _25 = proc_macro2::Delimiter::Bracket;
        _27 = TokenStream2::new() -> [return: bb13, unwind: bb109];
    }

    bb13: {
        _29 = &mut _27;
        _30 = const "doc";
        _28 = push_ident_spanned(_29, _20, _30) -> [return: bb14, unwind: bb108];
    }

    bb14: {
        _32 = &mut _27;
        _33 = proc_macro2::Delimiter::Parenthesis;
        _35 = TokenStream2::new() -> [return: bb15, unwind: bb108];
    }

    bb15: {
        _37 = &mut _35;
        _38 = const "hidden";
        _36 = push_ident_spanned(_37, _20, _38) -> [return: bb16, unwind: bb107];
    }

    bb16: {
        _34 = move _35;
        _31 = push_group_spanned(_32, _20, move _33, move _34) -> [return: bb17, unwind: bb108];
    }

    bb17: {
        _26 = move _27;
        _23 = push_group_spanned(_24, _20, move _25, move _26) -> [return: bb18, unwind: bb109];
    }

    bb18: {
        _40 = &mut _19;
        _39 = push_pound_spanned(_40, _20) -> [return: bb19, unwind: bb109];
    }

    bb19: {
        _42 = &mut _19;
        _43 = proc_macro2::Delimiter::Bracket;
        _45 = TokenStream2::new() -> [return: bb20, unwind: bb109];
    }

    bb20: {
        _47 = &mut _45;
        _48 = const "macro_export";
        _46 = push_ident_spanned(_47, _20, _48) -> [return: bb21, unwind: bb106];
    }

    bb21: {
        _44 = move _45;
        _41 = push_group_spanned(_42, _20, move _43, move _44) -> [return: bb22, unwind: bb109];
    }

    bb22: {
        _50 = &mut _19;
        _49 = push_pound_spanned(_50, _20) -> [return: bb23, unwind: bb109];
    }

    bb23: {
        _52 = &mut _19;
        _53 = proc_macro2::Delimiter::Bracket;
        _55 = TokenStream2::new() -> [return: bb24, unwind: bb109];
    }

    bb24: {
        _57 = &mut _55;
        _58 = const "doc";
        _56 = push_ident_spanned(_57, _20, _58) -> [return: bb25, unwind: bb105];
    }

    bb25: {
        _60 = &mut _55;
        _59 = push_eq_spanned(_60, _20) -> [return: bb26, unwind: bb105];
    }

    bb26: {
        _62 = &mut _55;
        _63 = const "r\" Rocket generated URI macro.\"";
        _61 = parse_spanned(_62, _20, _63) -> [return: bb27, unwind: bb105];
    }

    bb27: {
        _54 = move _55;
        _51 = push_group_spanned(_52, _20, move _53, move _54) -> [return: bb28, unwind: bb109];
    }

    bb28: {
        _65 = &mut _19;
        _66 = const "macro_rules";
        _64 = push_ident_spanned(_65, _20, _66) -> [return: bb29, unwind: bb109];
    }

    bb29: {
        _68 = &mut _19;
        _67 = push_bang_spanned(_68, _20) -> [return: bb30, unwind: bb109];
    }

    bb30: {
        _70 = &_12;
        _71 = &mut _19;
        _69 = <proc_macro2::Ident as ToTokens>::to_tokens(_70, _71) -> [return: bb31, unwind: bb109];
    }

    bb31: {
        _73 = &mut _19;
        _74 = proc_macro2::Delimiter::Brace;
        _76 = TokenStream2::new() -> [return: bb32, unwind: bb109];
    }

    bb32: {
        _78 = &mut _76;
        _79 = proc_macro2::Delimiter::Parenthesis;
        _81 = TokenStream2::new() -> [return: bb33, unwind: bb104];
    }

    bb33: {
        _83 = &mut _81;
        _84 = const "$";
        _82 = parse_spanned(_83, _20, _84) -> [return: bb34, unwind: bb103];
    }

    bb34: {
        _86 = &mut _81;
        _87 = proc_macro2::Delimiter::Parenthesis;
        _89 = TokenStream2::new() -> [return: bb35, unwind: bb103];
    }

    bb35: {
        _91 = &mut _89;
        _92 = const "$";
        _90 = parse_spanned(_91, _20, _92) -> [return: bb36, unwind: bb102];
    }

    bb36: {
        _94 = &mut _89;
        _95 = const "token";
        _93 = push_ident_spanned(_94, _20, _95) -> [return: bb37, unwind: bb102];
    }

    bb37: {
        _97 = &mut _89;
        _96 = push_colon_spanned(_97, _20) -> [return: bb38, unwind: bb102];
    }

    bb38: {
        _99 = &mut _89;
        _100 = const "tt";
        _98 = push_ident_spanned(_99, _20, _100) -> [return: bb39, unwind: bb102];
    }

    bb39: {
        _88 = move _89;
        _85 = push_group_spanned(_86, _20, move _87, move _88) -> [return: bb40, unwind: bb103];
    }

    bb40: {
        _102 = &mut _81;
        _101 = push_star_spanned(_102, _20) -> [return: bb41, unwind: bb103];
    }

    bb41: {
        _80 = move _81;
        _77 = push_group_spanned(_78, _20, move _79, move _80) -> [return: bb42, unwind: bb104];
    }

    bb42: {
        _104 = &mut _76;
        _103 = push_fat_arrow_spanned(_104, _20) -> [return: bb43, unwind: bb104];
    }

    bb43: {
        _106 = &mut _76;
        _107 = proc_macro2::Delimiter::Brace;
        _109 = TokenStream2::new() -> [return: bb44, unwind: bb104];
    }

    bb44: {
        _111 = &mut _109;
        _112 = proc_macro2::Delimiter::Brace;
        _114 = TokenStream2::new() -> [return: bb45, unwind: bb101];
    }

    bb45: {
        _116 = &mut _114;
        _117 = const "rocket";
        _115 = push_ident_spanned(_116, _20, _117) -> [return: bb46, unwind: bb100];
    }

    bb46: {
        _119 = &mut _114;
        _118 = push_colon2_spanned(_119, _20) -> [return: bb47, unwind: bb100];
    }

    bb47: {
        _121 = &mut _114;
        _122 = const "rocket_internal_uri";
        _120 = push_ident_spanned(_121, _20, _122) -> [return: bb48, unwind: bb100];
    }

    bb48: {
        _124 = &mut _114;
        _123 = push_bang_spanned(_124, _20) -> [return: bb49, unwind: bb100];
    }

    bb49: {
        _126 = &mut _114;
        _127 = proc_macro2::Delimiter::Parenthesis;
        _129 = TokenStream2::new() -> [return: bb50, unwind: bb100];
    }

    bb50: {
        _131 = &_16;
        _132 = &mut _129;
        _130 = <std::string::String as ToTokens>::to_tokens(_131, _132) -> [return: bb51, unwind: bb99];
    }

    bb51: {
        _134 = &mut _129;
        _133 = push_comma_spanned(_134, _20) -> [return: bb52, unwind: bb99];
    }

    bb52: {
        _136 = &mut _129;
        _137 = proc_macro2::Delimiter::Parenthesis;
        _139 = TokenStream2::new() -> [return: bb53, unwind: bb99];
    }

    bb53: {
        _140 = const 0_usize;
        _142 = <Map<Map<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _2) -> [return: bb54, unwind: bb98];
    }

    bb54: {
        _214 = move (_142.0: std::iter::Map<std::iter::Map<std::iter::Chain<impl std::iter::Iterator<Item = &attribute::param::Guard>, impl std::iter::Iterator<Item = &attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>);
        _141 = move (_214 as subtype Map<Map<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}>);
        _143 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb114, unwind: bb98];
    }

    bb55: {
        _144 = const true;
        switchInt(move _144) -> [0: bb64, otherwise: bb56];
    }

    bb56: {
        _147 = &mut _141;
        _146 = <Map<Map<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}>, {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}> as Iterator>::next(move _147) -> [return: bb57, unwind: bb98];
    }

    bb57: {
        _148 = discriminant(_146);
        switchInt(move _148) -> [0: bb64, 1: bb59, otherwise: bb58];
    }

    bb58: {
        unreachable;
    }

    bb59: {
        _149 = move ((_146 as Some).0: proc_macro2::TokenStream);
        _145 = RepInterp::<TokenStream2>(move _149);
        _151 = _140;
        _150 = Gt(move _151, const 0_usize);
        switchInt(move _150) -> [0: bb61, otherwise: bb60];
    }

    bb60: {
        _153 = &mut _139;
        _152 = push_comma_spanned(_153, _20) -> [return: bb115, unwind: bb97];
    }

    bb61: {
        _154 = CheckedAdd(_140, const 1_usize);
        assert(!move (_154.1: bool), "attempt to compute `{} + {}`, which would overflow", _140, const 1_usize) -> [success: bb62, unwind: bb97];
    }

    bb62: {
        _140 = move (_154.0: usize);
        _156 = &_145;
        _157 = &mut _139;
        _155 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_156, _157) -> [return: bb63, unwind: bb97];
    }

    bb63: {
        drop(_145) -> [return: bb55, unwind: bb98];
    }

    bb64: {
        _138 = move _139;
        _135 = push_group_spanned(_136, _20, move _137, move _138) -> [return: bb65, unwind: bb99];
    }

    bb65: {
        _159 = &mut _129;
        _158 = push_comma_spanned(_159, _20) -> [return: bb66, unwind: bb99];
    }

    bb66: {
        _161 = &mut _129;
        _162 = const "$";
        _160 = parse_spanned(_161, _20, _162) -> [return: bb67, unwind: bb99];
    }

    bb67: {
        _164 = &mut _129;
        _165 = proc_macro2::Delimiter::Parenthesis;
        _167 = TokenStream2::new() -> [return: bb68, unwind: bb99];
    }

    bb68: {
        _169 = &mut _167;
        _170 = const "$";
        _168 = parse_spanned(_169, _20, _170) -> [return: bb69, unwind: bb96];
    }

    bb69: {
        _172 = &mut _167;
        _173 = const "token";
        _171 = push_ident_spanned(_172, _20, _173) -> [return: bb70, unwind: bb96];
    }

    bb70: {
        _166 = move _167;
        _163 = push_group_spanned(_164, _20, move _165, move _166) -> [return: bb71, unwind: bb99];
    }

    bb71: {
        _175 = &mut _129;
        _174 = push_star_spanned(_175, _20) -> [return: bb72, unwind: bb99];
    }

    bb72: {
        _128 = move _129;
        _125 = push_group_spanned(_126, _20, move _127, move _128) -> [return: bb73, unwind: bb100];
    }

    bb73: {
        _113 = move _114;
        _110 = push_group_spanned(_111, _20, move _112, move _113) -> [return: bb74, unwind: bb101];
    }

    bb74: {
        _108 = move _109;
        _105 = push_group_spanned(_106, _20, move _107, move _108) -> [return: bb75, unwind: bb104];
    }

    bb75: {
        _177 = &mut _76;
        _176 = push_semi_spanned(_177, _20) -> [return: bb76, unwind: bb104];
    }

    bb76: {
        _75 = move _76;
        _72 = push_group_spanned(_73, _20, move _74, move _75) -> [return: bb77, unwind: bb109];
    }

    bb77: {
        _179 = &mut _19;
        _178 = push_pound_spanned(_179, _20) -> [return: bb78, unwind: bb109];
    }

    bb78: {
        _181 = &mut _19;
        _182 = proc_macro2::Delimiter::Bracket;
        _184 = TokenStream2::new() -> [return: bb79, unwind: bb109];
    }

    bb79: {
        _186 = &mut _184;
        _187 = const "doc";
        _185 = push_ident_spanned(_186, _20, _187) -> [return: bb80, unwind: bb95];
    }

    bb80: {
        _189 = &mut _184;
        _190 = proc_macro2::Delimiter::Parenthesis;
        _192 = TokenStream2::new() -> [return: bb81, unwind: bb95];
    }

    bb81: {
        _194 = &mut _192;
        _195 = const "hidden";
        _193 = push_ident_spanned(_194, _20, _195) -> [return: bb82, unwind: bb94];
    }

    bb82: {
        _191 = move _192;
        _188 = push_group_spanned(_189, _20, move _190, move _191) -> [return: bb83, unwind: bb95];
    }

    bb83: {
        _183 = move _184;
        _180 = push_group_spanned(_181, _20, move _182, move _183) -> [return: bb84, unwind: bb109];
    }

    bb84: {
        _197 = &mut _19;
        _198 = const "pub";
        _196 = push_ident_spanned(_197, _20, _198) -> [return: bb85, unwind: bb109];
    }

    bb85: {
        _200 = &mut _19;
        _201 = const "use";
        _199 = push_ident_spanned(_200, _20, _201) -> [return: bb86, unwind: bb109];
    }

    bb86: {
        _203 = &_12;
        _204 = &mut _19;
        _202 = <proc_macro2::Ident as ToTokens>::to_tokens(_203, _204) -> [return: bb87, unwind: bb109];
    }

    bb87: {
        _206 = &mut _19;
        _207 = const "as";
        _205 = push_ident_spanned(_206, _20, _207) -> [return: bb88, unwind: bb109];
    }

    bb88: {
        _209 = &_9;
        _210 = &mut _19;
        _208 = <proc_macro2::Ident as ToTokens>::to_tokens(_209, _210) -> [return: bb89, unwind: bb109];
    }

    bb89: {
        _212 = &mut _19;
        _211 = push_semi_spanned(_212, _20) -> [return: bb90, unwind: bb109];
    }

    bb90: {
        _0 = move _19;
        drop(_16) -> [return: bb91, unwind: bb111];
    }

    bb91: {
        drop(_12) -> [return: bb92, unwind: bb112];
    }

    bb92: {
        drop(_9) -> [return: bb93, unwind continue];
    }

    bb93: {
        return;
    }

    bb94 (cleanup): {
        drop(_192) -> [return: bb95, unwind terminate(cleanup)];
    }

    bb95 (cleanup): {
        drop(_184) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb96 (cleanup): {
        drop(_167) -> [return: bb99, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        drop(_145) -> [return: bb98, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        drop(_139) -> [return: bb99, unwind terminate(cleanup)];
    }

    bb99 (cleanup): {
        drop(_129) -> [return: bb100, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        drop(_114) -> [return: bb101, unwind terminate(cleanup)];
    }

    bb101 (cleanup): {
        drop(_109) -> [return: bb104, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        drop(_89) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        drop(_81) -> [return: bb104, unwind terminate(cleanup)];
    }

    bb104 (cleanup): {
        drop(_76) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        drop(_55) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb106 (cleanup): {
        drop(_45) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        drop(_35) -> [return: bb108, unwind terminate(cleanup)];
    }

    bb108 (cleanup): {
        drop(_27) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        drop(_19) -> [return: bb110, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        drop(_16) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_12) -> [return: bb112, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_9) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        resume;
    }

    bb114: {
        goto -> bb55;
    }

    bb115: {
        goto -> bb61;
    }
}

alloc1 (static: URI_MACRO_PREFIX, size: 16, align: 8) {
    ╾───alloc2607<imm>────╼ 11 00 00 00 00 00 00 00 │ ╾──────╼........
}

alloc2607 (size: 17, align: 1) {
    0x00 │ 72 6f 63 6b 65 74 5f 75 72 69 5f 6d 61 63 72 6f │ rocket_uri_macro
    0x10 │ 5f                                              │ _
}

fn internal_uri_macro_decl::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:200:14: 200:21}, _2: &Guard) -> (&proc_macro2::Ident, &syn::Type) {
    debug guard => _2;
    let mut _0: (&proc_macro2::Ident, &syn::Type);
    let mut _3: &proc_macro2::Ident;
    let mut _4: &syn::Type;

    bb0: {
        _3 = &((*_2).1: proc_macro2::Ident);
        _4 = &((*_2).2: syn::Type);
        _0 = (move _3, move _4);
        return;
    }
}

fn internal_uri_macro_decl::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:201:14: 201:27}, _2: (&proc_macro2::Ident, &syn::Type)) -> TokenStream2 {
    let mut _0: proc_macro2::TokenStream;
    let _3: &proc_macro2::Ident;
    let _4: &syn::Type;
    let _6: ();
    let _7: &&proc_macro2::Ident;
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let _12: &&syn::Type;
    let mut _13: &mut proc_macro2::TokenStream;
    scope 1 {
        debug ident => _3;
        debug ty => _4;
        let mut _5: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _5;
        }
    }

    bb0: {
        _3 = (_2.0: &proc_macro2::Ident);
        _4 = (_2.1: &syn::Type);
        _5 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_3;
        _8 = &mut _5;
        _6 = <&proc_macro2::Ident as ToTokens>::to_tokens(_7, _8) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _10 = &mut _5;
        _9 = push_colon(_10) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _12 = &_4;
        _13 = &mut _5;
        _11 = <&syn::Type as ToTokens>::to_tokens(_12, _13) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = move _5;
        return;
    }

    bb5 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn internal_uri_macro_decl::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:205:54: 205:66}, _2: &mut dyn Hasher) -> () {
    debug hasher => _2;
    debug route => (*((*_1).0: &&attribute::route::parse::Route));
    let mut _0: ();
    let _3: ();
    let mut _4: &proc_macro2::Ident;
    let mut _5: &mut &mut dyn std::hash::Hasher;
    let _6: ();
    let mut _7: &rocket_http::uri::Path<'_>;
    let _8: rocket_http::uri::Path<'_>;
    let _9: &rocket_http::uri::Origin<'_>;
    let mut _10: &attribute::route::parse::RouteUri;
    let mut _11: &mut &mut dyn std::hash::Hasher;
    let mut _12: &std::option::Option<rocket_http::uri::Query<'_>>;
    let _13: std::option::Option<rocket_http::uri::Query<'_>>;
    let _14: &rocket_http::uri::Origin<'_>;
    let mut _15: &attribute::route::parse::RouteUri;
    let mut _16: &mut &mut dyn std::hash::Hasher;
    let mut _17: &&attribute::route::parse::Route;
    let mut _18: &attribute::route::parse::Route;
    let mut _19: &&attribute::route::parse::Route;
    let mut _20: &attribute::route::parse::Route;
    let mut _21: &&attribute::route::parse::Route;
    let mut _22: &attribute::route::parse::Route;

    bb0: {
        _17 = deref_copy ((*_1).0: &&attribute::route::parse::Route);
        _18 = deref_copy (*_17);
        _4 = &((((*_18).5: syn::ItemFn).2: syn::Signature).5: proc_macro2::Ident);
        _5 = &mut _2;
        _3 = <proc_macro2::Ident as Hash>::hash::<&mut dyn Hasher>(move _4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _19 = deref_copy ((*_1).0: &&attribute::route::parse::Route);
        _20 = deref_copy (*_19);
        _10 = &(((*_20).0: attribute::route::parse::Attribute).1: attribute::route::parse::RouteUri);
        _9 = <RouteUri as std::ops::Deref>::deref(move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = rocket_http::uri::Origin::<'_>::path(_9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &_8;
        _11 = &mut _2;
        _6 = <rocket_http::uri::Path<'_> as Hash>::hash::<&mut dyn Hasher>(move _7, _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _21 = deref_copy ((*_1).0: &&attribute::route::parse::Route);
        _22 = deref_copy (*_21);
        _15 = &(((*_22).0: attribute::route::parse::Attribute).1: attribute::route::parse::RouteUri);
        _14 = <RouteUri as std::ops::Deref>::deref(move _15) -> [return: bb5, unwind continue];
    }

    bb5: {
        _13 = rocket_http::uri::Origin::<'_>::query(_14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = &_13;
        _16 = &mut _2;
        _0 = <Option<rocket_http::uri::Query<'_>> as Hash>::hash::<&mut dyn Hasher>(move _12, _16) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn responder_outcome_expr(_1: &route::parse::Route) -> TokenStream2 {
    debug route => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: proc_macro2::Span;
    let mut _3: isize;
    let mut _4: &proc_macro2::Ident;
    let _5: &std::boxed::Box<syn::Type>;
    let mut _6: proc_macro2::Span;
    let mut _9: indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _10: &indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>;
    let mut _12: std::option::Option<syn::token::Async>;
    let mut _14: std::option::Option<proc_macro2::Span>;
    let mut _15: proc_macro2::Span;
    let mut _17: std::option::Option<proc_macro2::Span>;
    let mut _18: proc_macro2::Span;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let _30: &&proc_macro2::Ident;
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let mut _34: proc_macro2::Delimiter;
    let mut _35: proc_macro2::TokenStream;
    let mut _39: (std::iter::Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>, quote::__private::HasIterator);
    let mut _41: bool;
    let mut _43: std::option::Option<proc_macro2::Ident>;
    let mut _44: &mut std::iter::Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>;
    let mut _45: isize;
    let mut _47: bool;
    let mut _48: usize;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let mut _51: (usize, bool);
    let _52: ();
    let _53: &quote::__private::RepInterp<proc_macro2::Ident>;
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let _56: &std::option::Option<proc_macro2::TokenStream>;
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let _61: &exports::StaticPath;
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let mut _75: proc_macro2::Delimiter;
    let mut _76: proc_macro2::TokenStream;
    let _78: ();
    let _79: &exports::StaticPath;
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: &str;
    scope 1 {
        debug ret_span => _2;
        let _7: &proc_macro2::Ident;
        scope 3 {
            debug user_handler_fn_name => _7;
            let _8: std::iter::Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>;
            scope 4 {
                debug parameter_names => _8;
                let _11: std::option::Option<proc_macro2::TokenStream>;
                scope 5 {
                    debug _await => _11;
                    scope 6 {
                        debug __req => _13;
                        scope 8 {
                            debug _route => _16;
                            let mut _19: proc_macro2::TokenStream;
                            scope 10 {
                                debug _s => _19;
                                let _20: proc_macro2::Span;
                                scope 11 {
                                    debug _span => _20;
                                    let mut _36: proc_macro2::TokenStream;
                                    let mut _77: proc_macro2::TokenStream;
                                    scope 12 {
                                        debug _s => _36;
                                        scope 13 {
                                            debug _span => _20;
                                            let mut _37: usize;
                                            scope 14 {
                                                debug _i => _37;
                                                scope 15 {
                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                    scope 16 {
                                                        debug parameter_names => _38;
                                                        debug i => const HasIterator;
                                                        let _40: quote::__private::HasIterator;
                                                        scope 18 {
                                                            debug has_iter => const HasIterator;
                                                            scope 19 {
                                                                let _42: quote::__private::RepInterp<proc_macro2::Ident>;
                                                                let _46: proc_macro2::Ident;
                                                                scope 20 {
                                                                    debug parameter_names => _42;
                                                                }
                                                                scope 21 {
                                                                    debug _x => _46;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 17 {
                                                        let mut _38: std::iter::Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                    scope 22 {
                                        debug _s => _77;
                                        scope 23 {
                                            debug _span => _20;
                                        }
                                    }
                                }
                            }
                        }
                        scope 9 {
                            let _16: exports::StaticPath;
                        }
                    }
                    scope 7 {
                        let _13: exports::StaticPath;
                    }
                }
            }
        }
    }
    scope 2 {
        debug ty => _5;
    }

    bb0: {
        _3 = discriminant(((((*_1).5: syn::ItemFn).2: syn::Signature).10: syn::ReturnType));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &((((((*_1).5: syn::ItemFn).2: syn::Signature).10: syn::ReturnType) as Type).1: std::boxed::Box<syn::Type>);
        _6 = <std::boxed::Box<syn::Type> as devise::Spanned>::span(_5) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &((((*_1).5: syn::ItemFn).2: syn::Signature).5: proc_macro2::Ident);
        _2 = proc_macro2::Ident::span(move _4) -> [return: bb5, unwind continue];
    }

    bb4: {
        _2 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = &((((*_1).5: syn::ItemFn).2: syn::Signature).5: proc_macro2::Ident);
        _10 = &(((*_1).6: attribute::route::parse::Arguments).1: indexmap::IndexMap<name::Name, (proc_macro2::Ident, syn::Type)>);
        _9 = IndexMap::<name::Name, (proc_macro2::Ident, syn::Type)>::values(move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = <indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)> as Iterator>::map::<proc_macro2::Ident, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>(move _9, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = ((((*_1).5: syn::ItemFn).2: syn::Signature).1: std::option::Option<syn::token::Async>);
        _11 = Option::<syn::token::Async>::map::<TokenStream2, {closure@core/codegen/src/attribute/route/mod.rs:239:14: 239:17}>(move _12, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:239:14: 239:17}) -> [return: bb8, unwind continue];
    }

    bb8: {
        _15 = _2;
        _14 = Option::<proc_macro2::Span>::Some(move _15);
        _13 = StaticPath(move _14, const "__req");
        _18 = _2;
        _17 = Option::<proc_macro2::Span>::Some(move _18);
        _16 = StaticPath(move _17, const "::rocket::route");
        _19 = TokenStream2::new() -> [return: bb9, unwind: bb43];
    }

    bb9: {
        _20 = _2;
        _22 = &mut _19;
        _23 = const "let";
        _21 = push_ident_spanned(_22, _20, _23) -> [return: bb10, unwind: bb42];
    }

    bb10: {
        _25 = &mut _19;
        _26 = const "___responder";
        _24 = push_ident_spanned(_25, _20, _26) -> [return: bb11, unwind: bb42];
    }

    bb11: {
        _28 = &mut _19;
        _27 = push_eq_spanned(_28, _20) -> [return: bb12, unwind: bb42];
    }

    bb12: {
        _30 = &_7;
        _31 = &mut _19;
        _29 = <&proc_macro2::Ident as ToTokens>::to_tokens(_30, _31) -> [return: bb13, unwind: bb42];
    }

    bb13: {
        _33 = &mut _19;
        _34 = proc_macro2::Delimiter::Parenthesis;
        _36 = TokenStream2::new() -> [return: bb14, unwind: bb42];
    }

    bb14: {
        _37 = const 0_usize;
        _39 = <Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _8) -> [return: bb15, unwind: bb41];
    }

    bb15: {
        _38 = move (_39.0: std::iter::Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}>);
        _40 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb45, unwind: bb41];
    }

    bb16: {
        _41 = const true;
        switchInt(move _41) -> [0: bb24, otherwise: bb17];
    }

    bb17: {
        _44 = &mut _38;
        _43 = <Map<indexmap::map::Values<'_, name::Name, (proc_macro2::Ident, syn::Type)>, {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}> as Iterator>::next(move _44) -> [return: bb18, unwind: bb41];
    }

    bb18: {
        _45 = discriminant(_43);
        switchInt(move _45) -> [0: bb24, 1: bb19, otherwise: bb2];
    }

    bb19: {
        _46 = move ((_43 as Some).0: proc_macro2::Ident);
        _42 = RepInterp::<proc_macro2::Ident>(move _46);
        _48 = _37;
        _47 = Gt(move _48, const 0_usize);
        switchInt(move _47) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _50 = &mut _36;
        _49 = push_comma_spanned(_50, _20) -> [return: bb46, unwind: bb40];
    }

    bb21: {
        _51 = CheckedAdd(_37, const 1_usize);
        assert(!move (_51.1: bool), "attempt to compute `{} + {}`, which would overflow", _37, const 1_usize) -> [success: bb22, unwind: bb40];
    }

    bb22: {
        _37 = move (_51.0: usize);
        _53 = &_42;
        _54 = &mut _36;
        _52 = <RepInterp<proc_macro2::Ident> as ToTokens>::to_tokens(_53, _54) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        drop(_42) -> [return: bb16, unwind: bb41];
    }

    bb24: {
        _35 = move _36;
        _32 = push_group_spanned(_33, _20, move _34, move _35) -> [return: bb25, unwind: bb42];
    }

    bb25: {
        _56 = &_11;
        _57 = &mut _19;
        _55 = <Option<TokenStream2> as ToTokens>::to_tokens(_56, _57) -> [return: bb26, unwind: bb42];
    }

    bb26: {
        _59 = &mut _19;
        _58 = push_semi_spanned(_59, _20) -> [return: bb27, unwind: bb42];
    }

    bb27: {
        _61 = &_16;
        _62 = &mut _19;
        _60 = <StaticPath as ToTokens>::to_tokens(_61, _62) -> [return: bb28, unwind: bb42];
    }

    bb28: {
        _64 = &mut _19;
        _63 = push_colon2_spanned(_64, _20) -> [return: bb29, unwind: bb42];
    }

    bb29: {
        _66 = &mut _19;
        _67 = const "Outcome";
        _65 = push_ident_spanned(_66, _20, _67) -> [return: bb30, unwind: bb42];
    }

    bb30: {
        _69 = &mut _19;
        _68 = push_colon2_spanned(_69, _20) -> [return: bb31, unwind: bb42];
    }

    bb31: {
        _71 = &mut _19;
        _72 = const "from";
        _70 = push_ident_spanned(_71, _20, _72) -> [return: bb32, unwind: bb42];
    }

    bb32: {
        _74 = &mut _19;
        _75 = proc_macro2::Delimiter::Parenthesis;
        _77 = TokenStream2::new() -> [return: bb33, unwind: bb42];
    }

    bb33: {
        _79 = &_13;
        _80 = &mut _77;
        _78 = <StaticPath as ToTokens>::to_tokens(_79, _80) -> [return: bb34, unwind: bb39];
    }

    bb34: {
        _82 = &mut _77;
        _81 = push_comma_spanned(_82, _20) -> [return: bb35, unwind: bb39];
    }

    bb35: {
        _84 = &mut _77;
        _85 = const "___responder";
        _83 = push_ident_spanned(_84, _20, _85) -> [return: bb36, unwind: bb39];
    }

    bb36: {
        _76 = move _77;
        _73 = push_group_spanned(_74, _20, move _75, move _76) -> [return: bb37, unwind: bb42];
    }

    bb37: {
        _0 = move _19;
        drop(_11) -> [return: bb38, unwind continue];
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_77) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_42) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_36) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_19) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_11) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        resume;
    }

    bb45: {
        goto -> bb16;
    }

    bb46: {
        goto -> bb21;
    }
}

fn responder_outcome_expr::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:236:14: 236:26}, _2: &(proc_macro2::Ident, syn::Type)) -> proc_macro2::Ident {
    let mut _0: proc_macro2::Ident;
    let _3: &proc_macro2::Ident;
    scope 1 {
        debug ident => _3;
    }

    bb0: {
        _3 = &((*_2).0: proc_macro2::Ident);
        _0 = <proc_macro2::Ident as syn_ext::IdentExt>::rocketized(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn responder_outcome_expr::{closure#1}(_1: {closure@core/codegen/src/attribute/route/mod.rs:239:14: 239:17}, _2: syn::token::Async) -> TokenStream2 {
    debug a => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _5: proc_macro2::Span;
    let mut _6: &syn::token::Async;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    scope 1 {
        debug _s => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug _span => _4;
        }
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_2;
        _5 = <syn::token::Async as devise::Spanned>::span(move _6) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _4 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(move _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _8 = &mut _3;
        _7 = push_dot_spanned(_8, _4) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _10 = &mut _3;
        _11 = const "await";
        _9 = push_ident_spanned(_10, _4, _11) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = move _3;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn sentinels_expr(_1: &route::parse::Route) -> TokenStream2 {
    debug route => _1;
    let mut _0: proc_macro2::TokenStream;
    let _2: std::option::Option<syn::Type>;
    let mut _3: isize;
    let _4: &std::boxed::Box<syn::Type>;
    let mut _5: syn::Type;
    let mut _6: &syn::Type;
    let mut _8: std::iter::Map<syn::generics::TypeParams<'_>, {closure@core/codegen/src/attribute/route/mod.rs:256:14: 256:17}>;
    let mut _9: syn::generics::TypeParams<'_>;
    let mut _10: &syn::Generics;
    let mut _12: std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>;
    let mut _13: std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>;
    let mut _14: std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>;
    let mut _15: std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>;
    let mut _16: std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>;
    let mut _17: std::option::IntoIter<&syn::Type>;
    let mut _18: std::option::Option<&syn::Type>;
    let mut _19: &std::option::Option<syn::Type>;
    let mut _20: {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21};
    let mut _21: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _23: {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53};
    let mut _24: &std::vec::Vec<&proc_macro2::Ident>;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let mut _40: proc_macro2::Delimiter;
    let mut _41: proc_macro2::TokenStream;
    let mut _45: (std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>, quote::__private::HasIterator);
    let mut _46: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>;
    let mut _48: bool;
    let mut _50: std::option::Option<proc_macro2::TokenStream>;
    let mut _51: &mut std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>;
    let mut _52: isize;
    let mut _54: bool;
    let mut _55: usize;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let mut _58: (usize, bool);
    let _59: ();
    let _60: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: std::boxed::Box<syn::Type>;
    let mut _63: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<impl std::iter::Iterator<Item = &attribute::param::Guard>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>;
    let mut _64: bool;
    let mut _65: *const syn::Type;
    scope 1 {
        debug ret_ty => _2;
        let _7: std::vec::Vec<&proc_macro2::Ident>;
        scope 3 {
            debug generic_idents => _7;
            let _11: std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>;
            scope 4 {
                debug eligible_types => _11;
                let _22: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>;
                scope 5 {
                    debug sentinel => _22;
                    let mut _25: proc_macro2::TokenStream;
                    scope 6 {
                        debug _s => _25;
                        let mut _42: proc_macro2::TokenStream;
                        scope 7 {
                            debug _s => _42;
                            let mut _43: usize;
                            scope 8 {
                                debug _i => _43;
                                scope 9 {
                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                    scope 10 {
                                        debug sentinel => _44;
                                        debug i => const HasIterator;
                                        let _47: quote::__private::HasIterator;
                                        scope 12 {
                                            debug has_iter => const HasIterator;
                                            scope 13 {
                                                let _49: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                                let _53: proc_macro2::TokenStream;
                                                scope 14 {
                                                    debug sentinel => _49;
                                                }
                                                scope 15 {
                                                    debug _x => _53;
                                                }
                                            }
                                        }
                                    }
                                    scope 11 {
                                        let mut _44: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<std::iter::Chain<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, attribute::param::Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug ty => _4;
    }

    bb0: {
        _64 = const false;
        _3 = discriminant(((((*_1).5: syn::ItemFn).2: syn::Signature).10: syn::ReturnType));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = &((((((*_1).5: syn::ItemFn).2: syn::Signature).10: syn::ReturnType) as Type).1: std::boxed::Box<syn::Type>);
        _62 = deref_copy (*_4);
        _65 = (((_62.0: std::ptr::Unique<syn::Type>).0: std::ptr::NonNull<syn::Type>).0: *const syn::Type);
        _6 = &(*_65);
        _5 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(move _6) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _2 = Option::<syn::Type>::None;
        goto -> bb5;
    }

    bb4: {
        _2 = Option::<syn::Type>::Some(move _5);
        goto -> bb5;
    }

    bb5: {
        _10 = &((((*_1).5: syn::ItemFn).2: syn::Signature).6: syn::Generics);
        _9 = Generics::type_params(move _10) -> [return: bb6, unwind: bb44];
    }

    bb6: {
        _8 = <syn::generics::TypeParams<'_> as Iterator>::map::<&proc_macro2::Ident, {closure@core/codegen/src/attribute/route/mod.rs:256:14: 256:17}>(move _9, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:256:14: 256:17}) -> [return: bb7, unwind: bb44];
    }

    bb7: {
        _7 = <Map<syn::generics::TypeParams<'_>, {closure@core/codegen/src/attribute/route/mod.rs:256:14: 256:17}> as Iterator>::collect::<Vec<&proc_macro2::Ident>>(move _8) -> [return: bb8, unwind: bb44];
    }

    bb8: {
        _16 = route::<impl route::parse::Route>::guards(_1) -> [return: bb9, unwind: bb43];
    }

    bb9: {
        _15 = <std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>> as Iterator>::map::<&syn::Type, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>(move _16, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}) -> [return: bb10, unwind: bb43];
    }

    bb10: {
        _19 = &_2;
        _18 = Option::<syn::Type>::as_ref(move _19) -> [return: bb11, unwind: bb43];
    }

    bb11: {
        _17 = <Option<&syn::Type> as IntoIterator>::into_iter(move _18) -> [return: bb12, unwind: bb43];
    }

    bb12: {
        _14 = <Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}> as Iterator>::chain::<std::option::IntoIter<&syn::Type>>(move _15, move _17) -> [return: bb13, unwind: bb43];
    }

    bb13: {
        _13 = <std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>> as Iterator>::flat_map::<Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>(move _14, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}) -> [return: bb14, unwind: bb43];
    }

    bb14: {
        _21 = &_7;
        _20 = {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21} { generic_idents: move _21 };
        _12 = <FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}> as Iterator>::filter::<{closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>(move _13, move _20) -> [return: bb15, unwind: bb43];
    }

    bb15: {
        _11 = <Filter<FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}> as Iterator>::map::<(Option<Cow<'_, syn::Type>>, Cow<'_, syn::Type>), {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>(move _12, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}) -> [return: bb16, unwind: bb43];
    }

    bb16: {
        _24 = &_7;
        _23 = {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53} { generic_idents: move _24 };
        _22 = <Map<Filter<FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>(move _11, move _23) -> [return: bb17, unwind: bb43];
    }

    bb17: {
        _64 = const true;
        _25 = TokenStream2::new() -> [return: bb18, unwind: bb47];
    }

    bb18: {
        _27 = &mut _25;
        _26 = push_colon2(_27) -> [return: bb19, unwind: bb42];
    }

    bb19: {
        _29 = &mut _25;
        _30 = const "std";
        _28 = push_ident(_29, _30) -> [return: bb20, unwind: bb42];
    }

    bb20: {
        _32 = &mut _25;
        _31 = push_colon2(_32) -> [return: bb21, unwind: bb42];
    }

    bb21: {
        _34 = &mut _25;
        _35 = const "vec";
        _33 = push_ident(_34, _35) -> [return: bb22, unwind: bb42];
    }

    bb22: {
        _37 = &mut _25;
        _36 = push_bang(_37) -> [return: bb23, unwind: bb42];
    }

    bb23: {
        _39 = &mut _25;
        _40 = proc_macro2::Delimiter::Bracket;
        _42 = TokenStream2::new() -> [return: bb24, unwind: bb42];
    }

    bb24: {
        _43 = const 0_usize;
        _64 = const false;
        _46 = move _22;
        _45 = <Map<Map<Filter<FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _46) -> [return: bb25, unwind: bb41];
    }

    bb25: {
        _63 = move (_45.0: std::iter::Map<std::iter::Map<std::iter::Filter<std::iter::FlatMap<std::iter::Chain<std::iter::Map<impl std::iter::Iterator<Item = &attribute::param::Guard>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, std::vec::Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>);
        _44 = move (_63 as subtype Map<Map<Filter<FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}>);
        _47 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb48, unwind: bb40];
    }

    bb26: {
        _48 = const true;
        switchInt(move _48) -> [0: bb34, otherwise: bb27];
    }

    bb27: {
        _51 = &mut _44;
        _50 = <Map<Map<Filter<FlatMap<std::iter::Chain<Map<std::iter::Chain<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:28:45: 28:48}>>, std::slice::Iter<'_, Guard>>, {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}>, std::option::IntoIter<&syn::Type>>, Vec<syn_ext::Child<'_>>, {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}>, {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}>, {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}>, {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}> as Iterator>::next(move _51) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _52 = discriminant(_50);
        switchInt(move _52) -> [0: bb34, 1: bb29, otherwise: bb2];
    }

    bb29: {
        _53 = move ((_50 as Some).0: proc_macro2::TokenStream);
        _49 = RepInterp::<TokenStream2>(move _53);
        _55 = _43;
        _54 = Gt(move _55, const 0_usize);
        switchInt(move _54) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _57 = &mut _42;
        _56 = push_comma(_57) -> [return: bb49, unwind: bb39];
    }

    bb31: {
        _58 = CheckedAdd(_43, const 1_usize);
        assert(!move (_58.1: bool), "attempt to compute `{} + {}`, which would overflow", _43, const 1_usize) -> [success: bb32, unwind: bb39];
    }

    bb32: {
        _43 = move (_58.0: usize);
        _60 = &_49;
        _61 = &mut _42;
        _59 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_60, _61) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        drop(_49) -> [return: bb26, unwind: bb40];
    }

    bb34: {
        drop(_44) -> [return: bb35, unwind: bb41];
    }

    bb35: {
        _41 = move _42;
        _38 = push_group(_39, move _40, move _41) -> [return: bb36, unwind: bb42];
    }

    bb36: {
        _0 = move _25;
        _64 = const false;
        drop(_7) -> [return: bb37, unwind: bb44];
    }

    bb37: {
        drop(_2) -> [return: bb38, unwind continue];
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_49) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_44) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_42) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_25) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_7) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_2) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        resume;
    }

    bb46 (cleanup): {
        drop(_22) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_64) -> [0: bb43, otherwise: bb46];
    }

    bb48: {
        goto -> bb26;
    }

    bb49: {
        goto -> bb31;
    }
}

fn sentinels_expr::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:256:14: 256:17}, _2: &TypeParam) -> &proc_macro2::Ident {
    debug p => _2;
    let mut _0: &proc_macro2::Ident;

    bb0: {
        _0 = &((*_2).1: proc_macro2::Ident);
        return;
    }
}

const TYPE_MACROS: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 4];
    let _2: &[&str; 4];
    let _3: [&str; 4];
    let mut _4: &[&str; 4];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in TYPE_MACROS: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "ReaderStream", const "TextStream", const "ByteStream", const "EventStream"];
        _0 = &_1;
        return;
    }
}

fn sentinels_expr::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:279:14: 279:21}, _2: &Guard) -> &syn::Type {
    debug guard => _2;
    let mut _0: &syn::Type;

    bb0: {
        _0 = &((*_2).2: syn::Type);
        return;
    }
}

fn sentinels_expr::{closure#2}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:281:19: 281:23}, _2: &syn::Type) -> Vec<syn_ext::Child<'_>> {
    debug ty => _2;
    let mut _0: std::vec::Vec<syn_ext::Child<'_>>;
    let _3: &[&str];

    bb0: {
        _3 = const _;
        _0 = <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn sentinels_expr::{closure#3}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:282:17: 282:21}, _2: &syn_ext::Child<'_>) -> bool {
    debug ty => _2;
    debug generic_idents => (*((*_1).0: &std::vec::Vec<&proc_macro2::Ident>));
    let mut _0: bool;
    let _3: &syn::Type;
    let _4: &[&proc_macro2::Ident];
    let mut _5: &std::vec::Vec<&proc_macro2::Ident>;

    bb0: {
        _3 = <syn_ext::Child<'_> as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = deref_copy ((*_1).0: &std::vec::Vec<&proc_macro2::Ident>);
        _4 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <syn::Type as syn_ext::TypeExt>::is_concrete(_3, _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn sentinels_expr::{closure#4}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:283:14: 283:21}, _2: syn_ext::Child<'_>) -> (Option<Cow<'_, syn::Type>>, Cow<'_, syn::Type>) {
    debug child => _2;
    let mut _0: (std::option::Option<std::borrow::Cow<'_, syn::Type>>, std::borrow::Cow<'_, syn::Type>);
    let mut _3: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _4: std::borrow::Cow<'_, syn::Type>;

    bb0: {
        _3 = move (_2.0: std::option::Option<std::borrow::Cow<'_, syn::Type>>);
        _4 = move (_2.1: std::borrow::Cow<'_, syn::Type>);
        _0 = (move _3, move _4);
        return;
    }
}

fn sentinels_expr::{closure#5}(_1: &mut {closure@core/codegen/src/attribute/route/mod.rs:285:39: 285:53}, _2: (Option<Cow<'_, syn::Type>>, Cow<'_, syn::Type>)) -> TokenStream2 {
    debug generic_idents => (*((*_1).0: &std::vec::Vec<&proc_macro2::Ident>));
    let mut _0: proc_macro2::TokenStream;
    let _3: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let _4: std::borrow::Cow<'_, syn::Type>;
    let mut _6: std::option::Option<proc_macro2::Span>;
    let mut _7: proc_macro2::Span;
    let mut _8: &std::borrow::Cow<'_, syn::Type>;
    let mut _9: isize;
    let mut _12: bool;
    let _13: &syn::Type;
    let _14: &[&proc_macro2::Ident];
    let mut _17: &std::borrow::Cow<'_, syn::Type>;
    let _18: ();
    let _19: &exports::StaticPath;
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let mut _30: proc_macro2::Delimiter;
    let mut _31: proc_macro2::TokenStream;
    let _33: ();
    let _34: &std::borrow::Cow<'_, syn::Type>;
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let _39: &std::borrow::Cow<'_, syn::Type>;
    let mut _40: &mut proc_macro2::TokenStream;
    let mut _43: &std::borrow::Cow<'_, syn::Type>;
    let _44: ();
    let _45: &exports::StaticPath;
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &str;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let mut _56: proc_macro2::Delimiter;
    let mut _57: proc_macro2::TokenStream;
    let _59: ();
    let _60: &std::borrow::Cow<'_, syn::Type>;
    let mut _61: &mut proc_macro2::TokenStream;
    let mut _62: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _63: bool;
    let mut _64: isize;
    let mut _65: isize;
    scope 1 {
        debug parent => _3;
        debug ty => _4;
        scope 2 {
            debug _sentinel => _5;
            let _10: std::borrow::Cow<'_, syn::Type>;
            let _11: &std::borrow::Cow<'_, syn::Type>;
            let mut _41: proc_macro2::TokenStream;
            scope 4 {
                debug p => _10;
                debug p => _11;
                let mut _15: proc_macro2::TokenStream;
                scope 5 {
                    debug _s => _15;
                    let _16: proc_macro2::Span;
                    scope 6 {
                        debug _span => _16;
                        let mut _32: proc_macro2::TokenStream;
                        scope 7 {
                            debug _s => _32;
                            scope 8 {
                                debug _span => _16;
                            }
                        }
                    }
                }
            }
            scope 9 {
                debug _s => _41;
                let _42: proc_macro2::Span;
                scope 10 {
                    debug _span => _42;
                    let mut _58: proc_macro2::TokenStream;
                    scope 11 {
                        debug _s => _58;
                        scope 12 {
                        }
                    }
                }
            }
        }
        scope 3 {
            let _5: exports::StaticPath;
        }
    }

    bb0: {
        _63 = const false;
        _63 = const true;
        _3 = move (_2.0: std::option::Option<std::borrow::Cow<'_, syn::Type>>);
        _4 = move (_2.1: std::borrow::Cow<'_, syn::Type>);
        _8 = &_4;
        _7 = <Cow<'_, syn::Type> as devise::Spanned>::span(move _8) -> [return: bb1, unwind: bb36];
    }

    bb1: {
        _6 = Option::<proc_macro2::Span>::Some(move _7);
        _5 = StaticPath(move _6, const "::rocket::sentinel");
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb19, 1: bb3, otherwise: bb2];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _11 = &((_3 as Some).0: std::borrow::Cow<'_, syn::Type>);
        _13 = <Cow<'_, syn::Type> as std::ops::Deref>::deref(_11) -> [return: bb4, unwind: bb36];
    }

    bb4: {
        _62 = deref_copy ((*_1).0: &std::vec::Vec<&proc_macro2::Ident>);
        _14 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(_62) -> [return: bb5, unwind: bb36];
    }

    bb5: {
        _12 = <syn::Type as syn_ext::TypeExt>::is_concrete(_13, _14) -> [return: bb6, unwind: bb36];
    }

    bb6: {
        switchInt(move _12) -> [0: bb19, otherwise: bb7];
    }

    bb7: {
        _63 = const false;
        _10 = move ((_3 as Some).0: std::borrow::Cow<'_, syn::Type>);
        _15 = TokenStream2::new() -> [return: bb8, unwind: bb35];
    }

    bb8: {
        _17 = &_4;
        _16 = <Cow<'_, syn::Type> as devise::Spanned>::span(move _17) -> [return: bb9, unwind: bb34];
    }

    bb9: {
        _19 = &_5;
        _20 = &mut _15;
        _18 = <StaticPath as ToTokens>::to_tokens(_19, _20) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _22 = &mut _15;
        _21 = push_colon2_spanned(_22, _16) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _24 = &mut _15;
        _25 = const "resolve";
        _23 = push_ident_spanned(_24, _16, _25) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _27 = &mut _15;
        _26 = push_bang_spanned(_27, _16) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _29 = &mut _15;
        _30 = proc_macro2::Delimiter::Parenthesis;
        _32 = TokenStream2::new() -> [return: bb14, unwind: bb34];
    }

    bb14: {
        _34 = &_4;
        _35 = &mut _32;
        _33 = <Cow<'_, syn::Type> as ToTokens>::to_tokens(_34, _35) -> [return: bb15, unwind: bb33];
    }

    bb15: {
        _37 = &mut _32;
        _36 = push_comma_spanned(_37, _16) -> [return: bb16, unwind: bb33];
    }

    bb16: {
        _39 = &_10;
        _40 = &mut _32;
        _38 = <Cow<'_, syn::Type> as ToTokens>::to_tokens(_39, _40) -> [return: bb17, unwind: bb33];
    }

    bb17: {
        _31 = move _32;
        _28 = push_group_spanned(_29, _16, move _30, move _31) -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _0 = move _15;
        drop(_10) -> [return: bb29, unwind: bb36];
    }

    bb19: {
        _41 = TokenStream2::new() -> [return: bb20, unwind: bb36];
    }

    bb20: {
        _43 = &_4;
        _42 = <Cow<'_, syn::Type> as devise::Spanned>::span(move _43) -> [return: bb21, unwind: bb32];
    }

    bb21: {
        _45 = &_5;
        _46 = &mut _41;
        _44 = <StaticPath as ToTokens>::to_tokens(_45, _46) -> [return: bb22, unwind: bb32];
    }

    bb22: {
        _48 = &mut _41;
        _47 = push_colon2_spanned(_48, _42) -> [return: bb23, unwind: bb32];
    }

    bb23: {
        _50 = &mut _41;
        _51 = const "resolve";
        _49 = push_ident_spanned(_50, _42, _51) -> [return: bb24, unwind: bb32];
    }

    bb24: {
        _53 = &mut _41;
        _52 = push_bang_spanned(_53, _42) -> [return: bb25, unwind: bb32];
    }

    bb25: {
        _55 = &mut _41;
        _56 = proc_macro2::Delimiter::Parenthesis;
        _58 = TokenStream2::new() -> [return: bb26, unwind: bb32];
    }

    bb26: {
        _60 = &_4;
        _61 = &mut _58;
        _59 = <Cow<'_, syn::Type> as ToTokens>::to_tokens(_60, _61) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _57 = move _58;
        _54 = push_group_spanned(_55, _42, move _56, move _57) -> [return: bb28, unwind: bb32];
    }

    bb28: {
        _0 = move _41;
        goto -> bb29;
    }

    bb29: {
        drop(_4) -> [return: bb30, unwind: bb43];
    }

    bb30: {
        _64 = discriminant(_3);
        switchInt(move _64) -> [1: bb39, otherwise: bb38];
    }

    bb31 (cleanup): {
        drop(_58) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_41) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_32) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_15) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_10) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_4) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        resume;
    }

    bb38: {
        _63 = const false;
        return;
    }

    bb39: {
        switchInt(_63) -> [0: bb38, otherwise: bb40];
    }

    bb40: {
        drop(((_3 as Some).0: std::borrow::Cow<'_, syn::Type>)) -> [return: bb38, unwind continue];
    }

    bb41 (cleanup): {
        switchInt(_63) -> [0: bb37, otherwise: bb42];
    }

    bb42 (cleanup): {
        drop(((_3 as Some).0: std::borrow::Cow<'_, syn::Type>)) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        _65 = discriminant(_3);
        switchInt(move _65) -> [1: bb41, otherwise: bb37];
    }
}

fn codegen_route(_1: route::parse::Route) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug route => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: std::iter::Map<std::slice::Iter<'_, attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::request_guard_decl}>;
    let mut _3: std::slice::Iter<'_, attribute::param::Guard>;
    let _4: &[attribute::param::Guard];
    let mut _5: &std::vec::Vec<attribute::param::Guard>;
    let mut _7: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>;
    let mut _8: &attribute::route::parse::Route;
    let _10: &attribute::route::parse::Route;
    let mut _12: std::option::Option<&attribute::param::Guard>;
    let mut _13: &std::option::Option<attribute::param::Guard>;
    let _15: &attribute::route::parse::Route;
    let mut _18: (&syn::Visibility, &syn::ItemFn);
    let mut _19: &syn::Visibility;
    let mut _20: &syn::ItemFn;
    let _23: &attribute::route::parse::Route;
    let _25: &attribute::route::parse::Route;
    let _28: &rocket_http::uri::Origin<'_>;
    let mut _29: &attribute::route::parse::RouteUri;
    let mut _31: std::option::Option<isize>;
    let mut _33: std::option::Option<&http_codegen::MediaType>;
    let mut _34: &std::option::Option<http_codegen::MediaType>;
    let mut _35: proc_macro2::TokenStream;
    let mut _36: proc_macro2::TokenStream;
    let _38: ();
    let _39: &&syn::ItemFn;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let mut _45: proc_macro2::Delimiter;
    let mut _46: proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let mut _53: proc_macro2::Delimiter;
    let mut _54: proc_macro2::TokenStream;
    let _56: ();
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: &str;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let mut _63: proc_macro2::Delimiter;
    let mut _64: proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let mut _71: proc_macro2::Delimiter;
    let mut _72: proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: &str;
    let _77: ();
    let mut _78: &mut proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let mut _81: proc_macro2::Delimiter;
    let mut _82: proc_macro2::TokenStream;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: &str;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: ();
    let mut _90: &mut proc_macro2::TokenStream;
    let _91: &str;
    let _92: ();
    let _93: &&syn::Visibility;
    let mut _94: &mut proc_macro2::TokenStream;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let _97: &str;
    let _98: ();
    let _99: &&proc_macro2::Ident;
    let mut _100: &mut proc_macro2::TokenStream;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let mut _103: proc_macro2::Delimiter;
    let mut _104: proc_macro2::TokenStream;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let mut _109: proc_macro2::Delimiter;
    let mut _110: proc_macro2::TokenStream;
    let _112: ();
    let mut _113: &mut proc_macro2::TokenStream;
    let _114: &str;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: ();
    let mut _118: &mut proc_macro2::TokenStream;
    let _119: &str;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: &str;
    let _123: ();
    let _124: &&proc_macro2::Ident;
    let mut _125: &mut proc_macro2::TokenStream;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let mut _128: proc_macro2::Delimiter;
    let mut _129: proc_macro2::TokenStream;
    let _131: ();
    let mut _132: &mut proc_macro2::TokenStream;
    let _133: ();
    let mut _134: &mut proc_macro2::TokenStream;
    let mut _135: proc_macro2::Delimiter;
    let mut _136: proc_macro2::TokenStream;
    let _138: ();
    let mut _139: &mut proc_macro2::TokenStream;
    let _140: &str;
    let _141: ();
    let mut _142: &mut proc_macro2::TokenStream;
    let mut _143: proc_macro2::Delimiter;
    let mut _144: proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: ();
    let mut _152: &mut proc_macro2::TokenStream;
    let _153: &str;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let _156: ();
    let mut _157: &mut proc_macro2::TokenStream;
    let _158: &str;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: &str;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: &str;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let mut _167: proc_macro2::Delimiter;
    let mut _168: proc_macro2::TokenStream;
    let _170: ();
    let mut _171: &mut proc_macro2::TokenStream;
    let _172: &str;
    let _173: ();
    let mut _174: &mut proc_macro2::TokenStream;
    let _175: ();
    let mut _176: &mut proc_macro2::TokenStream;
    let _177: ();
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: ();
    let mut _180: &mut proc_macro2::TokenStream;
    let _181: &str;
    let _182: ();
    let mut _183: &mut proc_macro2::TokenStream;
    let mut _184: proc_macro2::Delimiter;
    let mut _185: proc_macro2::TokenStream;
    let _187: ();
    let mut _188: &mut proc_macro2::TokenStream;
    let _189: &str;
    let _190: ();
    let mut _191: &mut proc_macro2::TokenStream;
    let _192: &str;
    let _193: ();
    let mut _194: &mut proc_macro2::TokenStream;
    let _195: ();
    let mut _196: &mut proc_macro2::TokenStream;
    let _197: &str;
    let _198: ();
    let mut _199: &mut proc_macro2::TokenStream;
    let _200: ();
    let mut _201: &mut proc_macro2::TokenStream;
    let mut _202: proc_macro2::Delimiter;
    let mut _203: proc_macro2::TokenStream;
    let _205: ();
    let mut _206: &mut proc_macro2::TokenStream;
    let _207: ();
    let mut _208: &mut proc_macro2::TokenStream;
    let _209: ();
    let mut _210: &mut proc_macro2::TokenStream;
    let _211: ();
    let mut _212: &mut proc_macro2::TokenStream;
    let _213: &str;
    let _214: ();
    let mut _215: &mut proc_macro2::TokenStream;
    let _216: ();
    let mut _217: &mut proc_macro2::TokenStream;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let _220: &str;
    let _221: ();
    let mut _222: &mut proc_macro2::TokenStream;
    let _223: ();
    let mut _224: &mut proc_macro2::TokenStream;
    let _225: ();
    let mut _226: &mut proc_macro2::TokenStream;
    let _227: ();
    let mut _228: &mut proc_macro2::TokenStream;
    let _229: ();
    let mut _230: &mut proc_macro2::TokenStream;
    let _231: ();
    let mut _232: &mut proc_macro2::TokenStream;
    let _233: ();
    let mut _234: &mut proc_macro2::TokenStream;
    let _235: &str;
    let _236: ();
    let mut _237: &mut proc_macro2::TokenStream;
    let _238: ();
    let mut _239: &mut proc_macro2::TokenStream;
    let _240: ();
    let mut _241: &mut proc_macro2::TokenStream;
    let _242: ();
    let mut _243: &mut proc_macro2::TokenStream;
    let _244: ();
    let mut _245: &mut proc_macro2::TokenStream;
    let _246: &str;
    let _247: ();
    let mut _248: &mut proc_macro2::TokenStream;
    let _249: ();
    let mut _250: &mut proc_macro2::TokenStream;
    let _251: &str;
    let _252: ();
    let mut _253: &mut proc_macro2::TokenStream;
    let _254: ();
    let mut _255: &mut proc_macro2::TokenStream;
    let mut _256: proc_macro2::Delimiter;
    let mut _257: proc_macro2::TokenStream;
    let _259: ();
    let mut _260: &mut proc_macro2::TokenStream;
    let _261: ();
    let mut _262: &mut proc_macro2::TokenStream;
    let _263: ();
    let mut _264: &mut proc_macro2::TokenStream;
    let _265: &str;
    let _266: ();
    let mut _267: &mut proc_macro2::TokenStream;
    let mut _268: proc_macro2::Delimiter;
    let mut _269: proc_macro2::TokenStream;
    let _271: ();
    let mut _272: &mut proc_macro2::TokenStream;
    let _273: &str;
    let _274: ();
    let mut _275: &mut proc_macro2::TokenStream;
    let _276: &str;
    let _277: ();
    let mut _278: &mut proc_macro2::TokenStream;
    let mut _279: proc_macro2::Delimiter;
    let mut _280: proc_macro2::TokenStream;
    let mut _283: (std::iter::Map<std::slice::Iter<'_, attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::request_guard_decl}>, quote::__private::HasIterator);
    let mut _285: bool;
    let mut _287: std::option::Option<proc_macro2::TokenStream>;
    let mut _288: &mut std::iter::Map<std::slice::Iter<'_, attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::request_guard_decl}>;
    let mut _289: isize;
    let _291: ();
    let _292: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _293: &mut proc_macro2::TokenStream;
    let mut _295: (std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>, quote::__private::HasIterator);
    let mut _297: bool;
    let mut _299: std::option::Option<proc_macro2::TokenStream>;
    let mut _300: &mut std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>;
    let mut _301: isize;
    let _303: ();
    let _304: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _305: &mut proc_macro2::TokenStream;
    let _306: ();
    let _307: &std::option::Option<proc_macro2::TokenStream>;
    let mut _308: &mut proc_macro2::TokenStream;
    let _309: ();
    let _310: &std::option::Option<proc_macro2::TokenStream>;
    let mut _311: &mut proc_macro2::TokenStream;
    let _312: ();
    let _313: &proc_macro2::TokenStream;
    let mut _314: &mut proc_macro2::TokenStream;
    let _315: ();
    let mut _316: &mut proc_macro2::TokenStream;
    let _317: ();
    let mut _318: &mut proc_macro2::TokenStream;
    let _319: ();
    let mut _320: &mut proc_macro2::TokenStream;
    let _321: &str;
    let _322: ();
    let mut _323: &mut proc_macro2::TokenStream;
    let mut _324: proc_macro2::Delimiter;
    let mut _325: proc_macro2::TokenStream;
    let _327: ();
    let mut _328: &mut proc_macro2::TokenStream;
    let _329: &str;
    let _330: ();
    let mut _331: &mut proc_macro2::TokenStream;
    let _332: ();
    let mut _333: &mut proc_macro2::TokenStream;
    let _334: &str;
    let _335: ();
    let mut _336: &mut proc_macro2::TokenStream;
    let _337: ();
    let mut _338: &mut proc_macro2::TokenStream;
    let mut _339: proc_macro2::Delimiter;
    let mut _340: proc_macro2::TokenStream;
    let _342: ();
    let _343: &&proc_macro2::Ident;
    let mut _344: &mut proc_macro2::TokenStream;
    let _345: ();
    let mut _346: &mut proc_macro2::TokenStream;
    let _347: ();
    let mut _348: &mut proc_macro2::TokenStream;
    let _349: &str;
    let _350: ();
    let mut _351: &mut proc_macro2::TokenStream;
    let _352: ();
    let _353: &devise::SpanWrapped<http_codegen::Method>;
    let mut _354: &mut proc_macro2::TokenStream;
    let _355: ();
    let mut _356: &mut proc_macro2::TokenStream;
    let _357: ();
    let mut _358: &mut proc_macro2::TokenStream;
    let _359: &str;
    let _360: ();
    let mut _361: &mut proc_macro2::TokenStream;
    let _362: ();
    let _363: &std::string::String;
    let mut _364: &mut proc_macro2::TokenStream;
    let _365: ();
    let mut _366: &mut proc_macro2::TokenStream;
    let _367: ();
    let mut _368: &mut proc_macro2::TokenStream;
    let _369: &str;
    let _370: ();
    let mut _371: &mut proc_macro2::TokenStream;
    let _372: ();
    let mut _373: &mut proc_macro2::TokenStream;
    let _374: &str;
    let _375: ();
    let mut _376: &mut proc_macro2::TokenStream;
    let _377: ();
    let mut _378: &mut proc_macro2::TokenStream;
    let _379: &str;
    let _380: ();
    let mut _381: &mut proc_macro2::TokenStream;
    let _382: ();
    let _383: &http_codegen::Optional<&http_codegen::MediaType>;
    let mut _384: &mut proc_macro2::TokenStream;
    let _385: ();
    let mut _386: &mut proc_macro2::TokenStream;
    let _387: ();
    let mut _388: &mut proc_macro2::TokenStream;
    let _389: &str;
    let _390: ();
    let mut _391: &mut proc_macro2::TokenStream;
    let _392: ();
    let _393: &http_codegen::Optional<isize>;
    let mut _394: &mut proc_macro2::TokenStream;
    let _395: ();
    let mut _396: &mut proc_macro2::TokenStream;
    let _397: ();
    let mut _398: &mut proc_macro2::TokenStream;
    let _399: &str;
    let _400: ();
    let mut _401: &mut proc_macro2::TokenStream;
    let _402: ();
    let _403: &proc_macro2::TokenStream;
    let mut _404: &mut proc_macro2::TokenStream;
    let _405: ();
    let mut _406: &mut proc_macro2::TokenStream;
    let _407: ();
    let mut _408: &mut proc_macro2::TokenStream;
    let _409: ();
    let mut _410: &mut proc_macro2::TokenStream;
    let mut _411: proc_macro2::Delimiter;
    let mut _412: proc_macro2::TokenStream;
    let _414: ();
    let mut _415: &mut proc_macro2::TokenStream;
    let _416: &str;
    let _417: ();
    let mut _418: &mut proc_macro2::TokenStream;
    let mut _419: proc_macro2::Delimiter;
    let mut _420: proc_macro2::TokenStream;
    let _422: ();
    let mut _423: &mut proc_macro2::TokenStream;
    let _424: &str;
    let _425: ();
    let mut _426: &mut proc_macro2::TokenStream;
    let _427: &str;
    let _428: ();
    let mut _429: &mut proc_macro2::TokenStream;
    let _430: &str;
    let _431: ();
    let mut _432: &mut proc_macro2::TokenStream;
    let _433: &str;
    let _434: ();
    let mut _435: &mut proc_macro2::TokenStream;
    let mut _436: proc_macro2::Delimiter;
    let mut _437: proc_macro2::TokenStream;
    let _439: ();
    let mut _440: &mut proc_macro2::TokenStream;
    let _441: &str;
    let _442: ();
    let mut _443: &mut proc_macro2::TokenStream;
    let _444: ();
    let mut _445: &mut proc_macro2::TokenStream;
    let _446: ();
    let mut _447: &mut proc_macro2::TokenStream;
    let mut _448: proc_macro2::Delimiter;
    let mut _449: proc_macro2::TokenStream;
    let _451: ();
    let mut _452: &mut proc_macro2::TokenStream;
    let _453: &str;
    let _454: ();
    let mut _455: &mut proc_macro2::TokenStream;
    let _456: ();
    let mut _457: &mut proc_macro2::TokenStream;
    let _458: &str;
    let _459: ();
    let mut _460: &mut proc_macro2::TokenStream;
    let mut _461: proc_macro2::Delimiter;
    let mut _462: proc_macro2::TokenStream;
    let _463: ();
    let mut _464: &mut proc_macro2::TokenStream;
    let _465: ();
    let mut _466: &mut proc_macro2::TokenStream;
    let _467: &str;
    let _468: ();
    let mut _469: &mut proc_macro2::TokenStream;
    let mut _470: proc_macro2::Delimiter;
    let mut _471: proc_macro2::TokenStream;
    let _472: ();
    let mut _473: &mut proc_macro2::TokenStream;
    let _474: ();
    let mut _475: &mut proc_macro2::TokenStream;
    let mut _476: proc_macro2::Delimiter;
    let mut _477: proc_macro2::TokenStream;
    let _479: ();
    let mut _480: &mut proc_macro2::TokenStream;
    let _481: &str;
    let _482: ();
    let mut _483: &mut proc_macro2::TokenStream;
    let _484: ();
    let mut _485: &mut proc_macro2::TokenStream;
    let _486: &str;
    let _487: ();
    let _488: &proc_macro2::TokenStream;
    let mut _489: &mut proc_macro2::TokenStream;
    let mut _499: std::iter::Map<impl std::iter::Iterator<Item = &attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>;
    scope 1 {
        debug request_guards => _2;
        let _6: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>;
        scope 2 {
            debug param_guards => _6;
            let _9: std::option::Option<proc_macro2::TokenStream>;
            scope 3 {
                debug query_guards => _9;
                let _11: std::option::Option<proc_macro2::TokenStream>;
                scope 4 {
                    debug data_guard => _11;
                    let _14: proc_macro2::TokenStream;
                    scope 5 {
                        debug sentinels => _14;
                        let _16: &syn::Visibility;
                        let _17: &syn::ItemFn;
                        scope 6 {
                            debug vis => _16;
                            debug handler_fn => _17;
                            let _21: &proc_macro2::Ident;
                            scope 7 {
                                debug handler_fn_name => _21;
                                let _22: proc_macro2::TokenStream;
                                scope 8 {
                                    debug internal_uri_macro => _22;
                                    let _24: proc_macro2::TokenStream;
                                    scope 9 {
                                        debug responder_outcome => _24;
                                        let _26: devise::SpanWrapped<http_codegen::Method>;
                                        scope 10 {
                                            debug method => _26;
                                            let _27: std::string::String;
                                            scope 11 {
                                                debug uri => _27;
                                                let _30: http_codegen::Optional<isize>;
                                                scope 12 {
                                                    debug rank => _30;
                                                    let _32: http_codegen::Optional<&http_codegen::MediaType>;
                                                    scope 13 {
                                                        debug format => _32;
                                                        let mut _37: proc_macro2::TokenStream;
                                                        scope 14 {
                                                            debug _s => _37;
                                                            let mut _47: proc_macro2::TokenStream;
                                                            let mut _65: proc_macro2::TokenStream;
                                                            let mut _83: proc_macro2::TokenStream;
                                                            let mut _111: proc_macro2::TokenStream;
                                                            let mut _130: proc_macro2::TokenStream;
                                                            let mut _478: proc_macro2::TokenStream;
                                                            scope 15 {
                                                                debug _s => _47;
                                                                let mut _55: proc_macro2::TokenStream;
                                                                scope 16 {
                                                                    debug _s => _55;
                                                                }
                                                            }
                                                            scope 17 {
                                                                debug _s => _65;
                                                                let mut _73: proc_macro2::TokenStream;
                                                                scope 18 {
                                                                    debug _s => _73;
                                                                }
                                                            }
                                                            scope 19 {
                                                                debug _s => _83;
                                                            }
                                                            scope 20 {
                                                                debug _s => _111;
                                                            }
                                                            scope 21 {
                                                                debug _s => _130;
                                                                let mut _137: proc_macro2::TokenStream;
                                                                let mut _169: proc_macro2::TokenStream;
                                                                let mut _186: proc_macro2::TokenStream;
                                                                let mut _413: proc_macro2::TokenStream;
                                                                let mut _438: proc_macro2::TokenStream;
                                                                let mut _450: proc_macro2::TokenStream;
                                                                let mut _490: &exports::StaticPath;
                                                                let mut _498: &exports::StaticPath;
                                                                scope 22 {
                                                                    debug _s => _137;
                                                                    let mut _145: proc_macro2::TokenStream;
                                                                    scope 23 {
                                                                        debug _s => _145;
                                                                    }
                                                                }
                                                                scope 24 {
                                                                    debug _s => _169;
                                                                }
                                                                scope 25 {
                                                                    debug _s => _186;
                                                                    let mut _204: proc_macro2::TokenStream;
                                                                    let mut _258: proc_macro2::TokenStream;
                                                                    let mut _326: proc_macro2::TokenStream;
                                                                    let mut _491: &exports::StaticPath;
                                                                    let mut _493: &exports::StaticPath;
                                                                    scope 26 {
                                                                        debug _s => _204;
                                                                        let mut _494: &exports::StaticPath;
                                                                        let mut _495: &exports::StaticPath;
                                                                        let mut _496: &exports::StaticPath;
                                                                        let mut _497: &exports::StaticPath;
                                                                    }
                                                                    scope 27 {
                                                                        debug _s => _258;
                                                                        let mut _270: proc_macro2::TokenStream;
                                                                        let mut _492: &exports::StaticPath;
                                                                        scope 28 {
                                                                            debug _s => _270;
                                                                            let mut _281: proc_macro2::TokenStream;
                                                                            scope 29 {
                                                                                debug _s => _281;
                                                                                scope 30 {
                                                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                                    scope 31 {
                                                                                        debug request_guards => _282;
                                                                                        debug i => const HasIterator;
                                                                                        let _284: quote::__private::HasIterator;
                                                                                        scope 33 {
                                                                                            debug has_iter => const HasIterator;
                                                                                            scope 34 {
                                                                                                let _286: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                                                                                let _290: proc_macro2::TokenStream;
                                                                                                scope 35 {
                                                                                                    debug request_guards => _286;
                                                                                                }
                                                                                                scope 36 {
                                                                                                    debug _x => _290;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 32 {
                                                                                        let mut _282: std::iter::Map<std::slice::Iter<'_, attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::request_guard_decl}>;
                                                                                    }
                                                                                }
                                                                                scope 37 {
                                                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                                                    scope 38 {
                                                                                        debug param_guards => _294;
                                                                                        debug i => const HasIterator;
                                                                                        let _296: quote::__private::HasIterator;
                                                                                        scope 40 {
                                                                                            debug has_iter => const HasIterator;
                                                                                            scope 41 {
                                                                                                let _298: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                                                                                let _302: proc_macro2::TokenStream;
                                                                                                scope 42 {
                                                                                                    debug param_guards => _298;
                                                                                                }
                                                                                                scope 43 {
                                                                                                    debug _x => _302;
                                                                                                }
                                                                                            }
                                                                                        }
                                                                                    }
                                                                                    scope 39 {
                                                                                        let mut _294: std::iter::Map<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>;
                                                                                    }
                                                                                }
                                                                            }
                                                                        }
                                                                    }
                                                                    scope 44 {
                                                                        debug _s => _326;
                                                                        let mut _341: proc_macro2::TokenStream;
                                                                        scope 45 {
                                                                            debug _s => _341;
                                                                        }
                                                                    }
                                                                }
                                                                scope 46 {
                                                                    debug _s => _413;
                                                                    let mut _421: proc_macro2::TokenStream;
                                                                    scope 47 {
                                                                        debug _s => _421;
                                                                    }
                                                                }
                                                                scope 48 {
                                                                    debug _s => _438;
                                                                }
                                                                scope 49 {
                                                                    debug _s => _450;
                                                                }
                                                            }
                                                            scope 50 {
                                                                debug _s => _478;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = &(_1.4: std::vec::Vec<attribute::param::Guard>);
        _4 = <Vec<Guard> as std::ops::Deref>::deref(move _5) -> [return: bb1, unwind: bb241];
    }

    bb1: {
        _3 = core::slice::<impl [Guard]>::iter(_4) -> [return: bb2, unwind: bb241];
    }

    bb2: {
        _2 = <std::slice::Iter<'_, Guard> as Iterator>::map::<TokenStream2, for<'a> fn(&'a Guard) -> TokenStream2 {request_guard_decl}>(move _3, request_guard_decl) -> [return: bb3, unwind: bb241];
    }

    bb3: {
        _8 = &_1;
        _7 = route::<impl route::parse::Route>::param_guards(move _8) -> [return: bb4, unwind: bb241];
    }

    bb4: {
        _6 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}> as Iterator>::map::<TokenStream2, for<'a> fn(&'a Guard) -> TokenStream2 {param_guard_decl}>(move _7, param_guard_decl) -> [return: bb5, unwind: bb241];
    }

    bb5: {
        _10 = &_1;
        _9 = query_decls(_10) -> [return: bb6, unwind: bb241];
    }

    bb6: {
        _13 = &(_1.3: std::option::Option<attribute::param::Guard>);
        _12 = Option::<Guard>::as_ref(move _13) -> [return: bb7, unwind: bb240];
    }

    bb7: {
        _11 = Option::<&Guard>::map::<TokenStream2, for<'a> fn(&'a Guard) -> TokenStream2 {data_guard_decl}>(move _12, data_guard_decl) -> [return: bb8, unwind: bb240];
    }

    bb8: {
        _15 = &_1;
        _14 = sentinels_expr(_15) -> [return: bb9, unwind: bb239];
    }

    bb9: {
        _19 = &((_1.5: syn::ItemFn).1: syn::Visibility);
        _20 = &(_1.5: syn::ItemFn);
        _18 = (move _19, move _20);
        _16 = (_18.0: &syn::Visibility);
        _17 = (_18.1: &syn::ItemFn);
        _21 = &(((*_17).2: syn::Signature).5: proc_macro2::Ident);
        _23 = &_1;
        _22 = internal_uri_macro_decl(_23) -> [return: bb10, unwind: bb238];
    }

    bb10: {
        _25 = &_1;
        _24 = responder_outcome_expr(_25) -> [return: bb11, unwind: bb237];
    }

    bb11: {
        _26 = ((_1.0: attribute::route::parse::Attribute).0: devise::SpanWrapped<http_codegen::Method>);
        _29 = &((_1.0: attribute::route::parse::Attribute).1: attribute::route::parse::RouteUri);
        _28 = <RouteUri as std::ops::Deref>::deref(move _29) -> [return: bb12, unwind: bb236];
    }

    bb12: {
        _27 = <rocket_http::uri::Origin<'_> as ToString>::to_string(_28) -> [return: bb13, unwind: bb236];
    }

    bb13: {
        _31 = ((_1.0: attribute::route::parse::Attribute).4: std::option::Option<isize>);
        _30 = Optional::<isize>(move _31);
        _34 = &((_1.0: attribute::route::parse::Attribute).3: std::option::Option<http_codegen::MediaType>);
        _33 = Option::<http_codegen::MediaType>::as_ref(move _34) -> [return: bb14, unwind: bb235];
    }

    bb14: {
        _32 = Optional::<&http_codegen::MediaType>(move _33);
        _37 = TokenStream2::new() -> [return: bb15, unwind: bb235];
    }

    bb15: {
        _39 = &_17;
        _40 = &mut _37;
        _38 = <&ItemFn as ToTokens>::to_tokens(_39, _40) -> [return: bb16, unwind: bb234];
    }

    bb16: {
        _42 = &mut _37;
        _41 = push_pound(_42) -> [return: bb17, unwind: bb234];
    }

    bb17: {
        _44 = &mut _37;
        _45 = proc_macro2::Delimiter::Bracket;
        _47 = TokenStream2::new() -> [return: bb18, unwind: bb234];
    }

    bb18: {
        _49 = &mut _47;
        _50 = const "doc";
        _48 = push_ident(_49, _50) -> [return: bb19, unwind: bb233];
    }

    bb19: {
        _52 = &mut _47;
        _53 = proc_macro2::Delimiter::Parenthesis;
        _55 = TokenStream2::new() -> [return: bb20, unwind: bb233];
    }

    bb20: {
        _57 = &mut _55;
        _58 = const "hidden";
        _56 = push_ident(_57, _58) -> [return: bb21, unwind: bb232];
    }

    bb21: {
        _54 = move _55;
        _51 = push_group(_52, move _53, move _54) -> [return: bb22, unwind: bb233];
    }

    bb22: {
        _46 = move _47;
        _43 = push_group(_44, move _45, move _46) -> [return: bb23, unwind: bb234];
    }

    bb23: {
        _60 = &mut _37;
        _59 = push_pound(_60) -> [return: bb24, unwind: bb234];
    }

    bb24: {
        _62 = &mut _37;
        _63 = proc_macro2::Delimiter::Bracket;
        _65 = TokenStream2::new() -> [return: bb25, unwind: bb234];
    }

    bb25: {
        _67 = &mut _65;
        _68 = const "allow";
        _66 = push_ident(_67, _68) -> [return: bb26, unwind: bb231];
    }

    bb26: {
        _70 = &mut _65;
        _71 = proc_macro2::Delimiter::Parenthesis;
        _73 = TokenStream2::new() -> [return: bb27, unwind: bb231];
    }

    bb27: {
        _75 = &mut _73;
        _76 = const "non_camel_case_types";
        _74 = push_ident(_75, _76) -> [return: bb28, unwind: bb230];
    }

    bb28: {
        _72 = move _73;
        _69 = push_group(_70, move _71, move _72) -> [return: bb29, unwind: bb231];
    }

    bb29: {
        _64 = move _65;
        _61 = push_group(_62, move _63, move _64) -> [return: bb30, unwind: bb234];
    }

    bb30: {
        _78 = &mut _37;
        _77 = push_pound(_78) -> [return: bb31, unwind: bb234];
    }

    bb31: {
        _80 = &mut _37;
        _81 = proc_macro2::Delimiter::Bracket;
        _83 = TokenStream2::new() -> [return: bb32, unwind: bb234];
    }

    bb32: {
        _85 = &mut _83;
        _86 = const "doc";
        _84 = push_ident(_85, _86) -> [return: bb33, unwind: bb229];
    }

    bb33: {
        _88 = &mut _83;
        _87 = push_eq(_88) -> [return: bb34, unwind: bb229];
    }

    bb34: {
        _90 = &mut _83;
        _91 = const "r\" Rocket code generated proxy structure.\"";
        _89 = quote::__private::parse(_90, _91) -> [return: bb35, unwind: bb229];
    }

    bb35: {
        _82 = move _83;
        _79 = push_group(_80, move _81, move _82) -> [return: bb36, unwind: bb234];
    }

    bb36: {
        _93 = &_16;
        _94 = &mut _37;
        _92 = <&Visibility as ToTokens>::to_tokens(_93, _94) -> [return: bb37, unwind: bb234];
    }

    bb37: {
        _96 = &mut _37;
        _97 = const "struct";
        _95 = push_ident(_96, _97) -> [return: bb38, unwind: bb234];
    }

    bb38: {
        _99 = &_21;
        _100 = &mut _37;
        _98 = <&proc_macro2::Ident as ToTokens>::to_tokens(_99, _100) -> [return: bb39, unwind: bb234];
    }

    bb39: {
        _102 = &mut _37;
        _103 = proc_macro2::Delimiter::Brace;
        _104 = TokenStream2::new() -> [return: bb40, unwind: bb234];
    }

    bb40: {
        _101 = push_group(_102, move _103, move _104) -> [return: bb41, unwind: bb234];
    }

    bb41: {
        _106 = &mut _37;
        _105 = push_pound(_106) -> [return: bb42, unwind: bb234];
    }

    bb42: {
        _108 = &mut _37;
        _109 = proc_macro2::Delimiter::Bracket;
        _111 = TokenStream2::new() -> [return: bb43, unwind: bb234];
    }

    bb43: {
        _113 = &mut _111;
        _114 = const "doc";
        _112 = push_ident(_113, _114) -> [return: bb44, unwind: bb228];
    }

    bb44: {
        _116 = &mut _111;
        _115 = push_eq(_116) -> [return: bb45, unwind: bb228];
    }

    bb45: {
        _118 = &mut _111;
        _119 = const "r\" Rocket code generated proxy static conversion implementations.\"";
        _117 = quote::__private::parse(_118, _119) -> [return: bb46, unwind: bb228];
    }

    bb46: {
        _110 = move _111;
        _107 = push_group(_108, move _109, move _110) -> [return: bb47, unwind: bb234];
    }

    bb47: {
        _121 = &mut _37;
        _122 = const "impl";
        _120 = push_ident(_121, _122) -> [return: bb48, unwind: bb234];
    }

    bb48: {
        _124 = &_21;
        _125 = &mut _37;
        _123 = <&proc_macro2::Ident as ToTokens>::to_tokens(_124, _125) -> [return: bb49, unwind: bb234];
    }

    bb49: {
        _127 = &mut _37;
        _128 = proc_macro2::Delimiter::Brace;
        _130 = TokenStream2::new() -> [return: bb50, unwind: bb234];
    }

    bb50: {
        _132 = &mut _130;
        _131 = push_pound(_132) -> [return: bb51, unwind: bb227];
    }

    bb51: {
        _134 = &mut _130;
        _135 = proc_macro2::Delimiter::Bracket;
        _137 = TokenStream2::new() -> [return: bb52, unwind: bb227];
    }

    bb52: {
        _139 = &mut _137;
        _140 = const "allow";
        _138 = push_ident(_139, _140) -> [return: bb53, unwind: bb226];
    }

    bb53: {
        _142 = &mut _137;
        _143 = proc_macro2::Delimiter::Parenthesis;
        _145 = TokenStream2::new() -> [return: bb54, unwind: bb226];
    }

    bb54: {
        _147 = &mut _145;
        _148 = const "non_snake_case";
        _146 = push_ident(_147, _148) -> [return: bb55, unwind: bb225];
    }

    bb55: {
        _150 = &mut _145;
        _149 = push_comma(_150) -> [return: bb56, unwind: bb225];
    }

    bb56: {
        _152 = &mut _145;
        _153 = const "unreachable_patterns";
        _151 = push_ident(_152, _153) -> [return: bb57, unwind: bb225];
    }

    bb57: {
        _155 = &mut _145;
        _154 = push_comma(_155) -> [return: bb58, unwind: bb225];
    }

    bb58: {
        _157 = &mut _145;
        _158 = const "unreachable_code";
        _156 = push_ident(_157, _158) -> [return: bb59, unwind: bb225];
    }

    bb59: {
        _144 = move _145;
        _141 = push_group(_142, move _143, move _144) -> [return: bb60, unwind: bb226];
    }

    bb60: {
        _136 = move _137;
        _133 = push_group(_134, move _135, move _136) -> [return: bb61, unwind: bb227];
    }

    bb61: {
        _160 = &mut _130;
        _161 = const "fn";
        _159 = push_ident(_160, _161) -> [return: bb62, unwind: bb227];
    }

    bb62: {
        _163 = &mut _130;
        _164 = const "into_info";
        _162 = push_ident(_163, _164) -> [return: bb63, unwind: bb227];
    }

    bb63: {
        _166 = &mut _130;
        _167 = proc_macro2::Delimiter::Parenthesis;
        _169 = TokenStream2::new() -> [return: bb64, unwind: bb227];
    }

    bb64: {
        _171 = &mut _169;
        _172 = const "self";
        _170 = push_ident(_171, _172) -> [return: bb65, unwind: bb224];
    }

    bb65: {
        _168 = move _169;
        _165 = push_group(_166, move _167, move _168) -> [return: bb66, unwind: bb227];
    }

    bb66: {
        _174 = &mut _130;
        _173 = push_rarrow(_174) -> [return: bb67, unwind: bb227];
    }

    bb67: {
        _498 = const _;
        _176 = &mut _130;
        _175 = <StaticPath as ToTokens>::to_tokens(_498, _176) -> [return: bb68, unwind: bb227];
    }

    bb68: {
        _178 = &mut _130;
        _177 = push_colon2(_178) -> [return: bb69, unwind: bb227];
    }

    bb69: {
        _180 = &mut _130;
        _181 = const "StaticInfo";
        _179 = push_ident(_180, _181) -> [return: bb70, unwind: bb227];
    }

    bb70: {
        _183 = &mut _130;
        _184 = proc_macro2::Delimiter::Brace;
        _186 = TokenStream2::new() -> [return: bb71, unwind: bb227];
    }

    bb71: {
        _188 = &mut _186;
        _189 = const "fn";
        _187 = push_ident(_188, _189) -> [return: bb72, unwind: bb223];
    }

    bb72: {
        _191 = &mut _186;
        _192 = const "monomorphized_function";
        _190 = push_ident(_191, _192) -> [return: bb73, unwind: bb223];
    }

    bb73: {
        _194 = &mut _186;
        _193 = push_lt(_194) -> [return: bb74, unwind: bb223];
    }

    bb74: {
        _196 = &mut _186;
        _197 = const "'__r";
        _195 = push_lifetime(_196, _197) -> [return: bb75, unwind: bb223];
    }

    bb75: {
        _199 = &mut _186;
        _198 = push_gt(_199) -> [return: bb76, unwind: bb223];
    }

    bb76: {
        _201 = &mut _186;
        _202 = proc_macro2::Delimiter::Parenthesis;
        _204 = TokenStream2::new() -> [return: bb77, unwind: bb223];
    }

    bb77: {
        _497 = const _;
        _206 = &mut _204;
        _205 = <StaticPath as ToTokens>::to_tokens(_497, _206) -> [return: bb78, unwind: bb222];
    }

    bb78: {
        _208 = &mut _204;
        _207 = push_colon(_208) -> [return: bb79, unwind: bb222];
    }

    bb79: {
        _210 = &mut _204;
        _209 = push_and(_210) -> [return: bb80, unwind: bb222];
    }

    bb80: {
        _212 = &mut _204;
        _213 = const "'__r";
        _211 = push_lifetime(_212, _213) -> [return: bb81, unwind: bb222];
    }

    bb81: {
        _496 = const _;
        _215 = &mut _204;
        _214 = <StaticPath as ToTokens>::to_tokens(_496, _215) -> [return: bb82, unwind: bb222];
    }

    bb82: {
        _217 = &mut _204;
        _216 = push_lt(_217) -> [return: bb83, unwind: bb222];
    }

    bb83: {
        _219 = &mut _204;
        _220 = const "'_";
        _218 = push_lifetime(_219, _220) -> [return: bb84, unwind: bb222];
    }

    bb84: {
        _222 = &mut _204;
        _221 = push_gt(_222) -> [return: bb85, unwind: bb222];
    }

    bb85: {
        _224 = &mut _204;
        _223 = push_comma(_224) -> [return: bb86, unwind: bb222];
    }

    bb86: {
        _495 = const _;
        _226 = &mut _204;
        _225 = <StaticPath as ToTokens>::to_tokens(_495, _226) -> [return: bb87, unwind: bb222];
    }

    bb87: {
        _228 = &mut _204;
        _227 = push_colon(_228) -> [return: bb88, unwind: bb222];
    }

    bb88: {
        _494 = const _;
        _230 = &mut _204;
        _229 = <StaticPath as ToTokens>::to_tokens(_494, _230) -> [return: bb89, unwind: bb222];
    }

    bb89: {
        _232 = &mut _204;
        _231 = push_lt(_232) -> [return: bb90, unwind: bb222];
    }

    bb90: {
        _234 = &mut _204;
        _235 = const "'__r";
        _233 = push_lifetime(_234, _235) -> [return: bb91, unwind: bb222];
    }

    bb91: {
        _237 = &mut _204;
        _236 = push_gt(_237) -> [return: bb92, unwind: bb222];
    }

    bb92: {
        _203 = move _204;
        _200 = push_group(_201, move _202, move _203) -> [return: bb93, unwind: bb223];
    }

    bb93: {
        _239 = &mut _186;
        _238 = push_rarrow(_239) -> [return: bb94, unwind: bb223];
    }

    bb94: {
        _493 = const _;
        _241 = &mut _186;
        _240 = <StaticPath as ToTokens>::to_tokens(_493, _241) -> [return: bb95, unwind: bb223];
    }

    bb95: {
        _243 = &mut _186;
        _242 = push_colon2(_243) -> [return: bb96, unwind: bb223];
    }

    bb96: {
        _245 = &mut _186;
        _246 = const "BoxFuture";
        _244 = push_ident(_245, _246) -> [return: bb97, unwind: bb223];
    }

    bb97: {
        _248 = &mut _186;
        _247 = push_lt(_248) -> [return: bb98, unwind: bb223];
    }

    bb98: {
        _250 = &mut _186;
        _251 = const "'__r";
        _249 = push_lifetime(_250, _251) -> [return: bb99, unwind: bb223];
    }

    bb99: {
        _253 = &mut _186;
        _252 = push_gt(_253) -> [return: bb100, unwind: bb223];
    }

    bb100: {
        _255 = &mut _186;
        _256 = proc_macro2::Delimiter::Brace;
        _258 = TokenStream2::new() -> [return: bb101, unwind: bb223];
    }

    bb101: {
        _492 = const _;
        _260 = &mut _258;
        _259 = <StaticPath as ToTokens>::to_tokens(_492, _260) -> [return: bb102, unwind: bb221];
    }

    bb102: {
        _262 = &mut _258;
        _261 = push_colon2(_262) -> [return: bb103, unwind: bb221];
    }

    bb103: {
        _264 = &mut _258;
        _265 = const "pin";
        _263 = push_ident(_264, _265) -> [return: bb104, unwind: bb221];
    }

    bb104: {
        _267 = &mut _258;
        _268 = proc_macro2::Delimiter::Parenthesis;
        _270 = TokenStream2::new() -> [return: bb105, unwind: bb221];
    }

    bb105: {
        _272 = &mut _270;
        _273 = const "async";
        _271 = push_ident(_272, _273) -> [return: bb106, unwind: bb220];
    }

    bb106: {
        _275 = &mut _270;
        _276 = const "move";
        _274 = push_ident(_275, _276) -> [return: bb107, unwind: bb220];
    }

    bb107: {
        _278 = &mut _270;
        _279 = proc_macro2::Delimiter::Brace;
        _281 = TokenStream2::new() -> [return: bb108, unwind: bb220];
    }

    bb108: {
        _283 = <Map<std::slice::Iter<'_, Guard>, for<'a> fn(&'a Guard) -> TokenStream2 {request_guard_decl}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _2) -> [return: bb109, unwind: bb219];
    }

    bb109: {
        _282 = move (_283.0: std::iter::Map<std::slice::Iter<'_, attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::request_guard_decl}>);
        _284 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb243, unwind: bb219];
    }

    bb110: {
        _285 = const true;
        switchInt(move _285) -> [0: bb116, otherwise: bb111];
    }

    bb111: {
        _288 = &mut _282;
        _287 = <Map<std::slice::Iter<'_, Guard>, for<'a> fn(&'a Guard) -> TokenStream2 {request_guard_decl}> as Iterator>::next(move _288) -> [return: bb112, unwind: bb219];
    }

    bb112: {
        _289 = discriminant(_287);
        switchInt(move _289) -> [0: bb116, 1: bb114, otherwise: bb113];
    }

    bb113: {
        unreachable;
    }

    bb114: {
        _290 = move ((_287 as Some).0: proc_macro2::TokenStream);
        _286 = RepInterp::<TokenStream2>(move _290);
        _292 = &_286;
        _293 = &mut _281;
        _291 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_292, _293) -> [return: bb115, unwind: bb218];
    }

    bb115: {
        drop(_286) -> [return: bb110, unwind: bb219];
    }

    bb116: {
        _295 = <Map<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a Guard) -> TokenStream2 {param_guard_decl}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _6) -> [return: bb117, unwind: bb219];
    }

    bb117: {
        _499 = move (_295.0: std::iter::Map<impl std::iter::Iterator<Item = &attribute::param::Guard>, for<'a> fn(&'a attribute::param::Guard) -> proc_macro2::TokenStream {attribute::route::param_guard_decl}>);
        _294 = move (_499 as subtype Map<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a Guard) -> TokenStream2 {param_guard_decl}>);
        _296 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb244, unwind: bb219];
    }

    bb118: {
        _297 = const true;
        switchInt(move _297) -> [0: bb123, otherwise: bb119];
    }

    bb119: {
        _300 = &mut _294;
        _299 = <Map<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/attribute/route/mod.rs:24:44: 24:47}>, for<'a> fn(&'a Guard) -> TokenStream2 {param_guard_decl}> as Iterator>::next(move _300) -> [return: bb120, unwind: bb219];
    }

    bb120: {
        _301 = discriminant(_299);
        switchInt(move _301) -> [0: bb123, 1: bb121, otherwise: bb113];
    }

    bb121: {
        _302 = move ((_299 as Some).0: proc_macro2::TokenStream);
        _298 = RepInterp::<TokenStream2>(move _302);
        _304 = &_298;
        _305 = &mut _281;
        _303 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_304, _305) -> [return: bb122, unwind: bb217];
    }

    bb122: {
        drop(_298) -> [return: bb118, unwind: bb219];
    }

    bb123: {
        _307 = &_9;
        _308 = &mut _281;
        _306 = <Option<TokenStream2> as ToTokens>::to_tokens(_307, _308) -> [return: bb124, unwind: bb219];
    }

    bb124: {
        _310 = &_11;
        _311 = &mut _281;
        _309 = <Option<TokenStream2> as ToTokens>::to_tokens(_310, _311) -> [return: bb125, unwind: bb219];
    }

    bb125: {
        _313 = &_24;
        _314 = &mut _281;
        _312 = <TokenStream2 as ToTokens>::to_tokens(_313, _314) -> [return: bb126, unwind: bb219];
    }

    bb126: {
        _280 = move _281;
        _277 = push_group(_278, move _279, move _280) -> [return: bb127, unwind: bb220];
    }

    bb127: {
        _269 = move _270;
        _266 = push_group(_267, move _268, move _269) -> [return: bb128, unwind: bb221];
    }

    bb128: {
        _257 = move _258;
        _254 = push_group(_255, move _256, move _257) -> [return: bb129, unwind: bb223];
    }

    bb129: {
        _491 = const _;
        _316 = &mut _186;
        _315 = <StaticPath as ToTokens>::to_tokens(_491, _316) -> [return: bb130, unwind: bb223];
    }

    bb130: {
        _318 = &mut _186;
        _317 = push_colon2(_318) -> [return: bb131, unwind: bb223];
    }

    bb131: {
        _320 = &mut _186;
        _321 = const "StaticInfo";
        _319 = push_ident(_320, _321) -> [return: bb132, unwind: bb223];
    }

    bb132: {
        _323 = &mut _186;
        _324 = proc_macro2::Delimiter::Brace;
        _326 = TokenStream2::new() -> [return: bb133, unwind: bb223];
    }

    bb133: {
        _328 = &mut _326;
        _329 = const "name";
        _327 = push_ident(_328, _329) -> [return: bb134, unwind: bb216];
    }

    bb134: {
        _331 = &mut _326;
        _330 = push_colon(_331) -> [return: bb135, unwind: bb216];
    }

    bb135: {
        _333 = &mut _326;
        _334 = const "stringify";
        _332 = push_ident(_333, _334) -> [return: bb136, unwind: bb216];
    }

    bb136: {
        _336 = &mut _326;
        _335 = push_bang(_336) -> [return: bb137, unwind: bb216];
    }

    bb137: {
        _338 = &mut _326;
        _339 = proc_macro2::Delimiter::Parenthesis;
        _341 = TokenStream2::new() -> [return: bb138, unwind: bb216];
    }

    bb138: {
        _343 = &_21;
        _344 = &mut _341;
        _342 = <&proc_macro2::Ident as ToTokens>::to_tokens(_343, _344) -> [return: bb139, unwind: bb215];
    }

    bb139: {
        _340 = move _341;
        _337 = push_group(_338, move _339, move _340) -> [return: bb140, unwind: bb216];
    }

    bb140: {
        _346 = &mut _326;
        _345 = push_comma(_346) -> [return: bb141, unwind: bb216];
    }

    bb141: {
        _348 = &mut _326;
        _349 = const "method";
        _347 = push_ident(_348, _349) -> [return: bb142, unwind: bb216];
    }

    bb142: {
        _351 = &mut _326;
        _350 = push_colon(_351) -> [return: bb143, unwind: bb216];
    }

    bb143: {
        _353 = &_26;
        _354 = &mut _326;
        _352 = <devise::SpanWrapped<http_codegen::Method> as ToTokens>::to_tokens(_353, _354) -> [return: bb144, unwind: bb216];
    }

    bb144: {
        _356 = &mut _326;
        _355 = push_comma(_356) -> [return: bb145, unwind: bb216];
    }

    bb145: {
        _358 = &mut _326;
        _359 = const "uri";
        _357 = push_ident(_358, _359) -> [return: bb146, unwind: bb216];
    }

    bb146: {
        _361 = &mut _326;
        _360 = push_colon(_361) -> [return: bb147, unwind: bb216];
    }

    bb147: {
        _363 = &_27;
        _364 = &mut _326;
        _362 = <std::string::String as ToTokens>::to_tokens(_363, _364) -> [return: bb148, unwind: bb216];
    }

    bb148: {
        _366 = &mut _326;
        _365 = push_comma(_366) -> [return: bb149, unwind: bb216];
    }

    bb149: {
        _368 = &mut _326;
        _369 = const "handler";
        _367 = push_ident(_368, _369) -> [return: bb150, unwind: bb216];
    }

    bb150: {
        _371 = &mut _326;
        _370 = push_colon(_371) -> [return: bb151, unwind: bb216];
    }

    bb151: {
        _373 = &mut _326;
        _374 = const "monomorphized_function";
        _372 = push_ident(_373, _374) -> [return: bb152, unwind: bb216];
    }

    bb152: {
        _376 = &mut _326;
        _375 = push_comma(_376) -> [return: bb153, unwind: bb216];
    }

    bb153: {
        _378 = &mut _326;
        _379 = const "format";
        _377 = push_ident(_378, _379) -> [return: bb154, unwind: bb216];
    }

    bb154: {
        _381 = &mut _326;
        _380 = push_colon(_381) -> [return: bb155, unwind: bb216];
    }

    bb155: {
        _383 = &_32;
        _384 = &mut _326;
        _382 = <Optional<&http_codegen::MediaType> as ToTokens>::to_tokens(_383, _384) -> [return: bb156, unwind: bb216];
    }

    bb156: {
        _386 = &mut _326;
        _385 = push_comma(_386) -> [return: bb157, unwind: bb216];
    }

    bb157: {
        _388 = &mut _326;
        _389 = const "rank";
        _387 = push_ident(_388, _389) -> [return: bb158, unwind: bb216];
    }

    bb158: {
        _391 = &mut _326;
        _390 = push_colon(_391) -> [return: bb159, unwind: bb216];
    }

    bb159: {
        _393 = &_30;
        _394 = &mut _326;
        _392 = <Optional<isize> as ToTokens>::to_tokens(_393, _394) -> [return: bb160, unwind: bb216];
    }

    bb160: {
        _396 = &mut _326;
        _395 = push_comma(_396) -> [return: bb161, unwind: bb216];
    }

    bb161: {
        _398 = &mut _326;
        _399 = const "sentinels";
        _397 = push_ident(_398, _399) -> [return: bb162, unwind: bb216];
    }

    bb162: {
        _401 = &mut _326;
        _400 = push_colon(_401) -> [return: bb163, unwind: bb216];
    }

    bb163: {
        _403 = &_14;
        _404 = &mut _326;
        _402 = <TokenStream2 as ToTokens>::to_tokens(_403, _404) -> [return: bb164, unwind: bb216];
    }

    bb164: {
        _406 = &mut _326;
        _405 = push_comma(_406) -> [return: bb165, unwind: bb216];
    }

    bb165: {
        _325 = move _326;
        _322 = push_group(_323, move _324, move _325) -> [return: bb166, unwind: bb223];
    }

    bb166: {
        _185 = move _186;
        _182 = push_group(_183, move _184, move _185) -> [return: bb167, unwind: bb227];
    }

    bb167: {
        _408 = &mut _130;
        _407 = push_pound(_408) -> [return: bb168, unwind: bb227];
    }

    bb168: {
        _410 = &mut _130;
        _411 = proc_macro2::Delimiter::Bracket;
        _413 = TokenStream2::new() -> [return: bb169, unwind: bb227];
    }

    bb169: {
        _415 = &mut _413;
        _416 = const "doc";
        _414 = push_ident(_415, _416) -> [return: bb170, unwind: bb214];
    }

    bb170: {
        _418 = &mut _413;
        _419 = proc_macro2::Delimiter::Parenthesis;
        _421 = TokenStream2::new() -> [return: bb171, unwind: bb214];
    }

    bb171: {
        _423 = &mut _421;
        _424 = const "hidden";
        _422 = push_ident(_423, _424) -> [return: bb172, unwind: bb213];
    }

    bb172: {
        _420 = move _421;
        _417 = push_group(_418, move _419, move _420) -> [return: bb173, unwind: bb214];
    }

    bb173: {
        _412 = move _413;
        _409 = push_group(_410, move _411, move _412) -> [return: bb174, unwind: bb227];
    }

    bb174: {
        _426 = &mut _130;
        _427 = const "pub";
        _425 = push_ident(_426, _427) -> [return: bb175, unwind: bb227];
    }

    bb175: {
        _429 = &mut _130;
        _430 = const "fn";
        _428 = push_ident(_429, _430) -> [return: bb176, unwind: bb227];
    }

    bb176: {
        _432 = &mut _130;
        _433 = const "into_route";
        _431 = push_ident(_432, _433) -> [return: bb177, unwind: bb227];
    }

    bb177: {
        _435 = &mut _130;
        _436 = proc_macro2::Delimiter::Parenthesis;
        _438 = TokenStream2::new() -> [return: bb178, unwind: bb227];
    }

    bb178: {
        _440 = &mut _438;
        _441 = const "self";
        _439 = push_ident(_440, _441) -> [return: bb179, unwind: bb212];
    }

    bb179: {
        _437 = move _438;
        _434 = push_group(_435, move _436, move _437) -> [return: bb180, unwind: bb227];
    }

    bb180: {
        _443 = &mut _130;
        _442 = push_rarrow(_443) -> [return: bb181, unwind: bb227];
    }

    bb181: {
        _490 = const _;
        _445 = &mut _130;
        _444 = <StaticPath as ToTokens>::to_tokens(_490, _445) -> [return: bb182, unwind: bb227];
    }

    bb182: {
        _447 = &mut _130;
        _448 = proc_macro2::Delimiter::Brace;
        _450 = TokenStream2::new() -> [return: bb183, unwind: bb227];
    }

    bb183: {
        _452 = &mut _450;
        _453 = const "self";
        _451 = push_ident(_452, _453) -> [return: bb184, unwind: bb211];
    }

    bb184: {
        _455 = &mut _450;
        _454 = push_dot(_455) -> [return: bb185, unwind: bb211];
    }

    bb185: {
        _457 = &mut _450;
        _458 = const "into_info";
        _456 = push_ident(_457, _458) -> [return: bb186, unwind: bb211];
    }

    bb186: {
        _460 = &mut _450;
        _461 = proc_macro2::Delimiter::Parenthesis;
        _462 = TokenStream2::new() -> [return: bb187, unwind: bb211];
    }

    bb187: {
        _459 = push_group(_460, move _461, move _462) -> [return: bb188, unwind: bb211];
    }

    bb188: {
        _464 = &mut _450;
        _463 = push_dot(_464) -> [return: bb189, unwind: bb211];
    }

    bb189: {
        _466 = &mut _450;
        _467 = const "into";
        _465 = push_ident(_466, _467) -> [return: bb190, unwind: bb211];
    }

    bb190: {
        _469 = &mut _450;
        _470 = proc_macro2::Delimiter::Parenthesis;
        _471 = TokenStream2::new() -> [return: bb191, unwind: bb211];
    }

    bb191: {
        _468 = push_group(_469, move _470, move _471) -> [return: bb192, unwind: bb211];
    }

    bb192: {
        _449 = move _450;
        _446 = push_group(_447, move _448, move _449) -> [return: bb193, unwind: bb227];
    }

    bb193: {
        _129 = move _130;
        _126 = push_group(_127, move _128, move _129) -> [return: bb194, unwind: bb234];
    }

    bb194: {
        _473 = &mut _37;
        _472 = push_pound(_473) -> [return: bb195, unwind: bb234];
    }

    bb195: {
        _475 = &mut _37;
        _476 = proc_macro2::Delimiter::Bracket;
        _478 = TokenStream2::new() -> [return: bb196, unwind: bb234];
    }

    bb196: {
        _480 = &mut _478;
        _481 = const "doc";
        _479 = push_ident(_480, _481) -> [return: bb197, unwind: bb210];
    }

    bb197: {
        _483 = &mut _478;
        _482 = push_eq(_483) -> [return: bb198, unwind: bb210];
    }

    bb198: {
        _485 = &mut _478;
        _486 = const "r\" Rocket code generated wrapping URI macro.\"";
        _484 = quote::__private::parse(_485, _486) -> [return: bb199, unwind: bb210];
    }

    bb199: {
        _477 = move _478;
        _474 = push_group(_475, move _476, move _477) -> [return: bb200, unwind: bb234];
    }

    bb200: {
        _488 = &_22;
        _489 = &mut _37;
        _487 = <TokenStream2 as ToTokens>::to_tokens(_488, _489) -> [return: bb201, unwind: bb234];
    }

    bb201: {
        _36 = move _37;
        _35 = <TokenStream2 as Into<TokenStream2>>::into(move _36) -> [return: bb202, unwind: bb235];
    }

    bb202: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _35);
        drop(_27) -> [return: bb203, unwind: bb236];
    }

    bb203: {
        drop(_24) -> [return: bb204, unwind: bb237];
    }

    bb204: {
        drop(_22) -> [return: bb205, unwind: bb238];
    }

    bb205: {
        drop(_14) -> [return: bb206, unwind: bb239];
    }

    bb206: {
        drop(_11) -> [return: bb207, unwind: bb240];
    }

    bb207: {
        drop(_9) -> [return: bb208, unwind: bb241];
    }

    bb208: {
        drop(_1) -> [return: bb209, unwind continue];
    }

    bb209: {
        return;
    }

    bb210 (cleanup): {
        drop(_478) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb211 (cleanup): {
        drop(_450) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb212 (cleanup): {
        drop(_438) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb213 (cleanup): {
        drop(_421) -> [return: bb214, unwind terminate(cleanup)];
    }

    bb214 (cleanup): {
        drop(_413) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb215 (cleanup): {
        drop(_341) -> [return: bb216, unwind terminate(cleanup)];
    }

    bb216 (cleanup): {
        drop(_326) -> [return: bb223, unwind terminate(cleanup)];
    }

    bb217 (cleanup): {
        drop(_298) -> [return: bb219, unwind terminate(cleanup)];
    }

    bb218 (cleanup): {
        drop(_286) -> [return: bb219, unwind terminate(cleanup)];
    }

    bb219 (cleanup): {
        drop(_281) -> [return: bb220, unwind terminate(cleanup)];
    }

    bb220 (cleanup): {
        drop(_270) -> [return: bb221, unwind terminate(cleanup)];
    }

    bb221 (cleanup): {
        drop(_258) -> [return: bb223, unwind terminate(cleanup)];
    }

    bb222 (cleanup): {
        drop(_204) -> [return: bb223, unwind terminate(cleanup)];
    }

    bb223 (cleanup): {
        drop(_186) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb224 (cleanup): {
        drop(_169) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb225 (cleanup): {
        drop(_145) -> [return: bb226, unwind terminate(cleanup)];
    }

    bb226 (cleanup): {
        drop(_137) -> [return: bb227, unwind terminate(cleanup)];
    }

    bb227 (cleanup): {
        drop(_130) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb228 (cleanup): {
        drop(_111) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb229 (cleanup): {
        drop(_83) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb230 (cleanup): {
        drop(_73) -> [return: bb231, unwind terminate(cleanup)];
    }

    bb231 (cleanup): {
        drop(_65) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb232 (cleanup): {
        drop(_55) -> [return: bb233, unwind terminate(cleanup)];
    }

    bb233 (cleanup): {
        drop(_47) -> [return: bb234, unwind terminate(cleanup)];
    }

    bb234 (cleanup): {
        drop(_37) -> [return: bb235, unwind terminate(cleanup)];
    }

    bb235 (cleanup): {
        drop(_27) -> [return: bb236, unwind terminate(cleanup)];
    }

    bb236 (cleanup): {
        drop(_24) -> [return: bb237, unwind terminate(cleanup)];
    }

    bb237 (cleanup): {
        drop(_22) -> [return: bb238, unwind terminate(cleanup)];
    }

    bb238 (cleanup): {
        drop(_14) -> [return: bb239, unwind terminate(cleanup)];
    }

    bb239 (cleanup): {
        drop(_11) -> [return: bb240, unwind terminate(cleanup)];
    }

    bb240 (cleanup): {
        drop(_9) -> [return: bb241, unwind terminate(cleanup)];
    }

    bb241 (cleanup): {
        drop(_1) -> [return: bb242, unwind terminate(cleanup)];
    }

    bb242 (cleanup): {
        resume;
    }

    bb243: {
        goto -> bb110;
    }

    bb244: {
        goto -> bb118;
    }
}

promoted[0] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[5] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[6] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[7] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[8] in codegen_route: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn complete_route(_1: TokenStream2, _2: TokenStream2) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug args => _1;
    debug input => _2;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _3: syn::ItemFn;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::ItemFn>;
    let mut _5: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _6: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _7: std::result::Result<syn::ItemFn, syn::Error>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _10: syn::ItemFn;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let mut _18: proc_macro2::Delimiter;
    let mut _19: proc_macro2::TokenStream;
    let _21: ();
    let _22: &proc_macro2::TokenStream;
    let mut _23: &mut proc_macro2::TokenStream;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::Attribute>;
    let mut _26: std::result::Result<attribute::route::parse::Attribute, devise::Diagnostic>;
    let _27: &devise::MetaItem;
    let _28: devise::MetaItem;
    let mut _29: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, devise::MetaItem>;
    let mut _30: std::result::Result<devise::MetaItem, syn::Error>;
    let mut _31: isize;
    let mut _34: isize;
    let mut _37: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::Route>;
    let mut _38: std::result::Result<attribute::route::parse::Route, devise::Diagnostic>;
    let mut _39: attribute::route::parse::Attribute;
    let mut _40: syn::ItemFn;
    let mut _41: isize;
    let mut _44: bool;
    let mut _45: bool;
    scope 1 {
        debug function => _3;
        let _11: proc_macro2::TokenStream;
        let mut _12: proc_macro2::TokenStream;
        scope 6 {
            debug attr_tokens => _11;
            let _24: attribute::route::parse::Attribute;
            let _32: std::result::Result<std::convert::Infallible, syn::Error>;
            let _33: devise::MetaItem;
            let _35: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
            let _36: attribute::route::parse::Attribute;
            scope 9 {
                debug attribute => _24;
                let _42: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _43: attribute::route::parse::Route;
                scope 18 {
                    debug residual => _42;
                    scope 19 {
                    }
                }
                scope 20 {
                    debug val => _43;
                    scope 21 {
                    }
                }
            }
            scope 10 {
                debug residual => _32;
                scope 11 {
                }
            }
            scope 12 {
                debug val => _33;
                scope 13 {
                }
            }
            scope 14 {
                debug residual => _35;
                scope 15 {
                }
            }
            scope 16 {
                debug val => _36;
                scope 17 {
                }
            }
        }
        scope 7 {
            debug _s => _12;
            let mut _20: proc_macro2::TokenStream;
            scope 8 {
                debug _s => _20;
            }
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _45 = const false;
        _44 = const false;
        _7 = syn::parse2::<ItemFn>(move _2) -> [return: bb1, unwind: bb34];
    }

    bb1: {
        _6 = std::result::Result::<ItemFn, syn::Error>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/mod.rs:372:18: 372:21}>(move _7, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:372:18: 372:21}) -> [return: bb2, unwind: bb34];
    }

    bb2: {
        _5 = std::result::Result::<ItemFn, devise::Diagnostic>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/mod.rs:373:18: 373:24}>(move _6, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:373:18: 373:24}) -> [return: bb3, unwind: bb34];
    }

    bb3: {
        _4 = <std::result::Result<ItemFn, devise::Diagnostic> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind: bb34];
    }

    bb4: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_4 as Continue).0: syn::ItemFn);
        _45 = const true;
        _3 = move _10;
        _12 = TokenStream2::new() -> [return: bb8, unwind: bb41];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _9) -> [return: bb42, unwind: bb34];
    }

    bb8: {
        _14 = &mut _12;
        _15 = const "route";
        _13 = push_ident(_14, _15) -> [return: bb9, unwind: bb33];
    }

    bb9: {
        _17 = &mut _12;
        _18 = proc_macro2::Delimiter::Parenthesis;
        _20 = TokenStream2::new() -> [return: bb10, unwind: bb33];
    }

    bb10: {
        _22 = &_1;
        _23 = &mut _20;
        _21 = <TokenStream2 as ToTokens>::to_tokens(_22, _23) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _19 = move _20;
        _16 = push_group(_17, move _18, move _19) -> [return: bb12, unwind: bb33];
    }

    bb12: {
        _11 = move _12;
        _30 = syn::parse2::<devise::MetaItem>(move _11) -> [return: bb13, unwind: bb41];
    }

    bb13: {
        _29 = <std::result::Result<devise::MetaItem, syn::Error> as std::ops::Try>::branch(move _30) -> [return: bb14, unwind: bb41];
    }

    bb14: {
        _31 = discriminant(_29);
        switchInt(move _31) -> [0: bb15, 1: bb16, otherwise: bb6];
    }

    bb15: {
        _33 = move ((_29 as Continue).0: devise::MetaItem);
        _28 = move _33;
        _27 = &_28;
        _26 = <route::parse::Attribute as devise::FromMeta>::from_meta(_27) -> [return: bb17, unwind: bb31];
    }

    bb16: {
        _32 = move ((_29 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _32) -> [return: bb43, unwind: bb41];
    }

    bb17: {
        _25 = <std::result::Result<route::parse::Attribute, devise::Diagnostic> as std::ops::Try>::branch(move _26) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        _34 = discriminant(_25);
        switchInt(move _34) -> [0: bb19, 1: bb20, otherwise: bb6];
    }

    bb19: {
        _36 = move ((_25 as Continue).0: attribute::route::parse::Attribute);
        _44 = const true;
        _24 = move _36;
        drop(_28) -> [return: bb36, unwind: bb39];
    }

    bb20: {
        _35 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _35) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        drop(_28) -> [return: bb37, unwind: bb41];
    }

    bb22: {
        _37 = <std::result::Result<route::parse::Route, devise::Diagnostic> as std::ops::Try>::branch(move _38) -> [return: bb23, unwind: bb39];
    }

    bb23: {
        _41 = discriminant(_37);
        switchInt(move _41) -> [0: bb24, 1: bb25, otherwise: bb6];
    }

    bb24: {
        _43 = move ((_37 as Continue).0: attribute::route::parse::Route);
        _0 = codegen_route(move _43) -> [return: bb27, unwind: bb34];
    }

    bb25: {
        _42 = move ((_37 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _42) -> [return: bb26, unwind: bb34];
    }

    bb26: {
        _44 = const false;
        _45 = const false;
        goto -> bb29;
    }

    bb27: {
        _44 = const false;
        _45 = const false;
        drop(_1) -> [return: bb30, unwind continue];
    }

    bb28: {
        _45 = const false;
        goto -> bb29;
    }

    bb29: {
        drop(_1) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_28) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_20) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_12) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_1) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        _44 = const false;
        _39 = move _24;
        _45 = const false;
        _40 = move _3;
        _38 = route::parse::Route::from(move _39, move _40) -> [return: bb22, unwind: bb39];
    }

    bb37: {
        _44 = const false;
        drop(_3) -> [return: bb28, unwind: bb34];
    }

    bb38 (cleanup): {
        drop(_24) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        switchInt(_44) -> [0: bb41, otherwise: bb38];
    }

    bb40 (cleanup): {
        drop(_3) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        switchInt(_45) -> [0: bb34, otherwise: bb40];
    }

    bb42: {
        goto -> bb28;
    }

    bb43: {
        goto -> bb37;
    }
}

fn complete_route::{closure#0}(_1: {closure@core/codegen/src/attribute/route/mod.rs:372:18: 372:21}, _2: syn::Error) -> devise::Diagnostic {
    debug e => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = <devise::Diagnostic as From<syn::Error>>::from(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn complete_route::{closure#1}(_1: {closure@core/codegen/src/attribute/route/mod.rs:373:18: 373:24}, _2: devise::Diagnostic) -> devise::Diagnostic {
    debug diag => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = devise::Diagnostic::help::<&str>(move _2, const "`#[route]` can only be used on functions") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn incomplete_route(_1: rocket_http::Method, _2: TokenStream2, _3: TokenStream2) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug method => _1;
    debug args => _2;
    debug input => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: std::string::String;
    let _5: &str;
    let mut _6: &std::string::String;
    let _7: std::string::String;
    let mut _8: &rocket_http::Method;
    let mut _10: &proc_macro_ext::StringLit;
    let _11: proc_macro_ext::StringLit;
    let mut _12: std::string::String;
    let mut _14: std::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: &[core::fmt::rt::Argument<'_>];
    let _17: &[core::fmt::rt::Argument<'_>; 1];
    let _18: [core::fmt::rt::Argument<'_>; 1];
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &rocket_http::Method;
    let mut _21: proc_macro2::Span;
    let mut _22: std::ops::Range<usize>;
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: &std::string::String;
    let mut _26: (usize, bool);
    let _28: &str;
    let _29: &std::string::String;
    let mut _30: proc_macro2::Span;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::ItemFn>;
    let mut _33: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _34: std::result::Result<syn::ItemFn, devise::Diagnostic>;
    let mut _35: std::result::Result<syn::ItemFn, syn::Error>;
    let mut _36: proc_macro2::TokenStream;
    let mut _37: {closure@core/codegen/src/attribute/route/mod.rs:394:18: 394:21};
    let mut _38: &std::string::String;
    let mut _39: isize;
    let _44: ();
    let _45: &proc_macro2::Ident;
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let mut _49: proc_macro2::Delimiter;
    let mut _50: proc_macro2::TokenStream;
    let _52: ();
    let _53: &proc_macro2::TokenStream;
    let mut _54: &mut proc_macro2::TokenStream;
    let mut _56: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::MethodAttribute>;
    let mut _57: std::result::Result<attribute::route::parse::MethodAttribute, devise::Diagnostic>;
    let _58: &devise::MetaItem;
    let _59: devise::MetaItem;
    let mut _60: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, devise::MetaItem>;
    let mut _61: std::result::Result<devise::MetaItem, syn::Error>;
    let mut _62: isize;
    let mut _65: isize;
    let mut _69: devise::SpanWrapped<http_codegen::Method>;
    let mut _70: std::option::Option<proc_macro2::Span>;
    let mut _71: http_codegen::Method;
    let mut _72: rocket_http::Method;
    let mut _73: attribute::route::parse::RouteUri;
    let mut _74: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>;
    let mut _75: std::option::Option<http_codegen::MediaType>;
    let mut _76: std::option::Option<isize>;
    let mut _77: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, attribute::route::parse::Route>;
    let mut _78: std::result::Result<attribute::route::parse::Route, devise::Diagnostic>;
    let mut _79: syn::ItemFn;
    let mut _80: isize;
    let mut _84: bool;
    let mut _85: bool;
    let mut _86: bool;
    let mut _87: bool;
    let mut _88: bool;
    let mut _89: bool;
    scope 1 {
        debug method_str => _4;
        let _9: proc_macro2::Span;
        let _13: std::string::String;
        let mut _83: &[&str; 2];
        scope 2 {
            debug method_span => _9;
            let _27: proc_macro2::Ident;
            scope 4 {
                debug method_ident => _27;
                let _31: syn::ItemFn;
                let _40: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                let _41: syn::ItemFn;
                scope 5 {
                    debug function => _31;
                    let _42: proc_macro2::TokenStream;
                    let mut _43: proc_macro2::TokenStream;
                    scope 10 {
                        debug full_attr => _42;
                        let _55: attribute::route::parse::MethodAttribute;
                        let _63: std::result::Result<std::convert::Infallible, syn::Error>;
                        let _64: devise::MetaItem;
                        let _66: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                        let _67: attribute::route::parse::MethodAttribute;
                        scope 13 {
                            debug method_attribute => _55;
                            let _68: attribute::route::parse::Attribute;
                            scope 22 {
                                debug attribute => _68;
                                let _81: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                                let _82: attribute::route::parse::Route;
                                scope 23 {
                                    debug residual => _81;
                                    scope 24 {
                                    }
                                }
                                scope 25 {
                                    debug val => _82;
                                    scope 26 {
                                    }
                                }
                            }
                        }
                        scope 14 {
                            debug residual => _63;
                            scope 15 {
                            }
                        }
                        scope 16 {
                            debug val => _64;
                            scope 17 {
                            }
                        }
                        scope 18 {
                            debug residual => _66;
                            scope 19 {
                            }
                        }
                        scope 20 {
                            debug val => _67;
                            scope 21 {
                            }
                        }
                    }
                    scope 11 {
                        debug _s => _43;
                        let mut _51: proc_macro2::TokenStream;
                        scope 12 {
                            debug _s => _51;
                        }
                    }
                }
                scope 6 {
                    debug residual => _40;
                    scope 7 {
                    }
                }
                scope 8 {
                    debug val => _41;
                    scope 9 {
                    }
                }
            }
        }
        scope 3 {
            debug res => _13;
        }
    }

    bb0: {
        _89 = const false;
        _88 = const false;
        _87 = const false;
        _86 = const false;
        _85 = const false;
        _84 = const false;
        _89 = const true;
        _8 = &_1;
        _7 = <rocket_http::Method as ToString>::to_string(move _8) -> [return: bb1, unwind: bb75];
    }

    bb1: {
        _6 = &_7;
        _5 = <std::string::String as std::ops::Deref>::deref(move _6) -> [return: bb2, unwind: bb59];
    }

    bb2: {
        _4 = str::<impl str>::to_lowercase(_5) -> [return: bb3, unwind: bb59];
    }

    bb3: {
        drop(_7) -> [return: bb4, unwind: bb58];
    }

    bb4: {
        _83 = const _;
        _15 = _83 as &[&str] (PointerCoercion(Unsize));
        _20 = &_1;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::Method>(_20) -> [return: bb5, unwind: bb58];
    }

    bb5: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = std::fmt::Arguments::<'_>::new_v1(move _15, move _16) -> [return: bb6, unwind: bb58];
    }

    bb6: {
        _13 = format(move _14) -> [return: bb7, unwind: bb58];
    }

    bb7: {
        _88 = const true;
        _12 = move _13;
        _21 = proc_macro2::Span::call_site() -> [return: bb8, unwind: bb73];
    }

    bb8: {
        _88 = const false;
        _11 = StringLit::new::<std::string::String>(move _12, move _21) -> [return: bb9, unwind: bb73];
    }

    bb9: {
        _10 = &_11;
        _88 = const false;
        _25 = &_4;
        _24 = std::string::String::len(move _25) -> [return: bb10, unwind: bb57];
    }

    bb10: {
        _26 = CheckedAdd(const 2_usize, _24);
        assert(!move (_26.1: bool), "attempt to compute `{} + {}`, which would overflow", const 2_usize, move _24) -> [success: bb11, unwind: bb57];
    }

    bb11: {
        _23 = move (_26.0: usize);
        _22 = std::ops::Range::<usize> { start: const 2_usize, end: move _23 };
        _9 = StringLit::subspan::<std::ops::Range<usize>>(move _10, move _22) -> [return: bb12, unwind: bb57];
    }

    bb12: {
        drop(_11) -> [return: bb13, unwind: bb58];
    }

    bb13: {
        _29 = &_4;
        _28 = <std::string::String as std::ops::Deref>::deref(_29) -> [return: bb14, unwind: bb58];
    }

    bb14: {
        _30 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(_9) -> [return: bb15, unwind: bb58];
    }

    bb15: {
        _27 = proc_macro2::Ident::new(_28, move _30) -> [return: bb16, unwind: bb58];
    }

    bb16: {
        _89 = const false;
        _36 = move _3;
        _35 = syn::parse2::<ItemFn>(move _36) -> [return: bb17, unwind: bb56];
    }

    bb17: {
        _34 = std::result::Result::<ItemFn, syn::Error>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/mod.rs:393:18: 393:21}>(move _35, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:393:18: 393:21}) -> [return: bb18, unwind: bb56];
    }

    bb18: {
        _38 = &_4;
        _37 = {closure@core/codegen/src/attribute/route/mod.rs:394:18: 394:21} { method_str: move _38 };
        _33 = std::result::Result::<ItemFn, devise::Diagnostic>::map_err::<devise::Diagnostic, {closure@core/codegen/src/attribute/route/mod.rs:394:18: 394:21}>(move _34, move _37) -> [return: bb19, unwind: bb56];
    }

    bb19: {
        _32 = <std::result::Result<ItemFn, devise::Diagnostic> as std::ops::Try>::branch(move _33) -> [return: bb20, unwind: bb56];
    }

    bb20: {
        _39 = discriminant(_32);
        switchInt(move _39) -> [0: bb21, 1: bb23, otherwise: bb22];
    }

    bb21: {
        _41 = move ((_32 as Continue).0: syn::ItemFn);
        _87 = const true;
        _31 = move _41;
        _43 = TokenStream2::new() -> [return: bb24, unwind: bb71];
    }

    bb22: {
        unreachable;
    }

    bb23: {
        _40 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _40) -> [return: bb76, unwind: bb56];
    }

    bb24: {
        _45 = &_27;
        _46 = &mut _43;
        _44 = <proc_macro2::Ident as ToTokens>::to_tokens(_45, _46) -> [return: bb25, unwind: bb55];
    }

    bb25: {
        _48 = &mut _43;
        _49 = proc_macro2::Delimiter::Parenthesis;
        _51 = TokenStream2::new() -> [return: bb26, unwind: bb55];
    }

    bb26: {
        _53 = &_2;
        _54 = &mut _51;
        _52 = <TokenStream2 as ToTokens>::to_tokens(_53, _54) -> [return: bb27, unwind: bb54];
    }

    bb27: {
        _50 = move _51;
        _47 = push_group(_48, move _49, move _50) -> [return: bb28, unwind: bb55];
    }

    bb28: {
        _42 = move _43;
        _61 = syn::parse2::<devise::MetaItem>(move _42) -> [return: bb29, unwind: bb71];
    }

    bb29: {
        _60 = <std::result::Result<devise::MetaItem, syn::Error> as std::ops::Try>::branch(move _61) -> [return: bb30, unwind: bb71];
    }

    bb30: {
        _62 = discriminant(_60);
        switchInt(move _62) -> [0: bb31, 1: bb32, otherwise: bb22];
    }

    bb31: {
        _64 = move ((_60 as Continue).0: devise::MetaItem);
        _59 = move _64;
        _58 = &_59;
        _57 = <MethodAttribute as devise::FromMeta>::from_meta(_58) -> [return: bb33, unwind: bb53];
    }

    bb32: {
        _63 = move ((_60 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _63) -> [return: bb77, unwind: bb71];
    }

    bb33: {
        _56 = <std::result::Result<MethodAttribute, devise::Diagnostic> as std::ops::Try>::branch(move _57) -> [return: bb34, unwind: bb53];
    }

    bb34: {
        _65 = discriminant(_56);
        switchInt(move _65) -> [0: bb35, 1: bb36, otherwise: bb22];
    }

    bb35: {
        _67 = move ((_56 as Continue).0: attribute::route::parse::MethodAttribute);
        _84 = const true;
        _85 = const true;
        _86 = const true;
        _55 = move _67;
        drop(_59) -> [return: bb62, unwind: bb69];
    }

    bb36: {
        _66 = move ((_56 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _66) -> [return: bb37, unwind: bb53];
    }

    bb37: {
        drop(_59) -> [return: bb63, unwind: bb71];
    }

    bb38: {
        _77 = <std::result::Result<route::parse::Route, devise::Diagnostic> as std::ops::Try>::branch(move _78) -> [return: bb39, unwind: bb69];
    }

    bb39: {
        _80 = discriminant(_77);
        switchInt(move _80) -> [0: bb40, 1: bb41, otherwise: bb22];
    }

    bb40: {
        _82 = move ((_77 as Continue).0: attribute::route::parse::Route);
        _0 = codegen_route(move _82) -> [return: bb43, unwind: bb51];
    }

    bb41: {
        _81 = move ((_77 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _81) -> [return: bb42, unwind: bb51];
    }

    bb42: {
        _84 = const false;
        _85 = const false;
        _86 = const false;
        _87 = const false;
        drop(_27) -> [return: bb46, unwind: bb52];
    }

    bb43: {
        _84 = const false;
        _85 = const false;
        _86 = const false;
        _87 = const false;
        drop(_27) -> [return: bb44, unwind: bb52];
    }

    bb44: {
        drop(_4) -> [return: bb45, unwind: bb75];
    }

    bb45: {
        drop(_2) -> [return: bb50, unwind continue];
    }

    bb46: {
        drop(_4) -> [return: bb49, unwind: bb75];
    }

    bb47: {
        _87 = const false;
        drop(_27) -> [return: bb48, unwind: bb58];
    }

    bb48: {
        drop(_4) -> [return: bb49, unwind: bb75];
    }

    bb49: {
        drop(_2) -> [return: bb50, unwind continue];
    }

    bb50: {
        return;
    }

    bb51 (cleanup): {
        drop(_27) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_4) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_59) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_51) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_43) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_27) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_11) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_4) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_7) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_2) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        resume;
    }

    bb62: {
        _70 = Option::<proc_macro2::Span>::None;
        _72 = _1;
        _71 = http_codegen::Method(move _72);
        _69 = devise::SpanWrapped::<http_codegen::Method> { span: _9, key_span: move _70, full_span: _9, value: move _71 };
        _86 = const false;
        _73 = move (_55.0: attribute::route::parse::RouteUri);
        _85 = const false;
        _74 = move (_55.1: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>);
        _84 = const false;
        _75 = move (_55.2: std::option::Option<http_codegen::MediaType>);
        _76 = (_55.3: std::option::Option<isize>);
        _68 = route::parse::Attribute { method: move _69, uri: move _73, data: move _74, format: move _75, rank: move _76 };
        _87 = const false;
        _79 = move _31;
        _78 = route::parse::Route::from(move _68, move _79) -> [return: bb38, unwind: bb69];
    }

    bb63: {
        _84 = const false;
        _85 = const false;
        _86 = const false;
        drop(_31) -> [return: bb47, unwind: bb56];
    }

    bb64 (cleanup): {
        switchInt(_84) -> [0: bb71, otherwise: bb65];
    }

    bb65 (cleanup): {
        drop((_55.2: std::option::Option<http_codegen::MediaType>)) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        switchInt(_85) -> [0: bb64, otherwise: bb67];
    }

    bb67 (cleanup): {
        drop((_55.1: std::option::Option<devise::SpanWrapped<attribute::param::Dynamic>>)) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop((_55.0: attribute::route::parse::RouteUri)) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        switchInt(_86) -> [0: bb66, otherwise: bb68];
    }

    bb70 (cleanup): {
        drop(_31) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        switchInt(_87) -> [0: bb56, otherwise: bb70];
    }

    bb72 (cleanup): {
        drop(_12) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        switchInt(_88) -> [0: bb58, otherwise: bb72];
    }

    bb74 (cleanup): {
        drop(_3) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        switchInt(_89) -> [0: bb60, otherwise: bb74];
    }

    bb76: {
        goto -> bb47;
    }

    bb77: {
        goto -> bb63;
    }
}

promoted[0] in incomplete_route: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "#[", const "]"];
        _0 = &_1;
        return;
    }
}

fn incomplete_route::{closure#0}(_1: {closure@core/codegen/src/attribute/route/mod.rs:393:18: 393:21}, _2: syn::Error) -> devise::Diagnostic {
    debug e => _2;
    let mut _0: devise::Diagnostic;

    bb0: {
        _0 = <devise::Diagnostic as From<syn::Error>>::from(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn incomplete_route::{closure#1}(_1: {closure@core/codegen/src/attribute/route/mod.rs:394:18: 394:21}, _2: devise::Diagnostic) -> devise::Diagnostic {
    debug d => _2;
    debug method_str => (*(_1.0: &std::string::String));
    let mut _0: devise::Diagnostic;
    let mut _3: devise::Diagnostic;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let mut _11: &[&str; 2];
    let mut _12: &std::string::String;
    let mut _13: bool;
    scope 1 {
        debug res => _4;
    }

    bb0: {
        _13 = const false;
        _13 = const true;
        _3 = move _2;
        _11 = const _;
        _6 = _11 as &[&str] (PointerCoercion(Unsize));
        _12 = deref_copy (_1.0: &std::string::String);
        _10 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_12) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _4 = format(move _5) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _13 = const false;
        _0 = devise::Diagnostic::help::<std::string::String>(move _3, move _4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _13 = const false;
        return;
    }

    bb5 (cleanup): {
        resume;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        switchInt(_13) -> [0: bb5, otherwise: bb6];
    }
}

promoted[0] in incomplete_route::{closure#1}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "#[", const "] can only be used on functions"];
        _0 = &_1;
        return;
    }
}

fn route_attribute(_1: M, _2: proc_macro::TokenStream, _3: proc_macro::TokenStream) -> TokenStream2 {
    debug method => _1;
    debug args => _2;
    debug input => _3;
    let mut _0: proc_macro2::TokenStream;
    let _4: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _5: std::option::Option<rocket_http::Method>;
    let mut _6: isize;
    let _7: rocket_http::Method;
    let mut _8: proc_macro2::TokenStream;
    let mut _9: proc_macro::TokenStream;
    let mut _10: proc_macro2::TokenStream;
    let mut _11: proc_macro::TokenStream;
    let mut _12: proc_macro2::TokenStream;
    let mut _13: proc_macro::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: proc_macro::TokenStream;
    let mut _16: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: bool;
    scope 1 {
        debug result => _4;
    }
    scope 2 {
        debug method => _7;
    }

    bb0: {
        _20 = const false;
        _19 = const false;
        _18 = const false;
        _17 = const false;
        _20 = const true;
        _19 = const true;
        _5 = <M as Into<Option<rocket_http::Method>>>::into(move _1) -> [return: bb1, unwind: bb20];
    }

    bb1: {
        _6 = discriminant(_5);
        switchInt(move _6) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _20 = const false;
        _13 = move _2;
        _12 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _13) -> [return: bb8, unwind: bb20];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _7 = ((_5 as Some).0: rocket_http::Method);
        _20 = const false;
        _9 = move _2;
        _8 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _9) -> [return: bb5, unwind: bb20];
    }

    bb5: {
        _18 = const true;
        _19 = const false;
        _11 = move _3;
        _10 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _11) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        _18 = const false;
        _4 = incomplete_route(_7, move _8, move _10) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _18 = const false;
        goto -> bb11;
    }

    bb8: {
        _17 = const true;
        _19 = const false;
        _15 = move _3;
        _14 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _15) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _17 = const false;
        _4 = complete_route(move _12, move _14) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _17 = const false;
        goto -> bb11;
    }

    bb11: {
        _16 = move _4;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/attribute/route/mod.rs:422:27: 422:33}>(move _16, const ZeroSized: {closure@core/codegen/src/attribute/route/mod.rs:422:27: 422:33}) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        switchInt(_20) -> [0: bb14, otherwise: bb21];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15 (cleanup): {
        drop(_12) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        switchInt(_17) -> [0: bb20, otherwise: bb15];
    }

    bb17 (cleanup): {
        drop(_8) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_18) -> [0: bb20, otherwise: bb17];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        switchInt(_19) -> [0: bb13, otherwise: bb19];
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }
}

fn route_attribute::{closure#0}(_1: {closure@core/codegen/src/attribute/route/mod.rs:422:27: 422:33}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:10:10: 10:15>::fmt(_1: &param::parse::Error<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&str;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &proc_macro2::Span;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&str;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &proc_macro2::Span;
    let _16: &str;
    let mut _17: &dyn std::fmt::Debug;
    let _18: &&attribute::param::parse::ErrorKind;
    let _19: &attribute::param::parse::ErrorKind;

    bb0: {
        _3 = const "Error";
        _4 = const "segment";
        _6 = &((*_1).0: &str);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "span";
        _9 = &((*_1).1: proc_macro2::Span);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "source";
        _12 = &((*_1).2: &str);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "source_span";
        _15 = &((*_1).3: proc_macro2::Span);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _16 = const "kind";
        _19 = &((*_1).4: attribute::param::parse::ErrorKind);
        _18 = &_19;
        _17 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field5_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14, _16, move _17) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:19:10: 19:15>::fmt(_1: &param::parse::ErrorKind, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb1, otherwise: bb2];
    }

    bb1: {
        _10 = const "Static";
        _3 = _10;
        goto -> bb8;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Empty";
        _3 = _5;
        goto -> bb8;
    }

    bb4: {
        _6 = const "BadIdent";
        _3 = _6;
        goto -> bb8;
    }

    bb5: {
        _7 = const "Ignored";
        _3 = _7;
        goto -> bb8;
    }

    bb6: {
        _8 = const "EarlyTrailing";
        _3 = _8;
        goto -> bb8;
    }

    bb7: {
        _9 = const "NoTrailing";
        _3 = _9;
        goto -> bb8;
    }

    bb8: {
        _0 = std::fmt::Formatter::<'_>::write_str(_2, move _3) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:19:17: 19:26>::eq(_1: &param::parse::ErrorKind, _2: &param::parse::ErrorKind) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:19:28: 19:30>::assert_receiver_is_total_eq(_1: &param::parse::ErrorKind) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:19:38: 19:43>::clone(_1: &param::parse::ErrorKind) -> param::parse::ErrorKind {
    debug self => _1;
    let mut _0: attribute::param::parse::ErrorKind;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:29:1: 29:13>::parse(_1: &str, _2: proc_macro2::Span) -> std::result::Result<param::Dynamic, param::parse::Error<'_>> {
    debug segment => _1;
    debug span => _2;
    let mut _0: std::result::Result<attribute::param::Dynamic, attribute::param::parse::Error<'_>>;
    let mut _3: attribute::param::Parameter;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>, attribute::param::Parameter>;
    let mut _5: std::result::Result<attribute::param::Parameter, attribute::param::parse::Error<'_>>;
    let _6: &&str;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>;
    let _9: attribute::param::Parameter;
    let mut _10: isize;
    let _11: attribute::param::Dynamic;
    let mut _12: attribute::param::Dynamic;
    let _13: attribute::param::Guard;
    let mut _14: attribute::param::Dynamic;
    let mut _15: attribute::param::parse::Error<'_>;
    let mut _16: &str;
    let mut _17: attribute::param::parse::ErrorKind;
    let mut _18: &str;
    let mut _19: isize;
    let mut _20: isize;
    scope 1 {
        debug residual => _8;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _9;
        scope 4 {
        }
    }
    scope 5 {
        debug d => _11;
    }
    scope 6 {
        debug g => _13;
    }

    bb0: {
        _6 = &_1;
        _18 = deref_copy (*_6);
        _5 = param::parse::<impl Parameter>::parse::<P>(_18, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <std::result::Result<Parameter, param::parse::Error<'_>> as std::ops::Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = move ((_4 as Continue).0: attribute::param::Parameter);
        _3 = move _9;
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb6, 1: bb9, 2: bb8, 3: bb10, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>);
        _0 = <std::result::Result<param::Dynamic, param::parse::Error<'_>> as FromResidual<std::result::Result<Infallible, param::parse::Error<'_>>>>::from_residual(move _8) -> [return: bb12, unwind continue];
    }

    bb6: {
        _16 = _1;
        _17 = param::parse::ErrorKind::Static;
        _15 = param::parse::Error::<'_>::new(move _16, _2, move _17) -> [return: bb11, unwind: bb19];
    }

    bb7: {
        _12 = move _11;
        _0 = std::result::Result::<param::Dynamic, param::parse::Error<'_>>::Ok(move _12);
        goto -> bb17;
    }

    bb8: {
        _11 = move ((_3 as Dynamic).0: attribute::param::Dynamic);
        goto -> bb7;
    }

    bb9: {
        _11 = move ((_3 as Ignored).0: attribute::param::Dynamic);
        goto -> bb7;
    }

    bb10: {
        _13 = move ((_3 as Guard).0: attribute::param::Guard);
        _14 = move (_13.0: attribute::param::Dynamic);
        _0 = std::result::Result::<param::Dynamic, param::parse::Error<'_>>::Ok(move _14);
        drop((_13.1: proc_macro2::Ident)) -> [return: bb15, unwind: bb14];
    }

    bb11: {
        _0 = std::result::Result::<param::Dynamic, param::parse::Error<'_>>::Err(move _15);
        goto -> bb17;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        resume;
    }

    bb14 (cleanup): {
        drop((_13.2: syn::Type)) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15: {
        drop((_13.2: syn::Type)) -> [return: bb17, unwind: bb19];
    }

    bb16: {
        drop(_3) -> [return: bb12, unwind continue];
    }

    bb17: {
        _19 = discriminant(_3);
        switchInt(move _19) -> [1: bb12, 2: bb12, 3: bb12, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        _20 = discriminant(_3);
        switchInt(move _20) -> [1: bb13, 2: bb13, 3: bb13, otherwise: bb18];
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse(_1: &str, _2: proc_macro2::Span) -> std::result::Result<Parameter, param::parse::Error<'_>> {
    debug segment => _1;
    debug source_span => _2;
    let mut _0: std::result::Result<attribute::param::Parameter, attribute::param::parse::Error<'_>>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let _7: &str;
    let mut _8: std::ops::Range<usize>;
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: (usize, bool);
    let mut _12: bool;
    let mut _13: &str;
    let _14: &str;
    let mut _15: &str;
    let mut _16: std::ops::RangeTo<usize>;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: &str;
    let mut _20: (usize, bool);
    let mut _22: &str;
    let mut _23: bool;
    let mut _24: &str;
    let mut _25: attribute::param::parse::Error<'_>;
    let mut _26: &str;
    let mut _27: attribute::param::parse::ErrorKind;
    let mut _28: bool;
    let mut _29: &str;
    let mut _30: attribute::param::parse::Error<'_>;
    let mut _31: &str;
    let mut _32: attribute::param::parse::ErrorKind;
    let mut _34: name::Name;
    let mut _35: &str;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: &attribute::param::Dynamic;
    let mut _39: bool;
    let mut _40: attribute::param::parse::Error<'_>;
    let mut _41: &str;
    let mut _42: attribute::param::parse::ErrorKind;
    let mut _43: bool;
    let mut _44: &attribute::param::Dynamic;
    let mut _45: attribute::param::Parameter;
    let mut _46: attribute::param::Dynamic;
    let mut _47: attribute::param::Parameter;
    let mut _48: attribute::param::Dynamic;
    let mut _49: bool;
    let mut _50: attribute::param::parse::Error<'_>;
    let mut _51: attribute::param::parse::ErrorKind;
    let mut _52: bool;
    let _54: proc_macro2::TokenStream;
    let mut _55: devise::Diagnostic;
    let mut _56: devise::Diagnostic;
    let mut _58: std::fmt::Arguments<'_>;
    let mut _59: &[&str];
    let mut _60: &[core::fmt::rt::Argument<'_>];
    let _61: &[core::fmt::rt::Argument<'_>; 1];
    let _62: [core::fmt::rt::Argument<'_>; 1];
    let mut _63: core::fmt::rt::Argument<'_>;
    let _64: &std::string::String;
    let mut _65: bool;
    let mut _66: bool;
    let _67: proc_macro2::TokenStream;
    let mut _68: devise::Diagnostic;
    let mut _69: attribute::param::Parameter;
    let mut _70: name::Name;
    let mut _74: bool;
    let mut _75: bool;
    scope 1 {
        debug trailing => _3;
        let mut _6: &str;
        let _53: std::string::String;
        scope 2 {
            debug name => _6;
            let _21: proc_macro2::Span;
            scope 3 {
                debug span => _21;
                let _33: attribute::param::Dynamic;
                scope 4 {
                    debug dynamic => _33;
                    let mut _71: &rocket_http::uri::fmt::Kind;
                    let mut _72: &rocket_http::uri::fmt::Kind;
                }
            }
        }
        scope 5 {
            debug candidate => _53;
            let _57: std::string::String;
            let mut _73: &[&str; 2];
            scope 6 {
                debug res => _57;
            }
        }
    }

    bb0: {
        _74 = const false;
        _75 = const false;
        _3 = const false;
        _4 = core::str::<impl str>::starts_with::<'_, char>(_1, const '<') -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb33, otherwise: bb2];
    }

    bb2: {
        _5 = core::str::<impl str>::ends_with::<'_, char>(_1, const '>') -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb33, otherwise: bb4];
    }

    bb4: {
        _10 = core::str::<impl str>::len(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _11 = CheckedSub(_10, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} - {}`, which would overflow", move _10, const 1_usize) -> [success: bb6, unwind continue];
    }

    bb6: {
        _9 = move (_11.0: usize);
        _8 = std::ops::Range::<usize> { start: const 1_usize, end: move _9 };
        _7 = <str as std::ops::Index<std::ops::Range<usize>>>::index(_1, move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = _7;
        _13 = _6;
        _12 = core::str::<impl str>::ends_with::<'_, &str>(move _13, const "..") -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _12) -> [0: bb13, otherwise: bb9];
    }

    bb9: {
        _3 = const true;
        _15 = _6;
        _19 = _6;
        _18 = core::str::<impl str>::len(move _19) -> [return: bb10, unwind continue];
    }

    bb10: {
        _20 = CheckedSub(_18, const 2_usize);
        assert(!move (_20.1: bool), "attempt to compute `{} - {}`, which would overflow", move _18, const 2_usize) -> [success: bb11, unwind continue];
    }

    bb11: {
        _17 = move (_20.0: usize);
        _16 = RangeTo::<usize> { end: move _17 };
        _14 = <str as std::ops::Index<RangeTo<usize>>>::index(move _15, move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _6 = _14;
        goto -> bb13;
    }

    bb13: {
        _22 = _6;
        _21 = param::parse::subspan(move _22, _1, _2) -> [return: bb14, unwind continue];
    }

    bb14: {
        _24 = _6;
        _23 = core::str::<impl str>::is_empty(move _24) -> [return: bb15, unwind continue];
    }

    bb15: {
        switchInt(move _23) -> [0: bb18, otherwise: bb16];
    }

    bb16: {
        _26 = _6;
        _27 = param::parse::ErrorKind::Empty;
        _25 = param::parse::Error::<'_>::new(move _26, _2, move _27) -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Err(move _25);
        goto -> bb59;
    }

    bb18: {
        _29 = _6;
        _28 = is_valid_ident(move _29) -> [return: bb19, unwind continue];
    }

    bb19: {
        switchInt(move _28) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _35 = _6;
        _34 = name::Name::new::<&str>(move _35, _21) -> [return: bb23, unwind continue];
    }

    bb21: {
        _31 = _6;
        _32 = param::parse::ErrorKind::BadIdent;
        _30 = param::parse::Error::<'_>::new(move _31, _21, move _32) -> [return: bb22, unwind continue];
    }

    bb22: {
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Err(move _30);
        goto -> bb59;
    }

    bb23: {
        _36 = _3;
        _74 = const true;
        _33 = param::Dynamic { name: move _34, index: const 0_usize, trailing: move _36 };
        _38 = &_33;
        _37 = param::Dynamic::is_wild(move _38) -> [return: bb24, unwind: bb61];
    }

    bb24: {
        switchInt(move _37) -> [0: bb29, otherwise: bb25];
    }

    bb25: {
        _72 = const _;
        _71 = const _;
        _39 = <Kind as PartialEq>::ne(_72, _71) -> [return: bb26, unwind: bb61];
    }

    bb26: {
        switchInt(move _39) -> [0: bb29, otherwise: bb27];
    }

    bb27: {
        _41 = _6;
        _42 = param::parse::ErrorKind::Ignored;
        _40 = param::parse::Error::<'_>::new(move _41, _21, move _42) -> [return: bb28, unwind: bb61];
    }

    bb28: {
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Err(move _40);
        goto -> bb57;
    }

    bb29: {
        _44 = &_33;
        _43 = param::Dynamic::is_wild(move _44) -> [return: bb30, unwind: bb61];
    }

    bb30: {
        switchInt(move _43) -> [0: bb32, otherwise: bb31];
    }

    bb31: {
        _74 = const false;
        _46 = move _33;
        _45 = Parameter::Ignored(move _46);
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Ok(move _45);
        goto -> bb57;
    }

    bb32: {
        _74 = const false;
        _48 = move _33;
        _47 = Parameter::Dynamic(move _48);
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Ok(move _47);
        goto -> bb57;
    }

    bb33: {
        _49 = core::str::<impl str>::is_empty(_1) -> [return: bb34, unwind continue];
    }

    bb34: {
        switchInt(move _49) -> [0: bb37, otherwise: bb35];
    }

    bb35: {
        _51 = param::parse::ErrorKind::Empty;
        _50 = param::parse::Error::<'_>::new(_1, _2, move _51) -> [return: bb36, unwind continue];
    }

    bb36: {
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Err(move _50);
        goto -> bb59;
    }

    bb37: {
        _52 = core::str::<impl str>::starts_with::<'_, char>(_1, const '<') -> [return: bb38, unwind continue];
    }

    bb38: {
        switchInt(move _52) -> [0: bb48, otherwise: bb39];
    }

    bb39: {
        _53 = candidate_from_malformed(_1) -> [return: bb40, unwind continue];
    }

    bb40: {
        _56 = <proc_macro2::Span as SpanDiagnosticExt>::warning::<&str>(_2, const "`segment` starts with `<` but does not end with `>`") -> [return: bb41, unwind: bb60];
    }

    bb41: {
        _75 = const true;
        _73 = const _;
        _59 = _73 as &[&str] (PointerCoercion(Unsize));
        _64 = &_53;
        _63 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_64) -> [return: bb42, unwind: bb65];
    }

    bb42: {
        _62 = [move _63];
        _61 = &_62;
        _60 = _61 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _58 = std::fmt::Arguments::<'_>::new_v1(move _59, move _60) -> [return: bb43, unwind: bb65];
    }

    bb43: {
        _57 = format(move _58) -> [return: bb44, unwind: bb65];
    }

    bb44: {
        _75 = const false;
        _55 = devise::Diagnostic::help::<std::string::String>(move _56, move _57) -> [return: bb45, unwind: bb65];
    }

    bb45: {
        _75 = const false;
        _54 = devise::Diagnostic::emit_as_item_tokens(move _55) -> [return: bb46, unwind: bb60];
    }

    bb46: {
        drop(_54) -> [return: bb47, unwind: bb60];
    }

    bb47: {
        drop(_53) -> [return: bb55, unwind continue];
    }

    bb48: {
        _65 = core::str::<impl str>::contains::<'_, char>(_1, const '>') -> [return: bb49, unwind continue];
    }

    bb49: {
        switchInt(move _65) -> [0: bb50, otherwise: bb52];
    }

    bb50: {
        _66 = core::str::<impl str>::contains::<'_, char>(_1, const '<') -> [return: bb51, unwind continue];
    }

    bb51: {
        switchInt(move _66) -> [0: bb55, otherwise: bb52];
    }

    bb52: {
        _68 = <proc_macro2::Span as SpanDiagnosticExt>::warning::<&str>(_2, const "`segment` contains `<` or `>` but is not a dynamic parameter") -> [return: bb53, unwind continue];
    }

    bb53: {
        _67 = devise::Diagnostic::emit_as_item_tokens(move _68) -> [return: bb54, unwind continue];
    }

    bb54: {
        drop(_67) -> [return: bb55, unwind continue];
    }

    bb55: {
        _70 = name::Name::new::<&str>(_1, _2) -> [return: bb56, unwind continue];
    }

    bb56: {
        _69 = Parameter::Static(move _70);
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Ok(move _69);
        goto -> bb59;
    }

    bb57: {
        switchInt(_74) -> [0: bb58, otherwise: bb63];
    }

    bb58: {
        _74 = const false;
        goto -> bb59;
    }

    bb59: {
        return;
    }

    bb60 (cleanup): {
        drop(_53) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_33) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        resume;
    }

    bb63: {
        drop(_33) -> [return: bb58, unwind continue];
    }

    bb64 (cleanup): {
        drop(_56) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        switchInt(_75) -> [0: bb60, otherwise: bb64];
    }
}

promoted[0] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse: &Kind = {
    let mut _0: &rocket_http::uri::fmt::Kind;
    let mut _1: rocket_http::uri::fmt::Kind;

    bb0: {
        _1 = rocket_http::uri::fmt::Kind::Path;
        _0 = &_1;
        return;
    }
}

promoted[1] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse: &Kind = {
    let mut _0: &rocket_http::uri::fmt::Kind;
    let mut _1: rocket_http::uri::fmt::Kind;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "perhaps you meant the dynamic parameter `<", const ">`?"];
        _0 = &_1;
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse_many(_1: &str, _2: proc_macro2::Span) -> Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}> {
    debug source => _1;
    debug source_span => _2;
    let mut _0: std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>;
    let mut _3: std::option::Option<(&str, proc_macro2::Span)>;
    let mut _4: std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>;
    let mut _5: std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>;
    let mut _6: std::str::Split<'_, char>;
    let mut _7: {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37};
    scope 1 {
        debug trailing => _3;
    }

    bb0: {
        _3 = Option::<(&str, proc_macro2::Span)>::None;
        _6 = core::str::<impl str>::split::<'_, char>(_1, const _) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = <std::str::Split<'_, char> as Iterator>::filter::<{closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>(move _6, const ZeroSized: {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}> as Iterator>::enumerate(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37} { trailing: _3, source: _1, source_span: _2 };
        _0 = <Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>> as Iterator>::map::<std::result::Result<Parameter, param::parse::Error<'_>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>(move _4, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse_many::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}, _2: &&str) -> bool {
    debug s => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &str;

    bb0: {
        _4 = deref_copy (*_2);
        _3 = core::str::<impl str>::is_empty(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse_many::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}, _2: (usize, &str)) -> std::result::Result<Parameter, param::parse::Error<'_>> {
    debug trailing => ((*_1).0: std::option::Option<(&str, proc_macro2::Span)>);
    debug source => ((*_1).1: &str);
    debug source_span => ((*_1).2: proc_macro2::Span);
    let mut _0: std::result::Result<attribute::param::Parameter, attribute::param::parse::Error<'_>>;
    let _3: usize;
    let _4: &str;
    let mut _5: isize;
    let mut _9: attribute::param::parse::Error<'_>;
    let mut _10: attribute::param::parse::ErrorKind;
    let mut _11: proc_macro2::Span;
    let mut _13: proc_macro2::Span;
    let mut _15: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>, attribute::param::Parameter>;
    let mut _16: std::result::Result<attribute::param::Parameter, attribute::param::parse::Error<'_>>;
    let mut _17: std::result::Result<attribute::param::Parameter, attribute::param::parse::Error<'_>>;
    let mut _18: {closure@core/codegen/src/attribute/param/parse.rs:107:30: 107:33};
    let mut _19: &&str;
    let mut _20: &proc_macro2::Span;
    let mut _21: isize;
    let mut _24: std::option::Option<&mut attribute::param::Dynamic>;
    let mut _25: &mut attribute::param::Parameter;
    let mut _26: isize;
    let mut _28: bool;
    let mut _29: std::option::Option<(&str, proc_macro2::Span)>;
    let mut _30: (&str, proc_macro2::Span);
    let mut _31: attribute::param::Parameter;
    let mut _32: &str;
    let mut _33: &str;
    let mut _34: &mut attribute::param::Dynamic;
    let mut _35: &mut attribute::param::Dynamic;
    scope 1 {
        debug i => _3;
        debug segment => _4;
        let _12: proc_macro2::Span;
        scope 2 {
            debug trail => _6;
            debug span => _7;
            let _6: &str;
            let _7: proc_macro2::Span;
            let _8: attribute::param::parse::Error<'_>;
            scope 3 {
                debug error => _8;
            }
        }
        scope 4 {
            debug segment_span => _12;
            let mut _14: attribute::param::Parameter;
            let _22: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>;
            let _23: attribute::param::Parameter;
            scope 5 {
                debug parsed => _14;
                scope 10 {
                    debug d => _27;
                    let _27: &mut &mut attribute::param::Dynamic;
                }
            }
            scope 6 {
                debug residual => _22;
                scope 7 {
                }
            }
            scope 8 {
                debug val => _23;
                scope 9 {
                }
            }
        }
    }

    bb0: {
        _3 = (_2.0: usize);
        _4 = (_2.1: &str);
        _5 = discriminant(((*_1).0: std::option::Option<(&str, proc_macro2::Span)>));
        switchInt(move _5) -> [1: bb1, otherwise: bb4];
    }

    bb1: {
        _6 = (((((*_1).0: std::option::Option<(&str, proc_macro2::Span)>) as Some).0: (&str, proc_macro2::Span)).0: &str);
        _7 = (((((*_1).0: std::option::Option<(&str, proc_macro2::Span)>) as Some).0: (&str, proc_macro2::Span)).1: proc_macro2::Span);
        _10 = param::parse::ErrorKind::EarlyTrailing;
        _9 = param::parse::Error::<'_>::new(_6, _7, move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _32 = deref_copy ((*_1).1: &str);
        _11 = ((*_1).2: proc_macro2::Span);
        _8 = param::parse::Error::<'_>::source(move _9, _32, move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Err(move _8);
        goto -> bb17;
    }

    bb4: {
        _33 = deref_copy ((*_1).1: &str);
        _13 = ((*_1).2: proc_macro2::Span);
        _12 = param::parse::subspan(_4, _33, move _13) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = param::parse::<impl Parameter>::parse::<P>(_4, _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _19 = &((*_1).1: &str);
        _20 = &((*_1).2: proc_macro2::Span);
        _18 = {closure@core/codegen/src/attribute/param/parse.rs:107:30: 107:33} { source: move _19, source_span: move _20 };
        _16 = std::result::Result::<Parameter, param::parse::Error<'_>>::map_err::<param::parse::Error<'_>, {closure@core/codegen/src/attribute/param/parse.rs:107:30: 107:33}>(move _17, move _18) -> [return: bb7, unwind continue];
    }

    bb7: {
        _15 = <std::result::Result<Parameter, param::parse::Error<'_>> as std::ops::Try>::branch(move _16) -> [return: bb8, unwind continue];
    }

    bb8: {
        _21 = discriminant(_15);
        switchInt(move _21) -> [0: bb9, 1: bb11, otherwise: bb10];
    }

    bb9: {
        _23 = move ((_15 as Continue).0: attribute::param::Parameter);
        _14 = move _23;
        _25 = &mut _14;
        _24 = Parameter::dynamic_mut(move _25) -> [return: bb12, unwind: bb18];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _22 = move ((_15 as Break).0: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>);
        _0 = <std::result::Result<Parameter, param::parse::Error<'_>> as FromResidual<std::result::Result<Infallible, param::parse::Error<'_>>>>::from_residual(move _22) -> [return: bb17, unwind continue];
    }

    bb12: {
        _26 = discriminant(_24);
        switchInt(move _26) -> [1: bb13, otherwise: bb16];
    }

    bb13: {
        _27 = &mut ((_24 as Some).0: &mut attribute::param::Dynamic);
        _34 = deref_copy (*_27);
        _28 = ((*_34).2: bool);
        switchInt(move _28) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _30 = (_4, _12);
        _29 = Option::<(&str, proc_macro2::Span)>::Some(move _30);
        ((*_1).0: std::option::Option<(&str, proc_macro2::Span)>) = move _29;
        goto -> bb15;
    }

    bb15: {
        _35 = deref_copy (*_27);
        ((*_35).1: usize) = _3;
        goto -> bb16;
    }

    bb16: {
        _31 = move _14;
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::Ok(move _31);
        goto -> bb17;
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_14) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:42:1: 42:15>::parse_many::{closure#1}::{closure#0}(_1: {closure@core/codegen/src/attribute/param/parse.rs:107:30: 107:33}, _2: param::parse::Error<'_>) -> param::parse::Error<'_> {
    debug e => _2;
    debug source => (*(_1.0: &&str));
    debug source_span => (*(_1.1: &proc_macro2::Span));
    let mut _0: attribute::param::parse::Error<'_>;
    let mut _3: proc_macro2::Span;
    let mut _4: &&str;
    let mut _5: &str;
    let mut _6: &proc_macro2::Span;

    bb0: {
        _4 = deref_copy (_1.0: &&str);
        _5 = deref_copy (*_4);
        _6 = deref_copy (_1.1: &proc_macro2::Span);
        _3 = (*_6);
        _0 = param::parse::Error::<'_>::source(move _2, _5, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:122:1: 122:37>::fmt(_1: &param::parse::ErrorKind, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb7, 4: bb6, 5: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = const "unexpected static parameter";
        _0 = <str as std::fmt::Display>::fmt(_9, _2) -> [return: bb8, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "parameters cannot be empty";
        _0 = <str as std::fmt::Display>::fmt(_4, _2) -> [return: bb8, unwind continue];
    }

    bb4: {
        _5 = const "invalid identifier";
        _0 = <str as std::fmt::Display>::fmt(_5, _2) -> [return: bb8, unwind continue];
    }

    bb5: {
        _6 = const "parameter must be named";
        _0 = <str as std::fmt::Display>::fmt(_6, _2) -> [return: bb8, unwind continue];
    }

    bb6: {
        _7 = const "parameter cannot be trailing";
        _0 = <str as std::fmt::Display>::fmt(_7, _2) -> [return: bb8, unwind continue];
    }

    bb7: {
        _8 = const "unexpected text after trailing parameter";
        _0 = <str as std::fmt::Display>::fmt(_8, _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:135:1: 135:19>::new(_1: &str, _2: proc_macro2::Span, _3: param::parse::ErrorKind) -> param::parse::Error<'_> {
    debug segment => _1;
    debug span => _2;
    debug kind => _3;
    let mut _0: attribute::param::parse::Error<'_>;

    bb0: {
        _0 = param::parse::Error::<'_> { segment: _1, span: _2, source: _1, source_span: _2, kind: _3 };
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:135:1: 135:19>::source(_1: param::parse::Error<'_>, _2: &str, _3: proc_macro2::Span) -> param::parse::Error<'_> {
    debug self => _1;
    debug source => _2;
    debug span => _3;
    let mut _0: attribute::param::parse::Error<'_>;

    bb0: {
        (_1.2: &str) = _2;
        (_1.3: proc_macro2::Span) = _3;
        _0 = move _1;
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:147:1: 147:36>::from(_1: param::parse::Error<'_>) -> devise::Diagnostic {
    debug error => _1;
    let mut _0: devise::Diagnostic;
    let mut _2: isize;
    let mut _3: proc_macro2::Span;
    let mut _4: std::string::String;
    let mut _5: &attribute::param::parse::ErrorKind;
    let _6: std::string::String;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 2];
    let _15: [core::fmt::rt::Argument<'_>; 2];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &attribute::param::parse::ErrorKind;
    let mut _18: core::fmt::rt::Argument<'_>;
    let _19: &&str;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &std::string::String;
    let mut _28: devise::Diagnostic;
    let mut _29: proc_macro2::Span;
    let mut _30: std::string::String;
    let mut _31: &attribute::param::parse::ErrorKind;
    let mut _32: devise::Diagnostic;
    let mut _33: devise::Diagnostic;
    let mut _34: proc_macro2::Span;
    let mut _35: proc_macro2::Span;
    let mut _36: std::string::String;
    let mut _37: &attribute::param::parse::ErrorKind;
    let mut _38: proc_macro2::Span;
    let _39: std::string::String;
    let mut _40: devise::Diagnostic;
    let mut _41: proc_macro2::Span;
    let mut _42: std::string::String;
    let mut _43: &attribute::param::parse::ErrorKind;
    let mut _45: std::fmt::Arguments<'_>;
    let mut _46: &[&str];
    let mut _47: &[core::fmt::rt::Argument<'_>];
    let _48: &[core::fmt::rt::Argument<'_>; 1];
    let _49: [core::fmt::rt::Argument<'_>; 1];
    let mut _50: core::fmt::rt::Argument<'_>;
    let _51: &std::string::String;
    let _52: std::string::String;
    let mut _53: devise::Diagnostic;
    let mut _54: proc_macro2::Span;
    let mut _55: std::string::String;
    let mut _56: &attribute::param::parse::ErrorKind;
    let mut _58: std::fmt::Arguments<'_>;
    let mut _59: &[&str];
    let mut _60: &[core::fmt::rt::Argument<'_>];
    let _61: &[core::fmt::rt::Argument<'_>; 1];
    let _62: [core::fmt::rt::Argument<'_>; 1];
    let mut _63: core::fmt::rt::Argument<'_>;
    let _64: &std::string::String;
    let mut _69: &str;
    let mut _70: &str;
    let mut _71: &str;
    let mut _72: &str;
    let mut _73: &str;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: bool;
    scope 1 {
        debug candidate => _6;
        let _10: std::string::String;
        let _20: std::string::String;
        let mut _67: &[&str; 2];
        let mut _68: &[&str; 3];
        scope 2 {
            debug res => _10;
        }
        scope 3 {
            debug res => _20;
        }
    }
    scope 4 {
        debug candidate => _39;
        let _44: std::string::String;
        let mut _66: &[&str; 2];
        scope 5 {
            debug res => _44;
        }
    }
    scope 6 {
        debug candidate => _52;
        let _57: std::string::String;
        let mut _65: &[&str; 2];
        scope 7 {
            debug res => _57;
        }
    }

    bb0: {
        _76 = const false;
        _75 = const false;
        _74 = const false;
        _2 = discriminant((_1.4: attribute::param::parse::ErrorKind));
        switchInt(move _2) -> [0: bb3, 1: bb5, 2: bb17, 3: bb20, 4: bb25, 5: bb1, otherwise: bb2];
    }

    bb1: {
        _69 = deref_copy (_1.0: &str);
        _52 = candidate_from_malformed(_69) -> [return: bb33, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = (_1.1: proc_macro2::Span);
        _5 = &(_1.4: attribute::param::parse::ErrorKind);
        _4 = <param::parse::ErrorKind as ToString>::to_string(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _3, move _4) -> [return: bb40, unwind continue];
    }

    bb5: {
        _70 = deref_copy (_1.0: &str);
        _6 = candidate_from_malformed(_70) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = (_1.1: proc_macro2::Span);
        _68 = const _;
        _12 = _68 as &[&str] (PointerCoercion(Unsize));
        _17 = &(_1.4: attribute::param::parse::ErrorKind);
        _16 = core::fmt::rt::Argument::<'_>::new_display::<param::parse::ErrorKind>(_17) -> [return: bb7, unwind: bb43];
    }

    bb7: {
        _19 = &(_1.0: &str);
        _18 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_19) -> [return: bb8, unwind: bb43];
    }

    bb8: {
        _15 = [move _16, move _18];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _11 = std::fmt::Arguments::<'_>::new_v1(move _12, move _13) -> [return: bb9, unwind: bb43];
    }

    bb9: {
        _10 = format(move _11) -> [return: bb10, unwind: bb43];
    }

    bb10: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _9, move _10) -> [return: bb11, unwind: bb43];
    }

    bb11: {
        _7 = devise::Diagnostic::help::<&str>(move _8, const "dynamic parameters must be valid identifiers") -> [return: bb12, unwind: bb43];
    }

    bb12: {
        _76 = const true;
        _67 = const _;
        _22 = _67 as &[&str] (PointerCoercion(Unsize));
        _27 = &_6;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_27) -> [return: bb13, unwind: bb50];
    }

    bb13: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = std::fmt::Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb14, unwind: bb50];
    }

    bb14: {
        _20 = format(move _21) -> [return: bb15, unwind: bb50];
    }

    bb15: {
        _76 = const false;
        _0 = devise::Diagnostic::help::<std::string::String>(move _7, move _20) -> [return: bb16, unwind: bb50];
    }

    bb16: {
        _76 = const false;
        drop(_6) -> [return: bb40, unwind continue];
    }

    bb17: {
        _29 = (_1.1: proc_macro2::Span);
        _31 = &(_1.4: attribute::param::parse::ErrorKind);
        _30 = <param::parse::ErrorKind as ToString>::to_string(move _31) -> [return: bb18, unwind continue];
    }

    bb18: {
        _28 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _29, move _30) -> [return: bb19, unwind continue];
    }

    bb19: {
        _0 = devise::Diagnostic::help::<&str>(move _28, const "use a name such as `_guard` or `_param`") -> [return: bb40, unwind continue];
    }

    bb20: {
        _71 = deref_copy (_1.0: &str);
        _72 = deref_copy (_1.2: &str);
        _35 = (_1.3: proc_macro2::Span);
        _34 = trailspan(_71, _72, move _35) -> [return: bb21, unwind continue];
    }

    bb21: {
        _37 = &(_1.4: attribute::param::parse::ErrorKind);
        _36 = <param::parse::ErrorKind as ToString>::to_string(move _37) -> [return: bb22, unwind continue];
    }

    bb22: {
        _33 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _34, move _36) -> [return: bb23, unwind continue];
    }

    bb23: {
        _32 = devise::Diagnostic::help::<&str>(move _33, const "a trailing parameter must be the final component") -> [return: bb24, unwind continue];
    }

    bb24: {
        _38 = (_1.1: proc_macro2::Span);
        _0 = devise::Diagnostic::span_note::<proc_macro2::Span, &str>(move _32, move _38, const "trailing param is here") -> [return: bb40, unwind continue];
    }

    bb25: {
        _73 = deref_copy (_1.0: &str);
        _39 = candidate_from_malformed(_73) -> [return: bb26, unwind continue];
    }

    bb26: {
        _41 = (_1.1: proc_macro2::Span);
        _43 = &(_1.4: attribute::param::parse::ErrorKind);
        _42 = <param::parse::ErrorKind as ToString>::to_string(move _43) -> [return: bb27, unwind: bb42];
    }

    bb27: {
        _40 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _41, move _42) -> [return: bb28, unwind: bb42];
    }

    bb28: {
        _75 = const true;
        _66 = const _;
        _46 = _66 as &[&str] (PointerCoercion(Unsize));
        _51 = &_39;
        _50 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_51) -> [return: bb29, unwind: bb48];
    }

    bb29: {
        _49 = [move _50];
        _48 = &_49;
        _47 = _48 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _45 = std::fmt::Arguments::<'_>::new_v1(move _46, move _47) -> [return: bb30, unwind: bb48];
    }

    bb30: {
        _44 = format(move _45) -> [return: bb31, unwind: bb48];
    }

    bb31: {
        _75 = const false;
        _0 = devise::Diagnostic::help::<std::string::String>(move _40, move _44) -> [return: bb32, unwind: bb48];
    }

    bb32: {
        _75 = const false;
        drop(_39) -> [return: bb40, unwind continue];
    }

    bb33: {
        _54 = (_1.1: proc_macro2::Span);
        _56 = &(_1.4: attribute::param::parse::ErrorKind);
        _55 = <param::parse::ErrorKind as ToString>::to_string(move _56) -> [return: bb34, unwind: bb41];
    }

    bb34: {
        _53 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _54, move _55) -> [return: bb35, unwind: bb41];
    }

    bb35: {
        _74 = const true;
        _65 = const _;
        _59 = _65 as &[&str] (PointerCoercion(Unsize));
        _64 = &_52;
        _63 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_64) -> [return: bb36, unwind: bb46];
    }

    bb36: {
        _62 = [move _63];
        _61 = &_62;
        _60 = _61 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _58 = std::fmt::Arguments::<'_>::new_v1(move _59, move _60) -> [return: bb37, unwind: bb46];
    }

    bb37: {
        _57 = format(move _58) -> [return: bb38, unwind: bb46];
    }

    bb38: {
        _74 = const false;
        _0 = devise::Diagnostic::help::<std::string::String>(move _53, move _57) -> [return: bb39, unwind: bb46];
    }

    bb39: {
        _74 = const false;
        drop(_52) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_52) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_39) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_6) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        resume;
    }

    bb45 (cleanup): {
        drop(_53) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        switchInt(_74) -> [0: bb41, otherwise: bb45];
    }

    bb47 (cleanup): {
        drop(_40) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_75) -> [0: bb42, otherwise: bb47];
    }

    bb49 (cleanup): {
        drop(_7) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        switchInt(_76) -> [0: bb43, otherwise: bb49];
    }
}

promoted[0] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:147:1: 147:36>::from: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "parameter must be dynamic: `<", const ">`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:147:1: 147:36>::from: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "did you mean `<", const ">`?"];
        _0 = &_1;
        return;
    }
}

promoted[2] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:147:1: 147:36>::from: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "did you mean `<", const ">`?"];
        _0 = &_1;
        return;
    }
}

promoted[3] in param::parse::<impl at core/codegen/src/attribute/param/parse.rs:147:1: 147:36>::from: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": `", const "`"];
        _0 = &_1;
        return;
    }
}

fn param::parse::<impl at core/codegen/src/attribute/param/parse.rs:181:1: 181:34>::from_meta(_1: &devise::MetaItem) -> std::result::Result<param::Dynamic, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<attribute::param::Dynamic, devise::Diagnostic>;
    let _2: proc_macro_ext::StringLit;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, proc_macro_ext::StringLit>;
    let mut _4: std::result::Result<proc_macro_ext::StringLit, devise::Diagnostic>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _7: proc_macro_ext::StringLit;
    let mut _9: &proc_macro_ext::StringLit;
    let mut _10: std::ops::Range<usize>;
    let mut _11: usize;
    let mut _12: usize;
    let _13: &str;
    let mut _14: &proc_macro_ext::StringLit;
    let mut _15: (usize, bool);
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>, attribute::param::Dynamic>;
    let mut _18: std::result::Result<attribute::param::Dynamic, attribute::param::parse::Error<'_>>;
    let _19: &str;
    let _20: &proc_macro_ext::StringLit;
    let mut _21: isize;
    let mut _24: bool;
    let mut _25: &attribute::param::Dynamic;
    let mut _26: devise::Diagnostic;
    let mut _27: attribute::param::parse::Error<'_>;
    let _28: &str;
    let _29: &proc_macro_ext::StringLit;
    let mut _30: attribute::param::parse::ErrorKind;
    let mut _31: bool;
    let mut _32: devise::Diagnostic;
    let mut _33: attribute::param::parse::Error<'_>;
    let _34: &str;
    let _35: &proc_macro_ext::StringLit;
    let mut _36: attribute::param::parse::ErrorKind;
    let mut _37: attribute::param::Dynamic;
    scope 1 {
        debug string => _2;
        let _8: proc_macro2::Span;
        scope 6 {
            debug span => _8;
            let _16: attribute::param::Dynamic;
            let _22: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>;
            let _23: attribute::param::Dynamic;
            scope 7 {
                debug param => _16;
            }
            scope 8 {
                debug residual => _22;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _23;
                scope 11 {
                }
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = <StringLit as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<StringLit, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: proc_macro_ext::StringLit);
        _2 = move _7;
        _9 = &_2;
        _14 = &_2;
        _13 = <StringLit as std::ops::Deref>::deref(move _14) -> [return: bb6, unwind: bb30];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<param::Dynamic, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _6) -> [return: bb28, unwind continue];
    }

    bb6: {
        _12 = core::str::<impl str>::len(_13) -> [return: bb7, unwind: bb30];
    }

    bb7: {
        _15 = CheckedAdd(_12, const 1_usize);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", move _12, const 1_usize) -> [success: bb8, unwind: bb30];
    }

    bb8: {
        _11 = move (_15.0: usize);
        _10 = std::ops::Range::<usize> { start: const 1_usize, end: move _11 };
        _8 = StringLit::subspan::<std::ops::Range<usize>>(move _9, move _10) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _20 = &_2;
        _19 = <StringLit as std::ops::Deref>::deref(_20) -> [return: bb10, unwind: bb30];
    }

    bb10: {
        _18 = param::parse::<impl param::Dynamic>::parse::<rocket_http::uri::fmt::Path>(_19, _8) -> [return: bb11, unwind: bb30];
    }

    bb11: {
        _17 = <std::result::Result<param::Dynamic, param::parse::Error<'_>> as std::ops::Try>::branch(move _18) -> [return: bb12, unwind: bb30];
    }

    bb12: {
        _21 = discriminant(_17);
        switchInt(move _21) -> [0: bb13, 1: bb14, otherwise: bb4];
    }

    bb13: {
        _23 = move ((_17 as Continue).0: attribute::param::Dynamic);
        _16 = move _23;
        _25 = &_16;
        _24 = param::Dynamic::is_wild(move _25) -> [return: bb15, unwind: bb29];
    }

    bb14: {
        _22 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, attribute::param::parse::Error<'_>>);
        _0 = <std::result::Result<param::Dynamic, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, param::parse::Error<'_>>>>::from_residual(move _22) -> [return: bb32, unwind: bb30];
    }

    bb15: {
        switchInt(move _24) -> [0: bb20, otherwise: bb16];
    }

    bb16: {
        _29 = &_2;
        _28 = <StringLit as std::ops::Deref>::deref(_29) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _30 = param::parse::ErrorKind::Ignored;
        _27 = param::parse::Error::<'_>::new(_28, _8, move _30) -> [return: bb18, unwind: bb29];
    }

    bb18: {
        _26 = <param::parse::Error<'_> as Into<devise::Diagnostic>>::into(move _27) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _0 = std::result::Result::<param::Dynamic, devise::Diagnostic>::Err(move _26);
        goto -> bb26;
    }

    bb20: {
        _31 = (_16.2: bool);
        switchInt(move _31) -> [0: bb25, otherwise: bb21];
    }

    bb21: {
        _35 = &_2;
        _34 = <StringLit as std::ops::Deref>::deref(_35) -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _36 = param::parse::ErrorKind::NoTrailing;
        _33 = param::parse::Error::<'_>::new(_34, _8, move _36) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        _32 = <param::parse::Error<'_> as Into<devise::Diagnostic>>::into(move _33) -> [return: bb24, unwind: bb29];
    }

    bb24: {
        _0 = std::result::Result::<param::Dynamic, devise::Diagnostic>::Err(move _32);
        goto -> bb26;
    }

    bb25: {
        _37 = move _16;
        _0 = std::result::Result::<param::Dynamic, devise::Diagnostic>::Ok(move _37);
        drop(_2) -> [return: bb28, unwind continue];
    }

    bb26: {
        drop(_16) -> [return: bb27, unwind: bb30];
    }

    bb27: {
        drop(_2) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_16) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_2) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        resume;
    }

    bb32: {
        goto -> bb27;
    }
}

fn param::parse::subspan(_1: &str, _2: &str, _3: proc_macro2::Span) -> proc_macro2::Span {
    debug needle => _1;
    debug haystack => _2;
    debug span => _3;
    let mut _0: proc_macro2::Span;
    let _4: usize;
    let mut _5: usize;
    let mut _6: *const u8;
    let mut _7: usize;
    let mut _8: *const u8;
    let mut _9: (usize, bool);
    let mut _10: &proc_macro_ext::StringLit;
    let _11: proc_macro_ext::StringLit;
    let mut _12: std::ops::Range<usize>;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: (usize, bool);
    scope 1 {
        debug index => _4;
    }

    bb0: {
        _6 = core::str::<impl str>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = move _6 as usize (PointerExposeAddress);
        _8 = core::str::<impl str>::as_ptr(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = move _8 as usize (PointerExposeAddress);
        _9 = CheckedSub(_5, _7);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, move _7) -> [success: bb3, unwind continue];
    }

    bb3: {
        _4 = move (_9.0: usize);
        _11 = StringLit::new::<&str>(_2, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = &_11;
        _14 = core::str::<impl str>::len(_1) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _15 = CheckedAdd(_4, _14);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _4, move _14) -> [success: bb6, unwind: bb9];
    }

    bb6: {
        _13 = move (_15.0: usize);
        _12 = std::ops::Range::<usize> { start: _4, end: move _13 };
        _0 = StringLit::subspan::<std::ops::Range<usize>>(move _10, move _12) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        drop(_11) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_11) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn trailspan(_1: &str, _2: &str, _3: proc_macro2::Span) -> proc_macro2::Span {
    debug needle => _1;
    debug haystack => _2;
    debug span => _3;
    let mut _0: proc_macro2::Span;
    let _4: usize;
    let mut _5: usize;
    let mut _6: *const u8;
    let mut _7: usize;
    let mut _8: *const u8;
    let mut _9: (usize, bool);
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: *const u8;
    let mut _14: usize;
    let mut _15: *const u8;
    let mut _16: &proc_macro_ext::StringLit;
    let mut _17: std::ops::RangeFrom<usize>;
    let mut _18: usize;
    let mut _19: (usize, bool);
    let mut _20: &proc_macro_ext::StringLit;
    let mut _21: std::ops::RangeFrom<usize>;
    scope 1 {
        debug index => _4;
        let _10: proc_macro_ext::StringLit;
        scope 2 {
            debug lit => _10;
        }
    }

    bb0: {
        _6 = core::str::<impl str>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = move _6 as usize (PointerExposeAddress);
        _8 = core::str::<impl str>::as_ptr(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = move _8 as usize (PointerExposeAddress);
        _9 = CheckedSub(_5, _7);
        assert(!move (_9.1: bool), "attempt to compute `{} - {}`, which would overflow", move _5, move _7) -> [success: bb3, unwind continue];
    }

    bb3: {
        _4 = move (_9.0: usize);
        _10 = StringLit::new::<&str>(_2, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = core::str::<impl str>::as_ptr(_1) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _12 = move _13 as usize (PointerExposeAddress);
        _15 = core::str::<impl str>::as_ptr(_2) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _14 = move _15 as usize (PointerExposeAddress);
        _11 = Gt(move _12, move _14);
        switchInt(move _11) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _16 = &_10;
        _19 = CheckedSub(_4, const 1_usize);
        assert(!move (_19.1: bool), "attempt to compute `{} - {}`, which would overflow", _4, const 1_usize) -> [success: bb8, unwind: bb12];
    }

    bb8: {
        _18 = move (_19.0: usize);
        _17 = RangeFrom::<usize> { start: move _18 };
        _0 = StringLit::subspan::<RangeFrom<usize>>(move _16, move _17) -> [return: bb14, unwind: bb12];
    }

    bb9: {
        _20 = &_10;
        _21 = RangeFrom::<usize> { start: _4 };
        _0 = StringLit::subspan::<RangeFrom<usize>>(move _20, move _21) -> [return: bb15, unwind: bb12];
    }

    bb10: {
        drop(_10) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_10) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        goto -> bb10;
    }

    bb15: {
        goto -> bb10;
    }
}

fn candidate_from_malformed(_1: &str) -> std::string::String {
    debug segment => _1;
    let mut _0: std::string::String;
    let _2: std::string::String;
    let mut _3: std::iter::Map<std::iter::Filter<std::iter::Enumerate<std::str::Chars<'_>>, {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}>, {closure@core/codegen/src/attribute/param/parse.rs:215:14: 215:22}>;
    let mut _4: std::iter::Filter<std::iter::Enumerate<std::str::Chars<'_>>, {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}>;
    let mut _5: std::iter::Enumerate<std::str::Chars<'_>>;
    let mut _6: std::str::Chars<'_>;
    let mut _7: bool;
    let mut _8: &std::string::String;
    let _9: &str;
    let mut _10: bool;
    scope 1 {
        debug candidate => _2;
    }

    bb0: {
        _10 = const false;
        _6 = core::str::<impl str>::chars(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = <Chars<'_> as Iterator>::enumerate(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <Enumerate<Chars<'_>> as Iterator>::filter::<{closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}>(move _5, const ZeroSized: {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <Filter<Enumerate<Chars<'_>>, {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}> as Iterator>::map::<char, {closure@core/codegen/src/attribute/param/parse.rs:215:14: 215:22}>(move _4, const ZeroSized: {closure@core/codegen/src/attribute/param/parse.rs:215:14: 215:22}) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = const true;
        _2 = <Map<Filter<Enumerate<Chars<'_>>, {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}>, {closure@core/codegen/src/attribute/param/parse.rs:215:14: 215:22}> as Iterator>::collect::<std::string::String>(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = &_2;
        _7 = std::string::String::is_empty(move _8) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        switchInt(move _7) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _9 = const "param";
        _0 = <&str as Into<std::string::String>>::into(_9) -> [return: bb14, unwind: bb11];
    }

    bb8: {
        _10 = const false;
        _0 = move _2;
        goto -> bb9;
    }

    bb9: {
        switchInt(_10) -> [0: bb10, otherwise: bb13];
    }

    bb10: {
        _10 = const false;
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb14: {
        goto -> bb9;
    }
}

fn candidate_from_malformed::{closure#0}(_1: &mut {closure@core/codegen/src/attribute/param/parse.rs:214:17: 214:25}, _2: &(usize, char)) -> bool {
    let mut _0: bool;
    let _3: &usize;
    let _4: &char;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: char;
    let mut _8: usize;
    let mut _9: char;
    scope 1 {
        debug i => _3;
        debug c => _4;
    }

    bb0: {
        _3 = &((*_2).0: usize);
        _4 = &((*_2).1: char);
        _5 = (*_3);
        switchInt(move _5) -> [0: bb1, otherwise: bb4];
    }

    bb1: {
        _7 = (*_4);
        _6 = is_ident_start(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _6) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const true;
        goto -> bb7;
    }

    bb4: {
        _8 = (*_3);
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _9 = (*_4);
        _0 = is_ident_continue(move _9) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = const false;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn candidate_from_malformed::{closure#1}(_1: &mut {closure@core/codegen/src/attribute/param/parse.rs:215:14: 215:22}, _2: (usize, char)) -> char {
    let mut _0: char;
    scope 1 {
        debug c => _0;
    }

    bb0: {
        _0 = (_2.1: char);
        return;
    }
}

fn is_ident_start(_1: char) -> bool {
    debug c => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &char;
    let mut _4: char;
    let mut _5: bool;
    let mut _6: char;
    let mut _7: char;

    bb0: {
        _3 = &_1;
        _2 = char::methods::<impl char>::is_ascii_alphabetic(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = _1;
        switchInt(move _4) -> [95: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = const true;
        goto -> bb7;
    }

    bb4: {
        _6 = _1;
        _5 = Gt(move _6, const '\u{7f}');
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _7 = _1;
        _0 = <char as UnicodeXID>::is_xid_start(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = const false;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn is_ident_continue(_1: char) -> bool {
    debug c => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &char;
    let mut _4: char;
    let mut _5: bool;
    let mut _6: char;
    let mut _7: char;

    bb0: {
        _3 = &_1;
        _2 = char::methods::<impl char>::is_ascii_alphanumeric(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = _1;
        switchInt(move _4) -> [95: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = const true;
        goto -> bb7;
    }

    bb4: {
        _6 = _1;
        _5 = Gt(move _6, const '\u{7f}');
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _7 = _1;
        _0 = <char as UnicodeXID>::is_xid_continue(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = const false;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn is_valid_ident(_1: &str) -> bool {
    debug string => _1;
    let mut _0: bool;
    let mut _2: std::str::Chars<'_>;
    let mut _3: std::option::Option<char>;
    let mut _4: &mut std::str::Chars<'_>;
    let mut _5: isize;
    let mut _7: bool;
    let mut _8: &mut std::str::Chars<'_>;
    scope 1 {
        debug chars => _2;
        let _6: char;
        scope 2 {
            debug c => _6;
        }
    }

    bb0: {
        _2 = core::str::<impl str>::chars(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _2;
        _3 = <Chars<'_> as Iterator>::next(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _0 = const false;
        goto -> bb9;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = ((_3 as Some).0: char);
        _7 = is_ident_start(_6) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _7) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _8 = &mut _2;
        _0 = <Chars<'_> as Iterator>::all::<fn(char) -> bool {is_ident_continue}>(move _8, is_ident_continue) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = const false;
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:8:10: 8:15>::fmt(_1: &Parameter, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &name::Name;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&name::Name;
    let _8: &attribute::param::Dynamic;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&attribute::param::Dynamic;
    let _12: &attribute::param::Dynamic;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&attribute::param::Dynamic;
    let _16: &attribute::param::Guard;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&attribute::param::Guard;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }
    scope 4 {
        debug __self_0 => _16;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _16 = &(((*_1) as Guard).0: attribute::param::Guard);
        _17 = const "Guard";
        _19 = &_16;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _17, move _18) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Static).0: name::Name);
        _5 = const "Static";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb6, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as Ignored).0: attribute::param::Dynamic);
        _9 = const "Ignored";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb6, unwind continue];
    }

    bb5: {
        _12 = &(((*_1) as Dynamic).0: attribute::param::Dynamic);
        _13 = const "Dynamic";
        _15 = &_12;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:8:17: 8:22>::clone(_1: &Parameter) -> Parameter {
    debug self => _1;
    let mut _0: attribute::param::Parameter;
    let mut _2: isize;
    let _3: &name::Name;
    let mut _4: name::Name;
    let _5: &attribute::param::Dynamic;
    let mut _6: attribute::param::Dynamic;
    let _7: &attribute::param::Dynamic;
    let mut _8: attribute::param::Dynamic;
    let _9: &attribute::param::Guard;
    let mut _10: attribute::param::Guard;
    scope 1 {
        debug __self_0 => _3;
    }
    scope 2 {
        debug __self_0 => _5;
    }
    scope 3 {
        debug __self_0 => _7;
    }
    scope 4 {
        debug __self_0 => _9;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb5, 2: bb7, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = &(((*_1) as Guard).0: attribute::param::Guard);
        _10 = <Guard as Clone>::clone(_9) -> [return: bb9, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as Static).0: name::Name);
        _4 = <name::Name as Clone>::clone(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Parameter::Static(move _4);
        goto -> bb10;
    }

    bb5: {
        _5 = &(((*_1) as Ignored).0: attribute::param::Dynamic);
        _6 = <param::Dynamic as Clone>::clone(_5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = Parameter::Ignored(move _6);
        goto -> bb10;
    }

    bb7: {
        _7 = &(((*_1) as Dynamic).0: attribute::param::Dynamic);
        _8 = <param::Dynamic as Clone>::clone(_7) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = Parameter::Dynamic(move _8);
        goto -> bb10;
    }

    bb9: {
        _0 = Parameter::Guard(move _10);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:8:24: 8:33>::eq(_1: &Parameter, _2: &Parameter) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&attribute::param::Parameter, &attribute::param::Parameter);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _11: isize;
    let mut _20: &attribute::param::Parameter;
    let mut _21: &attribute::param::Parameter;
    let mut _22: &attribute::param::Parameter;
    let mut _23: &attribute::param::Parameter;
    let mut _24: &attribute::param::Parameter;
    let mut _25: &attribute::param::Parameter;
    let mut _26: &attribute::param::Parameter;
    let mut _27: &attribute::param::Parameter;
    let mut _28: &attribute::param::Parameter;
    let mut _29: &attribute::param::Parameter;
    let mut _30: &attribute::param::Parameter;
    let mut _31: &attribute::param::Parameter;
    let mut _32: &attribute::param::Parameter;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _12: &name::Name;
            let _13: &name::Name;
            let _14: &attribute::param::Dynamic;
            let _15: &attribute::param::Dynamic;
            let _16: &attribute::param::Dynamic;
            let _17: &attribute::param::Dynamic;
            let _18: &attribute::param::Guard;
            let _19: &attribute::param::Guard;
            scope 3 {
                debug __self_0 => _12;
                debug __arg1_0 => _13;
            }
            scope 4 {
                debug __self_0 => _14;
                debug __arg1_0 => _15;
            }
            scope 5 {
                debug __self_0 => _16;
                debug __arg1_0 => _17;
            }
            scope 6 {
                debug __self_0 => _18;
                debug __arg1_0 => _19;
            }
            scope 7 {
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _20 = deref_copy (_6.0: &attribute::param::Parameter);
        _11 = discriminant((*_20));
        switchInt(move _11) -> [0: bb3, 1: bb5, 2: bb6, 3: bb7, otherwise: bb4];
    }

    bb2: {
        _0 = const false;
        goto -> bb12;
    }

    bb3: {
        _21 = deref_copy (_6.1: &attribute::param::Parameter);
        _7 = discriminant((*_21));
        switchInt(move _7) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _22 = deref_copy (_6.1: &attribute::param::Parameter);
        _8 = discriminant((*_22));
        switchInt(move _8) -> [1: bb9, otherwise: bb4];
    }

    bb6: {
        _23 = deref_copy (_6.1: &attribute::param::Parameter);
        _9 = discriminant((*_23));
        switchInt(move _9) -> [2: bb10, otherwise: bb4];
    }

    bb7: {
        _24 = deref_copy (_6.1: &attribute::param::Parameter);
        _10 = discriminant((*_24));
        switchInt(move _10) -> [3: bb11, otherwise: bb4];
    }

    bb8: {
        _25 = deref_copy (_6.0: &attribute::param::Parameter);
        _12 = &(((*_25) as Static).0: name::Name);
        _26 = deref_copy (_6.1: &attribute::param::Parameter);
        _13 = &(((*_26) as Static).0: name::Name);
        _0 = <name::Name as PartialEq>::eq(_12, _13) -> [return: bb12, unwind continue];
    }

    bb9: {
        _27 = deref_copy (_6.0: &attribute::param::Parameter);
        _14 = &(((*_27) as Ignored).0: attribute::param::Dynamic);
        _28 = deref_copy (_6.1: &attribute::param::Parameter);
        _15 = &(((*_28) as Ignored).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as PartialEq>::eq(_14, _15) -> [return: bb12, unwind continue];
    }

    bb10: {
        _29 = deref_copy (_6.0: &attribute::param::Parameter);
        _16 = &(((*_29) as Dynamic).0: attribute::param::Dynamic);
        _30 = deref_copy (_6.1: &attribute::param::Parameter);
        _17 = &(((*_30) as Dynamic).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as PartialEq>::eq(_16, _17) -> [return: bb12, unwind continue];
    }

    bb11: {
        _31 = deref_copy (_6.0: &attribute::param::Parameter);
        _18 = &(((*_31) as Guard).0: attribute::param::Guard);
        _32 = deref_copy (_6.1: &attribute::param::Parameter);
        _19 = &(((*_32) as Guard).0: attribute::param::Guard);
        _0 = <Guard as PartialEq>::eq(_18, _19) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:8:35: 8:37>::assert_receiver_is_total_eq(_1: &Parameter) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:8:39: 8:43>::hash(_1: &Parameter, _2: &mut __H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let _3: isize;
    let _4: ();
    let _5: &isize;
    let mut _6: isize;
    scope 1 {
        debug __self_tag => _3;
        let _7: &name::Name;
        let _8: &attribute::param::Dynamic;
        let _9: &attribute::param::Dynamic;
        let _10: &attribute::param::Guard;
        scope 2 {
            debug __self_0 => _7;
        }
        scope 3 {
            debug __self_0 => _8;
        }
        scope 4 {
            debug __self_0 => _9;
        }
        scope 5 {
            debug __self_0 => _10;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _5 = &_3;
        _4 = <isize as Hash>::hash::<__H>(_5, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant((*_1));
        switchInt(move _6) -> [0: bb4, 1: bb5, 2: bb6, 3: bb2, otherwise: bb3];
    }

    bb2: {
        _10 = &(((*_1) as Guard).0: attribute::param::Guard);
        _0 = <Guard as Hash>::hash::<__H>(_10, _2) -> [return: bb7, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _7 = &(((*_1) as Static).0: name::Name);
        _0 = <name::Name as Hash>::hash::<__H>(_7, _2) -> [return: bb7, unwind continue];
    }

    bb5: {
        _8 = &(((*_1) as Ignored).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as Hash>::hash::<__H>(_8, _2) -> [return: bb7, unwind continue];
    }

    bb6: {
        _9 = &(((*_1) as Dynamic).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as Hash>::hash::<__H>(_9, _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:16:10: 16:15>::fmt(_1: &param::Dynamic, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &name::Name;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &usize;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&bool;
    let _13: &bool;

    bb0: {
        _3 = const "Dynamic";
        _4 = const "name";
        _6 = &((*_1).0: name::Name);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "index";
        _9 = &((*_1).1: usize);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "trailing";
        _13 = &((*_1).2: bool);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:16:17: 16:22>::clone(_1: &param::Dynamic) -> param::Dynamic {
    debug self => _1;
    let mut _0: attribute::param::Dynamic;
    let mut _2: name::Name;
    let _3: &name::Name;
    let mut _4: usize;
    let _5: &usize;
    let mut _6: bool;
    let _7: &bool;

    bb0: {
        _3 = &((*_1).0: name::Name);
        _2 = <name::Name as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: usize);
        _4 = (*_5);
        _7 = &((*_1).2: bool);
        _6 = (*_7);
        _0 = param::Dynamic { name: move _2, index: move _4, trailing: move _6 };
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:23:10: 23:15>::fmt(_1: &Guard, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &attribute::param::Dynamic;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &proc_macro2::Ident;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&syn::Type;
    let _13: &syn::Type;

    bb0: {
        _3 = const "Guard";
        _4 = const "source";
        _6 = &((*_1).0: attribute::param::Dynamic);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "fn_ident";
        _9 = &((*_1).1: proc_macro2::Ident);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "ty";
        _13 = &((*_1).2: syn::Type);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:23:17: 23:22>::clone(_1: &Guard) -> Guard {
    debug self => _1;
    let mut _0: attribute::param::Guard;
    let mut _2: attribute::param::Dynamic;
    let _3: &attribute::param::Dynamic;
    let mut _4: proc_macro2::Ident;
    let _5: &proc_macro2::Ident;
    let mut _6: syn::Type;
    let _7: &syn::Type;

    bb0: {
        _3 = &((*_1).0: attribute::param::Dynamic);
        _2 = <param::Dynamic as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: proc_macro2::Ident);
        _4 = <proc_macro2::Ident as Clone>::clone(_5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = &((*_1).2: syn::Type);
        _6 = <syn::Type as Clone>::clone(_7) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = Guard { source: move _2, fn_ident: move _4, ty: move _6 };
        return;
    }

    bb4 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::r#static(_1: &Parameter) -> Option<&name::Name> {
    debug self => _1;
    let mut _0: std::option::Option<&name::Name>;
    let mut _2: isize;
    let _3: &name::Name;
    scope 1 {
        debug s => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&name::Name>::None;
        goto -> bb3;
    }

    bb2: {
        _3 = &(((*_1) as Static).0: name::Name);
        _0 = Option::<&name::Name>::Some(_3);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::ignored(_1: &Parameter) -> Option<&param::Dynamic> {
    debug self => _1;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;
    let mut _2: isize;
    let _3: &attribute::param::Dynamic;
    scope 1 {
        debug d => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&param::Dynamic>::None;
        goto -> bb3;
    }

    bb2: {
        _3 = &(((*_1) as Ignored).0: attribute::param::Dynamic);
        _0 = Option::<&param::Dynamic>::Some(_3);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::take_dynamic(_1: Parameter) -> Option<param::Dynamic> {
    debug self => _1;
    let mut _0: std::option::Option<attribute::param::Dynamic>;
    let mut _2: isize;
    let _3: attribute::param::Dynamic;
    let _4: attribute::param::Guard;
    let mut _5: attribute::param::Dynamic;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: isize;
    let mut _9: isize;
    scope 1 {
        debug d => _3;
    }
    scope 2 {
        debug g => _4;
    }

    bb0: {
        _7 = const false;
        _6 = const false;
        _6 = const true;
        _7 = const true;
        _2 = discriminant(_1);
        switchInt(move _2) -> [2: bb2, 3: bb3, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<param::Dynamic>::None;
        goto -> bb14;
    }

    bb2: {
        _7 = const false;
        _3 = move ((_1 as Dynamic).0: attribute::param::Dynamic);
        _0 = Option::<param::Dynamic>::Some(move _3);
        goto -> bb14;
    }

    bb3: {
        _6 = const false;
        _4 = move ((_1 as Guard).0: attribute::param::Guard);
        _5 = move (_4.0: attribute::param::Dynamic);
        _0 = Option::<param::Dynamic>::Some(move _5);
        drop((_4.1: proc_macro2::Ident)) -> [return: bb7, unwind: bb6];
    }

    bb4 (cleanup): {
        _9 = discriminant(_1);
        switchInt(move _9) -> [2: bb5, 3: bb5, otherwise: bb15];
    }

    bb5 (cleanup): {
        resume;
    }

    bb6 (cleanup): {
        drop((_4.2: syn::Type)) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb7: {
        drop((_4.2: syn::Type)) -> [return: bb14, unwind: bb4];
    }

    bb8: {
        return;
    }

    bb9: {
        switchInt(_7) -> [0: bb8, otherwise: bb10];
    }

    bb10: {
        drop(((_1 as Dynamic).0: attribute::param::Dynamic)) -> [return: bb8, unwind continue];
    }

    bb11: {
        switchInt(_6) -> [0: bb8, otherwise: bb12];
    }

    bb12: {
        drop(((_1 as Guard).0: attribute::param::Guard)) -> [return: bb8, unwind continue];
    }

    bb13: {
        drop(_1) -> [return: bb8, unwind continue];
    }

    bb14: {
        _8 = discriminant(_1);
        switchInt(move _8) -> [2: bb9, 3: bb11, otherwise: bb13];
    }

    bb15 (cleanup): {
        drop(_1) -> [return: bb5, unwind terminate(cleanup)];
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::dynamic(_1: &Parameter) -> Option<&param::Dynamic> {
    debug self => _1;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;
    let mut _2: isize;
    let _3: &attribute::param::Dynamic;
    let _4: &attribute::param::Guard;
    let _5: &attribute::param::Dynamic;
    scope 1 {
        debug d => _3;
    }
    scope 2 {
        debug g => _4;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [2: bb2, 3: bb3, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&param::Dynamic>::None;
        goto -> bb4;
    }

    bb2: {
        _3 = &(((*_1) as Dynamic).0: attribute::param::Dynamic);
        _0 = Option::<&param::Dynamic>::Some(_3);
        goto -> bb4;
    }

    bb3: {
        _4 = &(((*_1) as Guard).0: attribute::param::Guard);
        _5 = &((*_4).0: attribute::param::Dynamic);
        _0 = Option::<&param::Dynamic>::Some(_5);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::dynamic_mut(_1: &mut Parameter) -> Option<&mut param::Dynamic> {
    debug self => _1;
    let mut _0: std::option::Option<&mut attribute::param::Dynamic>;
    let mut _2: isize;
    let _3: &mut attribute::param::Dynamic;
    let _4: &mut attribute::param::Guard;
    let mut _5: &mut attribute::param::Dynamic;
    scope 1 {
        debug d => _3;
    }
    scope 2 {
        debug g => _4;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [2: bb2, 3: bb3, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&mut param::Dynamic>::None;
        goto -> bb4;
    }

    bb2: {
        _3 = &mut (((*_1) as Dynamic).0: attribute::param::Dynamic);
        _0 = Option::<&mut param::Dynamic>::Some(_3);
        goto -> bb4;
    }

    bb3: {
        _4 = &mut (((*_1) as Guard).0: attribute::param::Guard);
        _5 = &mut ((*_4).0: attribute::param::Dynamic);
        _0 = Option::<&mut param::Dynamic>::Some(_5);
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:30:1: 30:15>::guard(_1: &Parameter) -> Option<&Guard> {
    debug self => _1;
    let mut _0: std::option::Option<&attribute::param::Guard>;
    let mut _2: isize;
    let _3: &attribute::param::Guard;
    scope 1 {
        debug g => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [3: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&Guard>::None;
        goto -> bb3;
    }

    bb2: {
        _3 = &(((*_1) as Guard).0: attribute::param::Guard);
        _0 = Option::<&Guard>::Some(_3);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:77:1: 77:13>::is_wild(_1: &param::Dynamic) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &&name::Name;
    let _3: &name::Name;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_1).0: name::Name);
        _2 = &_3;
        _4 = const _;
        _0 = <&name::Name as PartialEq<&str>>::eq(move _2, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in param::<impl at core/codegen/src/attribute/param/mod.rs:77:1: 77:13>::is_wild: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "_";
        _0 = &_1;
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:84:1: 84:11>::from(_1: param::Dynamic, _2: proc_macro2::Ident, _3: syn::Type) -> Guard {
    debug source => _1;
    debug fn_ident => _2;
    debug ty => _3;
    let mut _0: attribute::param::Guard;

    bb0: {
        _0 = Guard { source: move _1, fn_ident: move _2, ty: move _3 };
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:92:9: 92:26>::deref(_1: &param::Dynamic) -> &name::Name {
    debug self => _1;
    let mut _0: &name::Name;

    bb0: {
        _0 = &((*_1).0: name::Name);
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:100:9: 100:30>::eq(_1: &param::Dynamic, _2: &param::Dynamic) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &name::Name;
    let mut _4: &name::Name;

    bb0: {
        _3 = &((*_1).0: name::Name);
        _4 = &((*_2).0: name::Name);
        _0 = <name::Name as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:108:9: 108:25>::hash(_1: &param::Dynamic, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &name::Name;

    bb0: {
        _3 = &((*_1).0: name::Name);
        _0 = <name::Name as Hash>::hash::<H>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:92:9: 92:26>::deref(_1: &Guard) -> &param::Dynamic {
    debug self => _1;
    let mut _0: &attribute::param::Dynamic;

    bb0: {
        _0 = &((*_1).0: attribute::param::Dynamic);
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:100:9: 100:30>::eq(_1: &Guard, _2: &Guard) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &attribute::param::Dynamic;
    let mut _4: &attribute::param::Dynamic;

    bb0: {
        _3 = &((*_1).0: attribute::param::Dynamic);
        _4 = &((*_2).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn param::<impl at core/codegen/src/attribute/param/mod.rs:108:9: 108:25>::hash(_1: &Guard, _2: &mut H) -> () {
    debug self => _1;
    debug state => _2;
    let mut _0: ();
    let mut _3: &attribute::param::Dynamic;

    bb0: {
        _3 = &((*_1).0: attribute::param::Dynamic);
        _0 = <param::Dynamic as Hash>::hash::<H>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn prefix_last_segment(_1: &mut syn::Path, _2: &str) -> () {
    debug path => _1;
    debug prefix => _2;
    let mut _0: ();
    let mut _3: &mut syn::PathSegment;
    let mut _4: std::option::Option<&mut syn::PathSegment>;
    let mut _5: &mut syn::punctuated::Punctuated<syn::PathSegment, syn::token::Colon2>;
    let _6: &str;
    let mut _7: proc_macro2::Ident;
    let mut _8: &proc_macro2::Ident;
    scope 1 {
        debug last_seg => _3;
    }

    bb0: {
        _5 = &mut ((*_1).1: syn::punctuated::Punctuated<syn::PathSegment, syn::token::Colon2>);
        _4 = syn::punctuated::Punctuated::<PathSegment, Colon2>::last_mut(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = const "syn::Path has segments";
        _3 = Option::<&mut PathSegment>::expect(move _4, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &((*_3).0: proc_macro2::Ident);
        _7 = <proc_macro2::Ident as syn_ext::IdentExt>::prepend(move _8, _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        drop(((*_3).0: proc_macro2::Ident)) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        ((*_3).0: proc_macro2::Ident) = move _7;
        return;
    }

    bb5 (cleanup): {
        ((*_3).0: proc_macro2::Ident) = move _7;
        resume;
    }
}

fn _uri_macro(_1: TokenStream2) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: &proc_macro2::TokenStream;
    let mut _5: bang::uri_parsing::UriMacro;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::UriMacro>;
    let mut _7: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _8: proc_macro2::TokenStream;
    let mut _9: isize;
    let mut _12: isize;
    let _14: ();
    let mut _15: &mut syn::Path;
    let _16: &&str;
    let mut _18: proc_macro2::TokenStream;
    let _20: ();
    let _21: &&syn::Path;
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let mut _27: proc_macro2::Delimiter;
    let mut _28: proc_macro2::TokenStream;
    let _30: ();
    let _31: &proc_macro2::TokenStream;
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _34: proc_macro2::TokenStream;
    let _36: ();
    let _37: &bang::uri_parsing::UriLit;
    let mut _38: &mut proc_macro2::TokenStream;
    let mut _39: &str;
    let mut _40: bool;
    let mut _41: isize;
    let mut _42: isize;
    scope 1 {
        debug input2 => _2;
        let _10: std::result::Result<std::convert::Infallible, syn::Error>;
        let _11: bang::uri_parsing::UriMacro;
        let _13: &mut bang::uri_parsing::RoutedUri;
        let _33: bang::uri_parsing::UriLit;
        scope 2 {
            debug residual => _10;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _11;
            scope 5 {
            }
        }
        scope 6 {
            debug mac => _13;
            let _17: &syn::Path;
            scope 7 {
                debug path => _17;
                let mut _19: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _19;
                    let mut _29: proc_macro2::TokenStream;
                    scope 9 {
                        debug _s => _29;
                    }
                }
            }
        }
        scope 10 {
            debug uri => _33;
            let mut _35: proc_macro2::TokenStream;
            scope 11 {
                debug _s => _35;
            }
        }
    }

    bb0: {
        _40 = const false;
        _40 = const true;
        _4 = &_1;
        _3 = <TokenStream2 as Clone>::clone(move _4) -> [return: bb1, unwind: bb35];
    }

    bb1: {
        _2 = <TokenStream2 as Into<TokenStream2>>::into(move _3) -> [return: bb2, unwind: bb35];
    }

    bb2: {
        _40 = const false;
        _8 = move _1;
        _7 = syn::parse2::<uri_parsing::UriMacro>(move _8) -> [return: bb3, unwind: bb29];
    }

    bb3: {
        _6 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as std::ops::Try>::branch(move _7) -> [return: bb4, unwind: bb29];
    }

    bb4: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_6 as Continue).0: bang::uri_parsing::UriMacro);
        _5 = move _11;
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb9, 1: bb10, otherwise: bb6];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _10) -> [return: bb8, unwind: bb28];
    }

    bb8: {
        drop(_2) -> [return: bb22, unwind: bb35];
    }

    bb9: {
        _33 = move ((_5 as Literal).0: bang::uri_parsing::UriLit);
        _35 = TokenStream2::new() -> [return: bb18, unwind: bb24];
    }

    bb10: {
        _13 = &mut ((_5 as Routed).0: bang::uri_parsing::RoutedUri);
        _15 = &mut (((*_13).1: bang::uri_parsing::RouteInvocation).0: syn::Path);
        _16 = const {alloc1: &&str};
        _39 = deref_copy (*_16);
        _14 = prefix_last_segment(_15, _39) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _17 = &(((*_13).1: bang::uri_parsing::RouteInvocation).0: syn::Path);
        _19 = TokenStream2::new() -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _21 = &_17;
        _22 = &mut _19;
        _20 = <&syn::Path as ToTokens>::to_tokens(_21, _22) -> [return: bb13, unwind: bb26];
    }

    bb13: {
        _24 = &mut _19;
        _23 = push_bang(_24) -> [return: bb14, unwind: bb26];
    }

    bb14: {
        _26 = &mut _19;
        _27 = proc_macro2::Delimiter::Parenthesis;
        _29 = TokenStream2::new() -> [return: bb15, unwind: bb26];
    }

    bb15: {
        _31 = &_2;
        _32 = &mut _29;
        _30 = <TokenStream2 as ToTokens>::to_tokens(_31, _32) -> [return: bb16, unwind: bb25];
    }

    bb16: {
        _28 = move _29;
        _25 = push_group(_26, move _27, move _28) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _18 = move _19;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _18);
        goto -> bb20;
    }

    bb18: {
        _37 = &_33;
        _38 = &mut _35;
        _36 = <UriLit as ToTokens>::to_tokens(_37, _38) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        _34 = move _35;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _34);
        drop(_33) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _41 = discriminant(_5);
        switchInt(move _41) -> [0: bb22, otherwise: bb31];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_35) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_33) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_29) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_19) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_2) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_2) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_2) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }

    bb31: {
        drop(_5) -> [return: bb22, unwind: bb35];
    }

    bb32 (cleanup): {
        drop(_5) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        _42 = discriminant(_5);
        switchInt(move _42) -> [0: bb35, otherwise: bb32];
    }

    bb34 (cleanup): {
        drop(_1) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        switchInt(_40) -> [0: bb30, otherwise: bb34];
    }
}

alloc1 (static: URI_MACRO_PREFIX, size: 16, align: 8) {
    ╾───alloc2607<imm>────╼ 11 00 00 00 00 00 00 00 │ ╾──────╼........
}

alloc2607 (size: 17, align: 1) {
    0x00 │ 72 6f 63 6b 65 74 5f 75 72 69 5f 6d 61 63 72 6f │ rocket_uri_macro
    0x10 │ 5f                                              │ _
}

fn extract_exprs(_1: &uri_parsing::InternalUriParams) -> std::result::Result<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic> {
    debug internal => _1;
    let mut _0: std::result::Result<(std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>, std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>;
    let _2: &syn::Path;
    let mut _3: bang::uri_parsing::Validation<'_>;
    let mut _4: isize;
    let mut _8: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
    let mut _9: &std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
    let mut _10: std::iter::Take<std::slice::Iter<'_, &bang::uri_parsing::ArgExpr>>;
    let mut _11: std::iter::Take<std::slice::Iter<'_, &bang::uri_parsing::ArgExpr>>;
    let mut _12: std::slice::Iter<'_, &bang::uri_parsing::ArgExpr>;
    let _13: &[&bang::uri_parsing::ArgExpr];
    let mut _14: &std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _16: std::option::Option<&&bang::uri_parsing::ArgExpr>;
    let mut _17: &mut std::iter::Take<std::slice::Iter<'_, &bang::uri_parsing::ArgExpr>>;
    let mut _18: isize;
    let mut _20: bool;
    let mut _21: &std::option::Option<&syn::Expr>;
    let _22: std::option::Option<&syn::Expr>;
    let mut _23: devise::Diagnostic;
    let mut _24: proc_macro2::Span;
    let mut _26: std::vec::IntoIter<&bang::uri_parsing::ArgExpr>;
    let mut _27: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _28: &std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _30: std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>;
    let mut _31: std::vec::IntoIter<&bang::uri_parsing::ArgExpr>;
    let mut _32: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _34: std::slice::Iter<'_, bang::uri_parsing::FnArg>;
    let _35: &[bang::uri_parsing::FnArg];
    let mut _36: &std::vec::Vec<bang::uri_parsing::FnArg>;
    let mut _37: (std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>, std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>);
    let mut _38: std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>;
    let mut _39: std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>;
    let mut _41: &proc_macro2::TokenStream;
    let _42: proc_macro2::TokenStream;
    let _44: ();
    let _45: &&syn::Path;
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut std::string::String;
    let mut _50: devise::Diagnostic;
    let mut _51: proc_macro2::Span;
    let mut _52: &bang::uri_parsing::RoutedUri;
    let mut _54: std::fmt::Arguments<'_>;
    let mut _55: &[&str];
    let mut _56: &[core::fmt::rt::Argument<'_>];
    let _57: &[core::fmt::rt::Argument<'_>; 2];
    let _58: [core::fmt::rt::Argument<'_>; 2];
    let mut _59: core::fmt::rt::Argument<'_>;
    let _60: &std::string::String;
    let mut _61: core::fmt::rt::Argument<'_>;
    let _62: &rocket_http::uri::Origin<'_>;
    let mut _66: &proc_macro2::TokenStream;
    let _67: proc_macro2::TokenStream;
    let _69: ();
    let _70: &&syn::Path;
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut std::string::String;
    let mut _75: devise::Diagnostic;
    let mut _76: proc_macro2::Span;
    let mut _77: &bang::uri_parsing::RoutedUri;
    let mut _78: std::string::String;
    let mut _80: std::fmt::Arguments<'_>;
    let mut _81: &[&str];
    let mut _82: &[core::fmt::rt::Argument<'_>];
    let _83: &[core::fmt::rt::Argument<'_>; 2];
    let _84: [core::fmt::rt::Argument<'_>; 2];
    let mut _85: core::fmt::rt::Argument<'_>;
    let _86: &std::string::String;
    let _87: std::string::String;
    let mut _88: usize;
    let _89: &str;
    let mut _91: std::fmt::Arguments<'_>;
    let mut _92: &[&str];
    let mut _93: &[core::fmt::rt::Argument<'_>];
    let _94: &[core::fmt::rt::Argument<'_>; 1];
    let _95: [core::fmt::rt::Argument<'_>; 1];
    let mut _96: core::fmt::rt::Argument<'_>;
    let _97: &usize;
    let mut _98: core::fmt::rt::Argument<'_>;
    let _99: &std::string::String;
    let _100: std::string::String;
    let mut _101: usize;
    let _102: &str;
    let mut _104: std::fmt::Arguments<'_>;
    let mut _105: &[&str];
    let mut _106: &[core::fmt::rt::Argument<'_>];
    let _107: &[core::fmt::rt::Argument<'_>; 1];
    let _108: [core::fmt::rt::Argument<'_>; 1];
    let mut _109: core::fmt::rt::Argument<'_>;
    let _110: &usize;
    let mut _112: std::fmt::Arguments<'_>;
    let mut _113: &[&str];
    let mut _114: &[core::fmt::rt::Argument<'_>];
    let _115: &[core::fmt::rt::Argument<'_>; 2];
    let _116: [core::fmt::rt::Argument<'_>; 2];
    let mut _117: core::fmt::rt::Argument<'_>;
    let _118: &std::string::String;
    let mut _119: core::fmt::rt::Argument<'_>;
    let _120: &rocket_http::uri::Origin<'_>;
    let mut _126: std::fmt::Arguments<'_>;
    let mut _127: &[&str];
    let mut _128: &[core::fmt::rt::Argument<'_>];
    let _129: &[core::fmt::rt::Argument<'_>; 1];
    let _130: [core::fmt::rt::Argument<'_>; 1];
    let mut _131: core::fmt::rt::Argument<'_>;
    let _132: &proc_macro2::TokenStream;
    let _133: proc_macro2::TokenStream;
    let _135: ();
    let _136: &&syn::Path;
    let mut _137: &mut proc_macro2::TokenStream;
    let mut _139: devise::Diagnostic;
    let mut _140: proc_macro2::Span;
    let mut _141: &bang::uri_parsing::RoutedUri;
    let mut _142: std::string::String;
    let mut _143: std::string::String;
    let mut _145: std::fmt::Arguments<'_>;
    let mut _146: &[&str];
    let mut _147: &[core::fmt::rt::Argument<'_>];
    let _148: &[core::fmt::rt::Argument<'_>; 1];
    let _149: [core::fmt::rt::Argument<'_>; 1];
    let mut _150: core::fmt::rt::Argument<'_>;
    let _151: &std::string::String;
    let _152: std::string::String;
    let mut _153: bool;
    let mut _154: &std::vec::Vec<&name::Name>;
    let mut _157: (&str, std::string::String);
    let mut _158: std::slice::Iter<'_, &name::Name>;
    let _159: &[&name::Name];
    let mut _160: &std::vec::Vec<&name::Name>;
    let mut _161: devise::Diagnostic;
    let mut _162: devise::Diagnostic;
    let mut _164: std::fmt::Arguments<'_>;
    let mut _165: &[&str];
    let mut _166: &[core::fmt::rt::Argument<'_>];
    let _167: &[core::fmt::rt::Argument<'_>; 2];
    let _168: [core::fmt::rt::Argument<'_>; 2];
    let mut _169: core::fmt::rt::Argument<'_>;
    let _170: &&str;
    let mut _171: core::fmt::rt::Argument<'_>;
    let _172: &std::string::String;
    let mut _173: bool;
    let mut _174: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _177: (&str, std::string::String);
    let mut _178: std::slice::Iter<'_, &proc_macro2::Ident>;
    let _179: &[&proc_macro2::Ident];
    let mut _180: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _182: std::iter::Map<std::slice::Iter<'_, &proc_macro2::Ident>, {closure@core/codegen/src/bang/uri.rs:104:54: 104:61}>;
    let mut _183: std::slice::Iter<'_, &proc_macro2::Ident>;
    let _184: &[&proc_macro2::Ident];
    let mut _185: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _186: devise::Diagnostic;
    let mut _187: devise::Diagnostic;
    let mut _188: std::vec::Vec<proc_macro2::Span>;
    let mut _190: std::fmt::Arguments<'_>;
    let mut _191: &[&str];
    let mut _192: &[core::fmt::rt::Argument<'_>];
    let _193: &[core::fmt::rt::Argument<'_>; 2];
    let _194: [core::fmt::rt::Argument<'_>; 2];
    let mut _195: core::fmt::rt::Argument<'_>;
    let _196: &&str;
    let mut _197: core::fmt::rt::Argument<'_>;
    let _198: &std::string::String;
    let mut _199: bool;
    let mut _200: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _203: (&str, std::string::String);
    let mut _204: std::slice::Iter<'_, &proc_macro2::Ident>;
    let _205: &[&proc_macro2::Ident];
    let mut _206: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _208: std::iter::Map<std::slice::Iter<'_, &proc_macro2::Ident>, {closure@core/codegen/src/bang/uri.rs:110:52: 110:59}>;
    let mut _209: std::slice::Iter<'_, &proc_macro2::Ident>;
    let _210: &[&proc_macro2::Ident];
    let mut _211: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _212: devise::Diagnostic;
    let mut _213: devise::Diagnostic;
    let mut _214: std::vec::Vec<proc_macro2::Span>;
    let mut _216: std::fmt::Arguments<'_>;
    let mut _217: &[&str];
    let mut _218: &[core::fmt::rt::Argument<'_>];
    let _219: &[core::fmt::rt::Argument<'_>; 2];
    let _220: [core::fmt::rt::Argument<'_>; 2];
    let mut _221: core::fmt::rt::Argument<'_>;
    let _222: &&str;
    let mut _223: core::fmt::rt::Argument<'_>;
    let _224: &std::string::String;
    let mut _225: devise::Diagnostic;
    let mut _236: &bang::uri_parsing::ArgExpr;
    let mut _237: bool;
    let mut _238: bool;
    let mut _239: bool;
    let mut _240: bool;
    let mut _241: bool;
    let mut _242: bool;
    let mut _243: bool;
    let mut _244: bool;
    let mut _245: bool;
    let mut _246: bool;
    let mut _247: bool;
    let mut _248: isize;
    let mut _249: isize;
    let mut _250: isize;
    scope 1 {
        debug route_name => _2;
        let _5: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
        let mut _40: std::string::String;
        let mut _43: proc_macro2::TokenStream;
        let _63: usize;
        let _64: usize;
        let _121: std::vec::Vec<&name::Name>;
        let _122: std::vec::Vec<&proc_macro2::Ident>;
        let _123: std::vec::Vec<&proc_macro2::Ident>;
        scope 2 {
            debug exprs => _5;
            let _6: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
            scope 3 {
                debug path_params => _6;
                let _7: usize;
                scope 4 {
                    debug path_param_count => _7;
                    let mut _15: std::iter::Take<std::slice::Iter<'_, &bang::uri_parsing::ArgExpr>>;
                    let _25: std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>;
                    scope 5 {
                        debug iter => _15;
                        let _19: &&bang::uri_parsing::ArgExpr;
                        scope 6 {
                            debug expr => _19;
                        }
                    }
                    scope 7 {
                        debug query_exprs => _25;
                        let _29: std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>;
                        scope 8 {
                            debug path_exprs => _29;
                            let _33: std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>;
                            scope 9 {
                                debug types => _33;
                            }
                        }
                    }
                }
            }
        }
        scope 10 {
            debug route_name => _40;
            let _49: devise::Diagnostic;
            let _53: std::string::String;
            let mut _235: &[&str; 3];
            scope 12 {
                debug diag => _49;
            }
            scope 13 {
                debug res => _53;
            }
        }
        scope 11 {
            debug _s => _43;
        }
        scope 14 {
            debug expected => _63;
            debug actual => _64;
            let mut _65: std::string::String;
            let mut _68: proc_macro2::TokenStream;
            scope 15 {
                debug route_name => _65;
                let _74: devise::Diagnostic;
                let _79: std::string::String;
                let _90: std::string::String;
                let _103: std::string::String;
                let _111: std::string::String;
                let mut _231: &[&str; 3];
                let mut _232: &[&str; 2];
                let mut _233: &[&str; 2];
                let mut _234: &[&str; 3];
                scope 17 {
                    debug diag => _74;
                }
                scope 18 {
                    debug res => _79;
                }
                scope 19 {
                    debug res => _90;
                }
                scope 20 {
                    debug res => _103;
                }
                scope 21 {
                    debug res => _111;
                }
            }
            scope 16 {
                debug _s => _68;
            }
        }
        scope 22 {
            debug missing => _121;
            debug extra => _122;
            debug dup => _123;
            let _124: std::string::String;
            let _125: std::string::String;
            let mut _134: proc_macro2::TokenStream;
            let mut _230: &[&str; 2];
            scope 23 {
                debug e => _124;
                let mut _138: devise::Diagnostic;
                let _144: std::string::String;
                let mut _229: &[&str; 1];
                scope 26 {
                    debug diag => _138;
                    let _155: &str;
                    let _156: std::string::String;
                    let _175: &str;
                    let _176: std::string::String;
                    let _201: &str;
                    let _202: std::string::String;
                    scope 28 {
                        debug ps => _155;
                        debug msg => _156;
                        let _163: std::string::String;
                        let mut _228: &[&str; 2];
                        scope 29 {
                            debug res => _163;
                        }
                    }
                    scope 30 {
                        debug ps => _175;
                        debug msg => _176;
                        let _181: std::vec::Vec<proc_macro2::Span>;
                        scope 31 {
                            debug spans => _181;
                            let _189: std::string::String;
                            let mut _227: &[&str; 2];
                            scope 32 {
                                debug res => _189;
                            }
                        }
                    }
                    scope 33 {
                        debug ps => _201;
                        debug msg => _202;
                        let _207: std::vec::Vec<proc_macro2::Span>;
                        scope 34 {
                            debug spans => _207;
                            let _215: std::string::String;
                            let mut _226: &[&str; 2];
                            scope 35 {
                                debug res => _215;
                            }
                        }
                    }
                }
                scope 27 {
                    debug res => _144;
                }
            }
            scope 24 {
                debug res => _125;
            }
            scope 25 {
                debug _s => _134;
            }
        }
    }

    bb0: {
        _247 = const false;
        _246 = const false;
        _245 = const false;
        _244 = const false;
        _242 = const false;
        _243 = const false;
        _241 = const false;
        _240 = const false;
        _239 = const false;
        _238 = const false;
        _237 = const false;
        _2 = &((((*_1).4: bang::uri_parsing::RoutedUri).1: bang::uri_parsing::RouteInvocation).0: syn::Path);
        _3 = uri_parsing::InternalUriParams::validate(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb30, 1: bb43, 2: bb2, 3: bb4, otherwise: bb3];
    }

    bb2: {
        _121 = move ((_3 as Named).0: std::vec::Vec<&name::Name>);
        _122 = move ((_3 as Named).1: std::vec::Vec<&proc_macro2::Ident>);
        _123 = move ((_3 as Named).2: std::vec::Vec<&proc_macro2::Ident>);
        _230 = const _;
        _127 = _230 as &[&str] (PointerCoercion(Unsize));
        _134 = TokenStream2::new() -> [return: bb74, unwind: bb144];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _247 = const true;
        _5 = move ((_3 as Ok).0: std::vec::Vec<&bang::uri_parsing::ArgExpr>);
        _6 = uri_parsing::InternalUriParams::dynamic_path_params(_1) -> [return: bb5, unwind: bb181];
    }

    bb5: {
        _9 = &_6;
        _8 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}> as Clone>::clone(move _9) -> [return: bb6, unwind: bb181];
    }

    bb6: {
        _7 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}> as Iterator>::count(move _8) -> [return: bb7, unwind: bb181];
    }

    bb7: {
        _14 = &_5;
        _13 = <Vec<&uri_parsing::ArgExpr> as std::ops::Deref>::deref(move _14) -> [return: bb8, unwind: bb181];
    }

    bb8: {
        _12 = core::slice::<impl [&uri_parsing::ArgExpr]>::iter(_13) -> [return: bb9, unwind: bb181];
    }

    bb9: {
        _11 = <std::slice::Iter<'_, &uri_parsing::ArgExpr> as Iterator>::take(move _12, _7) -> [return: bb10, unwind: bb181];
    }

    bb10: {
        _10 = <std::iter::Take<std::slice::Iter<'_, &uri_parsing::ArgExpr>> as IntoIterator>::into_iter(move _11) -> [return: bb11, unwind: bb181];
    }

    bb11: {
        _15 = move _10;
        goto -> bb12;
    }

    bb12: {
        _17 = &mut _15;
        _16 = <std::iter::Take<std::slice::Iter<'_, &uri_parsing::ArgExpr>> as Iterator>::next(_17) -> [return: bb13, unwind: bb181];
    }

    bb13: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb15, 1: bb14, otherwise: bb3];
    }

    bb14: {
        _19 = ((_16 as Some).0: &&bang::uri_parsing::ArgExpr);
        _236 = deref_copy (*_19);
        _22 = uri_parsing::ArgExpr::as_expr(_236) -> [return: bb16, unwind: bb181];
    }

    bb15: {
        _28 = &_5;
        _27 = <Vec<&uri_parsing::ArgExpr> as Clone>::clone(move _28) -> [return: bb21, unwind: bb181];
    }

    bb16: {
        _21 = &_22;
        _20 = Option::<&syn::Expr>::is_some(move _21) -> [return: bb17, unwind: bb181];
    }

    bb17: {
        switchInt(move _20) -> [0: bb18, otherwise: bb12];
    }

    bb18: {
        _24 = <&uri_parsing::ArgExpr as devise::Spanned>::span(_19) -> [return: bb19, unwind: bb181];
    }

    bb19: {
        _23 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _24, const "path parameters cannot be ignored") -> [return: bb20, unwind: bb181];
    }

    bb20: {
        _0 = std::result::Result::<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>::Err(move _23);
        drop(_5) -> [return: bb132, unwind: bb183];
    }

    bb21: {
        _26 = <Vec<&uri_parsing::ArgExpr> as IntoIterator>::into_iter(move _27) -> [return: bb22, unwind: bb181];
    }

    bb22: {
        _25 = <std::vec::IntoIter<&uri_parsing::ArgExpr> as Iterator>::skip(move _26, _7) -> [return: bb23, unwind: bb181];
    }

    bb23: {
        _247 = const false;
        _32 = move _5;
        _31 = <Vec<&uri_parsing::ArgExpr> as IntoIterator>::into_iter(move _32) -> [return: bb24, unwind: bb158];
    }

    bb24: {
        _30 = <std::vec::IntoIter<&uri_parsing::ArgExpr> as Iterator>::map::<&syn::Expr, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>(move _31, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}) -> [return: bb25, unwind: bb158];
    }

    bb25: {
        _29 = <Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}> as Iterator>::take(move _30, _7) -> [return: bb26, unwind: bb158];
    }

    bb26: {
        _36 = &((*_1).3: std::vec::Vec<bang::uri_parsing::FnArg>);
        _35 = <Vec<uri_parsing::FnArg> as std::ops::Deref>::deref(move _36) -> [return: bb27, unwind: bb157];
    }

    bb27: {
        _34 = core::slice::<impl [uri_parsing::FnArg]>::iter(_35) -> [return: bb28, unwind: bb157];
    }

    bb28: {
        _33 = <std::slice::Iter<'_, uri_parsing::FnArg> as Iterator>::map::<(&proc_macro2::Ident, &syn::Type), {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>(move _34, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}) -> [return: bb29, unwind: bb157];
    }

    bb29: {
        _38 = move _29;
        _39 = move _25;
        _37 = (move _38, move _39, move _33);
        _0 = std::result::Result::<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>::Ok(move _37);
        _247 = const false;
        goto -> bb131;
    }

    bb30: {
        _43 = TokenStream2::new() -> [return: bb31, unwind: bb183];
    }

    bb31: {
        _45 = &_2;
        _46 = &mut _43;
        _44 = <&syn::Path as ToTokens>::to_tokens(_45, _46) -> [return: bb32, unwind: bb156];
    }

    bb32: {
        _42 = move _43;
        _41 = &_42;
        _40 = <TokenStream2 as ToString>::to_string(move _41) -> [return: bb33, unwind: bb155];
    }

    bb33: {
        drop(_42) -> [return: bb34, unwind: bb154];
    }

    bb34: {
        _48 = &mut _40;
        _47 = std::string::String::retain::<{closure@core/codegen/src/bang/uri.rs:66:31: 66:34}>(move _48, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:66:31: 66:34}) -> [return: bb35, unwind: bb154];
    }

    bb35: {
        _52 = &((*_1).4: bang::uri_parsing::RoutedUri);
        _51 = RoutedUri::args_span(move _52) -> [return: bb36, unwind: bb154];
    }

    bb36: {
        _50 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _51, const "expected unnamed arguments due to ignored parameters") -> [return: bb37, unwind: bb154];
    }

    bb37: {
        _246 = const true;
        _235 = const _;
        _55 = _235 as &[&str] (PointerCoercion(Unsize));
        _60 = &_40;
        _59 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_60) -> [return: bb38, unwind: bb179];
    }

    bb38: {
        _62 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _61 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Origin<'_>>(_62) -> [return: bb39, unwind: bb179];
    }

    bb39: {
        _58 = [move _59, move _61];
        _57 = &_58;
        _56 = _57 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _54 = std::fmt::Arguments::<'_>::new_v1(move _55, move _56) -> [return: bb40, unwind: bb179];
    }

    bb40: {
        _53 = format(move _54) -> [return: bb41, unwind: bb179];
    }

    bb41: {
        _246 = const false;
        _49 = devise::Diagnostic::note::<std::string::String>(move _50, move _53) -> [return: bb42, unwind: bb179];
    }

    bb42: {
        _246 = const false;
        _0 = std::result::Result::<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>::Err(move _49);
        drop(_40) -> [return: bb131, unwind: bb183];
    }

    bb43: {
        _63 = ((_3 as Unnamed).0: usize);
        _64 = ((_3 as Unnamed).1: usize);
        _68 = TokenStream2::new() -> [return: bb44, unwind: bb183];
    }

    bb44: {
        _70 = &_2;
        _71 = &mut _68;
        _69 = <&syn::Path as ToTokens>::to_tokens(_70, _71) -> [return: bb45, unwind: bb153];
    }

    bb45: {
        _67 = move _68;
        _66 = &_67;
        _65 = <TokenStream2 as ToString>::to_string(move _66) -> [return: bb46, unwind: bb152];
    }

    bb46: {
        drop(_67) -> [return: bb47, unwind: bb151];
    }

    bb47: {
        _73 = &mut _65;
        _72 = std::string::String::retain::<{closure@core/codegen/src/bang/uri.rs:77:31: 77:34}>(move _73, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:77:31: 77:34}) -> [return: bb48, unwind: bb151];
    }

    bb48: {
        _77 = &((*_1).4: bang::uri_parsing::RoutedUri);
        _76 = RoutedUri::args_span(move _77) -> [return: bb49, unwind: bb151];
    }

    bb49: {
        _234 = const _;
        _81 = _234 as &[&str] (PointerCoercion(Unsize));
        _88 = _63;
        switchInt(move _88) -> [1: bb50, otherwise: bb51];
    }

    bb50: {
        _89 = const "1 parameter";
        _87 = <&str as Into<std::string::String>>::into(_89) -> [return: bb184, unwind: bb151];
    }

    bb51: {
        _233 = const _;
        _92 = _233 as &[&str] (PointerCoercion(Unsize));
        _97 = &_63;
        _96 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_97) -> [return: bb52, unwind: bb151];
    }

    bb52: {
        _95 = [move _96];
        _94 = &_95;
        _93 = _94 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _91 = std::fmt::Arguments::<'_>::new_v1(move _92, move _93) -> [return: bb53, unwind: bb151];
    }

    bb53: {
        _90 = format(move _91) -> [return: bb54, unwind: bb151];
    }

    bb54: {
        _87 = move _90;
        goto -> bb55;
    }

    bb55: {
        _86 = &_87;
        _85 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_86) -> [return: bb56, unwind: bb150];
    }

    bb56: {
        _101 = _64;
        switchInt(move _101) -> [1: bb57, otherwise: bb58];
    }

    bb57: {
        _102 = const "1 was";
        _100 = <&str as Into<std::string::String>>::into(_102) -> [return: bb185, unwind: bb150];
    }

    bb58: {
        _232 = const _;
        _105 = _232 as &[&str] (PointerCoercion(Unsize));
        _110 = &_64;
        _109 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_110) -> [return: bb59, unwind: bb150];
    }

    bb59: {
        _108 = [move _109];
        _107 = &_108;
        _106 = _107 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _104 = std::fmt::Arguments::<'_>::new_v1(move _105, move _106) -> [return: bb60, unwind: bb150];
    }

    bb60: {
        _103 = format(move _104) -> [return: bb61, unwind: bb150];
    }

    bb61: {
        _100 = move _103;
        goto -> bb62;
    }

    bb62: {
        _99 = &_100;
        _98 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_99) -> [return: bb63, unwind: bb149];
    }

    bb63: {
        _84 = [move _85, move _98];
        _83 = &_84;
        _82 = _83 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _80 = std::fmt::Arguments::<'_>::new_v1(move _81, move _82) -> [return: bb64, unwind: bb149];
    }

    bb64: {
        _79 = format(move _80) -> [return: bb65, unwind: bb149];
    }

    bb65: {
        drop(_100) -> [return: bb66, unwind: bb147];
    }

    bb66: {
        drop(_87) -> [return: bb67, unwind: bb148];
    }

    bb67: {
        _78 = move _79;
        _75 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _76, move _78) -> [return: bb68, unwind: bb151];
    }

    bb68: {
        _245 = const true;
        _231 = const _;
        _113 = _231 as &[&str] (PointerCoercion(Unsize));
        _118 = &_65;
        _117 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_118) -> [return: bb69, unwind: bb177];
    }

    bb69: {
        _120 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _119 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Origin<'_>>(_120) -> [return: bb70, unwind: bb177];
    }

    bb70: {
        _116 = [move _117, move _119];
        _115 = &_116;
        _114 = _115 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _112 = std::fmt::Arguments::<'_>::new_v1(move _113, move _114) -> [return: bb71, unwind: bb177];
    }

    bb71: {
        _111 = format(move _112) -> [return: bb72, unwind: bb177];
    }

    bb72: {
        _245 = const false;
        _74 = devise::Diagnostic::note::<std::string::String>(move _75, move _111) -> [return: bb73, unwind: bb177];
    }

    bb73: {
        _245 = const false;
        _0 = std::result::Result::<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>::Err(move _74);
        drop(_65) -> [return: bb131, unwind: bb183];
    }

    bb74: {
        _136 = &_2;
        _137 = &mut _134;
        _135 = <&syn::Path as ToTokens>::to_tokens(_136, _137) -> [return: bb75, unwind: bb143];
    }

    bb75: {
        _133 = move _134;
        _132 = &_133;
        _131 = core::fmt::rt::Argument::<'_>::new_display::<TokenStream2>(_132) -> [return: bb76, unwind: bb142];
    }

    bb76: {
        _130 = [move _131];
        _129 = &_130;
        _128 = _129 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _126 = std::fmt::Arguments::<'_>::new_v1(move _127, move _128) -> [return: bb77, unwind: bb142];
    }

    bb77: {
        _125 = format(move _126) -> [return: bb78, unwind: bb142];
    }

    bb78: {
        drop(_133) -> [return: bb79, unwind: bb141];
    }

    bb79: {
        _244 = const true;
        _124 = move _125;
        _141 = &((*_1).4: bang::uri_parsing::RoutedUri);
        _140 = RoutedUri::args_span(move _141) -> [return: bb80, unwind: bb175];
    }

    bb80: {
        _244 = const false;
        _142 = move _124;
        _139 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _140, move _142) -> [return: bb81, unwind: bb175];
    }

    bb81: {
        _243 = const true;
        _229 = const _;
        _146 = _229 as &[&str] (PointerCoercion(Unsize));
        _152 = uri_parsing::InternalUriParams::fn_args_str(_1) -> [return: bb82, unwind: bb173];
    }

    bb82: {
        _151 = &_152;
        _150 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_151) -> [return: bb83, unwind: bb140];
    }

    bb83: {
        _149 = [move _150];
        _148 = &_149;
        _147 = _148 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _145 = std::fmt::Arguments::<'_>::new_v1(move _146, move _147) -> [return: bb84, unwind: bb140];
    }

    bb84: {
        _144 = format(move _145) -> [return: bb85, unwind: bb140];
    }

    bb85: {
        drop(_152) -> [return: bb86, unwind: bb139];
    }

    bb86: {
        _143 = move _144;
        _243 = const false;
        _138 = devise::Diagnostic::note::<std::string::String>(move _139, move _143) -> [return: bb87, unwind: bb173];
    }

    bb87: {
        _242 = const true;
        _243 = const false;
        _154 = &_121;
        _153 = Vec::<&name::Name>::is_empty(move _154) -> [return: bb88, unwind: bb171];
    }

    bb88: {
        switchInt(move _153) -> [0: bb89, otherwise: bb98];
    }

    bb89: {
        _160 = &_121;
        _159 = <Vec<&name::Name> as std::ops::Deref>::deref(move _160) -> [return: bb90, unwind: bb171];
    }

    bb90: {
        _158 = core::slice::<impl [&name::Name]>::iter(_159) -> [return: bb91, unwind: bb171];
    }

    bb91: {
        _157 = extract_exprs::join::<&&name::Name, std::slice::Iter<'_, &name::Name>>(move _158) -> [return: bb92, unwind: bb171];
    }

    bb92: {
        _155 = (_157.0: &str);
        _156 = move (_157.1: std::string::String);
        _242 = const false;
        _241 = const true;
        _162 = move _138;
        _228 = const _;
        _165 = _228 as &[&str] (PointerCoercion(Unsize));
        _170 = &_155;
        _169 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_170) -> [return: bb93, unwind: bb169];
    }

    bb93: {
        _172 = &_156;
        _171 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_172) -> [return: bb94, unwind: bb169];
    }

    bb94: {
        _168 = [move _169, move _171];
        _167 = &_168;
        _166 = _167 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _164 = std::fmt::Arguments::<'_>::new_v1(move _165, move _166) -> [return: bb95, unwind: bb169];
    }

    bb95: {
        _163 = format(move _164) -> [return: bb96, unwind: bb169];
    }

    bb96: {
        _241 = const false;
        _161 = devise::Diagnostic::help::<std::string::String>(move _162, move _163) -> [return: bb97, unwind: bb169];
    }

    bb97: {
        _241 = const false;
        _242 = const true;
        _138 = move _161;
        drop(_156) -> [return: bb98, unwind: bb171];
    }

    bb98: {
        _174 = &_122;
        _173 = Vec::<&proc_macro2::Ident>::is_empty(move _174) -> [return: bb99, unwind: bb171];
    }

    bb99: {
        switchInt(move _173) -> [0: bb100, otherwise: bb113];
    }

    bb100: {
        _180 = &_122;
        _179 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(move _180) -> [return: bb101, unwind: bb171];
    }

    bb101: {
        _178 = core::slice::<impl [&proc_macro2::Ident]>::iter(_179) -> [return: bb102, unwind: bb171];
    }

    bb102: {
        _177 = extract_exprs::join::<&&proc_macro2::Ident, std::slice::Iter<'_, &proc_macro2::Ident>>(move _178) -> [return: bb103, unwind: bb171];
    }

    bb103: {
        _175 = (_177.0: &str);
        _176 = move (_177.1: std::string::String);
        _185 = &_122;
        _184 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(move _185) -> [return: bb104, unwind: bb137];
    }

    bb104: {
        _183 = core::slice::<impl [&proc_macro2::Ident]>::iter(_184) -> [return: bb105, unwind: bb137];
    }

    bb105: {
        _182 = <std::slice::Iter<'_, &proc_macro2::Ident> as Iterator>::map::<proc_macro2::Span, {closure@core/codegen/src/bang/uri.rs:104:54: 104:61}>(move _183, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:104:54: 104:61}) -> [return: bb106, unwind: bb137];
    }

    bb106: {
        _181 = <Map<std::slice::Iter<'_, &proc_macro2::Ident>, {closure@core/codegen/src/bang/uri.rs:104:54: 104:61}> as Iterator>::collect::<Vec<proc_macro2::Span>>(move _182) -> [return: bb107, unwind: bb137];
    }

    bb107: {
        _242 = const false;
        _240 = const true;
        _187 = move _138;
        _239 = const true;
        _188 = move _181;
        _227 = const _;
        _191 = _227 as &[&str] (PointerCoercion(Unsize));
        _196 = &_175;
        _195 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_196) -> [return: bb108, unwind: bb166];
    }

    bb108: {
        _198 = &_176;
        _197 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_198) -> [return: bb109, unwind: bb166];
    }

    bb109: {
        _194 = [move _195, move _197];
        _193 = &_194;
        _192 = _193 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _190 = std::fmt::Arguments::<'_>::new_v1(move _191, move _192) -> [return: bb110, unwind: bb166];
    }

    bb110: {
        _189 = format(move _190) -> [return: bb111, unwind: bb166];
    }

    bb111: {
        _240 = const false;
        _239 = const false;
        _186 = devise::Diagnostic::span_help::<Vec<proc_macro2::Span>, std::string::String>(move _187, move _188, move _189) -> [return: bb112, unwind: bb166];
    }

    bb112: {
        _239 = const false;
        _240 = const false;
        _242 = const true;
        _138 = move _186;
        drop(_176) -> [return: bb113, unwind: bb171];
    }

    bb113: {
        _200 = &_123;
        _199 = Vec::<&proc_macro2::Ident>::is_empty(move _200) -> [return: bb114, unwind: bb171];
    }

    bb114: {
        switchInt(move _199) -> [0: bb115, otherwise: bb128];
    }

    bb115: {
        _206 = &_123;
        _205 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(move _206) -> [return: bb116, unwind: bb171];
    }

    bb116: {
        _204 = core::slice::<impl [&proc_macro2::Ident]>::iter(_205) -> [return: bb117, unwind: bb171];
    }

    bb117: {
        _203 = extract_exprs::join::<&&proc_macro2::Ident, std::slice::Iter<'_, &proc_macro2::Ident>>(move _204) -> [return: bb118, unwind: bb171];
    }

    bb118: {
        _201 = (_203.0: &str);
        _202 = move (_203.1: std::string::String);
        _211 = &_123;
        _210 = <Vec<&proc_macro2::Ident> as std::ops::Deref>::deref(move _211) -> [return: bb119, unwind: bb135];
    }

    bb119: {
        _209 = core::slice::<impl [&proc_macro2::Ident]>::iter(_210) -> [return: bb120, unwind: bb135];
    }

    bb120: {
        _208 = <std::slice::Iter<'_, &proc_macro2::Ident> as Iterator>::map::<proc_macro2::Span, {closure@core/codegen/src/bang/uri.rs:110:52: 110:59}>(move _209, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:110:52: 110:59}) -> [return: bb121, unwind: bb135];
    }

    bb121: {
        _207 = <Map<std::slice::Iter<'_, &proc_macro2::Ident>, {closure@core/codegen/src/bang/uri.rs:110:52: 110:59}> as Iterator>::collect::<Vec<proc_macro2::Span>>(move _208) -> [return: bb122, unwind: bb135];
    }

    bb122: {
        _242 = const false;
        _238 = const true;
        _213 = move _138;
        _237 = const true;
        _214 = move _207;
        _226 = const _;
        _217 = _226 as &[&str] (PointerCoercion(Unsize));
        _222 = &_201;
        _221 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_222) -> [return: bb123, unwind: bb163];
    }

    bb123: {
        _224 = &_202;
        _223 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_224) -> [return: bb124, unwind: bb163];
    }

    bb124: {
        _220 = [move _221, move _223];
        _219 = &_220;
        _218 = _219 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _216 = std::fmt::Arguments::<'_>::new_v1(move _217, move _218) -> [return: bb125, unwind: bb163];
    }

    bb125: {
        _215 = format(move _216) -> [return: bb126, unwind: bb163];
    }

    bb126: {
        _238 = const false;
        _237 = const false;
        _212 = devise::Diagnostic::span_help::<Vec<proc_macro2::Span>, std::string::String>(move _213, move _214, move _215) -> [return: bb127, unwind: bb163];
    }

    bb127: {
        _237 = const false;
        _238 = const false;
        _242 = const true;
        _138 = move _212;
        drop(_202) -> [return: bb128, unwind: bb171];
    }

    bb128: {
        _242 = const false;
        _225 = move _138;
        _0 = std::result::Result::<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>::Err(move _225);
        _242 = const false;
        _244 = const false;
        drop(_123) -> [return: bb129, unwind: bb145];
    }

    bb129: {
        drop(_122) -> [return: bb130, unwind: bb146];
    }

    bb130: {
        drop(_121) -> [return: bb131, unwind: bb183];
    }

    bb131: {
        _248 = discriminant(_3);
        switchInt(move _248) -> [2: bb133, 3: bb133, otherwise: bb160];
    }

    bb132: {
        _247 = const false;
        _249 = discriminant(_3);
        switchInt(move _249) -> [2: bb133, 3: bb133, otherwise: bb161];
    }

    bb133: {
        return;
    }

    bb134 (cleanup): {
        switchInt(_238) -> [0: bb135, otherwise: bb164];
    }

    bb135 (cleanup): {
        drop(_202) -> [return: bb171, unwind terminate(cleanup)];
    }

    bb136 (cleanup): {
        switchInt(_240) -> [0: bb137, otherwise: bb167];
    }

    bb137 (cleanup): {
        drop(_176) -> [return: bb171, unwind terminate(cleanup)];
    }

    bb138 (cleanup): {
        drop(_156) -> [return: bb171, unwind terminate(cleanup)];
    }

    bb139 (cleanup): {
        drop(_144) -> [return: bb173, unwind terminate(cleanup)];
    }

    bb140 (cleanup): {
        drop(_152) -> [return: bb173, unwind terminate(cleanup)];
    }

    bb141 (cleanup): {
        drop(_125) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb142 (cleanup): {
        drop(_133) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb143 (cleanup): {
        drop(_134) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb144 (cleanup): {
        drop(_123) -> [return: bb145, unwind terminate(cleanup)];
    }

    bb145 (cleanup): {
        drop(_122) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb146 (cleanup): {
        drop(_121) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb147 (cleanup): {
        drop(_87) -> [return: bb148, unwind terminate(cleanup)];
    }

    bb148 (cleanup): {
        drop(_79) -> [return: bb151, unwind terminate(cleanup)];
    }

    bb149 (cleanup): {
        drop(_100) -> [return: bb150, unwind terminate(cleanup)];
    }

    bb150 (cleanup): {
        drop(_87) -> [return: bb151, unwind terminate(cleanup)];
    }

    bb151 (cleanup): {
        drop(_65) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb152 (cleanup): {
        drop(_67) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb153 (cleanup): {
        drop(_68) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb154 (cleanup): {
        drop(_40) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb155 (cleanup): {
        drop(_42) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb156 (cleanup): {
        drop(_43) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb157 (cleanup): {
        drop(_29) -> [return: bb158, unwind terminate(cleanup)];
    }

    bb158 (cleanup): {
        drop(_25) -> [return: bb181, unwind terminate(cleanup)];
    }

    bb159 (cleanup): {
        resume;
    }

    bb160: {
        drop(_3) -> [return: bb133, unwind continue];
    }

    bb161: {
        drop(_3) -> [return: bb133, unwind continue];
    }

    bb162 (cleanup): {
        drop(_214) -> [return: bb134, unwind terminate(cleanup)];
    }

    bb163 (cleanup): {
        switchInt(_237) -> [0: bb134, otherwise: bb162];
    }

    bb164 (cleanup): {
        drop(_213) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb165 (cleanup): {
        drop(_188) -> [return: bb136, unwind terminate(cleanup)];
    }

    bb166 (cleanup): {
        switchInt(_239) -> [0: bb136, otherwise: bb165];
    }

    bb167 (cleanup): {
        drop(_187) -> [return: bb137, unwind terminate(cleanup)];
    }

    bb168 (cleanup): {
        drop(_162) -> [return: bb138, unwind terminate(cleanup)];
    }

    bb169 (cleanup): {
        switchInt(_241) -> [0: bb138, otherwise: bb168];
    }

    bb170 (cleanup): {
        drop(_138) -> [return: bb175, unwind terminate(cleanup)];
    }

    bb171 (cleanup): {
        switchInt(_242) -> [0: bb175, otherwise: bb170];
    }

    bb172 (cleanup): {
        drop(_139) -> [return: bb175, unwind terminate(cleanup)];
    }

    bb173 (cleanup): {
        switchInt(_243) -> [0: bb175, otherwise: bb172];
    }

    bb174 (cleanup): {
        drop(_124) -> [return: bb144, unwind terminate(cleanup)];
    }

    bb175 (cleanup): {
        switchInt(_244) -> [0: bb144, otherwise: bb174];
    }

    bb176 (cleanup): {
        drop(_75) -> [return: bb151, unwind terminate(cleanup)];
    }

    bb177 (cleanup): {
        switchInt(_245) -> [0: bb151, otherwise: bb176];
    }

    bb178 (cleanup): {
        drop(_50) -> [return: bb154, unwind terminate(cleanup)];
    }

    bb179 (cleanup): {
        switchInt(_246) -> [0: bb154, otherwise: bb178];
    }

    bb180 (cleanup): {
        drop(_5) -> [return: bb183, unwind terminate(cleanup)];
    }

    bb181 (cleanup): {
        switchInt(_247) -> [0: bb183, otherwise: bb180];
    }

    bb182 (cleanup): {
        drop(_3) -> [return: bb159, unwind terminate(cleanup)];
    }

    bb183 (cleanup): {
        _250 = discriminant(_3);
        switchInt(move _250) -> [2: bb159, 3: bb159, otherwise: bb182];
    }

    bb184: {
        goto -> bb55;
    }

    bb185: {
        goto -> bb62;
    }
}

promoted[0] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "duplicate ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[1] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unknown ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[2] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "missing ", const ": "];
        _0 = &_1;
        return;
    }
}

promoted[3] in extract_exprs: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "uri parameters are: "];
        _0 = &_1;
        return;
    }
}

promoted[4] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "invalid parameters for `", const "` route uri"];
        _0 = &_1;
        return;
    }
}

promoted[5] in extract_exprs: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "route `", const "` has uri \"", const "\""];
        _0 = &_1;
        return;
    }
}

promoted[6] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const " were"];
        _0 = &_1;
        return;
    }
}

promoted[7] in extract_exprs: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const " parameters"];
        _0 = &_1;
        return;
    }
}

promoted[8] in extract_exprs: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "route expects ", const " but ", const " supplied"];
        _0 = &_1;
        return;
    }
}

promoted[9] in extract_exprs: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "uri for route `", const "` ignores path parameters: \"", const "\""];
        _0 = &_1;
        return;
    }
}

fn extract_exprs::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}, _2: &uri_parsing::ArgExpr) -> &syn::Expr {
    debug e => _2;
    let mut _0: &syn::Expr;

    bb0: {
        _0 = uri_parsing::ArgExpr::unwrap_expr(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn extract_exprs::{closure#1}(_1: &mut {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}, _2: &uri_parsing::FnArg) -> (&proc_macro2::Ident, &syn::Type) {
    debug a => _2;
    let mut _0: (&proc_macro2::Ident, &syn::Type);
    let mut _3: &proc_macro2::Ident;
    let mut _4: &syn::Type;

    bb0: {
        _3 = &((*_2).0: proc_macro2::Ident);
        _4 = &((*_2).1: syn::Type);
        _0 = (move _3, move _4);
        return;
    }
}

fn extract_exprs::{closure#2}(_1: &mut {closure@core/codegen/src/bang/uri.rs:66:31: 66:34}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;

    bb0: {
        _3 = char::methods::<impl char>::is_whitespace(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

fn extract_exprs::{closure#3}(_1: &mut {closure@core/codegen/src/bang/uri.rs:77:31: 77:34}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;

    bb0: {
        _3 = char::methods::<impl char>::is_whitespace(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

fn extract_exprs::join(_1: T) -> (&str, std::string::String) {
    debug iter => _1;
    let mut _0: (&str, std::string::String);
    let mut _2: std::vec::Vec<std::string::String>;
    let mut _3: std::iter::Map<T, {closure@core/codegen/src/bang/uri.rs:92:50: 92:53}>;
    let _4: ();
    let mut _5: &mut std::vec::Vec<std::string::String>;
    let mut _6: &str;
    let mut _7: usize;
    let mut _8: &std::vec::Vec<std::string::String>;
    let _9: &str;
    let mut _10: std::string::String;
    let _11: &[std::string::String];
    let mut _12: &std::vec::Vec<std::string::String>;
    let _13: &str;
    scope 1 {
        debug items => _2;
    }

    bb0: {
        _3 = <T as Iterator>::map::<std::string::String, {closure@core/codegen/src/bang/uri.rs:92:50: 92:53}>(move _1, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:92:50: 92:53}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Map<T, {closure@core/codegen/src/bang/uri.rs:92:50: 92:53}> as Iterator>::collect::<Vec<std::string::String>>(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &mut _2;
        _4 = Vec::<std::string::String>::dedup(move _5) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _8 = &_2;
        _7 = Vec::<std::string::String>::len(move _8) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        switchInt(move _7) -> [1: bb5, otherwise: bb6];
    }

    bb5: {
        _9 = const "parameter";
        _6 = <&str as Into<&str>>::into(_9) -> [return: bb13, unwind: bb11];
    }

    bb6: {
        _6 = const "parameters";
        goto -> bb7;
    }

    bb7: {
        _12 = &_2;
        _11 = <Vec<std::string::String> as std::ops::Deref>::deref(move _12) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _13 = const ", ";
        _10 = slice::<impl [std::string::String]>::join::<&str>(_11, _13) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        _0 = (move _6, move _10);
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        goto -> bb7;
    }
}

fn extract_exprs::join::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri.rs:92:50: 92:53}, _2: S) -> std::string::String {
    debug i => _2;
    let mut _0: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &S;
    let mut _10: &[&str; 2];
    scope 1 {
        debug res => _0;
    }

    bb0: {
        _10 = const _;
        _4 = _10 as &[&str] (PointerCoercion(Unsize));
        _9 = &_2;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<S>(_9) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = std::fmt::Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _0 = format(move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

promoted[0] in extract_exprs::join::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "`", const "`"];
        _0 = &_1;
        return;
    }
}

fn extract_exprs::{closure#4}(_1: &mut {closure@core/codegen/src/bang/uri.rs:104:54: 104:61}, _2: &&proc_macro2::Ident) -> proc_macro2::Span {
    debug ident => _2;
    let mut _0: proc_macro2::Span;

    bb0: {
        _0 = <&proc_macro2::Ident as devise::Spanned>::span(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn extract_exprs::{closure#5}(_1: &mut {closure@core/codegen/src/bang/uri.rs:110:52: 110:59}, _2: &&proc_macro2::Ident) -> proc_macro2::Span {
    debug ident => _2;
    let mut _0: proc_macro2::Span;

    bb0: {
        _0 = <&proc_macro2::Ident as devise::Spanned>::span(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn add_binding(_1: &mut Vec<TokenStream2>, _2: &proc_macro2::Ident, _3: &syn::Type, _4: &syn::Expr) -> () {
    debug to => _1;
    debug ident => _2;
    debug ty => _3;
    debug expr => _4;
    let mut _0: ();
    let _5: proc_macro2::Span;
    let mut _6: &syn::Expr;
    let mut _8: rocket_http::uri::fmt::Kind;
    let mut _9: isize;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let mut _27: proc_macro2::Ident;
    let mut _28: &proc_macro2::Ident;
    let mut _29: proc_macro2::Span;
    let mut _30: &syn::Expr;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let _37: &proc_macro2::Ident;
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let _42: &&syn::Expr;
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let mut _51: proc_macro2::Delimiter;
    let mut _52: proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: &str;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let mut _59: proc_macro2::Delimiter;
    let mut _60: proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let _65: ();
    let _66: &proc_macro2::TokenStream;
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let _74: &&proc_macro2::Ident;
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: ();
    let _81: &&syn::Type;
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: &str;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: &str;
    let _93: ();
    let mut _94: &mut proc_macro2::TokenStream;
    let _95: ();
    let _96: &proc_macro2::TokenStream;
    let mut _97: &mut proc_macro2::TokenStream;
    let _98: ();
    let mut _99: &mut proc_macro2::TokenStream;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let _102: ();
    let mut _103: &mut proc_macro2::TokenStream;
    let _104: ();
    let mut _105: &mut proc_macro2::TokenStream;
    let _106: ();
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: &str;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let mut _111: proc_macro2::Delimiter;
    let mut _112: proc_macro2::TokenStream;
    let _114: ();
    let _115: &proc_macro2::Ident;
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: ();
    let mut _118: &mut proc_macro2::TokenStream;
    let mut _122: bool;
    scope 1 {
        debug span => _5;
        let _7: proc_macro2::TokenStream;
        let mut _10: proc_macro2::TokenStream;
        let mut _18: proc_macro2::TokenStream;
        scope 2 {
            debug part => _7;
            let _26: proc_macro2::Ident;
            scope 7 {
                debug tmp_ident => _26;
                let _31: proc_macro2::TokenStream;
                let mut _32: proc_macro2::TokenStream;
                scope 8 {
                    debug let_stmt => _31;
                    let mut _46: proc_macro2::TokenStream;
                    scope 11 {
                        debug _s => _46;
                        scope 12 {
                            debug _span => _5;
                            let mut _53: proc_macro2::TokenStream;
                            let mut _113: proc_macro2::TokenStream;
                            let mut _119: &exports::StaticPath;
                            scope 13 {
                                debug _s => _53;
                                scope 14 {
                                    debug _span => _5;
                                    let mut _61: proc_macro2::TokenStream;
                                    scope 15 {
                                        debug _s => _61;
                                        scope 16 {
                                            debug _span => _5;
                                        }
                                    }
                                }
                            }
                            scope 17 {
                                debug _s => _113;
                                scope 18 {
                                }
                            }
                        }
                    }
                }
                scope 9 {
                    debug _s => _32;
                    scope 10 {
                        debug _span => _5;
                    }
                }
            }
        }
        scope 3 {
            debug _s => _10;
            scope 4 {
                debug _span => _5;
                let mut _121: &exports::StaticPath;
            }
        }
        scope 5 {
            debug _s => _18;
            scope 6 {
                debug _span => _5;
                let mut _120: &exports::StaticPath;
            }
        }
    }

    bb0: {
        _122 = const false;
        _6 = _4;
        _5 = <syn::Expr as devise::Spanned>::span(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = const _;
        _9 = discriminant(_8);
        switchInt(move _9) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _18 = TokenStream2::new() -> [return: bb9, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _10 = TokenStream2::new() -> [return: bb5, unwind continue];
    }

    bb5: {
        _121 = const _;
        _12 = &mut _10;
        _11 = <StaticPath as ToTokens>::to_tokens(_121, _12) -> [return: bb6, unwind: bb65];
    }

    bb6: {
        _14 = &mut _10;
        _13 = push_colon2_spanned(_14, _5) -> [return: bb7, unwind: bb65];
    }

    bb7: {
        _16 = &mut _10;
        _17 = const "Path";
        _15 = push_ident_spanned(_16, _5, _17) -> [return: bb8, unwind: bb65];
    }

    bb8: {
        _7 = move _10;
        goto -> bb13;
    }

    bb9: {
        _120 = const _;
        _20 = &mut _18;
        _19 = <StaticPath as ToTokens>::to_tokens(_120, _20) -> [return: bb10, unwind: bb64];
    }

    bb10: {
        _22 = &mut _18;
        _21 = push_colon2_spanned(_22, _5) -> [return: bb11, unwind: bb64];
    }

    bb11: {
        _24 = &mut _18;
        _25 = const "Query";
        _23 = push_ident_spanned(_24, _5, _25) -> [return: bb12, unwind: bb64];
    }

    bb12: {
        _7 = move _18;
        goto -> bb13;
    }

    bb13: {
        _28 = _2;
        _27 = <proc_macro2::Ident as Clone>::clone(move _28) -> [return: bb14, unwind: bb63];
    }

    bb14: {
        _122 = const true;
        _30 = _4;
        _29 = <syn::Expr as devise::Spanned>::span(move _30) -> [return: bb15, unwind: bb68];
    }

    bb15: {
        _122 = const false;
        _26 = <proc_macro2::Ident as syn_ext::IdentExt>::with_span(move _27, move _29) -> [return: bb16, unwind: bb68];
    }

    bb16: {
        _122 = const false;
        _32 = TokenStream2::new() -> [return: bb17, unwind: bb62];
    }

    bb17: {
        _34 = &mut _32;
        _35 = const "let";
        _33 = push_ident_spanned(_34, _5, _35) -> [return: bb18, unwind: bb61];
    }

    bb18: {
        _37 = &_26;
        _38 = &mut _32;
        _36 = <proc_macro2::Ident as ToTokens>::to_tokens(_37, _38) -> [return: bb19, unwind: bb61];
    }

    bb19: {
        _40 = &mut _32;
        _39 = push_eq_spanned(_40, _5) -> [return: bb20, unwind: bb61];
    }

    bb20: {
        _42 = &_4;
        _43 = &mut _32;
        _41 = <&syn::Expr as ToTokens>::to_tokens(_42, _43) -> [return: bb21, unwind: bb61];
    }

    bb21: {
        _31 = move _32;
        _46 = TokenStream2::new() -> [return: bb22, unwind: bb60];
    }

    bb22: {
        _48 = &mut _46;
        _47 = push_pound_spanned(_48, _5) -> [return: bb23, unwind: bb59];
    }

    bb23: {
        _50 = &mut _46;
        _51 = proc_macro2::Delimiter::Bracket;
        _53 = TokenStream2::new() -> [return: bb24, unwind: bb59];
    }

    bb24: {
        _55 = &mut _53;
        _56 = const "allow";
        _54 = push_ident_spanned(_55, _5, _56) -> [return: bb25, unwind: bb58];
    }

    bb25: {
        _58 = &mut _53;
        _59 = proc_macro2::Delimiter::Parenthesis;
        _61 = TokenStream2::new() -> [return: bb26, unwind: bb58];
    }

    bb26: {
        _63 = &mut _61;
        _64 = const "non_snake_case";
        _62 = push_ident_spanned(_63, _5, _64) -> [return: bb27, unwind: bb57];
    }

    bb27: {
        _60 = move _61;
        _57 = push_group_spanned(_58, _5, move _59, move _60) -> [return: bb28, unwind: bb58];
    }

    bb28: {
        _52 = move _53;
        _49 = push_group_spanned(_50, _5, move _51, move _52) -> [return: bb29, unwind: bb59];
    }

    bb29: {
        _66 = &_31;
        _67 = &mut _46;
        _65 = <TokenStream2 as ToTokens>::to_tokens(_66, _67) -> [return: bb30, unwind: bb59];
    }

    bb30: {
        _69 = &mut _46;
        _68 = push_semi_spanned(_69, _5) -> [return: bb31, unwind: bb59];
    }

    bb31: {
        _71 = &mut _46;
        _72 = const "let";
        _70 = push_ident_spanned(_71, _5, _72) -> [return: bb32, unwind: bb59];
    }

    bb32: {
        _74 = &_2;
        _75 = &mut _46;
        _73 = <&proc_macro2::Ident as ToTokens>::to_tokens(_74, _75) -> [return: bb33, unwind: bb59];
    }

    bb33: {
        _77 = &mut _46;
        _76 = push_eq_spanned(_77, _5) -> [return: bb34, unwind: bb59];
    }

    bb34: {
        _79 = &mut _46;
        _78 = push_lt_spanned(_79, _5) -> [return: bb35, unwind: bb59];
    }

    bb35: {
        _81 = &_3;
        _82 = &mut _46;
        _80 = <&syn::Type as ToTokens>::to_tokens(_81, _82) -> [return: bb36, unwind: bb59];
    }

    bb36: {
        _84 = &mut _46;
        _85 = const "as";
        _83 = push_ident_spanned(_84, _5, _85) -> [return: bb37, unwind: bb59];
    }

    bb37: {
        _119 = const _;
        _87 = &mut _46;
        _86 = <StaticPath as ToTokens>::to_tokens(_119, _87) -> [return: bb38, unwind: bb59];
    }

    bb38: {
        _89 = &mut _46;
        _88 = push_colon2_spanned(_89, _5) -> [return: bb39, unwind: bb59];
    }

    bb39: {
        _91 = &mut _46;
        _92 = const "FromUriParam";
        _90 = push_ident_spanned(_91, _5, _92) -> [return: bb40, unwind: bb59];
    }

    bb40: {
        _94 = &mut _46;
        _93 = push_lt_spanned(_94, _5) -> [return: bb41, unwind: bb59];
    }

    bb41: {
        _96 = &_7;
        _97 = &mut _46;
        _95 = <TokenStream2 as ToTokens>::to_tokens(_96, _97) -> [return: bb42, unwind: bb59];
    }

    bb42: {
        _99 = &mut _46;
        _98 = push_comma_spanned(_99, _5) -> [return: bb43, unwind: bb59];
    }

    bb43: {
        _101 = &mut _46;
        _100 = push_underscore_spanned(_101, _5) -> [return: bb44, unwind: bb59];
    }

    bb44: {
        _103 = &mut _46;
        _102 = push_shr_spanned(_103, _5) -> [return: bb45, unwind: bb59];
    }

    bb45: {
        _105 = &mut _46;
        _104 = push_colon2_spanned(_105, _5) -> [return: bb46, unwind: bb59];
    }

    bb46: {
        _107 = &mut _46;
        _108 = const "from_uri_param";
        _106 = push_ident_spanned(_107, _5, _108) -> [return: bb47, unwind: bb59];
    }

    bb47: {
        _110 = &mut _46;
        _111 = proc_macro2::Delimiter::Parenthesis;
        _113 = TokenStream2::new() -> [return: bb48, unwind: bb59];
    }

    bb48: {
        _115 = &_26;
        _116 = &mut _113;
        _114 = <proc_macro2::Ident as ToTokens>::to_tokens(_115, _116) -> [return: bb49, unwind: bb56];
    }

    bb49: {
        _112 = move _113;
        _109 = push_group_spanned(_110, _5, move _111, move _112) -> [return: bb50, unwind: bb59];
    }

    bb50: {
        _118 = &mut _46;
        _117 = push_semi_spanned(_118, _5) -> [return: bb51, unwind: bb59];
    }

    bb51: {
        _45 = move _46;
        _44 = Vec::<TokenStream2>::push(_1, move _45) -> [return: bb52, unwind: bb60];
    }

    bb52: {
        drop(_31) -> [return: bb53, unwind: bb62];
    }

    bb53: {
        drop(_26) -> [return: bb54, unwind: bb63];
    }

    bb54: {
        drop(_7) -> [return: bb55, unwind continue];
    }

    bb55: {
        return;
    }

    bb56 (cleanup): {
        drop(_113) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_61) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_53) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_46) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_31) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_32) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_26) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_7) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_18) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_10) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        resume;
    }

    bb67 (cleanup): {
        drop(_27) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        switchInt(_122) -> [0: bb63, otherwise: bb67];
    }
}

promoted[0] in add_binding: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in add_binding: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in add_binding: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn explode_path(_1: &uri_parsing::InternalUriParams, _2: &mut Vec<TokenStream2>, _3: impl Iterator<Item = &'a Expr>, _4: impl Iterator<Item = (&'a Ident, &'a Type)>) -> TokenStream2 {
    debug internal => _1;
    debug bindings => _2;
    debug exprs => _3;
    debug args => _4;
    let mut _0: proc_macro2::TokenStream;
    let mut _5: usize;
    let mut _6: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
    let _7: &str;
    let mut _8: &rocket_http::uri::Path<'_>;
    let _9: rocket_http::uri::Path<'_>;
    let mut _10: &rocket_http::uri::Origin<'_>;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let mut _26: proc_macro2::Delimiter;
    let mut _27: proc_macro2::TokenStream;
    let _29: ();
    let _30: &&str;
    let mut _31: &mut proc_macro2::TokenStream;
    let _32: proc_macro2::TokenStream;
    let mut _33: proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: &str;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let mut _53: std::slice::Iter<'_, attribute::param::Parameter>;
    let _54: &[attribute::param::Parameter];
    let mut _55: &std::vec::Vec<attribute::param::Parameter>;
    let mut _56: {closure@core/codegen/src/bang/uri.rs:146:57: 146:64};
    let mut _57: &proc_macro2::TokenStream;
    let mut _58: &mut impl Iterator<Item = (&'a Ident, &'a Type)>;
    let mut _59: &mut impl Iterator<Item = &'a Expr>;
    let mut _60: &mut &mut std::vec::Vec<proc_macro2::TokenStream>;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: &str;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let mut _76: proc_macro2::Delimiter;
    let mut _77: proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let mut _83: proc_macro2::Delimiter;
    let mut _84: proc_macro2::TokenStream;
    let mut _88: (std::iter::Map<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>, quote::__private::HasIterator);
    let mut _90: bool;
    let mut _92: std::option::Option<proc_macro2::TokenStream>;
    let mut _93: &mut std::iter::Map<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>;
    let mut _94: isize;
    let mut _96: bool;
    let mut _97: usize;
    let _98: ();
    let mut _99: &mut proc_macro2::TokenStream;
    let mut _100: (usize, bool);
    let _101: ();
    let _102: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _103: &mut proc_macro2::TokenStream;
    scope 1 {
        debug path => _7;
        let mut _11: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _11;
            let mut _28: proc_macro2::TokenStream;
            let mut _104: &exports::StaticPath;
            scope 3 {
                debug _s => _28;
            }
        }
    }
    scope 4 {
        debug uri_display => _32;
        let _52: std::iter::Map<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>;
        scope 6 {
            debug dyn_exprs => _52;
            let mut _61: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _61;
                let mut _78: proc_macro2::TokenStream;
                let mut _105: &exports::StaticPath;
                scope 8 {
                    debug _s => _78;
                    let mut _85: proc_macro2::TokenStream;
                    scope 9 {
                        debug _s => _85;
                        let mut _86: usize;
                        scope 10 {
                            debug _i => _86;
                            scope 11 {
                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                scope 12 {
                                    debug dyn_exprs => _87;
                                    debug i => const HasIterator;
                                    let _89: quote::__private::HasIterator;
                                    scope 14 {
                                        debug has_iter => const HasIterator;
                                        scope 15 {
                                            let _91: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                            let _95: proc_macro2::TokenStream;
                                            scope 16 {
                                                debug dyn_exprs => _91;
                                            }
                                            scope 17 {
                                                debug _x => _95;
                                            }
                                        }
                                    }
                                }
                                scope 13 {
                                    let mut _87: std::iter::Map<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 5 {
        debug _s => _33;
        let mut _106: &exports::StaticPath;
        let mut _107: &exports::StaticPath;
    }

    bb0: {
        _6 = uri_parsing::InternalUriParams::dynamic_path_params(_1) -> [return: bb1, unwind: bb61];
    }

    bb1: {
        _5 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}> as Iterator>::count(move _6) -> [return: bb2, unwind: bb61];
    }

    bb2: {
        switchInt(move _5) -> [0: bb3, otherwise: bb15];
    }

    bb3: {
        _10 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _9 = rocket_http::uri::Origin::<'_>::path(move _10) -> [return: bb4, unwind: bb61];
    }

    bb4: {
        _8 = &_9;
        _7 = rocket_http::uri::Path::<'_>::as_str(move _8) -> [return: bb5, unwind: bb61];
    }

    bb5: {
        _11 = TokenStream2::new() -> [return: bb6, unwind: bb61];
    }

    bb6: {
        _104 = const _;
        _13 = &mut _11;
        _12 = <StaticPath as ToTokens>::to_tokens(_104, _13) -> [return: bb7, unwind: bb60];
    }

    bb7: {
        _15 = &mut _11;
        _14 = push_colon2(_15) -> [return: bb8, unwind: bb60];
    }

    bb8: {
        _17 = &mut _11;
        _18 = const "UriArgumentsKind";
        _16 = push_ident(_17, _18) -> [return: bb9, unwind: bb60];
    }

    bb9: {
        _20 = &mut _11;
        _19 = push_colon2(_20) -> [return: bb10, unwind: bb60];
    }

    bb10: {
        _22 = &mut _11;
        _23 = const "Static";
        _21 = push_ident(_22, _23) -> [return: bb11, unwind: bb60];
    }

    bb11: {
        _25 = &mut _11;
        _26 = proc_macro2::Delimiter::Parenthesis;
        _28 = TokenStream2::new() -> [return: bb12, unwind: bb60];
    }

    bb12: {
        _30 = &_7;
        _31 = &mut _28;
        _29 = <&str as ToTokens>::to_tokens(_30, _31) -> [return: bb13, unwind: bb59];
    }

    bb13: {
        _27 = move _28;
        _24 = push_group(_25, move _26, move _27) -> [return: bb14, unwind: bb60];
    }

    bb14: {
        _0 = move _11;
        goto -> bb50;
    }

    bb15: {
        _33 = TokenStream2::new() -> [return: bb16, unwind: bb61];
    }

    bb16: {
        _107 = const _;
        _35 = &mut _33;
        _34 = <StaticPath as ToTokens>::to_tokens(_107, _35) -> [return: bb17, unwind: bb58];
    }

    bb17: {
        _37 = &mut _33;
        _36 = push_colon2(_37) -> [return: bb18, unwind: bb58];
    }

    bb18: {
        _39 = &mut _33;
        _40 = const "UriDisplay";
        _38 = push_ident(_39, _40) -> [return: bb19, unwind: bb58];
    }

    bb19: {
        _42 = &mut _33;
        _41 = push_lt(_42) -> [return: bb20, unwind: bb58];
    }

    bb20: {
        _106 = const _;
        _44 = &mut _33;
        _43 = <StaticPath as ToTokens>::to_tokens(_106, _44) -> [return: bb21, unwind: bb58];
    }

    bb21: {
        _46 = &mut _33;
        _45 = push_colon2(_46) -> [return: bb22, unwind: bb58];
    }

    bb22: {
        _48 = &mut _33;
        _49 = const "Path";
        _47 = push_ident(_48, _49) -> [return: bb23, unwind: bb58];
    }

    bb23: {
        _51 = &mut _33;
        _50 = push_gt(_51) -> [return: bb24, unwind: bb58];
    }

    bb24: {
        _32 = move _33;
        _55 = &((*_1).1: std::vec::Vec<attribute::param::Parameter>);
        _54 = <Vec<Parameter> as std::ops::Deref>::deref(move _55) -> [return: bb25, unwind: bb57];
    }

    bb25: {
        _53 = core::slice::<impl [Parameter]>::iter(_54) -> [return: bb26, unwind: bb57];
    }

    bb26: {
        _57 = &_32;
        _58 = &mut _4;
        _59 = &mut _3;
        _60 = &mut _2;
        _56 = {closure@core/codegen/src/bang/uri.rs:146:57: 146:64} { uri_display: move _57, args: move _58, exprs: move _59, bindings: move _60 };
        _52 = <std::slice::Iter<'_, Parameter> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>(move _53, move _56) -> [return: bb27, unwind: bb57];
    }

    bb27: {
        _61 = TokenStream2::new() -> [return: bb28, unwind: bb57];
    }

    bb28: {
        _105 = const _;
        _63 = &mut _61;
        _62 = <StaticPath as ToTokens>::to_tokens(_105, _63) -> [return: bb29, unwind: bb56];
    }

    bb29: {
        _65 = &mut _61;
        _64 = push_colon2(_65) -> [return: bb30, unwind: bb56];
    }

    bb30: {
        _67 = &mut _61;
        _68 = const "UriArgumentsKind";
        _66 = push_ident(_67, _68) -> [return: bb31, unwind: bb56];
    }

    bb31: {
        _70 = &mut _61;
        _69 = push_colon2(_70) -> [return: bb32, unwind: bb56];
    }

    bb32: {
        _72 = &mut _61;
        _73 = const "Dynamic";
        _71 = push_ident(_72, _73) -> [return: bb33, unwind: bb56];
    }

    bb33: {
        _75 = &mut _61;
        _76 = proc_macro2::Delimiter::Parenthesis;
        _78 = TokenStream2::new() -> [return: bb34, unwind: bb56];
    }

    bb34: {
        _80 = &mut _78;
        _79 = push_and(_80) -> [return: bb35, unwind: bb55];
    }

    bb35: {
        _82 = &mut _78;
        _83 = proc_macro2::Delimiter::Bracket;
        _85 = TokenStream2::new() -> [return: bb36, unwind: bb55];
    }

    bb36: {
        _86 = const 0_usize;
        _88 = <Map<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _52) -> [return: bb37, unwind: bb54];
    }

    bb37: {
        _87 = move (_88.0: std::iter::Map<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}>);
        _89 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb64, unwind: bb54];
    }

    bb38: {
        _90 = const true;
        switchInt(move _90) -> [0: bb47, otherwise: bb39];
    }

    bb39: {
        _93 = &mut _87;
        _92 = <Map<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}> as Iterator>::next(move _93) -> [return: bb40, unwind: bb54];
    }

    bb40: {
        _94 = discriminant(_92);
        switchInt(move _94) -> [0: bb47, 1: bb42, otherwise: bb41];
    }

    bb41: {
        unreachable;
    }

    bb42: {
        _95 = move ((_92 as Some).0: proc_macro2::TokenStream);
        _91 = RepInterp::<TokenStream2>(move _95);
        _97 = _86;
        _96 = Gt(move _97, const 0_usize);
        switchInt(move _96) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _99 = &mut _85;
        _98 = push_comma(_99) -> [return: bb65, unwind: bb53];
    }

    bb44: {
        _100 = CheckedAdd(_86, const 1_usize);
        assert(!move (_100.1: bool), "attempt to compute `{} + {}`, which would overflow", _86, const 1_usize) -> [success: bb45, unwind: bb53];
    }

    bb45: {
        _86 = move (_100.0: usize);
        _102 = &_91;
        _103 = &mut _85;
        _101 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_102, _103) -> [return: bb46, unwind: bb53];
    }

    bb46: {
        drop(_91) -> [return: bb38, unwind: bb54];
    }

    bb47: {
        _84 = move _85;
        _81 = push_group(_82, move _83, move _84) -> [return: bb48, unwind: bb55];
    }

    bb48: {
        _77 = move _78;
        _74 = push_group(_75, move _76, move _77) -> [return: bb49, unwind: bb56];
    }

    bb49: {
        _0 = move _61;
        drop(_32) -> [return: bb50, unwind: bb61];
    }

    bb50: {
        drop(_4) -> [return: bb51, unwind: bb62];
    }

    bb51: {
        drop(_3) -> [return: bb52, unwind continue];
    }

    bb52: {
        return;
    }

    bb53 (cleanup): {
        drop(_91) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_85) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_78) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_61) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_32) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_33) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_28) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_11) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_4) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_3) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        resume;
    }

    bb64: {
        goto -> bb38;
    }

    bb65: {
        goto -> bb44;
    }
}

promoted[0] in explode_path: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in explode_path: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in explode_path: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in explode_path: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn explode_path::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri.rs:146:57: 146:64}, _2: &Parameter) -> TokenStream2 {
    debug param => _2;
    debug uri_display => (*((*_1).0: &proc_macro2::TokenStream));
    debug args => (*((*_1).1: &mut impl Iterator<Item = (&'a Ident, &'a Type)>));
    debug exprs => (*((*_1).2: &mut impl Iterator<Item = &'a Expr>));
    debug bindings => (*((*_1).3: &mut &mut std::vec::Vec<proc_macro2::TokenStream>));
    let mut _0: proc_macro2::TokenStream;
    let mut _3: isize;
    let _4: &name::Name;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let _9: &&name::Name;
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: &proc_macro2::Ident;
    let _22: &syn::Type;
    let mut _23: (&proc_macro2::Ident, &syn::Type);
    let mut _24: std::option::Option<(&proc_macro2::Ident, &syn::Type)>;
    let _25: &str;
    let mut _27: std::option::Option<&syn::Expr>;
    let _28: &str;
    let _29: ();
    let _30: &&proc_macro2::Ident;
    let _31: &&syn::Type;
    let _32: &&syn::Expr;
    let mut _35: &syn::Expr;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let _39: &&proc_macro2::Ident;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: &str;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &syn::Expr;
    let mut _52: std::option::Option<&syn::Expr>;
    let _53: &str;
    let mut _56: &syn::Expr;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let _60: &&syn::Expr;
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: ();
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: &str;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: ();
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: &str;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let mut _72: &mut impl Iterator<Item = &'a Expr>;
    let mut _73: &proc_macro2::TokenStream;
    let mut _74: &mut impl Iterator<Item = (&'a Ident, &'a Type)>;
    let mut _75: &mut impl Iterator<Item = &'a Expr>;
    let mut _76: &mut &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _77: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _78: &proc_macro2::Ident;
    let mut _79: &syn::Type;
    let mut _80: &syn::Expr;
    let mut _81: &proc_macro2::TokenStream;
    let mut _82: &proc_macro2::TokenStream;
    scope 1 {
        debug name => _4;
        let mut _5: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _5;
        }
    }
    scope 3 {
        debug ident => _21;
        debug ty => _22;
        let _26: &syn::Expr;
        scope 4 {
            debug expr => _26;
            let mut _33: proc_macro2::TokenStream;
            scope 5 {
                debug _s => _33;
                let _34: proc_macro2::Span;
                scope 6 {
                    debug _span => _34;
                }
            }
        }
    }
    scope 7 {
        debug expr => _51;
        let mut _54: proc_macro2::TokenStream;
        scope 8 {
            debug _s => _54;
            let _55: proc_macro2::Span;
            scope 9 {
                debug _span => _55;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [0: bb3, 1: bb1, 2: bb11, 3: bb11, otherwise: bb2];
    }

    bb1: {
        _72 = deref_copy ((*_1).2: &mut impl Iterator<Item = &'a Expr>);
        _52 = <impl Iterator<Item = &'a Expr> as Iterator>::next(_72) -> [return: bb25, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_2) as Static).0: name::Name);
        _5 = TokenStream2::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = &mut _5;
        _6 = push_and(_7) -> [return: bb5, unwind: bb38];
    }

    bb5: {
        _9 = &_4;
        _10 = &mut _5;
        _8 = <&name::Name as ToTokens>::to_tokens(_9, _10) -> [return: bb6, unwind: bb38];
    }

    bb6: {
        _12 = &mut _5;
        _13 = const "as";
        _11 = push_ident(_12, _13) -> [return: bb7, unwind: bb38];
    }

    bb7: {
        _15 = &mut _5;
        _14 = push_and(_15) -> [return: bb8, unwind: bb38];
    }

    bb8: {
        _17 = &mut _5;
        _18 = const "dyn";
        _16 = push_ident(_17, _18) -> [return: bb9, unwind: bb38];
    }

    bb9: {
        _73 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _20 = &mut _5;
        _19 = <TokenStream2 as ToTokens>::to_tokens(_73, _20) -> [return: bb10, unwind: bb38];
    }

    bb10: {
        _0 = move _5;
        goto -> bb35;
    }

    bb11: {
        _74 = deref_copy ((*_1).1: &mut impl Iterator<Item = (&'a Ident, &'a Type)>);
        _24 = <impl Iterator<Item = (&'a Ident, &'a Type)> as Iterator>::next(_74) -> [return: bb12, unwind continue];
    }

    bb12: {
        _25 = const "ident/ty for non-ignored";
        _23 = Option::<(&proc_macro2::Ident, &syn::Type)>::expect(move _24, _25) -> [return: bb13, unwind continue];
    }

    bb13: {
        _21 = (_23.0: &proc_macro2::Ident);
        _22 = (_23.1: &syn::Type);
        _75 = deref_copy ((*_1).2: &mut impl Iterator<Item = &'a Expr>);
        _27 = <impl Iterator<Item = &'a Expr> as Iterator>::next(_75) -> [return: bb14, unwind continue];
    }

    bb14: {
        _28 = const "one expr per dynamic arg";
        _26 = Option::<&syn::Expr>::expect(move _27, _28) -> [return: bb15, unwind continue];
    }

    bb15: {
        _76 = deref_copy ((*_1).3: &mut &mut std::vec::Vec<proc_macro2::TokenStream>);
        _77 = deref_copy (*_76);
        _30 = &_21;
        _78 = deref_copy (*_30);
        _31 = &_22;
        _79 = deref_copy (*_31);
        _32 = &_26;
        _80 = deref_copy (*_32);
        _29 = add_binding::<rocket_http::uri::fmt::Path>(_77, _78, _79, _80) -> [return: bb16, unwind continue];
    }

    bb16: {
        _33 = TokenStream2::new() -> [return: bb17, unwind continue];
    }

    bb17: {
        _35 = _26;
        _34 = <syn::Expr as devise::Spanned>::span(move _35) -> [return: bb18, unwind: bb37];
    }

    bb18: {
        _37 = &mut _33;
        _36 = push_and_spanned(_37, _34) -> [return: bb19, unwind: bb37];
    }

    bb19: {
        _39 = &_21;
        _40 = &mut _33;
        _38 = <&proc_macro2::Ident as ToTokens>::to_tokens(_39, _40) -> [return: bb20, unwind: bb37];
    }

    bb20: {
        _42 = &mut _33;
        _43 = const "as";
        _41 = push_ident_spanned(_42, _34, _43) -> [return: bb21, unwind: bb37];
    }

    bb21: {
        _45 = &mut _33;
        _44 = push_and_spanned(_45, _34) -> [return: bb22, unwind: bb37];
    }

    bb22: {
        _47 = &mut _33;
        _48 = const "dyn";
        _46 = push_ident_spanned(_47, _34, _48) -> [return: bb23, unwind: bb37];
    }

    bb23: {
        _81 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _50 = &mut _33;
        _49 = <TokenStream2 as ToTokens>::to_tokens(_81, _50) -> [return: bb24, unwind: bb37];
    }

    bb24: {
        _0 = move _33;
        goto -> bb35;
    }

    bb25: {
        _53 = const "one expr per dynamic arg";
        _51 = Option::<&syn::Expr>::expect(move _52, _53) -> [return: bb26, unwind continue];
    }

    bb26: {
        _54 = TokenStream2::new() -> [return: bb27, unwind continue];
    }

    bb27: {
        _56 = _51;
        _55 = <syn::Expr as devise::Spanned>::span(move _56) -> [return: bb28, unwind: bb36];
    }

    bb28: {
        _58 = &mut _54;
        _57 = push_and_spanned(_58, _55) -> [return: bb29, unwind: bb36];
    }

    bb29: {
        _60 = &_51;
        _61 = &mut _54;
        _59 = <&syn::Expr as ToTokens>::to_tokens(_60, _61) -> [return: bb30, unwind: bb36];
    }

    bb30: {
        _63 = &mut _54;
        _64 = const "as";
        _62 = push_ident_spanned(_63, _55, _64) -> [return: bb31, unwind: bb36];
    }

    bb31: {
        _66 = &mut _54;
        _65 = push_and_spanned(_66, _55) -> [return: bb32, unwind: bb36];
    }

    bb32: {
        _68 = &mut _54;
        _69 = const "dyn";
        _67 = push_ident_spanned(_68, _55, _69) -> [return: bb33, unwind: bb36];
    }

    bb33: {
        _82 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _71 = &mut _54;
        _70 = <TokenStream2 as ToTokens>::to_tokens(_82, _71) -> [return: bb34, unwind: bb36];
    }

    bb34: {
        _0 = move _54;
        goto -> bb35;
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_54) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_33) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_5) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        resume;
    }
}

fn explode_query(_1: &uri_parsing::InternalUriParams, _2: &mut Vec<TokenStream2>, _3: impl Iterator<Item = &'a ArgExpr>, _4: impl Iterator<Item = (&'a Ident, &'a Type)>) -> Option<TokenStream2> {
    debug internal => _1;
    debug bindings => _2;
    debug arg_exprs => _3;
    debug args => _4;
    let mut _0: std::option::Option<proc_macro2::TokenStream>;
    let _5: &str;
    let mut _6: &rocket_http::uri::Query<'_>;
    let _7: rocket_http::uri::Query<'_>;
    let mut _8: std::ops::ControlFlow<std::option::Option<std::convert::Infallible>, rocket_http::uri::Query<'_>>;
    let mut _9: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _10: &rocket_http::uri::Origin<'_>;
    let mut _11: isize;
    let _12: rocket_http::uri::Query<'_>;
    let mut _13: usize;
    let mut _14: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>;
    let mut _15: proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let mut _31: proc_macro2::Delimiter;
    let mut _32: proc_macro2::TokenStream;
    let _34: ();
    let _35: &&str;
    let mut _36: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: &str;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let mut _67: std::slice::Iter<'_, attribute::param::Parameter>;
    let _68: &[attribute::param::Parameter];
    let mut _69: &std::vec::Vec<attribute::param::Parameter>;
    let mut _70: {closure@core/codegen/src/bang/uri.rs:181:61: 181:68};
    let mut _71: &proc_macro2::TokenStream;
    let mut _72: &mut impl Iterator<Item = (&'a Ident, &'a Type)>;
    let mut _73: &mut impl Iterator<Item = &'a ArgExpr>;
    let mut _74: &mut &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _75: &proc_macro2::TokenStream;
    let mut _76: proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: ();
    let mut _81: &mut proc_macro2::TokenStream;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: &str;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: &str;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let mut _92: proc_macro2::Delimiter;
    let mut _93: proc_macro2::TokenStream;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let mut _99: proc_macro2::Delimiter;
    let mut _100: proc_macro2::TokenStream;
    let mut _104: (std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>, quote::__private::HasIterator);
    let mut _106: bool;
    let mut _108: std::option::Option<proc_macro2::TokenStream>;
    let mut _109: &mut std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>;
    let mut _110: isize;
    let mut _112: bool;
    let mut _113: usize;
    let _114: ();
    let mut _115: &mut proc_macro2::TokenStream;
    let mut _116: (usize, bool);
    let _117: ();
    let _118: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _119: &mut proc_macro2::TokenStream;
    scope 1 {
        debug query => _5;
        let mut _16: proc_macro2::TokenStream;
        let _37: proc_macro2::TokenStream;
        let mut _38: proc_macro2::TokenStream;
        scope 6 {
            debug _s => _16;
            let mut _33: proc_macro2::TokenStream;
            let mut _120: &exports::StaticPath;
            scope 7 {
                debug _s => _33;
            }
        }
        scope 8 {
            debug query_arg => _37;
            let _46: proc_macro2::TokenStream;
            let mut _47: proc_macro2::TokenStream;
            scope 10 {
                debug uri_display => _46;
                let _66: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>;
                scope 12 {
                    debug dyn_exprs => _66;
                    let mut _77: proc_macro2::TokenStream;
                    scope 13 {
                        debug _s => _77;
                        let mut _94: proc_macro2::TokenStream;
                        let mut _121: &exports::StaticPath;
                        scope 14 {
                            debug _s => _94;
                            let mut _101: proc_macro2::TokenStream;
                            scope 15 {
                                debug _s => _101;
                                let mut _102: usize;
                                scope 16 {
                                    debug _i => _102;
                                    scope 17 {
                                        debug has_iter => const ThereIsNoIteratorInRepetition;
                                        scope 18 {
                                            debug dyn_exprs => _103;
                                            debug i => const HasIterator;
                                            let _105: quote::__private::HasIterator;
                                            scope 20 {
                                                debug has_iter => const HasIterator;
                                                scope 21 {
                                                    let _107: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                                    let _111: proc_macro2::TokenStream;
                                                    scope 22 {
                                                        debug dyn_exprs => _107;
                                                    }
                                                    scope 23 {
                                                        debug _x => _111;
                                                    }
                                                }
                                            }
                                        }
                                        scope 19 {
                                            let mut _103: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 11 {
                debug _s => _47;
                let mut _122: &exports::StaticPath;
                let mut _123: &exports::StaticPath;
            }
        }
        scope 9 {
            debug _s => _38;
            let mut _124: &exports::StaticPath;
        }
    }
    scope 2 {
        debug residual => const Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _10 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _9 = rocket_http::uri::Origin::<'_>::query(move _10) -> [return: bb1, unwind: bb73];
    }

    bb1: {
        _8 = <Option<rocket_http::uri::Query<'_>> as std::ops::Try>::branch(move _9) -> [return: bb2, unwind: bb73];
    }

    bb2: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _12 = ((_8 as Continue).0: rocket_http::uri::Query<'_>);
        _7 = _12;
        _6 = &_7;
        _5 = rocket_http::uri::Query::<'_>::as_str(move _6) -> [return: bb6, unwind: bb73];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _0 = <Option<TokenStream2> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb76, unwind: bb73];
    }

    bb6: {
        _14 = uri_parsing::InternalUriParams::dynamic_query_params(_1) -> [return: bb7, unwind: bb73];
    }

    bb7: {
        _13 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}> as Iterator>::count(move _14) -> [return: bb8, unwind: bb73];
    }

    bb8: {
        switchInt(move _13) -> [0: bb9, otherwise: bb19];
    }

    bb9: {
        _16 = TokenStream2::new() -> [return: bb10, unwind: bb73];
    }

    bb10: {
        _120 = const _;
        _18 = &mut _16;
        _17 = <StaticPath as ToTokens>::to_tokens(_120, _18) -> [return: bb11, unwind: bb72];
    }

    bb11: {
        _20 = &mut _16;
        _19 = push_colon2(_20) -> [return: bb12, unwind: bb72];
    }

    bb12: {
        _22 = &mut _16;
        _23 = const "UriArgumentsKind";
        _21 = push_ident(_22, _23) -> [return: bb13, unwind: bb72];
    }

    bb13: {
        _25 = &mut _16;
        _24 = push_colon2(_25) -> [return: bb14, unwind: bb72];
    }

    bb14: {
        _27 = &mut _16;
        _28 = const "Static";
        _26 = push_ident(_27, _28) -> [return: bb15, unwind: bb72];
    }

    bb15: {
        _30 = &mut _16;
        _31 = proc_macro2::Delimiter::Parenthesis;
        _33 = TokenStream2::new() -> [return: bb16, unwind: bb72];
    }

    bb16: {
        _35 = &_5;
        _36 = &mut _33;
        _34 = <&str as ToTokens>::to_tokens(_35, _36) -> [return: bb17, unwind: bb71];
    }

    bb17: {
        _32 = move _33;
        _29 = push_group(_30, move _31, move _32) -> [return: bb18, unwind: bb72];
    }

    bb18: {
        _15 = move _16;
        _0 = Option::<TokenStream2>::Some(move _15);
        goto -> bb60;
    }

    bb19: {
        _38 = TokenStream2::new() -> [return: bb20, unwind: bb73];
    }

    bb20: {
        _124 = const _;
        _40 = &mut _38;
        _39 = <StaticPath as ToTokens>::to_tokens(_124, _40) -> [return: bb21, unwind: bb70];
    }

    bb21: {
        _42 = &mut _38;
        _41 = push_colon2(_42) -> [return: bb22, unwind: bb70];
    }

    bb22: {
        _44 = &mut _38;
        _45 = const "UriQueryArgument";
        _43 = push_ident(_44, _45) -> [return: bb23, unwind: bb70];
    }

    bb23: {
        _37 = move _38;
        _47 = TokenStream2::new() -> [return: bb24, unwind: bb69];
    }

    bb24: {
        _123 = const _;
        _49 = &mut _47;
        _48 = <StaticPath as ToTokens>::to_tokens(_123, _49) -> [return: bb25, unwind: bb68];
    }

    bb25: {
        _51 = &mut _47;
        _50 = push_colon2(_51) -> [return: bb26, unwind: bb68];
    }

    bb26: {
        _53 = &mut _47;
        _54 = const "UriDisplay";
        _52 = push_ident(_53, _54) -> [return: bb27, unwind: bb68];
    }

    bb27: {
        _56 = &mut _47;
        _55 = push_lt(_56) -> [return: bb28, unwind: bb68];
    }

    bb28: {
        _122 = const _;
        _58 = &mut _47;
        _57 = <StaticPath as ToTokens>::to_tokens(_122, _58) -> [return: bb29, unwind: bb68];
    }

    bb29: {
        _60 = &mut _47;
        _59 = push_colon2(_60) -> [return: bb30, unwind: bb68];
    }

    bb30: {
        _62 = &mut _47;
        _63 = const "Query";
        _61 = push_ident(_62, _63) -> [return: bb31, unwind: bb68];
    }

    bb31: {
        _65 = &mut _47;
        _64 = push_gt(_65) -> [return: bb32, unwind: bb68];
    }

    bb32: {
        _46 = move _47;
        _69 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _68 = <Vec<Parameter> as std::ops::Deref>::deref(move _69) -> [return: bb33, unwind: bb67];
    }

    bb33: {
        _67 = core::slice::<impl [Parameter]>::iter(_68) -> [return: bb34, unwind: bb67];
    }

    bb34: {
        _71 = &_37;
        _72 = &mut _4;
        _73 = &mut _3;
        _74 = &mut _2;
        _75 = &_46;
        _70 = {closure@core/codegen/src/bang/uri.rs:181:61: 181:68} { query_arg: move _71, args: move _72, arg_exprs: move _73, bindings: move _74, uri_display: move _75 };
        _66 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<TokenStream2, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>(move _67, move _70) -> [return: bb35, unwind: bb67];
    }

    bb35: {
        _77 = TokenStream2::new() -> [return: bb36, unwind: bb67];
    }

    bb36: {
        _121 = const _;
        _79 = &mut _77;
        _78 = <StaticPath as ToTokens>::to_tokens(_121, _79) -> [return: bb37, unwind: bb66];
    }

    bb37: {
        _81 = &mut _77;
        _80 = push_colon2(_81) -> [return: bb38, unwind: bb66];
    }

    bb38: {
        _83 = &mut _77;
        _84 = const "UriArgumentsKind";
        _82 = push_ident(_83, _84) -> [return: bb39, unwind: bb66];
    }

    bb39: {
        _86 = &mut _77;
        _85 = push_colon2(_86) -> [return: bb40, unwind: bb66];
    }

    bb40: {
        _88 = &mut _77;
        _89 = const "Dynamic";
        _87 = push_ident(_88, _89) -> [return: bb41, unwind: bb66];
    }

    bb41: {
        _91 = &mut _77;
        _92 = proc_macro2::Delimiter::Parenthesis;
        _94 = TokenStream2::new() -> [return: bb42, unwind: bb66];
    }

    bb42: {
        _96 = &mut _94;
        _95 = push_and(_96) -> [return: bb43, unwind: bb65];
    }

    bb43: {
        _98 = &mut _94;
        _99 = proc_macro2::Delimiter::Bracket;
        _101 = TokenStream2::new() -> [return: bb44, unwind: bb65];
    }

    bb44: {
        _102 = const 0_usize;
        _104 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _66) -> [return: bb45, unwind: bb64];
    }

    bb45: {
        _103 = move (_104.0: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}>);
        _105 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb77, unwind: bb64];
    }

    bb46: {
        _106 = const true;
        switchInt(move _106) -> [0: bb54, otherwise: bb47];
    }

    bb47: {
        _109 = &mut _103;
        _108 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}> as Iterator>::next(move _109) -> [return: bb48, unwind: bb64];
    }

    bb48: {
        _110 = discriminant(_108);
        switchInt(move _110) -> [0: bb54, 1: bb49, otherwise: bb4];
    }

    bb49: {
        _111 = move ((_108 as Some).0: proc_macro2::TokenStream);
        _107 = RepInterp::<TokenStream2>(move _111);
        _113 = _102;
        _112 = Gt(move _113, const 0_usize);
        switchInt(move _112) -> [0: bb51, otherwise: bb50];
    }

    bb50: {
        _115 = &mut _101;
        _114 = push_comma(_115) -> [return: bb78, unwind: bb63];
    }

    bb51: {
        _116 = CheckedAdd(_102, const 1_usize);
        assert(!move (_116.1: bool), "attempt to compute `{} + {}`, which would overflow", _102, const 1_usize) -> [success: bb52, unwind: bb63];
    }

    bb52: {
        _102 = move (_116.0: usize);
        _118 = &_107;
        _119 = &mut _101;
        _117 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_118, _119) -> [return: bb53, unwind: bb63];
    }

    bb53: {
        drop(_107) -> [return: bb46, unwind: bb64];
    }

    bb54: {
        _100 = move _101;
        _97 = push_group(_98, move _99, move _100) -> [return: bb55, unwind: bb65];
    }

    bb55: {
        _93 = move _94;
        _90 = push_group(_91, move _92, move _93) -> [return: bb56, unwind: bb66];
    }

    bb56: {
        _76 = move _77;
        _0 = Option::<TokenStream2>::Some(move _76);
        drop(_46) -> [return: bb57, unwind: bb69];
    }

    bb57: {
        drop(_37) -> [return: bb58, unwind: bb73];
    }

    bb58: {
        drop(_4) -> [return: bb59, unwind: bb74];
    }

    bb59: {
        drop(_3) -> [return: bb62, unwind continue];
    }

    bb60: {
        drop(_4) -> [return: bb61, unwind: bb74];
    }

    bb61: {
        drop(_3) -> [return: bb62, unwind continue];
    }

    bb62: {
        return;
    }

    bb63 (cleanup): {
        drop(_107) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_101) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_94) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_77) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        drop(_46) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop(_47) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        drop(_37) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        drop(_38) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        drop(_33) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        drop(_16) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        drop(_4) -> [return: bb74, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        drop(_3) -> [return: bb75, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        resume;
    }

    bb76: {
        goto -> bb60;
    }

    bb77: {
        goto -> bb46;
    }

    bb78: {
        goto -> bb51;
    }
}

promoted[0] in explode_query: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in explode_query: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in explode_query: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in explode_query: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in explode_query: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn explode_query::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri.rs:181:61: 181:68}, _2: &Parameter) -> Option<TokenStream2> {
    debug param => _2;
    debug query_arg => (*((*_1).0: &proc_macro2::TokenStream));
    debug args => (*((*_1).1: &mut impl Iterator<Item = (&'a Ident, &'a Type)>));
    debug arg_exprs => (*((*_1).2: &mut impl Iterator<Item = &'a ArgExpr>));
    debug bindings => (*((*_1).3: &mut &mut std::vec::Vec<proc_macro2::TokenStream>));
    debug uri_display => (*((*_1).4: &proc_macro2::TokenStream));
    let mut _0: std::option::Option<proc_macro2::TokenStream>;
    let mut _3: isize;
    let mut _5: proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::Delimiter;
    let mut _17: proc_macro2::TokenStream;
    let _19: ();
    let _20: &&name::Name;
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &attribute::param::Dynamic;
    let mut _23: isize;
    let _24: &name::Name;
    let mut _25: proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: &str;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let mut _36: proc_macro2::Delimiter;
    let mut _37: proc_macro2::TokenStream;
    let _39: ();
    let _40: &&name::Name;
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: &attribute::param::Dynamic;
    let _43: &attribute::param::Guard;
    let _44: &attribute::param::Dynamic;
    let _45: !;
    let mut _48: (&proc_macro2::Ident, &syn::Type);
    let mut _49: std::option::Option<(&proc_macro2::Ident, &syn::Type)>;
    let _50: &str;
    let mut _52: std::option::Option<&bang::uri_parsing::ArgExpr>;
    let _53: &str;
    let mut _55: std::option::Option<&syn::Expr>;
    let mut _56: isize;
    let _58: ();
    let mut _59: proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: ();
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: &str;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: ();
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: &str;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let _84: &&syn::Type;
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let mut _90: proc_macro2::Delimiter;
    let mut _91: proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let mut _94: &proc_macro2::TokenStream;
    let mut _95: proc_macro2::Span;
    let _97: ();
    let _98: &&proc_macro2::Ident;
    let _99: &&syn::Type;
    let _100: &&syn::Expr;
    let mut _101: proc_macro2::TokenStream;
    let mut _104: &syn::Expr;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: ();
    let mut _110: &mut proc_macro2::TokenStream;
    let _111: &str;
    let _112: ();
    let mut _113: &mut proc_macro2::TokenStream;
    let mut _114: proc_macro2::Delimiter;
    let mut _115: proc_macro2::TokenStream;
    let _117: ();
    let _118: &&name::Name;
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: ();
    let mut _121: &mut proc_macro2::TokenStream;
    let _122: ();
    let mut _123: &mut proc_macro2::TokenStream;
    let _124: ();
    let _125: &&proc_macro2::Ident;
    let mut _126: &mut proc_macro2::TokenStream;
    let _127: ();
    let mut _128: &mut proc_macro2::TokenStream;
    let _129: &str;
    let _130: ();
    let mut _131: &mut proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: &str;
    let _135: ();
    let mut _136: &mut proc_macro2::TokenStream;
    let mut _139: &syn::Expr;
    let _140: ();
    let mut _141: &mut proc_macro2::TokenStream;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let _146: &str;
    let _147: ();
    let mut _148: &mut proc_macro2::TokenStream;
    let mut _149: proc_macro2::Delimiter;
    let mut _150: proc_macro2::TokenStream;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: ();
    let _155: &&proc_macro2::Ident;
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let _159: &str;
    let _160: ();
    let mut _161: &mut proc_macro2::TokenStream;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: &str;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let mut _167: &&str;
    let mut _170: &proc_macro2::TokenStream;
    let mut _171: &proc_macro2::TokenStream;
    let mut _172: &mut impl Iterator<Item = (&'a Ident, &'a Type)>;
    let mut _173: &mut impl Iterator<Item = &'a ArgExpr>;
    let mut _174: &mut &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _175: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _176: &mut &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _177: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _178: &proc_macro2::Ident;
    let mut _179: &syn::Type;
    let mut _180: &syn::Expr;
    let mut _181: &proc_macro2::TokenStream;
    let mut _182: &proc_macro2::TokenStream;
    let mut _183: &proc_macro2::TokenStream;
    let mut _184: &proc_macro2::TokenStream;
    scope 1 {
        debug source => _4;
        let _4: &name::Name;
        let mut _6: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _6;
            let mut _18: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _18;
            }
        }
    }
    scope 4 {
        debug dynamic => _22;
        let _46: &proc_macro2::Ident;
        let _47: &syn::Type;
        scope 10 {
            debug ident => _46;
            debug ty => _47;
            let _51: &bang::uri_parsing::ArgExpr;
            scope 11 {
                debug arg_expr => _51;
                let _54: &syn::Expr;
                let _57: &syn::Expr;
                let _60: proc_macro2::TokenStream;
                let mut _61: proc_macro2::TokenStream;
                scope 12 {
                    debug expr => _54;
                    let _96: &name::Name;
                    scope 18 {
                        debug name => _96;
                        let mut _102: proc_macro2::TokenStream;
                        let mut _137: proc_macro2::TokenStream;
                        scope 19 {
                            debug _s => _102;
                            let _103: proc_macro2::Span;
                            scope 20 {
                                debug _span => _103;
                                let mut _116: proc_macro2::TokenStream;
                                scope 21 {
                                    debug _s => _116;
                                    scope 22 {
                                        debug _span => _103;
                                    }
                                }
                            }
                        }
                        scope 23 {
                            debug _s => _137;
                            let _138: proc_macro2::Span;
                            scope 24 {
                                debug _span => _138;
                                let mut _151: proc_macro2::TokenStream;
                                scope 25 {
                                    debug _s => _151;
                                    scope 26 {
                                        debug _span => _138;
                                    }
                                }
                            }
                        }
                    }
                }
                scope 13 {
                    debug expr => _57;
                }
                scope 14 {
                    debug tokens => _60;
                }
                scope 15 {
                    debug _s => _61;
                    let _62: proc_macro2::Span;
                    scope 16 {
                        debug _span => _62;
                        let mut _168: &exports::StaticPath;
                        let mut _169: &exports::StaticPath;
                        scope 17 {
                        }
                    }
                }
            }
        }
    }
    scope 5 {
        debug source => _24;
        let mut _26: proc_macro2::TokenStream;
        scope 6 {
            debug _s => _26;
            let mut _38: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _38;
            }
        }
    }
    scope 8 {
        debug seg => _42;
    }
    scope 9 {
        debug seg => _43;
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [0: bb1, otherwise: bb9];
    }

    bb1: {
        _4 = &(((*_2) as Static).0: name::Name);
        _6 = TokenStream2::new() -> [return: bb2, unwind continue];
    }

    bb2: {
        _170 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _8 = &mut _6;
        _7 = <TokenStream2 as ToTokens>::to_tokens(_170, _8) -> [return: bb3, unwind: bb93];
    }

    bb3: {
        _10 = &mut _6;
        _9 = push_colon2(_10) -> [return: bb4, unwind: bb93];
    }

    bb4: {
        _12 = &mut _6;
        _13 = const "Raw";
        _11 = push_ident(_12, _13) -> [return: bb5, unwind: bb93];
    }

    bb5: {
        _15 = &mut _6;
        _16 = proc_macro2::Delimiter::Parenthesis;
        _18 = TokenStream2::new() -> [return: bb6, unwind: bb93];
    }

    bb6: {
        _20 = &_4;
        _21 = &mut _18;
        _19 = <&name::Name as ToTokens>::to_tokens(_20, _21) -> [return: bb7, unwind: bb92];
    }

    bb7: {
        _17 = move _18;
        _14 = push_group(_15, move _16, move _17) -> [return: bb8, unwind: bb93];
    }

    bb8: {
        _5 = move _6;
        _0 = Option::<TokenStream2>::Some(move _5);
        goto -> bb83;
    }

    bb9: {
        _23 = discriminant((*_2));
        switchInt(move _23) -> [0: bb12, 1: bb10, 2: bb20, 3: bb21, otherwise: bb11];
    }

    bb10: {
        _167 = const _;
        _45 = core::panicking::unreachable_display::<&str>(_167) -> unwind continue;
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _24 = &(((*_2) as Static).0: name::Name);
        _26 = TokenStream2::new() -> [return: bb13, unwind continue];
    }

    bb13: {
        _171 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _28 = &mut _26;
        _27 = <TokenStream2 as ToTokens>::to_tokens(_171, _28) -> [return: bb14, unwind: bb91];
    }

    bb14: {
        _30 = &mut _26;
        _29 = push_colon2(_30) -> [return: bb15, unwind: bb91];
    }

    bb15: {
        _32 = &mut _26;
        _33 = const "Raw";
        _31 = push_ident(_32, _33) -> [return: bb16, unwind: bb91];
    }

    bb16: {
        _35 = &mut _26;
        _36 = proc_macro2::Delimiter::Parenthesis;
        _38 = TokenStream2::new() -> [return: bb17, unwind: bb91];
    }

    bb17: {
        _40 = &_24;
        _41 = &mut _38;
        _39 = <&name::Name as ToTokens>::to_tokens(_40, _41) -> [return: bb18, unwind: bb90];
    }

    bb18: {
        _37 = move _38;
        _34 = push_group(_35, move _36, move _37) -> [return: bb19, unwind: bb91];
    }

    bb19: {
        _25 = move _26;
        _0 = Option::<TokenStream2>::Some(move _25);
        goto -> bb83;
    }

    bb20: {
        _42 = &(((*_2) as Dynamic).0: attribute::param::Dynamic);
        _22 = _42;
        goto -> bb23;
    }

    bb21: {
        _43 = &(((*_2) as Guard).0: attribute::param::Guard);
        _44 = <Guard as std::ops::Deref>::deref(_43) -> [return: bb22, unwind continue];
    }

    bb22: {
        _22 = _44;
        goto -> bb23;
    }

    bb23: {
        _172 = deref_copy ((*_1).1: &mut impl Iterator<Item = (&'a Ident, &'a Type)>);
        _49 = <impl Iterator<Item = (&'a Ident, &'a Type)> as Iterator>::next(_172) -> [return: bb24, unwind continue];
    }

    bb24: {
        _50 = const "ident/ty for query";
        _48 = Option::<(&proc_macro2::Ident, &syn::Type)>::expect(move _49, _50) -> [return: bb25, unwind continue];
    }

    bb25: {
        _46 = (_48.0: &proc_macro2::Ident);
        _47 = (_48.1: &syn::Type);
        _173 = deref_copy ((*_1).2: &mut impl Iterator<Item = &'a ArgExpr>);
        _52 = <impl Iterator<Item = &'a ArgExpr> as Iterator>::next(_173) -> [return: bb26, unwind continue];
    }

    bb26: {
        _53 = const "one expr per query";
        _51 = Option::<&uri_parsing::ArgExpr>::expect(move _52, _53) -> [return: bb27, unwind continue];
    }

    bb27: {
        _55 = uri_parsing::ArgExpr::as_expr(_51) -> [return: bb28, unwind continue];
    }

    bb28: {
        _56 = discriminant(_55);
        switchInt(move _56) -> [0: bb29, 1: bb30, otherwise: bb11];
    }

    bb29: {
        _174 = deref_copy ((*_1).3: &mut &mut std::vec::Vec<proc_macro2::TokenStream>);
        _175 = deref_copy (*_174);
        _61 = TokenStream2::new() -> [return: bb31, unwind continue];
    }

    bb30: {
        _57 = ((_55 as Some).0: &syn::Expr);
        _54 = _57;
        _96 = &((*_22).0: name::Name);
        _176 = deref_copy ((*_1).3: &mut &mut std::vec::Vec<proc_macro2::TokenStream>);
        _177 = deref_copy (*_176);
        _98 = &_46;
        _178 = deref_copy (*_98);
        _99 = &_47;
        _179 = deref_copy (*_99);
        _100 = &_54;
        _180 = deref_copy (*_100);
        _97 = add_binding::<rocket_http::uri::fmt::Query>(_177, _178, _179, _180) -> [return: bb51, unwind continue];
    }

    bb31: {
        _62 = <uri_parsing::ArgExpr as devise::Spanned>::span(_51) -> [return: bb32, unwind: bb89];
    }

    bb32: {
        _169 = const _;
        _64 = &mut _61;
        _63 = <StaticPath as ToTokens>::to_tokens(_169, _64) -> [return: bb33, unwind: bb89];
    }

    bb33: {
        _66 = &mut _61;
        _65 = push_colon2_spanned(_66, _62) -> [return: bb34, unwind: bb89];
    }

    bb34: {
        _68 = &mut _61;
        _69 = const "assert_ignorable";
        _67 = push_ident_spanned(_68, _62, _69) -> [return: bb35, unwind: bb89];
    }

    bb35: {
        _71 = &mut _61;
        _70 = push_colon2_spanned(_71, _62) -> [return: bb36, unwind: bb89];
    }

    bb36: {
        _73 = &mut _61;
        _72 = push_lt_spanned(_73, _62) -> [return: bb37, unwind: bb89];
    }

    bb37: {
        _168 = const _;
        _75 = &mut _61;
        _74 = <StaticPath as ToTokens>::to_tokens(_168, _75) -> [return: bb38, unwind: bb89];
    }

    bb38: {
        _77 = &mut _61;
        _76 = push_colon2_spanned(_77, _62) -> [return: bb39, unwind: bb89];
    }

    bb39: {
        _79 = &mut _61;
        _80 = const "Query";
        _78 = push_ident_spanned(_79, _62, _80) -> [return: bb40, unwind: bb89];
    }

    bb40: {
        _82 = &mut _61;
        _81 = push_comma_spanned(_82, _62) -> [return: bb41, unwind: bb89];
    }

    bb41: {
        _84 = &_47;
        _85 = &mut _61;
        _83 = <&syn::Type as ToTokens>::to_tokens(_84, _85) -> [return: bb42, unwind: bb89];
    }

    bb42: {
        _87 = &mut _61;
        _86 = push_gt_spanned(_87, _62) -> [return: bb43, unwind: bb89];
    }

    bb43: {
        _89 = &mut _61;
        _90 = proc_macro2::Delimiter::Parenthesis;
        _91 = TokenStream2::new() -> [return: bb44, unwind: bb89];
    }

    bb44: {
        _88 = push_group_spanned(_89, _62, move _90, move _91) -> [return: bb45, unwind: bb89];
    }

    bb45: {
        _93 = &mut _61;
        _92 = push_semi_spanned(_93, _62) -> [return: bb46, unwind: bb89];
    }

    bb46: {
        _60 = move _61;
        _94 = &_60;
        _95 = <uri_parsing::ArgExpr as devise::Spanned>::span(_51) -> [return: bb47, unwind: bb88];
    }

    bb47: {
        _59 = <TokenStream2 as AstItemExt>::respanned_tokens(move _94, move _95) -> [return: bb48, unwind: bb88];
    }

    bb48: {
        drop(_60) -> [return: bb49, unwind continue];
    }

    bb49: {
        _58 = Vec::<TokenStream2>::push(_175, move _59) -> [return: bb50, unwind continue];
    }

    bb50: {
        _0 = Option::<TokenStream2>::None;
        goto -> bb83;
    }

    bb51: {
        switchInt(((*_22).2: bool)) -> [0: bb53, otherwise: bb52];
    }

    bb52: {
        _137 = TokenStream2::new() -> [return: bb69, unwind continue];
    }

    bb53: {
        _102 = TokenStream2::new() -> [return: bb54, unwind continue];
    }

    bb54: {
        _104 = _54;
        _103 = <syn::Expr as devise::Spanned>::span(move _104) -> [return: bb55, unwind: bb87];
    }

    bb55: {
        _181 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _106 = &mut _102;
        _105 = <TokenStream2 as ToTokens>::to_tokens(_181, _106) -> [return: bb56, unwind: bb87];
    }

    bb56: {
        _108 = &mut _102;
        _107 = push_colon2_spanned(_108, _103) -> [return: bb57, unwind: bb87];
    }

    bb57: {
        _110 = &mut _102;
        _111 = const "NameValue";
        _109 = push_ident_spanned(_110, _103, _111) -> [return: bb58, unwind: bb87];
    }

    bb58: {
        _113 = &mut _102;
        _114 = proc_macro2::Delimiter::Parenthesis;
        _116 = TokenStream2::new() -> [return: bb59, unwind: bb87];
    }

    bb59: {
        _118 = &_96;
        _119 = &mut _116;
        _117 = <&name::Name as ToTokens>::to_tokens(_118, _119) -> [return: bb60, unwind: bb86];
    }

    bb60: {
        _121 = &mut _116;
        _120 = push_comma_spanned(_121, _103) -> [return: bb61, unwind: bb86];
    }

    bb61: {
        _123 = &mut _116;
        _122 = push_and_spanned(_123, _103) -> [return: bb62, unwind: bb86];
    }

    bb62: {
        _125 = &_46;
        _126 = &mut _116;
        _124 = <&proc_macro2::Ident as ToTokens>::to_tokens(_125, _126) -> [return: bb63, unwind: bb86];
    }

    bb63: {
        _128 = &mut _116;
        _129 = const "as";
        _127 = push_ident_spanned(_128, _103, _129) -> [return: bb64, unwind: bb86];
    }

    bb64: {
        _131 = &mut _116;
        _130 = push_and_spanned(_131, _103) -> [return: bb65, unwind: bb86];
    }

    bb65: {
        _133 = &mut _116;
        _134 = const "dyn";
        _132 = push_ident_spanned(_133, _103, _134) -> [return: bb66, unwind: bb86];
    }

    bb66: {
        _182 = deref_copy ((*_1).4: &proc_macro2::TokenStream);
        _136 = &mut _116;
        _135 = <TokenStream2 as ToTokens>::to_tokens(_182, _136) -> [return: bb67, unwind: bb86];
    }

    bb67: {
        _115 = move _116;
        _112 = push_group_spanned(_113, _103, move _114, move _115) -> [return: bb68, unwind: bb87];
    }

    bb68: {
        _101 = move _102;
        goto -> bb82;
    }

    bb69: {
        _139 = _54;
        _138 = <syn::Expr as devise::Spanned>::span(move _139) -> [return: bb70, unwind: bb85];
    }

    bb70: {
        _183 = deref_copy ((*_1).0: &proc_macro2::TokenStream);
        _141 = &mut _137;
        _140 = <TokenStream2 as ToTokens>::to_tokens(_183, _141) -> [return: bb71, unwind: bb85];
    }

    bb71: {
        _143 = &mut _137;
        _142 = push_colon2_spanned(_143, _138) -> [return: bb72, unwind: bb85];
    }

    bb72: {
        _145 = &mut _137;
        _146 = const "Value";
        _144 = push_ident_spanned(_145, _138, _146) -> [return: bb73, unwind: bb85];
    }

    bb73: {
        _148 = &mut _137;
        _149 = proc_macro2::Delimiter::Parenthesis;
        _151 = TokenStream2::new() -> [return: bb74, unwind: bb85];
    }

    bb74: {
        _153 = &mut _151;
        _152 = push_and_spanned(_153, _138) -> [return: bb75, unwind: bb84];
    }

    bb75: {
        _155 = &_46;
        _156 = &mut _151;
        _154 = <&proc_macro2::Ident as ToTokens>::to_tokens(_155, _156) -> [return: bb76, unwind: bb84];
    }

    bb76: {
        _158 = &mut _151;
        _159 = const "as";
        _157 = push_ident_spanned(_158, _138, _159) -> [return: bb77, unwind: bb84];
    }

    bb77: {
        _161 = &mut _151;
        _160 = push_and_spanned(_161, _138) -> [return: bb78, unwind: bb84];
    }

    bb78: {
        _163 = &mut _151;
        _164 = const "dyn";
        _162 = push_ident_spanned(_163, _138, _164) -> [return: bb79, unwind: bb84];
    }

    bb79: {
        _184 = deref_copy ((*_1).4: &proc_macro2::TokenStream);
        _166 = &mut _151;
        _165 = <TokenStream2 as ToTokens>::to_tokens(_184, _166) -> [return: bb80, unwind: bb84];
    }

    bb80: {
        _150 = move _151;
        _147 = push_group_spanned(_148, _138, move _149, move _150) -> [return: bb81, unwind: bb85];
    }

    bb81: {
        _101 = move _137;
        goto -> bb82;
    }

    bb82: {
        _0 = Option::<TokenStream2>::Some(move _101);
        goto -> bb83;
    }

    bb83: {
        return;
    }

    bb84 (cleanup): {
        drop(_151) -> [return: bb85, unwind terminate(cleanup)];
    }

    bb85 (cleanup): {
        drop(_137) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb86 (cleanup): {
        drop(_116) -> [return: bb87, unwind terminate(cleanup)];
    }

    bb87 (cleanup): {
        drop(_102) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb88 (cleanup): {
        drop(_60) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb89 (cleanup): {
        drop(_61) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        drop(_38) -> [return: bb91, unwind terminate(cleanup)];
    }

    bb91 (cleanup): {
        drop(_26) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        drop(_18) -> [return: bb93, unwind terminate(cleanup)];
    }

    bb93 (cleanup): {
        drop(_6) -> [return: bb94, unwind terminate(cleanup)];
    }

    bb94 (cleanup): {
        resume;
    }
}

promoted[0] in explode_query::{closure#0}: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "invariant: unignorable q";
        _0 = &_1;
        return;
    }
}

promoted[1] in explode_query::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in explode_query::{closure#0}: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn _uri_internal_macro(_1: TokenStream2) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: bang::uri_parsing::InternalUriParams;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::InternalUriParams>;
    let mut _4: std::result::Result<bang::uri_parsing::InternalUriParams, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: bang::uri_parsing::InternalUriParams;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, (std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>, std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>)>;
    let mut _12: std::result::Result<(std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>, std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic>;
    let _13: &bang::uri_parsing::InternalUriParams;
    let mut _14: isize;
    let _19: &bang::uri_parsing::InternalUriParams;
    let mut _20: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _21: std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>;
    let mut _22: &mut std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>;
    let mut _24: std::option::Option<proc_macro2::TokenStream>;
    let _25: &bang::uri_parsing::InternalUriParams;
    let mut _26: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _27: std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>;
    let mut _28: std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>;
    let mut _30: std::option::Option<&bang::uri_parsing::UriExpr>;
    let mut _31: &std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _33: std::option::Option<&bang::uri_parsing::UriExpr>;
    let mut _34: &std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _35: proc_macro2::TokenStream;
    let mut _38: &syn::Path;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let mut _43: proc_macro2::Delimiter;
    let mut _44: proc_macro2::TokenStream;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: &str;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let mut _51: proc_macro2::Delimiter;
    let mut _52: proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: &str;
    let _57: ();
    let mut _58: &mut proc_macro2::TokenStream;
    let mut _59: proc_macro2::Delimiter;
    let mut _60: proc_macro2::TokenStream;
    let mut _63: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _64: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _66: bool;
    let mut _68: std::option::Option<&proc_macro2::TokenStream>;
    let mut _69: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _70: isize;
    let _72: ();
    let _73: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: ();
    let mut _76: &mut proc_macro2::TokenStream;
    let _77: &str;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: &str;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let _85: ();
    let mut _86: &mut proc_macro2::TokenStream;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let _89: &str;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: &str;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let mut _97: proc_macro2::Delimiter;
    let mut _98: proc_macro2::TokenStream;
    let _100: ();
    let _101: &proc_macro2::TokenStream;
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: ();
    let mut _104: &mut proc_macro2::TokenStream;
    let _105: ();
    let _106: &http_codegen::Optional<proc_macro2::TokenStream>;
    let mut _107: &mut proc_macro2::TokenStream;
    let _108: ();
    let mut _109: &mut proc_macro2::TokenStream;
    let _110: ();
    let mut _111: &mut proc_macro2::TokenStream;
    let _112: &str;
    let _113: ();
    let _114: &std::option::Option<proc_macro2::TokenStream>;
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let _117: &std::option::Option<proc_macro2::TokenStream>;
    let mut _118: &mut proc_macro2::TokenStream;
    let _119: ();
    let mut _120: &mut proc_macro2::TokenStream;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: &str;
    let _124: ();
    let mut _125: &mut proc_macro2::TokenStream;
    let mut _126: proc_macro2::Delimiter;
    let mut _127: proc_macro2::TokenStream;
    let mut _129: (impl std::iter::Iterator<Item = &syn::Expr>, impl std::iter::Iterator<Item = &bang::uri_parsing::ArgExpr>, impl std::iter::Iterator<Item = (&proc_macro2::Ident, &syn::Type)>);
    let mut _130: impl std::iter::Iterator<Item = &syn::Expr>;
    let mut _131: impl std::iter::Iterator<Item = &bang::uri_parsing::ArgExpr>;
    let mut _132: impl std::iter::Iterator<Item = (&proc_macro2::Ident, &syn::Type)>;
    let mut _133: bool;
    let mut _134: bool;
    scope 1 {
        debug internal => _2;
        let _8: std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>;
        let _9: std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>;
        let mut _10: std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>;
        let _15: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _16: (std::iter::Take<std::iter::Map<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, std::iter::Skip<std::vec::IntoIter<&bang::uri_parsing::ArgExpr>>, std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>);
        scope 6 {
            debug path_exprs => _8;
            debug query_exprs => _9;
            debug fn_args => _10;
            let mut _17: std::vec::Vec<proc_macro2::TokenStream>;
            scope 11 {
                debug bindings => _17;
                let _18: proc_macro2::TokenStream;
                scope 12 {
                    debug path => _18;
                    let _23: http_codegen::Optional<proc_macro2::TokenStream>;
                    scope 13 {
                        debug query => _23;
                        let _29: std::option::Option<proc_macro2::TokenStream>;
                        scope 14 {
                            debug prefix => _29;
                            let _32: std::option::Option<proc_macro2::TokenStream>;
                            scope 15 {
                                debug suffix => _32;
                                let mut _36: proc_macro2::TokenStream;
                                scope 16 {
                                    debug _s => _36;
                                    let _37: proc_macro2::Span;
                                    scope 17 {
                                        debug _span => _37;
                                        let mut _45: proc_macro2::TokenStream;
                                        let mut _61: proc_macro2::TokenStream;
                                        scope 18 {
                                            debug _s => _45;
                                            scope 19 {
                                                debug _span => _37;
                                                let mut _53: proc_macro2::TokenStream;
                                                scope 20 {
                                                    debug _s => _53;
                                                    scope 21 {
                                                        debug _span => _37;
                                                    }
                                                }
                                            }
                                        }
                                        scope 22 {
                                            debug _s => _61;
                                            scope 23 {
                                                debug _span => _37;
                                                let mut _99: proc_macro2::TokenStream;
                                                let mut _128: &exports::StaticPath;
                                                scope 24 {
                                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                                    scope 25 {
                                                        debug bindings => _62;
                                                        debug i => const HasIterator;
                                                        let _65: quote::__private::HasIterator;
                                                        scope 27 {
                                                            debug has_iter => const HasIterator;
                                                            scope 28 {
                                                                let _67: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                                                let _71: &proc_macro2::TokenStream;
                                                                scope 29 {
                                                                    debug bindings => _67;
                                                                }
                                                                scope 30 {
                                                                    debug _x => _71;
                                                                }
                                                            }
                                                        }
                                                    }
                                                    scope 26 {
                                                        let mut _62: std::slice::Iter<'_, proc_macro2::TokenStream>;
                                                    }
                                                }
                                                scope 31 {
                                                    debug _s => _99;
                                                    scope 32 {
                                                        debug _span => _37;
                                                    }
                                                }
                                                scope 33 {
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 7 {
            debug residual => _15;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _16;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _134 = const false;
        _133 = const false;
        _4 = syn::parse2::<uri_parsing::InternalUriParams>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: bang::uri_parsing::InternalUriParams);
        _2 = move _7;
        _13 = &_2;
        _12 = extract_exprs(_13) -> [return: bb6, unwind: bb73];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb61, unwind continue];
    }

    bb6: {
        _11 = <std::result::Result<(std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>), devise::Diagnostic> as std::ops::Try>::branch(move _12) -> [return: bb7, unwind: bb73];
    }

    bb7: {
        _14 = discriminant(_11);
        switchInt(move _14) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _129 = move ((_11 as Continue).0: (impl std::iter::Iterator<Item = &syn::Expr>, impl std::iter::Iterator<Item = &bang::uri_parsing::ArgExpr>, impl std::iter::Iterator<Item = (&proc_macro2::Ident, &syn::Type)>));
        _16 = move (_129 as subtype (std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>));
        _130 = move (_16.0: impl std::iter::Iterator<Item = &syn::Expr>);
        _134 = const true;
        _8 = move (_130 as subtype std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>);
        _131 = move (_16.1: impl std::iter::Iterator<Item = &bang::uri_parsing::ArgExpr>);
        _133 = const true;
        _9 = move (_131 as subtype Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>);
        _132 = move (_16.2: impl std::iter::Iterator<Item = (&proc_macro2::Ident, &syn::Type)>);
        _10 = move (_132 as subtype Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>);
        _17 = Vec::<TokenStream2>::new() -> [return: bb11, unwind: bb76];
    }

    bb9: {
        _15 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _15) -> [return: bb10, unwind: bb73];
    }

    bb10: {
        drop(_2) -> [return: bb61, unwind continue];
    }

    bb11: {
        _19 = &_2;
        _20 = &mut _17;
        _134 = const false;
        _21 = move _8;
        _22 = &mut _10;
        _18 = explode_path::<'_, std::iter::Take<Map<std::vec::IntoIter<&uri_parsing::ArgExpr>, {closure@core/codegen/src/bang/uri.rs:60:52: 60:55}>>, &mut Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>>(_19, _20, move _21, move _22) -> [return: bb12, unwind: bb71];
    }

    bb12: {
        _25 = &_2;
        _26 = &mut _17;
        _133 = const false;
        _27 = move _9;
        _28 = move _10;
        _24 = explode_query::<'_, Skip<std::vec::IntoIter<&uri_parsing::ArgExpr>>, Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri.rs:61:53: 61:56}>>(_25, _26, move _27, move _28) -> [return: bb13, unwind: bb70];
    }

    bb13: {
        _23 = Optional::<TokenStream2>(move _24);
        _31 = &((_2.4: bang::uri_parsing::RoutedUri).0: std::option::Option<bang::uri_parsing::UriExpr>);
        _30 = Option::<UriExpr>::as_ref(move _31) -> [return: bb14, unwind: bb69];
    }

    bb14: {
        _29 = Option::<&UriExpr>::map::<TokenStream2, {closure@core/codegen/src/bang/uri.rs:234:14: 234:22}>(move _30, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:234:14: 234:22}) -> [return: bb15, unwind: bb69];
    }

    bb15: {
        _34 = &((_2.4: bang::uri_parsing::RoutedUri).2: std::option::Option<bang::uri_parsing::UriExpr>);
        _33 = Option::<UriExpr>::as_ref(move _34) -> [return: bb16, unwind: bb68];
    }

    bb16: {
        _32 = Option::<&UriExpr>::map::<TokenStream2, {closure@core/codegen/src/bang/uri.rs:237:14: 237:22}>(move _33, const ZeroSized: {closure@core/codegen/src/bang/uri.rs:237:14: 237:22}) -> [return: bb17, unwind: bb68];
    }

    bb17: {
        _36 = TokenStream2::new() -> [return: bb18, unwind: bb67];
    }

    bb18: {
        _38 = &(((_2.4: bang::uri_parsing::RoutedUri).1: bang::uri_parsing::RouteInvocation).0: syn::Path);
        _37 = <syn::Path as devise::Spanned>::span(move _38) -> [return: bb19, unwind: bb66];
    }

    bb19: {
        _40 = &mut _36;
        _39 = push_pound_spanned(_40, _37) -> [return: bb20, unwind: bb66];
    }

    bb20: {
        _42 = &mut _36;
        _43 = proc_macro2::Delimiter::Bracket;
        _45 = TokenStream2::new() -> [return: bb21, unwind: bb66];
    }

    bb21: {
        _47 = &mut _45;
        _48 = const "allow";
        _46 = push_ident_spanned(_47, _37, _48) -> [return: bb22, unwind: bb65];
    }

    bb22: {
        _50 = &mut _45;
        _51 = proc_macro2::Delimiter::Parenthesis;
        _53 = TokenStream2::new() -> [return: bb23, unwind: bb65];
    }

    bb23: {
        _55 = &mut _53;
        _56 = const "unused_braces";
        _54 = push_ident_spanned(_55, _37, _56) -> [return: bb24, unwind: bb64];
    }

    bb24: {
        _52 = move _53;
        _49 = push_group_spanned(_50, _37, move _51, move _52) -> [return: bb25, unwind: bb65];
    }

    bb25: {
        _44 = move _45;
        _41 = push_group_spanned(_42, _37, move _43, move _44) -> [return: bb26, unwind: bb66];
    }

    bb26: {
        _58 = &mut _36;
        _59 = proc_macro2::Delimiter::Brace;
        _61 = TokenStream2::new() -> [return: bb27, unwind: bb66];
    }

    bb27: {
        _64 = &_17;
        _63 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _64) -> [return: bb28, unwind: bb63];
    }

    bb28: {
        _62 = move (_63.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _65 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb78, unwind: bb63];
    }

    bb29: {
        _66 = const true;
        switchInt(move _66) -> [0: bb33, otherwise: bb30];
    }

    bb30: {
        _69 = &mut _62;
        _68 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _69) -> [return: bb31, unwind: bb63];
    }

    bb31: {
        _70 = discriminant(_68);
        switchInt(move _70) -> [0: bb33, 1: bb32, otherwise: bb4];
    }

    bb32: {
        _71 = ((_68 as Some).0: &proc_macro2::TokenStream);
        _67 = RepInterp::<&TokenStream2>(_71);
        _73 = &_67;
        _74 = &mut _61;
        _72 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_73, _74) -> [return: bb79, unwind: bb63];
    }

    bb33: {
        _76 = &mut _61;
        _77 = const "let";
        _75 = push_ident_spanned(_76, _37, _77) -> [return: bb34, unwind: bb63];
    }

    bb34: {
        _79 = &mut _61;
        _80 = const "__builder";
        _78 = push_ident_spanned(_79, _37, _80) -> [return: bb35, unwind: bb63];
    }

    bb35: {
        _82 = &mut _61;
        _81 = push_eq_spanned(_82, _37) -> [return: bb36, unwind: bb63];
    }

    bb36: {
        _128 = const _;
        _84 = &mut _61;
        _83 = <StaticPath as ToTokens>::to_tokens(_128, _84) -> [return: bb37, unwind: bb63];
    }

    bb37: {
        _86 = &mut _61;
        _85 = push_colon2_spanned(_86, _37) -> [return: bb38, unwind: bb63];
    }

    bb38: {
        _88 = &mut _61;
        _89 = const "RouteUriBuilder";
        _87 = push_ident_spanned(_88, _37, _89) -> [return: bb39, unwind: bb63];
    }

    bb39: {
        _91 = &mut _61;
        _90 = push_colon2_spanned(_91, _37) -> [return: bb40, unwind: bb63];
    }

    bb40: {
        _93 = &mut _61;
        _94 = const "new";
        _92 = push_ident_spanned(_93, _37, _94) -> [return: bb41, unwind: bb63];
    }

    bb41: {
        _96 = &mut _61;
        _97 = proc_macro2::Delimiter::Parenthesis;
        _99 = TokenStream2::new() -> [return: bb42, unwind: bb63];
    }

    bb42: {
        _101 = &_18;
        _102 = &mut _99;
        _100 = <TokenStream2 as ToTokens>::to_tokens(_101, _102) -> [return: bb43, unwind: bb62];
    }

    bb43: {
        _104 = &mut _99;
        _103 = push_comma_spanned(_104, _37) -> [return: bb44, unwind: bb62];
    }

    bb44: {
        _106 = &_23;
        _107 = &mut _99;
        _105 = <Optional<TokenStream2> as ToTokens>::to_tokens(_106, _107) -> [return: bb45, unwind: bb62];
    }

    bb45: {
        _98 = move _99;
        _95 = push_group_spanned(_96, _37, move _97, move _98) -> [return: bb46, unwind: bb63];
    }

    bb46: {
        _109 = &mut _61;
        _108 = push_semi_spanned(_109, _37) -> [return: bb47, unwind: bb63];
    }

    bb47: {
        _111 = &mut _61;
        _112 = const "__builder";
        _110 = push_ident_spanned(_111, _37, _112) -> [return: bb48, unwind: bb63];
    }

    bb48: {
        _114 = &_29;
        _115 = &mut _61;
        _113 = <Option<TokenStream2> as ToTokens>::to_tokens(_114, _115) -> [return: bb49, unwind: bb63];
    }

    bb49: {
        _117 = &_32;
        _118 = &mut _61;
        _116 = <Option<TokenStream2> as ToTokens>::to_tokens(_117, _118) -> [return: bb50, unwind: bb63];
    }

    bb50: {
        _120 = &mut _61;
        _119 = push_dot_spanned(_120, _37) -> [return: bb51, unwind: bb63];
    }

    bb51: {
        _122 = &mut _61;
        _123 = const "render";
        _121 = push_ident_spanned(_122, _37, _123) -> [return: bb52, unwind: bb63];
    }

    bb52: {
        _125 = &mut _61;
        _126 = proc_macro2::Delimiter::Parenthesis;
        _127 = TokenStream2::new() -> [return: bb53, unwind: bb63];
    }

    bb53: {
        _124 = push_group_spanned(_125, _37, move _126, move _127) -> [return: bb54, unwind: bb63];
    }

    bb54: {
        _60 = move _61;
        _57 = push_group_spanned(_58, _37, move _59, move _60) -> [return: bb55, unwind: bb66];
    }

    bb55: {
        _35 = move _36;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _35);
        drop(_32) -> [return: bb56, unwind: bb68];
    }

    bb56: {
        drop(_29) -> [return: bb57, unwind: bb69];
    }

    bb57: {
        drop(_23) -> [return: bb58, unwind: bb70];
    }

    bb58: {
        drop(_18) -> [return: bb59, unwind: bb71];
    }

    bb59: {
        drop(_17) -> [return: bb60, unwind: bb76];
    }

    bb60: {
        _133 = const false;
        _134 = const false;
        drop(_2) -> [return: bb61, unwind continue];
    }

    bb61: {
        return;
    }

    bb62 (cleanup): {
        drop(_99) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_61) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_53) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_45) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_36) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        drop(_32) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop(_29) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        drop(_23) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        drop(_18) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        drop(_17) -> [return: bb76, unwind terminate(cleanup)];
    }

    bb72 (cleanup): {
        switchInt(_134) -> [0: bb73, otherwise: bb77];
    }

    bb73 (cleanup): {
        drop(_2) -> [return: bb74, unwind terminate(cleanup)];
    }

    bb74 (cleanup): {
        resume;
    }

    bb75 (cleanup): {
        drop(_9) -> [return: bb72, unwind terminate(cleanup)];
    }

    bb76 (cleanup): {
        switchInt(_133) -> [0: bb72, otherwise: bb75];
    }

    bb77 (cleanup): {
        drop(_8) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb78: {
        goto -> bb29;
    }

    bb79: {
        goto -> bb29;
    }
}

promoted[0] in _uri_internal_macro: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn _uri_internal_macro::{closure#0}(_1: {closure@core/codegen/src/bang/uri.rs:234:14: 234:22}, _2: &UriExpr) -> TokenStream2 {
    debug prefix => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _5: &bang::uri_parsing::UriExpr;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let _17: &&bang::uri_parsing::UriExpr;
    let mut _18: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug _span => _4;
            let mut _15: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _15;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _2;
        _4 = <UriExpr as devise::Spanned>::span(move _5) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _7 = &mut _3;
        _6 = push_dot_spanned(_7, _4) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _9 = &mut _3;
        _10 = const "with_prefix";
        _8 = push_ident_spanned(_9, _4, _10) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _12 = &mut _3;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _17 = &_2;
        _18 = &mut _15;
        _16 = <&UriExpr as ToTokens>::to_tokens(_17, _18) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        _14 = move _15;
        _11 = push_group_spanned(_12, _4, move _13, move _14) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move _3;
        return;
    }

    bb8 (cleanup): {
        drop(_15) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn _uri_internal_macro::{closure#1}(_1: {closure@core/codegen/src/bang/uri.rs:237:14: 237:22}, _2: &UriExpr) -> TokenStream2 {
    debug suffix => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _5: &bang::uri_parsing::UriExpr;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let _17: &&bang::uri_parsing::UriExpr;
    let mut _18: &mut proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
        let _4: proc_macro2::Span;
        scope 2 {
            debug _span => _4;
            let mut _15: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _15;
                scope 4 {
                }
            }
        }
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = _2;
        _4 = <UriExpr as devise::Spanned>::span(move _5) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _7 = &mut _3;
        _6 = push_dot_spanned(_7, _4) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _9 = &mut _3;
        _10 = const "with_suffix";
        _8 = push_ident_spanned(_9, _4, _10) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _12 = &mut _3;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _17 = &_2;
        _18 = &mut _15;
        _16 = <&UriExpr as ToTokens>::to_tokens(_17, _18) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        _14 = move _15;
        _11 = push_group_spanned(_12, _4, move _13, move _14) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _0 = move _3;
        return;
    }

    bb8 (cleanup): {
        drop(_15) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:20:10: 20:15>::fmt(_1: &uri_parsing::ArgExpr, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &syn::Expr;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&syn::Expr;
    let _8: &syn::token::Underscore;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&syn::token::Underscore;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Ignored).0: syn::token::Underscore);
        _9 = const "Ignored";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Expr).0: syn::Expr);
        _5 = const "Expr";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:26:10: 26:15>::fmt(_1: &Arg, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &bang::uri_parsing::ArgExpr;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&bang::uri_parsing::ArgExpr;
    let _8: &name::Name;
    let _9: &proc_macro2::Ident;
    let _10: &syn::token::Eq;
    let _11: &bang::uri_parsing::ArgExpr;
    let _12: &str;
    let mut _13: &dyn std::fmt::Debug;
    let mut _14: &dyn std::fmt::Debug;
    let mut _15: &dyn std::fmt::Debug;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&bang::uri_parsing::ArgExpr;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
        debug __self_1 => _9;
        debug __self_2 => _10;
        debug __self_3 => _11;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Named).0: name::Name);
        _9 = &(((*_1) as Named).1: proc_macro2::Ident);
        _10 = &(((*_1) as Named).2: syn::token::Eq);
        _11 = &(((*_1) as Named).3: bang::uri_parsing::ArgExpr);
        _12 = const "Named";
        _13 = _8 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _14 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = _10 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &_11;
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field4_finish(_2, _12, move _13, move _14, move _15, move _16) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Unnamed).0: bang::uri_parsing::ArgExpr);
        _5 = const "Unnamed";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:32:10: 32:15>::fmt(_1: &uri_parsing::Args, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let _8: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Named).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        _9 = const "Named";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Unnamed).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        _5 = const "Unnamed";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:39:10: 39:15>::fmt(_1: &UriLit, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &rocket_http::uri::Uri<'_>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "UriLit";
        _5 = &((*_1).0: rocket_http::uri::Uri<'_>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:43:10: 43:15>::fmt(_1: &UriExpr, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &bang::uri_parsing::UriLit;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&bang::uri_parsing::UriLit;
    let _8: &syn::Expr;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&syn::Expr;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Expr).0: syn::Expr);
        _9 = const "Expr";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Uri).0: bang::uri_parsing::UriLit);
        _5 = const "Uri";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:52:10: 52:15>::fmt(_1: &RouteInvocation, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &syn::Path;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&bang::uri_parsing::Args;
    let _10: &bang::uri_parsing::Args;

    bb0: {
        _3 = const "RouteInvocation";
        _4 = const "path";
        _6 = &((*_1).0: syn::Path);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "args";
        _10 = &((*_1).1: bang::uri_parsing::Args);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:59:10: 59:15>::fmt(_1: &RoutedUri, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<bang::uri_parsing::UriExpr>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bang::uri_parsing::RouteInvocation;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&std::option::Option<bang::uri_parsing::UriExpr>;
    let _13: &std::option::Option<bang::uri_parsing::UriExpr>;

    bb0: {
        _3 = const "RoutedUri";
        _4 = const "prefix";
        _6 = &((*_1).0: std::option::Option<bang::uri_parsing::UriExpr>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "route";
        _9 = &((*_1).1: bang::uri_parsing::RouteInvocation);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "suffix";
        _13 = &((*_1).2: std::option::Option<bang::uri_parsing::UriExpr>);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:79:10: 79:15>::fmt(_1: &uri_parsing::UriMacro, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &bang::uri_parsing::UriLit;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&bang::uri_parsing::UriLit;
    let _8: &bang::uri_parsing::RoutedUri;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&bang::uri_parsing::RoutedUri;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &(((*_1) as Routed).0: bang::uri_parsing::RoutedUri);
        _9 = const "Routed";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Literal).0: bang::uri_parsing::UriLit);
        _5 = const "Literal";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:85:10: 85:15>::fmt(_1: &uri_parsing::Validation<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &std::vec::Vec<&attribute::param::Dynamic>;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&std::vec::Vec<&attribute::param::Dynamic>;
    let _8: &usize;
    let _9: &usize;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &&usize;
    let _14: &std::vec::Vec<&name::Name>;
    let _15: &std::vec::Vec<&proc_macro2::Ident>;
    let _16: &std::vec::Vec<&proc_macro2::Ident>;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let mut _19: &dyn std::fmt::Debug;
    let mut _20: &dyn std::fmt::Debug;
    let _21: &&std::vec::Vec<&proc_macro2::Ident>;
    let _22: &std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let _23: &str;
    let mut _24: &dyn std::fmt::Debug;
    let _25: &&std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
        debug __self_1 => _9;
    }
    scope 3 {
        debug __self_0 => _14;
        debug __self_1 => _15;
        debug __self_2 => _16;
    }
    scope 4 {
        debug __self_0 => _22;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _22 = &(((*_1) as Ok).0: std::vec::Vec<&bang::uri_parsing::ArgExpr>);
        _23 = const "Ok";
        _25 = &_22;
        _24 = _25 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _23, move _24) -> [return: bb6, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as NamedIgnored).0: std::vec::Vec<&attribute::param::Dynamic>);
        _5 = const "NamedIgnored";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb6, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as Unnamed).0: usize);
        _9 = &(((*_1) as Unnamed).1: usize);
        _10 = const "Unnamed";
        _11 = _8 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &_9;
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _10, move _11, move _12) -> [return: bb6, unwind continue];
    }

    bb5: {
        _14 = &(((*_1) as Named).0: std::vec::Vec<&name::Name>);
        _15 = &(((*_1) as Named).1: std::vec::Vec<&proc_macro2::Ident>);
        _16 = &(((*_1) as Named).2: std::vec::Vec<&proc_macro2::Ident>);
        _17 = const "Named";
        _18 = _14 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _19 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _21 = &_16;
        _20 = _21 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field3_finish(_2, _17, move _18, move _19, move _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:114:10: 114:15>::fmt(_1: &uri_parsing::InternalUriParams, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &rocket_http::uri::Origin<'_>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::vec::Vec<attribute::param::Parameter>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &std::vec::Vec<attribute::param::Parameter>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::vec::Vec<bang::uri_parsing::FnArg>;
    let _16: &str;
    let mut _17: &dyn std::fmt::Debug;
    let _18: &&bang::uri_parsing::RoutedUri;
    let _19: &bang::uri_parsing::RoutedUri;

    bb0: {
        _3 = const "InternalUriParams";
        _4 = const "route_uri";
        _6 = &((*_1).0: rocket_http::uri::Origin<'_>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "path_params";
        _9 = &((*_1).1: std::vec::Vec<attribute::param::Parameter>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "query_params";
        _12 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "fn_args";
        _15 = &((*_1).3: std::vec::Vec<bang::uri_parsing::FnArg>);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _16 = const "uri_mac";
        _19 = &((*_1).4: bang::uri_parsing::RoutedUri);
        _18 = &_19;
        _17 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field5_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14, _16, move _17) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:123:10: 123:15>::fmt(_1: &uri_parsing::FnArg, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &proc_macro2::Ident;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&syn::Type;
    let _10: &syn::Type;

    bb0: {
        _3 = const "FnArg";
        _4 = const "ident";
        _6 = &((*_1).0: proc_macro2::Ident);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "ty";
        _10 = &((*_1).1: syn::Type);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn err(_1: proc_macro2::Span, _2: S) -> std::result::Result<T, syn::Error> {
    debug span => _1;
    debug s => _2;
    let mut _0: std::result::Result<T, syn::Error>;
    let mut _3: syn::Error;
    let mut _4: proc_macro2::Span;
    let mut _5: &str;
    let mut _6: &S;

    bb0: {
        _4 = <proc_macro2::Span as Into<proc_macro2::Span>>::into(_1) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _6 = &_2;
        _5 = <S as AsRef<str>>::as_ref(move _6) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _3 = syn::Error::new::<&str>(move _4, move _5) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = std::result::Result::<T, syn::Error>::Err(move _3);
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:133:1: 133:23>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::ArgExpr, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::ArgExpr, syn::Error>;
    let mut _2: bool;
    let mut _3: bang::uri_parsing::ArgExpr;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Underscore>;
    let mut _5: std::result::Result<syn::token::Underscore, syn::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, syn::Error>;
    let _8: syn::token::Underscore;
    let mut _9: std::result::Result<syn::Expr, syn::Error>;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _2 = ParseBuffer::<'_>::peek::<fn(syn::lookahead::TokenMarker) -> Underscore {Underscore::<syn::lookahead::TokenMarker>}>(_1, Underscore::<syn::lookahead::TokenMarker>) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _5 = ParseBuffer::<'_>::parse::<Underscore>(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<Underscore, syn::Error> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = ((_4 as Continue).0: syn::token::Underscore);
        _3 = uri_parsing::ArgExpr::Ignored(_8);
        _0 = std::result::Result::<uri_parsing::ArgExpr, syn::Error>::Ok(move _3);
        goto -> bb10;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::ArgExpr, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb10, unwind continue];
    }

    bb8: {
        _9 = ParseBuffer::<'_>::parse::<syn::Expr>(_1) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<syn::Expr, syn::Error>::map::<uri_parsing::ArgExpr, fn(syn::Expr) -> uri_parsing::ArgExpr {uri_parsing::ArgExpr::Expr}>(move _9, uri_parsing::ArgExpr::Expr) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:143:1: 143:19>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<Arg, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::Arg, syn::Error>;
    let _2: bool;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro2::Ident>;
    let mut _5: std::result::Result<proc_macro2::Ident, syn::Error>;
    let mut _6: isize;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Eq>;
    let mut _10: std::result::Result<syn::token::Eq, syn::Error>;
    let mut _11: isize;
    let mut _15: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::ArgExpr>;
    let mut _16: std::result::Result<bang::uri_parsing::ArgExpr, syn::Error>;
    let mut _17: isize;
    let mut _20: bang::uri_parsing::Arg;
    let mut _21: name::Name;
    let mut _22: &proc_macro2::Ident;
    let mut _23: proc_macro2::Ident;
    let mut _24: bang::uri_parsing::ArgExpr;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::ArgExpr>;
    let mut _26: std::result::Result<bang::uri_parsing::ArgExpr, syn::Error>;
    let mut _27: isize;
    let mut _30: bang::uri_parsing::Arg;
    scope 1 {
        debug has_key => _2;
        let _3: proc_macro2::Ident;
        let _7: std::result::Result<std::convert::Infallible, syn::Error>;
        let _8: proc_macro2::Ident;
        let _28: std::result::Result<std::convert::Infallible, syn::Error>;
        let _29: bang::uri_parsing::ArgExpr;
        scope 2 {
            debug ident => _3;
            let _12: std::result::Result<std::convert::Infallible, syn::Error>;
            let _13: syn::token::Eq;
            scope 7 {
                debug eq_token => _13;
                let _14: bang::uri_parsing::ArgExpr;
                let _18: std::result::Result<std::convert::Infallible, syn::Error>;
                let _19: bang::uri_parsing::ArgExpr;
                scope 12 {
                    debug expr => _14;
                }
                scope 13 {
                    debug residual => _18;
                    scope 14 {
                    }
                }
                scope 15 {
                    debug val => _19;
                    scope 16 {
                    }
                }
            }
            scope 8 {
                debug residual => _12;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _13;
                scope 11 {
                }
            }
        }
        scope 3 {
            debug residual => _7;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _8;
            scope 6 {
            }
        }
        scope 17 {
            debug expr => _29;
        }
        scope 18 {
            debug residual => _28;
            scope 19 {
            }
        }
        scope 20 {
            debug val => _29;
            scope 21 {
            }
        }
    }

    bb0: {
        _2 = ParseBuffer::<'_>::peek2::<fn(syn::lookahead::TokenMarker) -> syn::token::Eq {syn::token::Eq::<syn::lookahead::TokenMarker>}>(_1, syn::token::Eq::<syn::lookahead::TokenMarker>) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(_2) -> [0: bb17, otherwise: bb2];
    }

    bb2: {
        _5 = ParseBuffer::<'_>::parse::<proc_macro2::Ident>(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<proc_macro2::Ident, syn::Error> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = move ((_4 as Continue).0: proc_macro2::Ident);
        _3 = move _8;
        _10 = ParseBuffer::<'_>::parse::<syn::token::Eq>(_1) -> [return: bb8, unwind: bb25];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Arg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb23, unwind continue];
    }

    bb8: {
        _9 = <std::result::Result<syn::token::Eq, syn::Error> as std::ops::Try>::branch(move _10) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb10, 1: bb11, otherwise: bb6];
    }

    bb10: {
        _13 = ((_9 as Continue).0: syn::token::Eq);
        _16 = ParseBuffer::<'_>::parse::<uri_parsing::ArgExpr>(_1) -> [return: bb12, unwind: bb25];
    }

    bb11: {
        _12 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Arg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _12) -> [return: bb27, unwind: bb25];
    }

    bb12: {
        _15 = <std::result::Result<uri_parsing::ArgExpr, syn::Error> as std::ops::Try>::branch(move _16) -> [return: bb13, unwind: bb25];
    }

    bb13: {
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb14, 1: bb15, otherwise: bb6];
    }

    bb14: {
        _19 = move ((_15 as Continue).0: bang::uri_parsing::ArgExpr);
        _14 = move _19;
        _22 = &_3;
        _21 = <name::Name as From<&proc_macro2::Ident>>::from(move _22) -> [return: bb16, unwind: bb24];
    }

    bb15: {
        _18 = move ((_15 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Arg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _18) -> [return: bb28, unwind: bb25];
    }

    bb16: {
        _23 = move _3;
        _24 = move _14;
        _20 = Arg::Named(move _21, move _23, _13, move _24);
        _0 = std::result::Result::<Arg, syn::Error>::Ok(move _20);
        goto -> bb23;
    }

    bb17: {
        _26 = ParseBuffer::<'_>::parse::<uri_parsing::ArgExpr>(_1) -> [return: bb18, unwind continue];
    }

    bb18: {
        _25 = <std::result::Result<uri_parsing::ArgExpr, syn::Error> as std::ops::Try>::branch(move _26) -> [return: bb19, unwind continue];
    }

    bb19: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb20, 1: bb21, otherwise: bb6];
    }

    bb20: {
        _29 = move ((_25 as Continue).0: bang::uri_parsing::ArgExpr);
        _30 = Arg::Unnamed(move _29);
        _0 = std::result::Result::<Arg, syn::Error>::Ok(move _30);
        goto -> bb23;
    }

    bb21: {
        _28 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Arg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _28) -> [return: bb23, unwind continue];
    }

    bb22: {
        drop(_3) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_14) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_3) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27: {
        goto -> bb22;
    }

    bb28: {
        goto -> bb22;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:158:1: 158:20>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::Args, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::Args, syn::Error>;
    let mut _2: bool;
    let mut _3: syn::buffer::Cursor<'_>;
    let mut _4: bang::uri_parsing::Args;
    let mut _5: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let _6: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>>;
    let mut _8: std::result::Result<syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>, syn::Error>;
    let mut _9: for<'a> fn(&'a syn::parse::ParseBuffer<'a>) -> std::result::Result<bang::uri_parsing::Arg, syn::Error>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, syn::Error>;
    let _12: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _14: syn::punctuated::Iter<'_, bang::uri_parsing::Arg>;
    let mut _15: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _17: std::option::Option<&bang::uri_parsing::Arg>;
    let mut _18: &mut syn::punctuated::Iter<'_, bang::uri_parsing::Arg>;
    let mut _19: isize;
    let mut _21: isize;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: proc_macro2::Span;
    let mut _26: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _27: std::option::Option<bool>;
    let mut _28: bool;
    let mut _29: isize;
    let mut _30: bang::uri_parsing::Args;
    let mut _31: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _32: bang::uri_parsing::Args;
    let mut _33: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    scope 1 {
        debug args => _6;
        let mut _13: std::option::Option<bool>;
        scope 6 {
            debug first_is_named => _13;
            let mut _16: syn::punctuated::Iter<'_, bang::uri_parsing::Arg>;
            scope 7 {
                debug iter => _16;
                let _20: &bang::uri_parsing::Arg;
                scope 8 {
                    debug arg => _20;
                    scope 9 {
                        debug first_is_named => _22;
                        let _22: bool;
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _11;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _3 = ParseBuffer::<'_>::cursor(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = syn::buffer::Cursor::<'_>::eof(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _5 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = uri_parsing::Args::Unnamed(move _5);
        _0 = std::result::Result::<uri_parsing::Args, syn::Error>::Ok(move _4);
        goto -> bb28;
    }

    bb5: {
        _9 = <bang::uri_parsing::Arg as syn::parse::Parse>::parse as for<'a> fn(&'a syn::parse::ParseBuffer<'a>) -> std::result::Result<bang::uri_parsing::Arg, syn::Error> (PointerCoercion(ReifyFnPointer));
        _8 = ParseBuffer::<'_>::parse_terminated::<Arg, syn::token::Comma>(_1, move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <std::result::Result<syn::punctuated::Punctuated<Arg, syn::token::Comma>, syn::Error> as std::ops::Try>::branch(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _12 = move ((_7 as Continue).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        _6 = move _12;
        _13 = Option::<bool>::None;
        _15 = &_6;
        _14 = <&syn::punctuated::Punctuated<Arg, syn::token::Comma> as IntoIterator>::into_iter(move _15) -> [return: bb11, unwind: bb30];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _11 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::Args, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _11) -> [return: bb28, unwind continue];
    }

    bb11: {
        _16 = move _14;
        goto -> bb12;
    }

    bb12: {
        _18 = &mut _16;
        _17 = <syn::punctuated::Iter<'_, Arg> as Iterator>::next(_18) -> [return: bb13, unwind: bb29];
    }

    bb13: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb15, 1: bb14, otherwise: bb9];
    }

    bb14: {
        _20 = ((_17 as Some).0: &bang::uri_parsing::Arg);
        _21 = discriminant(_13);
        switchInt(move _21) -> [1: bb16, otherwise: bb21];
    }

    bb15: {
        drop(_16) -> [return: bb23, unwind: bb30];
    }

    bb16: {
        _22 = ((_13 as Some).0: bool);
        _24 = Arg::is_named(_20) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _23 = Ne(_22, move _24);
        switchInt(move _23) -> [0: bb12, otherwise: bb18];
    }

    bb18: {
        _26 = &_6;
        _25 = <syn::punctuated::Punctuated<Arg, syn::token::Comma> as devise::Spanned>::span(move _26) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _0 = err::<uri_parsing::Args, &str>(move _25, const "named and unnamed parameters cannot be mixed") -> [return: bb20, unwind: bb29];
    }

    bb20: {
        drop(_16) -> [return: bb27, unwind: bb30];
    }

    bb21: {
        _28 = Arg::is_named(_20) -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _27 = Option::<bool>::Some(move _28);
        _13 = move _27;
        goto -> bb12;
    }

    bb23: {
        _29 = discriminant(_13);
        switchInt(move _29) -> [1: bb25, otherwise: bb24];
    }

    bb24: {
        _33 = move _6;
        _32 = uri_parsing::Args::Unnamed(move _33);
        _0 = std::result::Result::<uri_parsing::Args, syn::Error>::Ok(move _32);
        goto -> bb28;
    }

    bb25: {
        switchInt(((_13 as Some).0: bool)) -> [0: bb24, otherwise: bb26];
    }

    bb26: {
        _31 = move _6;
        _30 = uri_parsing::Args::Named(move _31);
        _0 = std::result::Result::<uri_parsing::Args, syn::Error>::Ok(move _30);
        goto -> bb28;
    }

    bb27: {
        drop(_6) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_16) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_6) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:186:1: 186:31>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<RouteInvocation, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::RouteInvocation, syn::Error>;
    let _2: syn::Path;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::Path>;
    let mut _4: std::result::Result<syn::Path, syn::Error>;
    let mut _5: &syn::parse::ParseBuffer<'_>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, syn::Error>;
    let _8: syn::Path;
    let mut _10: bool;
    let mut _11: &syn::parse::ParseBuffer<'_>;
    let mut _13: std::result::Result<syn::group::Parens<'_>, syn::Error>;
    let _14: &&syn::parse::ParseBuffer<'_>;
    let mut _15: isize;
    let mut _17: syn::parse::ParseBuffer<'_>;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::Args>;
    let mut _20: std::result::Result<bang::uri_parsing::Args, syn::Error>;
    let mut _21: &syn::parse::ParseBuffer<'_>;
    let mut _22: isize;
    let mut _25: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _26: bang::uri_parsing::RouteInvocation;
    let mut _27: syn::Path;
    let mut _28: bang::uri_parsing::Args;
    let mut _29: &syn::parse::ParseBuffer<'_>;
    let mut _30: bool;
    scope 1 {
        debug path => _2;
        let _9: bang::uri_parsing::Args;
        let _12: syn::parse::ParseBuffer<'_>;
        scope 6 {
            debug args => _9;
        }
        scope 7 {
            debug args => _12;
            let _16: syn::group::Parens<'_>;
            let _18: syn::Error;
            let _23: std::result::Result<std::convert::Infallible, syn::Error>;
            let _24: bang::uri_parsing::Args;
            scope 8 {
                debug parens => _16;
            }
            scope 9 {
                debug error => _18;
            }
            scope 10 {
                debug residual => _23;
                scope 11 {
                }
            }
            scope 12 {
                debug val => _24;
                scope 13 {
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _30 = const false;
        _5 = _1;
        _4 = ParseBuffer::<'_>::parse::<syn::Path>(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<syn::Path, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_3 as Continue).0: syn::Path);
        _2 = move _8;
        _11 = _1;
        _10 = ParseBuffer::<'_>::peek::<fn(syn::lookahead::TokenMarker) -> syn::token::Paren {syn::token::Paren::<syn::lookahead::TokenMarker>}>(move _11, syn::token::Paren::<syn::lookahead::TokenMarker>) -> [return: bb6, unwind: bb24];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<RouteInvocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb22, unwind continue];
    }

    bb6: {
        switchInt(move _10) -> [0: bb17, otherwise: bb7];
    }

    bb7: {
        _14 = &_1;
        _29 = deref_copy (*_14);
        _13 = parse_parens(_29) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb10, 1: bb9, otherwise: bb4];
    }

    bb9: {
        _18 = move ((_13 as Err).0: syn::Error);
        _0 = std::result::Result::<RouteInvocation, syn::Error>::Err(move _18);
        _30 = const false;
        goto -> bb21;
    }

    bb10: {
        _16 = move ((_13 as Ok).0: syn::group::Parens<'_>);
        _17 = move (_16.1: syn::parse::ParseBuffer<'_>);
        _30 = const true;
        _12 = move _17;
        _21 = &_12;
        _20 = ParseBuffer::<'_>::parse::<uri_parsing::Args>(move _21) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _19 = <std::result::Result<uri_parsing::Args, syn::Error> as std::ops::Try>::branch(move _20) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb13, 1: bb14, otherwise: bb4];
    }

    bb13: {
        _24 = move ((_19 as Continue).0: bang::uri_parsing::Args);
        _9 = move _24;
        drop(_12) -> [return: bb16, unwind: bb24];
    }

    bb14: {
        _23 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<RouteInvocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _23) -> [return: bb15, unwind: bb23];
    }

    bb15: {
        drop(_12) -> [return: bb20, unwind: bb24];
    }

    bb16: {
        _30 = const false;
        goto -> bb19;
    }

    bb17: {
        _25 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::new() -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _9 = uri_parsing::Args::Unnamed(move _25);
        goto -> bb19;
    }

    bb19: {
        _27 = move _2;
        _28 = move _9;
        _26 = RouteInvocation { path: move _27, args: move _28 };
        _0 = std::result::Result::<RouteInvocation, syn::Error>::Ok(move _26);
        goto -> bb22;
    }

    bb20: {
        _30 = const false;
        goto -> bb21;
    }

    bb21: {
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_12) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26 (cleanup): {
        drop(_12) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        switchInt(_30) -> [0: bb24, otherwise: bb26];
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:201:1: 201:22>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<UriLit, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::UriLit, syn::Error>;
    let _2: proc_macro_ext::StringLit;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro_ext::StringLit>;
    let mut _4: std::result::Result<proc_macro_ext::StringLit, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: proc_macro_ext::StringLit;
    let mut _9: std::result::Result<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>;
    let _10: &str;
    let _11: &proc_macro_ext::StringLit;
    let mut _12: isize;
    let mut _16: &proc_macro_ext::StringLit;
    let mut _17: std::ops::Range<usize>;
    let mut _18: usize;
    let mut _19: usize;
    let mut _20: &rocket_http::uri::Error<'_>;
    let mut _21: (usize, bool);
    let mut _22: usize;
    let mut _23: usize;
    let mut _24: &rocket_http::uri::Error<'_>;
    let mut _25: (usize, bool);
    let mut _27: std::fmt::Arguments<'_>;
    let mut _28: &[&str];
    let mut _29: &[core::fmt::rt::Argument<'_>];
    let _30: &[core::fmt::rt::Argument<'_>; 1];
    let _31: [core::fmt::rt::Argument<'_>; 1];
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &rocket_http::uri::Error<'_>;
    let mut _34: bang::uri_parsing::UriLit;
    let mut _35: rocket_http::uri::Uri<'_>;
    let mut _36: proc_macro2::Span;
    let mut _37: &proc_macro_ext::StringLit;
    let mut _39: bool;
    scope 1 {
        debug string => _2;
        let _8: rocket_http::uri::Uri<'_>;
        let _13: rocket_http::uri::Uri<'_>;
        let _14: rocket_http::uri::Error<'_>;
        scope 6 {
            debug uri => _8;
        }
        scope 7 {
            debug uri => _13;
        }
        scope 8 {
            debug e => _14;
            let _15: proc_macro2::Span;
            scope 9 {
                debug span => _15;
                let _26: std::string::String;
                let mut _38: &[&str; 1];
                scope 10 {
                    debug res => _26;
                }
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _39 = const false;
        _4 = ParseBuffer::<'_>::parse::<StringLit>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<StringLit, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: proc_macro_ext::StringLit);
        _2 = move _7;
        _11 = &_2;
        _10 = <StringLit as std::ops::Deref>::deref(_11) -> [return: bb6, unwind: bb25];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<UriLit, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb22, unwind continue];
    }

    bb6: {
        _9 = rocket_http::uri::Uri::<'_>::parse_any(_10) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb9, 1: bb8, otherwise: bb4];
    }

    bb8: {
        _14 = move ((_9 as Err).0: rocket_http::uri::Error<'_>);
        _16 = &_2;
        _20 = &_14;
        _19 = rocket_http::uri::Error::<'_>::index(move _20) -> [return: bb11, unwind: bb24];
    }

    bb9: {
        _13 = move ((_9 as Ok).0: rocket_http::uri::Uri<'_>);
        _8 = <rocket_http::uri::Uri<'_> as IntoOwned>::into_owned(move _13) -> [return: bb10, unwind: bb25];
    }

    bb10: {
        _39 = const true;
        _39 = const false;
        _35 = move _8;
        _37 = &_2;
        _36 = StringLit::span(move _37) -> [return: bb20, unwind: bb23];
    }

    bb11: {
        _21 = CheckedAdd(_19, const 1_usize);
        assert(!move (_21.1: bool), "attempt to compute `{} + {}`, which would overflow", move _19, const 1_usize) -> [success: bb12, unwind: bb24];
    }

    bb12: {
        _18 = move (_21.0: usize);
        _24 = &_14;
        _23 = rocket_http::uri::Error::<'_>::index(move _24) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _25 = CheckedAdd(_23, const 2_usize);
        assert(!move (_25.1: bool), "attempt to compute `{} + {}`, which would overflow", move _23, const 2_usize) -> [success: bb14, unwind: bb24];
    }

    bb14: {
        _22 = move (_25.0: usize);
        _17 = std::ops::Range::<usize> { start: move _18, end: move _22 };
        _15 = StringLit::subspan::<std::ops::Range<usize>>(move _16, move _17) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _38 = const _;
        _28 = _38 as &[&str] (PointerCoercion(Unsize));
        _33 = &_14;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Error<'_>>(_33) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _31 = [move _32];
        _30 = &_31;
        _29 = _30 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _27 = std::fmt::Arguments::<'_>::new_v1(move _28, move _29) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _26 = format(move _27) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _0 = err::<UriLit, std::string::String>(_15, move _26) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        drop(_14) -> [return: bb21, unwind: bb25];
    }

    bb20: {
        _34 = UriLit(move _35, move _36);
        _0 = std::result::Result::<UriLit, syn::Error>::Ok(move _34);
        _39 = const false;
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb21: {
        _39 = const false;
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_35) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_14) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_2) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27 (cleanup): {
        drop(_8) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_39) -> [0: bb25, otherwise: bb27];
    }
}

promoted[0] in uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:201:1: 201:22>::parse: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "invalid URI: "];
        _0 = &_1;
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:216:1: 216:14>::unary(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::UriMacro, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _2: bool;
    let mut _3: bang::uri_parsing::UriMacro;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::UriLit>;
    let mut _5: std::result::Result<bang::uri_parsing::UriLit, syn::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, syn::Error>;
    let _8: bang::uri_parsing::UriLit;
    let mut _9: bang::uri_parsing::UriMacro;
    let mut _10: bang::uri_parsing::RoutedUri;
    let mut _11: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::RouteInvocation>;
    let mut _13: std::result::Result<bang::uri_parsing::RouteInvocation, syn::Error>;
    let mut _14: isize;
    let _15: std::result::Result<std::convert::Infallible, syn::Error>;
    let _16: bang::uri_parsing::RouteInvocation;
    let mut _17: std::option::Option<bang::uri_parsing::UriExpr>;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _15;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _16;
        scope 8 {
        }
    }

    bb0: {
        _2 = ParseBuffer::<'_>::peek::<fn(syn::lookahead::TokenMarker) -> LitStr {LitStr}>(_1, LitStr) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _5 = ParseBuffer::<'_>::parse::<UriLit>(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<UriLit, syn::Error> as std::ops::Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = move ((_4 as Continue).0: bang::uri_parsing::UriLit);
        _3 = uri_parsing::UriMacro::Literal(move _8);
        _0 = std::result::Result::<uri_parsing::UriMacro, syn::Error>::Ok(move _3);
        goto -> bb14;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb14, unwind continue];
    }

    bb8: {
        _11 = Option::<UriExpr>::None;
        _13 = ParseBuffer::<'_>::parse::<RouteInvocation>(_1) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _12 = <std::result::Result<RouteInvocation, syn::Error> as std::ops::Try>::branch(move _13) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb11, 1: bb12, otherwise: bb6];
    }

    bb11: {
        _16 = move ((_12 as Continue).0: bang::uri_parsing::RouteInvocation);
        _17 = Option::<UriExpr>::None;
        _10 = RoutedUri { prefix: move _11, route: move _16, suffix: move _17 };
        _9 = uri_parsing::UriMacro::Routed(move _10);
        _0 = std::result::Result::<uri_parsing::UriMacro, syn::Error>::Ok(move _9);
        goto -> bb14;
    }

    bb12: {
        _15 = move ((_12 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _15) -> [return: bb13, unwind: bb15];
    }

    bb13: {
        drop(_11) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_11) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_11) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:216:1: 216:14>::binary(_1: TokenStream2, _2: TokenStream2) -> std::result::Result<uri_parsing::UriMacro, syn::Error> {
    debug prefix => _1;
    debug middle => _2;
    let mut _0: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _3: bang::uri_parsing::UriMacro;
    let mut _4: bang::uri_parsing::RoutedUri;
    let mut _5: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, std::option::Option<bang::uri_parsing::UriExpr>>;
    let mut _7: std::result::Result<std::option::Option<bang::uri_parsing::UriExpr>, syn::Error>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, syn::Error>;
    let _10: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::RouteInvocation>;
    let mut _12: std::result::Result<bang::uri_parsing::RouteInvocation, syn::Error>;
    let mut _13: proc_macro2::TokenStream;
    let mut _14: isize;
    let _15: std::result::Result<std::convert::Infallible, syn::Error>;
    let _16: bang::uri_parsing::RouteInvocation;
    let mut _17: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _18: bool;
    scope 1 {
        debug residual => _9;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _10;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _15;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _16;
        scope 8 {
        }
    }

    bb0: {
        _18 = const false;
        _18 = const true;
        _7 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<Option<UriExpr>, syn::Error> {UriExpr::parse_prefix} as Parser>::parse2(UriExpr::parse_prefix, move _1) -> [return: bb1, unwind: bb18];
    }

    bb1: {
        _6 = <std::result::Result<Option<UriExpr>, syn::Error> as std::ops::Try>::branch(move _7) -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _10 = move ((_6 as Continue).0: std::option::Option<bang::uri_parsing::UriExpr>);
        _5 = move _10;
        _18 = const false;
        _13 = move _2;
        _12 = syn::parse2::<RouteInvocation>(move _13) -> [return: bb6, unwind: bb13];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _9) -> [return: bb19, unwind: bb18];
    }

    bb6: {
        _11 = <std::result::Result<RouteInvocation, syn::Error> as std::ops::Try>::branch(move _12) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _14 = discriminant(_11);
        switchInt(move _14) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _16 = move ((_11 as Continue).0: bang::uri_parsing::RouteInvocation);
        _17 = Option::<UriExpr>::None;
        _4 = RoutedUri { prefix: move _5, route: move _16, suffix: move _17 };
        _3 = uri_parsing::UriMacro::Routed(move _4);
        _0 = std::result::Result::<uri_parsing::UriMacro, syn::Error>::Ok(move _3);
        goto -> bb11;
    }

    bb9: {
        _15 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _15) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_5) -> [return: bb15, unwind: bb18];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_5) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_5) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        switchInt(_18) -> [0: bb11, otherwise: bb16];
    }

    bb16: {
        drop(_2) -> [return: bb11, unwind continue];
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_18) -> [0: bb14, otherwise: bb17];
    }

    bb19: {
        goto -> bb15;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:216:1: 216:14>::ternary(_1: TokenStream2, _2: TokenStream2, _3: TokenStream2) -> std::result::Result<uri_parsing::UriMacro, syn::Error> {
    debug prefix => _1;
    debug mid => _2;
    debug suffix => _3;
    let mut _0: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _4: bang::uri_parsing::UriMacro;
    let mut _5: bang::uri_parsing::RoutedUri;
    let mut _6: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, std::option::Option<bang::uri_parsing::UriExpr>>;
    let mut _8: std::result::Result<std::option::Option<bang::uri_parsing::UriExpr>, syn::Error>;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, syn::Error>;
    let _11: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _12: bang::uri_parsing::RouteInvocation;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::RouteInvocation>;
    let mut _14: std::result::Result<bang::uri_parsing::RouteInvocation, syn::Error>;
    let mut _15: proc_macro2::TokenStream;
    let mut _16: isize;
    let _17: std::result::Result<std::convert::Infallible, syn::Error>;
    let _18: bang::uri_parsing::RouteInvocation;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, std::option::Option<bang::uri_parsing::UriExpr>>;
    let mut _20: std::result::Result<std::option::Option<bang::uri_parsing::UriExpr>, syn::Error>;
    let mut _21: proc_macro2::TokenStream;
    let mut _22: isize;
    let _23: std::result::Result<std::convert::Infallible, syn::Error>;
    let _24: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _25: bool;
    let mut _26: bool;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _17;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _18;
        scope 8 {
        }
    }
    scope 9 {
        debug residual => _23;
        scope 10 {
        }
    }
    scope 11 {
        debug val => _24;
        scope 12 {
        }
    }

    bb0: {
        _26 = const false;
        _25 = const false;
        _26 = const true;
        _25 = const true;
        _8 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<Option<UriExpr>, syn::Error> {UriExpr::parse_prefix} as Parser>::parse2(UriExpr::parse_prefix, move _1) -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _7 = <std::result::Result<Option<UriExpr>, syn::Error> as std::ops::Try>::branch(move _8) -> [return: bb2, unwind: bb30];
    }

    bb2: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _11 = move ((_7 as Continue).0: std::option::Option<bang::uri_parsing::UriExpr>);
        _6 = move _11;
        _26 = const false;
        _15 = move _2;
        _14 = syn::parse2::<RouteInvocation>(move _15) -> [return: bb6, unwind: bb23];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _10) -> [return: bb32, unwind: bb30];
    }

    bb6: {
        _13 = <std::result::Result<RouteInvocation, syn::Error> as std::ops::Try>::branch(move _14) -> [return: bb7, unwind: bb23];
    }

    bb7: {
        _16 = discriminant(_13);
        switchInt(move _16) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _18 = move ((_13 as Continue).0: bang::uri_parsing::RouteInvocation);
        _12 = move _18;
        _25 = const false;
        _21 = move _3;
        _20 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<Option<UriExpr>, syn::Error> {UriExpr::parse_suffix} as Parser>::parse2(UriExpr::parse_suffix, move _21) -> [return: bb11, unwind: bb21];
    }

    bb9: {
        _17 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _17) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        drop(_6) -> [return: bb26, unwind: bb30];
    }

    bb11: {
        _19 = <std::result::Result<Option<UriExpr>, syn::Error> as std::ops::Try>::branch(move _20) -> [return: bb12, unwind: bb21];
    }

    bb12: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb13, 1: bb14, otherwise: bb4];
    }

    bb13: {
        _24 = move ((_19 as Continue).0: std::option::Option<bang::uri_parsing::UriExpr>);
        _5 = RoutedUri { prefix: move _6, route: move _12, suffix: move _24 };
        _4 = uri_parsing::UriMacro::Routed(move _5);
        _0 = std::result::Result::<uri_parsing::UriMacro, syn::Error>::Ok(move _4);
        goto -> bb18;
    }

    bb14: {
        _23 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _23) -> [return: bb15, unwind: bb19];
    }

    bb15: {
        drop(_12) -> [return: bb16, unwind: bb20];
    }

    bb16: {
        drop(_6) -> [return: bb26, unwind: bb30];
    }

    bb17: {
        switchInt(_26) -> [0: bb18, otherwise: bb28];
    }

    bb18: {
        return;
    }

    bb19 (cleanup): {
        drop(_12) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop(_6) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_12) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_6) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_6) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_26) -> [0: bb25, otherwise: bb31];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        switchInt(_25) -> [0: bb17, otherwise: bb27];
    }

    bb27: {
        drop(_3) -> [return: bb17, unwind: bb24];
    }

    bb28: {
        drop(_2) -> [return: bb18, unwind continue];
    }

    bb29 (cleanup): {
        drop(_3) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_25) -> [0: bb24, otherwise: bb29];
    }

    bb31 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb32: {
        goto -> bb26;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:246:1: 246:24>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::UriMacro, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _2: std::vec::Vec<proc_macro2::TokenStream>;
    let mut _3: std::option::Option<proc_macro2::TokenStream>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, std::option::Option<proc_macro2::TokenStream>>;
    let mut _5: std::result::Result<std::option::Option<proc_macro2::TokenStream>, syn::Error>;
    let mut _6: isize;
    let mut _9: isize;
    let _11: ();
    let mut _12: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _15: (usize, std::vec::IntoIter<proc_macro2::TokenStream>);
    let mut _16: usize;
    let mut _17: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _18: std::vec::IntoIter<proc_macro2::TokenStream>;
    let mut _19: std::vec::Vec<proc_macro2::TokenStream>;
    let mut _21: &mut std::vec::IntoIter<proc_macro2::TokenStream>;
    let mut _22: proc_macro2::Span;
    let mut _23: proc_macro2::TokenStream;
    let mut _24: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _25: proc_macro2::TokenStream;
    let mut _26: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _27: proc_macro2::TokenStream;
    let mut _28: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _29: proc_macro2::TokenStream;
    let mut _30: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _31: proc_macro2::TokenStream;
    let mut _32: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _33: proc_macro2::TokenStream;
    let mut _34: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
    let mut _36: proc_macro2::Span;
    let mut _37: &proc_macro2::TokenStream;
    let _38: proc_macro2::TokenStream;
    let mut _39: std::option::Option<proc_macro2::TokenStream>;
    let mut _40: &mut std::iter::Skip<std::vec::IntoIter<proc_macro2::TokenStream>>;
    let mut _41: std::iter::Skip<std::vec::IntoIter<proc_macro2::TokenStream>>;
    let mut _42: std::vec::IntoIter<proc_macro2::TokenStream>;
    let mut _44: std::fmt::Arguments<'_>;
    let mut _45: &[&str];
    let mut _46: &[core::fmt::rt::Argument<'_>];
    let _47: &[core::fmt::rt::Argument<'_>; 1];
    let _48: [core::fmt::rt::Argument<'_>; 1];
    let mut _49: core::fmt::rt::Argument<'_>;
    let _50: &usize;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: bool;
    scope 1 {
        debug args => _2;
        let _13: usize;
        let mut _14: std::vec::IntoIter<proc_macro2::TokenStream>;
        scope 2 {
            debug tokens => _10;
            let _7: std::result::Result<std::convert::Infallible, syn::Error>;
            let _8: std::option::Option<proc_macro2::TokenStream>;
            let _10: proc_macro2::TokenStream;
            scope 3 {
                debug residual => _7;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _8;
                scope 6 {
                }
            }
        }
        scope 7 {
            debug arg_count => _13;
            debug iter => _14;
            let mut _20: {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26};
            scope 8 {
                debug next => _20;
                let _35: usize;
                scope 9 {
                    debug n => _35;
                    let _43: std::string::String;
                    let mut _51: &[&str; 1];
                    scope 10 {
                        debug res => _43;
                    }
                }
            }
        }
    }

    bb0: {
        _56 = const false;
        _52 = const false;
        _55 = const false;
        _54 = const false;
        _53 = const false;
        _56 = const true;
        _2 = Vec::<TokenStream2>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ParseBuffer::<'_>::step::<for<'c, 'a> fn(StepCursor<'c, 'a>) -> std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'c>), syn::Error> {stream}, Option<TokenStream2>>(_1, stream) -> [return: bb2, unwind: bb53];
    }

    bb2: {
        _4 = <std::result::Result<Option<TokenStream2>, syn::Error> as std::ops::Try>::branch(move _5) -> [return: bb3, unwind: bb53];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _8 = move ((_4 as Continue).0: std::option::Option<proc_macro2::TokenStream>);
        _3 = move _8;
        _9 = discriminant(_3);
        switchInt(move _9) -> [1: bb9, otherwise: bb8];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb7, unwind: bb53];
    }

    bb7: {
        drop(_2) -> [return: bb37, unwind continue];
    }

    bb8: {
        drop(_3) -> [return: bb42, unwind: bb53];
    }

    bb9: {
        _10 = move ((_3 as Some).0: proc_macro2::TokenStream);
        _12 = &mut _2;
        _11 = Vec::<TokenStream2>::push(move _12, move _10) -> [return: bb54, unwind: bb53];
    }

    bb10: {
        _56 = const false;
        _19 = move _2;
        _18 = <Vec<TokenStream2> as IntoIterator>::into_iter(move _19) -> [return: bb11, unwind: bb53];
    }

    bb11: {
        _15 = (move _16, move _18);
        _13 = (_15.0: usize);
        _52 = const true;
        _14 = move (_15.1: std::vec::IntoIter<proc_macro2::TokenStream>);
        _21 = &mut _14;
        _20 = {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} { iter: move _21 };
        switchInt(_13) -> [0: bb13, 1: bb15, 2: bb17, 3: bb21, otherwise: bb12];
    }

    bb12: {
        _35 = _13;
        _52 = const false;
        _42 = move _14;
        _41 = <std::vec::IntoIter<TokenStream2> as Iterator>::skip(move _42, const 3_usize) -> [return: bb26, unwind: bb51];
    }

    bb13: {
        _22 = proc_macro2::Span::call_site() -> [return: bb14, unwind: bb51];
    }

    bb14: {
        _0 = err::<uri_parsing::UriMacro, &str>(move _22, const "expected at least 1 argument, found none") -> [return: bb55, unwind: bb51];
    }

    bb15: {
        _24 = &mut _20;
        _23 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _24, const ()) -> [return: bb16, unwind: bb51];
    }

    bb16: {
        _0 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<uri_parsing::UriMacro, syn::Error> {uri_parsing::UriMacro::unary} as Parser>::parse2(uri_parsing::UriMacro::unary, move _23) -> [return: bb56, unwind: bb51];
    }

    bb17: {
        _26 = &mut _20;
        _25 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _26, const ()) -> [return: bb18, unwind: bb51];
    }

    bb18: {
        _55 = const true;
        _28 = &mut _20;
        _27 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _28, const ()) -> [return: bb19, unwind: bb49];
    }

    bb19: {
        _55 = const false;
        _0 = uri_parsing::UriMacro::binary(move _25, move _27) -> [return: bb20, unwind: bb49];
    }

    bb20: {
        _55 = const false;
        goto -> bb35;
    }

    bb21: {
        _30 = &mut _20;
        _29 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _30, const ()) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        _54 = const true;
        _32 = &mut _20;
        _31 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _32, const ()) -> [return: bb23, unwind: bb47];
    }

    bb23: {
        _53 = const true;
        _34 = &mut _20;
        _33 = <{closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26} as FnMut<()>>::call_mut(move _34, const ()) -> [return: bb24, unwind: bb45];
    }

    bb24: {
        _54 = const false;
        _53 = const false;
        _0 = uri_parsing::UriMacro::ternary(move _29, move _31, move _33) -> [return: bb25, unwind: bb45];
    }

    bb25: {
        _53 = const false;
        _54 = const false;
        goto -> bb35;
    }

    bb26: {
        _40 = &mut _41;
        _39 = <Skip<std::vec::IntoIter<TokenStream2>> as Iterator>::next(move _40) -> [return: bb27, unwind: bb40];
    }

    bb27: {
        _38 = Option::<TokenStream2>::unwrap(move _39) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _37 = &_38;
        _36 = <TokenStream2 as devise::Spanned>::span(move _37) -> [return: bb29, unwind: bb39];
    }

    bb29: {
        _51 = const _;
        _45 = _51 as &[&str] (PointerCoercion(Unsize));
        _50 = &_35;
        _49 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_50) -> [return: bb30, unwind: bb39];
    }

    bb30: {
        _48 = [move _49];
        _47 = &_48;
        _46 = _47 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _44 = std::fmt::Arguments::<'_>::new_v1(move _45, move _46) -> [return: bb31, unwind: bb39];
    }

    bb31: {
        _43 = format(move _44) -> [return: bb32, unwind: bb39];
    }

    bb32: {
        _0 = err::<uri_parsing::UriMacro, std::string::String>(move _36, move _43) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        drop(_38) -> [return: bb34, unwind: bb40];
    }

    bb34: {
        drop(_41) -> [return: bb35, unwind: bb51];
    }

    bb35: {
        switchInt(_52) -> [0: bb36, otherwise: bb43];
    }

    bb36: {
        _52 = const false;
        _56 = const false;
        goto -> bb38;
    }

    bb37: {
        _56 = const false;
        goto -> bb38;
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_38) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_41) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        resume;
    }

    bb42: {
        _17 = &_2;
        _16 = Vec::<TokenStream2>::len(move _17) -> [return: bb10, unwind: bb53];
    }

    bb43: {
        drop(_14) -> [return: bb36, unwind: bb53];
    }

    bb44 (cleanup): {
        drop(_31) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_53) -> [0: bb47, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_29) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_54) -> [0: bb51, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop(_25) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        switchInt(_55) -> [0: bb51, otherwise: bb48];
    }

    bb50 (cleanup): {
        drop(_14) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        switchInt(_52) -> [0: bb53, otherwise: bb50];
    }

    bb52 (cleanup): {
        drop(_2) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        switchInt(_56) -> [0: bb41, otherwise: bb52];
    }

    bb54: {
        goto -> bb1;
    }

    bb55: {
        goto -> bb35;
    }

    bb56: {
        goto -> bb35;
    }
}

promoted[0] in uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:246:1: 246:24>::parse: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "expected 1, 2, or 3 arguments, found "];
        _0 = &_1;
        return;
    }
}

fn stream(_1: StepCursor<'_, '_>) -> std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error> {
    debug cursor => _1;
    let mut _0: std::result::Result<(std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>), syn::Error>;
    let mut _2: proc_macro2::TokenStream;
    let mut _4: &syn::buffer::Cursor<'_>;
    let mut _5: &syn::parse::StepCursor<'_, '_>;
    let mut _6: ();
    let mut _7: std::option::Option<(proc_macro2::TokenTree, syn::buffer::Cursor<'_>)>;
    let mut _8: syn::buffer::Cursor<'_>;
    let mut _9: isize;
    let mut _12: isize;
    let mut _15: char;
    let mut _16: &mut proc_macro2::TokenStream;
    let mut _17: proc_macro2::TokenTree;
    let mut _18: std::option::Option<std::result::Result<(std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>), syn::Error>>;
    let mut _19: bool;
    let mut _20: &proc_macro2::TokenStream;
    let mut _21: {closure@core/codegen/src/bang/uri_parsing.rs:263:23: 263:25};
    let mut _22: &syn::buffer::Cursor<'_>;
    let mut _23: {closure@core/codegen/src/bang/uri_parsing.rs:264:33: 264:35};
    let mut _24: &syn::buffer::Cursor<'_>;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: isize;
    let mut _29: isize;
    scope 1 {
        debug stream => _2;
        let mut _3: syn::buffer::Cursor<'_>;
        scope 2 {
            debug cursor => _3;
            scope 3 {
                debug tt => _10;
                debug next => _11;
                let _10: proc_macro2::TokenTree;
                let _11: syn::buffer::Cursor<'_>;
                let _13: proc_macro2::Punct;
                let _14: &proc_macro2::Punct;
                scope 4 {
                    debug p => _13;
                    debug p => _14;
                }
            }
        }
    }

    bb0: {
        _27 = const false;
        _26 = const false;
        _25 = const false;
        _27 = const true;
        _2 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &_1;
        _4 = <StepCursor<'_, '_> as std::ops::Deref>::deref(move _5) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _3 = (*_4);
        goto -> bb3;
    }

    bb3: {
        _8 = _3;
        _7 = syn::buffer::Cursor::<'_>::token_tree(move _8) -> [return: bb4, unwind: bb24];
    }

    bb4: {
        _25 = const true;
        _9 = discriminant(_7);
        switchInt(move _9) -> [1: bb5, otherwise: bb19];
    }

    bb5: {
        _25 = const false;
        _26 = const true;
        _10 = move (((_7 as Some).0: (proc_macro2::TokenTree, syn::buffer::Cursor<'_>)).0: proc_macro2::TokenTree);
        _11 = (((_7 as Some).0: (proc_macro2::TokenTree, syn::buffer::Cursor<'_>)).1: syn::buffer::Cursor<'_>);
        _3 = _11;
        _12 = discriminant(_10);
        switchInt(move _12) -> [2: bb7, otherwise: bb6];
    }

    bb6: {
        _16 = &mut _2;
        _26 = const false;
        _17 = move _10;
        _6 = <TokenStream2 as quote::TokenStreamExt>::append::<proc_macro2::TokenTree>(move _16, move _17) -> [return: bb10, unwind: bb22];
    }

    bb7: {
        _14 = &((_10 as Punct).0: proc_macro2::Punct);
        _15 = proc_macro2::Punct::as_char(_14) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        switchInt(move _15) -> [44: bb9, otherwise: bb6];
    }

    bb9: {
        _13 = move ((_10 as Punct).0: proc_macro2::Punct);
        drop(_10) -> [return: bb11, unwind: bb24];
    }

    bb10: {
        _26 = const false;
        _25 = const false;
        goto -> bb3;
    }

    bb11: {
        _26 = const false;
        goto -> bb19;
    }

    bb12: {
        _22 = &_3;
        _21 = {closure@core/codegen/src/bang/uri_parsing.rs:263:23: 263:25} { cursor: move _22 };
        _18 = core::bool::<impl bool>::then::<std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error>, {closure@core/codegen/src/bang/uri_parsing.rs:263:23: 263:25}>(move _19, move _21) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _24 = &_3;
        _27 = const false;
        _23 = {closure@core/codegen/src/bang/uri_parsing.rs:264:33: 264:35} { stream: move _2, cursor: move _24 };
        _0 = Option::<std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error>>::unwrap_or_else::<{closure@core/codegen/src/bang/uri_parsing.rs:264:33: 264:35}>(move _18, move _23) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _27 = const false;
        return;
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        _25 = const false;
        _20 = &_2;
        _19 = TokenStream2::is_empty(move _20) -> [return: bb12, unwind: bb24];
    }

    bb17: {
        switchInt(_25) -> [0: bb16, otherwise: bb18];
    }

    bb18: {
        drop((((_7 as Some).0: (proc_macro2::TokenTree, syn::buffer::Cursor<'_>)).0: proc_macro2::TokenTree)) -> [return: bb16, unwind: bb24];
    }

    bb19: {
        _28 = discriminant(_7);
        switchInt(move _28) -> [1: bb17, otherwise: bb16];
    }

    bb20 (cleanup): {
        drop(_10) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        _29 = discriminant(_10);
        switchInt(move _29) -> [2: bb24, otherwise: bb20];
    }

    bb22 (cleanup): {
        switchInt(_26) -> [0: bb24, otherwise: bb21];
    }

    bb23 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_27) -> [0: bb15, otherwise: bb23];
    }
}

fn stream::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:263:23: 263:25}) -> std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error> {
    debug cursor => (*(_1.0: &syn::buffer::Cursor<'_>));
    let mut _0: std::result::Result<(std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>), syn::Error>;
    let mut _2: (std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>);
    let mut _3: std::option::Option<proc_macro2::TokenStream>;
    let mut _4: syn::buffer::Cursor<'_>;
    let mut _5: &syn::buffer::Cursor<'_>;

    bb0: {
        _3 = Option::<TokenStream2>::None;
        _5 = deref_copy (_1.0: &syn::buffer::Cursor<'_>);
        _4 = (*_5);
        _2 = (move _3, move _4);
        _0 = std::result::Result::<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error>::Ok(move _2);
        return;
    }
}

fn stream::{closure#1}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:264:33: 264:35}) -> std::result::Result<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error> {
    debug stream => (_1.0: proc_macro2::TokenStream);
    debug cursor => (*(_1.1: &syn::buffer::Cursor<'_>));
    let mut _0: std::result::Result<(std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>), syn::Error>;
    let mut _2: (std::option::Option<proc_macro2::TokenStream>, syn::buffer::Cursor<'_>);
    let mut _3: std::option::Option<proc_macro2::TokenStream>;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: syn::buffer::Cursor<'_>;
    let mut _6: &syn::buffer::Cursor<'_>;

    bb0: {
        _4 = move (_1.0: proc_macro2::TokenStream);
        _3 = Option::<TokenStream2>::Some(move _4);
        _6 = deref_copy (_1.1: &syn::buffer::Cursor<'_>);
        _5 = (*_6);
        _2 = (move _3, move _5);
        _0 = std::result::Result::<(Option<TokenStream2>, syn::buffer::Cursor<'_>), syn::Error>::Ok(move _2);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:246:1: 246:24>::parse::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:273:24: 273:26}) -> TokenStream2 {
    debug iter => (*((*_1).0: &mut std::vec::IntoIter<proc_macro2::TokenStream>));
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::option::Option<proc_macro2::TokenStream>;
    let mut _3: &mut std::vec::IntoIter<proc_macro2::TokenStream>;

    bb0: {
        _3 = deref_copy ((*_1).0: &mut std::vec::IntoIter<proc_macro2::TokenStream>);
        _2 = <std::vec::IntoIter<TokenStream2> as Iterator>::next(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<TokenStream2>::unwrap(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:285:1: 285:25>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<RoutedUri, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::RoutedUri, syn::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::UriMacro>;
    let mut _3: std::result::Result<bang::uri_parsing::UriMacro, syn::Error>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, syn::Error>;
    let _6: bang::uri_parsing::UriMacro;
    let mut _7: isize;
    let _8: bang::uri_parsing::RoutedUri;
    let _9: bang::uri_parsing::UriLit;
    let mut _10: proc_macro2::Span;
    let mut _11: &bang::uri_parsing::UriLit;
    scope 1 {
        debug residual => _5;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _6;
        scope 4 {
        }
    }
    scope 5 {
        debug route => _8;
    }
    scope 6 {
        debug uri => _9;
    }

    bb0: {
        _3 = <uri_parsing::UriMacro as Parse>::parse(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<uri_parsing::UriMacro, syn::Error> as std::ops::Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = move ((_2 as Continue).0: bang::uri_parsing::UriMacro);
        _7 = discriminant(_6);
        switchInt(move _7) -> [0: bb6, 1: bb7, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<RoutedUri, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _5) -> [return: bb10, unwind continue];
    }

    bb6: {
        _9 = move ((_6 as Literal).0: bang::uri_parsing::UriLit);
        _11 = &_9;
        _10 = <UriLit as devise::Spanned>::span(move _11) -> [return: bb8, unwind: bb11];
    }

    bb7: {
        _8 = move ((_6 as Routed).0: bang::uri_parsing::RoutedUri);
        _0 = std::result::Result::<RoutedUri, syn::Error>::Ok(move _8);
        goto -> bb10;
    }

    bb8: {
        _0 = err::<RoutedUri, &str>(move _10, const "expected route URI, found literal") -> [return: bb9, unwind: bb11];
    }

    bb9: {
        drop(_9) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_9) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:294:1: 294:21>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::FnArg, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::FnArg, syn::Error>;
    let _2: proc_macro2::Ident;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro2::Ident>;
    let mut _4: std::result::Result<proc_macro2::Ident, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: proc_macro2::Ident;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Colon>;
    let mut _9: std::result::Result<syn::token::Colon, syn::Error>;
    let mut _10: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::Type>;
    let mut _15: std::result::Result<syn::Type, syn::Error>;
    let mut _16: isize;
    let _19: ();
    let mut _20: &mut syn::Type;
    let mut _21: bang::uri_parsing::FnArg;
    let mut _22: proc_macro2::Ident;
    let mut _23: syn::Type;
    scope 1 {
        debug ident => _2;
        let _11: std::result::Result<std::convert::Infallible, syn::Error>;
        let _12: syn::token::Colon;
        let mut _13: syn::Type;
        let _17: std::result::Result<std::convert::Infallible, syn::Error>;
        let _18: syn::Type;
        scope 6 {
            debug residual => _11;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _12;
            scope 9 {
            }
        }
        scope 10 {
            debug ty => _13;
        }
        scope 11 {
            debug residual => _17;
            scope 12 {
            }
        }
        scope 13 {
            debug val => _18;
            scope 14 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = ParseBuffer::<'_>::parse::<proc_macro2::Ident>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<proc_macro2::Ident, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: proc_macro2::Ident);
        _2 = move _7;
        _9 = ParseBuffer::<'_>::parse::<syn::token::Colon>(_1) -> [return: bb6, unwind: bb18];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::FnArg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb16, unwind continue];
    }

    bb6: {
        _8 = <std::result::Result<syn::token::Colon, syn::Error> as std::ops::Try>::branch(move _9) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: syn::token::Colon);
        _15 = ParseBuffer::<'_>::parse::<syn::Type>(_1) -> [return: bb10, unwind: bb18];
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::FnArg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _11) -> [return: bb20, unwind: bb18];
    }

    bb10: {
        _14 = <std::result::Result<syn::Type, syn::Error> as std::ops::Try>::branch(move _15) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _18 = move ((_14 as Continue).0: syn::Type);
        _13 = move _18;
        _20 = &mut _13;
        _19 = <syn::Type as devise::ext::TypeExt>::strip_lifetimes(move _20) -> [return: bb14, unwind: bb17];
    }

    bb13: {
        _17 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::FnArg, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _17) -> [return: bb21, unwind: bb18];
    }

    bb14: {
        _22 = move _2;
        _23 = move _13;
        _21 = uri_parsing::FnArg { ident: move _22, ty: move _23 };
        _0 = std::result::Result::<uri_parsing::FnArg, syn::Error>::Ok(move _21);
        goto -> bb16;
    }

    bb15: {
        drop(_2) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_13) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20: {
        goto -> bb15;
    }

    bb21: {
        goto -> bb15;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<uri_parsing::InternalUriParams, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::uri_parsing::InternalUriParams, syn::Error>;
    let _2: proc_macro_ext::StringLit;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro_ext::StringLit>;
    let mut _4: std::result::Result<proc_macro_ext::StringLit, syn::Error>;
    let mut _5: &syn::parse::ParseBuffer<'_>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, syn::Error>;
    let _8: proc_macro_ext::StringLit;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Comma>;
    let mut _10: std::result::Result<syn::token::Comma, syn::Error>;
    let mut _11: &syn::parse::ParseBuffer<'_>;
    let mut _12: isize;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, rocket_http::uri::Origin<'_>>;
    let mut _17: std::result::Result<rocket_http::uri::Origin<'_>, syn::Error>;
    let mut _18: std::result::Result<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>;
    let mut _19: std::result::Result<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>;
    let _20: &str;
    let _21: &proc_macro_ext::StringLit;
    let mut _22: {closure@core/codegen/src/bang/uri_parsing.rs:313:22: 313:25};
    let mut _23: &&syn::parse::ParseBuffer<'_>;
    let mut _24: isize;
    let mut _28: std::result::Result<syn::group::Parens<'_>, syn::Error>;
    let _29: &&syn::parse::ParseBuffer<'_>;
    let mut _30: isize;
    let mut _32: syn::parse::ParseBuffer<'_>;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>>;
    let mut _36: std::result::Result<syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>, syn::Error>;
    let mut _37: &syn::parse::ParseBuffer<'_>;
    let mut _38: for<'a> fn(&'a syn::parse::ParseBuffer<'a>) -> std::result::Result<bang::uri_parsing::FnArg, syn::Error>;
    let mut _39: isize;
    let mut _43: syn::punctuated::IntoIter<bang::uri_parsing::FnArg>;
    let mut _44: syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>;
    let mut _45: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Comma>;
    let mut _46: std::result::Result<syn::token::Comma, syn::Error>;
    let mut _47: &syn::parse::ParseBuffer<'_>;
    let mut _48: isize;
    let mut _52: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::uri_parsing::RoutedUri>;
    let mut _53: std::result::Result<bang::uri_parsing::RoutedUri, syn::Error>;
    let mut _54: &syn::parse::ParseBuffer<'_>;
    let mut _55: isize;
    let mut _59: &proc_macro_ext::StringLit;
    let mut _60: std::ops::Range<usize>;
    let mut _61: usize;
    let mut _62: usize;
    let _63: &rocket_http::RawStr;
    let mut _64: &rocket_http::uri::Path<'_>;
    let _65: rocket_http::uri::Path<'_>;
    let mut _66: &rocket_http::uri::Origin<'_>;
    let mut _67: (usize, bool);
    let mut _69: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/bang/uri_parsing.rs:325:18: 325:21}>;
    let mut _70: std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>;
    let _71: &str;
    let mut _72: &rocket_http::uri::Path<'_>;
    let _73: rocket_http::uri::Path<'_>;
    let mut _74: &rocket_http::uri::Origin<'_>;
    let mut _76: &rocket_http::uri::Origin<'_>;
    let mut _78: std::option::Option<std::vec::Vec<attribute::param::Parameter>>;
    let mut _79: {closure@core/codegen/src/bang/uri_parsing.rs:329:38: 329:45};
    let mut _80: &rocket_http::uri::Origin<'_>;
    let mut _81: &proc_macro_ext::StringLit;
    let mut _82: bang::uri_parsing::InternalUriParams;
    let mut _83: rocket_http::uri::Origin<'_>;
    let mut _84: std::vec::Vec<attribute::param::Parameter>;
    let mut _85: std::vec::Vec<bang::uri_parsing::FnArg>;
    let mut _86: bang::uri_parsing::RoutedUri;
    let mut _87: &syn::parse::ParseBuffer<'_>;
    let mut _88: bool;
    let mut _89: bool;
    let mut _90: bool;
    scope 1 {
        debug route_uri_str => _2;
        let _13: std::result::Result<std::convert::Infallible, syn::Error>;
        let _14: syn::token::Comma;
        let _15: rocket_http::uri::Origin<'_>;
        let _25: std::result::Result<std::convert::Infallible, syn::Error>;
        let _26: rocket_http::uri::Origin<'_>;
        scope 6 {
            debug residual => _13;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _14;
            scope 9 {
            }
        }
        scope 10 {
            debug route_uri => _15;
            let _27: syn::parse::ParseBuffer<'_>;
            scope 15 {
                debug content => _27;
                let _31: syn::group::Parens<'_>;
                let _33: syn::Error;
                let _34: syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>;
                let _40: std::result::Result<std::convert::Infallible, syn::Error>;
                let _41: syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>;
                scope 16 {
                    debug parens => _31;
                }
                scope 17 {
                    debug error => _33;
                }
                scope 18 {
                    debug fn_args => _34;
                    let _42: std::vec::Vec<bang::uri_parsing::FnArg>;
                    scope 23 {
                        debug fn_args => _42;
                        let _49: std::result::Result<std::convert::Infallible, syn::Error>;
                        let _50: syn::token::Comma;
                        let _51: bang::uri_parsing::RoutedUri;
                        let _56: std::result::Result<std::convert::Infallible, syn::Error>;
                        let _57: bang::uri_parsing::RoutedUri;
                        scope 24 {
                            debug residual => _49;
                            scope 25 {
                            }
                        }
                        scope 26 {
                            debug val => _50;
                            scope 27 {
                            }
                        }
                        scope 28 {
                            debug uri_params => _51;
                            let _58: proc_macro2::Span;
                            scope 33 {
                                debug span => _58;
                                let _68: std::vec::Vec<attribute::param::Parameter>;
                                scope 34 {
                                    debug path_params => _68;
                                    let _75: std::option::Option<rocket_http::uri::Query<'_>>;
                                    scope 35 {
                                        debug query => _75;
                                        let _77: std::vec::Vec<attribute::param::Parameter>;
                                        scope 36 {
                                            debug query_params => _77;
                                        }
                                    }
                                }
                            }
                        }
                        scope 29 {
                            debug residual => _56;
                            scope 30 {
                            }
                        }
                        scope 31 {
                            debug val => _57;
                            scope 32 {
                            }
                        }
                    }
                }
                scope 19 {
                    debug residual => _40;
                    scope 20 {
                    }
                }
                scope 21 {
                    debug val => _41;
                    scope 22 {
                    }
                }
            }
        }
        scope 11 {
            debug residual => _25;
            scope 12 {
            }
        }
        scope 13 {
            debug val => _26;
            scope 14 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _90 = const false;
        _88 = const false;
        _89 = const false;
        _5 = _1;
        _4 = ParseBuffer::<'_>::parse::<StringLit>(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<StringLit, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_3 as Continue).0: proc_macro_ext::StringLit);
        _2 = move _8;
        _11 = _1;
        _10 = ParseBuffer::<'_>::parse::<syn::token::Comma>(move _11) -> [return: bb6, unwind: bb58];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb53, unwind continue];
    }

    bb6: {
        _9 = <std::result::Result<syn::token::Comma, syn::Error> as std::ops::Try>::branch(move _10) -> [return: bb7, unwind: bb58];
    }

    bb7: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _14 = ((_9 as Continue).0: syn::token::Comma);
        _21 = &_2;
        _20 = <StringLit as std::ops::Deref>::deref(_21) -> [return: bb10, unwind: bb58];
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _13) -> [return: bb67, unwind: bb58];
    }

    bb10: {
        _19 = rocket_http::uri::Origin::<'_>::parse_route(_20) -> [return: bb11, unwind: bb58];
    }

    bb11: {
        _18 = std::result::Result::<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>::map::<rocket_http::uri::Origin<'_>, {closure@core/codegen/src/bang/uri_parsing.rs:312:18: 312:21}>(move _19, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:312:18: 312:21}) -> [return: bb12, unwind: bb58];
    }

    bb12: {
        _23 = &_1;
        _22 = {closure@core/codegen/src/bang/uri_parsing.rs:313:22: 313:25} { input: move _23 };
        _17 = std::result::Result::<rocket_http::uri::Origin<'_>, rocket_http::uri::Error<'_>>::map_err::<syn::Error, {closure@core/codegen/src/bang/uri_parsing.rs:313:22: 313:25}>(move _18, move _22) -> [return: bb13, unwind: bb58];
    }

    bb13: {
        _16 = <std::result::Result<rocket_http::uri::Origin<'_>, syn::Error> as std::ops::Try>::branch(move _17) -> [return: bb14, unwind: bb58];
    }

    bb14: {
        _24 = discriminant(_16);
        switchInt(move _24) -> [0: bb15, 1: bb16, otherwise: bb4];
    }

    bb15: {
        _26 = move ((_16 as Continue).0: rocket_http::uri::Origin<'_>);
        _90 = const true;
        _15 = move _26;
        _29 = &_1;
        _87 = deref_copy (*_29);
        _28 = parse_parens(_87) -> [return: bb17, unwind: bb65];
    }

    bb16: {
        _25 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _25) -> [return: bb68, unwind: bb58];
    }

    bb17: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb19, 1: bb18, otherwise: bb4];
    }

    bb18: {
        _33 = move ((_28 as Err).0: syn::Error);
        _0 = std::result::Result::<uri_parsing::InternalUriParams, syn::Error>::Err(move _33);
        goto -> bb61;
    }

    bb19: {
        _31 = move ((_28 as Ok).0: syn::group::Parens<'_>);
        _32 = move (_31.1: syn::parse::ParseBuffer<'_>);
        _88 = const true;
        _27 = move _32;
        _37 = &_27;
        _38 = <bang::uri_parsing::FnArg as syn::parse::Parse>::parse as for<'a> fn(&'a syn::parse::ParseBuffer<'a>) -> std::result::Result<bang::uri_parsing::FnArg, syn::Error> (PointerCoercion(ReifyFnPointer));
        _36 = ParseBuffer::<'_>::parse_terminated::<uri_parsing::FnArg, syn::token::Comma>(move _37, move _38) -> [return: bb20, unwind: bb65];
    }

    bb20: {
        _35 = <std::result::Result<syn::punctuated::Punctuated<uri_parsing::FnArg, syn::token::Comma>, syn::Error> as std::ops::Try>::branch(move _36) -> [return: bb21, unwind: bb65];
    }

    bb21: {
        _39 = discriminant(_35);
        switchInt(move _39) -> [0: bb22, 1: bb23, otherwise: bb4];
    }

    bb22: {
        _41 = move ((_35 as Continue).0: syn::punctuated::Punctuated<bang::uri_parsing::FnArg, syn::token::Comma>);
        _89 = const true;
        _34 = move _41;
        _89 = const false;
        _44 = move _34;
        _43 = <syn::punctuated::Punctuated<uri_parsing::FnArg, syn::token::Comma> as IntoIterator>::into_iter(move _44) -> [return: bb24, unwind: bb63];
    }

    bb23: {
        _40 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _40) -> [return: bb69, unwind: bb65];
    }

    bb24: {
        _42 = <syn::punctuated::IntoIter<uri_parsing::FnArg> as Iterator>::collect::<Vec<uri_parsing::FnArg>>(move _43) -> [return: bb25, unwind: bb63];
    }

    bb25: {
        _47 = _1;
        _46 = ParseBuffer::<'_>::parse::<syn::token::Comma>(move _47) -> [return: bb26, unwind: bb56];
    }

    bb26: {
        _45 = <std::result::Result<syn::token::Comma, syn::Error> as std::ops::Try>::branch(move _46) -> [return: bb27, unwind: bb56];
    }

    bb27: {
        _48 = discriminant(_45);
        switchInt(move _48) -> [0: bb28, 1: bb29, otherwise: bb4];
    }

    bb28: {
        _50 = ((_45 as Continue).0: syn::token::Comma);
        _54 = _1;
        _53 = ParseBuffer::<'_>::parse::<RoutedUri>(move _54) -> [return: bb30, unwind: bb56];
    }

    bb29: {
        _49 = move ((_45 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _49) -> [return: bb70, unwind: bb56];
    }

    bb30: {
        _52 = <std::result::Result<RoutedUri, syn::Error> as std::ops::Try>::branch(move _53) -> [return: bb31, unwind: bb56];
    }

    bb31: {
        _55 = discriminant(_52);
        switchInt(move _55) -> [0: bb32, 1: bb33, otherwise: bb4];
    }

    bb32: {
        _57 = move ((_52 as Continue).0: bang::uri_parsing::RoutedUri);
        _51 = move _57;
        _59 = &_2;
        _66 = &_15;
        _65 = rocket_http::uri::Origin::<'_>::path(move _66) -> [return: bb34, unwind: bb55];
    }

    bb33: {
        _56 = move ((_52 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<uri_parsing::InternalUriParams, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _56) -> [return: bb71, unwind: bb56];
    }

    bb34: {
        _64 = &_65;
        _63 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _64) -> [return: bb35, unwind: bb55];
    }

    bb35: {
        _62 = RawStr::len(_63) -> [return: bb36, unwind: bb55];
    }

    bb36: {
        _67 = CheckedAdd(_62, const 1_usize);
        assert(!move (_67.1: bool), "attempt to compute `{} + {}`, which would overflow", move _62, const 1_usize) -> [success: bb37, unwind: bb55];
    }

    bb37: {
        _61 = move (_67.0: usize);
        _60 = std::ops::Range::<usize> { start: const 1_usize, end: move _61 };
        _58 = StringLit::subspan::<std::ops::Range<usize>>(move _59, move _60) -> [return: bb38, unwind: bb55];
    }

    bb38: {
        _74 = &_15;
        _73 = rocket_http::uri::Origin::<'_>::path(move _74) -> [return: bb39, unwind: bb55];
    }

    bb39: {
        _72 = &_73;
        _71 = rocket_http::uri::Path::<'_>::as_str(move _72) -> [return: bb40, unwind: bb55];
    }

    bb40: {
        _70 = param::parse::<impl Parameter>::parse_many::<rocket_http::uri::fmt::Path>(_71, _58) -> [return: bb41, unwind: bb55];
    }

    bb41: {
        _69 = <Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}> as Iterator>::map::<Parameter, {closure@core/codegen/src/bang/uri_parsing.rs:325:18: 325:21}>(move _70, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:325:18: 325:21}) -> [return: bb42, unwind: bb55];
    }

    bb42: {
        _68 = <Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/bang/uri_parsing.rs:325:18: 325:21}> as Iterator>::collect::<Vec<Parameter>>(move _69) -> [return: bb43, unwind: bb55];
    }

    bb43: {
        _76 = &_15;
        _75 = rocket_http::uri::Origin::<'_>::query(move _76) -> [return: bb44, unwind: bb54];
    }

    bb44: {
        _80 = &_15;
        _81 = &_2;
        _79 = {closure@core/codegen/src/bang/uri_parsing.rs:329:38: 329:45} { route_uri: move _80, route_uri_str: move _81 };
        _78 = Option::<rocket_http::uri::Query<'_>>::map::<Vec<Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:329:38: 329:45}>(_75, move _79) -> [return: bb45, unwind: bb54];
    }

    bb45: {
        _77 = Option::<Vec<Parameter>>::unwrap_or_default(move _78) -> [return: bb46, unwind: bb54];
    }

    bb46: {
        _90 = const false;
        _83 = move _15;
        _84 = move _68;
        _85 = move _42;
        _86 = move _51;
        _82 = uri_parsing::InternalUriParams { route_uri: move _83, path_params: move _84, query_params: move _77, fn_args: move _85, uri_mac: move _86 };
        _0 = std::result::Result::<uri_parsing::InternalUriParams, syn::Error>::Ok(move _82);
        _89 = const false;
        drop(_27) -> [return: bb47, unwind: bb57];
    }

    bb47: {
        _88 = const false;
        _90 = const false;
        drop(_2) -> [return: bb53, unwind continue];
    }

    bb48: {
        drop(_42) -> [return: bb49, unwind: bb63];
    }

    bb49: {
        _89 = const false;
        goto -> bb61;
    }

    bb50: {
        _88 = const false;
        drop(_15) -> [return: bb51, unwind: bb58];
    }

    bb51: {
        _90 = const false;
        goto -> bb52;
    }

    bb52: {
        drop(_2) -> [return: bb53, unwind continue];
    }

    bb53: {
        return;
    }

    bb54 (cleanup): {
        drop(_68) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_51) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_42) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        switchInt(_90) -> [0: bb58, otherwise: bb66];
    }

    bb58 (cleanup): {
        drop(_2) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        resume;
    }

    bb60: {
        drop(_27) -> [return: bb50, unwind: bb57];
    }

    bb61: {
        switchInt(_88) -> [0: bb50, otherwise: bb60];
    }

    bb62 (cleanup): {
        drop(_34) -> [return: bb65, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        switchInt(_89) -> [0: bb65, otherwise: bb62];
    }

    bb64 (cleanup): {
        drop(_27) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        switchInt(_88) -> [0: bb57, otherwise: bb64];
    }

    bb66 (cleanup): {
        drop(_15) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb67: {
        goto -> bb52;
    }

    bb68: {
        goto -> bb51;
    }

    bb69: {
        goto -> bb49;
    }

    bb70: {
        goto -> bb48;
    }

    bb71: {
        goto -> bb48;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:312:18: 312:21}, _2: rocket_http::uri::Origin<'_>) -> rocket_http::uri::Origin<'_> {
    debug o => _2;
    let mut _0: rocket_http::uri::Origin<'_>;
    let mut _3: rocket_http::uri::Origin<'_>;

    bb0: {
        _3 = rocket_http::uri::Origin::<'_>::into_normalized(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <rocket_http::uri::Origin<'_> as IntoOwned>::into_owned(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse::{closure#1}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:313:22: 313:25}, _2: rocket_http::uri::Error<'_>) -> syn::Error {
    debug input => (*(_1.0: &&syn::parse::ParseBuffer<'_>));
    let mut _0: syn::Error;
    let mut _3: &&syn::parse::ParseBuffer<'_>;
    let mut _4: &syn::parse::ParseBuffer<'_>;

    bb0: {
        _3 = deref_copy (_1.0: &&syn::parse::ParseBuffer<'_>);
        _4 = deref_copy (*_3);
        _0 = ParseBuffer::<'_>::error::<&str>(_4, const "internal error: invalid route URI") -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse::{closure#2}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:325:18: 325:21}, _2: std::result::Result<Parameter, param::parse::Error<'_>>) -> Parameter {
    debug p => _2;
    let mut _0: attribute::param::Parameter;
    let _3: &str;

    bb0: {
        _3 = const "internal error: invalid path parameter";
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::expect(move _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse::{closure#3}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:329:38: 329:45}, _2: rocket_http::uri::Query<'_>) -> Vec<Parameter> {
    debug query => _2;
    debug route_uri => (*(_1.0: &rocket_http::uri::Origin<'_>));
    debug route_uri_str => (*(_1.1: &proc_macro_ext::StringLit));
    let mut _0: std::vec::Vec<attribute::param::Parameter>;
    let _3: usize;
    let mut _4: usize;
    let _5: &rocket_http::RawStr;
    let mut _6: &rocket_http::uri::Path<'_>;
    let _7: rocket_http::uri::Path<'_>;
    let mut _8: (usize, bool);
    let mut _10: std::ops::Range<usize>;
    let mut _11: usize;
    let mut _12: usize;
    let _13: &rocket_http::RawStr;
    let mut _14: &rocket_http::uri::Query<'_>;
    let mut _15: (usize, bool);
    let mut _16: std::iter::Map<std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/bang/uri_parsing.rs:333:22: 333:25}>;
    let mut _17: std::iter::Map<std::iter::Enumerate<std::iter::Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>;
    let _18: &str;
    let mut _19: &rocket_http::uri::Query<'_>;
    let mut _20: &rocket_http::uri::Origin<'_>;
    let mut _21: &proc_macro_ext::StringLit;
    scope 1 {
        debug i => _3;
        let _9: proc_macro2::Span;
        scope 2 {
            debug span => _9;
        }
    }

    bb0: {
        _20 = deref_copy (_1.0: &rocket_http::uri::Origin<'_>);
        _7 = rocket_http::uri::Origin::<'_>::path(_20) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_7;
        _5 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RawStr::len(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = CheckedAdd(_4, const 2_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _4, const 2_usize) -> [success: bb4, unwind continue];
    }

    bb4: {
        _3 = move (_8.0: usize);
        _21 = deref_copy (_1.1: &proc_macro_ext::StringLit);
        _14 = &_2;
        _13 = <rocket_http::uri::Query<'_> as std::ops::Deref>::deref(move _14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = RawStr::len(_13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _15 = CheckedAdd(_3, _12);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _3, move _12) -> [success: bb7, unwind continue];
    }

    bb7: {
        _11 = move (_15.0: usize);
        _10 = std::ops::Range::<usize> { start: _3, end: move _11 };
        _9 = StringLit::subspan::<std::ops::Range<usize>>(_21, move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _19 = &_2;
        _18 = rocket_http::uri::Query::<'_>::as_str(move _19) -> [return: bb9, unwind continue];
    }

    bb9: {
        _17 = param::parse::<impl Parameter>::parse_many::<rocket_http::uri::fmt::Query>(_18, _9) -> [return: bb10, unwind continue];
    }

    bb10: {
        _16 = <Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}> as Iterator>::map::<Parameter, {closure@core/codegen/src/bang/uri_parsing.rs:333:22: 333:25}>(move _17, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:333:22: 333:25}) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = <Map<Map<Enumerate<Filter<std::str::Split<'_, char>, {closure@core/codegen/src/attribute/param/parse.rs:95:21: 95:24}>>, {closure@core/codegen/src/attribute/param/parse.rs:97:18: 97:37}>, {closure@core/codegen/src/bang/uri_parsing.rs:333:22: 333:25}> as Iterator>::collect::<Vec<Parameter>>(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:304:1: 304:33>::parse::{closure#3}::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:333:22: 333:25}, _2: std::result::Result<Parameter, param::parse::Error<'_>>) -> Parameter {
    debug p => _2;
    let mut _0: attribute::param::Parameter;
    let _3: &str;

    bb0: {
        _3 = const "internal error: invalid query parameter";
        _0 = std::result::Result::<Parameter, param::parse::Error<'_>>::expect(move _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::fn_args_str(_1: &uri_parsing::InternalUriParams) -> std::string::String {
    debug self => _1;
    let mut _0: std::string::String;
    let _2: &[std::string::String];
    let mut _3: &std::vec::Vec<std::string::String>;
    let _4: std::vec::Vec<std::string::String>;
    let mut _5: std::iter::Map<std::slice::Iter<'_, bang::uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri_parsing.rs:350:18: 350:39}>;
    let mut _6: std::slice::Iter<'_, bang::uri_parsing::FnArg>;
    let _7: &[bang::uri_parsing::FnArg];
    let mut _8: &std::vec::Vec<bang::uri_parsing::FnArg>;
    let _9: &str;

    bb0: {
        _8 = &((*_1).3: std::vec::Vec<bang::uri_parsing::FnArg>);
        _7 = <Vec<uri_parsing::FnArg> as std::ops::Deref>::deref(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = core::slice::<impl [uri_parsing::FnArg]>::iter(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = <std::slice::Iter<'_, uri_parsing::FnArg> as Iterator>::map::<std::string::String, {closure@core/codegen/src/bang/uri_parsing.rs:350:18: 350:39}>(move _6, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:350:18: 350:39}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Map<std::slice::Iter<'_, uri_parsing::FnArg>, {closure@core/codegen/src/bang/uri_parsing.rs:350:18: 350:39}> as Iterator>::collect::<Vec<std::string::String>>(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = &_4;
        _2 = <Vec<std::string::String> as std::ops::Deref>::deref(move _3) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _9 = const ", ";
        _0 = slice::<impl [std::string::String]>::join::<&str>(_2, _9) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        drop(_4) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::fn_args_str::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:350:18: 350:39}, _2: &uri_parsing::FnArg) -> std::string::String {
    let mut _0: std::string::String;
    let _3: &proc_macro2::Ident;
    let _4: &syn::Type;
    let mut _7: &proc_macro2::TokenStream;
    let _8: proc_macro2::TokenStream;
    let _10: ();
    let _11: &syn::Type;
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _14: std::iter::Filter<std::str::Chars<'_>, {closure@core/codegen/src/bang/uri_parsing.rs:353:60: 353:63}>;
    let mut _15: std::str::Chars<'_>;
    let _16: &str;
    let mut _17: &std::string::String;
    let mut _18: std::fmt::Arguments<'_>;
    let mut _19: &[&str];
    let mut _20: &[core::fmt::rt::Argument<'_>];
    let _21: &[core::fmt::rt::Argument<'_>; 2];
    let _22: [core::fmt::rt::Argument<'_>; 2];
    let mut _23: core::fmt::rt::Argument<'_>;
    let _24: &&proc_macro2::Ident;
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &std::string::String;
    scope 1 {
        debug ident => _3;
        debug ty => _4;
        let _5: syn::Type;
        scope 2 {
            debug ty => _5;
            let _6: std::string::String;
            let mut _9: proc_macro2::TokenStream;
            scope 3 {
                debug ty_str => _6;
                let _13: std::string::String;
                scope 5 {
                    debug ty_str => _13;
                    let mut _27: &[&str; 2];
                    scope 6 {
                        debug res => _0;
                    }
                }
            }
            scope 4 {
                debug _s => _9;
            }
        }
    }

    bb0: {
        _3 = &((*_2).0: proc_macro2::Ident);
        _4 = &((*_2).1: syn::Type);
        _5 = <syn::Type as devise::ext::TypeExt>::with_stripped_lifetimes(_4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = TokenStream2::new() -> [return: bb2, unwind: bb21];
    }

    bb2: {
        _11 = &_5;
        _12 = &mut _9;
        _10 = <syn::Type as ToTokens>::to_tokens(_11, _12) -> [return: bb3, unwind: bb20];
    }

    bb3: {
        _8 = move _9;
        _7 = &_8;
        _6 = <TokenStream2 as ToString>::to_string(move _7) -> [return: bb4, unwind: bb19];
    }

    bb4: {
        drop(_8) -> [return: bb5, unwind: bb18];
    }

    bb5: {
        _17 = &_6;
        _16 = <std::string::String as std::ops::Deref>::deref(move _17) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        _15 = core::str::<impl str>::chars(_16) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _14 = <Chars<'_> as Iterator>::filter::<{closure@core/codegen/src/bang/uri_parsing.rs:353:60: 353:63}>(move _15, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:353:60: 353:63}) -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _13 = <Filter<Chars<'_>, {closure@core/codegen/src/bang/uri_parsing.rs:353:60: 353:63}> as Iterator>::collect::<std::string::String>(move _14) -> [return: bb9, unwind: bb18];
    }

    bb9: {
        _27 = const _;
        _19 = _27 as &[&str] (PointerCoercion(Unsize));
        _24 = &_3;
        _23 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_24) -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _26 = &_13;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_26) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _22 = [move _23, move _25];
        _21 = &_22;
        _20 = _21 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = std::fmt::Arguments::<'_>::new_v1(move _19, move _20) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _0 = format(move _18) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        drop(_13) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        drop(_6) -> [return: bb15, unwind: bb21];
    }

    bb15: {
        drop(_5) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_13) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_6) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_8) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        drop(_9) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_5) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }
}

promoted[0] in uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::fn_args_str::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ": "];
        _0 = &_1;
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::fn_args_str::{closure#0}::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:353:60: 353:63}, _2: &char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: char;

    bb0: {
        _4 = (*_2);
        _3 = char::methods::<impl char>::is_whitespace(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _3);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::dynamic_path_params(_1: &uri_parsing::InternalUriParams) -> FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}> {
    debug self => _1;
    let mut _0: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
    let mut _2: std::slice::Iter<'_, attribute::param::Parameter>;
    let _3: &[attribute::param::Parameter];
    let mut _4: &std::vec::Vec<attribute::param::Parameter>;

    bb0: {
        _4 = &((*_1).1: std::vec::Vec<attribute::param::Parameter>);
        _3 = <Vec<Parameter> as std::ops::Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = core::slice::<impl [Parameter]>::iter(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&param::Dynamic, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::dynamic_path_params::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}, _2: &Parameter) -> Option<&param::Dynamic> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;
    let mut _3: std::option::Option<&attribute::param::Dynamic>;
    let mut _4: &attribute::param::Parameter;
    let mut _5: {closure@core/codegen/src/bang/uri_parsing.rs:362:49: 362:51};
    let mut _6: &&attribute::param::Parameter;

    bb0: {
        _4 = _2;
        _3 = Parameter::dynamic(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_2;
        _5 = {closure@core/codegen/src/bang/uri_parsing.rs:362:49: 362:51} { p: move _6 };
        _0 = Option::<&param::Dynamic>::or_else::<{closure@core/codegen/src/bang/uri_parsing.rs:362:49: 362:51}>(move _3, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::dynamic_path_params::{closure#0}::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:362:49: 362:51}) -> Option<&param::Dynamic> {
    debug p => (*(_1.0: &&attribute::param::Parameter));
    let mut _0: std::option::Option<&attribute::param::Dynamic>;
    let mut _2: &&attribute::param::Parameter;
    let mut _3: &attribute::param::Parameter;

    bb0: {
        _2 = deref_copy (_1.0: &&attribute::param::Parameter);
        _3 = deref_copy (*_2);
        _0 = Parameter::ignored(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::dynamic_query_params(_1: &uri_parsing::InternalUriParams) -> FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}> {
    debug self => _1;
    let mut _0: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>;
    let mut _2: std::slice::Iter<'_, attribute::param::Parameter>;
    let _3: &[attribute::param::Parameter];
    let mut _4: &std::vec::Vec<attribute::param::Parameter>;

    bb0: {
        _4 = &((*_1).2: std::vec::Vec<attribute::param::Parameter>);
        _3 = <Vec<Parameter> as std::ops::Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = core::slice::<impl [Parameter]>::iter(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <std::slice::Iter<'_, Parameter> as Iterator>::filter_map::<&param::Dynamic, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::dynamic_query_params::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}, _2: &Parameter) -> Option<&param::Dynamic> {
    debug p => _2;
    let mut _0: std::option::Option<&attribute::param::Dynamic>;

    bb0: {
        _0 = Parameter::dynamic(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::validate(_1: &uri_parsing::InternalUriParams) -> uri_parsing::Validation<'_> {
    debug self => _1;
    let mut _0: bang::uri_parsing::Validation<'_>;
    let _2: &bang::uri_parsing::Args;
    let mut _4: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>;
    let mut _5: std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>;
    let mut _6: isize;
    let mut _10: (usize, usize);
    let mut _11: usize;
    let mut _12: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>;
    let mut _13: usize;
    let mut _15: syn::punctuated::Iter<'_, bang::uri_parsing::Arg>;
    let mut _16: bool;
    let mut _17: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _18: std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}>;
    let mut _21: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>;
    let mut _22: &std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>;
    let mut _23: bool;
    let mut _24: usize;
    let mut _25: std::iter::Filter<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}>;
    let mut _26: &std::iter::Filter<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}>;
    let mut _27: std::vec::Vec<&attribute::param::Dynamic>;
    let mut _28: std::iter::Filter<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}>;
    let mut _30: std::iter::Map<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:387:49: 387:52}>;
    let mut _31: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>;
    let mut _34: (std::vec::Vec<&proc_macro2::Ident>, std::vec::Vec<&proc_macro2::Ident>);
    let mut _35: std::vec::Vec<&proc_macro2::Ident>;
    let mut _36: std::vec::Vec<&proc_macro2::Ident>;
    let mut _38: syn::punctuated::Iter<'_, bang::uri_parsing::Arg>;
    let mut _39: std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}>;
    let _41: ();
    let mut _42: std::option::Option<(&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr)>;
    let mut _43: &mut std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}>;
    let mut _44: isize;
    let mut _48: std::option::Option<&mut std::option::Option<&bang::uri_parsing::ArgExpr>>;
    let mut _49: &mut indexmap::IndexMap<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
    let mut _50: isize;
    let mut _53: bool;
    let mut _54: &std::option::Option<&bang::uri_parsing::ArgExpr>;
    let mut _55: &mut std::vec::Vec<&proc_macro2::Ident>;
    let mut _57: std::option::Option<&bang::uri_parsing::ArgExpr>;
    let mut _58: &mut std::vec::Vec<&proc_macro2::Ident>;
    let mut _61: (std::vec::Vec<&name::Name>, std::vec::Vec<&bang::uri_parsing::ArgExpr>);
    let mut _62: std::vec::Vec<&name::Name>;
    let mut _63: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _64: indexmap::map::IntoIter<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
    let mut _65: indexmap::IndexMap<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
    let _67: ();
    let mut _68: std::option::Option<(&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>)>;
    let mut _69: &mut indexmap::map::IntoIter<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
    let mut _70: isize;
    let mut _73: isize;
    let mut _75: &mut std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _76: &mut std::vec::Vec<&name::Name>;
    let mut _77: usize;
    let mut _78: usize;
    let mut _79: usize;
    let mut _80: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _81: usize;
    let mut _82: &std::vec::Vec<&proc_macro2::Ident>;
    let mut _83: (usize, bool);
    let mut _84: usize;
    let mut _85: &std::vec::Vec<&name::Name>;
    let mut _86: (usize, bool);
    let mut _87: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
    let mut _88: std::vec::Vec<&name::Name>;
    let mut _89: std::vec::Vec<&proc_macro2::Ident>;
    let mut _90: std::vec::Vec<&proc_macro2::Ident>;
    let mut _91: &&mut std::option::Option<&bang::uri_parsing::ArgExpr>;
    let mut _92: &mut std::option::Option<&bang::uri_parsing::ArgExpr>;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: bool;
    let mut _98: bool;
    scope 1 {
        debug args => _2;
        let _3: std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>;
        scope 2 {
            debug all_params => _3;
            let _7: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
            let _19: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
            scope 3 {
                debug args => _7;
                let _8: usize;
                let _9: usize;
                scope 4 {
                    debug expected => _8;
                    debug actual => _9;
                    let _14: std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}>;
                    scope 5 {
                        debug unnamed_args => _14;
                    }
                }
            }
            scope 6 {
                debug args => _19;
                let _20: std::iter::Filter<std::iter::Chain<std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, std::iter::FilterMap<std::slice::Iter<'_, attribute::param::Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}>;
                scope 7 {
                    debug ignored => _20;
                    let mut _29: indexmap::IndexMap<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
                    scope 8 {
                        debug params => _29;
                        let mut _32: std::vec::Vec<&proc_macro2::Ident>;
                        let mut _33: std::vec::Vec<&proc_macro2::Ident>;
                        scope 9 {
                            debug extra => _32;
                            debug dup => _33;
                            let _37: std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}>;
                            scope 10 {
                                debug named_args => _37;
                                let mut _40: std::iter::Map<syn::punctuated::Iter<'_, bang::uri_parsing::Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}>;
                                let mut _59: std::vec::Vec<&name::Name>;
                                let mut _60: std::vec::Vec<&bang::uri_parsing::ArgExpr>;
                                scope 11 {
                                    debug iter => _40;
                                    let _45: &name::Name;
                                    let _46: &proc_macro2::Ident;
                                    let _47: &bang::uri_parsing::ArgExpr;
                                    scope 12 {
                                        debug name => _45;
                                        debug ident => _46;
                                        debug expr => _47;
                                        let _51: &&mut std::option::Option<&bang::uri_parsing::ArgExpr>;
                                        let _52: &&&mut std::option::Option<&bang::uri_parsing::ArgExpr>;
                                        let _56: &mut std::option::Option<&bang::uri_parsing::ArgExpr>;
                                        scope 13 {
                                            debug entry => _51;
                                            debug entry => _52;
                                        }
                                        scope 14 {
                                            debug entry => _56;
                                        }
                                    }
                                }
                                scope 15 {
                                    debug missing => _59;
                                    debug exprs => _60;
                                    let mut _66: indexmap::map::IntoIter<&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>>;
                                    scope 16 {
                                        debug iter => _66;
                                        let _71: &name::Name;
                                        let _72: std::option::Option<&bang::uri_parsing::ArgExpr>;
                                        scope 17 {
                                            debug name => _71;
                                            debug expr => _72;
                                            let _74: &bang::uri_parsing::ArgExpr;
                                            scope 18 {
                                                debug expr => _74;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _93 = const false;
        _98 = const false;
        _97 = const false;
        _96 = const false;
        _95 = const false;
        _94 = const false;
        _2 = &((((*_1).4: bang::uri_parsing::RoutedUri).1: bang::uri_parsing::RouteInvocation).1: bang::uri_parsing::Args);
        _4 = uri_parsing::InternalUriParams::dynamic_path_params(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = uri_parsing::InternalUriParams::dynamic_query_params(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}> as Iterator>::chain::<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>(move _4, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant((*_2));
        switchInt(move _6) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _19 = &(((*_2) as Named).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        _22 = &_3;
        _21 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>> as Clone>::clone(move _22) -> [return: bb15, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = &(((*_2) as Unnamed).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        _12 = move _3;
        _11 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>> as Iterator>::count(move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _13 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::len(_7) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = (move _11, move _13);
        _8 = (_10.0: usize);
        _9 = (_10.1: usize);
        _15 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::iter(_7) -> [return: bb9, unwind continue];
    }

    bb9: {
        _14 = <syn::punctuated::Iter<'_, Arg> as Iterator>::map::<&uri_parsing::ArgExpr, {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}>(move _15, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}) -> [return: bb10, unwind continue];
    }

    bb10: {
        _93 = const true;
        _16 = Eq(_8, _9);
        switchInt(_16) -> [0: bb11, otherwise: bb12];
    }

    bb11: {
        _0 = uri_parsing::Validation::<'_>::Unnamed(_8, _9);
        goto -> bb71;
    }

    bb12: {
        _93 = const false;
        _18 = move _14;
        _17 = <Map<syn::punctuated::Iter<'_, Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}> as Iterator>::collect::<Vec<&uri_parsing::ArgExpr>>(move _18) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = uri_parsing::Validation::<'_>::Ok(move _17);
        goto -> bb71;
    }

    bb14: {
        _93 = const false;
        goto -> bb62;
    }

    bb15: {
        _20 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>> as Iterator>::filter::<{closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}>(move _21, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}) -> [return: bb16, unwind continue];
    }

    bb16: {
        _26 = &_20;
        _25 = <Filter<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}> as Clone>::clone(move _26) -> [return: bb17, unwind continue];
    }

    bb17: {
        _24 = <Filter<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}> as Iterator>::count(move _25) -> [return: bb18, unwind continue];
    }

    bb18: {
        _23 = Gt(move _24, const 0_usize);
        switchInt(move _23) -> [0: bb21, otherwise: bb19];
    }

    bb19: {
        _28 = move _20;
        _27 = <Filter<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}> as Iterator>::collect::<Vec<&param::Dynamic>>(move _28) -> [return: bb20, unwind continue];
    }

    bb20: {
        _0 = uri_parsing::Validation::<'_>::NamedIgnored(move _27);
        goto -> bb62;
    }

    bb21: {
        _31 = move _3;
        _30 = <std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>> as Iterator>::map::<(&name::Name, Option<&uri_parsing::ArgExpr>), {closure@core/codegen/src/bang/uri_parsing.rs:387:49: 387:52}>(move _31, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:387:49: 387:52}) -> [return: bb22, unwind continue];
    }

    bb22: {
        _29 = <Map<std::iter::Chain<FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:362:25: 362:28}>, FilterMap<std::slice::Iter<'_, Parameter>, {closure@core/codegen/src/bang/uri_parsing.rs:366:45: 366:48}>>, {closure@core/codegen/src/bang/uri_parsing.rs:387:49: 387:52}> as Iterator>::collect::<IndexMap<&name::Name, Option<&uri_parsing::ArgExpr>>>(move _30) -> [return: bb23, unwind continue];
    }

    bb23: {
        _98 = const true;
        _35 = Vec::<&proc_macro2::Ident>::new() -> [return: bb24, unwind: bb82];
    }

    bb24: {
        _36 = Vec::<&proc_macro2::Ident>::new() -> [return: bb25, unwind: bb68];
    }

    bb25: {
        _34 = (move _35, move _36);
        _97 = const true;
        _32 = move (_34.0: std::vec::Vec<&proc_macro2::Ident>);
        _96 = const true;
        _33 = move (_34.1: std::vec::Vec<&proc_macro2::Ident>);
        _38 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::iter(_19) -> [return: bb26, unwind: bb79];
    }

    bb26: {
        _37 = <syn::punctuated::Iter<'_, Arg> as Iterator>::map::<(&name::Name, &proc_macro2::Ident, &uri_parsing::ArgExpr), {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}>(move _38, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}) -> [return: bb27, unwind: bb79];
    }

    bb27: {
        _39 = <Map<syn::punctuated::Iter<'_, Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}> as IntoIterator>::into_iter(move _37) -> [return: bb28, unwind: bb79];
    }

    bb28: {
        _40 = move _39;
        goto -> bb29;
    }

    bb29: {
        _43 = &mut _40;
        _42 = <Map<syn::punctuated::Iter<'_, Arg>, {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}> as Iterator>::next(_43) -> [return: bb30, unwind: bb66];
    }

    bb30: {
        _44 = discriminant(_42);
        switchInt(move _44) -> [0: bb32, 1: bb31, otherwise: bb5];
    }

    bb31: {
        _45 = (((_42 as Some).0: (&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr)).0: &name::Name);
        _46 = (((_42 as Some).0: (&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr)).1: &proc_macro2::Ident);
        _47 = (((_42 as Some).0: (&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr)).2: &bang::uri_parsing::ArgExpr);
        _49 = &mut _29;
        _48 = IndexMap::<&name::Name, Option<&uri_parsing::ArgExpr>>::get_mut::<name::Name>(move _49, _45) -> [return: bb33, unwind: bb66];
    }

    bb32: {
        drop(_40) -> [return: bb39, unwind: bb79];
    }

    bb33: {
        _50 = discriminant(_48);
        switchInt(move _50) -> [0: bb34, 1: bb35, otherwise: bb5];
    }

    bb34: {
        _58 = &mut _32;
        _41 = Vec::<&proc_macro2::Ident>::push(move _58, _46) -> [return: bb83, unwind: bb66];
    }

    bb35: {
        _51 = &((_48 as Some).0: &mut std::option::Option<&bang::uri_parsing::ArgExpr>);
        _52 = &_51;
        _91 = deref_copy (*_52);
        _92 = deref_copy (*_91);
        _54 = &(*_92);
        _53 = Option::<&uri_parsing::ArgExpr>::is_some(move _54) -> [return: bb36, unwind: bb66];
    }

    bb36: {
        switchInt(move _53) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _55 = &mut _33;
        _41 = Vec::<&proc_macro2::Ident>::push(move _55, _46) -> [return: bb84, unwind: bb66];
    }

    bb38: {
        _56 = move ((_48 as Some).0: &mut std::option::Option<&bang::uri_parsing::ArgExpr>);
        _57 = Option::<&uri_parsing::ArgExpr>::Some(_47);
        (*_56) = move _57;
        goto -> bb29;
    }

    bb39: {
        _62 = Vec::<&name::Name>::new() -> [return: bb40, unwind: bb79];
    }

    bb40: {
        _63 = Vec::<&uri_parsing::ArgExpr>::new() -> [return: bb41, unwind: bb65];
    }

    bb41: {
        _61 = (move _62, move _63);
        _95 = const true;
        _59 = move (_61.0: std::vec::Vec<&name::Name>);
        _94 = const true;
        _60 = move (_61.1: std::vec::Vec<&bang::uri_parsing::ArgExpr>);
        _98 = const false;
        _65 = move _29;
        _64 = <IndexMap<&name::Name, Option<&uri_parsing::ArgExpr>> as IntoIterator>::into_iter(move _65) -> [return: bb42, unwind: bb64];
    }

    bb42: {
        _66 = move _64;
        goto -> bb43;
    }

    bb43: {
        _69 = &mut _66;
        _68 = <indexmap::map::IntoIter<&name::Name, Option<&uri_parsing::ArgExpr>> as Iterator>::next(_69) -> [return: bb44, unwind: bb63];
    }

    bb44: {
        _70 = discriminant(_68);
        switchInt(move _70) -> [0: bb46, 1: bb45, otherwise: bb5];
    }

    bb45: {
        _71 = (((_68 as Some).0: (&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>)).0: &name::Name);
        _72 = (((_68 as Some).0: (&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>)).1: std::option::Option<&bang::uri_parsing::ArgExpr>);
        _73 = discriminant(_72);
        switchInt(move _73) -> [0: bb47, 1: bb48, otherwise: bb5];
    }

    bb46: {
        drop(_66) -> [return: bb49, unwind: bb64];
    }

    bb47: {
        _76 = &mut _59;
        _67 = Vec::<&name::Name>::push(move _76, _71) -> [return: bb85, unwind: bb63];
    }

    bb48: {
        _74 = ((_72 as Some).0: &bang::uri_parsing::ArgExpr);
        _75 = &mut _60;
        _67 = Vec::<&uri_parsing::ArgExpr>::push(move _75, _74) -> [return: bb86, unwind: bb63];
    }

    bb49: {
        _80 = &_32;
        _79 = Vec::<&proc_macro2::Ident>::len(move _80) -> [return: bb50, unwind: bb64];
    }

    bb50: {
        _82 = &_33;
        _81 = Vec::<&proc_macro2::Ident>::len(move _82) -> [return: bb51, unwind: bb64];
    }

    bb51: {
        _83 = CheckedAdd(_79, _81);
        assert(!move (_83.1: bool), "attempt to compute `{} + {}`, which would overflow", move _79, move _81) -> [success: bb52, unwind: bb64];
    }

    bb52: {
        _78 = move (_83.0: usize);
        _85 = &_59;
        _84 = Vec::<&name::Name>::len(move _85) -> [return: bb53, unwind: bb64];
    }

    bb53: {
        _86 = CheckedAdd(_78, _84);
        assert(!move (_86.1: bool), "attempt to compute `{} + {}`, which would overflow", move _78, move _84) -> [success: bb54, unwind: bb64];
    }

    bb54: {
        _77 = move (_86.0: usize);
        switchInt(move _77) -> [0: bb55, otherwise: bb56];
    }

    bb55: {
        _94 = const false;
        _87 = move _60;
        _0 = uri_parsing::Validation::<'_>::Ok(move _87);
        goto -> bb57;
    }

    bb56: {
        _95 = const false;
        _88 = move _59;
        _97 = const false;
        _89 = move _32;
        _96 = const false;
        _90 = move _33;
        _0 = uri_parsing::Validation::<'_>::Named(move _88, move _89, move _90);
        goto -> bb57;
    }

    bb57: {
        switchInt(_94) -> [0: bb58, otherwise: bb72];
    }

    bb58: {
        _94 = const false;
        switchInt(_95) -> [0: bb59, otherwise: bb73];
    }

    bb59: {
        _95 = const false;
        switchInt(_96) -> [0: bb60, otherwise: bb74];
    }

    bb60: {
        _96 = const false;
        switchInt(_97) -> [0: bb61, otherwise: bb75];
    }

    bb61: {
        _97 = const false;
        _98 = const false;
        goto -> bb62;
    }

    bb62: {
        return;
    }

    bb63 (cleanup): {
        drop(_66) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        drop(_60) -> [return: bb77, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        drop(_62) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        drop(_40) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        switchInt(_97) -> [0: bb82, otherwise: bb80];
    }

    bb68 (cleanup): {
        drop(_35) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        resume;
    }

    bb70: {
        drop(_14) -> [return: bb14, unwind continue];
    }

    bb71: {
        switchInt(_93) -> [0: bb14, otherwise: bb70];
    }

    bb72: {
        drop(_60) -> [return: bb58, unwind: bb77];
    }

    bb73: {
        drop(_59) -> [return: bb59, unwind: bb79];
    }

    bb74: {
        drop(_33) -> [return: bb60, unwind: bb67];
    }

    bb75: {
        drop(_32) -> [return: bb61, unwind: bb82];
    }

    bb76 (cleanup): {
        drop(_59) -> [return: bb79, unwind terminate(cleanup)];
    }

    bb77 (cleanup): {
        switchInt(_95) -> [0: bb79, otherwise: bb76];
    }

    bb78 (cleanup): {
        drop(_33) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb79 (cleanup): {
        switchInt(_96) -> [0: bb67, otherwise: bb78];
    }

    bb80 (cleanup): {
        drop(_32) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        drop(_29) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        switchInt(_98) -> [0: bb69, otherwise: bb81];
    }

    bb83: {
        goto -> bb29;
    }

    bb84: {
        goto -> bb29;
    }

    bb85: {
        goto -> bb43;
    }

    bb86: {
        goto -> bb43;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::validate::{closure#0}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:375:52: 375:57}, _2: &Arg) -> &uri_parsing::ArgExpr {
    debug arg => _2;
    let mut _0: &bang::uri_parsing::ArgExpr;

    bb0: {
        _0 = Arg::unnamed(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::validate::{closure#1}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:382:57: 382:60}, _2: &&param::Dynamic) -> bool {
    debug p => _2;
    let mut _0: bool;
    let mut _3: &attribute::param::Dynamic;

    bb0: {
        _3 = deref_copy (*_2);
        _0 = param::Dynamic::is_wild(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::validate::{closure#2}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:387:49: 387:52}, _2: &param::Dynamic) -> (&name::Name, Option<&uri_parsing::ArgExpr>) {
    debug p => _2;
    let mut _0: (&name::Name, std::option::Option<&bang::uri_parsing::ArgExpr>);
    let mut _3: &name::Name;
    let mut _4: std::option::Option<&bang::uri_parsing::ArgExpr>;

    bb0: {
        _3 = &((*_2).0: name::Name);
        _4 = Option::<&uri_parsing::ArgExpr>::None;
        _0 = (move _3, move _4);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:347:1: 347:23>::validate::{closure#3}(_1: &mut {closure@core/codegen/src/bang/uri_parsing.rs:391:50: 391:55}, _2: &Arg) -> (&name::Name, &proc_macro2::Ident, &uri_parsing::ArgExpr) {
    debug arg => _2;
    let mut _0: (&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr);

    bb0: {
        _0 = Arg::named(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:418:1: 418:15>::args_span(_1: &RoutedUri) -> proc_macro2::Span {
    debug self => _1;
    let mut _0: proc_macro2::Span;
    let mut _2: usize;
    let mut _3: &bang::uri_parsing::Args;
    let mut _4: &syn::Path;
    let mut _5: &bang::uri_parsing::Args;

    bb0: {
        _3 = &(((*_1).1: bang::uri_parsing::RouteInvocation).1: bang::uri_parsing::Args);
        _2 = uri_parsing::Args::num(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(_2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = &(((*_1).1: bang::uri_parsing::RouteInvocation).1: bang::uri_parsing::Args);
        _0 = <uri_parsing::Args as devise::Spanned>::span(move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _4 = &(((*_1).1: bang::uri_parsing::RouteInvocation).0: syn::Path);
        _0 = <syn::Path as devise::Spanned>::span(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:428:1: 428:9>::is_named(_1: &Arg) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        _0 = Eq(_2, const 1_isize);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:428:1: 428:9>::unnamed(_1: &Arg) -> &uri_parsing::ArgExpr {
    debug self => _1;
    let mut _0: &bang::uri_parsing::ArgExpr;
    let mut _2: isize;
    let _3: !;
    scope 1 {
        debug expr => _0;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = begin_panic::<&str>(const "Called Arg::unnamed() on an Arg::named!") -> unwind continue;
    }

    bb2: {
        _0 = &(((*_1) as Unnamed).0: bang::uri_parsing::ArgExpr);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:428:1: 428:9>::named(_1: &Arg) -> (&name::Name, &proc_macro2::Ident, &uri_parsing::ArgExpr) {
    debug self => _1;
    let mut _0: (&name::Name, &proc_macro2::Ident, &bang::uri_parsing::ArgExpr);
    let mut _2: isize;
    let _3: &name::Name;
    let _4: &proc_macro2::Ident;
    let _5: &bang::uri_parsing::ArgExpr;
    let _6: !;
    scope 1 {
        debug name => _3;
        debug ident => _4;
        debug expr => _5;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = begin_panic::<&str>(const "Called Arg::named() on an Arg::Unnamed!") -> unwind continue;
    }

    bb2: {
        _3 = &(((*_1) as Named).0: name::Name);
        _4 = &(((*_1) as Named).1: proc_macro2::Ident);
        _5 = &(((*_1) as Named).3: bang::uri_parsing::ArgExpr);
        _0 = (_3, _4, _5);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:451:1: 451:10>::num(_1: &uri_parsing::Args) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: isize;
    let _3: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _4: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    scope 1 {
        debug inner => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb1, 1: bb4, otherwise: bb2];
    }

    bb1: {
        _3 = &(((*_1) as Unnamed).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        goto -> bb3;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = _3;
        _0 = syn::punctuated::Punctuated::<Arg, syn::token::Comma>::len(move _4) -> [return: bb5, unwind continue];
    }

    bb4: {
        _3 = &(((*_1) as Named).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        goto -> bb3;
    }

    bb5: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:459:1: 459:13>::as_expr(_1: &uri_parsing::ArgExpr) -> Option<&syn::Expr> {
    debug self => _1;
    let mut _0: std::option::Option<&syn::Expr>;
    let mut _2: isize;
    let _3: &syn::Expr;
    scope 1 {
        debug expr => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&syn::Expr>::None;
        goto -> bb3;
    }

    bb2: {
        _3 = &(((*_1) as Expr).0: syn::Expr);
        _0 = Option::<&syn::Expr>::Some(_3);
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:459:1: 459:13>::unwrap_expr(_1: &uri_parsing::ArgExpr) -> &syn::Expr {
    debug self => _1;
    let mut _0: &syn::Expr;
    let mut _2: isize;
    let _3: !;
    scope 1 {
        debug expr => _0;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = begin_panic::<&str>(const "Called ArgExpr::expr() on ArgExpr::Ignored!") -> unwind continue;
    }

    bb2: {
        _0 = &(((*_1) as Expr).0: syn::Expr);
        return;
    }
}

fn uri_err(_1: &StringLit, _2: rocket_http::uri::Error<'_>) -> std::result::Result<T, syn::Error> {
    debug lit => _1;
    debug error => _2;
    let mut _0: std::result::Result<T, syn::Error>;
    let _3: proc_macro2::Span;
    let mut _4: std::ops::Range<usize>;
    let mut _5: usize;
    let mut _6: usize;
    let mut _7: &rocket_http::uri::Error<'_>;
    let mut _8: (usize, bool);
    let mut _9: usize;
    let mut _10: usize;
    let mut _11: &rocket_http::uri::Error<'_>;
    let mut _12: (usize, bool);
    let mut _14: std::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: &[core::fmt::rt::Argument<'_>];
    let _17: &[core::fmt::rt::Argument<'_>; 1];
    let _18: [core::fmt::rt::Argument<'_>; 1];
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &rocket_http::uri::Error<'_>;
    scope 1 {
        debug span => _3;
        let _13: std::string::String;
        let mut _21: &[&str; 1];
        scope 2 {
            debug res => _13;
        }
    }

    bb0: {
        _7 = &_2;
        _6 = rocket_http::uri::Error::<'_>::index(move _7) -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _8 = CheckedAdd(_6, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, const 1_usize) -> [success: bb2, unwind: bb11];
    }

    bb2: {
        _5 = move (_8.0: usize);
        _11 = &_2;
        _10 = rocket_http::uri::Error::<'_>::index(move _11) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _12 = CheckedAdd(_10, const 2_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _10, const 2_usize) -> [success: bb4, unwind: bb11];
    }

    bb4: {
        _9 = move (_12.0: usize);
        _4 = std::ops::Range::<usize> { start: move _5, end: move _9 };
        _3 = StringLit::subspan::<std::ops::Range<usize>>(_1, move _4) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        _21 = const _;
        _15 = _21 as &[&str] (PointerCoercion(Unsize));
        _20 = &_2;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::uri::Error<'_>>(_20) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = std::fmt::Arguments::<'_>::new_v1(move _15, move _16) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _13 = format(move _14) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _0 = err::<T, std::string::String>(_3, move _13) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

promoted[0] in uri_err: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "invalid URI: "];
        _0 = &_1;
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix(_1: &ParseBuffer<'_>) -> std::result::Result<Option<UriExpr>, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<std::option::Option<bang::uri_parsing::UriExpr>, syn::Error>;
    let mut _2: std::result::Result<syn::token::Underscore, syn::Error>;
    let mut _3: isize;
    let mut _4: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _5: bool;
    let mut _6: std::result::Result<syn::Expr, syn::Error>;
    let _7: proc_macro_ext::StringLit;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro_ext::StringLit>;
    let mut _9: std::result::Result<proc_macro_ext::StringLit, syn::Error>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, syn::Error>;
    let _12: proc_macro_ext::StringLit;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, rocket_http::uri::Uri<'_>>;
    let mut _15: std::result::Result<rocket_http::uri::Uri<'_>, syn::Error>;
    let mut _16: std::result::Result<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>;
    let mut _17: std::result::Result<rocket_http::uri::Uri<'_>, (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>)>;
    let mut _18: std::result::Result<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>;
    let _19: &str;
    let _20: &proc_macro_ext::StringLit;
    let mut _21: {closure@core/codegen/src/bang/uri_parsing.rs:492:22: 492:25};
    let mut _22: &proc_macro_ext::StringLit;
    let mut _23: {closure@core/codegen/src/bang/uri_parsing.rs:493:22: 493:32};
    let mut _24: &proc_macro_ext::StringLit;
    let mut _25: {closure@core/codegen/src/bang/uri_parsing.rs:494:22: 494:25};
    let mut _26: &proc_macro_ext::StringLit;
    let mut _27: isize;
    let mut _30: bool;
    let mut _31: &rocket_http::uri::Uri<'_>;
    let mut _32: isize;
    let mut _35: bool;
    let mut _36: &std::option::Option<rocket_http::uri::Query<'_>>;
    let _37: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _38: bool;
    let mut _39: &rocket_http::uri::Uri<'_>;
    let mut _40: isize;
    let mut _43: bool;
    let mut _44: &std::option::Option<rocket_http::uri::Query<'_>>;
    let _45: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _46: proc_macro2::Span;
    let mut _47: &proc_macro_ext::StringLit;
    let mut _48: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _49: bang::uri_parsing::UriExpr;
    let mut _50: bang::uri_parsing::UriLit;
    let mut _51: rocket_http::uri::Uri<'_>;
    let mut _52: rocket_http::uri::Uri<'_>;
    let mut _53: proc_macro2::Span;
    let mut _54: &proc_macro_ext::StringLit;
    let mut _55: &rocket_http::uri::Origin<'_>;
    let mut _56: &rocket_http::uri::Absolute<'_>;
    let mut _57: bool;
    scope 1 {
    }
    scope 2 {
        debug lit => _7;
        let _13: rocket_http::uri::Uri<'_>;
        let _28: std::result::Result<std::convert::Infallible, syn::Error>;
        let _29: rocket_http::uri::Uri<'_>;
        scope 7 {
            debug uri => _13;
            let _33: &rocket_http::uri::Origin<'_>;
            let _34: &&rocket_http::uri::Origin<'_>;
            let _41: &rocket_http::uri::Absolute<'_>;
            let _42: &&rocket_http::uri::Absolute<'_>;
            scope 12 {
                debug o => _33;
                debug o => _34;
            }
            scope 13 {
                debug a => _41;
                debug a => _42;
            }
        }
        scope 8 {
            debug residual => _28;
            scope 9 {
            }
        }
        scope 10 {
            debug val => _29;
            scope 11 {
            }
        }
    }
    scope 3 {
        debug residual => _11;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _12;
        scope 6 {
        }
    }

    bb0: {
        _57 = const false;
        _2 = ParseBuffer::<'_>::parse::<Underscore>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = Option::<UriExpr>::None;
        _0 = std::result::Result::<Option<UriExpr>, syn::Error>::Ok(move _4);
        drop(_2) -> [return: bb42, unwind continue];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ParseBuffer::<'_>::peek::<fn(syn::lookahead::TokenMarker) -> LitStr {LitStr}>(_1, LitStr) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _5) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _9 = ParseBuffer::<'_>::parse::<StringLit>(_1) -> [return: bb9, unwind continue];
    }

    bb7: {
        _6 = ParseBuffer::<'_>::parse::<syn::Expr>(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = std::result::Result::<syn::Expr, syn::Error>::map::<Option<UriExpr>, {closure@core/codegen/src/bang/uri_parsing.rs:487:46: 487:49}>(move _6, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:487:46: 487:49}) -> [return: bb42, unwind continue];
    }

    bb9: {
        _8 = <std::result::Result<StringLit, syn::Error> as std::ops::Try>::branch(move _9) -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _12 = move ((_8 as Continue).0: proc_macro_ext::StringLit);
        _7 = move _12;
        _20 = &_7;
        _19 = <StringLit as std::ops::Deref>::deref(_20) -> [return: bb14, unwind: bb44];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Option<UriExpr>, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _11) -> [return: bb42, unwind continue];
    }

    bb14: {
        _18 = rocket_http::uri::Uri::<'_>::parse::<rocket_http::uri::Origin<'_>>(_19) -> [return: bb15, unwind: bb44];
    }

    bb15: {
        _22 = &_7;
        _21 = {closure@core/codegen/src/bang/uri_parsing.rs:492:22: 492:25} { lit: move _22 };
        _17 = std::result::Result::<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>::or_else::<(rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>), {closure@core/codegen/src/bang/uri_parsing.rs:492:22: 492:25}>(move _18, move _21) -> [return: bb16, unwind: bb44];
    }

    bb16: {
        _24 = &_7;
        _23 = {closure@core/codegen/src/bang/uri_parsing.rs:493:22: 493:32} { lit: move _24 };
        _16 = std::result::Result::<rocket_http::uri::Uri<'_>, (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>)>::map_err::<rocket_http::uri::Error<'_>, {closure@core/codegen/src/bang/uri_parsing.rs:493:22: 493:32}>(move _17, move _23) -> [return: bb17, unwind: bb44];
    }

    bb17: {
        _26 = &_7;
        _25 = {closure@core/codegen/src/bang/uri_parsing.rs:494:22: 494:25} { lit: move _26 };
        _15 = std::result::Result::<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>::or_else::<syn::Error, {closure@core/codegen/src/bang/uri_parsing.rs:494:22: 494:25}>(move _16, move _25) -> [return: bb18, unwind: bb44];
    }

    bb18: {
        _14 = <std::result::Result<rocket_http::uri::Uri<'_>, syn::Error> as std::ops::Try>::branch(move _15) -> [return: bb19, unwind: bb44];
    }

    bb19: {
        _27 = discriminant(_14);
        switchInt(move _27) -> [0: bb20, 1: bb21, otherwise: bb12];
    }

    bb20: {
        _29 = move ((_14 as Continue).0: rocket_http::uri::Uri<'_>);
        _57 = const true;
        _13 = move _29;
        _31 = &_13;
        _32 = discriminant((*_31));
        switchInt(move _32) -> [1: bb23, otherwise: bb22];
    }

    bb21: {
        _28 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Option<UriExpr>, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _28) -> [return: bb48, unwind: bb44];
    }

    bb22: {
        _30 = const false;
        goto -> bb27;
    }

    bb23: {
        _33 = &(((*_31) as Origin).0: rocket_http::uri::Origin<'_>);
        _34 = &_33;
        _55 = deref_copy (*_34);
        _37 = rocket_http::uri::Origin::<'_>::query(_55) -> [return: bb24, unwind: bb47];
    }

    bb24: {
        _36 = &_37;
        _35 = Option::<rocket_http::uri::Query<'_>>::is_some(move _36) -> [return: bb25, unwind: bb47];
    }

    bb25: {
        switchInt(move _35) -> [0: bb22, otherwise: bb26];
    }

    bb26: {
        _30 = const true;
        goto -> bb27;
    }

    bb27: {
        switchInt(move _30) -> [0: bb28, otherwise: bb35];
    }

    bb28: {
        _39 = &_13;
        _40 = discriminant((*_39));
        switchInt(move _40) -> [3: bb30, otherwise: bb29];
    }

    bb29: {
        _38 = const false;
        goto -> bb34;
    }

    bb30: {
        _41 = &(((*_39) as Absolute).0: rocket_http::uri::Absolute<'_>);
        _42 = &_41;
        _56 = deref_copy (*_42);
        _45 = rocket_http::uri::Absolute::<'_>::query(_56) -> [return: bb31, unwind: bb47];
    }

    bb31: {
        _44 = &_45;
        _43 = Option::<rocket_http::uri::Query<'_>>::is_some(move _44) -> [return: bb32, unwind: bb47];
    }

    bb32: {
        switchInt(move _43) -> [0: bb29, otherwise: bb33];
    }

    bb33: {
        _38 = const true;
        goto -> bb34;
    }

    bb34: {
        switchInt(move _38) -> [0: bb38, otherwise: bb35];
    }

    bb35: {
        _47 = &_7;
        _46 = StringLit::span(move _47) -> [return: bb36, unwind: bb47];
    }

    bb36: {
        _0 = err::<Option<UriExpr>, &str>(move _46, const "URI prefix cannot contain query part") -> [return: bb37, unwind: bb47];
    }

    bb37: {
        drop(_13) -> [return: bb41, unwind: bb44];
    }

    bb38: {
        _57 = const false;
        _52 = move _13;
        _51 = <rocket_http::uri::Uri<'_> as IntoOwned>::into_owned(move _52) -> [return: bb39, unwind: bb47];
    }

    bb39: {
        _54 = &_7;
        _53 = StringLit::span(move _54) -> [return: bb40, unwind: bb43];
    }

    bb40: {
        _50 = UriLit(move _51, move _53);
        _49 = UriExpr::Uri(move _50);
        _48 = Option::<UriExpr>::Some(move _49);
        _0 = std::result::Result::<Option<UriExpr>, syn::Error>::Ok(move _48);
        _57 = const false;
        drop(_7) -> [return: bb42, unwind continue];
    }

    bb41: {
        _57 = const false;
        drop(_7) -> [return: bb42, unwind continue];
    }

    bb42: {
        return;
    }

    bb43 (cleanup): {
        drop(_51) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_7) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        resume;
    }

    bb46 (cleanup): {
        drop(_13) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_57) -> [0: bb44, otherwise: bb46];
    }

    bb48: {
        goto -> bb41;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:487:46: 487:49}, _2: syn::Expr) -> Option<UriExpr> {
    debug e => _2;
    let mut _0: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _3: bang::uri_parsing::UriExpr;

    bb0: {
        _3 = UriExpr::Expr(move _2);
        _0 = Option::<UriExpr>::Some(move _3);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#1}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:492:22: 492:25}, _2: rocket_http::uri::Error<'_>) -> std::result::Result<rocket_http::uri::Uri<'_>, (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>)> {
    debug e => _2;
    debug lit => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: std::result::Result<rocket_http::uri::Uri<'_>, (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>)>;
    let mut _3: std::result::Result<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>;
    let _4: &str;
    let mut _5: {closure@core/codegen/src/bang/uri_parsing.rs:492:67: 492:71};
    let mut _6: &proc_macro_ext::StringLit;
    let mut _7: bool;

    bb0: {
        _7 = const false;
        _7 = const true;
        _6 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _4 = <StringLit as std::ops::Deref>::deref(_6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _3 = rocket_http::uri::Uri::<'_>::parse::<rocket_http::uri::Absolute<'_>>(_4) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _7 = const false;
        _5 = {closure@core/codegen/src/bang/uri_parsing.rs:492:67: 492:71} { e: move _2 };
        _0 = std::result::Result::<rocket_http::uri::Uri<'_>, rocket_http::uri::Error<'_>>::map_err::<(rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>), {closure@core/codegen/src/bang/uri_parsing.rs:492:67: 492:71}>(move _3, move _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        switchInt(_7) -> [0: bb4, otherwise: bb5];
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#1}::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:492:67: 492:71}, _2: rocket_http::uri::Error<'_>) -> (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>) {
    debug e2 => _2;
    debug e => (_1.0: rocket_http::uri::Error<'_>);
    let mut _0: (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>);
    let mut _3: rocket_http::uri::Error<'_>;

    bb0: {
        _3 = move (_1.0: rocket_http::uri::Error<'_>);
        _0 = (move _3, move _2);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#2}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:493:22: 493:32}, _2: (rocket_http::uri::Error<'_>, rocket_http::uri::Error<'_>)) -> rocket_http::uri::Error<'_> {
    debug lit => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: rocket_http::uri::Error<'_>;
    let _3: rocket_http::uri::Error<'_>;
    let _4: rocket_http::uri::Error<'_>;
    let mut _5: std::option::Option<rocket_http::uri::Error<'_>>;
    let mut _6: bool;
    let _7: &str;
    let mut _8: {closure@core/codegen/src/bang/uri_parsing.rs:493:59: 493:61};
    let mut _9: {closure@core/codegen/src/bang/uri_parsing.rs:493:81: 493:83};
    let mut _10: &proc_macro_ext::StringLit;
    let mut _11: bool;
    let mut _12: bool;
    scope 1 {
        debug e1 => _3;
        debug e2 => _4;
    }

    bb0: {
        _12 = const false;
        _11 = const false;
        _12 = const true;
        _3 = move (_2.0: rocket_http::uri::Error<'_>);
        _11 = const true;
        _4 = move (_2.1: rocket_http::uri::Error<'_>);
        _10 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _7 = <StringLit as std::ops::Deref>::deref(_10) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _6 = core::str::<impl str>::starts_with::<'_, char>(_7, const '/') -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _12 = const false;
        _8 = {closure@core/codegen/src/bang/uri_parsing.rs:493:59: 493:61} { e1: move _3 };
        _5 = core::bool::<impl bool>::then::<rocket_http::uri::Error<'_>, {closure@core/codegen/src/bang/uri_parsing.rs:493:59: 493:61}>(move _6, move _8) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _11 = const false;
        _9 = {closure@core/codegen/src/bang/uri_parsing.rs:493:81: 493:83} { e2: move _4 };
        _0 = Option::<rocket_http::uri::Error<'_>>::unwrap_or_else::<{closure@core/codegen/src/bang/uri_parsing.rs:493:81: 493:83}>(move _5, move _9) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _11 = const false;
        _12 = const false;
        return;
    }

    bb5 (cleanup): {
        switchInt(_12) -> [0: bb6, otherwise: bb9];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        switchInt(_11) -> [0: bb5, otherwise: bb7];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#2}::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:493:59: 493:61}) -> rocket_http::uri::Error<'_> {
    debug e1 => (_1.0: rocket_http::uri::Error<'_>);
    let mut _0: rocket_http::uri::Error<'_>;

    bb0: {
        _0 = move (_1.0: rocket_http::uri::Error<'_>);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#2}::{closure#1}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:493:81: 493:83}) -> rocket_http::uri::Error<'_> {
    debug e2 => (_1.0: rocket_http::uri::Error<'_>);
    let mut _0: rocket_http::uri::Error<'_>;

    bb0: {
        _0 = move (_1.0: rocket_http::uri::Error<'_>);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_prefix::{closure#3}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:494:22: 494:25}, _2: rocket_http::uri::Error<'_>) -> std::result::Result<rocket_http::uri::Uri<'_>, syn::Error> {
    debug e => _2;
    debug lit => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: std::result::Result<rocket_http::uri::Uri<'_>, syn::Error>;
    let mut _3: &proc_macro_ext::StringLit;

    bb0: {
        _3 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _0 = uri_err::<rocket_http::uri::Uri<'_>>(_3, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_suffix(_1: &ParseBuffer<'_>) -> std::result::Result<Option<UriExpr>, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<std::option::Option<bang::uri_parsing::UriExpr>, syn::Error>;
    let mut _2: std::result::Result<syn::token::Underscore, syn::Error>;
    let mut _3: isize;
    let mut _4: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _5: bool;
    let mut _6: std::result::Result<syn::Expr, syn::Error>;
    let _7: proc_macro_ext::StringLit;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro_ext::StringLit>;
    let mut _9: std::result::Result<proc_macro_ext::StringLit, syn::Error>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, syn::Error>;
    let _12: proc_macro_ext::StringLit;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, rocket_http::uri::Reference<'_>>;
    let mut _15: std::result::Result<rocket_http::uri::Reference<'_>, syn::Error>;
    let mut _16: std::result::Result<rocket_http::uri::Reference<'_>, rocket_http::uri::Error<'_>>;
    let _17: &str;
    let _18: &proc_macro_ext::StringLit;
    let mut _19: {closure@core/codegen/src/bang/uri_parsing.rs:515:50: 515:53};
    let mut _20: &proc_macro_ext::StringLit;
    let mut _21: isize;
    let mut _24: bool;
    let mut _25: &std::option::Option<&str>;
    let _26: std::option::Option<&str>;
    let mut _27: &rocket_http::uri::Reference<'_>;
    let mut _28: bool;
    let mut _29: &std::option::Option<&rocket_http::uri::Authority<'_>>;
    let _30: std::option::Option<&rocket_http::uri::Authority<'_>>;
    let mut _31: &rocket_http::uri::Reference<'_>;
    let mut _32: bool;
    let _33: &rocket_http::RawStr;
    let mut _34: &rocket_http::uri::Path<'_>;
    let _35: rocket_http::uri::Path<'_>;
    let mut _36: &rocket_http::uri::Reference<'_>;
    let mut _37: proc_macro2::Span;
    let mut _38: &proc_macro_ext::StringLit;
    let mut _40: std::option::Option<&rocket_http::RawStr>;
    let mut _41: &rocket_http::uri::Reference<'_>;
    let mut _42: isize;
    let mut _44: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _45: &rocket_http::uri::Reference<'_>;
    let mut _46: rocket_http::uri::Absolute<'_>;
    let _47: &str;
    let mut _48: std::option::Option<rocket_http::uri::Authority<'_>>;
    let _49: &str;
    let mut _50: rocket_http::uri::Reference<'_>;
    let mut _51: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _52: bang::uri_parsing::UriExpr;
    let mut _53: bang::uri_parsing::UriLit;
    let mut _54: rocket_http::uri::Uri<'_>;
    let mut _55: rocket_http::uri::Uri<'_>;
    let mut _56: proc_macro2::Span;
    let mut _57: &proc_macro_ext::StringLit;
    let mut _58: bool;
    scope 1 {
    }
    scope 2 {
        debug lit => _7;
        let _13: rocket_http::uri::Reference<'_>;
        let _22: std::result::Result<std::convert::Infallible, syn::Error>;
        let _23: rocket_http::uri::Reference<'_>;
        scope 7 {
            debug uri => _13;
            let _39: rocket_http::uri::Uri<'_>;
            let _43: std::option::Option<&str>;
            scope 12 {
                debug uri => _39;
            }
            scope 13 {
                debug query => _43;
            }
        }
        scope 8 {
            debug residual => _22;
            scope 9 {
            }
        }
        scope 10 {
            debug val => _23;
            scope 11 {
            }
        }
    }
    scope 3 {
        debug residual => _11;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _12;
        scope 6 {
        }
    }

    bb0: {
        _58 = const false;
        _2 = ParseBuffer::<'_>::parse::<Underscore>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, otherwise: bb3];
    }

    bb2: {
        _4 = Option::<UriExpr>::None;
        _0 = std::result::Result::<Option<UriExpr>, syn::Error>::Ok(move _4);
        drop(_2) -> [return: bb44, unwind continue];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ParseBuffer::<'_>::peek::<fn(syn::lookahead::TokenMarker) -> LitStr {LitStr}>(_1, LitStr) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _5) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _9 = ParseBuffer::<'_>::parse::<StringLit>(_1) -> [return: bb9, unwind continue];
    }

    bb7: {
        _6 = ParseBuffer::<'_>::parse::<syn::Expr>(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = std::result::Result::<syn::Expr, syn::Error>::map::<Option<UriExpr>, {closure@core/codegen/src/bang/uri_parsing.rs:511:46: 511:49}>(move _6, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:511:46: 511:49}) -> [return: bb44, unwind continue];
    }

    bb9: {
        _8 = <std::result::Result<StringLit, syn::Error> as std::ops::Try>::branch(move _9) -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _12 = move ((_8 as Continue).0: proc_macro_ext::StringLit);
        _7 = move _12;
        _18 = &_7;
        _17 = <StringLit as std::ops::Deref>::deref(_18) -> [return: bb14, unwind: bb46];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Option<UriExpr>, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _11) -> [return: bb44, unwind continue];
    }

    bb14: {
        _16 = rocket_http::uri::Reference::<'_>::parse(_17) -> [return: bb15, unwind: bb46];
    }

    bb15: {
        _20 = &_7;
        _19 = {closure@core/codegen/src/bang/uri_parsing.rs:515:50: 515:53} { lit: move _20 };
        _15 = std::result::Result::<rocket_http::uri::Reference<'_>, rocket_http::uri::Error<'_>>::or_else::<syn::Error, {closure@core/codegen/src/bang/uri_parsing.rs:515:50: 515:53}>(move _16, move _19) -> [return: bb16, unwind: bb46];
    }

    bb16: {
        _14 = <std::result::Result<rocket_http::uri::Reference<'_>, syn::Error> as std::ops::Try>::branch(move _15) -> [return: bb17, unwind: bb46];
    }

    bb17: {
        _21 = discriminant(_14);
        switchInt(move _21) -> [0: bb18, 1: bb19, otherwise: bb12];
    }

    bb18: {
        _23 = move ((_14 as Continue).0: rocket_http::uri::Reference<'_>);
        _58 = const true;
        _13 = move _23;
        _27 = &_13;
        _26 = rocket_http::uri::Reference::<'_>::scheme(move _27) -> [return: bb20, unwind: bb50];
    }

    bb19: {
        _22 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Option<UriExpr>, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _22) -> [return: bb51, unwind: bb46];
    }

    bb20: {
        _25 = &_26;
        _24 = Option::<&str>::is_some(move _25) -> [return: bb21, unwind: bb50];
    }

    bb21: {
        switchInt(move _24) -> [0: bb22, otherwise: bb30];
    }

    bb22: {
        _31 = &_13;
        _30 = rocket_http::uri::Reference::<'_>::authority(move _31) -> [return: bb23, unwind: bb50];
    }

    bb23: {
        _29 = &_30;
        _28 = Option::<&rocket_http::uri::Authority<'_>>::is_some(move _29) -> [return: bb24, unwind: bb50];
    }

    bb24: {
        switchInt(move _28) -> [0: bb25, otherwise: bb30];
    }

    bb25: {
        _36 = &_13;
        _35 = rocket_http::uri::Reference::<'_>::path(move _36) -> [return: bb26, unwind: bb50];
    }

    bb26: {
        _34 = &_35;
        _33 = <rocket_http::uri::Path<'_> as std::ops::Deref>::deref(move _34) -> [return: bb27, unwind: bb50];
    }

    bb27: {
        _32 = RawStr::is_empty(_33) -> [return: bb28, unwind: bb50];
    }

    bb28: {
        switchInt(move _32) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _41 = &_13;
        _40 = rocket_http::uri::Reference::<'_>::fragment(move _41) -> [return: bb33, unwind: bb50];
    }

    bb30: {
        _38 = &_7;
        _37 = StringLit::span(move _38) -> [return: bb31, unwind: bb50];
    }

    bb31: {
        _0 = err::<Option<UriExpr>, &str>(move _37, const "URI suffix must contain only query and/or fragment") -> [return: bb32, unwind: bb50];
    }

    bb32: {
        drop(_13) -> [return: bb43, unwind: bb46];
    }

    bb33: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb35, 1: bb34, otherwise: bb12];
    }

    bb34: {
        _58 = const false;
        _50 = move _13;
        _39 = rocket_http::uri::Uri::<'_>::Reference(move _50);
        goto -> bb39;
    }

    bb35: {
        _45 = &_13;
        _44 = rocket_http::uri::Reference::<'_>::query(move _45) -> [return: bb36, unwind: bb50];
    }

    bb36: {
        _43 = Option::<rocket_http::uri::Query<'_>>::map::<&str, {closure@core/codegen/src/bang/uri_parsing.rs:531:45: 531:48}>(move _44, const ZeroSized: {closure@core/codegen/src/bang/uri_parsing.rs:531:45: 531:48}) -> [return: bb37, unwind: bb50];
    }

    bb37: {
        _47 = const "";
        _48 = Option::<rocket_http::uri::Authority<'_>>::None;
        _49 = const "";
        _46 = rocket_http::uri::Absolute::<'_>::const_new(_47, move _48, _49, _43) -> [return: bb38, unwind: bb50];
    }

    bb38: {
        _39 = rocket_http::uri::Uri::<'_>::Absolute(move _46);
        goto -> bb39;
    }

    bb39: {
        _55 = move _39;
        _54 = <rocket_http::uri::Uri<'_> as IntoOwned>::into_owned(move _55) -> [return: bb40, unwind: bb50];
    }

    bb40: {
        _57 = &_7;
        _56 = StringLit::span(move _57) -> [return: bb41, unwind: bb45];
    }

    bb41: {
        _53 = UriLit(move _54, move _56);
        _52 = UriExpr::Uri(move _53);
        _51 = Option::<UriExpr>::Some(move _52);
        _0 = std::result::Result::<Option<UriExpr>, syn::Error>::Ok(move _51);
        switchInt(_58) -> [0: bb42, otherwise: bb48];
    }

    bb42: {
        _58 = const false;
        drop(_7) -> [return: bb44, unwind continue];
    }

    bb43: {
        _58 = const false;
        drop(_7) -> [return: bb44, unwind continue];
    }

    bb44: {
        return;
    }

    bb45 (cleanup): {
        drop(_54) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_7) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }

    bb48: {
        drop(_13) -> [return: bb42, unwind: bb46];
    }

    bb49 (cleanup): {
        drop(_13) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        switchInt(_58) -> [0: bb46, otherwise: bb49];
    }

    bb51: {
        goto -> bb43;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_suffix::{closure#0}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:511:46: 511:49}, _2: syn::Expr) -> Option<UriExpr> {
    debug e => _2;
    let mut _0: std::option::Option<bang::uri_parsing::UriExpr>;
    let mut _3: bang::uri_parsing::UriExpr;

    bb0: {
        _3 = UriExpr::Expr(move _2);
        _0 = Option::<UriExpr>::Some(move _3);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_suffix::{closure#1}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:515:50: 515:53}, _2: rocket_http::uri::Error<'_>) -> std::result::Result<rocket_http::uri::Reference<'_>, syn::Error> {
    debug e => _2;
    debug lit => (*(_1.0: &proc_macro_ext::StringLit));
    let mut _0: std::result::Result<rocket_http::uri::Reference<'_>, syn::Error>;
    let mut _3: &proc_macro_ext::StringLit;

    bb0: {
        _3 = deref_copy (_1.0: &proc_macro_ext::StringLit);
        _0 = uri_err::<rocket_http::uri::Reference<'_>>(_3, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:480:1: 480:13>::parse_suffix::{closure#2}(_1: {closure@core/codegen/src/bang/uri_parsing.rs:531:45: 531:48}, _2: rocket_http::uri::Query<'_>) -> &str {
    debug q => _2;
    let mut _0: &str;
    let mut _3: &rocket_http::uri::Query<'_>;

    bb0: {
        _3 = &_2;
        _0 = rocket_http::uri::Query::<'_>::as_str(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:541:1: 541:22>::deref(_1: &UriLit) -> &rocket_http::uri::Uri<'_> {
    debug self => _1;
    let mut _0: &rocket_http::uri::Uri<'_>;

    bb0: {
        _0 = &((*_1).0: rocket_http::uri::Uri<'_>);
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:549:1: 549:25>::to_tokens(_1: &UriLit, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let _3: &rocket_http::uri::Uri<'_>;
    let _4: proc_macro2::Span;
    let mut _5: (&rocket_http::uri::Uri<'_>, proc_macro2::Span);
    let mut _6: &rocket_http::uri::Uri<'_>;
    let mut _7: proc_macro2::Span;
    let mut _8: isize;
    let mut _10: &http_codegen::Origin<'_>;
    let _11: http_codegen::Origin<'_>;
    let mut _13: &http_codegen::Absolute<'_>;
    let _14: http_codegen::Absolute<'_>;
    let mut _16: &http_codegen::Authority<'_>;
    let _17: http_codegen::Authority<'_>;
    let mut _19: &http_codegen::Reference<'_>;
    let _20: http_codegen::Reference<'_>;
    let mut _22: &http_codegen::Asterisk;
    let _23: http_codegen::Asterisk;
    scope 1 {
        debug uri => _3;
        debug span => _4;
        let _9: &rocket_http::uri::Origin<'_>;
        let _12: &rocket_http::uri::Absolute<'_>;
        let _15: &rocket_http::uri::Authority<'_>;
        let _18: &rocket_http::uri::Reference<'_>;
        let _21: &rocket_http::uri::Asterisk;
        scope 2 {
            debug o => _9;
        }
        scope 3 {
            debug o => _12;
        }
        scope 4 {
            debug o => _15;
        }
        scope 5 {
            debug r => _18;
        }
        scope 6 {
            debug a => _21;
        }
    }

    bb0: {
        _6 = &((*_1).0: rocket_http::uri::Uri<'_>);
        _7 = ((*_1).1: proc_macro2::Span);
        _5 = (move _6, move _7);
        _3 = (_5.0: &rocket_http::uri::Uri<'_>);
        _4 = (_5.1: proc_macro2::Span);
        _8 = discriminant((*_3));
        switchInt(move _8) -> [0: bb1, 1: bb3, 2: bb5, 3: bb4, 4: bb6, otherwise: bb2];
    }

    bb1: {
        _21 = &(((*_3) as Asterisk).0: rocket_http::uri::Asterisk);
        _23 = http_codegen::Asterisk(const rocket_http::uri::Asterisk, _4);
        _22 = &_23;
        _0 = <http_codegen::Asterisk as ToTokens>::to_tokens(move _22, _2) -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _9 = &(((*_3) as Origin).0: rocket_http::uri::Origin<'_>);
        _11 = http_codegen::Origin::<'_>(_9, _4);
        _10 = &_11;
        _0 = <http_codegen::Origin<'_> as ToTokens>::to_tokens(move _10, _2) -> [return: bb7, unwind continue];
    }

    bb4: {
        _12 = &(((*_3) as Absolute).0: rocket_http::uri::Absolute<'_>);
        _14 = http_codegen::Absolute::<'_>(_12, _4);
        _13 = &_14;
        _0 = <http_codegen::Absolute<'_> as ToTokens>::to_tokens(move _13, _2) -> [return: bb7, unwind continue];
    }

    bb5: {
        _15 = &(((*_3) as Authority).0: rocket_http::uri::Authority<'_>);
        _17 = http_codegen::Authority::<'_>(_15, _4);
        _16 = &_17;
        _0 = <http_codegen::Authority<'_> as ToTokens>::to_tokens(move _16, _2) -> [return: bb7, unwind continue];
    }

    bb6: {
        _18 = &(((*_3) as Reference).0: rocket_http::uri::Reference<'_>);
        _20 = http_codegen::Reference::<'_>(_18, _4);
        _19 = &_20;
        _0 = <http_codegen::Reference<'_> as ToTokens>::to_tokens(move _19, _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:564:1: 564:26>::to_tokens(_1: &UriExpr, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &bang::uri_parsing::UriLit;
    let _5: &syn::Expr;
    scope 1 {
        debug uri => _4;
    }
    scope 2 {
        debug e => _5;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as Expr).0: syn::Expr);
        _0 = <syn::Expr as ToTokens>::to_tokens(_5, _2) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Uri).0: bang::uri_parsing::UriLit);
        _0 = <UriLit as ToTokens>::to_tokens(_4, _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:573:1: 573:26>::to_tokens(_1: &uri_parsing::ArgExpr, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &syn::Expr;
    let _5: &syn::token::Underscore;
    scope 1 {
        debug e => _4;
    }
    scope 2 {
        debug e => _5;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as Ignored).0: syn::token::Underscore);
        _0 = <Underscore as ToTokens>::to_tokens(_5, _2) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Expr).0: syn::Expr);
        _0 = <syn::Expr as ToTokens>::to_tokens(_4, _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:582:1: 582:22>::to_tokens(_1: &Arg, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &bang::uri_parsing::ArgExpr;
    let _5: &proc_macro2::Ident;
    let _6: &syn::token::Eq;
    let _7: &bang::uri_parsing::ArgExpr;
    let _8: ();
    let _9: ();
    let _10: ();
    scope 1 {
        debug e => _4;
    }
    scope 2 {
        debug ident => _5;
        debug eq => _6;
        debug expr => _7;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &(((*_1) as Named).1: proc_macro2::Ident);
        _6 = &(((*_1) as Named).2: syn::token::Eq);
        _7 = &(((*_1) as Named).3: bang::uri_parsing::ArgExpr);
        _8 = <proc_macro2::Ident as ToTokens>::to_tokens(_5, _2) -> [return: bb4, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Unnamed).0: bang::uri_parsing::ArgExpr);
        _0 = <uri_parsing::ArgExpr as ToTokens>::to_tokens(_4, _2) -> [return: bb6, unwind continue];
    }

    bb4: {
        _9 = <syn::token::Eq as ToTokens>::to_tokens(_6, _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = <uri_parsing::ArgExpr as ToTokens>::to_tokens(_7, _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn uri_parsing::<impl at core/codegen/src/bang/uri_parsing.rs:595:1: 595:23>::to_tokens(_1: &uri_parsing::Args, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    let mut _5: &syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>;
    scope 1 {
        debug e => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb4, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _4 = &(((*_1) as Named).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        goto -> bb3;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = _4;
        _0 = <syn::punctuated::Punctuated<Arg, syn::token::Comma> as ToTokens>::to_tokens(move _5, _2) -> [return: bb5, unwind continue];
    }

    bb4: {
        _4 = &(((*_1) as Unnamed).0: syn::punctuated::Punctuated<bang::uri_parsing::Arg, syn::token::Comma>);
        goto -> bb3;
    }

    bb5: {
        return;
    }
}

fn test_guide::_macro(_1: proc_macro::TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: syn::LitStr;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::LitStr>;
    let mut _4: std::result::Result<syn::LitStr, syn::Error>;
    let mut _5: proc_macro::TokenStream;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, syn::Error>;
    let _8: syn::LitStr;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::vec::Vec<proc_macro2::TokenStream>>;
    let mut _11: std::result::Result<std::vec::Vec<proc_macro2::TokenStream>, devise::Diagnostic>;
    let mut _12: std::result::Result<std::vec::Vec<proc_macro2::TokenStream>, std::boxed::Box<dyn std::error::Error>>;
    let _13: &syn::LitStr;
    let mut _14: {closure@core/codegen/src/bang/test_guide.rs:11:18: 11:21};
    let mut _15: &syn::LitStr;
    let mut _16: isize;
    let mut _19: proc_macro2::TokenStream;
    let mut _22: (std::slice::Iter<'_, proc_macro2::TokenStream>, quote::__private::HasIterator);
    let mut _23: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _25: bool;
    let mut _27: std::option::Option<&proc_macro2::TokenStream>;
    let mut _28: &mut std::slice::Iter<'_, proc_macro2::TokenStream>;
    let mut _29: isize;
    let _31: ();
    let _32: &quote::__private::RepInterp<&proc_macro2::TokenStream>;
    let mut _33: &mut proc_macro2::TokenStream;
    scope 1 {
        debug root_glob => _2;
        let _9: std::vec::Vec<proc_macro2::TokenStream>;
        let _17: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _18: std::vec::Vec<proc_macro2::TokenStream>;
        scope 6 {
            debug tests => _9;
            let mut _20: proc_macro2::TokenStream;
            scope 11 {
                debug _s => _20;
                scope 12 {
                    debug has_iter => const ThereIsNoIteratorInRepetition;
                    scope 13 {
                        debug tests => _21;
                        debug i => const HasIterator;
                        let _24: quote::__private::HasIterator;
                        scope 15 {
                            debug has_iter => const HasIterator;
                            scope 16 {
                                let _26: quote::__private::RepInterp<&proc_macro2::TokenStream>;
                                let _30: &proc_macro2::TokenStream;
                                scope 17 {
                                    debug tests => _26;
                                }
                                scope 18 {
                                    debug _x => _30;
                                }
                            }
                        }
                    }
                    scope 14 {
                        let mut _21: std::slice::Iter<'_, proc_macro2::TokenStream>;
                    }
                }
            }
        }
        scope 7 {
            debug residual => _17;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _18;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = <proc_macro::TokenStream as Into<proc_macro::TokenStream>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = syn::parse::<LitStr>(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::result::Result<LitStr, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _8 = move ((_3 as Continue).0: syn::LitStr);
        _2 = move _8;
        _13 = &_2;
        _12 = entry_to_tests(_13) -> [return: bb7, unwind: bb24];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _7) -> [return: bb21, unwind continue];
    }

    bb7: {
        _15 = &_2;
        _14 = {closure@core/codegen/src/bang/test_guide.rs:11:18: 11:21} { root_glob: move _15 };
        _11 = std::result::Result::<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>>::map_err::<devise::Diagnostic, {closure@core/codegen/src/bang/test_guide.rs:11:18: 11:21}>(move _12, move _14) -> [return: bb8, unwind: bb24];
    }

    bb8: {
        _10 = <std::result::Result<Vec<TokenStream2>, devise::Diagnostic> as std::ops::Try>::branch(move _11) -> [return: bb9, unwind: bb24];
    }

    bb9: {
        _16 = discriminant(_10);
        switchInt(move _16) -> [0: bb10, 1: bb11, otherwise: bb5];
    }

    bb10: {
        _18 = move ((_10 as Continue).0: std::vec::Vec<proc_macro2::TokenStream>);
        _9 = move _18;
        _20 = TokenStream2::new() -> [return: bb13, unwind: bb23];
    }

    bb11: {
        _17 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _17) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb13: {
        _23 = &_9;
        _22 = <Vec<TokenStream2> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _23) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _21 = move (_22.0: std::slice::Iter<'_, proc_macro2::TokenStream>);
        _24 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb26, unwind: bb22];
    }

    bb15: {
        _25 = const true;
        switchInt(move _25) -> [0: bb19, otherwise: bb16];
    }

    bb16: {
        _28 = &mut _21;
        _27 = <std::slice::Iter<'_, TokenStream2> as Iterator>::next(move _28) -> [return: bb17, unwind: bb22];
    }

    bb17: {
        _29 = discriminant(_27);
        switchInt(move _29) -> [0: bb19, 1: bb18, otherwise: bb5];
    }

    bb18: {
        _30 = ((_27 as Some).0: &proc_macro2::TokenStream);
        _26 = RepInterp::<&TokenStream2>(_30);
        _32 = &_26;
        _33 = &mut _20;
        _31 = <RepInterp<&TokenStream2> as ToTokens>::to_tokens(_32, _33) -> [return: bb27, unwind: bb22];
    }

    bb19: {
        _19 = move _20;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _19);
        drop(_9) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_20) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_9) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        goto -> bb15;
    }

    bb27: {
        goto -> bb15;
    }
}

fn test_guide::_macro::{closure#0}(_1: {closure@core/codegen/src/bang/test_guide.rs:11:18: 11:21}, _2: std::boxed::Box<dyn std::error::Error>) -> devise::Diagnostic {
    debug e => _2;
    debug root_glob => (*(_1.0: &syn::LitStr));
    let mut _0: devise::Diagnostic;
    let mut _3: proc_macro2::Span;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &std::boxed::Box<dyn std::error::Error>;
    let mut _12: &[&str; 1];
    let mut _13: &syn::LitStr;
    scope 1 {
        debug res => _4;
    }

    bb0: {
        _13 = deref_copy (_1.0: &syn::LitStr);
        _3 = LitStr::span(_13) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _12 = const _;
        _6 = _12 as &[&str] (PointerCoercion(Unsize));
        _11 = &_2;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<std::boxed::Box<dyn std::error::Error>>(_11) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _4 = format(move _5) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _0 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _3, move _4) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

promoted[0] in test_guide::_macro::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "failed to read: "];
        _0 = &_1;
        return;
    }
}

fn entry_to_tests(_1: &LitStr) -> std::result::Result<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>> {
    debug root_glob => _1;
    let mut _0: std::result::Result<std::vec::Vec<proc_macro2::TokenStream>, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::string::String;
    let mut _3: std::result::Result<std::string::String, std::env::VarError>;
    let _4: &str;
    let mut _6: &std::path::Display<'_>;
    let _7: std::path::Display<'_>;
    let _8: &std::path::Path;
    let mut _9: &std::path::PathBuf;
    let _10: std::path::PathBuf;
    let _11: &std::path::Path;
    let _12: &std::string::String;
    let mut _13: &std::string::String;
    let _14: std::string::String;
    let mut _16: glob::Paths;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<glob::PatternError>>, glob::Paths>;
    let mut _18: std::result::Result<glob::Paths, std::boxed::Box<glob::PatternError>>;
    let mut _19: std::result::Result<glob::Paths, glob::PatternError>;
    let _20: &str;
    let _21: &std::string::String;
    let mut _22: isize;
    let mut _26: std::option::Option<std::result::Result<std::path::PathBuf, glob::GlobError>>;
    let mut _27: &mut glob::Paths;
    let mut _28: isize;
    let mut _31: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<glob::GlobError>>, std::path::PathBuf>;
    let mut _32: std::result::Result<std::path::PathBuf, std::boxed::Box<glob::GlobError>>;
    let mut _33: isize;
    let mut _37: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, &str>, std::string::String>;
    let mut _38: std::result::Result<std::string::String, &str>;
    let mut _39: std::option::Option<std::string::String>;
    let mut _40: std::option::Option<&str>;
    let mut _41: std::option::Option<&std::ffi::OsStr>;
    let _42: &std::path::Path;
    let mut _43: &std::path::PathBuf;
    let mut _44: isize;
    let _48: &str;
    let _49: &std::string::String;
    let _50: std::string::String;
    let _51: &str;
    let mut _52: &std::string::String;
    let mut _53: proc_macro2::Span;
    let mut _55: &std::path::Display<'_>;
    let _56: std::path::Display<'_>;
    let _57: &std::path::Path;
    let mut _58: &std::path::PathBuf;
    let _59: std::path::PathBuf;
    let _60: &std::path::Path;
    let _61: &std::string::String;
    let mut _62: &std::path::PathBuf;
    let _63: ();
    let mut _64: &mut std::vec::Vec<proc_macro2::TokenStream>;
    let mut _65: proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let _70: &str;
    let _71: ();
    let _72: &proc_macro2::Ident;
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let mut _76: proc_macro2::Delimiter;
    let mut _77: proc_macro2::TokenStream;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: &str;
    let _82: ();
    let mut _83: &mut proc_macro2::TokenStream;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: &str;
    let _87: ();
    let mut _88: &mut proc_macro2::TokenStream;
    let mut _89: proc_macro2::Delimiter;
    let mut _90: proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let mut _94: proc_macro2::Delimiter;
    let mut _95: proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: &str;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let _102: &str;
    let _103: ();
    let mut _104: &mut proc_macro2::TokenStream;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: &str;
    let _108: ();
    let mut _109: &mut proc_macro2::TokenStream;
    let _110: ();
    let mut _111: &mut proc_macro2::TokenStream;
    let mut _112: proc_macro2::Delimiter;
    let mut _113: proc_macro2::TokenStream;
    let _115: ();
    let mut _116: &mut proc_macro2::TokenStream;
    let _117: ();
    let mut _118: &mut proc_macro2::TokenStream;
    let mut _119: proc_macro2::Delimiter;
    let mut _120: proc_macro2::TokenStream;
    let _122: ();
    let mut _123: &mut proc_macro2::TokenStream;
    let _124: &str;
    let _125: ();
    let mut _126: &mut proc_macro2::TokenStream;
    let _127: ();
    let mut _128: &mut proc_macro2::TokenStream;
    let _129: &str;
    let _130: ();
    let mut _131: &mut proc_macro2::TokenStream;
    let _132: &str;
    let _133: ();
    let mut _134: &mut proc_macro2::TokenStream;
    let _135: &str;
    let _136: ();
    let mut _137: &mut proc_macro2::TokenStream;
    let mut _138: proc_macro2::Delimiter;
    let mut _139: proc_macro2::TokenStream;
    let _140: ();
    let mut _141: &mut proc_macro2::TokenStream;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: &str;
    let _145: ();
    let mut _146: &mut proc_macro2::TokenStream;
    let _147: ();
    let mut _148: &mut proc_macro2::TokenStream;
    let mut _149: proc_macro2::Delimiter;
    let mut _150: proc_macro2::TokenStream;
    let _152: ();
    let mut _153: &mut proc_macro2::TokenStream;
    let _154: &str;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let mut _159: proc_macro2::Delimiter;
    let mut _160: proc_macro2::TokenStream;
    let _162: ();
    let _163: &std::string::String;
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let mut _167: bool;
    let mut _168: &std::vec::Vec<proc_macro2::TokenStream>;
    let mut _169: std::boxed::Box<dyn std::error::Error>;
    let mut _171: std::fmt::Arguments<'_>;
    let mut _172: &[&str];
    let mut _173: &[core::fmt::rt::Argument<'_>];
    let _174: &[core::fmt::rt::Argument<'_>; 1];
    let _175: [core::fmt::rt::Argument<'_>; 1];
    let mut _176: core::fmt::rt::Argument<'_>;
    let _177: &std::string::String;
    let mut _178: std::vec::Vec<proc_macro2::TokenStream>;
    scope 1 {
        debug manifest_dir => _2;
        let _5: std::string::String;
        scope 2 {
            debug full_glob => _5;
            let mut _15: std::vec::Vec<proc_macro2::TokenStream>;
            scope 3 {
                debug tests => _15;
                let _23: std::result::Result<std::convert::Infallible, std::boxed::Box<glob::PatternError>>;
                let _24: glob::Paths;
                let mut _25: glob::Paths;
                let _170: std::string::String;
                let mut _179: &[&str; 2];
                scope 4 {
                    debug residual => _23;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => _24;
                    scope 7 {
                    }
                }
                scope 8 {
                    debug iter => _25;
                    let _29: std::result::Result<std::path::PathBuf, glob::GlobError>;
                    scope 9 {
                        debug path => _29;
                        let _30: std::path::PathBuf;
                        let _34: std::result::Result<std::convert::Infallible, std::boxed::Box<glob::GlobError>>;
                        let _35: std::path::PathBuf;
                        scope 10 {
                            debug path => _30;
                            let _36: std::string::String;
                            let _45: std::result::Result<std::convert::Infallible, &str>;
                            let _46: std::string::String;
                            scope 15 {
                                debug name => _36;
                                let _47: proc_macro2::Ident;
                                scope 20 {
                                    debug ident => _47;
                                    let _54: std::string::String;
                                    scope 21 {
                                        debug full_path => _54;
                                        let mut _66: proc_macro2::TokenStream;
                                        scope 22 {
                                            debug _s => _66;
                                            let _67: proc_macro2::Span;
                                            scope 23 {
                                                debug _span => _67;
                                                let mut _78: proc_macro2::TokenStream;
                                                scope 24 {
                                                    debug _s => _78;
                                                    scope 25 {
                                                        debug _span => _67;
                                                        let mut _91: proc_macro2::TokenStream;
                                                        let mut _151: proc_macro2::TokenStream;
                                                        scope 26 {
                                                            debug _s => _91;
                                                            scope 27 {
                                                                debug _span => _67;
                                                                let mut _96: proc_macro2::TokenStream;
                                                                let mut _114: proc_macro2::TokenStream;
                                                                scope 28 {
                                                                    debug _s => _96;
                                                                    scope 29 {
                                                                        debug _span => _67;
                                                                    }
                                                                }
                                                                scope 30 {
                                                                    debug _s => _114;
                                                                    scope 31 {
                                                                        debug _span => _67;
                                                                        let mut _121: proc_macro2::TokenStream;
                                                                        scope 32 {
                                                                            debug _s => _121;
                                                                            scope 33 {
                                                                                debug _span => _67;
                                                                            }
                                                                        }
                                                                        scope 34 {
                                                                        }
                                                                    }
                                                                }
                                                            }
                                                        }
                                                        scope 35 {
                                                            debug _s => _151;
                                                            scope 36 {
                                                                debug _span => _67;
                                                                let mut _161: proc_macro2::TokenStream;
                                                                scope 37 {
                                                                    debug _s => _161;
                                                                    scope 38 {
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                            scope 16 {
                                debug residual => _45;
                                scope 17 {
                                }
                            }
                            scope 18 {
                                debug val => _46;
                                scope 19 {
                                }
                            }
                        }
                        scope 11 {
                            debug residual => _34;
                            scope 12 {
                            }
                        }
                        scope 13 {
                            debug val => _35;
                            scope 14 {
                            }
                        }
                    }
                }
                scope 39 {
                    debug res => _170;
                }
            }
        }
    }

    bb0: {
        _3 = std::env::var::<&str>(const "CARGO_MANIFEST_DIR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = const "MANIFEST_DIR";
        _2 = std::result::Result::<std::string::String, VarError>::expect(move _3, _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _12 = &_2;
        _11 = std::path::Path::new::<std::string::String>(_12) -> [return: bb3, unwind: bb128];
    }

    bb3: {
        _14 = LitStr::value(_1) -> [return: bb4, unwind: bb128];
    }

    bb4: {
        _13 = &_14;
        _10 = std::path::Path::join::<&std::string::String>(_11, move _13) -> [return: bb5, unwind: bb127];
    }

    bb5: {
        _9 = &_10;
        _8 = <PathBuf as std::ops::Deref>::deref(move _9) -> [return: bb6, unwind: bb126];
    }

    bb6: {
        _7 = std::path::Path::display(_8) -> [return: bb7, unwind: bb126];
    }

    bb7: {
        _6 = &_7;
        _5 = <std::path::Display<'_> as ToString>::to_string(move _6) -> [return: bb8, unwind: bb126];
    }

    bb8: {
        drop(_10) -> [return: bb9, unwind: bb124];
    }

    bb9: {
        drop(_14) -> [return: bb10, unwind: bb125];
    }

    bb10: {
        _15 = Vec::<TokenStream2>::new() -> [return: bb11, unwind: bb125];
    }

    bb11: {
        _21 = &_5;
        _20 = <std::string::String as std::ops::Deref>::deref(_21) -> [return: bb12, unwind: bb123];
    }

    bb12: {
        _19 = glob(_20) -> [return: bb13, unwind: bb123];
    }

    bb13: {
        _18 = std::result::Result::<Paths, PatternError>::map_err::<std::boxed::Box<PatternError>, fn(PatternError) -> std::boxed::Box<PatternError> {std::boxed::Box::<PatternError>::new}>(move _19, std::boxed::Box::<PatternError>::new) -> [return: bb14, unwind: bb123];
    }

    bb14: {
        _17 = <std::result::Result<Paths, std::boxed::Box<PatternError>> as std::ops::Try>::branch(move _18) -> [return: bb15, unwind: bb123];
    }

    bb15: {
        _22 = discriminant(_17);
        switchInt(move _22) -> [0: bb16, 1: bb18, otherwise: bb17];
    }

    bb16: {
        _24 = move ((_17 as Continue).0: glob::Paths);
        _16 = <Paths as IntoIterator>::into_iter(move _24) -> [return: bb19, unwind: bb123];
    }

    bb17: {
        unreachable;
    }

    bb18: {
        _23 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<glob::PatternError>>);
        _0 = <std::result::Result<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::boxed::Box<PatternError>>>>::from_residual(move _23) -> [return: bb130, unwind: bb123];
    }

    bb19: {
        _25 = move _16;
        goto -> bb20;
    }

    bb20: {
        _27 = &mut _25;
        _26 = <Paths as Iterator>::next(_27) -> [return: bb21, unwind: bb122];
    }

    bb21: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb23, 1: bb22, otherwise: bb17];
    }

    bb22: {
        _29 = move ((_26 as Some).0: std::result::Result<std::path::PathBuf, glob::GlobError>);
        _32 = std::result::Result::<PathBuf, GlobError>::map_err::<std::boxed::Box<GlobError>, fn(GlobError) -> std::boxed::Box<GlobError> {std::boxed::Box::<GlobError>::new}>(move _29, std::boxed::Box::<GlobError>::new) -> [return: bb24, unwind: bb122];
    }

    bb23: {
        drop(_25) -> [return: bb94, unwind: bb123];
    }

    bb24: {
        _31 = <std::result::Result<PathBuf, std::boxed::Box<GlobError>> as std::ops::Try>::branch(move _32) -> [return: bb25, unwind: bb122];
    }

    bb25: {
        _33 = discriminant(_31);
        switchInt(move _33) -> [0: bb26, 1: bb27, otherwise: bb17];
    }

    bb26: {
        _35 = move ((_31 as Continue).0: std::path::PathBuf);
        _30 = move _35;
        _43 = &_30;
        _42 = <PathBuf as std::ops::Deref>::deref(move _43) -> [return: bb28, unwind: bb121];
    }

    bb27: {
        _34 = move ((_31 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<glob::GlobError>>);
        _0 = <std::result::Result<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::boxed::Box<GlobError>>>>::from_residual(move _34) -> [return: bb131, unwind: bb122];
    }

    bb28: {
        _41 = std::path::Path::file_name(_42) -> [return: bb29, unwind: bb121];
    }

    bb29: {
        _40 = Option::<&OsStr>::and_then::<&str, {closure@core/codegen/src/bang/test_guide.rs:24:23: 24:26}>(move _41, const ZeroSized: {closure@core/codegen/src/bang/test_guide.rs:24:23: 24:26}) -> [return: bb30, unwind: bb121];
    }

    bb30: {
        _39 = Option::<&str>::map::<std::string::String, {closure@core/codegen/src/bang/test_guide.rs:25:18: 25:24}>(move _40, const ZeroSized: {closure@core/codegen/src/bang/test_guide.rs:25:18: 25:24}) -> [return: bb31, unwind: bb121];
    }

    bb31: {
        _38 = Option::<std::string::String>::ok_or_else::<&str, {closure@core/codegen/src/bang/test_guide.rs:27:25: 27:27}>(move _39, const ZeroSized: {closure@core/codegen/src/bang/test_guide.rs:27:25: 27:27}) -> [return: bb32, unwind: bb121];
    }

    bb32: {
        _37 = <std::result::Result<std::string::String, &str> as std::ops::Try>::branch(move _38) -> [return: bb33, unwind: bb121];
    }

    bb33: {
        _44 = discriminant(_37);
        switchInt(move _44) -> [0: bb34, 1: bb35, otherwise: bb17];
    }

    bb34: {
        _46 = move ((_37 as Continue).0: std::string::String);
        _36 = move _46;
        _52 = &_36;
        _51 = <std::string::String as std::ops::Deref>::deref(move _52) -> [return: bb37, unwind: bb120];
    }

    bb35: {
        _45 = ((_37 as Break).0: std::result::Result<std::convert::Infallible, &str>);
        _0 = <std::result::Result<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, &str>>>::from_residual(_45) -> [return: bb36, unwind: bb121];
    }

    bb36: {
        drop(_30) -> [return: bb103, unwind: bb122];
    }

    bb37: {
        _50 = str::<impl str>::to_lowercase(_51) -> [return: bb38, unwind: bb120];
    }

    bb38: {
        _49 = &_50;
        _48 = <std::string::String as std::ops::Deref>::deref(_49) -> [return: bb39, unwind: bb119];
    }

    bb39: {
        _53 = LitStr::span(_1) -> [return: bb40, unwind: bb119];
    }

    bb40: {
        _47 = proc_macro2::Ident::new(_48, move _53) -> [return: bb41, unwind: bb119];
    }

    bb41: {
        drop(_50) -> [return: bb42, unwind: bb118];
    }

    bb42: {
        _61 = &_2;
        _60 = std::path::Path::new::<std::string::String>(_61) -> [return: bb43, unwind: bb118];
    }

    bb43: {
        _62 = &_30;
        _59 = std::path::Path::join::<&PathBuf>(_60, move _62) -> [return: bb44, unwind: bb118];
    }

    bb44: {
        _58 = &_59;
        _57 = <PathBuf as std::ops::Deref>::deref(move _58) -> [return: bb45, unwind: bb117];
    }

    bb45: {
        _56 = std::path::Path::display(_57) -> [return: bb46, unwind: bb117];
    }

    bb46: {
        _55 = &_56;
        _54 = <std::path::Display<'_> as ToString>::to_string(move _55) -> [return: bb47, unwind: bb117];
    }

    bb47: {
        drop(_59) -> [return: bb48, unwind: bb116];
    }

    bb48: {
        _64 = &mut _15;
        _66 = TokenStream2::new() -> [return: bb49, unwind: bb116];
    }

    bb49: {
        _67 = LitStr::span(_1) -> [return: bb50, unwind: bb115];
    }

    bb50: {
        _69 = &mut _66;
        _70 = const "mod";
        _68 = push_ident_spanned(_69, _67, _70) -> [return: bb51, unwind: bb115];
    }

    bb51: {
        _72 = &_47;
        _73 = &mut _66;
        _71 = <proc_macro2::Ident as ToTokens>::to_tokens(_72, _73) -> [return: bb52, unwind: bb115];
    }

    bb52: {
        _75 = &mut _66;
        _76 = proc_macro2::Delimiter::Brace;
        _78 = TokenStream2::new() -> [return: bb53, unwind: bb115];
    }

    bb53: {
        _80 = &mut _78;
        _81 = const "macro_rules";
        _79 = push_ident_spanned(_80, _67, _81) -> [return: bb54, unwind: bb114];
    }

    bb54: {
        _83 = &mut _78;
        _82 = push_bang_spanned(_83, _67) -> [return: bb55, unwind: bb114];
    }

    bb55: {
        _85 = &mut _78;
        _86 = const "doc_comment";
        _84 = push_ident_spanned(_85, _67, _86) -> [return: bb56, unwind: bb114];
    }

    bb56: {
        _88 = &mut _78;
        _89 = proc_macro2::Delimiter::Brace;
        _91 = TokenStream2::new() -> [return: bb57, unwind: bb114];
    }

    bb57: {
        _93 = &mut _91;
        _94 = proc_macro2::Delimiter::Parenthesis;
        _96 = TokenStream2::new() -> [return: bb58, unwind: bb113];
    }

    bb58: {
        _98 = &mut _96;
        _99 = const "$";
        _97 = parse_spanned(_98, _67, _99) -> [return: bb59, unwind: bb112];
    }

    bb59: {
        _101 = &mut _96;
        _102 = const "x";
        _100 = push_ident_spanned(_101, _67, _102) -> [return: bb60, unwind: bb112];
    }

    bb60: {
        _104 = &mut _96;
        _103 = push_colon_spanned(_104, _67) -> [return: bb61, unwind: bb112];
    }

    bb61: {
        _106 = &mut _96;
        _107 = const "expr";
        _105 = push_ident_spanned(_106, _67, _107) -> [return: bb62, unwind: bb112];
    }

    bb62: {
        _95 = move _96;
        _92 = push_group_spanned(_93, _67, move _94, move _95) -> [return: bb63, unwind: bb113];
    }

    bb63: {
        _109 = &mut _91;
        _108 = push_fat_arrow_spanned(_109, _67) -> [return: bb64, unwind: bb113];
    }

    bb64: {
        _111 = &mut _91;
        _112 = proc_macro2::Delimiter::Parenthesis;
        _114 = TokenStream2::new() -> [return: bb65, unwind: bb113];
    }

    bb65: {
        _116 = &mut _114;
        _115 = push_pound_spanned(_116, _67) -> [return: bb66, unwind: bb111];
    }

    bb66: {
        _118 = &mut _114;
        _119 = proc_macro2::Delimiter::Bracket;
        _121 = TokenStream2::new() -> [return: bb67, unwind: bb111];
    }

    bb67: {
        _123 = &mut _121;
        _124 = const "doc";
        _122 = push_ident_spanned(_123, _67, _124) -> [return: bb68, unwind: bb110];
    }

    bb68: {
        _126 = &mut _121;
        _125 = push_eq_spanned(_126, _67) -> [return: bb69, unwind: bb110];
    }

    bb69: {
        _128 = &mut _121;
        _129 = const "$";
        _127 = parse_spanned(_128, _67, _129) -> [return: bb70, unwind: bb110];
    }

    bb70: {
        _131 = &mut _121;
        _132 = const "x";
        _130 = push_ident_spanned(_131, _67, _132) -> [return: bb71, unwind: bb110];
    }

    bb71: {
        _120 = move _121;
        _117 = push_group_spanned(_118, _67, move _119, move _120) -> [return: bb72, unwind: bb111];
    }

    bb72: {
        _134 = &mut _114;
        _135 = const "extern";
        _133 = push_ident_spanned(_134, _67, _135) -> [return: bb73, unwind: bb111];
    }

    bb73: {
        _137 = &mut _114;
        _138 = proc_macro2::Delimiter::Brace;
        _139 = TokenStream2::new() -> [return: bb74, unwind: bb111];
    }

    bb74: {
        _136 = push_group_spanned(_137, _67, move _138, move _139) -> [return: bb75, unwind: bb111];
    }

    bb75: {
        _113 = move _114;
        _110 = push_group_spanned(_111, _67, move _112, move _113) -> [return: bb76, unwind: bb113];
    }

    bb76: {
        _141 = &mut _91;
        _140 = push_semi_spanned(_141, _67) -> [return: bb77, unwind: bb113];
    }

    bb77: {
        _90 = move _91;
        _87 = push_group_spanned(_88, _67, move _89, move _90) -> [return: bb78, unwind: bb114];
    }

    bb78: {
        _143 = &mut _78;
        _144 = const "doc_comment";
        _142 = push_ident_spanned(_143, _67, _144) -> [return: bb79, unwind: bb114];
    }

    bb79: {
        _146 = &mut _78;
        _145 = push_bang_spanned(_146, _67) -> [return: bb80, unwind: bb114];
    }

    bb80: {
        _148 = &mut _78;
        _149 = proc_macro2::Delimiter::Parenthesis;
        _151 = TokenStream2::new() -> [return: bb81, unwind: bb114];
    }

    bb81: {
        _153 = &mut _151;
        _154 = const "include_str";
        _152 = push_ident_spanned(_153, _67, _154) -> [return: bb82, unwind: bb109];
    }

    bb82: {
        _156 = &mut _151;
        _155 = push_bang_spanned(_156, _67) -> [return: bb83, unwind: bb109];
    }

    bb83: {
        _158 = &mut _151;
        _159 = proc_macro2::Delimiter::Parenthesis;
        _161 = TokenStream2::new() -> [return: bb84, unwind: bb109];
    }

    bb84: {
        _163 = &_54;
        _164 = &mut _161;
        _162 = <std::string::String as ToTokens>::to_tokens(_163, _164) -> [return: bb85, unwind: bb108];
    }

    bb85: {
        _160 = move _161;
        _157 = push_group_spanned(_158, _67, move _159, move _160) -> [return: bb86, unwind: bb109];
    }

    bb86: {
        _150 = move _151;
        _147 = push_group_spanned(_148, _67, move _149, move _150) -> [return: bb87, unwind: bb114];
    }

    bb87: {
        _166 = &mut _78;
        _165 = push_semi_spanned(_166, _67) -> [return: bb88, unwind: bb114];
    }

    bb88: {
        _77 = move _78;
        _74 = push_group_spanned(_75, _67, move _76, move _77) -> [return: bb89, unwind: bb115];
    }

    bb89: {
        _65 = move _66;
        _63 = Vec::<TokenStream2>::push(move _64, move _65) -> [return: bb90, unwind: bb116];
    }

    bb90: {
        drop(_54) -> [return: bb91, unwind: bb118];
    }

    bb91: {
        drop(_47) -> [return: bb92, unwind: bb120];
    }

    bb92: {
        drop(_36) -> [return: bb93, unwind: bb121];
    }

    bb93: {
        drop(_30) -> [return: bb20, unwind: bb122];
    }

    bb94: {
        _168 = &_15;
        _167 = Vec::<TokenStream2>::is_empty(move _168) -> [return: bb95, unwind: bb123];
    }

    bb95: {
        switchInt(move _167) -> [0: bb101, otherwise: bb96];
    }

    bb96: {
        _179 = const _;
        _172 = _179 as &[&str] (PointerCoercion(Unsize));
        _177 = &_5;
        _176 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_177) -> [return: bb97, unwind: bb123];
    }

    bb97: {
        _175 = [move _176];
        _174 = &_175;
        _173 = _174 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _171 = std::fmt::Arguments::<'_>::new_v1(move _172, move _173) -> [return: bb98, unwind: bb123];
    }

    bb98: {
        _170 = format(move _171) -> [return: bb99, unwind: bb123];
    }

    bb99: {
        _169 = <std::string::String as Into<std::boxed::Box<dyn std::error::Error>>>::into(move _170) -> [return: bb100, unwind: bb123];
    }

    bb100: {
        _0 = std::result::Result::<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>>::Err(move _169);
        goto -> bb104;
    }

    bb101: {
        _178 = move _15;
        _0 = std::result::Result::<Vec<TokenStream2>, std::boxed::Box<dyn std::error::Error>>::Ok(move _178);
        drop(_5) -> [return: bb102, unwind: bb128];
    }

    bb102: {
        drop(_2) -> [return: bb107, unwind continue];
    }

    bb103: {
        drop(_25) -> [return: bb104, unwind: bb123];
    }

    bb104: {
        drop(_15) -> [return: bb105, unwind: bb125];
    }

    bb105: {
        drop(_5) -> [return: bb106, unwind: bb128];
    }

    bb106: {
        drop(_2) -> [return: bb107, unwind continue];
    }

    bb107: {
        return;
    }

    bb108 (cleanup): {
        drop(_161) -> [return: bb109, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        drop(_151) -> [return: bb114, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        drop(_121) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_114) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_96) -> [return: bb113, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_91) -> [return: bb114, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_78) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_66) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_54) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        drop(_59) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        drop(_47) -> [return: bb120, unwind terminate(cleanup)];
    }

    bb119 (cleanup): {
        drop(_50) -> [return: bb120, unwind terminate(cleanup)];
    }

    bb120 (cleanup): {
        drop(_36) -> [return: bb121, unwind terminate(cleanup)];
    }

    bb121 (cleanup): {
        drop(_30) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb122 (cleanup): {
        drop(_25) -> [return: bb123, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        drop(_15) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb124 (cleanup): {
        drop(_14) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        drop(_5) -> [return: bb128, unwind terminate(cleanup)];
    }

    bb126 (cleanup): {
        drop(_10) -> [return: bb127, unwind terminate(cleanup)];
    }

    bb127 (cleanup): {
        drop(_14) -> [return: bb128, unwind terminate(cleanup)];
    }

    bb128 (cleanup): {
        drop(_2) -> [return: bb129, unwind terminate(cleanup)];
    }

    bb129 (cleanup): {
        resume;
    }

    bb130: {
        goto -> bb104;
    }

    bb131: {
        goto -> bb103;
    }
}

promoted[0] in entry_to_tests: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "glob '", const "' evaluates to 0 files"];
        _0 = &_1;
        return;
    }
}

fn entry_to_tests::{closure#0}(_1: {closure@core/codegen/src/bang/test_guide.rs:24:23: 24:26}, _2: &OsStr) -> Option<&str> {
    debug f => _2;
    let mut _0: std::option::Option<&str>;

    bb0: {
        _0 = OsStr::to_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn entry_to_tests::{closure#1}(_1: {closure@core/codegen/src/bang/test_guide.rs:25:18: 25:24}, _2: &str) -> std::string::String {
    debug name => _2;
    let mut _0: std::string::String;
    let _3: &str;
    let _4: &str;

    bb0: {
        _3 = core::str::<impl str>::trim_matches::<'_, {closure@core/codegen/src/bang/test_guide.rs:25:43: 25:46}>(_2, const ZeroSized: {closure@core/codegen/src/bang/test_guide.rs:25:43: 25:46}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = const "_";
        _0 = str::<impl str>::replace::<'_, {closure@core/codegen/src/bang/test_guide.rs:26:26: 26:29}>(_3, const ZeroSized: {closure@core/codegen/src/bang/test_guide.rs:26:26: 26:29}, _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn entry_to_tests::{closure#1}::{closure#0}(_1: &{closure@core/codegen/src/bang/test_guide.rs:25:43: 25:46}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;
    let mut _3: bool;

    bb0: {
        _3 = char::methods::<impl char>::is_numeric(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = Eq(_2, const '-');
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn entry_to_tests::{closure#1}::{closure#1}(_1: &{closure@core/codegen/src/bang/test_guide.rs:26:26: 26:29}, _2: char) -> bool {
    debug c => _2;
    let mut _0: bool;

    bb0: {
        switchInt(move _2) -> [45: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const true;
        goto -> bb3;
    }

    bb2: {
        _0 = Eq(_2, const '.');
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn entry_to_tests::{closure#2}(_1: {closure@core/codegen/src/bang/test_guide.rs:27:25: 27:27}) -> &str {
    let mut _0: &str;

    bb0: {
        _0 = const "invalid file name";
        return;
    }
}

fn export::_macro(_1: proc_macro::TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: syn::ItemMacro;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::ItemMacro>;
    let mut _4: std::result::Result<syn::ItemMacro, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: syn::ItemMacro;
    let mut _9: isize;
    let mut _11: devise::Diagnostic;
    let mut _12: proc_macro2::Span;
    let mut _13: &syn::ItemMacro;
    let mut _16: (std::vec::Vec<syn::Attribute>, syn::Macro);
    let mut _17: std::vec::Vec<syn::Attribute>;
    let mut _18: syn::Macro;
    let mut _20: &proc_macro2::Ident;
    let _21: &str;
    let mut _23: &proc_macro2::Ident;
    let mut _24: {closure@core/codegen/src/bang/export.rs:20:46: 20:58};
    let mut _25: &syn::Macro;
    let mut _27: &proc_macro2::TokenStream;
    let mut _29: std::iter::Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/bang/export.rs:24:14: 24:17}>;
    let mut _30: proc_macro2::token_stream::IntoIter;
    let mut _31: proc_macro2::TokenStream;
    let mut _32: proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let mut _38: proc_macro2::Delimiter;
    let mut _39: proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: &str;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let mut _46: proc_macro2::Delimiter;
    let mut _47: proc_macro2::TokenStream;
    let _49: ();
    let mut _50: &mut proc_macro2::TokenStream;
    let _51: &str;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let _56: &proc_macro2::Ident;
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let mut _60: proc_macro2::Delimiter;
    let mut _61: proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let mut _67: proc_macro2::Delimiter;
    let mut _68: proc_macro2::TokenStream;
    let _70: ();
    let mut _71: &mut proc_macro2::TokenStream;
    let _72: &str;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let mut _75: proc_macro2::Delimiter;
    let mut _76: proc_macro2::TokenStream;
    let _78: ();
    let mut _79: &mut proc_macro2::TokenStream;
    let _80: &str;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: ();
    let mut _84: &mut proc_macro2::TokenStream;
    let mut _85: proc_macro2::Delimiter;
    let mut _86: proc_macro2::TokenStream;
    let _88: ();
    let mut _89: &mut proc_macro2::TokenStream;
    let _90: &str;
    let _91: ();
    let mut _92: &mut proc_macro2::TokenStream;
    let _93: &str;
    let _94: ();
    let mut _95: &mut proc_macro2::TokenStream;
    let _96: ();
    let _97: &proc_macro2::Ident;
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: ();
    let mut _100: &mut proc_macro2::TokenStream;
    let mut _101: proc_macro2::Delimiter;
    let mut _102: proc_macro2::TokenStream;
    let _104: ();
    let _105: &proc_macro2::TokenStream;
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: &str;
    let _110: ();
    let mut _111: &mut proc_macro2::TokenStream;
    let _112: &str;
    let _113: ();
    let _114: &proc_macro2::Ident;
    let mut _115: &mut proc_macro2::TokenStream;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let mut _119: (std::slice::Iter<'_, syn::Attribute>, quote::__private::HasIterator);
    let mut _120: &std::vec::Vec<syn::Attribute>;
    let mut _122: bool;
    let mut _124: std::option::Option<&syn::Attribute>;
    let mut _125: &mut std::slice::Iter<'_, syn::Attribute>;
    let mut _126: isize;
    let _128: ();
    let _129: &quote::__private::RepInterp<&syn::Attribute>;
    let mut _130: &mut proc_macro2::TokenStream;
    let _131: ();
    let mut _132: &mut proc_macro2::TokenStream;
    let _133: ();
    let mut _134: &mut proc_macro2::TokenStream;
    let mut _135: proc_macro2::Delimiter;
    let mut _136: proc_macro2::TokenStream;
    let _138: ();
    let mut _139: &mut proc_macro2::TokenStream;
    let _140: &str;
    let _141: ();
    let mut _142: &mut proc_macro2::TokenStream;
    let mut _143: proc_macro2::Delimiter;
    let mut _144: proc_macro2::TokenStream;
    let _146: ();
    let mut _147: &mut proc_macro2::TokenStream;
    let _148: &str;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let mut _151: proc_macro2::Delimiter;
    let mut _152: proc_macro2::TokenStream;
    let _154: ();
    let mut _155: &mut proc_macro2::TokenStream;
    let _156: &str;
    let _157: ();
    let mut _158: &mut proc_macro2::TokenStream;
    let _159: ();
    let mut _160: &mut proc_macro2::TokenStream;
    let _161: &str;
    let _162: ();
    let mut _163: &mut proc_macro2::TokenStream;
    let _164: &str;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let _167: &str;
    let _168: ();
    let _169: &proc_macro2::Ident;
    let mut _170: &mut proc_macro2::TokenStream;
    let _171: ();
    let mut _172: &mut proc_macro2::TokenStream;
    let mut _173: proc_macro2::Delimiter;
    let mut _174: proc_macro2::TokenStream;
    let _176: ();
    let _177: &proc_macro2::TokenStream;
    let mut _178: &mut proc_macro2::TokenStream;
    let _179: ();
    let mut _180: &mut proc_macro2::TokenStream;
    let _181: ();
    let mut _182: &mut proc_macro2::TokenStream;
    let mut _183: proc_macro2::Delimiter;
    let mut _184: proc_macro2::TokenStream;
    let _186: ();
    let mut _187: &mut proc_macro2::TokenStream;
    let _188: &str;
    let _189: ();
    let mut _190: &mut proc_macro2::TokenStream;
    let mut _191: proc_macro2::Delimiter;
    let mut _192: proc_macro2::TokenStream;
    let _194: ();
    let mut _195: &mut proc_macro2::TokenStream;
    let _196: &str;
    let _197: ();
    let mut _198: &mut proc_macro2::TokenStream;
    let mut _199: proc_macro2::Delimiter;
    let mut _200: proc_macro2::TokenStream;
    let _202: ();
    let mut _203: &mut proc_macro2::TokenStream;
    let _204: &str;
    let _205: ();
    let mut _206: &mut proc_macro2::TokenStream;
    let mut _207: proc_macro2::Delimiter;
    let mut _208: proc_macro2::TokenStream;
    let _210: ();
    let mut _211: &mut proc_macro2::TokenStream;
    let _212: &str;
    let _213: ();
    let mut _214: &mut proc_macro2::TokenStream;
    let _215: ();
    let mut _216: &mut proc_macro2::TokenStream;
    let _217: &str;
    let _218: ();
    let mut _219: &mut proc_macro2::TokenStream;
    let _220: &str;
    let _221: ();
    let mut _222: &mut proc_macro2::TokenStream;
    let _223: &str;
    let _224: ();
    let _225: &proc_macro2::Ident;
    let mut _226: &mut proc_macro2::TokenStream;
    let _227: ();
    let mut _228: &mut proc_macro2::TokenStream;
    let _229: ();
    let _230: &proc_macro2::Ident;
    let mut _231: &mut proc_macro2::TokenStream;
    let _232: ();
    let mut _233: &mut proc_macro2::TokenStream;
    let _234: &str;
    let _235: ();
    let _236: &proc_macro2::Ident;
    let mut _237: &mut proc_macro2::TokenStream;
    let _238: ();
    let mut _239: &mut proc_macro2::TokenStream;
    let mut _240: bool;
    let mut _241: bool;
    let mut _242: bool;
    let mut _243: bool;
    let mut _244: isize;
    scope 1 {
        debug mac => _2;
        let _8: proc_macro2::Ident;
        let _10: proc_macro2::Ident;
        scope 6 {
            debug macro_name => _8;
            let _14: std::vec::Vec<syn::Attribute>;
            let _15: syn::Macro;
            scope 8 {
                debug attrs => _14;
                debug def => _15;
                let _19: proc_macro2::Ident;
                scope 9 {
                    debug internal_name => _19;
                    let _22: proc_macro2::Ident;
                    scope 10 {
                        debug mod_name => _22;
                        let _26: proc_macro2::TokenStream;
                        scope 11 {
                            debug macro_rules_tokens => _26;
                            let _28: proc_macro2::TokenStream;
                            scope 12 {
                                debug decl_macro_tokens => _28;
                                let mut _33: proc_macro2::TokenStream;
                                scope 13 {
                                    debug _s => _33;
                                    let mut _40: proc_macro2::TokenStream;
                                    let mut _62: proc_macro2::TokenStream;
                                    let mut _137: proc_macro2::TokenStream;
                                    let mut _175: proc_macro2::TokenStream;
                                    let mut _185: proc_macro2::TokenStream;
                                    scope 14 {
                                        debug _s => _40;
                                        let mut _48: proc_macro2::TokenStream;
                                        scope 15 {
                                            debug _s => _48;
                                        }
                                    }
                                    scope 16 {
                                        debug _s => _62;
                                        let mut _69: proc_macro2::TokenStream;
                                        let mut _87: proc_macro2::TokenStream;
                                        let mut _103: proc_macro2::TokenStream;
                                        scope 17 {
                                            debug _s => _69;
                                            let mut _77: proc_macro2::TokenStream;
                                            scope 18 {
                                                debug _s => _77;
                                            }
                                        }
                                        scope 19 {
                                            debug _s => _87;
                                        }
                                        scope 20 {
                                            debug _s => _103;
                                        }
                                    }
                                    scope 21 {
                                        debug has_iter => const ThereIsNoIteratorInRepetition;
                                        scope 22 {
                                            debug attrs => _118;
                                            debug i => const HasIterator;
                                            let _121: quote::__private::HasIterator;
                                            scope 24 {
                                                debug has_iter => const HasIterator;
                                                scope 25 {
                                                    let _123: quote::__private::RepInterp<&syn::Attribute>;
                                                    let _127: &syn::Attribute;
                                                    scope 26 {
                                                        debug attrs => _123;
                                                    }
                                                    scope 27 {
                                                        debug _x => _127;
                                                    }
                                                }
                                            }
                                        }
                                        scope 23 {
                                            let mut _118: std::slice::Iter<'_, syn::Attribute>;
                                        }
                                    }
                                    scope 28 {
                                        debug _s => _137;
                                        let mut _145: proc_macro2::TokenStream;
                                        scope 29 {
                                            debug _s => _145;
                                            let mut _153: proc_macro2::TokenStream;
                                            scope 30 {
                                                debug _s => _153;
                                            }
                                        }
                                    }
                                    scope 31 {
                                        debug _s => _175;
                                    }
                                    scope 32 {
                                        debug _s => _185;
                                        let mut _193: proc_macro2::TokenStream;
                                        scope 33 {
                                            debug _s => _193;
                                            let mut _201: proc_macro2::TokenStream;
                                            scope 34 {
                                                debug _s => _201;
                                                let mut _209: proc_macro2::TokenStream;
                                                scope 35 {
                                                    debug _s => _209;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 7 {
            debug ident => _10;
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _243 = const false;
        _242 = const false;
        _241 = const false;
        _240 = const false;
        _4 = syn::parse::<ItemMacro>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<ItemMacro, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: syn::ItemMacro);
        _241 = const true;
        _242 = const true;
        _243 = const true;
        _2 = move _7;
        _9 = discriminant((_2.1: std::option::Option<proc_macro2::Ident>));
        switchInt(move _9) -> [0: bb6, 1: bb7, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb102, unwind continue];
    }

    bb6: {
        _13 = &_2;
        _12 = <ItemMacro as devise::Spanned>::span(move _13) -> [return: bb8, unwind: bb139];
    }

    bb7: {
        _243 = const false;
        _10 = move (((_2.1: std::option::Option<proc_macro2::Ident>) as Some).0: proc_macro2::Ident);
        _8 = move _10;
        _242 = const false;
        _17 = move (_2.0: std::vec::Vec<syn::Attribute>);
        _241 = const false;
        _18 = move (_2.2: syn::Macro);
        _16 = (move _17, move _18);
        _14 = move (_16.0: std::vec::Vec<syn::Attribute>);
        _240 = const true;
        _15 = move (_16.1: syn::Macro);
        _20 = &_8;
        _21 = const "___internal_";
        _19 = <proc_macro2::Ident as syn_ext::IdentExt>::prepend(move _20, _21) -> [return: bb10, unwind: bb132];
    }

    bb8: {
        _11 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _12, const "expected `macro_rules!`") -> [return: bb9, unwind: bb139];
    }

    bb9: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Err(move _11);
        drop((_2.0: std::vec::Vec<syn::Attribute>)) -> [return: bb128, unwind: bb127];
    }

    bb10: {
        _23 = &_8;
        _25 = &_15;
        _24 = {closure@core/codegen/src/bang/export.rs:20:46: 20:58} { def: move _25 };
        _22 = <proc_macro2::Ident as syn_ext::IdentExt>::uniqueify_with::<{closure@core/codegen/src/bang/export.rs:20:46: 20:58}>(move _23, move _24) -> [return: bb11, unwind: bb123];
    }

    bb11: {
        _27 = &(_15.3: proc_macro2::TokenStream);
        _26 = <TokenStream2 as Clone>::clone(move _27) -> [return: bb12, unwind: bb122];
    }

    bb12: {
        _240 = const false;
        _31 = move (_15.3: proc_macro2::TokenStream);
        _30 = <TokenStream2 as IntoIterator>::into_iter(move _31) -> [return: bb13, unwind: bb121];
    }

    bb13: {
        _29 = <proc_macro2::token_stream::IntoIter as Iterator>::map::<proc_macro2::TokenTree, {closure@core/codegen/src/bang/export.rs:24:14: 24:17}>(move _30, const ZeroSized: {closure@core/codegen/src/bang/export.rs:24:14: 24:17}) -> [return: bb14, unwind: bb121];
    }

    bb14: {
        _28 = <Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/bang/export.rs:24:14: 24:17}> as Iterator>::collect::<TokenStream2>(move _29) -> [return: bb15, unwind: bb121];
    }

    bb15: {
        _33 = TokenStream2::new() -> [return: bb16, unwind: bb120];
    }

    bb16: {
        _35 = &mut _33;
        _34 = push_pound(_35) -> [return: bb17, unwind: bb119];
    }

    bb17: {
        _37 = &mut _33;
        _38 = proc_macro2::Delimiter::Bracket;
        _40 = TokenStream2::new() -> [return: bb18, unwind: bb119];
    }

    bb18: {
        _42 = &mut _40;
        _43 = const "allow";
        _41 = push_ident(_42, _43) -> [return: bb19, unwind: bb118];
    }

    bb19: {
        _45 = &mut _40;
        _46 = proc_macro2::Delimiter::Parenthesis;
        _48 = TokenStream2::new() -> [return: bb20, unwind: bb118];
    }

    bb20: {
        _50 = &mut _48;
        _51 = const "non_snake_case";
        _49 = push_ident(_50, _51) -> [return: bb21, unwind: bb117];
    }

    bb21: {
        _47 = move _48;
        _44 = push_group(_45, move _46, move _47) -> [return: bb22, unwind: bb118];
    }

    bb22: {
        _39 = move _40;
        _36 = push_group(_37, move _38, move _39) -> [return: bb23, unwind: bb119];
    }

    bb23: {
        _53 = &mut _33;
        _54 = const "mod";
        _52 = push_ident(_53, _54) -> [return: bb24, unwind: bb119];
    }

    bb24: {
        _56 = &_22;
        _57 = &mut _33;
        _55 = <proc_macro2::Ident as ToTokens>::to_tokens(_56, _57) -> [return: bb25, unwind: bb119];
    }

    bb25: {
        _59 = &mut _33;
        _60 = proc_macro2::Delimiter::Brace;
        _62 = TokenStream2::new() -> [return: bb26, unwind: bb119];
    }

    bb26: {
        _64 = &mut _62;
        _63 = push_pound(_64) -> [return: bb27, unwind: bb116];
    }

    bb27: {
        _66 = &mut _62;
        _67 = proc_macro2::Delimiter::Bracket;
        _69 = TokenStream2::new() -> [return: bb28, unwind: bb116];
    }

    bb28: {
        _71 = &mut _69;
        _72 = const "doc";
        _70 = push_ident(_71, _72) -> [return: bb29, unwind: bb115];
    }

    bb29: {
        _74 = &mut _69;
        _75 = proc_macro2::Delimiter::Parenthesis;
        _77 = TokenStream2::new() -> [return: bb30, unwind: bb115];
    }

    bb30: {
        _79 = &mut _77;
        _80 = const "hidden";
        _78 = push_ident(_79, _80) -> [return: bb31, unwind: bb114];
    }

    bb31: {
        _76 = move _77;
        _73 = push_group(_74, move _75, move _76) -> [return: bb32, unwind: bb115];
    }

    bb32: {
        _68 = move _69;
        _65 = push_group(_66, move _67, move _68) -> [return: bb33, unwind: bb116];
    }

    bb33: {
        _82 = &mut _62;
        _81 = push_pound(_82) -> [return: bb34, unwind: bb116];
    }

    bb34: {
        _84 = &mut _62;
        _85 = proc_macro2::Delimiter::Bracket;
        _87 = TokenStream2::new() -> [return: bb35, unwind: bb116];
    }

    bb35: {
        _89 = &mut _87;
        _90 = const "macro_export";
        _88 = push_ident(_89, _90) -> [return: bb36, unwind: bb113];
    }

    bb36: {
        _86 = move _87;
        _83 = push_group(_84, move _85, move _86) -> [return: bb37, unwind: bb116];
    }

    bb37: {
        _92 = &mut _62;
        _93 = const "macro_rules";
        _91 = push_ident(_92, _93) -> [return: bb38, unwind: bb116];
    }

    bb38: {
        _95 = &mut _62;
        _94 = push_bang(_95) -> [return: bb39, unwind: bb116];
    }

    bb39: {
        _97 = &_19;
        _98 = &mut _62;
        _96 = <proc_macro2::Ident as ToTokens>::to_tokens(_97, _98) -> [return: bb40, unwind: bb116];
    }

    bb40: {
        _100 = &mut _62;
        _101 = proc_macro2::Delimiter::Brace;
        _103 = TokenStream2::new() -> [return: bb41, unwind: bb116];
    }

    bb41: {
        _105 = &_26;
        _106 = &mut _103;
        _104 = <TokenStream2 as ToTokens>::to_tokens(_105, _106) -> [return: bb42, unwind: bb112];
    }

    bb42: {
        _102 = move _103;
        _99 = push_group(_100, move _101, move _102) -> [return: bb43, unwind: bb116];
    }

    bb43: {
        _108 = &mut _62;
        _109 = const "pub";
        _107 = push_ident(_108, _109) -> [return: bb44, unwind: bb116];
    }

    bb44: {
        _111 = &mut _62;
        _112 = const "use";
        _110 = push_ident(_111, _112) -> [return: bb45, unwind: bb116];
    }

    bb45: {
        _114 = &_19;
        _115 = &mut _62;
        _113 = <proc_macro2::Ident as ToTokens>::to_tokens(_114, _115) -> [return: bb46, unwind: bb116];
    }

    bb46: {
        _117 = &mut _62;
        _116 = push_semi(_117) -> [return: bb47, unwind: bb116];
    }

    bb47: {
        _61 = move _62;
        _58 = push_group(_59, move _60, move _61) -> [return: bb48, unwind: bb119];
    }

    bb48: {
        _120 = &_14;
        _119 = <Vec<syn::Attribute> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _120) -> [return: bb49, unwind: bb119];
    }

    bb49: {
        _118 = move (_119.0: std::slice::Iter<'_, syn::Attribute>);
        _121 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb140, unwind: bb119];
    }

    bb50: {
        _122 = const true;
        switchInt(move _122) -> [0: bb54, otherwise: bb51];
    }

    bb51: {
        _125 = &mut _118;
        _124 = <std::slice::Iter<'_, syn::Attribute> as Iterator>::next(move _125) -> [return: bb52, unwind: bb119];
    }

    bb52: {
        _126 = discriminant(_124);
        switchInt(move _126) -> [0: bb54, 1: bb53, otherwise: bb4];
    }

    bb53: {
        _127 = ((_124 as Some).0: &syn::Attribute);
        _123 = RepInterp::<&syn::Attribute>(_127);
        _129 = &_123;
        _130 = &mut _33;
        _128 = <RepInterp<&syn::Attribute> as ToTokens>::to_tokens(_129, _130) -> [return: bb141, unwind: bb119];
    }

    bb54: {
        _132 = &mut _33;
        _131 = push_pound(_132) -> [return: bb55, unwind: bb119];
    }

    bb55: {
        _134 = &mut _33;
        _135 = proc_macro2::Delimiter::Bracket;
        _137 = TokenStream2::new() -> [return: bb56, unwind: bb119];
    }

    bb56: {
        _139 = &mut _137;
        _140 = const "cfg";
        _138 = push_ident(_139, _140) -> [return: bb57, unwind: bb111];
    }

    bb57: {
        _142 = &mut _137;
        _143 = proc_macro2::Delimiter::Parenthesis;
        _145 = TokenStream2::new() -> [return: bb58, unwind: bb111];
    }

    bb58: {
        _147 = &mut _145;
        _148 = const "all";
        _146 = push_ident(_147, _148) -> [return: bb59, unwind: bb110];
    }

    bb59: {
        _150 = &mut _145;
        _151 = proc_macro2::Delimiter::Parenthesis;
        _153 = TokenStream2::new() -> [return: bb60, unwind: bb110];
    }

    bb60: {
        _155 = &mut _153;
        _156 = const "nightly";
        _154 = push_ident(_155, _156) -> [return: bb61, unwind: bb109];
    }

    bb61: {
        _158 = &mut _153;
        _157 = push_comma(_158) -> [return: bb62, unwind: bb109];
    }

    bb62: {
        _160 = &mut _153;
        _161 = const "doc";
        _159 = push_ident(_160, _161) -> [return: bb63, unwind: bb109];
    }

    bb63: {
        _152 = move _153;
        _149 = push_group(_150, move _151, move _152) -> [return: bb64, unwind: bb110];
    }

    bb64: {
        _144 = move _145;
        _141 = push_group(_142, move _143, move _144) -> [return: bb65, unwind: bb111];
    }

    bb65: {
        _136 = move _137;
        _133 = push_group(_134, move _135, move _136) -> [return: bb66, unwind: bb119];
    }

    bb66: {
        _163 = &mut _33;
        _164 = const "pub";
        _162 = push_ident(_163, _164) -> [return: bb67, unwind: bb119];
    }

    bb67: {
        _166 = &mut _33;
        _167 = const "macro";
        _165 = push_ident(_166, _167) -> [return: bb68, unwind: bb119];
    }

    bb68: {
        _169 = &_8;
        _170 = &mut _33;
        _168 = <proc_macro2::Ident as ToTokens>::to_tokens(_169, _170) -> [return: bb69, unwind: bb119];
    }

    bb69: {
        _172 = &mut _33;
        _173 = proc_macro2::Delimiter::Brace;
        _175 = TokenStream2::new() -> [return: bb70, unwind: bb119];
    }

    bb70: {
        _177 = &_28;
        _178 = &mut _175;
        _176 = <TokenStream2 as ToTokens>::to_tokens(_177, _178) -> [return: bb71, unwind: bb108];
    }

    bb71: {
        _174 = move _175;
        _171 = push_group(_172, move _173, move _174) -> [return: bb72, unwind: bb119];
    }

    bb72: {
        _180 = &mut _33;
        _179 = push_pound(_180) -> [return: bb73, unwind: bb119];
    }

    bb73: {
        _182 = &mut _33;
        _183 = proc_macro2::Delimiter::Bracket;
        _185 = TokenStream2::new() -> [return: bb74, unwind: bb119];
    }

    bb74: {
        _187 = &mut _185;
        _188 = const "cfg";
        _186 = push_ident(_187, _188) -> [return: bb75, unwind: bb107];
    }

    bb75: {
        _190 = &mut _185;
        _191 = proc_macro2::Delimiter::Parenthesis;
        _193 = TokenStream2::new() -> [return: bb76, unwind: bb107];
    }

    bb76: {
        _195 = &mut _193;
        _196 = const "not";
        _194 = push_ident(_195, _196) -> [return: bb77, unwind: bb106];
    }

    bb77: {
        _198 = &mut _193;
        _199 = proc_macro2::Delimiter::Parenthesis;
        _201 = TokenStream2::new() -> [return: bb78, unwind: bb106];
    }

    bb78: {
        _203 = &mut _201;
        _204 = const "all";
        _202 = push_ident(_203, _204) -> [return: bb79, unwind: bb105];
    }

    bb79: {
        _206 = &mut _201;
        _207 = proc_macro2::Delimiter::Parenthesis;
        _209 = TokenStream2::new() -> [return: bb80, unwind: bb105];
    }

    bb80: {
        _211 = &mut _209;
        _212 = const "nightly";
        _210 = push_ident(_211, _212) -> [return: bb81, unwind: bb104];
    }

    bb81: {
        _214 = &mut _209;
        _213 = push_comma(_214) -> [return: bb82, unwind: bb104];
    }

    bb82: {
        _216 = &mut _209;
        _217 = const "doc";
        _215 = push_ident(_216, _217) -> [return: bb83, unwind: bb104];
    }

    bb83: {
        _208 = move _209;
        _205 = push_group(_206, move _207, move _208) -> [return: bb84, unwind: bb105];
    }

    bb84: {
        _200 = move _201;
        _197 = push_group(_198, move _199, move _200) -> [return: bb85, unwind: bb106];
    }

    bb85: {
        _192 = move _193;
        _189 = push_group(_190, move _191, move _192) -> [return: bb86, unwind: bb107];
    }

    bb86: {
        _184 = move _185;
        _181 = push_group(_182, move _183, move _184) -> [return: bb87, unwind: bb119];
    }

    bb87: {
        _219 = &mut _33;
        _220 = const "pub";
        _218 = push_ident(_219, _220) -> [return: bb88, unwind: bb119];
    }

    bb88: {
        _222 = &mut _33;
        _223 = const "use";
        _221 = push_ident(_222, _223) -> [return: bb89, unwind: bb119];
    }

    bb89: {
        _225 = &_22;
        _226 = &mut _33;
        _224 = <proc_macro2::Ident as ToTokens>::to_tokens(_225, _226) -> [return: bb90, unwind: bb119];
    }

    bb90: {
        _228 = &mut _33;
        _227 = push_colon2(_228) -> [return: bb91, unwind: bb119];
    }

    bb91: {
        _230 = &_19;
        _231 = &mut _33;
        _229 = <proc_macro2::Ident as ToTokens>::to_tokens(_230, _231) -> [return: bb92, unwind: bb119];
    }

    bb92: {
        _233 = &mut _33;
        _234 = const "as";
        _232 = push_ident(_233, _234) -> [return: bb93, unwind: bb119];
    }

    bb93: {
        _236 = &_8;
        _237 = &mut _33;
        _235 = <proc_macro2::Ident as ToTokens>::to_tokens(_236, _237) -> [return: bb94, unwind: bb119];
    }

    bb94: {
        _239 = &mut _33;
        _238 = push_semi(_239) -> [return: bb95, unwind: bb119];
    }

    bb95: {
        _32 = move _33;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _32);
        drop(_28) -> [return: bb96, unwind: bb121];
    }

    bb96: {
        drop(_26) -> [return: bb97, unwind: bb122];
    }

    bb97: {
        drop(_22) -> [return: bb98, unwind: bb123];
    }

    bb98: {
        drop(_19) -> [return: bb99, unwind: bb132];
    }

    bb99: {
        drop((_15.0: syn::Path)) -> [return: bb129, unwind: bb124];
    }

    bb100: {
        drop(_8) -> [return: bb101, unwind: bb139];
    }

    bb101: {
        _241 = const false;
        _242 = const false;
        _243 = const false;
        goto -> bb103;
    }

    bb102: {
        _241 = const false;
        _242 = const false;
        _243 = const false;
        goto -> bb103;
    }

    bb103: {
        return;
    }

    bb104 (cleanup): {
        drop(_209) -> [return: bb105, unwind terminate(cleanup)];
    }

    bb105 (cleanup): {
        drop(_201) -> [return: bb106, unwind terminate(cleanup)];
    }

    bb106 (cleanup): {
        drop(_193) -> [return: bb107, unwind terminate(cleanup)];
    }

    bb107 (cleanup): {
        drop(_185) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb108 (cleanup): {
        drop(_175) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb109 (cleanup): {
        drop(_153) -> [return: bb110, unwind terminate(cleanup)];
    }

    bb110 (cleanup): {
        drop(_145) -> [return: bb111, unwind terminate(cleanup)];
    }

    bb111 (cleanup): {
        drop(_137) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb112 (cleanup): {
        drop(_103) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb113 (cleanup): {
        drop(_87) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb114 (cleanup): {
        drop(_77) -> [return: bb115, unwind terminate(cleanup)];
    }

    bb115 (cleanup): {
        drop(_69) -> [return: bb116, unwind terminate(cleanup)];
    }

    bb116 (cleanup): {
        drop(_62) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb117 (cleanup): {
        drop(_48) -> [return: bb118, unwind terminate(cleanup)];
    }

    bb118 (cleanup): {
        drop(_40) -> [return: bb119, unwind terminate(cleanup)];
    }

    bb119 (cleanup): {
        drop(_33) -> [return: bb120, unwind terminate(cleanup)];
    }

    bb120 (cleanup): {
        drop(_28) -> [return: bb121, unwind terminate(cleanup)];
    }

    bb121 (cleanup): {
        drop(_26) -> [return: bb122, unwind terminate(cleanup)];
    }

    bb122 (cleanup): {
        drop(_22) -> [return: bb123, unwind terminate(cleanup)];
    }

    bb123 (cleanup): {
        drop(_19) -> [return: bb132, unwind terminate(cleanup)];
    }

    bb124 (cleanup): {
        drop(_14) -> [return: bb125, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        drop(_8) -> [return: bb139, unwind terminate(cleanup)];
    }

    bb126 (cleanup): {
        resume;
    }

    bb127 (cleanup): {
        drop((_2.2: syn::Macro)) -> [return: bb126, unwind terminate(cleanup)];
    }

    bb128: {
        drop((_2.2: syn::Macro)) -> [return: bb102, unwind continue];
    }

    bb129: {
        _240 = const false;
        drop(_14) -> [return: bb100, unwind: bb125];
    }

    bb130 (cleanup): {
        switchInt(_240) -> [0: bb124, otherwise: bb131];
    }

    bb131 (cleanup): {
        drop((_15.3: proc_macro2::TokenStream)) -> [return: bb124, unwind terminate(cleanup)];
    }

    bb132 (cleanup): {
        drop((_15.0: syn::Path)) -> [return: bb130, unwind terminate(cleanup)];
    }

    bb133 (cleanup): {
        switchInt(_241) -> [0: bb126, otherwise: bb134];
    }

    bb134 (cleanup): {
        drop((_2.2: syn::Macro)) -> [return: bb126, unwind terminate(cleanup)];
    }

    bb135 (cleanup): {
        _244 = discriminant((_2.1: std::option::Option<proc_macro2::Ident>));
        switchInt(move _244) -> [1: bb136, otherwise: bb133];
    }

    bb136 (cleanup): {
        switchInt(_243) -> [0: bb133, otherwise: bb137];
    }

    bb137 (cleanup): {
        drop((((_2.1: std::option::Option<proc_macro2::Ident>) as Some).0: proc_macro2::Ident)) -> [return: bb133, unwind terminate(cleanup)];
    }

    bb138 (cleanup): {
        drop((_2.0: std::vec::Vec<syn::Attribute>)) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb139 (cleanup): {
        switchInt(_242) -> [0: bb135, otherwise: bb138];
    }

    bb140: {
        goto -> bb50;
    }

    bb141: {
        goto -> bb50;
    }
}

fn export::_macro::{closure#0}(_1: &mut {closure@core/codegen/src/bang/export.rs:20:46: 20:58}, _2: &mut dyn Hasher) -> () {
    debug hasher => _2;
    debug def => (*((*_1).0: &syn::Macro));
    let mut _0: ();
    let mut _3: &mut &mut dyn std::hash::Hasher;
    let mut _4: &syn::Macro;

    bb0: {
        _4 = deref_copy ((*_1).0: &syn::Macro);
        _3 = &mut _2;
        _0 = <syn::Macro as Hash>::hash::<&mut dyn Hasher>(_4, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn export::_macro::{closure#1}(_1: &mut {closure@core/codegen/src/bang/export.rs:24:14: 24:17}, _2: proc_macro2::TokenTree) -> proc_macro2::TokenTree {
    debug t => _2;
    let mut _0: proc_macro2::TokenTree;
    let mut _3: isize;
    let _4: proc_macro2::Punct;
    let _5: &proc_macro2::Punct;
    let mut _6: char;
    let mut _8: proc_macro2::Spacing;
    let mut _9: &proc_macro2::Punct;
    let _10: ();
    let mut _11: &mut proc_macro2::Punct;
    let mut _12: proc_macro2::Span;
    let mut _13: &proc_macro2::Punct;
    let mut _14: proc_macro2::Punct;
    let mut _15: bool;
    let mut _16: isize;
    scope 1 {
        debug p => _4;
        debug p => _5;
        let mut _7: proc_macro2::Punct;
        scope 2 {
            debug token => _7;
        }
    }

    bb0: {
        _15 = const false;
        _15 = const true;
        _3 = discriminant(_2);
        switchInt(move _3) -> [2: bb2, otherwise: bb1];
    }

    bb1: {
        _15 = const false;
        _0 = move _2;
        goto -> bb14;
    }

    bb2: {
        _5 = &((_2 as Punct).0: proc_macro2::Punct);
        _6 = proc_macro2::Punct::as_char(_5) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        switchInt(move _6) -> [59: bb4, otherwise: bb1];
    }

    bb4: {
        _4 = move ((_2 as Punct).0: proc_macro2::Punct);
        _9 = &_4;
        _8 = proc_macro2::Punct::spacing(move _9) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _7 = proc_macro2::Punct::new(const ',', move _8) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _11 = &mut _7;
        _13 = &_4;
        _12 = proc_macro2::Punct::span(move _13) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _10 = proc_macro2::Punct::set_span(move _11, move _12) -> [return: bb8, unwind: bb9];
    }

    bb8: {
        _14 = move _7;
        _0 = proc_macro2::TokenTree::Punct(move _14);
        goto -> bb14;
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        _15 = const false;
        return;
    }

    bb12: {
        drop(_2) -> [return: bb11, unwind continue];
    }

    bb13: {
        _16 = discriminant(_2);
        switchInt(move _16) -> [2: bb11, otherwise: bb12];
    }

    bb14: {
        switchInt(_15) -> [0: bb11, otherwise: bb13];
    }
}

fn typed_stream::<impl at core/codegen/src/bang/typed_stream.rs:16:1: 16:26>::parse(_1: &ParseBuffer<'_>) -> std::result::Result<Invocation, syn::Error> {
    debug input => _1;
    let mut _0: std::result::Result<bang::typed_stream::Invocation, syn::Error>;
    let _2: syn::Path;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::Path>;
    let mut _4: std::result::Result<syn::Path, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: syn::Path;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Comma>;
    let mut _9: std::result::Result<syn::token::Comma, syn::Error>;
    let mut _10: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::Path>;
    let mut _15: std::result::Result<syn::Path, syn::Error>;
    let mut _16: isize;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Comma>;
    let mut _20: std::result::Result<syn::token::Comma, syn::Error>;
    let mut _21: isize;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::Path>;
    let mut _26: std::result::Result<syn::Path, syn::Error>;
    let mut _27: isize;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::token::Comma>;
    let mut _31: std::result::Result<syn::token::Comma, syn::Error>;
    let mut _32: isize;
    let mut _37: std::result::Result<syn::Type, syn::Error>;
    let mut _38: &syn::parse::ParseBuffer<'_>;
    let mut _39: isize;
    let _41: ();
    let _42: &syn::parse::ParseBuffer<'_>;
    let mut _43: syn::Type;
    let mut _44: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, proc_macro2::TokenStream>;
    let mut _45: std::result::Result<proc_macro2::TokenStream, syn::Error>;
    let mut _46: isize;
    let mut _49: bang::typed_stream::Invocation;
    let mut _50: syn::Path;
    let mut _51: syn::Path;
    let mut _52: syn::Path;
    let mut _53: bang::typed_stream::Input;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: bool;
    let mut _57: isize;
    let mut _58: isize;
    let mut _59: isize;
    scope 1 {
        debug ty_stream_ty => _2;
        let _11: std::result::Result<std::convert::Infallible, syn::Error>;
        let _12: syn::token::Comma;
        let _13: syn::Path;
        let _17: std::result::Result<std::convert::Infallible, syn::Error>;
        let _18: syn::Path;
        scope 6 {
            debug residual => _11;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _12;
            scope 9 {
            }
        }
        scope 10 {
            debug stream_mac => _13;
            let _22: std::result::Result<std::convert::Infallible, syn::Error>;
            let _23: syn::token::Comma;
            let _24: syn::Path;
            let _28: std::result::Result<std::convert::Infallible, syn::Error>;
            let _29: syn::Path;
            scope 15 {
                debug residual => _22;
                scope 16 {
                }
            }
            scope 17 {
                debug val => _23;
                scope 18 {
                }
            }
            scope 19 {
                debug stream_trait => _24;
                let _33: std::result::Result<std::convert::Infallible, syn::Error>;
                let _34: syn::token::Comma;
                let _35: syn::parse::ParseBuffer<'_>;
                scope 24 {
                    debug residual => _33;
                    scope 25 {
                    }
                }
                scope 26 {
                    debug val => _34;
                    scope 27 {
                    }
                }
                scope 28 {
                    debug fork => _35;
                    let _36: bang::typed_stream::Input;
                    let _40: syn::Type;
                    let _47: std::result::Result<std::convert::Infallible, syn::Error>;
                    let _48: proc_macro2::TokenStream;
                    scope 29 {
                        debug input => _36;
                    }
                    scope 30 {
                        debug ty => _40;
                    }
                    scope 31 {
                        debug residual => _47;
                        scope 32 {
                        }
                    }
                    scope 33 {
                        debug val => _48;
                        scope 34 {
                        }
                    }
                }
            }
            scope 20 {
                debug residual => _28;
                scope 21 {
                }
            }
            scope 22 {
                debug val => _29;
                scope 23 {
                }
            }
        }
        scope 11 {
            debug residual => _17;
            scope 12 {
            }
        }
        scope 13 {
            debug val => _18;
            scope 14 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _56 = const false;
        _55 = const false;
        _54 = const false;
        _4 = ParseBuffer::<'_>::parse::<syn::Path>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<syn::Path, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: syn::Path);
        _56 = const true;
        _2 = move _7;
        _9 = ParseBuffer::<'_>::parse::<syn::token::Comma>(_1) -> [return: bb6, unwind: bb60];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb42, unwind continue];
    }

    bb6: {
        _8 = <std::result::Result<syn::token::Comma, syn::Error> as std::ops::Try>::branch(move _9) -> [return: bb7, unwind: bb60];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: syn::token::Comma);
        _15 = ParseBuffer::<'_>::parse::<syn::Path>(_1) -> [return: bb10, unwind: bb60];
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _11) -> [return: bb61, unwind: bb60];
    }

    bb10: {
        _14 = <std::result::Result<syn::Path, syn::Error> as std::ops::Try>::branch(move _15) -> [return: bb11, unwind: bb60];
    }

    bb11: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _18 = move ((_14 as Continue).0: syn::Path);
        _55 = const true;
        _13 = move _18;
        _20 = ParseBuffer::<'_>::parse::<syn::token::Comma>(_1) -> [return: bb14, unwind: bb58];
    }

    bb13: {
        _17 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _17) -> [return: bb62, unwind: bb60];
    }

    bb14: {
        _19 = <std::result::Result<syn::token::Comma, syn::Error> as std::ops::Try>::branch(move _20) -> [return: bb15, unwind: bb58];
    }

    bb15: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb16, 1: bb17, otherwise: bb4];
    }

    bb16: {
        _23 = ((_19 as Continue).0: syn::token::Comma);
        _26 = ParseBuffer::<'_>::parse::<syn::Path>(_1) -> [return: bb18, unwind: bb58];
    }

    bb17: {
        _22 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _22) -> [return: bb63, unwind: bb58];
    }

    bb18: {
        _25 = <std::result::Result<syn::Path, syn::Error> as std::ops::Try>::branch(move _26) -> [return: bb19, unwind: bb58];
    }

    bb19: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb20, 1: bb21, otherwise: bb4];
    }

    bb20: {
        _29 = move ((_25 as Continue).0: syn::Path);
        _54 = const true;
        _24 = move _29;
        _31 = ParseBuffer::<'_>::parse::<syn::token::Comma>(_1) -> [return: bb22, unwind: bb56];
    }

    bb21: {
        _28 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _28) -> [return: bb64, unwind: bb58];
    }

    bb22: {
        _30 = <std::result::Result<syn::token::Comma, syn::Error> as std::ops::Try>::branch(move _31) -> [return: bb23, unwind: bb56];
    }

    bb23: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb24, 1: bb25, otherwise: bb4];
    }

    bb24: {
        _34 = ((_30 as Continue).0: syn::token::Comma);
        _35 = ParseBuffer::<'_>::fork(_1) -> [return: bb26, unwind: bb56];
    }

    bb25: {
        _33 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _33) -> [return: bb65, unwind: bb56];
    }

    bb26: {
        _38 = &_35;
        _37 = ParseBuffer::<'_>::parse::<syn::Type>(move _38) -> [return: bb27, unwind: bb46];
    }

    bb27: {
        _39 = discriminant(_37);
        switchInt(move _39) -> [0: bb29, 1: bb28, otherwise: bb4];
    }

    bb28: {
        _45 = ParseBuffer::<'_>::parse::<TokenStream2>(_1) -> [return: bb31, unwind: bb54];
    }

    bb29: {
        _40 = move ((_37 as Ok).0: syn::Type);
        _42 = &_35;
        _41 = <ParseBuffer<'_> as Speculative>::advance_to(_1, _42) -> [return: bb30, unwind: bb45];
    }

    bb30: {
        _43 = move _40;
        _36 = typed_stream::Input::Type(move _43);
        goto -> bb50;
    }

    bb31: {
        _44 = <std::result::Result<TokenStream2, syn::Error> as std::ops::Try>::branch(move _45) -> [return: bb32, unwind: bb54];
    }

    bb32: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb33, 1: bb34, otherwise: bb4];
    }

    bb33: {
        _48 = move ((_44 as Continue).0: proc_macro2::TokenStream);
        _36 = typed_stream::Input::Tokens(move _48);
        goto -> bb50;
    }

    bb34: {
        _47 = move ((_44 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<Invocation, syn::Error> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _47) -> [return: bb35, unwind: bb54];
    }

    bb35: {
        _58 = discriminant(_37);
        switchInt(move _58) -> [0: bb51, otherwise: bb52];
    }

    bb36: {
        _54 = const false;
        _55 = const false;
        _56 = const false;
        goto -> bb43;
    }

    bb37: {
        drop(_24) -> [return: bb38, unwind: bb58];
    }

    bb38: {
        _54 = const false;
        goto -> bb39;
    }

    bb39: {
        drop(_13) -> [return: bb40, unwind: bb60];
    }

    bb40: {
        _55 = const false;
        goto -> bb41;
    }

    bb41: {
        drop(_2) -> [return: bb42, unwind continue];
    }

    bb42: {
        _56 = const false;
        goto -> bb43;
    }

    bb43: {
        return;
    }

    bb44 (cleanup): {
        drop(_36) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_40) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_35) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }

    bb48: {
        _56 = const false;
        _50 = move _2;
        _55 = const false;
        _51 = move _13;
        _54 = const false;
        _52 = move _24;
        _53 = move _36;
        _49 = Invocation { ty_stream_ty: move _50, stream_mac: move _51, stream_trait: move _52, input: move _53 };
        _0 = std::result::Result::<Invocation, syn::Error>::Ok(move _49);
        drop(_35) -> [return: bb36, unwind: bb56];
    }

    bb49: {
        drop(_37) -> [return: bb48, unwind: bb44];
    }

    bb50: {
        _57 = discriminant(_37);
        switchInt(move _57) -> [0: bb48, otherwise: bb49];
    }

    bb51: {
        drop(_35) -> [return: bb37, unwind: bb56];
    }

    bb52: {
        drop(_37) -> [return: bb51, unwind: bb46];
    }

    bb53 (cleanup): {
        drop(_37) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        _59 = discriminant(_37);
        switchInt(move _59) -> [0: bb46, otherwise: bb53];
    }

    bb55 (cleanup): {
        drop(_24) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        switchInt(_54) -> [0: bb58, otherwise: bb55];
    }

    bb57 (cleanup): {
        drop(_13) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        switchInt(_55) -> [0: bb60, otherwise: bb57];
    }

    bb59 (cleanup): {
        drop(_2) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        switchInt(_56) -> [0: bb47, otherwise: bb59];
    }

    bb61: {
        goto -> bb41;
    }

    bb62: {
        goto -> bb40;
    }

    bb63: {
        goto -> bb39;
    }

    bb64: {
        goto -> bb38;
    }

    bb65: {
        goto -> bb37;
    }
}

fn typed_stream::_macro(_1: proc_macro::TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _2: bang::typed_stream::Invocation;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, bang::typed_stream::Invocation>;
    let mut _4: std::result::Result<bang::typed_stream::Invocation, syn::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, syn::Error>;
    let _7: bang::typed_stream::Invocation;
    let mut _11: (syn::Path, syn::Path, syn::Path);
    let mut _12: syn::Path;
    let mut _13: syn::Path;
    let mut _14: syn::Path;
    let mut _16: isize;
    let _19: ();
    let _20: &syn::Path;
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: &str;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let mut _29: proc_macro2::Delimiter;
    let mut _30: proc_macro2::TokenStream;
    let _32: ();
    let _33: &syn::Path;
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let mut _39: proc_macro2::Delimiter;
    let mut _40: proc_macro2::TokenStream;
    let _42: ();
    let _43: &proc_macro2::TokenStream;
    let mut _44: &mut proc_macro2::TokenStream;
    let _47: ();
    let _48: &syn::Path;
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: &str;
    let _55: ();
    let _56: &syn::Path;
    let mut _57: &mut proc_macro2::TokenStream;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: &str;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let _66: &syn::Type;
    let mut _67: &mut proc_macro2::TokenStream;
    let _68: ();
    let mut _69: &mut proc_macro2::TokenStream;
    let mut _70: proc_macro2::TokenStream;
    let mut _71: bool;
    let mut _72: bool;
    let mut _73: bool;
    let mut _74: bool;
    let mut _75: bool;
    let mut _76: isize;
    scope 1 {
        debug i => _2;
        let _8: syn::Path;
        let _9: syn::Path;
        let _10: syn::Path;
        scope 6 {
            debug s_ty => _8;
            debug mac => _9;
            debug s_trait => _10;
            let _15: proc_macro2::TokenStream;
            let _17: proc_macro2::TokenStream;
            let _45: syn::Type;
            scope 7 {
                debug tokens => _15;
            }
            scope 8 {
                debug tt => _17;
                let mut _18: proc_macro2::TokenStream;
                scope 9 {
                    debug _s => _18;
                    let mut _31: proc_macro2::TokenStream;
                    scope 10 {
                        debug _s => _31;
                        let mut _41: proc_macro2::TokenStream;
                        scope 11 {
                            debug _s => _41;
                        }
                    }
                }
            }
            scope 12 {
                debug ty => _45;
                let mut _46: proc_macro2::TokenStream;
                scope 13 {
                    debug _s => _46;
                }
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _75 = const false;
        _74 = const false;
        _73 = const false;
        _72 = const false;
        _71 = const false;
        _4 = syn::parse::<Invocation>(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Invocation, syn::Error> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: bang::typed_stream::Invocation);
        _71 = const true;
        _72 = const true;
        _73 = const true;
        _74 = const true;
        _75 = const true;
        _2 = move _7;
        _75 = const false;
        _12 = move (_2.0: syn::Path);
        _74 = const false;
        _13 = move (_2.1: syn::Path);
        _73 = const false;
        _14 = move (_2.2: syn::Path);
        _11 = (move _12, move _13, move _14);
        _8 = move (_11.0: syn::Path);
        _9 = move (_11.1: syn::Path);
        _10 = move (_11.2: syn::Path);
        _16 = discriminant((_2.3: bang::typed_stream::Input));
        switchInt(move _16) -> [0: bb7, 1: bb8, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _71 = const false;
        _72 = const false;
        _73 = const false;
        _74 = const false;
        _75 = const false;
        goto -> bb34;
    }

    bb7: {
        _72 = const false;
        _45 = move (((_2.3: bang::typed_stream::Input) as Type).0: syn::Type);
        _46 = TokenStream2::new() -> [return: bb20, unwind: bb36];
    }

    bb8: {
        _71 = const false;
        _17 = move (((_2.3: bang::typed_stream::Input) as Tokens).0: proc_macro2::TokenStream);
        _18 = TokenStream2::new() -> [return: bb9, unwind: bb40];
    }

    bb9: {
        _20 = &_8;
        _21 = &mut _18;
        _19 = <syn::Path as ToTokens>::to_tokens(_20, _21) -> [return: bb10, unwind: bb39];
    }

    bb10: {
        _23 = &mut _18;
        _22 = push_colon2(_23) -> [return: bb11, unwind: bb39];
    }

    bb11: {
        _25 = &mut _18;
        _26 = const "from";
        _24 = push_ident(_25, _26) -> [return: bb12, unwind: bb39];
    }

    bb12: {
        _28 = &mut _18;
        _29 = proc_macro2::Delimiter::Parenthesis;
        _31 = TokenStream2::new() -> [return: bb13, unwind: bb39];
    }

    bb13: {
        _33 = &_9;
        _34 = &mut _31;
        _32 = <syn::Path as ToTokens>::to_tokens(_33, _34) -> [return: bb14, unwind: bb38];
    }

    bb14: {
        _36 = &mut _31;
        _35 = push_bang(_36) -> [return: bb15, unwind: bb38];
    }

    bb15: {
        _38 = &mut _31;
        _39 = proc_macro2::Delimiter::Parenthesis;
        _41 = TokenStream2::new() -> [return: bb16, unwind: bb38];
    }

    bb16: {
        _43 = &_17;
        _44 = &mut _41;
        _42 = <TokenStream2 as ToTokens>::to_tokens(_43, _44) -> [return: bb17, unwind: bb37];
    }

    bb17: {
        _40 = move _41;
        _37 = push_group(_38, move _39, move _40) -> [return: bb18, unwind: bb38];
    }

    bb18: {
        _30 = move _31;
        _27 = push_group(_28, move _29, move _30) -> [return: bb19, unwind: bb39];
    }

    bb19: {
        _15 = move _18;
        drop(_17) -> [return: bb30, unwind: bb41];
    }

    bb20: {
        _48 = &_8;
        _49 = &mut _46;
        _47 = <syn::Path as ToTokens>::to_tokens(_48, _49) -> [return: bb21, unwind: bb35];
    }

    bb21: {
        _51 = &mut _46;
        _50 = push_lt(_51) -> [return: bb22, unwind: bb35];
    }

    bb22: {
        _53 = &mut _46;
        _54 = const "impl";
        _52 = push_ident(_53, _54) -> [return: bb23, unwind: bb35];
    }

    bb23: {
        _56 = &_10;
        _57 = &mut _46;
        _55 = <syn::Path as ToTokens>::to_tokens(_56, _57) -> [return: bb24, unwind: bb35];
    }

    bb24: {
        _59 = &mut _46;
        _58 = push_lt(_59) -> [return: bb25, unwind: bb35];
    }

    bb25: {
        _61 = &mut _46;
        _62 = const "Item";
        _60 = push_ident(_61, _62) -> [return: bb26, unwind: bb35];
    }

    bb26: {
        _64 = &mut _46;
        _63 = push_eq(_64) -> [return: bb27, unwind: bb35];
    }

    bb27: {
        _66 = &_45;
        _67 = &mut _46;
        _65 = <syn::Type as ToTokens>::to_tokens(_66, _67) -> [return: bb28, unwind: bb35];
    }

    bb28: {
        _69 = &mut _46;
        _68 = push_shr(_69) -> [return: bb29, unwind: bb35];
    }

    bb29: {
        _15 = move _46;
        drop(_45) -> [return: bb30, unwind: bb41];
    }

    bb30: {
        _70 = move _15;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _70);
        drop(_10) -> [return: bb31, unwind: bb42];
    }

    bb31: {
        drop(_9) -> [return: bb32, unwind: bb43];
    }

    bb32: {
        drop(_8) -> [return: bb33, unwind: bb55];
    }

    bb33: {
        _71 = const false;
        _72 = const false;
        _73 = const false;
        _74 = const false;
        _75 = const false;
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35 (cleanup): {
        drop(_46) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_45) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_41) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_31) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_18) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_17) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_10) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_9) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_8) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        resume;
    }

    bb45 (cleanup): {
        _76 = discriminant((_2.3: bang::typed_stream::Input));
        switchInt(move _76) -> [0: bb46, otherwise: bb48];
    }

    bb46 (cleanup): {
        switchInt(_72) -> [0: bb44, otherwise: bb47];
    }

    bb47 (cleanup): {
        drop((((_2.3: bang::typed_stream::Input) as Type).0: syn::Type)) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_71) -> [0: bb44, otherwise: bb49];
    }

    bb49 (cleanup): {
        drop((((_2.3: bang::typed_stream::Input) as Tokens).0: proc_macro2::TokenStream)) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        switchInt(_73) -> [0: bb45, otherwise: bb51];
    }

    bb51 (cleanup): {
        drop((_2.2: syn::Path)) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        switchInt(_74) -> [0: bb50, otherwise: bb53];
    }

    bb53 (cleanup): {
        drop((_2.1: syn::Path)) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop((_2.0: syn::Path)) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        switchInt(_75) -> [0: bb52, otherwise: bb54];
    }
}

fn struct_maker_vec(_1: proc_macro::TokenStream, _2: TokenStream2, _3: impl Fn(TokenStream) -> TokenStream) -> std::result::Result<TokenStream2, devise::Diagnostic> {
    debug input => _1;
    debug ty => _2;
    debug map => _3;
    let mut _0: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let _4: syn::punctuated::Punctuated<syn::Path, syn::token::Comma>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, syn::Error>, syn::punctuated::Punctuated<syn::Path, syn::token::Comma>>;
    let mut _6: std::result::Result<syn::punctuated::Punctuated<syn::Path, syn::token::Comma>, syn::Error>;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, syn::Error>;
    let _9: syn::punctuated::Punctuated<syn::Path, syn::token::Comma>;
    let mut _11: syn::punctuated::Iter<'_, syn::Path>;
    let mut _12: &syn::punctuated::Punctuated<syn::Path, syn::token::Comma>;
    let mut _13: {closure@core/codegen/src/bang/mod.rs:21:34: 21:40};
    let mut _14: &impl Fn(TokenStream) -> TokenStream;
    let mut _15: &proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let mut _20: proc_macro2::Delimiter;
    let mut _21: proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: ();
    let _36: &proc_macro2::TokenStream;
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: &str;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let mut _49: proc_macro2::Delimiter;
    let mut _50: proc_macro2::TokenStream;
    let mut _54: (std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>, quote::__private::HasIterator);
    let mut _55: std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>;
    let mut _57: bool;
    let mut _59: std::option::Option<proc_macro2::TokenStream>;
    let mut _60: &mut std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>;
    let mut _61: isize;
    let mut _63: bool;
    let mut _64: usize;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let mut _67: (usize, bool);
    let _68: ();
    let _69: &quote::__private::RepInterp<proc_macro2::TokenStream>;
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: ();
    let mut _74: &mut proc_macro2::TokenStream;
    let _75: &str;
    let mut _77: bool;
    scope 1 {
        debug paths => _4;
        let _10: std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>;
        scope 6 {
            debug exprs => _10;
            let mut _17: proc_macro2::TokenStream;
            scope 7 {
                debug _s => _17;
                let mut _22: proc_macro2::TokenStream;
                scope 8 {
                    debug _s => _22;
                    let mut _51: proc_macro2::TokenStream;
                    let mut _76: &exports::StaticPath;
                    scope 9 {
                        debug _s => _51;
                        let mut _52: usize;
                        scope 10 {
                            debug _i => _52;
                            scope 11 {
                                debug has_iter => const ThereIsNoIteratorInRepetition;
                                scope 12 {
                                    debug exprs => _53;
                                    debug i => const HasIterator;
                                    let _56: quote::__private::HasIterator;
                                    scope 14 {
                                        debug has_iter => const HasIterator;
                                        scope 15 {
                                            let _58: quote::__private::RepInterp<proc_macro2::TokenStream>;
                                            let _62: proc_macro2::TokenStream;
                                            scope 16 {
                                                debug exprs => _58;
                                            }
                                            scope 17 {
                                                debug _x => _62;
                                            }
                                        }
                                    }
                                }
                                scope 13 {
                                    let mut _53: std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>;
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _77 = const false;
        _6 = <for<'a> fn(&'a ParseBuffer<'a>) -> std::result::Result<syn::punctuated::Punctuated<syn::Path, syn::token::Comma>, syn::Error> {syn::punctuated::Punctuated::<syn::Path, syn::token::Comma>::parse_terminated} as Parser>::parse(syn::punctuated::Punctuated::<syn::Path, syn::token::Comma>::parse_terminated, move _1) -> [return: bb1, unwind: bb47];
    }

    bb1: {
        _5 = <std::result::Result<syn::punctuated::Punctuated<syn::Path, syn::token::Comma>, syn::Error> as std::ops::Try>::branch(move _6) -> [return: bb2, unwind: bb47];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = move ((_5 as Continue).0: syn::punctuated::Punctuated<syn::Path, syn::token::Comma>);
        _4 = move _9;
        _12 = &_4;
        _11 = syn::punctuated::Punctuated::<syn::Path, syn::token::Comma>::iter(move _12) -> [return: bb7, unwind: bb46];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, syn::Error>);
        _0 = <std::result::Result<TokenStream2, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, syn::Error>>>::from_residual(move _8) -> [return: bb6, unwind: bb47];
    }

    bb6: {
        drop(_3) -> [return: bb39, unwind: bb48];
    }

    bb7: {
        _14 = &_3;
        _15 = &_2;
        _13 = {closure@core/codegen/src/bang/mod.rs:21:34: 21:40} { map: move _14, ty: move _15 };
        _10 = <syn::punctuated::Iter<'_, syn::Path> as Iterator>::map::<TokenStream2, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>(move _11, move _13) -> [return: bb8, unwind: bb46];
    }

    bb8: {
        _77 = const true;
        _17 = TokenStream2::new() -> [return: bb9, unwind: bb51];
    }

    bb9: {
        _19 = &mut _17;
        _20 = proc_macro2::Delimiter::Brace;
        _22 = TokenStream2::new() -> [return: bb10, unwind: bb45];
    }

    bb10: {
        _24 = &mut _22;
        _25 = const "let";
        _23 = push_ident(_24, _25) -> [return: bb11, unwind: bb44];
    }

    bb11: {
        _27 = &mut _22;
        _28 = const "___vec";
        _26 = push_ident(_27, _28) -> [return: bb12, unwind: bb44];
    }

    bb12: {
        _30 = &mut _22;
        _29 = push_colon(_30) -> [return: bb13, unwind: bb44];
    }

    bb13: {
        _76 = const _;
        _32 = &mut _22;
        _31 = <StaticPath as ToTokens>::to_tokens(_76, _32) -> [return: bb14, unwind: bb44];
    }

    bb14: {
        _34 = &mut _22;
        _33 = push_lt(_34) -> [return: bb15, unwind: bb44];
    }

    bb15: {
        _36 = &_2;
        _37 = &mut _22;
        _35 = <TokenStream2 as ToTokens>::to_tokens(_36, _37) -> [return: bb16, unwind: bb44];
    }

    bb16: {
        _39 = &mut _22;
        _38 = push_gt(_39) -> [return: bb17, unwind: bb44];
    }

    bb17: {
        _41 = &mut _22;
        _40 = push_eq(_41) -> [return: bb18, unwind: bb44];
    }

    bb18: {
        _43 = &mut _22;
        _44 = const "vec";
        _42 = push_ident(_43, _44) -> [return: bb19, unwind: bb44];
    }

    bb19: {
        _46 = &mut _22;
        _45 = push_bang(_46) -> [return: bb20, unwind: bb44];
    }

    bb20: {
        _48 = &mut _22;
        _49 = proc_macro2::Delimiter::Bracket;
        _51 = TokenStream2::new() -> [return: bb21, unwind: bb44];
    }

    bb21: {
        _52 = const 0_usize;
        _77 = const false;
        _55 = move _10;
        _54 = <Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}> as quote::__private::ext::RepIteratorExt>::quote_into_iter(move _55) -> [return: bb22, unwind: bb43];
    }

    bb22: {
        _53 = move (_54.0: std::iter::Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}>);
        _56 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb52, unwind: bb42];
    }

    bb23: {
        _57 = const true;
        switchInt(move _57) -> [0: bb31, otherwise: bb24];
    }

    bb24: {
        _60 = &mut _53;
        _59 = <Map<syn::punctuated::Iter<'_, syn::Path>, {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}> as Iterator>::next(move _60) -> [return: bb25, unwind: bb42];
    }

    bb25: {
        _61 = discriminant(_59);
        switchInt(move _61) -> [0: bb31, 1: bb26, otherwise: bb4];
    }

    bb26: {
        _62 = move ((_59 as Some).0: proc_macro2::TokenStream);
        _58 = RepInterp::<TokenStream2>(move _62);
        _64 = _52;
        _63 = Gt(move _64, const 0_usize);
        switchInt(move _63) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _66 = &mut _51;
        _65 = push_comma(_66) -> [return: bb53, unwind: bb41];
    }

    bb28: {
        _67 = CheckedAdd(_52, const 1_usize);
        assert(!move (_67.1: bool), "attempt to compute `{} + {}`, which would overflow", _52, const 1_usize) -> [success: bb29, unwind: bb41];
    }

    bb29: {
        _52 = move (_67.0: usize);
        _69 = &_58;
        _70 = &mut _51;
        _68 = <RepInterp<TokenStream2> as ToTokens>::to_tokens(_69, _70) -> [return: bb30, unwind: bb41];
    }

    bb30: {
        drop(_58) -> [return: bb23, unwind: bb42];
    }

    bb31: {
        drop(_53) -> [return: bb32, unwind: bb43];
    }

    bb32: {
        _50 = move _51;
        _47 = push_group(_48, move _49, move _50) -> [return: bb33, unwind: bb44];
    }

    bb33: {
        _72 = &mut _22;
        _71 = push_semi(_72) -> [return: bb34, unwind: bb44];
    }

    bb34: {
        _74 = &mut _22;
        _75 = const "___vec";
        _73 = push_ident(_74, _75) -> [return: bb35, unwind: bb44];
    }

    bb35: {
        _21 = move _22;
        _18 = push_group(_19, move _20, move _21) -> [return: bb36, unwind: bb45];
    }

    bb36: {
        _16 = move _17;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::Ok(move _16);
        _77 = const false;
        drop(_4) -> [return: bb37, unwind: bb47];
    }

    bb37: {
        drop(_3) -> [return: bb38, unwind: bb48];
    }

    bb38: {
        drop(_2) -> [return: bb40, unwind continue];
    }

    bb39: {
        drop(_2) -> [return: bb40, unwind continue];
    }

    bb40: {
        return;
    }

    bb41 (cleanup): {
        drop(_58) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_53) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_51) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_22) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_17) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_4) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        drop(_3) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        drop(_2) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        resume;
    }

    bb50 (cleanup): {
        drop(_10) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        switchInt(_77) -> [0: bb46, otherwise: bb50];
    }

    bb52: {
        goto -> bb23;
    }

    bb53: {
        goto -> bb28;
    }
}

promoted[0] in struct_maker_vec: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn struct_maker_vec::{closure#0}(_1: &mut {closure@core/codegen/src/bang/mod.rs:21:34: 21:40}, _2: &syn::Path) -> TokenStream2 {
    debug path => _2;
    debug map => (*((*_1).0: &impl Fn(TokenStream) -> TokenStream));
    debug ty => (*((*_1).1: &proc_macro2::TokenStream));
    let mut _0: proc_macro2::TokenStream;
    let _3: proc_macro2::TokenStream;
    let mut _4: (proc_macro2::TokenStream,);
    let mut _5: proc_macro2::TokenStream;
    let mut _6: proc_macro2::TokenStream;
    let mut _8: &syn::Path;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let mut _14: &syn::Path;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let mut _17: proc_macro2::Delimiter;
    let mut _18: proc_macro2::TokenStream;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: &str;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let _29: &&syn::Path;
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _33: proc_macro2::Delimiter;
    let mut _34: proc_macro2::TokenStream;
    let _35: ();
    let mut _36: &mut proc_macro2::TokenStream;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: &str;
    let _40: ();
    let mut _41: &mut proc_macro2::TokenStream;
    let _42: &str;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: ();
    let mut _46: &mut proc_macro2::TokenStream;
    let _47: ();
    let mut _48: &mut proc_macro2::TokenStream;
    let _49: ();
    let _50: &proc_macro2::TokenStream;
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: ();
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: &str;
    let mut _57: &impl Fn(TokenStream) -> TokenStream;
    let mut _58: &proc_macro2::TokenStream;
    scope 1 {
        debug expr => _3;
        let mut _12: proc_macro2::TokenStream;
        scope 4 {
            debug _s => _12;
            let _13: proc_macro2::Span;
            scope 5 {
                debug _span => _13;
                let mut _19: proc_macro2::TokenStream;
                scope 6 {
                    debug _s => _19;
                    scope 7 {
                        debug _span => _13;
                        scope 8 {
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug _s => _6;
        let _7: proc_macro2::Span;
        scope 3 {
            debug _span => _7;
        }
    }

    bb0: {
        _57 = deref_copy ((*_1).0: &impl Fn(TokenStream) -> TokenStream);
        _6 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _2;
        _7 = <syn::Path as devise::Spanned>::span(move _8) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _10 = &mut _6;
        _11 = const "___struct";
        _9 = push_ident_spanned(_10, _7, _11) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _5 = move _6;
        _4 = (move _5,);
        _3 = <impl Fn(TokenStream) -> TokenStream as std::ops::Fn<(TokenStream2,)>>::call(_57, move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = TokenStream2::new() -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _14 = _2;
        _13 = <syn::Path as devise::Spanned>::span(move _14) -> [return: bb6, unwind: bb26];
    }

    bb6: {
        _16 = &mut _12;
        _17 = proc_macro2::Delimiter::Brace;
        _19 = TokenStream2::new() -> [return: bb7, unwind: bb26];
    }

    bb7: {
        _21 = &mut _19;
        _22 = const "let";
        _20 = push_ident_spanned(_21, _13, _22) -> [return: bb8, unwind: bb25];
    }

    bb8: {
        _24 = &mut _19;
        _25 = const "___struct";
        _23 = push_ident_spanned(_24, _13, _25) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _27 = &mut _19;
        _26 = push_eq_spanned(_27, _13) -> [return: bb10, unwind: bb25];
    }

    bb10: {
        _29 = &_2;
        _30 = &mut _19;
        _28 = <&syn::Path as ToTokens>::to_tokens(_29, _30) -> [return: bb11, unwind: bb25];
    }

    bb11: {
        _32 = &mut _19;
        _33 = proc_macro2::Delimiter::Brace;
        _34 = TokenStream2::new() -> [return: bb12, unwind: bb25];
    }

    bb12: {
        _31 = push_group_spanned(_32, _13, move _33, move _34) -> [return: bb13, unwind: bb25];
    }

    bb13: {
        _36 = &mut _19;
        _35 = push_semi_spanned(_36, _13) -> [return: bb14, unwind: bb25];
    }

    bb14: {
        _38 = &mut _19;
        _39 = const "let";
        _37 = push_ident_spanned(_38, _13, _39) -> [return: bb15, unwind: bb25];
    }

    bb15: {
        _41 = &mut _19;
        _42 = const "___item";
        _40 = push_ident_spanned(_41, _13, _42) -> [return: bb16, unwind: bb25];
    }

    bb16: {
        _44 = &mut _19;
        _43 = push_colon_spanned(_44, _13) -> [return: bb17, unwind: bb25];
    }

    bb17: {
        _58 = deref_copy ((*_1).1: &proc_macro2::TokenStream);
        _46 = &mut _19;
        _45 = <TokenStream2 as ToTokens>::to_tokens(_58, _46) -> [return: bb18, unwind: bb25];
    }

    bb18: {
        _48 = &mut _19;
        _47 = push_eq_spanned(_48, _13) -> [return: bb19, unwind: bb25];
    }

    bb19: {
        _50 = &_3;
        _51 = &mut _19;
        _49 = <TokenStream2 as ToTokens>::to_tokens(_50, _51) -> [return: bb20, unwind: bb25];
    }

    bb20: {
        _53 = &mut _19;
        _52 = push_semi_spanned(_53, _13) -> [return: bb21, unwind: bb25];
    }

    bb21: {
        _55 = &mut _19;
        _56 = const "___item";
        _54 = push_ident_spanned(_55, _13, _56) -> [return: bb22, unwind: bb25];
    }

    bb22: {
        _18 = move _19;
        _15 = push_group_spanned(_16, _13, move _17, move _18) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        _0 = move _12;
        drop(_3) -> [return: bb24, unwind continue];
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_19) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_12) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_6) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        resume;
    }
}

fn routes_macro(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: proc_macro::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let mut _16: bool;
    scope 1 {
        debug _s => _5;
    }

    bb0: {
        _16 = const false;
        _16 = const true;
        _3 = move _1;
        _5 = TokenStream2::new() -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _7 = &mut _5;
        _6 = push_colon2(_7) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _9 = &mut _5;
        _10 = const "rocket";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _12 = &mut _5;
        _11 = push_colon2(_12) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _14 = &mut _5;
        _15 = const "Route";
        _13 = push_ident(_14, _15) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _4 = move _5;
        _16 = const false;
        _2 = struct_maker_vec::<{closure@core/codegen/src/bang/mod.rs:37:54: 37:57}>(move _3, move _4, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:37:54: 37:57}) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _16 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:38:25: 38:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:38:25: 38:31}) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        switchInt(_16) -> [0: bb9, otherwise: bb10];
    }
}

fn routes_macro::{closure#0}(_1: &{closure@core/codegen/src/bang/mod.rs:37:54: 37:57}, _2: TokenStream2) -> TokenStream2 {
    debug e => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let _4: ();
    let _5: &proc_macro2::TokenStream;
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::Delimiter;
    let mut _15: proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _5 = &_2;
        _6 = &mut _3;
        _4 = <TokenStream2 as ToTokens>::to_tokens(_5, _6) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _8 = &mut _3;
        _7 = push_dot(_8) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _10 = &mut _3;
        _11 = const "into_route";
        _9 = push_ident(_10, _11) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _13 = &mut _3;
        _14 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _12 = push_group(_13, move _14, move _15) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        _0 = move _3;
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn routes_macro::{closure#1}(_1: {closure@core/codegen/src/bang/mod.rs:38:25: 38:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_expr_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn catchers_macro(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: proc_macro::TokenStream;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let mut _16: bool;
    scope 1 {
        debug _s => _5;
    }

    bb0: {
        _16 = const false;
        _16 = const true;
        _3 = move _1;
        _5 = TokenStream2::new() -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _7 = &mut _5;
        _6 = push_colon2(_7) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _9 = &mut _5;
        _10 = const "rocket";
        _8 = push_ident(_9, _10) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _12 = &mut _5;
        _11 = push_colon2(_12) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _14 = &mut _5;
        _15 = const "Catcher";
        _13 = push_ident(_14, _15) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _4 = move _5;
        _16 = const false;
        _2 = struct_maker_vec::<{closure@core/codegen/src/bang/mod.rs:42:56: 42:59}>(move _3, move _4, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:42:56: 42:59}) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _16 = const false;
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:43:25: 43:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:43:25: 43:31}) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        switchInt(_16) -> [0: bb9, otherwise: bb10];
    }
}

fn catchers_macro::{closure#0}(_1: &{closure@core/codegen/src/bang/mod.rs:42:56: 42:59}, _2: TokenStream2) -> TokenStream2 {
    debug e => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let _4: ();
    let _5: &proc_macro2::TokenStream;
    let mut _6: &mut proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: &str;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::Delimiter;
    let mut _15: proc_macro2::TokenStream;
    scope 1 {
        debug _s => _3;
    }

    bb0: {
        _3 = TokenStream2::new() -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _5 = &_2;
        _6 = &mut _3;
        _4 = <TokenStream2 as ToTokens>::to_tokens(_5, _6) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _8 = &mut _3;
        _7 = push_dot(_8) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _10 = &mut _3;
        _11 = const "into_catcher";
        _9 = push_ident(_10, _11) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _13 = &mut _3;
        _14 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _12 = push_group(_13, move _14, move _15) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        _0 = move _3;
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn catchers_macro::{closure#1}(_1: {closure@core/codegen/src/bang/mod.rs:43:25: 43:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_expr_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn uri_macro(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: proc_macro2::TokenStream;

    bb0: {
        _3 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _uri_macro(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:48:25: 48:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:48:25: 48:31}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn uri_macro::{closure#0}(_1: {closure@core/codegen/src/bang/mod.rs:48:25: 48:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: devise::Diagnostic;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let mut _29: bool;
    scope 1 {
        debug _s => _5;
    }

    bb0: {
        _29 = const false;
        _29 = const true;
        _3 = move _2;
        _5 = TokenStream2::new() -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _7 = &mut _5;
        _8 = const "rocket";
        _6 = push_ident(_7, _8) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _10 = &mut _5;
        _9 = push_colon2(_10) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _12 = &mut _5;
        _13 = const "http";
        _11 = push_ident(_12, _13) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _15 = &mut _5;
        _14 = push_colon2(_15) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _17 = &mut _5;
        _18 = const "uri";
        _16 = push_ident(_17, _18) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _20 = &mut _5;
        _19 = push_colon2(_20) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _22 = &mut _5;
        _23 = const "Origin";
        _21 = push_ident(_22, _23) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _25 = &mut _5;
        _24 = push_colon2(_25) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _27 = &mut _5;
        _28 = const "ROOT";
        _26 = push_ident(_27, _28) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        _4 = move _5;
        _29 = const false;
        _0 = devise::Diagnostic::emit_as_expr_tokens_or(move _3, move _4) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _29 = const false;
        return;
    }

    bb12 (cleanup): {
        drop(_5) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        switchInt(_29) -> [0: bb13, otherwise: bb14];
    }
}

fn uri_internal_macro(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;
    let mut _3: proc_macro2::TokenStream;

    bb0: {
        _3 = <proc_macro::TokenStream as Into<TokenStream2>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = _uri_internal_macro(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:60:25: 60:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:60:25: 60:31}) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn uri_internal_macro::{closure#0}(_1: {closure@core/codegen/src/bang/mod.rs:60:25: 60:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: devise::Diagnostic;
    let mut _4: proc_macro2::TokenStream;
    let mut _5: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: &str;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: &str;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: &str;
    let _19: ();
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: &str;
    let _24: ();
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: &str;
    let mut _29: bool;
    scope 1 {
        debug _s => _5;
    }

    bb0: {
        _29 = const false;
        _29 = const true;
        _3 = move _2;
        _5 = TokenStream2::new() -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _7 = &mut _5;
        _8 = const "rocket";
        _6 = push_ident(_7, _8) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _10 = &mut _5;
        _9 = push_colon2(_10) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _12 = &mut _5;
        _13 = const "http";
        _11 = push_ident(_12, _13) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _15 = &mut _5;
        _14 = push_colon2(_15) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _17 = &mut _5;
        _18 = const "uri";
        _16 = push_ident(_17, _18) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _20 = &mut _5;
        _19 = push_colon2(_20) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _22 = &mut _5;
        _23 = const "Origin";
        _21 = push_ident(_22, _23) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _25 = &mut _5;
        _24 = push_colon2(_25) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _27 = &mut _5;
        _28 = const "ROOT";
        _26 = push_ident(_27, _28) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        _4 = move _5;
        _29 = const false;
        _0 = devise::Diagnostic::emit_as_expr_tokens_or(move _3, move _4) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _29 = const false;
        return;
    }

    bb12 (cleanup): {
        drop(_5) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        switchInt(_29) -> [0: bb13, otherwise: bb14];
    }
}

fn guide_tests_internal(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _2 = test_guide::_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:67:25: 67:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:67:25: 67:31}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn guide_tests_internal::{closure#0}(_1: {closure@core/codegen/src/bang/mod.rs:67:25: 67:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn export_internal(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _2 = export::_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:72:25: 72:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:72:25: 72:31}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn export_internal::{closure#0}(_1: {closure@core/codegen/src/bang/mod.rs:72:25: 72:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn typed_stream(_1: proc_macro::TokenStream) -> TokenStream2 {
    debug input => _1;
    let mut _0: proc_macro2::TokenStream;
    let mut _2: std::result::Result<proc_macro2::TokenStream, devise::Diagnostic>;

    bb0: {
        _2 = typed_stream::_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<TokenStream2, devise::Diagnostic>::unwrap_or_else::<{closure@core/codegen/src/bang/mod.rs:77:25: 77:31}>(move _2, const ZeroSized: {closure@core/codegen/src/bang/mod.rs:77:25: 77:31}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn typed_stream::{closure#0}(_1: {closure@core/codegen/src/bang/mod.rs:77:25: 77:31}, _2: devise::Diagnostic) -> TokenStream2 {
    debug diag => _2;
    let mut _0: proc_macro2::TokenStream;

    bb0: {
        _0 = devise::Diagnostic::emit_as_item_tokens(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:7:10: 7:15>::fmt(_1: &http_codegen::ContentType, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::ContentType;
    let _6: &rocket_http::ContentType;

    bb0: {
        _3 = const "ContentType";
        _6 = &((*_1).0: rocket_http::ContentType);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:10:10: 10:15>::fmt(_1: &http_codegen::Status, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::Status;
    let _6: &rocket_http::Status;

    bb0: {
        _3 = const "Status";
        _6 = &((*_1).0: rocket_http::Status);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:13:10: 13:15>::fmt(_1: &http_codegen::MediaType, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::MediaType;
    let _6: &rocket_http::MediaType;

    bb0: {
        _3 = const "MediaType";
        _6 = &((*_1).0: rocket_http::MediaType);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:16:10: 16:15>::fmt(_1: &http_codegen::Method, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::Method;
    let _6: &rocket_http::Method;

    bb0: {
        _3 = const "Method";
        _6 = &((*_1).0: rocket_http::Method);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:16:23: 16:28>::clone(_1: &http_codegen::Method) -> http_codegen::Method {
    debug self => _1;
    let mut _0: http_codegen::Method;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:19:10: 19:15>::clone(_1: &Optional<T>) -> Optional<T> {
    debug self => _1;
    let mut _0: http_codegen::Optional<T>;
    let mut _2: std::option::Option<T>;
    let _3: &std::option::Option<T>;

    bb0: {
        _3 = &((*_1).0: std::option::Option<T>);
        _2 = <Option<T> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Optional::<T>(move _2);
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:19:17: 19:22>::fmt(_1: &Optional<T>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&std::option::Option<T>;
    let _6: &std::option::Option<T>;

    bb0: {
        _3 = const "Optional";
        _6 = &((*_1).0: std::option::Option<T>);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:22:10: 22:15>::fmt(_1: &http_codegen::Origin<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::uri::Origin<'_>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "Origin";
        _5 = &((*_1).0: &rocket_http::uri::Origin<'_>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:25:10: 25:15>::fmt(_1: &http_codegen::Absolute<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::uri::Absolute<'_>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "Absolute";
        _5 = &((*_1).0: &rocket_http::uri::Absolute<'_>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:28:10: 28:15>::fmt(_1: &http_codegen::Authority<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::uri::Authority<'_>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "Authority";
        _5 = &((*_1).0: &rocket_http::uri::Authority<'_>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:31:10: 31:15>::fmt(_1: &http_codegen::Reference<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&rocket_http::uri::Reference<'_>;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "Reference";
        _5 = &((*_1).0: &rocket_http::uri::Reference<'_>);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:34:10: 34:15>::fmt(_1: &http_codegen::Asterisk, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &rocket_http::uri::Asterisk;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&proc_macro2::Span;
    let _8: &proc_macro2::Span;

    bb0: {
        _3 = const "Asterisk";
        _5 = &((*_1).0: rocket_http::uri::Asterisk);
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = &((*_1).1: proc_macro2::Span);
        _7 = &_8;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field2_finish(_2, _3, move _4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:37:1: 37:25>::from_meta(_1: &devise::MetaItem) -> std::result::Result<http_codegen::Status, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<http_codegen::Status, devise::Diagnostic>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, usize>;
    let mut _3: std::result::Result<usize, devise::Diagnostic>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _6: usize;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: http_codegen::Status;
    let mut _12: rocket_http::Status;
    let mut _13: u16;
    scope 1 {
        debug num => _6;
    }
    scope 2 {
        debug residual => _5;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _6;
        scope 5 {
        }
    }

    bb0: {
        _3 = <usize as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<usize, devise::Diagnostic> as std::ops::Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: usize);
        _7 = Lt(_6, const 100_usize);
        switchInt(move _7) -> [0: bb6, otherwise: bb7];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<http_codegen::Status, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _5) -> [return: bb12, unwind continue];
    }

    bb6: {
        _8 = Ge(_6, const 600_usize);
        switchInt(move _8) -> [0: bb10, otherwise: bb7];
    }

    bb7: {
        _10 = devise::MetaItem::value_span(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _10, const "status must be in range [100, 599]") -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<http_codegen::Status, devise::Diagnostic>::Err(move _9);
        goto -> bb12;
    }

    bb10: {
        _13 = _6 as u16 (IntToInt);
        _12 = rocket_http::Status::new(move _13) -> [return: bb11, unwind continue];
    }

    bb11: {
        _11 = http_codegen::Status(move _12);
        _0 = std::result::Result::<http_codegen::Status, devise::Diagnostic>::Ok(move _11);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:48:1: 48:25>::to_tokens(_1: &http_codegen::Status, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: u16;
    let _4: ();
    let mut _5: proc_macro2::TokenStream;
    let _7: ();
    let mut _8: &mut proc_macro2::TokenStream;
    let _9: &str;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: &str;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let mut _22: proc_macro2::Delimiter;
    let mut _23: proc_macro2::TokenStream;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: &str;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: ();
    let _31: &u16;
    let mut _32: &mut proc_macro2::TokenStream;
    scope 1 {
        debug code => _3;
        let mut _6: proc_macro2::TokenStream;
        scope 2 {
            debug _s => _6;
            let mut _24: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _24;
            }
        }
    }

    bb0: {
        _3 = (((*_1).0: rocket_http::Status).0: u16);
        _6 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _6;
        _9 = const "rocket";
        _7 = push_ident(_8, _9) -> [return: bb2, unwind: bb14];
    }

    bb2: {
        _11 = &mut _6;
        _10 = push_colon2(_11) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _13 = &mut _6;
        _14 = const "http";
        _12 = push_ident(_13, _14) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _16 = &mut _6;
        _15 = push_colon2(_16) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _18 = &mut _6;
        _19 = const "Status";
        _17 = push_ident(_18, _19) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        _21 = &mut _6;
        _22 = proc_macro2::Delimiter::Brace;
        _24 = TokenStream2::new() -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _26 = &mut _24;
        _27 = const "code";
        _25 = push_ident(_26, _27) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _29 = &mut _24;
        _28 = push_colon(_29) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _31 = &_3;
        _32 = &mut _24;
        _30 = <u16 as ToTokens>::to_tokens(_31, _32) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        _23 = move _24;
        _20 = push_group(_21, move _22, move _23) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _5 = move _6;
        _4 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _5) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_24) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:55:1: 55:30>::from_meta(_1: &devise::MetaItem) -> std::result::Result<http_codegen::ContentType, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<http_codegen::ContentType, devise::Diagnostic>;
    let mut _2: std::option::Option<http_codegen::ContentType>;
    let mut _3: std::option::Option<rocket_http::ContentType>;
    let _4: &str;
    let _5: &std::string::String;
    let _6: std::string::String;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::string::String>;
    let mut _8: std::result::Result<std::string::String, devise::Diagnostic>;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _11: std::string::String;
    let mut _12: devise::Diagnostic;
    let mut _13: proc_macro2::Span;
    let mut _14: bool;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }

    bb0: {
        _14 = const false;
        _8 = <std::string::String as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = <std::result::Result<std::string::String, devise::Diagnostic> as std::ops::Try>::branch(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _11 = move ((_7 as Continue).0: std::string::String);
        _6 = move _11;
        _5 = &_6;
        _4 = <std::string::String as std::ops::Deref>::deref(_5) -> [return: bb7, unwind: bb14];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<http_codegen::ContentType, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _14 = const false;
        goto -> bb13;
    }

    bb7: {
        _3 = rocket_http::ContentType::parse_flexible(_4) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _2 = Option::<rocket_http::ContentType>::map::<http_codegen::ContentType, fn(rocket_http::ContentType) -> http_codegen::ContentType {http_codegen::ContentType}>(move _3, http_codegen::ContentType) -> [return: bb9, unwind: bb14];
    }

    bb9: {
        _14 = const true;
        _13 = devise::MetaItem::value_span(_1) -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _12 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _13, const "invalid or unknown content type") -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _14 = const false;
        _0 = Option::<http_codegen::ContentType>::ok_or::<devise::Diagnostic>(move _2, move _12) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _14 = const false;
        drop(_6) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_14) -> [0: bb14, otherwise: bb16];
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:63:1: 63:30>::to_tokens(_1: &http_codegen::ContentType, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: rocket_http::MediaType;
    let _4: &rocket_http::MediaType;
    let mut _5: &rocket_http::ContentType;
    let _7: ();
    let mut _8: proc_macro2::TokenStream;
    let _10: ();
    let mut _11: &mut proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let _14: &str;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: ();
    let mut _18: &mut proc_macro2::TokenStream;
    let _19: &str;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: &str;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let mut _27: proc_macro2::Delimiter;
    let mut _28: proc_macro2::TokenStream;
    let _30: ();
    let _31: &http_codegen::MediaType;
    let mut _32: &mut proc_macro2::TokenStream;
    scope 1 {
        debug http_media_type => _3;
        let _6: http_codegen::MediaType;
        scope 2 {
            debug media_type => _6;
            let mut _9: proc_macro2::TokenStream;
            scope 3 {
                debug _s => _9;
                let mut _29: proc_macro2::TokenStream;
                scope 4 {
                    debug _s => _29;
                }
            }
        }
    }

    bb0: {
        _5 = &((*_1).0: rocket_http::ContentType);
        _4 = rocket_http::ContentType::media_type(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <rocket_http::MediaType as Clone>::clone(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = http_codegen::MediaType(move _3);
        _9 = TokenStream2::new() -> [return: bb3, unwind: bb17];
    }

    bb3: {
        _11 = &mut _9;
        _10 = push_colon2(_11) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _13 = &mut _9;
        _14 = const "rocket";
        _12 = push_ident(_13, _14) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _16 = &mut _9;
        _15 = push_colon2(_16) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _18 = &mut _9;
        _19 = const "http";
        _17 = push_ident(_18, _19) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _21 = &mut _9;
        _20 = push_colon2(_21) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _23 = &mut _9;
        _24 = const "ContentType";
        _22 = push_ident(_23, _24) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _26 = &mut _9;
        _27 = proc_macro2::Delimiter::Parenthesis;
        _29 = TokenStream2::new() -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _31 = &_6;
        _32 = &mut _29;
        _30 = <http_codegen::MediaType as ToTokens>::to_tokens(_31, _32) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _28 = move _29;
        _25 = push_group(_26, move _27, move _28) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        _8 = move _9;
        _7 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _8) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        drop(_6) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_29) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_6) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:71:1: 71:28>::from_meta(_1: &devise::MetaItem) -> std::result::Result<http_codegen::MediaType, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<http_codegen::MediaType, devise::Diagnostic>;
    let _2: rocket_http::MediaType;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, rocket_http::MediaType>;
    let mut _4: std::result::Result<rocket_http::MediaType, devise::Diagnostic>;
    let mut _5: std::option::Option<rocket_http::MediaType>;
    let _6: &str;
    let _7: &std::string::String;
    let _8: std::string::String;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, std::string::String>;
    let mut _10: std::result::Result<std::string::String, devise::Diagnostic>;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _13: std::string::String;
    let mut _14: devise::Diagnostic;
    let mut _15: proc_macro2::Span;
    let mut _16: isize;
    let _17: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
    let _18: rocket_http::MediaType;
    let mut _19: bool;
    let mut _20: &rocket_http::MediaType;
    let _21: proc_macro2::TokenStream;
    let mut _22: devise::Diagnostic;
    let mut _23: proc_macro2::Span;
    let mut _25: std::fmt::Arguments<'_>;
    let mut _26: &[&str];
    let mut _27: &[core::fmt::rt::Argument<'_>];
    let _28: &[core::fmt::rt::Argument<'_>; 1];
    let _29: [core::fmt::rt::Argument<'_>; 1];
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &rocket_http::MediaType;
    let mut _32: http_codegen::MediaType;
    let mut _33: rocket_http::MediaType;
    let mut _35: bool;
    scope 1 {
        debug mt => _2;
        let _24: std::string::String;
        let mut _34: &[&str; 2];
        scope 10 {
            debug res => _24;
        }
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }
    scope 6 {
        debug residual => _17;
        scope 7 {
        }
    }
    scope 8 {
        debug val => _18;
        scope 9 {
        }
    }

    bb0: {
        _35 = const false;
        _10 = <std::string::String as devise::FromMeta>::from_meta(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = <std::result::Result<std::string::String, devise::Diagnostic> as std::ops::Try>::branch(move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _13 = move ((_9 as Continue).0: std::string::String);
        _8 = move _13;
        _7 = &_8;
        _6 = <std::string::String as std::ops::Deref>::deref(_7) -> [return: bb7, unwind: bb27];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _12 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<http_codegen::MediaType, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _35 = const false;
        goto -> bb25;
    }

    bb7: {
        _5 = rocket_http::MediaType::parse_flexible(_6) -> [return: bb8, unwind: bb27];
    }

    bb8: {
        _35 = const true;
        _15 = devise::MetaItem::value_span(_1) -> [return: bb9, unwind: bb31];
    }

    bb9: {
        _14 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _15, const "invalid or unknown media type") -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _35 = const false;
        _4 = Option::<rocket_http::MediaType>::ok_or::<devise::Diagnostic>(move _5, move _14) -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _35 = const false;
        _3 = <std::result::Result<rocket_http::MediaType, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _16 = discriminant(_3);
        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb4];
    }

    bb13: {
        _18 = move ((_3 as Continue).0: rocket_http::MediaType);
        _2 = move _18;
        drop(_8) -> [return: bb29, unwind: bb26];
    }

    bb14: {
        _17 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<http_codegen::MediaType, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _17) -> [return: bb15, unwind: bb27];
    }

    bb15: {
        drop(_8) -> [return: bb25, unwind continue];
    }

    bb16: {
        switchInt(move _19) -> [0: bb17, otherwise: bb24];
    }

    bb17: {
        _23 = devise::MetaItem::value_span(_1) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _34 = const _;
        _26 = _34 as &[&str] (PointerCoercion(Unsize));
        _31 = &_2;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<rocket_http::MediaType>(_31) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _29 = [move _30];
        _28 = &_29;
        _27 = _28 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _25 = std::fmt::Arguments::<'_>::new_v1(move _26, move _27) -> [return: bb20, unwind: bb26];
    }

    bb20: {
        _24 = format(move _25) -> [return: bb21, unwind: bb26];
    }

    bb21: {
        _22 = <proc_macro2::Span as SpanDiagnosticExt>::warning::<std::string::String>(move _23, move _24) -> [return: bb22, unwind: bb26];
    }

    bb22: {
        _21 = devise::Diagnostic::emit_as_item_tokens(move _22) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        drop(_21) -> [return: bb24, unwind: bb26];
    }

    bb24: {
        _33 = move _2;
        _32 = http_codegen::MediaType(move _33);
        _0 = std::result::Result::<http_codegen::MediaType, devise::Diagnostic>::Ok(move _32);
        goto -> bb25;
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        drop(_2) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_8) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29: {
        _20 = &_2;
        _19 = rocket_http::MediaType::is_known(move _20) -> [return: bb16, unwind: bb26];
    }

    bb30 (cleanup): {
        drop(_5) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        switchInt(_35) -> [0: bb27, otherwise: bb30];
    }
}

promoted[0] in http_codegen::<impl at core/codegen/src/http_codegen.rs:71:1: 71:28>::from_meta: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "'", const "' is not a known media type"];
        _0 = &_1;
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:87:1: 87:28>::to_tokens(_1: &http_codegen::MediaType, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &str;
    let _4: &str;
    let mut _5: (&str, &str);
    let mut _6: &str;
    let _7: &rocket_http::uncased::UncasedStr;
    let mut _8: &rocket_http::MediaType;
    let mut _9: &str;
    let _10: &rocket_http::uncased::UncasedStr;
    let mut _11: &rocket_http::MediaType;
    let mut _14: (std::vec::Vec<&str>, std::vec::Vec<&str>);
    let mut _15: std::iter::Map<std::iter::Map<either::Either<std::iter::Cloned<std::slice::Iter<'_, (&str, &str)>>, std::iter::Map<std::slice::Iter<'_, (rocket_http::private::Indexed<'_, str>, rocket_http::private::Indexed<'_, str>)>, {closure@rocket_http::MediaType::params::{closure#0}}>>, {closure@rocket_http::MediaType::params::{closure#1}}>, {closure@core/codegen/src/http_codegen.rs:90:50: 90:58}>;
    let mut _16: std::iter::Map<either::Either<std::iter::Cloned<std::slice::Iter<'_, (&str, &str)>>, std::iter::Map<std::slice::Iter<'_, (rocket_http::private::Indexed<'_, str>, rocket_http::private::Indexed<'_, str>)>, {closure@rocket_http::MediaType::params::{closure#0}}>>, {closure@rocket_http::MediaType::params::{closure#1}}>;
    let mut _17: &rocket_http::MediaType;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: &mut proc_macro2::TokenStream;
    let _24: &str;
    let _25: ();
    let mut _26: &mut proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: &str;
    let _30: ();
    let mut _31: proc_macro2::TokenStream;
    let _33: ();
    let _34: &proc_macro2::TokenStream;
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let mut _48: proc_macro2::Delimiter;
    let mut _49: proc_macro2::TokenStream;
    let _51: ();
    let _52: &&str;
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let _57: &&str;
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let mut _62: &mut proc_macro2::TokenStream;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let mut _65: proc_macro2::Delimiter;
    let mut _66: proc_macro2::TokenStream;
    let mut _70: (std::slice::Iter<'_, &str>, quote::__private::HasIterator);
    let mut _71: &std::vec::Vec<&str>;
    let mut _74: (std::slice::Iter<'_, &str>, quote::__private::HasIterator);
    let mut _75: &std::vec::Vec<&str>;
    let mut _77: bool;
    let mut _79: std::option::Option<&&str>;
    let mut _80: &mut std::slice::Iter<'_, &str>;
    let mut _81: isize;
    let mut _84: std::option::Option<&&str>;
    let mut _85: &mut std::slice::Iter<'_, &str>;
    let mut _86: isize;
    let mut _88: bool;
    let mut _89: usize;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let mut _92: (usize, bool);
    let _93: ();
    let mut _94: &mut proc_macro2::TokenStream;
    let mut _95: proc_macro2::Delimiter;
    let mut _96: proc_macro2::TokenStream;
    let _98: ();
    let _99: &quote::__private::RepInterp<&&str>;
    let mut _100: &mut proc_macro2::TokenStream;
    let _101: ();
    let mut _102: &mut proc_macro2::TokenStream;
    let _103: ();
    let _104: &quote::__private::RepInterp<&&str>;
    let mut _105: &mut proc_macro2::TokenStream;
    scope 1 {
        debug top => _3;
        debug sub => _4;
        let _12: std::vec::Vec<&str>;
        let _13: std::vec::Vec<&str>;
        scope 2 {
            debug keys => _12;
            debug values => _13;
            let _18: proc_macro2::TokenStream;
            let mut _19: proc_macro2::TokenStream;
            scope 3 {
                debug http => _18;
                let mut _32: proc_macro2::TokenStream;
                scope 5 {
                    debug _s => _32;
                    let mut _50: proc_macro2::TokenStream;
                    scope 6 {
                        debug _s => _50;
                        let mut _67: proc_macro2::TokenStream;
                        scope 7 {
                            debug _s => _67;
                            let mut _68: usize;
                            scope 8 {
                                debug _i => _68;
                                scope 9 {
                                    debug has_iter => const ThereIsNoIteratorInRepetition;
                                    scope 10 {
                                        debug keys => _69;
                                        debug i => const HasIterator;
                                        let _72: quote::__private::HasIterator;
                                        scope 12 {
                                            debug has_iter => const HasIterator;
                                            scope 13 {
                                                debug values => _73;
                                                debug i => const HasIterator;
                                                let _76: quote::__private::HasIterator;
                                                scope 15 {
                                                    debug has_iter => const HasIterator;
                                                    scope 16 {
                                                        let _78: quote::__private::RepInterp<&&str>;
                                                        let _82: &&str;
                                                        scope 17 {
                                                            debug keys => _78;
                                                            let _83: quote::__private::RepInterp<&&str>;
                                                            let _87: &&str;
                                                            scope 19 {
                                                                debug values => _83;
                                                                let mut _97: proc_macro2::TokenStream;
                                                                scope 21 {
                                                                    debug _s => _97;
                                                                }
                                                            }
                                                            scope 20 {
                                                                debug _x => _87;
                                                            }
                                                        }
                                                        scope 18 {
                                                            debug _x => _82;
                                                        }
                                                    }
                                                }
                                            }
                                            scope 14 {
                                                let mut _73: std::slice::Iter<'_, &str>;
                                            }
                                        }
                                    }
                                    scope 11 {
                                        let mut _69: std::slice::Iter<'_, &str>;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 4 {
                debug _s => _19;
            }
        }
    }

    bb0: {
        _8 = &((*_1).0: rocket_http::MediaType);
        _7 = rocket_http::MediaType::top(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = UncasedStr::as_str(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = &((*_1).0: rocket_http::MediaType);
        _10 = rocket_http::MediaType::sub(move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = UncasedStr::as_str(_10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = (move _6, move _9);
        _3 = (_5.0: &str);
        _4 = (_5.1: &str);
        _17 = &((*_1).0: rocket_http::MediaType);
        _16 = rocket_http::MediaType::params(move _17) -> [return: bb5, unwind continue];
    }

    bb5: {
        _15 = <Map<either::Either<Cloned<std::slice::Iter<'_, (&str, &str)>>, Map<std::slice::Iter<'_, (rocket_http::private::Indexed<'_, str>, rocket_http::private::Indexed<'_, str>)>, {closure@rocket_http::MediaType::params::{closure#0}}>>, {closure@rocket_http::MediaType::params::{closure#1}}> as Iterator>::map::<(&str, &str), {closure@core/codegen/src/http_codegen.rs:90:50: 90:58}>(move _16, const ZeroSized: {closure@core/codegen/src/http_codegen.rs:90:50: 90:58}) -> [return: bb6, unwind continue];
    }

    bb6: {
        _14 = <Map<Map<either::Either<Cloned<std::slice::Iter<'_, (&str, &str)>>, Map<std::slice::Iter<'_, (rocket_http::private::Indexed<'_, str>, rocket_http::private::Indexed<'_, str>)>, {closure@rocket_http::MediaType::params::{closure#0}}>>, {closure@rocket_http::MediaType::params::{closure#1}}>, {closure@core/codegen/src/http_codegen.rs:90:50: 90:58}> as Split2<&str, &str>>::split2(move _15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = move (_14.0: std::vec::Vec<&str>);
        _13 = move (_14.1: std::vec::Vec<&str>);
        _19 = TokenStream2::new() -> [return: bb8, unwind: bb56];
    }

    bb8: {
        _21 = &mut _19;
        _20 = push_colon2(_21) -> [return: bb9, unwind: bb55];
    }

    bb9: {
        _23 = &mut _19;
        _24 = const "rocket";
        _22 = push_ident(_23, _24) -> [return: bb10, unwind: bb55];
    }

    bb10: {
        _26 = &mut _19;
        _25 = push_colon2(_26) -> [return: bb11, unwind: bb55];
    }

    bb11: {
        _28 = &mut _19;
        _29 = const "http";
        _27 = push_ident(_28, _29) -> [return: bb12, unwind: bb55];
    }

    bb12: {
        _18 = move _19;
        _32 = TokenStream2::new() -> [return: bb13, unwind: bb54];
    }

    bb13: {
        _34 = &_18;
        _35 = &mut _32;
        _33 = <TokenStream2 as ToTokens>::to_tokens(_34, _35) -> [return: bb14, unwind: bb53];
    }

    bb14: {
        _37 = &mut _32;
        _36 = push_colon2(_37) -> [return: bb15, unwind: bb53];
    }

    bb15: {
        _39 = &mut _32;
        _40 = const "MediaType";
        _38 = push_ident(_39, _40) -> [return: bb16, unwind: bb53];
    }

    bb16: {
        _42 = &mut _32;
        _41 = push_colon2(_42) -> [return: bb17, unwind: bb53];
    }

    bb17: {
        _44 = &mut _32;
        _45 = const "const_new";
        _43 = push_ident(_44, _45) -> [return: bb18, unwind: bb53];
    }

    bb18: {
        _47 = &mut _32;
        _48 = proc_macro2::Delimiter::Parenthesis;
        _50 = TokenStream2::new() -> [return: bb19, unwind: bb53];
    }

    bb19: {
        _52 = &_3;
        _53 = &mut _50;
        _51 = <&str as ToTokens>::to_tokens(_52, _53) -> [return: bb20, unwind: bb52];
    }

    bb20: {
        _55 = &mut _50;
        _54 = push_comma(_55) -> [return: bb21, unwind: bb52];
    }

    bb21: {
        _57 = &_4;
        _58 = &mut _50;
        _56 = <&str as ToTokens>::to_tokens(_57, _58) -> [return: bb22, unwind: bb52];
    }

    bb22: {
        _60 = &mut _50;
        _59 = push_comma(_60) -> [return: bb23, unwind: bb52];
    }

    bb23: {
        _62 = &mut _50;
        _61 = push_and(_62) -> [return: bb24, unwind: bb52];
    }

    bb24: {
        _64 = &mut _50;
        _65 = proc_macro2::Delimiter::Bracket;
        _67 = TokenStream2::new() -> [return: bb25, unwind: bb52];
    }

    bb25: {
        _68 = const 0_usize;
        _71 = &_12;
        _70 = <Vec<&str> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _71) -> [return: bb26, unwind: bb51];
    }

    bb26: {
        _69 = move (_70.0: std::slice::Iter<'_, &str>);
        _72 = <ThereIsNoIteratorInRepetition as std::ops::BitOr<HasIterator>>::bitor(const ThereIsNoIteratorInRepetition, const HasIterator) -> [return: bb27, unwind: bb51];
    }

    bb27: {
        _75 = &_13;
        _74 = <Vec<&str> as quote::__private::ext::RepAsIteratorExt<'_>>::quote_into_iter(move _75) -> [return: bb28, unwind: bb51];
    }

    bb28: {
        _73 = move (_74.0: std::slice::Iter<'_, &str>);
        _76 = <HasIterator as std::ops::BitOr>::bitor(const HasIterator, const HasIterator) -> [return: bb59, unwind: bb51];
    }

    bb29: {
        _77 = const true;
        switchInt(move _77) -> [0: bb43, otherwise: bb30];
    }

    bb30: {
        _80 = &mut _69;
        _79 = <std::slice::Iter<'_, &str> as Iterator>::next(move _80) -> [return: bb31, unwind: bb51];
    }

    bb31: {
        _81 = discriminant(_79);
        switchInt(move _81) -> [0: bb43, 1: bb33, otherwise: bb32];
    }

    bb32: {
        unreachable;
    }

    bb33: {
        _82 = ((_79 as Some).0: &&str);
        _78 = RepInterp::<&&str>(_82);
        _85 = &mut _73;
        _84 = <std::slice::Iter<'_, &str> as Iterator>::next(move _85) -> [return: bb34, unwind: bb51];
    }

    bb34: {
        _86 = discriminant(_84);
        switchInt(move _86) -> [0: bb43, 1: bb35, otherwise: bb32];
    }

    bb35: {
        _87 = ((_84 as Some).0: &&str);
        _83 = RepInterp::<&&str>(_87);
        _89 = _68;
        _88 = Gt(move _89, const 0_usize);
        switchInt(move _88) -> [0: bb37, otherwise: bb36];
    }

    bb36: {
        _91 = &mut _67;
        _90 = push_comma(_91) -> [return: bb60, unwind: bb51];
    }

    bb37: {
        _92 = CheckedAdd(_68, const 1_usize);
        assert(!move (_92.1: bool), "attempt to compute `{} + {}`, which would overflow", _68, const 1_usize) -> [success: bb38, unwind: bb51];
    }

    bb38: {
        _68 = move (_92.0: usize);
        _94 = &mut _67;
        _95 = proc_macro2::Delimiter::Parenthesis;
        _97 = TokenStream2::new() -> [return: bb39, unwind: bb51];
    }

    bb39: {
        _99 = &_78;
        _100 = &mut _97;
        _98 = <RepInterp<&&str> as ToTokens>::to_tokens(_99, _100) -> [return: bb40, unwind: bb50];
    }

    bb40: {
        _102 = &mut _97;
        _101 = push_comma(_102) -> [return: bb41, unwind: bb50];
    }

    bb41: {
        _104 = &_83;
        _105 = &mut _97;
        _103 = <RepInterp<&&str> as ToTokens>::to_tokens(_104, _105) -> [return: bb42, unwind: bb50];
    }

    bb42: {
        _96 = move _97;
        _93 = push_group(_94, move _95, move _96) -> [return: bb61, unwind: bb51];
    }

    bb43: {
        _66 = move _67;
        _63 = push_group(_64, move _65, move _66) -> [return: bb44, unwind: bb52];
    }

    bb44: {
        _49 = move _50;
        _46 = push_group(_47, move _48, move _49) -> [return: bb45, unwind: bb53];
    }

    bb45: {
        _31 = move _32;
        _30 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _31) -> [return: bb46, unwind: bb54];
    }

    bb46: {
        drop(_18) -> [return: bb47, unwind: bb56];
    }

    bb47: {
        drop(_13) -> [return: bb48, unwind: bb57];
    }

    bb48: {
        drop(_12) -> [return: bb49, unwind continue];
    }

    bb49: {
        return;
    }

    bb50 (cleanup): {
        drop(_97) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_67) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_50) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_32) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_18) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_19) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_13) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_12) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        resume;
    }

    bb59: {
        goto -> bb29;
    }

    bb60: {
        goto -> bb37;
    }

    bb61: {
        goto -> bb29;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:87:1: 87:28>::to_tokens::{closure#0}(_1: &mut {closure@core/codegen/src/http_codegen.rs:90:50: 90:58}, _2: (&UncasedStr, &str)) -> (&str, &str) {
    let mut _0: (&str, &str);
    let _3: &rocket_http::uncased::UncasedStr;
    let _4: &str;
    let mut _5: &str;
    scope 1 {
        debug k => _3;
        debug v => _4;
    }

    bb0: {
        _3 = (_2.0: &rocket_http::uncased::UncasedStr);
        _4 = (_2.1: &str);
        _5 = UncasedStr::as_str(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = (move _5, _4);
        return;
    }
}

const VALID_METHODS_STR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "`GET`, `PUT`, `POST`, `DELETE`, `HEAD`, `PATCH`, `OPTIONS`";
        return;
    }
}

const VALID_METHODS: &[rocket_http::Method] = {
    let mut _0: &[rocket_http::Method];
    let mut _1: &[rocket_http::Method; 7];
    let _2: &[rocket_http::Method; 7];
    let _3: [rocket_http::Method; 7];
    let mut _4: rocket_http::Method;
    let mut _5: rocket_http::Method;
    let mut _6: rocket_http::Method;
    let mut _7: rocket_http::Method;
    let mut _8: rocket_http::Method;
    let mut _9: rocket_http::Method;
    let mut _10: rocket_http::Method;
    let mut _11: &[rocket_http::Method; 7];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _11 = const _;
        _2 = &(*_11);
        _1 = &(*_2);
        _0 = move _1 as &[rocket_http::Method] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in VALID_METHODS: &[rocket_http::Method; 7] = {
    let mut _0: &[rocket_http::Method; 7];
    let mut _1: [rocket_http::Method; 7];
    let mut _2: rocket_http::Method;
    let mut _3: rocket_http::Method;
    let mut _4: rocket_http::Method;
    let mut _5: rocket_http::Method;
    let mut _6: rocket_http::Method;
    let mut _7: rocket_http::Method;
    let mut _8: rocket_http::Method;

    bb0: {
        _2 = Get;
        _3 = Put;
        _4 = Post;
        _5 = rocket_http::Method::Delete;
        _6 = Head;
        _7 = Patch;
        _8 = Options;
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8];
        _0 = &_1;
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:108:1: 108:25>::from_meta(_1: &devise::MetaItem) -> std::result::Result<http_codegen::Method, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<http_codegen::Method, devise::Diagnostic>;
    let _2: proc_macro2::Span;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let mut _11: isize;
    let mut _13: std::option::Option<&proc_macro2::Ident>;
    let mut _14: isize;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, rocket_http::Method>;
    let mut _18: std::result::Result<rocket_http::Method, devise::Diagnostic>;
    let mut _19: std::result::Result<rocket_http::Method, ()>;
    let _20: &str;
    let mut _21: &std::string::String;
    let _22: std::string::String;
    let mut _23: {closure@core/codegen/src/http_codegen.rs:116:30: 116:33};
    let mut _24: &proc_macro2::Span;
    let mut _25: &std::string::String;
    let mut _26: isize;
    let mut _29: bool;
    let _30: &[rocket_http::Method];
    let _31: &rocket_http::Method;
    let mut _32: devise::Diagnostic;
    let mut _33: devise::Diagnostic;
    let mut _34: proc_macro2::Span;
    let _35: &str;
    let mut _36: &std::string::String;
    let mut _37: http_codegen::Method;
    let mut _38: rocket_http::Method;
    let mut _39: devise::Diagnostic;
    let mut _40: devise::Diagnostic;
    let mut _41: proc_macro2::Span;
    let mut _43: std::fmt::Arguments<'_>;
    let mut _44: &[&str];
    let mut _45: &[core::fmt::rt::Argument<'_>];
    let _46: &[core::fmt::rt::Argument<'_>; 1];
    let _47: [core::fmt::rt::Argument<'_>; 1];
    let mut _48: core::fmt::rt::Argument<'_>;
    let _49: &&str;
    let _50: &str;
    let _51: &str;
    let mut _52: &std::string::String;
    let mut _56: bool;
    let mut _57: bool;
    scope 1 {
        debug span => _2;
        let _3: std::string::String;
        let _4: std::string::String;
        let mut _54: &&str;
        let mut _55: &[&str; 1];
        scope 2 {
            debug help_text => _3;
            let _42: std::string::String;
            let mut _53: &[&str; 1];
            scope 4 {
                debug path => _12;
                let _12: &syn::Path;
                scope 5 {
                    debug ident => _15;
                    let _15: &proc_macro2::Ident;
                    let _16: rocket_http::Method;
                    let _27: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
                    let _28: rocket_http::Method;
                    scope 6 {
                        debug method => _16;
                    }
                    scope 7 {
                        debug residual => _27;
                        scope 8 {
                        }
                    }
                    scope 9 {
                        debug val => _28;
                        scope 10 {
                        }
                    }
                }
            }
            scope 11 {
                debug res => _42;
            }
        }
        scope 3 {
            debug res => _4;
        }
    }

    bb0: {
        _57 = const false;
        _56 = const false;
        _2 = devise::MetaItem::value_span(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _55 = const _;
        _6 = _55 as &[&str] (PointerCoercion(Unsize));
        _54 = const _;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_54) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = std::fmt::Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = format(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = move _4;
        _11 = discriminant((*_1));
        switchInt(move _11) -> [0: bb5, otherwise: bb24];
    }

    bb5: {
        _12 = &(((*_1) as Path).0: syn::Path);
        _13 = <syn::Path as PathExt>::last_ident(_12) -> [return: bb6, unwind: bb35];
    }

    bb6: {
        _14 = discriminant(_13);
        switchInt(move _14) -> [1: bb7, otherwise: bb24];
    }

    bb7: {
        _15 = ((_13 as Some).0: &proc_macro2::Ident);
        _22 = <proc_macro2::Ident as ToString>::to_string(_15) -> [return: bb8, unwind: bb35];
    }

    bb8: {
        _21 = &_22;
        _20 = <std::string::String as std::ops::Deref>::deref(move _21) -> [return: bb9, unwind: bb34];
    }

    bb9: {
        _19 = core::str::<impl str>::parse::<rocket_http::Method>(_20) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _24 = &_2;
        _25 = &_3;
        _23 = {closure@core/codegen/src/http_codegen.rs:116:30: 116:33} { span: move _24, help_text: move _25 };
        _18 = std::result::Result::<rocket_http::Method, ()>::map_err::<devise::Diagnostic, {closure@core/codegen/src/http_codegen.rs:116:30: 116:33}>(move _19, move _23) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _17 = <std::result::Result<rocket_http::Method, devise::Diagnostic> as std::ops::Try>::branch(move _18) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _26 = discriminant(_17);
        switchInt(move _26) -> [0: bb13, 1: bb15, otherwise: bb14];
    }

    bb13: {
        _28 = ((_17 as Continue).0: rocket_http::Method);
        _16 = _28;
        drop(_22) -> [return: bb17, unwind: bb35];
    }

    bb14: {
        unreachable;
    }

    bb15: {
        _27 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<http_codegen::Method, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _27) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        drop(_22) -> [return: bb32, unwind: bb35];
    }

    bb17: {
        _30 = const _;
        _31 = &_16;
        _29 = core::slice::<impl [rocket_http::Method]>::contains(_30, _31) -> [return: bb18, unwind: bb35];
    }

    bb18: {
        switchInt(move _29) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _38 = _16;
        _37 = http_codegen::Method(move _38);
        _0 = std::result::Result::<http_codegen::Method, devise::Diagnostic>::Ok(move _37);
        goto -> bb32;
    }

    bb20: {
        _34 = _2;
        _33 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _34, const "invalid HTTP method for route handlers") -> [return: bb21, unwind: bb35];
    }

    bb21: {
        _57 = const true;
        _36 = &_3;
        _35 = <std::string::String as std::ops::Deref>::deref(move _36) -> [return: bb22, unwind: bb40];
    }

    bb22: {
        _57 = const false;
        _32 = devise::Diagnostic::help::<&str>(move _33, _35) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        _57 = const false;
        _0 = std::result::Result::<http_codegen::Method, devise::Diagnostic>::Err(move _32);
        goto -> bb32;
    }

    bb24: {
        _41 = _2;
        _53 = const _;
        _44 = _53 as &[&str] (PointerCoercion(Unsize));
        _50 = devise::MetaItem::description(_1) -> [return: bb25, unwind: bb35];
    }

    bb25: {
        _49 = &_50;
        _48 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_49) -> [return: bb26, unwind: bb35];
    }

    bb26: {
        _47 = [move _48];
        _46 = &_47;
        _45 = _46 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _43 = std::fmt::Arguments::<'_>::new_v1(move _44, move _45) -> [return: bb27, unwind: bb35];
    }

    bb27: {
        _42 = format(move _43) -> [return: bb28, unwind: bb35];
    }

    bb28: {
        _40 = <proc_macro2::Span as SpanDiagnosticExt>::error::<std::string::String>(move _41, move _42) -> [return: bb29, unwind: bb35];
    }

    bb29: {
        _56 = const true;
        _52 = &_3;
        _51 = <std::string::String as std::ops::Deref>::deref(move _52) -> [return: bb30, unwind: bb38];
    }

    bb30: {
        _56 = const false;
        _39 = devise::Diagnostic::help::<&str>(move _40, _51) -> [return: bb31, unwind: bb38];
    }

    bb31: {
        _56 = const false;
        _0 = std::result::Result::<http_codegen::Method, devise::Diagnostic>::Err(move _39);
        drop(_3) -> [return: bb33, unwind continue];
    }

    bb32: {
        drop(_3) -> [return: bb33, unwind continue];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_22) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_3) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        resume;
    }

    bb37 (cleanup): {
        drop(_40) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_56) -> [0: bb35, otherwise: bb37];
    }

    bb39 (cleanup): {
        drop(_33) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        switchInt(_57) -> [0: bb35, otherwise: bb39];
    }
}

promoted[0] in http_codegen::<impl at core/codegen/src/http_codegen.rs:108:1: 108:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "expected identifier, found "];
        _0 = &_1;
        return;
    }
}

promoted[1] in http_codegen::<impl at core/codegen/src/http_codegen.rs:108:1: 108:25>::from_meta: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[2] in http_codegen::<impl at core/codegen/src/http_codegen.rs:108:1: 108:25>::from_meta: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "method must be one of: "];
        _0 = &_1;
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:108:1: 108:25>::from_meta::{closure#0}(_1: {closure@core/codegen/src/http_codegen.rs:116:30: 116:33}, _2: ()) -> devise::Diagnostic {
    debug span => (*(_1.0: &proc_macro2::Span));
    debug help_text => (*(_1.1: &std::string::String));
    let mut _0: devise::Diagnostic;
    let mut _3: devise::Diagnostic;
    let mut _4: proc_macro2::Span;
    let _5: &str;
    let mut _6: &proc_macro2::Span;
    let mut _7: &std::string::String;
    let mut _8: bool;

    bb0: {
        _8 = const false;
        _6 = deref_copy (_1.0: &proc_macro2::Span);
        _4 = (*_6);
        _8 = const true;
        _3 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _4, const "invalid HTTP method") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = deref_copy (_1.1: &std::string::String);
        _5 = <std::string::String as std::ops::Deref>::deref(_7) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _8 = const false;
        _0 = devise::Diagnostic::help::<&str>(move _3, _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _8 = const false;
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        switchInt(_8) -> [0: bb4, otherwise: bb5];
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:132:1: 132:25>::to_tokens(_1: &http_codegen::Method, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: proc_macro2::TokenStream;
    let mut _4: isize;
    let mut _5: proc_macro2::TokenStream;
    let _6: ();
    let mut _7: &mut proc_macro2::TokenStream;
    let _8: ();
    let mut _9: &mut proc_macro2::TokenStream;
    let _10: &str;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: &str;
    let _16: ();
    let mut _17: &mut proc_macro2::TokenStream;
    let _18: ();
    let mut _19: &mut proc_macro2::TokenStream;
    let _20: &str;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let mut _26: proc_macro2::TokenStream;
    let _27: ();
    let mut _28: &mut proc_macro2::TokenStream;
    let _29: ();
    let mut _30: &mut proc_macro2::TokenStream;
    let _31: &str;
    let _32: ();
    let mut _33: &mut proc_macro2::TokenStream;
    let _34: ();
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: &str;
    let _37: ();
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: &str;
    let _42: ();
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: &str;
    let mut _47: proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: ();
    let mut _51: &mut proc_macro2::TokenStream;
    let _52: &str;
    let _53: ();
    let mut _54: &mut proc_macro2::TokenStream;
    let _55: ();
    let mut _56: &mut proc_macro2::TokenStream;
    let _57: &str;
    let _58: ();
    let mut _59: &mut proc_macro2::TokenStream;
    let _60: ();
    let mut _61: &mut proc_macro2::TokenStream;
    let _62: &str;
    let _63: ();
    let mut _64: &mut proc_macro2::TokenStream;
    let _65: ();
    let mut _66: &mut proc_macro2::TokenStream;
    let _67: &str;
    let mut _68: proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let mut _72: &mut proc_macro2::TokenStream;
    let _73: &str;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let mut _77: &mut proc_macro2::TokenStream;
    let _78: &str;
    let _79: ();
    let mut _80: &mut proc_macro2::TokenStream;
    let _81: ();
    let mut _82: &mut proc_macro2::TokenStream;
    let _83: &str;
    let _84: ();
    let mut _85: &mut proc_macro2::TokenStream;
    let _86: ();
    let mut _87: &mut proc_macro2::TokenStream;
    let _88: &str;
    let mut _89: proc_macro2::TokenStream;
    let _90: ();
    let mut _91: &mut proc_macro2::TokenStream;
    let _92: ();
    let mut _93: &mut proc_macro2::TokenStream;
    let _94: &str;
    let _95: ();
    let mut _96: &mut proc_macro2::TokenStream;
    let _97: ();
    let mut _98: &mut proc_macro2::TokenStream;
    let _99: &str;
    let _100: ();
    let mut _101: &mut proc_macro2::TokenStream;
    let _102: ();
    let mut _103: &mut proc_macro2::TokenStream;
    let _104: &str;
    let _105: ();
    let mut _106: &mut proc_macro2::TokenStream;
    let _107: ();
    let mut _108: &mut proc_macro2::TokenStream;
    let _109: &str;
    let mut _110: proc_macro2::TokenStream;
    let _111: ();
    let mut _112: &mut proc_macro2::TokenStream;
    let _113: ();
    let mut _114: &mut proc_macro2::TokenStream;
    let _115: &str;
    let _116: ();
    let mut _117: &mut proc_macro2::TokenStream;
    let _118: ();
    let mut _119: &mut proc_macro2::TokenStream;
    let _120: &str;
    let _121: ();
    let mut _122: &mut proc_macro2::TokenStream;
    let _123: ();
    let mut _124: &mut proc_macro2::TokenStream;
    let _125: &str;
    let _126: ();
    let mut _127: &mut proc_macro2::TokenStream;
    let _128: ();
    let mut _129: &mut proc_macro2::TokenStream;
    let _130: &str;
    let mut _131: proc_macro2::TokenStream;
    let _132: ();
    let mut _133: &mut proc_macro2::TokenStream;
    let _134: ();
    let mut _135: &mut proc_macro2::TokenStream;
    let _136: &str;
    let _137: ();
    let mut _138: &mut proc_macro2::TokenStream;
    let _139: ();
    let mut _140: &mut proc_macro2::TokenStream;
    let _141: &str;
    let _142: ();
    let mut _143: &mut proc_macro2::TokenStream;
    let _144: ();
    let mut _145: &mut proc_macro2::TokenStream;
    let _146: &str;
    let _147: ();
    let mut _148: &mut proc_macro2::TokenStream;
    let _149: ();
    let mut _150: &mut proc_macro2::TokenStream;
    let _151: &str;
    let mut _152: proc_macro2::TokenStream;
    let _153: ();
    let mut _154: &mut proc_macro2::TokenStream;
    let _155: ();
    let mut _156: &mut proc_macro2::TokenStream;
    let _157: &str;
    let _158: ();
    let mut _159: &mut proc_macro2::TokenStream;
    let _160: ();
    let mut _161: &mut proc_macro2::TokenStream;
    let _162: &str;
    let _163: ();
    let mut _164: &mut proc_macro2::TokenStream;
    let _165: ();
    let mut _166: &mut proc_macro2::TokenStream;
    let _167: &str;
    let _168: ();
    let mut _169: &mut proc_macro2::TokenStream;
    let _170: ();
    let mut _171: &mut proc_macro2::TokenStream;
    let _172: &str;
    let mut _173: proc_macro2::TokenStream;
    let _174: ();
    let mut _175: &mut proc_macro2::TokenStream;
    let _176: ();
    let mut _177: &mut proc_macro2::TokenStream;
    let _178: &str;
    let _179: ();
    let mut _180: &mut proc_macro2::TokenStream;
    let _181: ();
    let mut _182: &mut proc_macro2::TokenStream;
    let _183: &str;
    let _184: ();
    let mut _185: &mut proc_macro2::TokenStream;
    let _186: ();
    let mut _187: &mut proc_macro2::TokenStream;
    let _188: &str;
    let _189: ();
    let mut _190: &mut proc_macro2::TokenStream;
    let _191: ();
    let mut _192: &mut proc_macro2::TokenStream;
    let _193: &str;
    let _194: ();
    let mut _195: proc_macro2::TokenStream;
    scope 1 {
        debug method_tokens => _3;
    }
    scope 2 {
        debug _s => _5;
    }
    scope 3 {
        debug _s => _26;
    }
    scope 4 {
        debug _s => _47;
    }
    scope 5 {
        debug _s => _68;
    }
    scope 6 {
        debug _s => _89;
    }
    scope 7 {
        debug _s => _110;
    }
    scope 8 {
        debug _s => _131;
    }
    scope 9 {
        debug _s => _152;
    }
    scope 10 {
        debug _s => _173;
    }

    bb0: {
        _4 = discriminant(((*_1).0: rocket_http::Method));
        switchInt(move _4) -> [0: bb3, 1: bb13, 2: bb23, 3: bb33, 4: bb43, 5: bb53, 6: bb63, 7: bb73, 8: bb1, otherwise: bb2];
    }

    bb1: {
        _173 = TokenStream2::new() -> [return: bb83, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = TokenStream2::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = &mut _5;
        _6 = push_colon2(_7) -> [return: bb5, unwind: bb102];
    }

    bb5: {
        _9 = &mut _5;
        _10 = const "rocket";
        _8 = push_ident(_9, _10) -> [return: bb6, unwind: bb102];
    }

    bb6: {
        _12 = &mut _5;
        _11 = push_colon2(_12) -> [return: bb7, unwind: bb102];
    }

    bb7: {
        _14 = &mut _5;
        _15 = const "http";
        _13 = push_ident(_14, _15) -> [return: bb8, unwind: bb102];
    }

    bb8: {
        _17 = &mut _5;
        _16 = push_colon2(_17) -> [return: bb9, unwind: bb102];
    }

    bb9: {
        _19 = &mut _5;
        _20 = const "Method";
        _18 = push_ident(_19, _20) -> [return: bb10, unwind: bb102];
    }

    bb10: {
        _22 = &mut _5;
        _21 = push_colon2(_22) -> [return: bb11, unwind: bb102];
    }

    bb11: {
        _24 = &mut _5;
        _25 = const "Get";
        _23 = push_ident(_24, _25) -> [return: bb12, unwind: bb102];
    }

    bb12: {
        _3 = move _5;
        goto -> bb92;
    }

    bb13: {
        _26 = TokenStream2::new() -> [return: bb14, unwind continue];
    }

    bb14: {
        _28 = &mut _26;
        _27 = push_colon2(_28) -> [return: bb15, unwind: bb101];
    }

    bb15: {
        _30 = &mut _26;
        _31 = const "rocket";
        _29 = push_ident(_30, _31) -> [return: bb16, unwind: bb101];
    }

    bb16: {
        _33 = &mut _26;
        _32 = push_colon2(_33) -> [return: bb17, unwind: bb101];
    }

    bb17: {
        _35 = &mut _26;
        _36 = const "http";
        _34 = push_ident(_35, _36) -> [return: bb18, unwind: bb101];
    }

    bb18: {
        _38 = &mut _26;
        _37 = push_colon2(_38) -> [return: bb19, unwind: bb101];
    }

    bb19: {
        _40 = &mut _26;
        _41 = const "Method";
        _39 = push_ident(_40, _41) -> [return: bb20, unwind: bb101];
    }

    bb20: {
        _43 = &mut _26;
        _42 = push_colon2(_43) -> [return: bb21, unwind: bb101];
    }

    bb21: {
        _45 = &mut _26;
        _46 = const "Put";
        _44 = push_ident(_45, _46) -> [return: bb22, unwind: bb101];
    }

    bb22: {
        _3 = move _26;
        goto -> bb92;
    }

    bb23: {
        _47 = TokenStream2::new() -> [return: bb24, unwind continue];
    }

    bb24: {
        _49 = &mut _47;
        _48 = push_colon2(_49) -> [return: bb25, unwind: bb100];
    }

    bb25: {
        _51 = &mut _47;
        _52 = const "rocket";
        _50 = push_ident(_51, _52) -> [return: bb26, unwind: bb100];
    }

    bb26: {
        _54 = &mut _47;
        _53 = push_colon2(_54) -> [return: bb27, unwind: bb100];
    }

    bb27: {
        _56 = &mut _47;
        _57 = const "http";
        _55 = push_ident(_56, _57) -> [return: bb28, unwind: bb100];
    }

    bb28: {
        _59 = &mut _47;
        _58 = push_colon2(_59) -> [return: bb29, unwind: bb100];
    }

    bb29: {
        _61 = &mut _47;
        _62 = const "Method";
        _60 = push_ident(_61, _62) -> [return: bb30, unwind: bb100];
    }

    bb30: {
        _64 = &mut _47;
        _63 = push_colon2(_64) -> [return: bb31, unwind: bb100];
    }

    bb31: {
        _66 = &mut _47;
        _67 = const "Post";
        _65 = push_ident(_66, _67) -> [return: bb32, unwind: bb100];
    }

    bb32: {
        _3 = move _47;
        goto -> bb92;
    }

    bb33: {
        _68 = TokenStream2::new() -> [return: bb34, unwind continue];
    }

    bb34: {
        _70 = &mut _68;
        _69 = push_colon2(_70) -> [return: bb35, unwind: bb99];
    }

    bb35: {
        _72 = &mut _68;
        _73 = const "rocket";
        _71 = push_ident(_72, _73) -> [return: bb36, unwind: bb99];
    }

    bb36: {
        _75 = &mut _68;
        _74 = push_colon2(_75) -> [return: bb37, unwind: bb99];
    }

    bb37: {
        _77 = &mut _68;
        _78 = const "http";
        _76 = push_ident(_77, _78) -> [return: bb38, unwind: bb99];
    }

    bb38: {
        _80 = &mut _68;
        _79 = push_colon2(_80) -> [return: bb39, unwind: bb99];
    }

    bb39: {
        _82 = &mut _68;
        _83 = const "Method";
        _81 = push_ident(_82, _83) -> [return: bb40, unwind: bb99];
    }

    bb40: {
        _85 = &mut _68;
        _84 = push_colon2(_85) -> [return: bb41, unwind: bb99];
    }

    bb41: {
        _87 = &mut _68;
        _88 = const "Delete";
        _86 = push_ident(_87, _88) -> [return: bb42, unwind: bb99];
    }

    bb42: {
        _3 = move _68;
        goto -> bb92;
    }

    bb43: {
        _89 = TokenStream2::new() -> [return: bb44, unwind continue];
    }

    bb44: {
        _91 = &mut _89;
        _90 = push_colon2(_91) -> [return: bb45, unwind: bb98];
    }

    bb45: {
        _93 = &mut _89;
        _94 = const "rocket";
        _92 = push_ident(_93, _94) -> [return: bb46, unwind: bb98];
    }

    bb46: {
        _96 = &mut _89;
        _95 = push_colon2(_96) -> [return: bb47, unwind: bb98];
    }

    bb47: {
        _98 = &mut _89;
        _99 = const "http";
        _97 = push_ident(_98, _99) -> [return: bb48, unwind: bb98];
    }

    bb48: {
        _101 = &mut _89;
        _100 = push_colon2(_101) -> [return: bb49, unwind: bb98];
    }

    bb49: {
        _103 = &mut _89;
        _104 = const "Method";
        _102 = push_ident(_103, _104) -> [return: bb50, unwind: bb98];
    }

    bb50: {
        _106 = &mut _89;
        _105 = push_colon2(_106) -> [return: bb51, unwind: bb98];
    }

    bb51: {
        _108 = &mut _89;
        _109 = const "Options";
        _107 = push_ident(_108, _109) -> [return: bb52, unwind: bb98];
    }

    bb52: {
        _3 = move _89;
        goto -> bb92;
    }

    bb53: {
        _110 = TokenStream2::new() -> [return: bb54, unwind continue];
    }

    bb54: {
        _112 = &mut _110;
        _111 = push_colon2(_112) -> [return: bb55, unwind: bb97];
    }

    bb55: {
        _114 = &mut _110;
        _115 = const "rocket";
        _113 = push_ident(_114, _115) -> [return: bb56, unwind: bb97];
    }

    bb56: {
        _117 = &mut _110;
        _116 = push_colon2(_117) -> [return: bb57, unwind: bb97];
    }

    bb57: {
        _119 = &mut _110;
        _120 = const "http";
        _118 = push_ident(_119, _120) -> [return: bb58, unwind: bb97];
    }

    bb58: {
        _122 = &mut _110;
        _121 = push_colon2(_122) -> [return: bb59, unwind: bb97];
    }

    bb59: {
        _124 = &mut _110;
        _125 = const "Method";
        _123 = push_ident(_124, _125) -> [return: bb60, unwind: bb97];
    }

    bb60: {
        _127 = &mut _110;
        _126 = push_colon2(_127) -> [return: bb61, unwind: bb97];
    }

    bb61: {
        _129 = &mut _110;
        _130 = const "Head";
        _128 = push_ident(_129, _130) -> [return: bb62, unwind: bb97];
    }

    bb62: {
        _3 = move _110;
        goto -> bb92;
    }

    bb63: {
        _131 = TokenStream2::new() -> [return: bb64, unwind continue];
    }

    bb64: {
        _133 = &mut _131;
        _132 = push_colon2(_133) -> [return: bb65, unwind: bb96];
    }

    bb65: {
        _135 = &mut _131;
        _136 = const "rocket";
        _134 = push_ident(_135, _136) -> [return: bb66, unwind: bb96];
    }

    bb66: {
        _138 = &mut _131;
        _137 = push_colon2(_138) -> [return: bb67, unwind: bb96];
    }

    bb67: {
        _140 = &mut _131;
        _141 = const "http";
        _139 = push_ident(_140, _141) -> [return: bb68, unwind: bb96];
    }

    bb68: {
        _143 = &mut _131;
        _142 = push_colon2(_143) -> [return: bb69, unwind: bb96];
    }

    bb69: {
        _145 = &mut _131;
        _146 = const "Method";
        _144 = push_ident(_145, _146) -> [return: bb70, unwind: bb96];
    }

    bb70: {
        _148 = &mut _131;
        _147 = push_colon2(_148) -> [return: bb71, unwind: bb96];
    }

    bb71: {
        _150 = &mut _131;
        _151 = const "Trace";
        _149 = push_ident(_150, _151) -> [return: bb72, unwind: bb96];
    }

    bb72: {
        _3 = move _131;
        goto -> bb92;
    }

    bb73: {
        _152 = TokenStream2::new() -> [return: bb74, unwind continue];
    }

    bb74: {
        _154 = &mut _152;
        _153 = push_colon2(_154) -> [return: bb75, unwind: bb95];
    }

    bb75: {
        _156 = &mut _152;
        _157 = const "rocket";
        _155 = push_ident(_156, _157) -> [return: bb76, unwind: bb95];
    }

    bb76: {
        _159 = &mut _152;
        _158 = push_colon2(_159) -> [return: bb77, unwind: bb95];
    }

    bb77: {
        _161 = &mut _152;
        _162 = const "http";
        _160 = push_ident(_161, _162) -> [return: bb78, unwind: bb95];
    }

    bb78: {
        _164 = &mut _152;
        _163 = push_colon2(_164) -> [return: bb79, unwind: bb95];
    }

    bb79: {
        _166 = &mut _152;
        _167 = const "Method";
        _165 = push_ident(_166, _167) -> [return: bb80, unwind: bb95];
    }

    bb80: {
        _169 = &mut _152;
        _168 = push_colon2(_169) -> [return: bb81, unwind: bb95];
    }

    bb81: {
        _171 = &mut _152;
        _172 = const "Connect";
        _170 = push_ident(_171, _172) -> [return: bb82, unwind: bb95];
    }

    bb82: {
        _3 = move _152;
        goto -> bb92;
    }

    bb83: {
        _175 = &mut _173;
        _174 = push_colon2(_175) -> [return: bb84, unwind: bb94];
    }

    bb84: {
        _177 = &mut _173;
        _178 = const "rocket";
        _176 = push_ident(_177, _178) -> [return: bb85, unwind: bb94];
    }

    bb85: {
        _180 = &mut _173;
        _179 = push_colon2(_180) -> [return: bb86, unwind: bb94];
    }

    bb86: {
        _182 = &mut _173;
        _183 = const "http";
        _181 = push_ident(_182, _183) -> [return: bb87, unwind: bb94];
    }

    bb87: {
        _185 = &mut _173;
        _184 = push_colon2(_185) -> [return: bb88, unwind: bb94];
    }

    bb88: {
        _187 = &mut _173;
        _188 = const "Method";
        _186 = push_ident(_187, _188) -> [return: bb89, unwind: bb94];
    }

    bb89: {
        _190 = &mut _173;
        _189 = push_colon2(_190) -> [return: bb90, unwind: bb94];
    }

    bb90: {
        _192 = &mut _173;
        _193 = const "Patch";
        _191 = push_ident(_192, _193) -> [return: bb91, unwind: bb94];
    }

    bb91: {
        _3 = move _173;
        goto -> bb92;
    }

    bb92: {
        _195 = move _3;
        _194 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _195) -> [return: bb93, unwind continue];
    }

    bb93: {
        return;
    }

    bb94 (cleanup): {
        drop(_173) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb95 (cleanup): {
        drop(_152) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb96 (cleanup): {
        drop(_131) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        drop(_110) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        drop(_89) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb99 (cleanup): {
        drop(_68) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        drop(_47) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb101 (cleanup): {
        drop(_26) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        drop(_5) -> [return: bb103, unwind terminate(cleanup)];
    }

    bb103 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:150:1: 150:43>::to_tokens(_1: &Optional<T>, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: proc_macro2::TokenStream;
    let mut _4: isize;
    let _5: &T;
    let mut _8: &T;
    let _9: ();
    let mut _10: &mut proc_macro2::TokenStream;
    let _11: ();
    let mut _12: &mut proc_macro2::TokenStream;
    let mut _13: proc_macro2::Delimiter;
    let mut _14: proc_macro2::TokenStream;
    let _16: ();
    let _17: &&T;
    let mut _18: &mut proc_macro2::TokenStream;
    let mut _19: proc_macro2::TokenStream;
    let _20: ();
    let mut _21: &mut proc_macro2::TokenStream;
    let _22: ();
    let mut _23: proc_macro2::TokenStream;
    scope 1 {
        debug opt_tokens => _3;
    }
    scope 2 {
        debug val => _5;
        let mut _6: proc_macro2::TokenStream;
        scope 3 {
            debug _s => _6;
            let _7: proc_macro2::Span;
            scope 4 {
                debug _span => _7;
                let mut _15: proc_macro2::TokenStream;
                let mut _25: &exports::StaticPath;
                scope 5 {
                    debug _s => _15;
                    scope 6 {
                    }
                }
            }
        }
    }
    scope 7 {
        debug _s => _19;
        let mut _24: &exports::StaticPath;
    }

    bb0: {
        _4 = discriminant(((*_1).0: std::option::Option<T>));
        switchInt(move _4) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _19 = TokenStream2::new() -> [return: bb10, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = &((((*_1).0: std::option::Option<T>) as Some).0: T);
        _6 = TokenStream2::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = _5;
        _7 = <T as devise::Spanned>::span(move _8) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _25 = const _;
        _10 = &mut _6;
        _9 = <StaticPath as ToTokens>::to_tokens(_25, _10) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _12 = &mut _6;
        _13 = proc_macro2::Delimiter::Parenthesis;
        _15 = TokenStream2::new() -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _17 = &_5;
        _18 = &mut _15;
        _16 = <&T as ToTokens>::to_tokens(_17, _18) -> [return: bb8, unwind: bb15];
    }

    bb8: {
        _14 = move _15;
        _11 = push_group_spanned(_12, _7, move _13, move _14) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _3 = move _6;
        goto -> bb12;
    }

    bb10: {
        _24 = const _;
        _21 = &mut _19;
        _20 = <StaticPath as ToTokens>::to_tokens(_24, _21) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _3 = move _19;
        goto -> bb12;
    }

    bb12: {
        _23 = move _3;
        _22 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_19) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_15) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_6) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

promoted[0] in http_codegen::<impl at core/codegen/src/http_codegen.rs:150:1: 150:43>::to_tokens: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[1] in http_codegen::<impl at core/codegen/src/http_codegen.rs:150:1: 150:43>::to_tokens: &StaticPath = {
    let mut _0: &exports::StaticPath;
    let mut _1: exports::StaticPath;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:164:1: 164:29>::to_tokens(_1: &http_codegen::Origin<'_>, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &rocket_http::uri::Origin<'_>;
    let _4: proc_macro2::Span;
    let mut _5: (&rocket_http::uri::Origin<'_>, proc_macro2::Span);
    let mut _6: &rocket_http::uri::Origin<'_>;
    let mut _7: proc_macro2::Span;
    let mut _9: rocket_http::uri::Origin<'_>;
    let mut _11: std::option::Option<proc_macro2::Span>;
    let mut _13: &rocket_http::uri::Path<'_>;
    let _14: rocket_http::uri::Path<'_>;
    let mut _15: &rocket_http::uri::Origin<'_>;
    let mut _17: std::option::Option<&str>;
    let mut _18: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _19: &rocket_http::uri::Origin<'_>;
    let _20: ();
    let mut _21: proc_macro2::TokenStream;
    let _23: ();
    let _24: &exports::StaticPath;
    let mut _25: &mut proc_macro2::TokenStream;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let _33: ();
    let mut _34: &mut proc_macro2::TokenStream;
    let _35: &str;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let mut _38: proc_macro2::Delimiter;
    let mut _39: proc_macro2::TokenStream;
    let _41: ();
    let _42: &&str;
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let _47: &http_codegen::Optional<&str>;
    let mut _48: &mut proc_macro2::TokenStream;
    scope 1 {
        debug origin => _3;
        debug span => _4;
        let _8: rocket_http::uri::Origin<'_>;
        scope 2 {
            debug origin => _8;
            scope 3 {
                debug _uri => _10;
                let _12: &str;
                scope 5 {
                    debug path => _12;
                    let _16: http_codegen::Optional<&str>;
                    scope 6 {
                        debug query => _16;
                        let mut _22: proc_macro2::TokenStream;
                        scope 7 {
                            debug _s => _22;
                            scope 8 {
                                debug _span => _4;
                                let mut _40: proc_macro2::TokenStream;
                                scope 9 {
                                    debug _s => _40;
                                    scope 10 {
                                        debug _span => _4;
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 4 {
                let _10: exports::StaticPath;
            }
        }
    }

    bb0: {
        _6 = ((*_1).0: &rocket_http::uri::Origin<'_>);
        _7 = ((*_1).1: proc_macro2::Span);
        _5 = (move _6, move _7);
        _3 = (_5.0: &rocket_http::uri::Origin<'_>);
        _4 = (_5.1: proc_macro2::Span);
        _9 = <rocket_http::uri::Origin<'_> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = rocket_http::uri::Origin::<'_>::into_normalized(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = Option::<proc_macro2::Span>::Some(_4);
        _10 = StaticPath(move _11, const "::rocket::http::uri");
        _15 = &_8;
        _14 = rocket_http::uri::Origin::<'_>::path(move _15) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _13 = &_14;
        _12 = rocket_http::uri::Path::<'_>::as_str(move _13) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _19 = &_8;
        _18 = rocket_http::uri::Origin::<'_>::query(move _19) -> [return: bb5, unwind: bb22];
    }

    bb5: {
        _17 = Option::<rocket_http::uri::Query<'_>>::map::<&str, {closure@core/codegen/src/http_codegen.rs:171:49: 171:52}>(move _18, const ZeroSized: {closure@core/codegen/src/http_codegen.rs:171:49: 171:52}) -> [return: bb6, unwind: bb22];
    }

    bb6: {
        _16 = Optional::<&str>(move _17);
        _22 = TokenStream2::new() -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _24 = &_10;
        _25 = &mut _22;
        _23 = <StaticPath as ToTokens>::to_tokens(_24, _25) -> [return: bb8, unwind: bb21];
    }

    bb8: {
        _27 = &mut _22;
        _26 = push_colon2_spanned(_27, _4) -> [return: bb9, unwind: bb21];
    }

    bb9: {
        _29 = &mut _22;
        _30 = const "Origin";
        _28 = push_ident_spanned(_29, _4, _30) -> [return: bb10, unwind: bb21];
    }

    bb10: {
        _32 = &mut _22;
        _31 = push_colon2_spanned(_32, _4) -> [return: bb11, unwind: bb21];
    }

    bb11: {
        _34 = &mut _22;
        _35 = const "const_new";
        _33 = push_ident_spanned(_34, _4, _35) -> [return: bb12, unwind: bb21];
    }

    bb12: {
        _37 = &mut _22;
        _38 = proc_macro2::Delimiter::Parenthesis;
        _40 = TokenStream2::new() -> [return: bb13, unwind: bb21];
    }

    bb13: {
        _42 = &_12;
        _43 = &mut _40;
        _41 = <&str as ToTokens>::to_tokens(_42, _43) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _45 = &mut _40;
        _44 = push_comma_spanned(_45, _4) -> [return: bb15, unwind: bb20];
    }

    bb15: {
        _47 = &_16;
        _48 = &mut _40;
        _46 = <Optional<&str> as ToTokens>::to_tokens(_47, _48) -> [return: bb16, unwind: bb20];
    }

    bb16: {
        _39 = move _40;
        _36 = push_group_spanned(_37, _4, move _38, move _39) -> [return: bb17, unwind: bb21];
    }

    bb17: {
        _21 = move _22;
        _20 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _21) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        drop(_8) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_40) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_22) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_8) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:164:1: 164:29>::to_tokens::{closure#0}(_1: {closure@core/codegen/src/http_codegen.rs:171:49: 171:52}, _2: rocket_http::uri::Query<'_>) -> &str {
    debug q => _2;
    let mut _0: &str;
    let mut _3: &rocket_http::uri::Query<'_>;

    bb0: {
        _3 = &_2;
        _0 = rocket_http::uri::Query::<'_>::as_str(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:178:1: 178:31>::to_tokens(_1: &http_codegen::Absolute<'_>, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &rocket_http::uri::Absolute<'_>;
    let _4: proc_macro2::Span;
    let mut _5: (&rocket_http::uri::Absolute<'_>, proc_macro2::Span);
    let mut _6: &rocket_http::uri::Absolute<'_>;
    let mut _7: proc_macro2::Span;
    let mut _9: std::option::Option<proc_macro2::Span>;
    let mut _10: proc_macro2::Span;
    let mut _12: rocket_http::uri::Absolute<'_>;
    let mut _14: &rocket_http::uri::Absolute<'_>;
    let mut _16: std::option::Option<http_codegen::Authority<'_>>;
    let mut _17: std::option::Option<&rocket_http::uri::Authority<'_>>;
    let mut _18: &rocket_http::uri::Absolute<'_>;
    let mut _19: {closure@core/codegen/src/http_codegen.rs:185:54: 185:57};
    let mut _20: &proc_macro2::Span;
    let mut _22: &rocket_http::uri::Path<'_>;
    let _23: rocket_http::uri::Path<'_>;
    let mut _24: &rocket_http::uri::Absolute<'_>;
    let mut _26: std::option::Option<&str>;
    let mut _27: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _28: &rocket_http::uri::Absolute<'_>;
    let _29: ();
    let mut _30: proc_macro2::TokenStream;
    let _33: ();
    let _34: &exports::StaticPath;
    let mut _35: &mut proc_macro2::TokenStream;
    let _36: ();
    let mut _37: &mut proc_macro2::TokenStream;
    let _38: ();
    let mut _39: &mut proc_macro2::TokenStream;
    let _40: &str;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let mut _48: proc_macro2::Delimiter;
    let mut _49: proc_macro2::TokenStream;
    let _51: ();
    let _52: &&str;
    let mut _53: &mut proc_macro2::TokenStream;
    let _54: ();
    let mut _55: &mut proc_macro2::TokenStream;
    let _56: ();
    let _57: &http_codegen::Optional<http_codegen::Authority<'_>>;
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let _62: &&str;
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let _67: &http_codegen::Optional<&str>;
    let mut _68: &mut proc_macro2::TokenStream;
    scope 1 {
        debug absolute => _3;
        debug span => _4;
        scope 2 {
            debug _uri => _8;
            let _11: rocket_http::uri::Absolute<'_>;
            scope 4 {
                debug absolute => _11;
                let _13: &str;
                scope 5 {
                    debug scheme => _13;
                    let _15: http_codegen::Optional<http_codegen::Authority<'_>>;
                    scope 6 {
                        debug auth => _15;
                        let _21: &str;
                        scope 7 {
                            debug path => _21;
                            let _25: http_codegen::Optional<&str>;
                            scope 8 {
                                debug query => _25;
                                let mut _31: proc_macro2::TokenStream;
                                scope 9 {
                                    debug _s => _31;
                                    let _32: proc_macro2::Span;
                                    scope 10 {
                                        debug _span => _32;
                                        let mut _50: proc_macro2::TokenStream;
                                        scope 11 {
                                            debug _s => _50;
                                            scope 12 {
                                                debug _span => _32;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 3 {
            let _8: exports::StaticPath;
        }
    }

    bb0: {
        _6 = ((*_1).0: &rocket_http::uri::Absolute<'_>);
        _7 = ((*_1).1: proc_macro2::Span);
        _5 = (move _6, move _7);
        _3 = (_5.0: &rocket_http::uri::Absolute<'_>);
        _4 = (_5.1: proc_macro2::Span);
        _10 = _4;
        _9 = Option::<proc_macro2::Span>::Some(move _10);
        _8 = StaticPath(move _9, const "::rocket::http::uri");
        _12 = <rocket_http::uri::Absolute<'_> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = rocket_http::uri::Absolute::<'_>::into_normalized(move _12) -> [return: bb2, unwind continue];
    }

    bb2: {
        _14 = &_11;
        _13 = rocket_http::uri::Absolute::<'_>::scheme(move _14) -> [return: bb3, unwind: bb29];
    }

    bb3: {
        _18 = &_11;
        _17 = rocket_http::uri::Absolute::<'_>::authority(move _18) -> [return: bb4, unwind: bb29];
    }

    bb4: {
        _20 = &_4;
        _19 = {closure@core/codegen/src/http_codegen.rs:185:54: 185:57} { span: move _20 };
        _16 = Option::<&rocket_http::uri::Authority<'_>>::map::<http_codegen::Authority<'_>, {closure@core/codegen/src/http_codegen.rs:185:54: 185:57}>(move _17, move _19) -> [return: bb5, unwind: bb29];
    }

    bb5: {
        _15 = Optional::<http_codegen::Authority<'_>>(move _16);
        _24 = &_11;
        _23 = rocket_http::uri::Absolute::<'_>::path(move _24) -> [return: bb6, unwind: bb29];
    }

    bb6: {
        _22 = &_23;
        _21 = rocket_http::uri::Path::<'_>::as_str(move _22) -> [return: bb7, unwind: bb29];
    }

    bb7: {
        _28 = &_11;
        _27 = rocket_http::uri::Absolute::<'_>::query(move _28) -> [return: bb8, unwind: bb29];
    }

    bb8: {
        _26 = Option::<rocket_http::uri::Query<'_>>::map::<&str, {closure@core/codegen/src/http_codegen.rs:187:51: 187:54}>(move _27, const ZeroSized: {closure@core/codegen/src/http_codegen.rs:187:51: 187:54}) -> [return: bb9, unwind: bb29];
    }

    bb9: {
        _25 = Optional::<&str>(move _26);
        _31 = TokenStream2::new() -> [return: bb10, unwind: bb29];
    }

    bb10: {
        _32 = _4;
        _34 = &_8;
        _35 = &mut _31;
        _33 = <StaticPath as ToTokens>::to_tokens(_34, _35) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _37 = &mut _31;
        _36 = push_colon2_spanned(_37, _32) -> [return: bb12, unwind: bb28];
    }

    bb12: {
        _39 = &mut _31;
        _40 = const "Absolute";
        _38 = push_ident_spanned(_39, _32, _40) -> [return: bb13, unwind: bb28];
    }

    bb13: {
        _42 = &mut _31;
        _41 = push_colon2_spanned(_42, _32) -> [return: bb14, unwind: bb28];
    }

    bb14: {
        _44 = &mut _31;
        _45 = const "const_new";
        _43 = push_ident_spanned(_44, _32, _45) -> [return: bb15, unwind: bb28];
    }

    bb15: {
        _47 = &mut _31;
        _48 = proc_macro2::Delimiter::Parenthesis;
        _50 = TokenStream2::new() -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _52 = &_13;
        _53 = &mut _50;
        _51 = <&str as ToTokens>::to_tokens(_52, _53) -> [return: bb17, unwind: bb27];
    }

    bb17: {
        _55 = &mut _50;
        _54 = push_comma_spanned(_55, _32) -> [return: bb18, unwind: bb27];
    }

    bb18: {
        _57 = &_15;
        _58 = &mut _50;
        _56 = <Optional<http_codegen::Authority<'_>> as ToTokens>::to_tokens(_57, _58) -> [return: bb19, unwind: bb27];
    }

    bb19: {
        _60 = &mut _50;
        _59 = push_comma_spanned(_60, _32) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        _62 = &_21;
        _63 = &mut _50;
        _61 = <&str as ToTokens>::to_tokens(_62, _63) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        _65 = &mut _50;
        _64 = push_comma_spanned(_65, _32) -> [return: bb22, unwind: bb27];
    }

    bb22: {
        _67 = &_25;
        _68 = &mut _50;
        _66 = <Optional<&str> as ToTokens>::to_tokens(_67, _68) -> [return: bb23, unwind: bb27];
    }

    bb23: {
        _49 = move _50;
        _46 = push_group_spanned(_47, _32, move _48, move _49) -> [return: bb24, unwind: bb28];
    }

    bb24: {
        _30 = move _31;
        _29 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _30) -> [return: bb25, unwind: bb29];
    }

    bb25: {
        drop(_11) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_50) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_31) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_11) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:178:1: 178:31>::to_tokens::{closure#0}(_1: {closure@core/codegen/src/http_codegen.rs:185:54: 185:57}, _2: &rocket_http::uri::Authority<'_>) -> http_codegen::Authority<'_> {
    debug a => _2;
    debug span => (*(_1.0: &proc_macro2::Span));
    let mut _0: http_codegen::Authority<'_>;
    let mut _3: proc_macro2::Span;
    let mut _4: &proc_macro2::Span;

    bb0: {
        _4 = deref_copy (_1.0: &proc_macro2::Span);
        _3 = (*_4);
        _0 = http_codegen::Authority::<'_>(_2, move _3);
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:178:1: 178:31>::to_tokens::{closure#1}(_1: {closure@core/codegen/src/http_codegen.rs:187:51: 187:54}, _2: rocket_http::uri::Query<'_>) -> &str {
    debug q => _2;
    let mut _0: &str;
    let mut _3: &rocket_http::uri::Query<'_>;

    bb0: {
        _3 = &_2;
        _0 = rocket_http::uri::Query::<'_>::as_str(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:194:1: 194:32>::to_tokens(_1: &http_codegen::Authority<'_>, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &rocket_http::uri::Authority<'_>;
    let _4: proc_macro2::Span;
    let mut _5: (&rocket_http::uri::Authority<'_>, proc_macro2::Span);
    let mut _6: &rocket_http::uri::Authority<'_>;
    let mut _7: proc_macro2::Span;
    let mut _9: std::option::Option<proc_macro2::Span>;
    let mut _11: std::option::Option<&str>;
    let mut _14: std::option::Option<u16>;
    let _15: ();
    let mut _16: proc_macro2::TokenStream;
    let _18: ();
    let _19: &exports::StaticPath;
    let mut _20: &mut proc_macro2::TokenStream;
    let _21: ();
    let mut _22: &mut proc_macro2::TokenStream;
    let _23: ();
    let mut _24: &mut proc_macro2::TokenStream;
    let _25: &str;
    let _26: ();
    let mut _27: &mut proc_macro2::TokenStream;
    let _28: ();
    let mut _29: &mut proc_macro2::TokenStream;
    let _30: &str;
    let _31: ();
    let mut _32: &mut proc_macro2::TokenStream;
    let mut _33: proc_macro2::Delimiter;
    let mut _34: proc_macro2::TokenStream;
    let _36: ();
    let _37: &http_codegen::Optional<&str>;
    let mut _38: &mut proc_macro2::TokenStream;
    let _39: ();
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let _42: &&str;
    let mut _43: &mut proc_macro2::TokenStream;
    let _44: ();
    let mut _45: &mut proc_macro2::TokenStream;
    let _46: ();
    let _47: &http_codegen::Optional<u16>;
    let mut _48: &mut proc_macro2::TokenStream;
    scope 1 {
        debug authority => _3;
        debug span => _4;
        scope 2 {
            debug _uri => _8;
            let _10: http_codegen::Optional<&str>;
            scope 4 {
                debug user_info => _10;
                let _12: &str;
                scope 5 {
                    debug host => _12;
                    let _13: http_codegen::Optional<u16>;
                    scope 6 {
                        debug port => _13;
                        let mut _17: proc_macro2::TokenStream;
                        scope 7 {
                            debug _s => _17;
                            scope 8 {
                                debug _span => _4;
                                let mut _35: proc_macro2::TokenStream;
                                scope 9 {
                                    debug _s => _35;
                                    scope 10 {
                                        debug _span => _4;
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 3 {
            let _8: exports::StaticPath;
        }
    }

    bb0: {
        _6 = ((*_1).0: &rocket_http::uri::Authority<'_>);
        _7 = ((*_1).1: proc_macro2::Span);
        _5 = (move _6, move _7);
        _3 = (_5.0: &rocket_http::uri::Authority<'_>);
        _4 = (_5.1: proc_macro2::Span);
        _9 = Option::<proc_macro2::Span>::Some(_4);
        _8 = StaticPath(move _9, const "::rocket::http::uri");
        _11 = rocket_http::uri::Authority::<'_>::user_info(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = Optional::<&str>(move _11);
        _12 = rocket_http::uri::Authority::<'_>::host(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _14 = rocket_http::uri::Authority::<'_>::port(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = Optional::<u16>(move _14);
        _17 = TokenStream2::new() -> [return: bb4, unwind continue];
    }

    bb4: {
        _19 = &_8;
        _20 = &mut _17;
        _18 = <StaticPath as ToTokens>::to_tokens(_19, _20) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _22 = &mut _17;
        _21 = push_colon2_spanned(_22, _4) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _24 = &mut _17;
        _25 = const "Authority";
        _23 = push_ident_spanned(_24, _4, _25) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _27 = &mut _17;
        _26 = push_colon2_spanned(_27, _4) -> [return: bb8, unwind: bb19];
    }

    bb8: {
        _29 = &mut _17;
        _30 = const "const_new";
        _28 = push_ident_spanned(_29, _4, _30) -> [return: bb9, unwind: bb19];
    }

    bb9: {
        _32 = &mut _17;
        _33 = proc_macro2::Delimiter::Parenthesis;
        _35 = TokenStream2::new() -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _37 = &_10;
        _38 = &mut _35;
        _36 = <Optional<&str> as ToTokens>::to_tokens(_37, _38) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _40 = &mut _35;
        _39 = push_comma_spanned(_40, _4) -> [return: bb12, unwind: bb18];
    }

    bb12: {
        _42 = &_12;
        _43 = &mut _35;
        _41 = <&str as ToTokens>::to_tokens(_42, _43) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _45 = &mut _35;
        _44 = push_comma_spanned(_45, _4) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _47 = &_13;
        _48 = &mut _35;
        _46 = <Optional<u16> as ToTokens>::to_tokens(_47, _48) -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _34 = move _35;
        _31 = push_group_spanned(_32, _4, move _33, move _34) -> [return: bb16, unwind: bb19];
    }

    bb16: {
        _16 = move _17;
        _15 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _16) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_35) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_17) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:208:1: 208:32>::to_tokens(_1: &http_codegen::Reference<'_>, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let _3: &rocket_http::uri::Reference<'_>;
    let _4: proc_macro2::Span;
    let mut _5: (&rocket_http::uri::Reference<'_>, proc_macro2::Span);
    let mut _6: &rocket_http::uri::Reference<'_>;
    let mut _7: proc_macro2::Span;
    let mut _9: std::option::Option<proc_macro2::Span>;
    let mut _10: proc_macro2::Span;
    let mut _12: rocket_http::uri::Reference<'_>;
    let mut _14: std::option::Option<&str>;
    let mut _15: &rocket_http::uri::Reference<'_>;
    let mut _17: std::option::Option<http_codegen::Authority<'_>>;
    let mut _18: std::option::Option<&rocket_http::uri::Authority<'_>>;
    let mut _19: &rocket_http::uri::Reference<'_>;
    let mut _20: {closure@core/codegen/src/http_codegen.rs:215:55: 215:58};
    let mut _21: &proc_macro2::Span;
    let mut _23: &rocket_http::uri::Path<'_>;
    let _24: rocket_http::uri::Path<'_>;
    let mut _25: &rocket_http::uri::Reference<'_>;
    let mut _27: std::option::Option<&str>;
    let mut _28: std::option::Option<rocket_http::uri::Query<'_>>;
    let mut _29: &rocket_http::uri::Reference<'_>;
    let mut _31: std::option::Option<&str>;
    let mut _32: std::option::Option<&rocket_http::RawStr>;
    let mut _33: &rocket_http::uri::Reference<'_>;
    let _34: ();
    let mut _35: proc_macro2::TokenStream;
    let _38: ();
    let _39: &exports::StaticPath;
    let mut _40: &mut proc_macro2::TokenStream;
    let _41: ();
    let mut _42: &mut proc_macro2::TokenStream;
    let _43: ();
    let mut _44: &mut proc_macro2::TokenStream;
    let _45: &str;
    let _46: ();
    let mut _47: &mut proc_macro2::TokenStream;
    let _48: ();
    let mut _49: &mut proc_macro2::TokenStream;
    let _50: &str;
    let _51: ();
    let mut _52: &mut proc_macro2::TokenStream;
    let mut _53: proc_macro2::Delimiter;
    let mut _54: proc_macro2::TokenStream;
    let _56: ();
    let _57: &http_codegen::Optional<&str>;
    let mut _58: &mut proc_macro2::TokenStream;
    let _59: ();
    let mut _60: &mut proc_macro2::TokenStream;
    let _61: ();
    let _62: &http_codegen::Optional<http_codegen::Authority<'_>>;
    let mut _63: &mut proc_macro2::TokenStream;
    let _64: ();
    let mut _65: &mut proc_macro2::TokenStream;
    let _66: ();
    let _67: &&str;
    let mut _68: &mut proc_macro2::TokenStream;
    let _69: ();
    let mut _70: &mut proc_macro2::TokenStream;
    let _71: ();
    let _72: &http_codegen::Optional<&str>;
    let mut _73: &mut proc_macro2::TokenStream;
    let _74: ();
    let mut _75: &mut proc_macro2::TokenStream;
    let _76: ();
    let _77: &http_codegen::Optional<&str>;
    let mut _78: &mut proc_macro2::TokenStream;
    scope 1 {
        debug reference => _3;
        debug span => _4;
        scope 2 {
            debug _uri => _8;
            let _11: rocket_http::uri::Reference<'_>;
            scope 4 {
                debug reference => _11;
                let _13: http_codegen::Optional<&str>;
                scope 5 {
                    debug scheme => _13;
                    let _16: http_codegen::Optional<http_codegen::Authority<'_>>;
                    scope 6 {
                        debug auth => _16;
                        let _22: &str;
                        scope 7 {
                            debug path => _22;
                            let _26: http_codegen::Optional<&str>;
                            scope 8 {
                                debug query => _26;
                                let _30: http_codegen::Optional<&str>;
                                scope 9 {
                                    debug frag => _30;
                                    let mut _36: proc_macro2::TokenStream;
                                    scope 10 {
                                        debug _s => _36;
                                        let _37: proc_macro2::Span;
                                        scope 11 {
                                            debug _span => _37;
                                            let mut _55: proc_macro2::TokenStream;
                                            scope 12 {
                                                debug _s => _55;
                                                scope 13 {
                                                    debug _span => _37;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 3 {
            let _8: exports::StaticPath;
        }
    }

    bb0: {
        _6 = ((*_1).0: &rocket_http::uri::Reference<'_>);
        _7 = ((*_1).1: proc_macro2::Span);
        _5 = (move _6, move _7);
        _3 = (_5.0: &rocket_http::uri::Reference<'_>);
        _4 = (_5.1: proc_macro2::Span);
        _10 = _4;
        _9 = Option::<proc_macro2::Span>::Some(move _10);
        _8 = StaticPath(move _9, const "::rocket::http::uri");
        _12 = <rocket_http::uri::Reference<'_> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = rocket_http::uri::Reference::<'_>::into_normalized(move _12) -> [return: bb2, unwind continue];
    }

    bb2: {
        _15 = &_11;
        _14 = rocket_http::uri::Reference::<'_>::scheme(move _15) -> [return: bb3, unwind: bb33];
    }

    bb3: {
        _13 = Optional::<&str>(move _14);
        _19 = &_11;
        _18 = rocket_http::uri::Reference::<'_>::authority(move _19) -> [return: bb4, unwind: bb33];
    }

    bb4: {
        _21 = &_4;
        _20 = {closure@core/codegen/src/http_codegen.rs:215:55: 215:58} { span: move _21 };
        _17 = Option::<&rocket_http::uri::Authority<'_>>::map::<http_codegen::Authority<'_>, {closure@core/codegen/src/http_codegen.rs:215:55: 215:58}>(move _18, move _20) -> [return: bb5, unwind: bb33];
    }

    bb5: {
        _16 = Optional::<http_codegen::Authority<'_>>(move _17);
        _25 = &_11;
        _24 = rocket_http::uri::Reference::<'_>::path(move _25) -> [return: bb6, unwind: bb33];
    }

    bb6: {
        _23 = &_24;
        _22 = rocket_http::uri::Path::<'_>::as_str(move _23) -> [return: bb7, unwind: bb33];
    }

    bb7: {
        _29 = &_11;
        _28 = rocket_http::uri::Reference::<'_>::query(move _29) -> [return: bb8, unwind: bb33];
    }

    bb8: {
        _27 = Option::<rocket_http::uri::Query<'_>>::map::<&str, {closure@core/codegen/src/http_codegen.rs:217:52: 217:55}>(move _28, const ZeroSized: {closure@core/codegen/src/http_codegen.rs:217:52: 217:55}) -> [return: bb9, unwind: bb33];
    }

    bb9: {
        _26 = Optional::<&str>(move _27);
        _33 = &_11;
        _32 = rocket_http::uri::Reference::<'_>::fragment(move _33) -> [return: bb10, unwind: bb33];
    }

    bb10: {
        _31 = Option::<&RawStr>::map::<&str, {closure@core/codegen/src/http_codegen.rs:218:54: 218:57}>(move _32, const ZeroSized: {closure@core/codegen/src/http_codegen.rs:218:54: 218:57}) -> [return: bb11, unwind: bb33];
    }

    bb11: {
        _30 = Optional::<&str>(move _31);
        _36 = TokenStream2::new() -> [return: bb12, unwind: bb33];
    }

    bb12: {
        _37 = _4;
        _39 = &_8;
        _40 = &mut _36;
        _38 = <StaticPath as ToTokens>::to_tokens(_39, _40) -> [return: bb13, unwind: bb32];
    }

    bb13: {
        _42 = &mut _36;
        _41 = push_colon2_spanned(_42, _37) -> [return: bb14, unwind: bb32];
    }

    bb14: {
        _44 = &mut _36;
        _45 = const "Reference";
        _43 = push_ident_spanned(_44, _37, _45) -> [return: bb15, unwind: bb32];
    }

    bb15: {
        _47 = &mut _36;
        _46 = push_colon2_spanned(_47, _37) -> [return: bb16, unwind: bb32];
    }

    bb16: {
        _49 = &mut _36;
        _50 = const "const_new";
        _48 = push_ident_spanned(_49, _37, _50) -> [return: bb17, unwind: bb32];
    }

    bb17: {
        _52 = &mut _36;
        _53 = proc_macro2::Delimiter::Parenthesis;
        _55 = TokenStream2::new() -> [return: bb18, unwind: bb32];
    }

    bb18: {
        _57 = &_13;
        _58 = &mut _55;
        _56 = <Optional<&str> as ToTokens>::to_tokens(_57, _58) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        _60 = &mut _55;
        _59 = push_comma_spanned(_60, _37) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _62 = &_16;
        _63 = &mut _55;
        _61 = <Optional<http_codegen::Authority<'_>> as ToTokens>::to_tokens(_62, _63) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        _65 = &mut _55;
        _64 = push_comma_spanned(_65, _37) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _67 = &_22;
        _68 = &mut _55;
        _66 = <&str as ToTokens>::to_tokens(_67, _68) -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _70 = &mut _55;
        _69 = push_comma_spanned(_70, _37) -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _72 = &_26;
        _73 = &mut _55;
        _71 = <Optional<&str> as ToTokens>::to_tokens(_72, _73) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _75 = &mut _55;
        _74 = push_comma_spanned(_75, _37) -> [return: bb26, unwind: bb31];
    }

    bb26: {
        _77 = &_30;
        _78 = &mut _55;
        _76 = <Optional<&str> as ToTokens>::to_tokens(_77, _78) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _54 = move _55;
        _51 = push_group_spanned(_52, _37, move _53, move _54) -> [return: bb28, unwind: bb32];
    }

    bb28: {
        _35 = move _36;
        _34 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _35) -> [return: bb29, unwind: bb33];
    }

    bb29: {
        drop(_11) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_55) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_36) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_11) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        resume;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:208:1: 208:32>::to_tokens::{closure#0}(_1: {closure@core/codegen/src/http_codegen.rs:215:55: 215:58}, _2: &rocket_http::uri::Authority<'_>) -> http_codegen::Authority<'_> {
    debug a => _2;
    debug span => (*(_1.0: &proc_macro2::Span));
    let mut _0: http_codegen::Authority<'_>;
    let mut _3: proc_macro2::Span;
    let mut _4: &proc_macro2::Span;

    bb0: {
        _4 = deref_copy (_1.0: &proc_macro2::Span);
        _3 = (*_4);
        _0 = http_codegen::Authority::<'_>(_2, move _3);
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:208:1: 208:32>::to_tokens::{closure#1}(_1: {closure@core/codegen/src/http_codegen.rs:217:52: 217:55}, _2: rocket_http::uri::Query<'_>) -> &str {
    debug q => _2;
    let mut _0: &str;
    let mut _3: &rocket_http::uri::Query<'_>;

    bb0: {
        _3 = &_2;
        _0 = rocket_http::uri::Query::<'_>::as_str(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:208:1: 208:32>::to_tokens::{closure#2}(_1: {closure@core/codegen/src/http_codegen.rs:218:54: 218:57}, _2: &RawStr) -> &str {
    debug f => _2;
    let mut _0: &str;

    bb0: {
        _0 = RawStr::as_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn http_codegen::<impl at core/codegen/src/http_codegen.rs:225:1: 225:27>::to_tokens(_1: &http_codegen::Asterisk, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let mut _4: std::option::Option<proc_macro2::Span>;
    let mut _5: proc_macro2::Span;
    let _6: ();
    let mut _7: proc_macro2::TokenStream;
    let _10: ();
    let _11: &exports::StaticPath;
    let mut _12: &mut proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let _15: ();
    let mut _16: &mut proc_macro2::TokenStream;
    let _17: &str;
    scope 1 {
        debug _uri => _3;
        let mut _8: proc_macro2::TokenStream;
        scope 3 {
            debug _s => _8;
            let _9: proc_macro2::Span;
            scope 4 {
                debug _span => _9;
            }
        }
    }
    scope 2 {
        let _3: exports::StaticPath;
    }

    bb0: {
        _5 = ((*_1).1: proc_macro2::Span);
        _4 = Option::<proc_macro2::Span>::Some(move _5);
        _3 = StaticPath(move _4, const "::rocket::http::uri");
        _8 = TokenStream2::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ((*_1).1: proc_macro2::Span);
        _11 = &_3;
        _12 = &mut _8;
        _10 = <StaticPath as ToTokens>::to_tokens(_11, _12) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _14 = &mut _8;
        _13 = push_colon2_spanned(_14, _9) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _16 = &mut _8;
        _17 = const "Asterisk";
        _15 = push_ident_spanned(_16, _9, _17) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _7 = move _8;
        _6 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(_2, move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_8) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:33:10: 33:15>::fmt(_1: &syn_ext::Child<'_>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::borrow::Cow<'_, syn::Type>;
    let _10: &std::borrow::Cow<'_, syn::Type>;

    bb0: {
        _3 = const "Child";
        _4 = const "parent";
        _6 = &((*_1).0: std::option::Option<std::borrow::Cow<'_, syn::Type>>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "ty";
        _10 = &((*_1).1: std::borrow::Cow<'_, syn::Type>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:39:1: 39:25>::deref(_1: &syn_ext::Child<'_>) -> &syn::Type {
    debug self => _1;
    let mut _0: &syn::Type;
    let _2: &std::borrow::Cow<'_, syn::Type>;

    bb0: {
        _2 = &((*_1).1: std::borrow::Cow<'_, syn::Type>);
        _0 = <Cow<'_, syn::Type> as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:47:1: 47:29>::into_owned(_1: syn_ext::Child<'_>) -> syn_ext::Child<'_> {
    debug self => _1;
    let mut _0: syn_ext::Child<'_>;
    let mut _2: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _3: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _4: std::borrow::Cow<'_, syn::Type>;
    let mut _5: syn::Type;
    let mut _6: std::borrow::Cow<'_, syn::Type>;
    let mut _7: bool;

    bb0: {
        _7 = const false;
        _7 = const true;
        _3 = move (_1.0: std::option::Option<std::borrow::Cow<'_, syn::Type>>);
        _2 = <Option<Cow<'_, syn::Type>> as IntoOwned>::into_owned(move _3) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _7 = const false;
        _6 = move (_1.1: std::borrow::Cow<'_, syn::Type>);
        _5 = Cow::<'_, syn::Type>::into_owned(move _6) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _4 = Cow::<'_, syn::Type>::Owned(move _5);
        _0 = syn_ext::Child::<'_> { parent: move _2, ty: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop((_1.1: std::borrow::Cow<'_, syn::Type>)) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        switchInt(_7) -> [0: bb4, otherwise: bb5];
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::prepend(_1: &proc_macro2::Ident, _2: &str) -> proc_macro2::Ident {
    debug self => _1;
    debug string => _2;
    let mut _0: proc_macro2::Ident;
    let _3: &str;
    let _4: &std::string::String;
    let _5: std::string::String;
    let _6: std::string::String;
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 2];
    let _11: [core::fmt::rt::Argument<'_>; 2];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &&str;
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &proc_macro2::Ident;
    let _16: proc_macro2::Ident;
    let mut _17: proc_macro2::Span;
    let mut _18: &[&str; 2];
    scope 1 {
        debug res => _6;
    }

    bb0: {
        _18 = const _;
        _8 = _18 as &[&str] (PointerCoercion(Unsize));
        _13 = &_2;
        _12 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = <proc_macro2::Ident as syn::ext::IdentExt>::unraw(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _15 = &_16;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<proc_macro2::Ident>(_15) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _11 = [move _12, move _14];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _7 = std::fmt::Arguments::<'_>::new_v1(move _8, move _9) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _6 = format(move _7) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        drop(_16) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _5 = move _6;
        _4 = &_5;
        _3 = <std::string::String as std::ops::Deref>::deref(_4) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _17 = proc_macro2::Ident::span(_1) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _0 = proc_macro2::Ident::new(_3, move _17) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        drop(_5) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_5) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        drop(_6) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_16) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

promoted[0] in syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::prepend: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ""];
        _0 = &_1;
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::append(_1: &proc_macro2::Ident, _2: &str) -> proc_macro2::Ident {
    debug self => _1;
    debug string => _2;
    let mut _0: proc_macro2::Ident;
    let _3: &str;
    let _4: &std::string::String;
    let _5: std::string::String;
    let _6: std::string::String;
    let mut _7: std::fmt::Arguments<'_>;
    let mut _8: &[&str];
    let mut _9: &[core::fmt::rt::Argument<'_>];
    let _10: &[core::fmt::rt::Argument<'_>; 2];
    let _11: [core::fmt::rt::Argument<'_>; 2];
    let mut _12: core::fmt::rt::Argument<'_>;
    let _13: &&proc_macro2::Ident;
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &&str;
    let mut _16: proc_macro2::Span;
    let mut _17: &proc_macro2::Ident;
    let mut _18: &[&str; 2];
    scope 1 {
        debug res => _6;
    }

    bb0: {
        _18 = const _;
        _8 = _18 as &[&str] (PointerCoercion(Unsize));
        _13 = &_1;
        _12 = core::fmt::rt::Argument::<'_>::new_display::<&proc_macro2::Ident>(_13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _15 = &_2;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_15) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = [move _12, move _14];
        _10 = &_11;
        _9 = _10 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _7 = std::fmt::Arguments::<'_>::new_v1(move _8, move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = format(move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = move _6;
        _4 = &_5;
        _3 = <std::string::String as std::ops::Deref>::deref(_4) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _17 = _1;
        _16 = proc_macro2::Ident::span(move _17) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _0 = proc_macro2::Ident::new(_3, move _16) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        drop(_5) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_5) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

promoted[0] in syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::append: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ""];
        _0 = &_1;
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::with_span(_1: proc_macro2::Ident, _2: proc_macro2::Span) -> proc_macro2::Ident {
    debug self => _1;
    debug span => _2;
    let mut _0: proc_macro2::Ident;
    let _3: ();
    let mut _4: &mut proc_macro2::Ident;

    bb0: {
        _4 = &mut _1;
        _3 = proc_macro2::Ident::set_span(move _4, _2) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::rocketized(_1: &proc_macro2::Ident) -> proc_macro2::Ident {
    debug self => _1;
    let mut _0: proc_macro2::Ident;
    let _2: &&str;
    let mut _3: &str;

    bb0: {
        _2 = const {alloc2: &&str};
        _3 = deref_copy (*_2);
        _0 = <proc_macro2::Ident as syn_ext::IdentExt>::prepend(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc2 (static: ROCKET_IDENT_PREFIX, size: 16, align: 8) {
    ╾───alloc4105<imm>────╼ 09 00 00 00 00 00 00 00 │ ╾──────╼........
}

alloc4105 (size: 9, align: 1) {
    5f 5f 72 6f 63 6b 65 74 5f                      │ __rocket_
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::uniqueify_with(_1: &proc_macro2::Ident, _2: F) -> proc_macro2::Ident {
    debug self => _1;
    debug f => _2;
    let mut _0: proc_macro2::Ident;
    let mut _3: std::hash::DefaultHasher;
    let _4: ();
    let mut _5: &mut std::hash::DefaultHasher;
    let _6: ();
    let mut _7: &u32;
    let _8: u32;
    let mut _9: &mut std::hash::DefaultHasher;
    let _10: ();
    let mut _11: &std::thread::ThreadId;
    let _12: std::thread::ThreadId;
    let mut _13: &std::thread::Thread;
    let _14: std::thread::Thread;
    let mut _15: &mut std::hash::DefaultHasher;
    let _16: ();
    let mut _17: &usize;
    let _18: usize;
    let _19: &std::sync::atomic::AtomicUsize;
    let mut _20: std::sync::atomic::Ordering;
    let mut _21: &mut std::hash::DefaultHasher;
    let _22: ();
    let mut _23: &mut F;
    let mut _24: (&mut dyn std::hash::Hasher,);
    let mut _25: &mut dyn std::hash::Hasher;
    let mut _26: &mut std::hash::DefaultHasher;
    let _27: &str;
    let _28: &std::string::String;
    let _29: std::string::String;
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 1];
    let _35: [core::fmt::rt::Argument<'_>; 1];
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &u64;
    let _38: u64;
    let mut _39: &std::hash::DefaultHasher;
    scope 1 {
        debug hasher => _3;
        let _30: std::string::String;
        let mut _40: &[&str; 1];
        scope 2 {
            debug res => _30;
        }
    }

    bb0: {
        _3 = DefaultHasher::new() -> [return: bb1, unwind: bb22];
    }

    bb1: {
        _5 = &mut _3;
        _4 = <proc_macro2::Ident as Hash>::hash::<DefaultHasher>(_1, _5) -> [return: bb2, unwind: bb22];
    }

    bb2: {
        _8 = id() -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _7 = &_8;
        _9 = &mut _3;
        _6 = <u32 as Hash>::hash::<DefaultHasher>(move _7, _9) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _14 = current() -> [return: bb5, unwind: bb22];
    }

    bb5: {
        _13 = &_14;
        _12 = Thread::id(move _13) -> [return: bb6, unwind: bb21];
    }

    bb6: {
        _11 = &_12;
        _15 = &mut _3;
        _10 = <ThreadId as Hash>::hash::<DefaultHasher>(move _11, _15) -> [return: bb7, unwind: bb21];
    }

    bb7: {
        drop(_14) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _19 = const {alloc3: &AtomicUsize};
        _20 = AcqRel;
        _18 = AtomicUsize::fetch_add(_19, const 1_usize, move _20) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _17 = &_18;
        _21 = &mut _3;
        _16 = <usize as Hash>::hash::<DefaultHasher>(move _17, _21) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        _23 = &mut _2;
        _26 = &mut _3;
        _25 = _26 as &mut dyn std::hash::Hasher (PointerCoercion(Unsize));
        _24 = (move _25,);
        _22 = <F as FnMut<(&mut dyn Hasher,)>>::call_mut(move _23, move _24) -> [return: bb11, unwind: bb22];
    }

    bb11: {
        _40 = const _;
        _32 = _40 as &[&str] (PointerCoercion(Unsize));
        _39 = &_3;
        _38 = <DefaultHasher as Hasher>::finish(move _39) -> [return: bb12, unwind: bb22];
    }

    bb12: {
        _37 = &_38;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_37) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _35 = [move _36];
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = std::fmt::Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _30 = format(move _31) -> [return: bb15, unwind: bb22];
    }

    bb15: {
        _29 = move _30;
        _28 = &_29;
        _27 = <std::string::String as std::ops::Deref>::deref(_28) -> [return: bb16, unwind: bb20];
    }

    bb16: {
        _0 = <proc_macro2::Ident as syn_ext::IdentExt>::append(_1, _27) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        drop(_29) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        drop(_2) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_29) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_14) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_2) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

alloc3 (static: COUNTER, size: 8, align: 8) {
    00 00 00 00 00 00 00 00                         │ ........
}

promoted[0] in syn_ext::<impl at core/codegen/src/syn_ext.rs:64:1: 64:29>::uniqueify_with: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "_"];
        _0 = &_1;
        return;
    }
}

static COUNTER: AtomicUsize = {
    let mut _0: std::sync::atomic::AtomicUsize;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicUsize::new(const 0_usize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:100:1: 100:39>::ty(_1: &ReturnType) -> Option<&syn::Type> {
    debug self => _1;
    let mut _0: std::option::Option<&syn::Type>;
    let mut _2: isize;
    let _3: &std::boxed::Box<syn::Type>;
    let mut _4: &syn::Type;
    let mut _5: std::boxed::Box<syn::Type>;
    let mut _6: *const syn::Type;
    scope 1 {
        debug ty => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _3 = &(((*_1) as Type).1: std::boxed::Box<syn::Type>);
        _5 = deref_copy (*_3);
        _6 = (((_5.0: std::ptr::Unique<syn::Type>).0: std::ptr::NonNull<syn::Type>).0: *const syn::Type);
        _4 = &(*_6);
        _0 = Option::<&syn::Type>::Some(move _4);
        goto -> bb4;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = Option::<&syn::Type>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:109:1: 109:36>::respanned(_1: &TokenStream2, _2: proc_macro2::Span) -> TokenStream2 {
    debug self => _1;
    debug span => _2;
    let mut _0: proc_macro2::TokenStream;
    let mut _3: std::iter::Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/syn_ext.rs:111:38: 111:49}>;
    let mut _4: proc_macro2::token_stream::IntoIter;
    let mut _5: proc_macro2::TokenStream;
    let mut _6: {closure@core/codegen/src/syn_ext.rs:111:38: 111:49};
    let mut _7: &proc_macro2::Span;

    bb0: {
        _5 = <TokenStream2 as Clone>::clone(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <TokenStream2 as IntoIterator>::into_iter(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &_2;
        _6 = {closure@core/codegen/src/syn_ext.rs:111:38: 111:49} { span: move _7 };
        _3 = <proc_macro2::token_stream::IntoIter as Iterator>::map::<proc_macro2::TokenTree, {closure@core/codegen/src/syn_ext.rs:111:38: 111:49}>(move _4, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = <Map<proc_macro2::token_stream::IntoIter, {closure@core/codegen/src/syn_ext.rs:111:38: 111:49}> as Iterator>::collect::<TokenStream2>(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:109:1: 109:36>::respanned::{closure#0}(_1: &mut {closure@core/codegen/src/syn_ext.rs:111:38: 111:49}, _2: proc_macro2::TokenTree) -> proc_macro2::TokenTree {
    debug token => _2;
    debug span => (*((*_1).0: &proc_macro2::Span));
    let mut _0: proc_macro2::TokenTree;
    let _3: ();
    let mut _4: &mut proc_macro2::TokenTree;
    let mut _5: proc_macro2::Span;
    let mut _6: &proc_macro2::Span;

    bb0: {
        _4 = &mut _2;
        _6 = deref_copy ((*_1).0: &proc_macro2::Span);
        _5 = (*_6);
        _3 = proc_macro2::TokenTree::set_span(move _4, move _5) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _0 = move _2;
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:118:1: 118:29>::typed(_1: &syn::FnArg) -> Option<(&proc_macro2::Ident, &syn::Type)> {
    debug self => _1;
    let mut _0: std::option::Option<(&proc_macro2::Ident, &syn::Type)>;
    let mut _2: isize;
    let _3: &syn::PatType;
    let mut _4: isize;
    let mut _6: (&proc_macro2::Ident, &syn::Type);
    let _7: &proc_macro2::Ident;
    let mut _8: &syn::Type;
    let _9: &std::boxed::Box<syn::Type>;
    let mut _10: std::boxed::Box<syn::Pat>;
    let mut _11: std::boxed::Box<syn::Pat>;
    let mut _12: std::boxed::Box<syn::Type>;
    let mut _13: *const syn::Pat;
    let mut _14: *const syn::Pat;
    let mut _15: *const syn::Type;
    scope 1 {
        debug arg => _3;
        let _5: &syn::PatIdent;
        scope 2 {
            debug pat => _5;
        }
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<(&proc_macro2::Ident, &syn::Type)>::None;
        goto -> bb5;
    }

    bb2: {
        _3 = &(((*_1) as Typed).0: syn::PatType);
        _10 = deref_copy ((*_3).1: std::boxed::Box<syn::Pat>);
        _13 = (((_10.0: std::ptr::Unique<syn::Pat>).0: std::ptr::NonNull<syn::Pat>).0: *const syn::Pat);
        _4 = discriminant((*_13));
        switchInt(move _4) -> [1: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Option::<(&proc_macro2::Ident, &syn::Type)>::None;
        goto -> bb5;
    }

    bb4: {
        _11 = deref_copy ((*_3).1: std::boxed::Box<syn::Pat>);
        _14 = (((_11.0: std::ptr::Unique<syn::Pat>).0: std::ptr::NonNull<syn::Pat>).0: *const syn::Pat);
        _5 = &(((*_14) as Ident).0: syn::PatIdent);
        _7 = &((*_5).3: proc_macro2::Ident);
        _9 = &((*_3).3: std::boxed::Box<syn::Type>);
        _12 = deref_copy (*_9);
        _15 = (((_12.0: std::ptr::Unique<syn::Type>).0: std::ptr::NonNull<syn::Type>).0: *const syn::Type);
        _8 = &(*_15);
        _6 = (_7, move _8);
        _0 = Option::<(&proc_macro2::Ident, &syn::Type)>::Some(move _6);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:118:1: 118:29>::wild(_1: &syn::FnArg) -> Option<&PatWild> {
    debug self => _1;
    let mut _0: std::option::Option<&syn::PatWild>;
    let mut _2: isize;
    let _3: &syn::PatType;
    let mut _4: isize;
    let mut _6: std::boxed::Box<syn::Pat>;
    let mut _7: std::boxed::Box<syn::Pat>;
    let mut _8: *const syn::Pat;
    let mut _9: *const syn::Pat;
    scope 1 {
        debug arg => _3;
        let _5: &syn::PatWild;
        scope 2 {
            debug pat => _5;
        }
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [1: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&PatWild>::None;
        goto -> bb5;
    }

    bb2: {
        _3 = &(((*_1) as Typed).0: syn::PatType);
        _6 = deref_copy ((*_3).1: std::boxed::Box<syn::Pat>);
        _8 = (((_6.0: std::ptr::Unique<syn::Pat>).0: std::ptr::NonNull<syn::Pat>).0: *const syn::Pat);
        _4 = discriminant((*_8));
        switchInt(move _4) -> [15: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Option::<&PatWild>::None;
        goto -> bb5;
    }

    bb4: {
        _7 = deref_copy ((*_3).1: std::boxed::Box<syn::Pat>);
        _9 = (((_7.0: std::ptr::Unique<syn::Pat>).0: std::ptr::NonNull<syn::Pat>).0: *const syn::Pat);
        _5 = &(((*_9) as Wild).0: syn::PatWild);
        _0 = Option::<&PatWild>::Some(_5);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn known_macro_inner_ty(_1: &TypeMacro, _2: &[&str]) -> Option<syn::Type> {
    debug t => _1;
    debug known => _2;
    let mut _0: std::option::Option<syn::Type>;
    let mut _3: bool;
    let mut _4: &mut std::slice::Iter<'_, &str>;
    let mut _5: std::slice::Iter<'_, &str>;
    let mut _6: {closure@core/codegen/src/syn_ext.rs:141:26: 141:29};
    let mut _7: &&syn::TypeMacro;
    let mut _8: std::result::Result<syn::Type, syn::Error>;
    let mut _9: proc_macro2::TokenStream;
    let mut _10: &proc_macro2::TokenStream;

    bb0: {
        _5 = core::slice::<impl [&str]>::iter(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _5;
        _7 = &_1;
        _6 = {closure@core/codegen/src/syn_ext.rs:141:26: 141:29} { t: move _7 };
        _3 = <std::slice::Iter<'_, &str> as Iterator>::any::<{closure@core/codegen/src/syn_ext.rs:141:26: 141:29}>(move _4, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _10 = &(((*_1).0: syn::Macro).3: proc_macro2::TokenStream);
        _9 = <TokenStream2 as Clone>::clone(move _10) -> [return: bb5, unwind continue];
    }

    bb4: {
        _0 = Option::<syn::Type>::None;
        goto -> bb7;
    }

    bb5: {
        _8 = syn::parse2::<syn::Type>(move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<syn::Type, syn::Error>::ok(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn known_macro_inner_ty::{closure#0}(_1: &mut {closure@core/codegen/src/syn_ext.rs:141:26: 141:29}, _2: &&str) -> bool {
    debug k => _2;
    debug t => (*((*_1).0: &&syn::TypeMacro));
    let mut _0: bool;
    let mut _3: std::option::Option<&proc_macro2::Ident>;
    let mut _4: &syn::Path;
    let mut _5: {closure@core/codegen/src/syn_ext.rs:141:68: 141:71};
    let mut _6: &&&str;
    let mut _7: &&syn::TypeMacro;
    let mut _8: &syn::TypeMacro;

    bb0: {
        _7 = deref_copy ((*_1).0: &&syn::TypeMacro);
        _8 = deref_copy (*_7);
        _4 = &(((*_8).0: syn::Macro).0: syn::Path);
        _3 = <syn::Path as PathExt>::last_ident(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &_2;
        _5 = {closure@core/codegen/src/syn_ext.rs:141:68: 141:71} { k: move _6 };
        _0 = Option::<&proc_macro2::Ident>::map_or::<bool, {closure@core/codegen/src/syn_ext.rs:141:68: 141:71}>(move _3, const false, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn known_macro_inner_ty::{closure#0}::{closure#0}(_1: {closure@core/codegen/src/syn_ext.rs:141:68: 141:71}, _2: &proc_macro2::Ident) -> bool {
    debug i => _2;
    debug k => (*(_1.0: &&&str));
    let mut _0: bool;
    let mut _3: &&proc_macro2::Ident;
    let mut _4: &&&str;

    bb0: {
        _3 = &_2;
        _4 = deref_copy (_1.0: &&&str);
        _0 = <&proc_macro2::Ident as PartialEq<&&str>>::eq(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::unfold(_1: &syn::Type) -> Vec<syn_ext::Child<'_>> {
    debug self => _1;
    let mut _0: std::vec::Vec<syn_ext::Child<'_>>;
    let mut _2: &[&str];
    let mut _3: &[&str; 0];

    bb0: {
        _3 = const _;
        _2 = _3 as &[&str] (PointerCoercion(Unsize));
        _0 = <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros(_1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::unfold: &[&str; 0] = {
    let mut _0: &[&str; 0];
    let mut _1: [&str; 0];

    bb0: {
        _1 = [];
        _0 = &_1;
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::unfold_with_known_macros(_1: &syn::Type, _2: &[&str]) -> Vec<syn_ext::Child<'_>> {
    debug self => _1;
    debug known_macros => _2;
    let mut _0: std::vec::Vec<syn_ext::Child<'_>>;
    let mut _3: <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros::Visitor<'_, '_>;
    let _4: ();
    let mut _5: &mut <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros::Visitor<'_, '_>;
    scope 1 {
        debug visitor => _3;
    }

    bb0: {
        _3 = Visitor::<'_, '_>::new(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _3;
        _4 = <Visitor<'_, '_> as Visit<'_>>::visit_type(move _5, _1) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move (_3.1: std::vec::Vec<syn_ext::Child<'_>>);
        drop((_3.0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>)) -> [return: bb5, unwind continue];
    }

    bb3 (cleanup): {
        drop(_3) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }

    bb5: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::unfold_with_known_macros::<impl at core/codegen/src/syn_ext.rs:160:9: 160:33>::new(_1: &[&str]) -> Visitor<'_, '_> {
    debug known_macros => _1;
    let mut _0: <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros::Visitor<'_, '_>;
    let mut _2: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>;
    let mut _3: std::vec::Vec<syn_ext::Child<'_>>;

    bb0: {
        _2 = Vec::<Cow<'_, syn::Type>>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Vec::<syn_ext::Child<'_>>::new() -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = Visitor::<'_, '_> { parents: move _2, children: move _3, known_macros: _1 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::unfold_with_known_macros::<impl at core/codegen/src/syn_ext.rs:166:9: 166:47>::visit_type(_1: &mut Visitor<'_, '_>, _2: &syn::Type) -> () {
    debug self => _1;
    debug ty => _2;
    let mut _0: ();
    let _3: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _4: std::option::Option<&std::borrow::Cow<'_, syn::Type>>;
    let _5: &[std::borrow::Cow<'_, syn::Type>];
    let mut _6: &std::vec::Vec<std::borrow::Cow<'_, syn::Type>>;
    let mut _7: isize;
    let mut _9: std::option::Option<syn::Type>;
    let mut _10: isize;
    let mut _13: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _14: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _15: &std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _16: isize;
    let _18: ();
    let mut _19: &mut std::vec::Vec<std::borrow::Cow<'_, syn::Type>>;
    let _20: ();
    let mut _21: &mut <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros::Visitor<'_, '_>;
    let _22: &syn::Type;
    let mut _24: std::vec::Vec<syn_ext::Child<'_>>;
    let _25: ();
    let mut _26: &mut std::vec::Vec<syn_ext::Child<'_>>;
    let mut _27: &mut std::vec::Vec<syn_ext::Child<'_>>;
    let _28: ();
    let mut _29: &mut std::vec::Vec<syn_ext::Child<'_>>;
    let mut _30: syn_ext::Child<'_>;
    let mut _31: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _32: std::borrow::Cow<'_, syn::Type>;
    let _33: ();
    let mut _34: &mut std::vec::Vec<std::borrow::Cow<'_, syn::Type>>;
    let mut _35: std::borrow::Cow<'_, syn::Type>;
    let _36: ();
    let _37: std::option::Option<std::borrow::Cow<'_, syn::Type>>;
    let mut _38: &mut std::vec::Vec<std::borrow::Cow<'_, syn::Type>>;
    let mut _39: &[&str];
    let mut _40: &[&str];
    let mut _41: bool;
    let mut _42: bool;
    let mut _43: bool;
    let mut _44: isize;
    scope 1 {
        debug parent => _3;
        scope 2 {
            debug t => _8;
            let _8: &syn::TypeMacro;
            scope 3 {
                debug inner_ty => _11;
                let _11: syn::Type;
                let mut _12: <syn::Type as syn_ext::TypeExt>::unfold_with_known_macros::Visitor<'_, '_>;
                scope 4 {
                    debug visitor => _12;
                    let mut _23: std::vec::Vec<syn_ext::Child<'_>>;
                    scope 5 {
                        debug parent => _17;
                        let _17: std::borrow::Cow<'_, syn::Type>;
                    }
                    scope 6 {
                        debug children => _23;
                    }
                }
            }
        }
    }

    bb0: {
        _43 = const false;
        _41 = const false;
        _42 = const false;
        _6 = &((*_1).0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>);
        _5 = <Vec<Cow<'_, syn::Type>> as std::ops::Deref>::deref(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = core::slice::<impl [Cow<'_, syn::Type>]>::last(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _43 = const true;
        _3 = Option::<&Cow<'_, syn::Type>>::cloned(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = discriminant((*_2));
        switchInt(move _7) -> [5: bb4, otherwise: bb15];
    }

    bb4: {
        _8 = &(((*_2) as Macro).0: syn::TypeMacro);
        _39 = deref_copy ((*_1).2: &[&str]);
        _9 = known_macro_inner_ty(_8, _39) -> [return: bb5, unwind: bb37];
    }

    bb5: {
        _10 = discriminant(_9);
        switchInt(move _10) -> [1: bb6, otherwise: bb14];
    }

    bb6: {
        _11 = move ((_9 as Some).0: syn::Type);
        _40 = deref_copy ((*_1).2: &[&str]);
        _12 = Visitor::<'_, '_>::new(_40) -> [return: bb7, unwind: bb26];
    }

    bb7: {
        _42 = const true;
        _15 = &_3;
        _14 = <Option<Cow<'_, syn::Type>> as Clone>::clone(move _15) -> [return: bb8, unwind: bb35];
    }

    bb8: {
        _13 = <Option<Cow<'_, syn::Type>> as IntoOwned>::into_owned(move _14) -> [return: bb9, unwind: bb35];
    }

    bb9: {
        _41 = const true;
        _16 = discriminant(_13);
        switchInt(move _16) -> [1: bb10, otherwise: bb31];
    }

    bb10: {
        _41 = const false;
        _17 = move ((_13 as Some).0: std::borrow::Cow<'_, syn::Type>);
        _19 = &mut (_12.0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>);
        _18 = Vec::<Cow<'_, syn::Type>>::push(move _19, move _17) -> [return: bb38, unwind: bb35];
    }

    bb11: {
        _42 = const false;
        _24 = move (_12.1: std::vec::Vec<syn_ext::Child<'_>>);
        _23 = <Vec<syn_ext::Child<'_>> as IntoOwned>::into_owned(move _24) -> [return: bb12, unwind: bb35];
    }

    bb12: {
        _26 = &mut ((*_1).1: std::vec::Vec<syn_ext::Child<'_>>);
        _27 = &mut _23;
        _25 = Vec::<syn_ext::Child<'_>>::append(move _26, _27) -> [return: bb13, unwind: bb25];
    }

    bb13: {
        drop(_23) -> [return: bb21, unwind: bb35];
    }

    bb14: {
        drop(_9) -> [return: bb15, unwind: bb37];
    }

    bb15: {
        _29 = &mut ((*_1).1: std::vec::Vec<syn_ext::Child<'_>>);
        _43 = const false;
        _31 = move _3;
        _32 = Cow::<'_, syn::Type>::Borrowed(_2);
        _30 = syn_ext::Child::<'_> { parent: move _31, ty: move _32 };
        _28 = Vec::<syn_ext::Child<'_>>::push(move _29, move _30) -> [return: bb16, unwind: bb37];
    }

    bb16: {
        _34 = &mut ((*_1).0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>);
        _35 = Cow::<'_, syn::Type>::Borrowed(_2);
        _33 = Vec::<Cow<'_, syn::Type>>::push(move _34, move _35) -> [return: bb17, unwind: bb37];
    }

    bb17: {
        _36 = syn::visit::visit_type::<'_, Visitor<'_, '_>>(_1, _2) -> [return: bb18, unwind: bb37];
    }

    bb18: {
        _38 = &mut ((*_1).0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>);
        _37 = Vec::<Cow<'_, syn::Type>>::pop(move _38) -> [return: bb19, unwind: bb37];
    }

    bb19: {
        drop(_37) -> [return: bb20, unwind: bb37];
    }

    bb20: {
        _43 = const false;
        goto -> bb24;
    }

    bb21: {
        drop((_12.0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>)) -> [return: bb32, unwind: bb26];
    }

    bb22: {
        drop(_3) -> [return: bb23, unwind continue];
    }

    bb23: {
        _43 = const false;
        goto -> bb24;
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_23) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_11) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }

    bb28: {
        _41 = const false;
        _21 = &mut _12;
        _22 = &_11;
        _20 = <Visitor<'_, '_> as Visit<'_>>::visit_type(move _21, _22) -> [return: bb11, unwind: bb35];
    }

    bb29: {
        switchInt(_41) -> [0: bb28, otherwise: bb30];
    }

    bb30: {
        drop(((_13 as Some).0: std::borrow::Cow<'_, syn::Type>)) -> [return: bb28, unwind: bb35];
    }

    bb31: {
        _44 = discriminant(_13);
        switchInt(move _44) -> [1: bb29, otherwise: bb28];
    }

    bb32: {
        _42 = const false;
        drop(_11) -> [return: bb22, unwind: bb37];
    }

    bb33 (cleanup): {
        switchInt(_42) -> [0: bb26, otherwise: bb34];
    }

    bb34 (cleanup): {
        drop((_12.1: std::vec::Vec<syn_ext::Child<'_>>)) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop((_12.0: std::vec::Vec<std::borrow::Cow<'_, syn::Type>>)) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_3) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        switchInt(_43) -> [0: bb27, otherwise: bb36];
    }

    bb38: {
        goto -> bb31;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::is_concrete(_1: &syn::Type, _2: &[&proc_macro2::Ident]) -> bool {
    debug self => _1;
    debug generics => _2;
    let mut _0: bool;
    let mut _3: <syn::Type as syn_ext::TypeExt>::is_concrete::ConcreteVisitor<'_>;
    let _4: ();
    let mut _5: &mut <syn::Type as syn_ext::TypeExt>::is_concrete::ConcreteVisitor<'_>;
    scope 1 {
        debug visitor => _3;
    }

    bb0: {
        _3 = ConcreteVisitor::<'_>(const true, _2);
        _5 = &mut _3;
        _4 = <ConcreteVisitor<'_> as Visit<'_>>::visit_type(move _5, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = (_3.0: bool);
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::is_concrete::<impl at core/codegen/src/syn_ext.rs:199:9: 199:55>::visit_type(_1: &mut ConcreteVisitor<'_>, _2: &syn::Type) -> () {
    debug self => _1;
    debug ty => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: &syn::TypePath;
    let _5: &&syn::TypePath;
    let mut _6: bool;
    let mut _7: &mut std::slice::Iter<'_, &proc_macro2::Ident>;
    let mut _8: std::slice::Iter<'_, &proc_macro2::Ident>;
    let mut _9: {closure@core/codegen/src/syn_ext.rs:204:50: 204:53};
    let mut _10: &[&proc_macro2::Ident];
    scope 1 {
        debug t => _4;
        debug t => _5;
    }

    bb0: {
        _3 = discriminant((*_2));
        switchInt(move _3) -> [1: bb7, 3: bb6, 4: bb6, 5: bb6, 6: bb7, 8: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = syn::visit::visit_type::<'_, ConcreteVisitor<'_>>(_1, _2) -> [return: bb8, unwind continue];
    }

    bb2: {
        _4 = &(((*_2) as Path).0: syn::TypePath);
        _5 = &_4;
        _10 = deref_copy ((*_1).1: &[&proc_macro2::Ident]);
        _8 = core::slice::<impl [&proc_macro2::Ident]>::iter(_10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &mut _8;
        _9 = {closure@core/codegen/src/syn_ext.rs:204:50: 204:53} { t: _5 };
        _6 = <std::slice::Iter<'_, &proc_macro2::Ident> as Iterator>::any::<{closure@core/codegen/src/syn_ext.rs:204:50: 204:53}>(move _7, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _6) -> [0: bb1, otherwise: bb5];
    }

    bb5: {
        ((*_1).0: bool) = const false;
        goto -> bb8;
    }

    bb6: {
        ((*_1).0: bool) = const false;
        goto -> bb8;
    }

    bb7: {
        ((*_1).0: bool) = const true;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn syn_ext::<impl at core/codegen/src/syn_ext.rs:148:1: 148:27>::is_concrete::<impl at core/codegen/src/syn_ext.rs:199:9: 199:55>::visit_type::{closure#0}(_1: &mut {closure@core/codegen/src/syn_ext.rs:204:50: 204:53}, _2: &&proc_macro2::Ident) -> bool {
    debug i => _2;
    debug t => (*((*_1).0: &&syn::TypePath));
    let mut _0: bool;
    let mut _3: &syn::Path;
    let mut _4: &&syn::TypePath;
    let mut _5: &syn::TypePath;
    let mut _6: &proc_macro2::Ident;

    bb0: {
        _4 = deref_copy ((*_1).0: &&syn::TypePath);
        _5 = deref_copy (*_4);
        _3 = &((*_5).1: syn::Path);
        _6 = deref_copy (*_2);
        _0 = syn::path::parsing::<impl syn::Path>::is_ident::<proc_macro2::Ident>(move _3, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:17:10: 17:15>::fmt(_1: &name::Name, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::string::String;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&proc_macro2::Span;
    let _10: &proc_macro2::Span;

    bb0: {
        _3 = const "Name";
        _4 = const "value";
        _6 = &((*_1).0: std::string::String);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "span";
        _10 = &((*_1).1: proc_macro2::Span);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:17:17: 17:22>::clone(_1: &name::Name) -> name::Name {
    debug self => _1;
    let mut _0: name::Name;
    let mut _2: std::string::String;
    let _3: &std::string::String;
    let mut _4: proc_macro2::Span;
    let _5: &proc_macro2::Span;

    bb0: {
        _3 = &((*_1).0: std::string::String);
        _2 = <std::string::String as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: proc_macro2::Span);
        _4 = <proc_macro2::Span as Clone>::clone(_5) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = name::Name { value: move _2, span: move _4 };
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn name::<impl at core/codegen/src/name.rs:23:1: 23:10>::new(_1: S, _2: proc_macro2::Span) -> name::Name {
    debug name => _1;
    debug span => _2;
    let mut _0: name::Name;
    let mut _3: std::string::String;

    bb0: {
        _3 = <S as Into<std::string::String>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = name::Name { value: move _3, span: _2 };
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:23:1: 23:10>::as_str(_1: &name::Name) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &std::string::String;

    bb0: {
        _2 = &((*_1).0: std::string::String);
        _0 = <std::string::String as std::ops::Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:23:1: 23:10>::as_uncased_str(_1: &name::Name) -> &UncasedStr {
    debug self => _1;
    let mut _0: &rocket_http::uncased::UncasedStr;
    let _2: &str;

    bb0: {
        _2 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = UncasedStr::new(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:23:1: 23:10>::span(_1: &name::Name) -> proc_macro2::Span {
    debug self => _1;
    let mut _0: proc_macro2::Span;

    bb0: {
        _0 = ((*_1).1: proc_macro2::Span);
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:46:1: 46:31>::from_meta(_1: &devise::MetaItem) -> std::result::Result<name::Name, devise::Diagnostic> {
    debug meta => _1;
    let mut _0: std::result::Result<name::Name, devise::Diagnostic>;
    let mut _2: syn::Lit;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, devise::Diagnostic>, syn::Lit>;
    let mut _4: std::result::Result<syn::Lit, devise::Diagnostic>;
    let mut _5: isize;
    let mut _8: isize;
    let mut _10: name::Name;
    let mut _11: std::string::String;
    let mut _12: &syn::LitStr;
    let mut _13: proc_macro2::Span;
    let mut _14: &syn::LitStr;
    let mut _15: devise::Diagnostic;
    let mut _16: proc_macro2::Span;
    let mut _17: bool;
    let mut _18: isize;
    let mut _19: isize;
    scope 1 {
        debug s => _9;
        let _6: std::result::Result<std::convert::Infallible, devise::Diagnostic>;
        let _7: syn::Lit;
        let _9: syn::LitStr;
        scope 2 {
            debug residual => _6;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _7;
            scope 5 {
            }
        }
    }

    bb0: {
        _17 = const false;
        _4 = devise::MetaItem::lit(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<syn::Lit, devise::Diagnostic> as std::ops::Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: syn::Lit);
        _2 = move _7;
        _8 = discriminant(_2);
        switchInt(move _8) -> [0: bb6, otherwise: bb10];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, devise::Diagnostic>);
        _0 = <std::result::Result<name::Name, devise::Diagnostic> as FromResidual<std::result::Result<Infallible, devise::Diagnostic>>>::from_residual(move _6) -> [return: bb14, unwind continue];
    }

    bb6: {
        _9 = move ((_2 as Str).0: syn::LitStr);
        _12 = &_9;
        _11 = LitStr::value(move _12) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        _17 = const true;
        _14 = &_9;
        _13 = LitStr::span(move _14) -> [return: bb8, unwind: bb20];
    }

    bb8: {
        _17 = const false;
        _10 = name::Name::new::<std::string::String>(move _11, move _13) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _17 = const false;
        _0 = std::result::Result::<name::Name, devise::Diagnostic>::Ok(move _10);
        drop(_9) -> [return: bb13, unwind: bb22];
    }

    bb10: {
        drop(_2) -> [return: bb17, unwind continue];
    }

    bb11: {
        _15 = <proc_macro2::Span as SpanDiagnosticExt>::error::<&str>(move _16, const "invalid value: expected string literal") -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = std::result::Result::<name::Name, devise::Diagnostic>::Err(move _15);
        goto -> bb14;
    }

    bb13: {
        _18 = discriminant(_2);
        switchInt(move _18) -> [0: bb14, otherwise: bb18];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_9) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17: {
        _16 = devise::MetaItem::value_span(_1) -> [return: bb11, unwind continue];
    }

    bb18: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb19 (cleanup): {
        drop(_11) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb19];
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        _19 = discriminant(_2);
        switchInt(move _19) -> [0: bb16, otherwise: bb21];
    }
}

fn name::<impl at core/codegen/src/name.rs:58:1: 58:30>::to_tokens(_1: &name::Name, _2: &mut TokenStream2) -> () {
    debug self => _1;
    debug tokens => _2;
    let mut _0: ();
    let mut _3: &syn::LitStr;
    let _4: syn::LitStr;
    let _5: &str;
    let mut _6: proc_macro2::Span;

    bb0: {
        _5 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = name::Name::span(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = LitStr::new(_5, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = &_4;
        _0 = <LitStr as ToTokens>::to_tokens(move _3, _2) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_4) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn name::<impl at core/codegen/src/name.rs:64:1: 64:27>::from(_1: &proc_macro2::Ident) -> name::Name {
    debug ident => _1;
    let mut _0: name::Name;
    let mut _2: std::string::String;
    let mut _3: &proc_macro2::Ident;
    let _4: proc_macro2::Ident;
    let mut _5: proc_macro2::Span;
    let mut _6: bool;

    bb0: {
        _6 = const false;
        _4 = <proc_macro2::Ident as syn::ext::IdentExt>::unraw(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _2 = <proc_macro2::Ident as ToString>::to_string(move _3) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _6 = const true;
        _5 = proc_macro2::Ident::span(_1) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _6 = const false;
        _0 = name::Name::new::<std::string::String>(move _2, move _5) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _6 = const false;
        drop(_4) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        switchInt(_6) -> [0: bb6, otherwise: bb8];
    }
}

fn name::<impl at core/codegen/src/name.rs:70:1: 70:25>::as_ref(_1: &name::Name) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:76:1: 76:30>::hash(_1: &name::Name, _2: &mut H) -> () {
    debug self => _1;
    debug hasher => _2;
    let mut _0: ();
    let _3: &str;

    bb0: {
        _3 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <str as Hash>::hash::<H>(_3, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:82:1: 82:30>::deref(_1: &name::Name) -> &str {
    debug self => _1;
    let mut _0: &str;

    bb0: {
        _0 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:92:1: 92:55>::eq(_1: &name::Name, _2: &S) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &&S;
    let mut _4: &&str;
    let _5: &str;

    bb0: {
        _3 = &_2;
        _5 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_5;
        _0 = <&S as PartialEq<&str>>::eq(move _3, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn name::<impl at core/codegen/src/name.rs:98:1: 98:32>::fmt(_1: &name::Name, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = name::Name::as_str(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <str as std::fmt::Display>::fmt(_3, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

static URI_MACRO_PREFIX: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "rocket_uri_macro_";
        return;
    }
}

static ROCKET_IDENT_PREFIX: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "__rocket_";
        return;
    }
}

fn route(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: std::option::Option<rocket_http::Method>;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Option::<rocket_http::Method>::None;
        _3 = route_attribute::<Option<rocket_http::Method>>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn get(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Get;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn put(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Put;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn post(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Post;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn delete(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = rocket_http::Method::Delete;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn head(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Head;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn patch(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Patch;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn options(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: rocket_http::Method;
    let mut _5: bool;
    let mut _6: &std::option::Option<std::ffi::OsString>;
    let _7: std::option::Option<std::ffi::OsString>;
    let mut _9: devise::Diagnostic;
    let mut _10: devise::Diagnostic;
    let mut _11: proc_macro2::Span;
    let mut _12: std::string::String;
    let mut _13: &proc_macro2::TokenStream;
    let _14: ();
    let mut _15: &mut proc_macro2::TokenStream;
    let mut _16: proc_macro2::TokenStream;
    let mut _17: bool;
    let mut _18: bool;
    scope 1 {
        debug tokens => _3;
        let _8: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _8;
        }
    }

    bb0: {
        _18 = const false;
        _17 = const false;
        _4 = Options;
        _3 = route_attribute::<rocket_http::Method>(move _4, move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = const true;
        _7 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = &_7;
        _5 = Option::<OsString>::is_some(move _6) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _5) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_7) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _11 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _10 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _11, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = const true;
        _13 = &_3;
        _12 = <TokenStream2 as ToString>::to_string(move _13) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _17 = const false;
        _9 = devise::Diagnostic::note::<std::string::String>(move _10, move _12) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _17 = const false;
        _8 = devise::Diagnostic::emit_as_item_tokens(move _9) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _15 = &mut _3;
        _14 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _15, move _8) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_7) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _18 = const false;
        _16 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _16) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _18 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_10) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_17) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_18) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn catch(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: bool;
    let mut _5: &std::option::Option<std::ffi::OsString>;
    let _6: std::option::Option<std::ffi::OsString>;
    let mut _8: devise::Diagnostic;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: std::string::String;
    let mut _12: &proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let mut _15: proc_macro2::TokenStream;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug tokens => _3;
        let _7: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _7;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _3 = catch_attribute(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = const true;
        _6 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _5 = &_6;
        _4 = Option::<OsString>::is_some(move _5) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _4) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_6) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _10 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _10, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _16 = const true;
        _12 = &_3;
        _11 = <TokenStream2 as ToString>::to_string(move _12) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _16 = const false;
        _8 = devise::Diagnostic::note::<std::string::String>(move _9, move _11) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _16 = const false;
        _7 = devise::Diagnostic::emit_as_item_tokens(move _8) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _14 = &mut _3;
        _13 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _14, move _7) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_6) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _17 = const false;
        _15 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _15) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _17 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_16) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn async_test(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: bool;
    let mut _5: &std::option::Option<std::ffi::OsString>;
    let _6: std::option::Option<std::ffi::OsString>;
    let mut _8: devise::Diagnostic;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: std::string::String;
    let mut _12: &proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let mut _15: proc_macro2::TokenStream;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug tokens => _3;
        let _7: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _7;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _3 = async_test_attribute(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = const true;
        _6 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _5 = &_6;
        _4 = Option::<OsString>::is_some(move _5) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _4) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_6) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _10 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _10, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _16 = const true;
        _12 = &_3;
        _11 = <TokenStream2 as ToString>::to_string(move _12) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _16 = const false;
        _8 = devise::Diagnostic::note::<std::string::String>(move _9, move _11) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _16 = const false;
        _7 = devise::Diagnostic::emit_as_item_tokens(move _8) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _14 = &mut _3;
        _13 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _14, move _7) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_6) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _17 = const false;
        _15 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _15) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _17 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_16) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn main(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: bool;
    let mut _5: &std::option::Option<std::ffi::OsString>;
    let _6: std::option::Option<std::ffi::OsString>;
    let mut _8: devise::Diagnostic;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: std::string::String;
    let mut _12: &proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let mut _15: proc_macro2::TokenStream;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug tokens => _3;
        let _7: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _7;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _3 = main_attribute(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = const true;
        _6 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _5 = &_6;
        _4 = Option::<OsString>::is_some(move _5) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _4) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_6) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _10 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _10, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _16 = const true;
        _12 = &_3;
        _11 = <TokenStream2 as ToString>::to_string(move _12) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _16 = const false;
        _8 = devise::Diagnostic::note::<std::string::String>(move _9, move _11) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _16 = const false;
        _7 = devise::Diagnostic::emit_as_item_tokens(move _8) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _14 = &mut _3;
        _13 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _14, move _7) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_6) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _17 = const false;
        _15 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _15) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _17 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_16) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn launch(_1: proc_macro::TokenStream, _2: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug args => _1;
    debug input => _2;
    let mut _0: proc_macro::TokenStream;
    let mut _3: proc_macro2::TokenStream;
    let mut _4: bool;
    let mut _5: &std::option::Option<std::ffi::OsString>;
    let _6: std::option::Option<std::ffi::OsString>;
    let mut _8: devise::Diagnostic;
    let mut _9: devise::Diagnostic;
    let mut _10: proc_macro2::Span;
    let mut _11: std::string::String;
    let mut _12: &proc_macro2::TokenStream;
    let _13: ();
    let mut _14: &mut proc_macro2::TokenStream;
    let mut _15: proc_macro2::TokenStream;
    let mut _16: bool;
    let mut _17: bool;
    scope 1 {
        debug tokens => _3;
        let _7: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _7;
        }
    }

    bb0: {
        _17 = const false;
        _16 = const false;
        _3 = launch_attribute(move _1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = const true;
        _6 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _5 = &_6;
        _4 = Option::<OsString>::is_some(move _5) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _4) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_6) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _10 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _9 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _10, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _16 = const true;
        _12 = &_3;
        _11 = <TokenStream2 as ToString>::to_string(move _12) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _16 = const false;
        _8 = devise::Diagnostic::note::<std::string::String>(move _9, move _11) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _16 = const false;
        _7 = devise::Diagnostic::emit_as_item_tokens(move _8) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _14 = &mut _3;
        _13 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _14, move _7) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_6) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _17 = const false;
        _15 = move _3;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _15) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _17 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_16) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_17) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn derive_from_form_field(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = from_form_field::derive_from_form_field(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn derive_from_form(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = from_form::derive_from_form(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn derive_responder(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = responder::derive_responder(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn derive_uri_display_query(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = uri_display::derive_uri_display_query(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn derive_uri_display_path(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = uri_display::derive_uri_display_path(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn routes(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = routes_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn catchers(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = catchers_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn uri(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = uri_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn rocket_internal_uri(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = uri_internal_macro(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn __typed_stream(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = typed_stream(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn internal_guide_tests(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = guide_tests_internal(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

fn export(_1: proc_macro::TokenStream) -> proc_macro::TokenStream {
    debug input => _1;
    let mut _0: proc_macro::TokenStream;
    let mut _2: proc_macro2::TokenStream;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::ffi::OsString>;
    let _5: std::option::Option<std::ffi::OsString>;
    let mut _7: devise::Diagnostic;
    let mut _8: devise::Diagnostic;
    let mut _9: proc_macro2::Span;
    let mut _10: std::string::String;
    let mut _11: &proc_macro2::TokenStream;
    let _12: ();
    let mut _13: &mut proc_macro2::TokenStream;
    let mut _14: proc_macro2::TokenStream;
    let mut _15: bool;
    let mut _16: bool;
    scope 1 {
        debug tokens => _2;
        let _6: proc_macro2::TokenStream;
        scope 2 {
            debug debug_tokens => _6;
        }
    }

    bb0: {
        _16 = const false;
        _15 = const false;
        _2 = export_internal(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _16 = const true;
        _5 = var_os::<&str>(const "ROCKET_CODEGEN_DEBUG") -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _4 = &_5;
        _3 = Option::<OsString>::is_some(move _4) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        switchInt(move _3) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        drop(_5) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _9 = proc_macro2::Span::call_site() -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _8 = <proc_macro2::Span as SpanDiagnosticExt>::note::<&str>(move _9, const "emitting Rocket code generation debug output") -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _15 = const true;
        _11 = &_2;
        _10 = <TokenStream2 as ToString>::to_string(move _11) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = const false;
        _7 = devise::Diagnostic::note::<std::string::String>(move _8, move _10) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = const false;
        _6 = devise::Diagnostic::emit_as_item_tokens(move _7) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _13 = &mut _2;
        _12 = <TokenStream2 as Extend<proc_macro2::TokenTree>>::extend::<TokenStream2>(move _13, move _6) -> [return: bb20, unwind: bb19];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind: bb19];
    }

    bb12: {
        _16 = const false;
        _14 = move _2;
        _0 = <TokenStream2 as Into<proc_macro::TokenStream>>::into(move _14) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _16 = const false;
        return;
    }

    bb14 (cleanup): {
        drop(_5) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_8) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_15) -> [0: bb19, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb18];
    }

    bb20: {
        goto -> bb12;
    }
}

const _: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

static _DECLS: &[ProcMacro] = {
    let mut _0: &[proc_macro::bridge::client::ProcMacro];
    let mut _1: &[proc_macro::bridge::client::ProcMacro; 24];
    let _2: &[proc_macro::bridge::client::ProcMacro; 24];
    let _3: [proc_macro::bridge::client::ProcMacro; 24];
    let mut _4: proc_macro::bridge::client::ProcMacro;
    let mut _5: proc_macro::bridge::client::ProcMacro;
    let mut _6: proc_macro::bridge::client::ProcMacro;
    let mut _7: proc_macro::bridge::client::ProcMacro;
    let mut _8: proc_macro::bridge::client::ProcMacro;
    let mut _9: proc_macro::bridge::client::ProcMacro;
    let mut _10: proc_macro::bridge::client::ProcMacro;
    let mut _11: proc_macro::bridge::client::ProcMacro;
    let mut _12: proc_macro::bridge::client::ProcMacro;
    let mut _13: proc_macro::bridge::client::ProcMacro;
    let mut _14: proc_macro::bridge::client::ProcMacro;
    let mut _15: proc_macro::bridge::client::ProcMacro;
    let mut _16: proc_macro::bridge::client::ProcMacro;
    let mut _17: &[&str];
    let mut _18: &[&str; 1];
    let _19: &[&str; 1];
    let _20: [&str; 1];
    let mut _21: proc_macro::bridge::client::ProcMacro;
    let mut _22: &[&str];
    let mut _23: &[&str; 1];
    let _24: &[&str; 1];
    let _25: [&str; 1];
    let mut _26: proc_macro::bridge::client::ProcMacro;
    let mut _27: &[&str];
    let mut _28: &[&str; 1];
    let _29: &[&str; 1];
    let _30: [&str; 1];
    let mut _31: proc_macro::bridge::client::ProcMacro;
    let mut _32: &[&str];
    let mut _33: &[&str; 1];
    let _34: &[&str; 1];
    let _35: [&str; 1];
    let mut _36: proc_macro::bridge::client::ProcMacro;
    let mut _37: &[&str];
    let mut _38: &[&str; 0];
    let _39: &[&str; 0];
    let _40: [&str; 0];
    let mut _41: proc_macro::bridge::client::ProcMacro;
    let mut _42: proc_macro::bridge::client::ProcMacro;
    let mut _43: proc_macro::bridge::client::ProcMacro;
    let mut _44: proc_macro::bridge::client::ProcMacro;
    let mut _45: proc_macro::bridge::client::ProcMacro;
    let mut _46: proc_macro::bridge::client::ProcMacro;
    let mut _47: proc_macro::bridge::client::ProcMacro;
    let mut _48: &[proc_macro::bridge::client::ProcMacro; 24];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _48 = const _;
        _2 = &(*_48);
        _1 = &(*_2);
        _0 = move _1 as &[proc_macro::bridge::client::ProcMacro] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in _DECLS: &[ProcMacro; 24] = {
    let mut _0: &[proc_macro::bridge::client::ProcMacro; 24];
    let mut _1: [proc_macro::bridge::client::ProcMacro; 24];
    let mut _2: proc_macro::bridge::client::ProcMacro;
    let mut _3: proc_macro::bridge::client::ProcMacro;
    let mut _4: proc_macro::bridge::client::ProcMacro;
    let mut _5: proc_macro::bridge::client::ProcMacro;
    let mut _6: proc_macro::bridge::client::ProcMacro;
    let mut _7: proc_macro::bridge::client::ProcMacro;
    let mut _8: proc_macro::bridge::client::ProcMacro;
    let mut _9: proc_macro::bridge::client::ProcMacro;
    let mut _10: proc_macro::bridge::client::ProcMacro;
    let mut _11: proc_macro::bridge::client::ProcMacro;
    let mut _12: proc_macro::bridge::client::ProcMacro;
    let mut _13: proc_macro::bridge::client::ProcMacro;
    let mut _14: proc_macro::bridge::client::ProcMacro;
    let mut _15: &[&str];
    let mut _16: &[&str; 1];
    let mut _17: &[&str; 1];
    let mut _18: [&str; 1];
    let mut _19: proc_macro::bridge::client::ProcMacro;
    let mut _20: &[&str];
    let mut _21: &[&str; 1];
    let mut _22: &[&str; 1];
    let mut _23: [&str; 1];
    let mut _24: proc_macro::bridge::client::ProcMacro;
    let mut _25: &[&str];
    let mut _26: &[&str; 1];
    let mut _27: &[&str; 1];
    let mut _28: [&str; 1];
    let mut _29: proc_macro::bridge::client::ProcMacro;
    let mut _30: &[&str];
    let mut _31: &[&str; 1];
    let mut _32: &[&str; 1];
    let mut _33: [&str; 1];
    let mut _34: proc_macro::bridge::client::ProcMacro;
    let mut _35: &[&str];
    let mut _36: &[&str; 0];
    let mut _37: &[&str; 0];
    let mut _38: [&str; 0];
    let mut _39: proc_macro::bridge::client::ProcMacro;
    let mut _40: proc_macro::bridge::client::ProcMacro;
    let mut _41: proc_macro::bridge::client::ProcMacro;
    let mut _42: proc_macro::bridge::client::ProcMacro;
    let mut _43: proc_macro::bridge::client::ProcMacro;
    let mut _44: proc_macro::bridge::client::ProcMacro;
    let mut _45: proc_macro::bridge::client::ProcMacro;

    bb0: {
        _2 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {route}>(const "route", route) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {get}>(const "get", get) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {put}>(const "put", put) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {post}>(const "post", post) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {delete}>(const "delete", delete) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {head}>(const "head", head) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {patch}>(const "patch", patch) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {options}>(const "options", options) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {catch}>(const "catch", catch) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {async_test}>(const "async_test", async_test) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {main}>(const "main", main) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = ProcMacro::attr::<fn(proc_macro::TokenStream, proc_macro::TokenStream) -> proc_macro::TokenStream {launch}>(const "launch", launch) -> [return: bb12, unwind continue];
    }

    bb12: {
        _18 = [const "field"];
        _17 = &_18;
        _16 = &(*_17);
        _15 = move _16 as &[&str] (PointerCoercion(Unsize));
        _14 = ProcMacro::custom_derive::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {derive_from_form_field}>(const "FromFormField", move _15, derive_from_form_field) -> [return: bb13, unwind continue];
    }

    bb13: {
        _23 = [const "field"];
        _22 = &_23;
        _21 = &(*_22);
        _20 = move _21 as &[&str] (PointerCoercion(Unsize));
        _19 = ProcMacro::custom_derive::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {derive_from_form}>(const "FromForm", move _20, derive_from_form) -> [return: bb14, unwind continue];
    }

    bb14: {
        _28 = [const "response"];
        _27 = &_28;
        _26 = &(*_27);
        _25 = move _26 as &[&str] (PointerCoercion(Unsize));
        _24 = ProcMacro::custom_derive::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {derive_responder}>(const "Responder", move _25, derive_responder) -> [return: bb15, unwind continue];
    }

    bb15: {
        _33 = [const "field"];
        _32 = &_33;
        _31 = &(*_32);
        _30 = move _31 as &[&str] (PointerCoercion(Unsize));
        _29 = ProcMacro::custom_derive::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {derive_uri_display_query}>(const "UriDisplayQuery", move _30, derive_uri_display_query) -> [return: bb16, unwind continue];
    }

    bb16: {
        _38 = [];
        _37 = &_38;
        _36 = &(*_37);
        _35 = move _36 as &[&str] (PointerCoercion(Unsize));
        _34 = ProcMacro::custom_derive::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {derive_uri_display_path}>(const "UriDisplayPath", move _35, derive_uri_display_path) -> [return: bb17, unwind continue];
    }

    bb17: {
        _39 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {routes}>(const "routes", routes) -> [return: bb18, unwind continue];
    }

    bb18: {
        _40 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {catchers}>(const "catchers", catchers) -> [return: bb19, unwind continue];
    }

    bb19: {
        _41 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {uri}>(const "uri", uri) -> [return: bb20, unwind continue];
    }

    bb20: {
        _42 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {rocket_internal_uri}>(const "rocket_internal_uri", rocket_internal_uri) -> [return: bb21, unwind continue];
    }

    bb21: {
        _43 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {__typed_stream}>(const "__typed_stream", __typed_stream) -> [return: bb22, unwind continue];
    }

    bb22: {
        _44 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {internal_guide_tests}>(const "internal_guide_tests", internal_guide_tests) -> [return: bb23, unwind continue];
    }

    bb23: {
        _45 = ProcMacro::bang::<fn(proc_macro::TokenStream) -> proc_macro::TokenStream {export}>(const "export", export) -> [return: bb24, unwind continue];
    }

    bb24: {
        _1 = [move _2, move _3, move _4, move _5, move _6, move _7, move _8, move _9, move _10, move _11, move _12, move _13, move _14, move _19, move _24, move _29, move _34, move _39, move _40, move _41, move _42, move _43, move _44, move _45];
        _0 = &_1;
        return;
    }
}

fn StaticPath(_1: Option<proc_macro2::Span>, _2: &str) -> StaticPath {
    let mut _0: exports::StaticPath;

    bb0: {
        _0 = StaticPath(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn StaticPath(_1: Option<proc_macro2::Span>, _2: &str) -> StaticPath {
    let mut _0: exports::StaticPath;

    bb0: {
        _0 = StaticPath(move _1, move _2);
        return;
    }
}

fn exports::StaticTokens(_1: fn() -> TokenStream2) -> exports::StaticTokens {
    let mut _0: exports::StaticTokens;

    bb0: {
        _0 = exports::StaticTokens(move _1);
        return;
    }
}

// MIR FOR CTFE
fn exports::StaticTokens(_1: fn() -> TokenStream2) -> exports::StaticTokens {
    let mut _0: exports::StaticTokens;

    bb0: {
        _0 = exports::StaticTokens(move _1);
        return;
    }
}

fn Diagnostics(_1: Vec<devise::Diagnostic>) -> Diagnostics {
    let mut _0: proc_macro_ext::Diagnostics;

    bb0: {
        _0 = Diagnostics(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Diagnostics(_1: Vec<devise::Diagnostic>) -> Diagnostics {
    let mut _0: proc_macro_ext::Diagnostics;

    bb0: {
        _0 = Diagnostics(move _1);
        return;
    }
}

fn StringLit(_1: std::string::String, _2: proc_macro2::Literal) -> StringLit {
    let mut _0: proc_macro_ext::StringLit;

    bb0: {
        _0 = StringLit(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn StringLit(_1: std::string::String, _2: proc_macro2::Literal) -> StringLit {
    let mut _0: proc_macro_ext::StringLit;

    bb0: {
        _0 = StringLit(move _1, move _2);
        return;
    }
}

fn FieldName::Cased(_1: name::Name) -> FieldName {
    let mut _0: derive::form_field::FieldName;

    bb0: {
        _0 = FieldName::Cased(move _1);
        return;
    }
}

// MIR FOR CTFE
fn FieldName::Cased(_1: name::Name) -> FieldName {
    let mut _0: derive::form_field::FieldName;

    bb0: {
        _0 = FieldName::Cased(move _1);
        return;
    }
}

fn FieldName::Uncased(_1: name::Name) -> FieldName {
    let mut _0: derive::form_field::FieldName;

    bb0: {
        _0 = FieldName::Uncased(move _1);
        return;
    }
}

// MIR FOR CTFE
fn FieldName::Uncased(_1: name::Name) -> FieldName {
    let mut _0: derive::form_field::FieldName;

    bb0: {
        _0 = FieldName::Uncased(move _1);
        return;
    }
}

fn RecordMemberAccesses(_1: Vec<Member>) -> RecordMemberAccesses {
    let mut _0: derive::form_field::RecordMemberAccesses;

    bb0: {
        _0 = RecordMemberAccesses(move _1);
        return;
    }
}

// MIR FOR CTFE
fn RecordMemberAccesses(_1: Vec<Member>) -> RecordMemberAccesses {
    let mut _0: derive::form_field::RecordMemberAccesses;

    bb0: {
        _0 = RecordMemberAccesses(move _1);
        return;
    }
}

fn Code(_1: Option<rocket_http::Status>) -> Code {
    let mut _0: attribute::catch::parse::Code;

    bb0: {
        _0 = Code(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Code(_1: Option<rocket_http::Status>) -> Code {
    let mut _0: attribute::catch::parse::Code;

    bb0: {
        _0 = Code(move _1);
        return;
    }
}

fn Parameter::Static(_1: name::Name) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Static(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Parameter::Static(_1: name::Name) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Static(move _1);
        return;
    }
}

fn Parameter::Ignored(_1: param::Dynamic) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Ignored(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Parameter::Ignored(_1: param::Dynamic) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Ignored(move _1);
        return;
    }
}

fn Parameter::Dynamic(_1: param::Dynamic) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Dynamic(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Parameter::Dynamic(_1: param::Dynamic) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Dynamic(move _1);
        return;
    }
}

fn Parameter::Guard(_1: Guard) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Guard(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Parameter::Guard(_1: Guard) -> Parameter {
    let mut _0: attribute::param::Parameter;

    bb0: {
        _0 = Parameter::Guard(move _1);
        return;
    }
}

fn uri_parsing::ArgExpr::Expr(_1: syn::Expr) -> uri_parsing::ArgExpr {
    let mut _0: bang::uri_parsing::ArgExpr;

    bb0: {
        _0 = uri_parsing::ArgExpr::Expr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::ArgExpr::Expr(_1: syn::Expr) -> uri_parsing::ArgExpr {
    let mut _0: bang::uri_parsing::ArgExpr;

    bb0: {
        _0 = uri_parsing::ArgExpr::Expr(move _1);
        return;
    }
}

fn uri_parsing::ArgExpr::Ignored(_1: Underscore) -> uri_parsing::ArgExpr {
    let mut _0: bang::uri_parsing::ArgExpr;

    bb0: {
        _0 = uri_parsing::ArgExpr::Ignored(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::ArgExpr::Ignored(_1: Underscore) -> uri_parsing::ArgExpr {
    let mut _0: bang::uri_parsing::ArgExpr;

    bb0: {
        _0 = uri_parsing::ArgExpr::Ignored(move _1);
        return;
    }
}

fn Arg::Unnamed(_1: uri_parsing::ArgExpr) -> Arg {
    let mut _0: bang::uri_parsing::Arg;

    bb0: {
        _0 = Arg::Unnamed(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Arg::Unnamed(_1: uri_parsing::ArgExpr) -> Arg {
    let mut _0: bang::uri_parsing::Arg;

    bb0: {
        _0 = Arg::Unnamed(move _1);
        return;
    }
}

fn Arg::Named(_1: name::Name, _2: proc_macro2::Ident, _3: syn::token::Eq, _4: uri_parsing::ArgExpr) -> Arg {
    let mut _0: bang::uri_parsing::Arg;

    bb0: {
        _0 = Arg::Named(move _1, move _2, move _3, move _4);
        return;
    }
}

// MIR FOR CTFE
fn Arg::Named(_1: name::Name, _2: proc_macro2::Ident, _3: syn::token::Eq, _4: uri_parsing::ArgExpr) -> Arg {
    let mut _0: bang::uri_parsing::Arg;

    bb0: {
        _0 = Arg::Named(move _1, move _2, move _3, move _4);
        return;
    }
}

fn uri_parsing::Args::Unnamed(_1: syn::punctuated::Punctuated<Arg, syn::token::Comma>) -> uri_parsing::Args {
    let mut _0: bang::uri_parsing::Args;

    bb0: {
        _0 = uri_parsing::Args::Unnamed(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Args::Unnamed(_1: syn::punctuated::Punctuated<Arg, syn::token::Comma>) -> uri_parsing::Args {
    let mut _0: bang::uri_parsing::Args;

    bb0: {
        _0 = uri_parsing::Args::Unnamed(move _1);
        return;
    }
}

fn uri_parsing::Args::Named(_1: syn::punctuated::Punctuated<Arg, syn::token::Comma>) -> uri_parsing::Args {
    let mut _0: bang::uri_parsing::Args;

    bb0: {
        _0 = uri_parsing::Args::Named(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Args::Named(_1: syn::punctuated::Punctuated<Arg, syn::token::Comma>) -> uri_parsing::Args {
    let mut _0: bang::uri_parsing::Args;

    bb0: {
        _0 = uri_parsing::Args::Named(move _1);
        return;
    }
}

fn UriLit(_1: rocket_http::uri::Uri<'_>, _2: proc_macro2::Span) -> UriLit {
    let mut _0: bang::uri_parsing::UriLit;

    bb0: {
        _0 = UriLit(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn UriLit(_1: rocket_http::uri::Uri<'_>, _2: proc_macro2::Span) -> UriLit {
    let mut _0: bang::uri_parsing::UriLit;

    bb0: {
        _0 = UriLit(move _1, move _2);
        return;
    }
}

fn UriExpr::Uri(_1: UriLit) -> UriExpr {
    let mut _0: bang::uri_parsing::UriExpr;

    bb0: {
        _0 = UriExpr::Uri(move _1);
        return;
    }
}

// MIR FOR CTFE
fn UriExpr::Uri(_1: UriLit) -> UriExpr {
    let mut _0: bang::uri_parsing::UriExpr;

    bb0: {
        _0 = UriExpr::Uri(move _1);
        return;
    }
}

fn UriExpr::Expr(_1: syn::Expr) -> UriExpr {
    let mut _0: bang::uri_parsing::UriExpr;

    bb0: {
        _0 = UriExpr::Expr(move _1);
        return;
    }
}

// MIR FOR CTFE
fn UriExpr::Expr(_1: syn::Expr) -> UriExpr {
    let mut _0: bang::uri_parsing::UriExpr;

    bb0: {
        _0 = UriExpr::Expr(move _1);
        return;
    }
}

fn uri_parsing::UriMacro::Literal(_1: UriLit) -> uri_parsing::UriMacro {
    let mut _0: bang::uri_parsing::UriMacro;

    bb0: {
        _0 = uri_parsing::UriMacro::Literal(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::UriMacro::Literal(_1: UriLit) -> uri_parsing::UriMacro {
    let mut _0: bang::uri_parsing::UriMacro;

    bb0: {
        _0 = uri_parsing::UriMacro::Literal(move _1);
        return;
    }
}

fn uri_parsing::UriMacro::Routed(_1: RoutedUri) -> uri_parsing::UriMacro {
    let mut _0: bang::uri_parsing::UriMacro;

    bb0: {
        _0 = uri_parsing::UriMacro::Routed(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::UriMacro::Routed(_1: RoutedUri) -> uri_parsing::UriMacro {
    let mut _0: bang::uri_parsing::UriMacro;

    bb0: {
        _0 = uri_parsing::UriMacro::Routed(move _1);
        return;
    }
}

fn uri_parsing::Validation::NamedIgnored(_1: Vec<&param::Dynamic>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::NamedIgnored(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Validation::NamedIgnored(_1: Vec<&param::Dynamic>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::NamedIgnored(move _1);
        return;
    }
}

fn uri_parsing::Validation::Unnamed(_1: usize, _2: usize) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Unnamed(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Validation::Unnamed(_1: usize, _2: usize) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Unnamed(move _1, move _2);
        return;
    }
}

fn uri_parsing::Validation::Named(_1: Vec<&name::Name>, _2: Vec<&proc_macro2::Ident>, _3: Vec<&proc_macro2::Ident>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Named(move _1, move _2, move _3);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Validation::Named(_1: Vec<&name::Name>, _2: Vec<&proc_macro2::Ident>, _3: Vec<&proc_macro2::Ident>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Named(move _1, move _2, move _3);
        return;
    }
}

fn uri_parsing::Validation::Ok(_1: Vec<&uri_parsing::ArgExpr>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Ok(move _1);
        return;
    }
}

// MIR FOR CTFE
fn uri_parsing::Validation::Ok(_1: Vec<&uri_parsing::ArgExpr>) -> uri_parsing::Validation<'_> {
    let mut _0: bang::uri_parsing::Validation<'_>;

    bb0: {
        _0 = uri_parsing::Validation::<'_>::Ok(move _1);
        return;
    }
}

fn typed_stream::Input::Type(_1: syn::Type) -> typed_stream::Input {
    let mut _0: bang::typed_stream::Input;

    bb0: {
        _0 = typed_stream::Input::Type(move _1);
        return;
    }
}

// MIR FOR CTFE
fn typed_stream::Input::Type(_1: syn::Type) -> typed_stream::Input {
    let mut _0: bang::typed_stream::Input;

    bb0: {
        _0 = typed_stream::Input::Type(move _1);
        return;
    }
}

fn typed_stream::Input::Tokens(_1: TokenStream2) -> typed_stream::Input {
    let mut _0: bang::typed_stream::Input;

    bb0: {
        _0 = typed_stream::Input::Tokens(move _1);
        return;
    }
}

// MIR FOR CTFE
fn typed_stream::Input::Tokens(_1: TokenStream2) -> typed_stream::Input {
    let mut _0: bang::typed_stream::Input;

    bb0: {
        _0 = typed_stream::Input::Tokens(move _1);
        return;
    }
}

fn http_codegen::ContentType(_1: rocket_http::ContentType) -> http_codegen::ContentType {
    let mut _0: http_codegen::ContentType;

    bb0: {
        _0 = http_codegen::ContentType(move _1);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::ContentType(_1: rocket_http::ContentType) -> http_codegen::ContentType {
    let mut _0: http_codegen::ContentType;

    bb0: {
        _0 = http_codegen::ContentType(move _1);
        return;
    }
}

fn http_codegen::Status(_1: rocket_http::Status) -> http_codegen::Status {
    let mut _0: http_codegen::Status;

    bb0: {
        _0 = http_codegen::Status(move _1);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Status(_1: rocket_http::Status) -> http_codegen::Status {
    let mut _0: http_codegen::Status;

    bb0: {
        _0 = http_codegen::Status(move _1);
        return;
    }
}

fn http_codegen::MediaType(_1: rocket_http::MediaType) -> http_codegen::MediaType {
    let mut _0: http_codegen::MediaType;

    bb0: {
        _0 = http_codegen::MediaType(move _1);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::MediaType(_1: rocket_http::MediaType) -> http_codegen::MediaType {
    let mut _0: http_codegen::MediaType;

    bb0: {
        _0 = http_codegen::MediaType(move _1);
        return;
    }
}

fn http_codegen::Method(_1: rocket_http::Method) -> http_codegen::Method {
    let mut _0: http_codegen::Method;

    bb0: {
        _0 = http_codegen::Method(move _1);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Method(_1: rocket_http::Method) -> http_codegen::Method {
    let mut _0: http_codegen::Method;

    bb0: {
        _0 = http_codegen::Method(move _1);
        return;
    }
}

fn Optional(_1: Option<T>) -> Optional<T> {
    let mut _0: http_codegen::Optional<T>;

    bb0: {
        _0 = Optional::<T>(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Optional(_1: Option<T>) -> Optional<T> {
    let mut _0: http_codegen::Optional<T>;

    bb0: {
        _0 = Optional::<T>(move _1);
        return;
    }
}

fn http_codegen::Origin(_1: &rocket_http::uri::Origin<'_>, _2: proc_macro2::Span) -> http_codegen::Origin<'_> {
    let mut _0: http_codegen::Origin<'_>;

    bb0: {
        _0 = http_codegen::Origin::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Origin(_1: &rocket_http::uri::Origin<'_>, _2: proc_macro2::Span) -> http_codegen::Origin<'_> {
    let mut _0: http_codegen::Origin<'_>;

    bb0: {
        _0 = http_codegen::Origin::<'_>(move _1, move _2);
        return;
    }
}

fn http_codegen::Absolute(_1: &rocket_http::uri::Absolute<'_>, _2: proc_macro2::Span) -> http_codegen::Absolute<'_> {
    let mut _0: http_codegen::Absolute<'_>;

    bb0: {
        _0 = http_codegen::Absolute::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Absolute(_1: &rocket_http::uri::Absolute<'_>, _2: proc_macro2::Span) -> http_codegen::Absolute<'_> {
    let mut _0: http_codegen::Absolute<'_>;

    bb0: {
        _0 = http_codegen::Absolute::<'_>(move _1, move _2);
        return;
    }
}

fn http_codegen::Authority(_1: &rocket_http::uri::Authority<'_>, _2: proc_macro2::Span) -> http_codegen::Authority<'_> {
    let mut _0: http_codegen::Authority<'_>;

    bb0: {
        _0 = http_codegen::Authority::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Authority(_1: &rocket_http::uri::Authority<'_>, _2: proc_macro2::Span) -> http_codegen::Authority<'_> {
    let mut _0: http_codegen::Authority<'_>;

    bb0: {
        _0 = http_codegen::Authority::<'_>(move _1, move _2);
        return;
    }
}

fn http_codegen::Reference(_1: &rocket_http::uri::Reference<'_>, _2: proc_macro2::Span) -> http_codegen::Reference<'_> {
    let mut _0: http_codegen::Reference<'_>;

    bb0: {
        _0 = http_codegen::Reference::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Reference(_1: &rocket_http::uri::Reference<'_>, _2: proc_macro2::Span) -> http_codegen::Reference<'_> {
    let mut _0: http_codegen::Reference<'_>;

    bb0: {
        _0 = http_codegen::Reference::<'_>(move _1, move _2);
        return;
    }
}

fn http_codegen::Asterisk(_1: rocket_http::uri::Asterisk, _2: proc_macro2::Span) -> http_codegen::Asterisk {
    let mut _0: http_codegen::Asterisk;

    bb0: {
        _0 = http_codegen::Asterisk(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn http_codegen::Asterisk(_1: rocket_http::uri::Asterisk, _2: proc_macro2::Span) -> http_codegen::Asterisk {
    let mut _0: http_codegen::Asterisk;

    bb0: {
        _0 = http_codegen::Asterisk(move _1, move _2);
        return;
    }
}

fn ConcreteVisitor(_1: bool, _2: &[&proc_macro2::Ident]) -> ConcreteVisitor<'_> {
    let mut _0: <syn::Type as syn_ext::TypeExt>::is_concrete::ConcreteVisitor<'_>;

    bb0: {
        _0 = ConcreteVisitor::<'_>(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn ConcreteVisitor(_1: bool, _2: &[&proc_macro2::Ident]) -> ConcreteVisitor<'_> {
    let mut _0: <syn::Type as syn_ext::TypeExt>::is_concrete::ConcreteVisitor<'_>;

    bb0: {
        _0 = ConcreteVisitor::<'_>(move _1, move _2);
        return;
    }
}
