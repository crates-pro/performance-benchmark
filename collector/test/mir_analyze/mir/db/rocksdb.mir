// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn error_message(_1: *const i8) -> String {
    debug ptr => _1;
    let mut _0: std::string::String;
    let _2: &std::ffi::CStr;
    let mut _4: std::borrow::Cow<'_, str>;
    let _5: &[u8];
    let _6: ();
    let mut _7: *mut libc::c_void;
    scope 1 {
        debug cstr => _2;
        let _3: std::string::String;
        scope 3 {
            debug s => _3;
            scope 4 {
            }
        }
    }
    scope 2 {
    }

    bb0: {
        _2 = CStr::from_ptr::<'_>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = CStr::to_bytes(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = String::from_utf8_lossy(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = Cow::<'_, str>::into_owned(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = _1 as *mut libc::c_void (PtrToPtr);
        _6 = free(move _7) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = move _3;
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn opt_bytes_to_ptr(_1: Option<T>) -> *const i8 {
    debug opt => _1;
    let mut _0: *const i8;
    let mut _2: isize;
    let _3: T;
    let mut _4: *const u8;
    let _5: &[u8];
    let mut _6: &T;
    scope 1 {
        debug v => _3;
    }

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb1, 1: bb3, otherwise: bb2];
    }

    bb1: {
        _0 = null::<i8>() -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = move ((_1 as Some).0: T);
        _6 = &_3;
        _5 = <T as AsRef<[u8]>>::as_ref(move _6) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _4 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = move _4 as *const i8 (PtrToPtr);
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        resume;
    }
}

fn backup::<impl at src/backup.rs:35:1: 35:18>::open(_1: &BackupEngineOptions, _2: P) -> Result<BackupEngine, Error> {
    debug opts => _1;
    debug path => _2;
    let mut _0: std::result::Result<backup::BackupEngine, Error>;
    let _3: &std::path::Path;
    let mut _4: &P;
    let mut _6: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _7: &[u8];
    let _8: &str;
    let mut _9: &std::borrow::Cow<'_, str>;
    let _10: std::borrow::Cow<'_, str>;
    let mut _11: isize;
    let mut _13: Error;
    let mut _14: std::string::String;
    let _15: &str;
    let mut _18: *const ffi::rocksdb_options_t;
    let mut _19: *mut ffi::rocksdb_options_t;
    let mut _20: *const i8;
    let _21: &std::ffi::CStr;
    let mut _22: &std::ffi::CString;
    let mut _23: *mut *mut i8;
    let mut _24: &mut *mut i8;
    let mut _25: bool;
    let mut _26: *mut i8;
    let mut _27: Error;
    let mut _28: std::string::String;
    let mut _29: *const i8;
    let mut _30: *mut i8;
    let mut _31: bool;
    let mut _32: Error;
    let mut _33: std::string::String;
    let _34: &str;
    let mut _35: backup::BackupEngine;
    let mut _36: isize;
    let mut _37: isize;
    let mut _38: isize;
    scope 1 {
        debug path => _3;
        let _5: std::ffi::CString;
        let _12: std::ffi::CString;
        scope 2 {
            debug cpath => _5;
            scope 4 {
                debug be => _17;
                scope 5 {
                    let mut _16: *mut i8;
                    scope 6 {
                        debug err => _16;
                        let _17: *mut ffi::rocksdb_backup_engine_t;
                        scope 7 {
                            debug result => _17;
                        }
                    }
                }
            }
        }
        scope 3 {
            debug c => _12;
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <P as AsRef<Path>>::as_ref(move _4) -> [return: bb1, unwind: bb33];
    }

    bb1: {
        _10 = Path::to_string_lossy(_3) -> [return: bb2, unwind: bb33];
    }

    bb2: {
        _9 = &_10;
        _8 = <Cow<'_, str> as Deref>::deref(move _9) -> [return: bb3, unwind: bb32];
    }

    bb3: {
        _7 = core::str::<impl str>::as_bytes(_8) -> [return: bb4, unwind: bb32];
    }

    bb4: {
        _6 = CString::new::<&[u8]>(move _7) -> [return: bb5, unwind: bb32];
    }

    bb5: {
        _11 = discriminant(_6);
        switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _15 = const "Failed to convert path to CString when opening backup engine";
        _14 = <str as ToOwned>::to_owned(_15) -> [return: bb9, unwind: bb40];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _12 = move ((_6 as Ok).0: std::ffi::CString);
        _5 = move _12;
        _36 = discriminant(_6);
        switchInt(move _36) -> [0: bb35, otherwise: bb36];
    }

    bb9: {
        _13 = Error::new(move _14) -> [return: bb10, unwind: bb40];
    }

    bb10: {
        _0 = Result::<BackupEngine, Error>::Err(move _13);
        _37 = discriminant(_6);
        switchInt(move _37) -> [0: bb37, otherwise: bb38];
    }

    bb11: {
        _16 = null_mut::<i8>() -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _19 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _18 = move _19 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _22 = &_5;
        _21 = <CString as Deref>::deref(move _22) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _20 = CStr::as_ptr(_21) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _24 = &mut _16;
        _23 = &raw mut (*_24);
        _17 = rocksdb_backup_engine_open(move _18, move _20, move _23) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _26 = _16;
        _25 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _26) -> [return: bb16, unwind: bb31];
    }

    bb16: {
        switchInt(move _25) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _31 = std::ptr::mut_ptr::<impl *mut rocksdb_backup_engine_t>::is_null(_17) -> [return: bb21, unwind: bb31];
    }

    bb18: {
        _30 = _16;
        _29 = move _30 as *const i8 (PointerCoercion(MutToConstPointer));
        _28 = error_message(move _29) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        _27 = Error::new(move _28) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _0 = Result::<BackupEngine, Error>::Err(move _27);
        goto -> bb27;
    }

    bb21: {
        switchInt(move _31) -> [0: bb25, otherwise: bb22];
    }

    bb22: {
        _34 = const "Could not initialize backup engine.";
        _33 = <str as ToOwned>::to_owned(_34) -> [return: bb23, unwind: bb31];
    }

    bb23: {
        _32 = Error::new(move _33) -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _0 = Result::<BackupEngine, Error>::Err(move _32);
        goto -> bb27;
    }

    bb25: {
        _35 = BackupEngine { inner: _17 };
        _0 = Result::<BackupEngine, Error>::Ok(move _35);
        drop(_5) -> [return: bb26, unwind: bb33];
    }

    bb26: {
        drop(_2) -> [return: bb29, unwind continue];
    }

    bb27: {
        drop(_5) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        drop(_2) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_10) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_5) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_10) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_2) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        resume;
    }

    bb35: {
        drop(_10) -> [return: bb11, unwind: bb31];
    }

    bb36: {
        drop(_6) -> [return: bb35, unwind: bb30];
    }

    bb37: {
        drop(_10) -> [return: bb28, unwind: bb33];
    }

    bb38: {
        drop(_6) -> [return: bb37, unwind: bb32];
    }

    bb39 (cleanup): {
        drop(_6) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        _38 = discriminant(_6);
        switchInt(move _38) -> [0: bb32, otherwise: bb39];
    }
}

fn backup::<impl at src/backup.rs:35:1: 35:18>::create_new_backup(_1: &mut BackupEngine, _2: &DB) -> Result<(), Error> {
    debug self => _1;
    debug db => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _5: *mut ffi::rocksdb_backup_engine_t;
    let mut _6: *mut ffi::rocksdb_t;
    let mut _7: *mut *mut i8;
    let mut _8: &mut *mut i8;
    let mut _9: bool;
    let mut _10: *mut i8;
    let mut _11: Error;
    let mut _12: std::string::String;
    let mut _13: *const i8;
    let mut _14: *mut i8;
    scope 1 {
        let mut _3: *mut i8;
        scope 2 {
            debug err => _3;
            let _4: ();
            scope 3 {
                debug result => const ();
            }
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ((*_1).0: *mut ffi::rocksdb_backup_engine_t);
        _6 = ((*_2).0: *mut ffi::rocksdb_t);
        _8 = &mut _3;
        _7 = &raw mut (*_8);
        _4 = rocksdb_backup_engine_create_new_backup(move _5, move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = _3;
        _9 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _9) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Result::<(), Error>::Ok(const ());
        goto -> bb8;
    }

    bb5: {
        _14 = _3;
        _13 = move _14 as *const i8 (PointerCoercion(MutToConstPointer));
        _12 = error_message(move _13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = Error::new(move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Result::<(), Error>::Err(move _11);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn backup::<impl at src/backup.rs:35:1: 35:18>::purge_old_backups(_1: &mut BackupEngine, _2: usize) -> Result<(), Error> {
    debug self => _1;
    debug num_backups_to_keep => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _5: *mut ffi::rocksdb_backup_engine_t;
    let mut _6: u32;
    let mut _7: *mut *mut i8;
    let mut _8: &mut *mut i8;
    let mut _9: bool;
    let mut _10: *mut i8;
    let mut _11: Error;
    let mut _12: std::string::String;
    let mut _13: *const i8;
    let mut _14: *mut i8;
    scope 1 {
        let mut _3: *mut i8;
        scope 2 {
            debug err => _3;
            let _4: ();
            scope 3 {
                debug result => const ();
            }
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ((*_1).0: *mut ffi::rocksdb_backup_engine_t);
        _6 = _2 as u32 (IntToInt);
        _8 = &mut _3;
        _7 = &raw mut (*_8);
        _4 = rocksdb_backup_engine_purge_old_backups(move _5, move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = _3;
        _9 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _9) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Result::<(), Error>::Ok(const ());
        goto -> bb8;
    }

    bb5: {
        _14 = _3;
        _13 = move _14 as *const i8 (PointerCoercion(MutToConstPointer));
        _12 = error_message(move _13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = Error::new(move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Result::<(), Error>::Err(move _11);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn backup::<impl at src/backup.rs:35:1: 35:18>::restore_from_latest_backup(_1: &mut BackupEngine, _2: D, _3: W, _4: &RestoreOptions) -> Result<(), Error> {
    debug self => _1;
    debug db_dir => _2;
    debug wal_dir => _3;
    debug opts => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &std::path::Path;
    let mut _6: &D;
    let mut _8: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _9: &[u8];
    let _10: &str;
    let mut _11: &std::borrow::Cow<'_, str>;
    let _12: std::borrow::Cow<'_, str>;
    let mut _13: isize;
    let mut _15: Error;
    let mut _16: std::string::String;
    let _17: &str;
    let mut _19: &W;
    let mut _21: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _22: &[u8];
    let _23: &str;
    let mut _24: &std::borrow::Cow<'_, str>;
    let _25: std::borrow::Cow<'_, str>;
    let mut _26: isize;
    let mut _28: Error;
    let mut _29: std::string::String;
    let _30: &str;
    let mut _33: *mut ffi::rocksdb_backup_engine_t;
    let mut _34: *const i8;
    let _35: &std::ffi::CStr;
    let mut _36: &std::ffi::CString;
    let mut _37: *const i8;
    let _38: &std::ffi::CStr;
    let mut _39: &std::ffi::CString;
    let mut _40: *const ffi::rocksdb_restore_options_t;
    let mut _41: *mut ffi::rocksdb_restore_options_t;
    let mut _42: *mut *mut i8;
    let mut _43: &mut *mut i8;
    let mut _44: bool;
    let mut _45: *mut i8;
    let mut _46: Error;
    let mut _47: std::string::String;
    let mut _48: *const i8;
    let mut _49: *mut i8;
    let mut _50: isize;
    let mut _51: isize;
    let mut _52: isize;
    let mut _53: isize;
    let mut _54: isize;
    let mut _55: isize;
    scope 1 {
        debug db_dir => _5;
        let _7: std::ffi::CString;
        let _14: std::ffi::CString;
        scope 2 {
            debug c_db_dir => _7;
            let _18: &std::path::Path;
            scope 4 {
                debug wal_dir => _18;
                let _20: std::ffi::CString;
                let _27: std::ffi::CString;
                scope 5 {
                    debug c_wal_dir => _20;
                    scope 7 {
                        let mut _31: *mut i8;
                        scope 8 {
                            debug err => _31;
                            let _32: ();
                            scope 9 {
                                debug result => const ();
                            }
                        }
                    }
                }
                scope 6 {
                    debug c => _27;
                }
            }
        }
        scope 3 {
            debug c => _14;
        }
    }

    bb0: {
        _6 = &_2;
        _5 = <D as AsRef<Path>>::as_ref(move _6) -> [return: bb1, unwind: bb46];
    }

    bb1: {
        _12 = Path::to_string_lossy(_5) -> [return: bb2, unwind: bb46];
    }

    bb2: {
        _11 = &_12;
        _10 = <Cow<'_, str> as Deref>::deref(move _11) -> [return: bb3, unwind: bb45];
    }

    bb3: {
        _9 = core::str::<impl str>::as_bytes(_10) -> [return: bb4, unwind: bb45];
    }

    bb4: {
        _8 = CString::new::<&[u8]>(move _9) -> [return: bb5, unwind: bb45];
    }

    bb5: {
        _13 = discriminant(_8);
        switchInt(move _13) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _17 = const "Failed to convert db_dir to CString when restoring from latest backup";
        _16 = <str as ToOwned>::to_owned(_17) -> [return: bb9, unwind: bb60];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _14 = move ((_8 as Ok).0: std::ffi::CString);
        _7 = move _14;
        _50 = discriminant(_8);
        switchInt(move _50) -> [0: bb49, otherwise: bb50];
    }

    bb9: {
        _15 = Error::new(move _16) -> [return: bb10, unwind: bb60];
    }

    bb10: {
        _0 = Result::<(), Error>::Err(move _15);
        _51 = discriminant(_8);
        switchInt(move _51) -> [0: bb51, otherwise: bb52];
    }

    bb11: {
        _19 = &_3;
        _18 = <W as AsRef<Path>>::as_ref(move _19) -> [return: bb12, unwind: bb44];
    }

    bb12: {
        _25 = Path::to_string_lossy(_18) -> [return: bb13, unwind: bb44];
    }

    bb13: {
        _24 = &_25;
        _23 = <Cow<'_, str> as Deref>::deref(move _24) -> [return: bb14, unwind: bb42];
    }

    bb14: {
        _22 = core::str::<impl str>::as_bytes(_23) -> [return: bb15, unwind: bb42];
    }

    bb15: {
        _21 = CString::new::<&[u8]>(move _22) -> [return: bb16, unwind: bb42];
    }

    bb16: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb18, 1: bb17, otherwise: bb7];
    }

    bb17: {
        _30 = const "Failed to convert wal_dir to CString when restoring from latest backup";
        _29 = <str as ToOwned>::to_owned(_30) -> [return: bb19, unwind: bb58];
    }

    bb18: {
        _27 = move ((_21 as Ok).0: std::ffi::CString);
        _20 = move _27;
        _52 = discriminant(_21);
        switchInt(move _52) -> [0: bb53, otherwise: bb54];
    }

    bb19: {
        _28 = Error::new(move _29) -> [return: bb20, unwind: bb58];
    }

    bb20: {
        _0 = Result::<(), Error>::Err(move _28);
        _53 = discriminant(_21);
        switchInt(move _53) -> [0: bb55, otherwise: bb56];
    }

    bb21: {
        _31 = null_mut::<i8>() -> [return: bb22, unwind: bb41];
    }

    bb22: {
        _33 = ((*_1).0: *mut ffi::rocksdb_backup_engine_t);
        _36 = &_7;
        _35 = <CString as Deref>::deref(move _36) -> [return: bb23, unwind: bb41];
    }

    bb23: {
        _34 = CStr::as_ptr(_35) -> [return: bb24, unwind: bb41];
    }

    bb24: {
        _39 = &_20;
        _38 = <CString as Deref>::deref(move _39) -> [return: bb25, unwind: bb41];
    }

    bb25: {
        _37 = CStr::as_ptr(_38) -> [return: bb26, unwind: bb41];
    }

    bb26: {
        _41 = ((*_4).0: *mut ffi::rocksdb_restore_options_t);
        _40 = move _41 as *const ffi::rocksdb_restore_options_t (PointerCoercion(MutToConstPointer));
        _43 = &mut _31;
        _42 = &raw mut (*_43);
        _32 = rocksdb_backup_engine_restore_db_from_latest_backup(move _33, move _34, move _37, move _40, move _42) -> [return: bb27, unwind: bb41];
    }

    bb27: {
        _45 = _31;
        _44 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _45) -> [return: bb28, unwind: bb41];
    }

    bb28: {
        switchInt(move _44) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_20) -> [return: bb33, unwind: bb44];
    }

    bb30: {
        _49 = _31;
        _48 = move _49 as *const i8 (PointerCoercion(MutToConstPointer));
        _47 = error_message(move _48) -> [return: bb31, unwind: bb41];
    }

    bb31: {
        _46 = Error::new(move _47) -> [return: bb32, unwind: bb41];
    }

    bb32: {
        _0 = Result::<(), Error>::Err(move _46);
        drop(_20) -> [return: bb36, unwind: bb44];
    }

    bb33: {
        drop(_7) -> [return: bb34, unwind: bb46];
    }

    bb34: {
        drop(_3) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        drop(_2) -> [return: bb39, unwind continue];
    }

    bb36: {
        drop(_7) -> [return: bb37, unwind: bb46];
    }

    bb37: {
        drop(_3) -> [return: bb38, unwind: bb47];
    }

    bb38: {
        drop(_2) -> [return: bb39, unwind continue];
    }

    bb39: {
        return;
    }

    bb40 (cleanup): {
        drop(_25) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_20) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_25) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_12) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_7) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_12) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_3) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        drop(_2) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        resume;
    }

    bb49: {
        drop(_12) -> [return: bb11, unwind: bb44];
    }

    bb50: {
        drop(_8) -> [return: bb49, unwind: bb43];
    }

    bb51: {
        drop(_12) -> [return: bb37, unwind: bb46];
    }

    bb52: {
        drop(_8) -> [return: bb51, unwind: bb45];
    }

    bb53: {
        drop(_25) -> [return: bb21, unwind: bb41];
    }

    bb54: {
        drop(_21) -> [return: bb53, unwind: bb40];
    }

    bb55: {
        drop(_25) -> [return: bb36, unwind: bb44];
    }

    bb56: {
        drop(_21) -> [return: bb55, unwind: bb42];
    }

    bb57 (cleanup): {
        drop(_21) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        _54 = discriminant(_21);
        switchInt(move _54) -> [0: bb42, otherwise: bb57];
    }

    bb59 (cleanup): {
        drop(_8) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        _55 = discriminant(_8);
        switchInt(move _55) -> [0: bb45, otherwise: bb59];
    }
}

fn backup::<impl at src/backup.rs:150:1: 150:20>::set_keep_log_files(_1: &mut RestoreOptions, _2: bool) -> () {
    debug self => _1;
    debug keep_log_files => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_restore_options_t;
    let mut _5: i32;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_restore_options_t);
        _5 = _2 as i32 (IntToInt);
        _3 = rocksdb_restore_options_set_keep_log_files(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn backup::<impl at src/backup.rs:158:1: 158:37>::default() -> BackupEngineOptions {
    let mut _0: backup::BackupEngineOptions;
    let mut _2: bool;
    let _3: !;
    let mut _4: std::string::String;
    let _5: &str;
    scope 1 {
        let _1: *mut ffi::rocksdb_options_t;
        scope 2 {
            debug opts => _1;
        }
    }

    bb0: {
        _1 = rocksdb_options_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_options_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _5 = const "Could not create RocksDB backup options";
        _4 = <str as ToOwned>::to_owned(_5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = begin_panic::<String>(move _4) -> unwind continue;
    }

    bb5: {
        _0 = BackupEngineOptions { inner: _1 };
        return;
    }
}

fn backup::<impl at src/backup.rs:170:1: 170:32>::default() -> RestoreOptions {
    let mut _0: backup::RestoreOptions;
    let mut _2: bool;
    let _3: !;
    let mut _4: std::string::String;
    let _5: &str;
    scope 1 {
        let _1: *mut ffi::rocksdb_restore_options_t;
        scope 2 {
            debug opts => _1;
        }
    }

    bb0: {
        _1 = rocksdb_restore_options_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_restore_options_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _5 = const "Could not create RocksDB restore options";
        _4 = <str as ToOwned>::to_owned(_5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = begin_panic::<String>(move _4) -> unwind continue;
    }

    bb5: {
        _0 = RestoreOptions { inner: _1 };
        return;
    }
}

fn backup::<impl at src/backup.rs:182:1: 182:27>::drop(_1: &mut BackupEngine) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_backup_engine_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_backup_engine_t);
        _2 = rocksdb_backup_engine_close(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn backup::<impl at src/backup.rs:190:1: 190:34>::drop(_1: &mut BackupEngineOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _2 = rocksdb_options_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn backup::<impl at src/backup.rs:198:1: 198:29>::drop(_1: &mut RestoreOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_restore_options_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_restore_options_t);
        _2 = rocksdb_restore_options_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const LOG_SIZE_FOR_FLUSH: u64 = {
    let mut _0: u64;

    bb0: {
        _0 = const 0_u64;
        return;
    }
}

fn checkpoint::<impl at src/checkpoint.rs:33:1: 33:16>::new(_1: &DB) -> Result<Checkpoint, Error> {
    debug db => _1;
    let mut _0: std::result::Result<checkpoint::Checkpoint, Error>;
    let mut _4: *mut ffi::rocksdb_t;
    let mut _5: *mut *mut i8;
    let mut _6: &mut *mut i8;
    let mut _7: bool;
    let mut _8: *mut i8;
    let mut _9: Error;
    let mut _10: std::string::String;
    let mut _11: *const i8;
    let mut _12: *mut i8;
    let mut _13: bool;
    let mut _14: Error;
    let mut _15: std::string::String;
    let _16: &str;
    let mut _17: checkpoint::Checkpoint;
    scope 1 {
        debug checkpoint => _3;
        scope 2 {
            let mut _2: *mut i8;
            scope 3 {
                debug err => _2;
                let _3: *mut ffi::rocksdb_checkpoint_t;
                scope 4 {
                    debug result => _3;
                }
            }
        }
    }

    bb0: {
        _2 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ((*_1).0: *mut ffi::rocksdb_t);
        _6 = &mut _2;
        _5 = &raw mut (*_6);
        _3 = rocksdb_checkpoint_object_create(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = _2;
        _7 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _13 = std::ptr::mut_ptr::<impl *mut rocksdb_checkpoint_t>::is_null(_3) -> [return: bb8, unwind continue];
    }

    bb5: {
        _12 = _2;
        _11 = move _12 as *const i8 (PointerCoercion(MutToConstPointer));
        _10 = error_message(move _11) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = Error::new(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Result::<Checkpoint, Error>::Err(move _9);
        goto -> bb13;
    }

    bb8: {
        switchInt(move _13) -> [0: bb12, otherwise: bb9];
    }

    bb9: {
        _16 = const "Could not create checkpoint object.";
        _15 = <str as ToOwned>::to_owned(_16) -> [return: bb10, unwind continue];
    }

    bb10: {
        _14 = Error::new(move _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = Result::<Checkpoint, Error>::Err(move _14);
        goto -> bb13;
    }

    bb12: {
        _17 = Checkpoint { inner: _3 };
        _0 = Result::<Checkpoint, Error>::Ok(move _17);
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

fn checkpoint::<impl at src/checkpoint.rs:33:1: 33:16>::create_checkpoint(_1: &Checkpoint, _2: P) -> Result<(), Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), Error>;
    let _3: &std::path::Path;
    let mut _4: &P;
    let mut _6: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _7: &[u8];
    let _8: &str;
    let mut _9: &std::borrow::Cow<'_, str>;
    let _10: std::borrow::Cow<'_, str>;
    let mut _11: isize;
    let mut _13: Error;
    let mut _14: std::string::String;
    let _15: &str;
    let mut _18: *mut ffi::rocksdb_checkpoint_t;
    let mut _19: *const i8;
    let _20: &std::ffi::CStr;
    let mut _21: &std::ffi::CString;
    let mut _22: *mut *mut i8;
    let mut _23: &mut *mut i8;
    let mut _24: bool;
    let mut _25: *mut i8;
    let mut _26: Error;
    let mut _27: std::string::String;
    let mut _28: *const i8;
    let mut _29: *mut i8;
    let mut _30: isize;
    let mut _31: isize;
    let mut _32: isize;
    scope 1 {
        debug path => _3;
        let _5: std::ffi::CString;
        let _12: std::ffi::CString;
        scope 2 {
            debug cpath => _5;
            scope 4 {
                let mut _16: *mut i8;
                scope 5 {
                    debug err => _16;
                    let _17: ();
                    scope 6 {
                        debug result => const ();
                    }
                }
            }
        }
        scope 3 {
            debug c => _12;
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <P as AsRef<Path>>::as_ref(move _4) -> [return: bb1, unwind: bb27];
    }

    bb1: {
        _10 = Path::to_string_lossy(_3) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        _9 = &_10;
        _8 = <Cow<'_, str> as Deref>::deref(move _9) -> [return: bb3, unwind: bb26];
    }

    bb3: {
        _7 = core::str::<impl str>::as_bytes(_8) -> [return: bb4, unwind: bb26];
    }

    bb4: {
        _6 = CString::new::<&[u8]>(move _7) -> [return: bb5, unwind: bb26];
    }

    bb5: {
        _11 = discriminant(_6);
        switchInt(move _11) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _15 = const "Failed to convert path to CString when creating DB checkpoint";
        _14 = <str as ToOwned>::to_owned(_15) -> [return: bb9, unwind: bb34];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _12 = move ((_6 as Ok).0: std::ffi::CString);
        _5 = move _12;
        _30 = discriminant(_6);
        switchInt(move _30) -> [0: bb29, otherwise: bb30];
    }

    bb9: {
        _13 = Error::new(move _14) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _0 = Result::<(), Error>::Err(move _13);
        _31 = discriminant(_6);
        switchInt(move _31) -> [0: bb31, otherwise: bb32];
    }

    bb11: {
        _16 = null_mut::<i8>() -> [return: bb12, unwind: bb25];
    }

    bb12: {
        _18 = ((*_1).0: *mut ffi::rocksdb_checkpoint_t);
        _21 = &_5;
        _20 = <CString as Deref>::deref(move _21) -> [return: bb13, unwind: bb25];
    }

    bb13: {
        _19 = CStr::as_ptr(_20) -> [return: bb14, unwind: bb25];
    }

    bb14: {
        _23 = &mut _16;
        _22 = &raw mut (*_23);
        _17 = rocksdb_checkpoint_create(move _18, move _19, const _, move _22) -> [return: bb15, unwind: bb25];
    }

    bb15: {
        _25 = _16;
        _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _25) -> [return: bb16, unwind: bb25];
    }

    bb16: {
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_5) -> [return: bb21, unwind: bb27];
    }

    bb18: {
        _29 = _16;
        _28 = move _29 as *const i8 (PointerCoercion(MutToConstPointer));
        _27 = error_message(move _28) -> [return: bb19, unwind: bb25];
    }

    bb19: {
        _26 = Error::new(move _27) -> [return: bb20, unwind: bb25];
    }

    bb20: {
        _0 = Result::<(), Error>::Err(move _26);
        drop(_5) -> [return: bb22, unwind: bb27];
    }

    bb21: {
        drop(_2) -> [return: bb23, unwind continue];
    }

    bb22: {
        drop(_2) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_10) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_5) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_10) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_2) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29: {
        drop(_10) -> [return: bb11, unwind: bb25];
    }

    bb30: {
        drop(_6) -> [return: bb29, unwind: bb24];
    }

    bb31: {
        drop(_10) -> [return: bb22, unwind: bb27];
    }

    bb32: {
        drop(_6) -> [return: bb31, unwind: bb26];
    }

    bb33 (cleanup): {
        drop(_6) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        _32 = discriminant(_6);
        switchInt(move _32) -> [0: bb26, otherwise: bb33];
    }
}

fn checkpoint::<impl at src/checkpoint.rs:74:1: 74:25>::drop(_1: &mut Checkpoint) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_checkpoint_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_checkpoint_t);
        _2 = rocksdb_checkpoint_object_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn compaction_filter::destructor_callback(_1: *mut c_void) -> () {
    debug raw_cb => _1;
    let mut _0: ();
    let mut _2: std::boxed::Box<compaction_filter::CompactionFilterCallback<F>>;
    scope 1 {
    }

    bb0: {
        _2 = _1 as std::boxed::Box<compaction_filter::CompactionFilterCallback<F>> (Transmute);
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn compaction_filter::name_callback(_1: *mut c_void) -> *const i8 {
    debug raw_cb => _1;
    let mut _0: *const i8;
    let _2: &compaction_filter::CompactionFilterCallback<F>;
    let _3: *mut compaction_filter::CompactionFilterCallback<F>;
    let _4: &std::ffi::CStr;
    let mut _5: &std::ffi::CString;
    scope 1 {
        debug cb => _2;
    }

    bb0: {
        _3 = _1 as *mut compaction_filter::CompactionFilterCallback<F> (PtrToPtr);
        _2 = &(*_3);
        _5 = &((*_2).0: std::ffi::CString);
        _4 = <CString as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn filter_callback(_1: *mut c_void, _2: i32, _3: *const i8, _4: usize, _5: *const i8, _6: usize, _7: *mut *mut i8, _8: *mut usize, _9: *mut u8) -> u8 {
    debug raw_cb => _1;
    debug level => _2;
    debug raw_key => _3;
    debug key_length => _4;
    debug existing_value => _5;
    debug value_length => _6;
    debug new_value => _7;
    debug new_value_length => _8;
    debug value_changed => _9;
    let mut _0: u8;
    let _10: &mut compaction_filter::CompactionFilterCallback<F>;
    let mut _11: *mut compaction_filter::CompactionFilterCallback<F>;
    let mut _13: *const u8;
    let mut _15: *const u8;
    let mut _17: &mut F;
    let mut _18: (u32, &[u8], &[u8]);
    let mut _19: u32;
    let mut _20: isize;
    let mut _22: *const u8;
    let mut _23: usize;
    let mut _24: u8;
    scope 1 {
        debug cb => _10;
        let _12: &[u8];
        scope 2 {
            debug key => _12;
            let _14: &[u8];
            scope 3 {
                debug oldval => _14;
                let _16: compaction_filter::Decision;
                scope 4 {
                    debug result => _16;
                    let _21: &[u8];
                    scope 5 {
                        debug newval => _21;
                        let mut _25: *const ();
                        let mut _26: usize;
                        let mut _27: usize;
                        let mut _28: usize;
                        let mut _29: usize;
                        let mut _30: bool;
                        let mut _31: *const ();
                        let mut _32: usize;
                        let mut _33: usize;
                        let mut _34: usize;
                        let mut _35: usize;
                        let mut _36: bool;
                    }
                }
            }
        }
    }

    bb0: {
        _11 = _1 as *mut compaction_filter::CompactionFilterCallback<F> (PtrToPtr);
        _10 = &mut (*_11);
        _13 = _3 as *const u8 (PtrToPtr);
        _12 = std::slice::from_raw_parts::<'_, u8>(move _13, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _15 = _5 as *const u8 (PtrToPtr);
        _14 = std::slice::from_raw_parts::<'_, u8>(move _15, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _17 = &mut ((*_10).1: F);
        _19 = _2 as u32 (IntToInt);
        _18 = (move _19, _12, _14);
        _16 = <F as FnMut<(u32, &[u8], &[u8])>>::call_mut(move _17, move _18) -> [return: bb3, unwind continue];
    }

    bb3: {
        _20 = discriminant(_16);
        switchInt(move _20) -> [0: bb6, 1: bb7, 2: bb4, otherwise: bb5];
    }

    bb4: {
        _21 = ((_16 as Change).0: &[u8]);
        _22 = core::slice::<impl [u8]>::as_ptr(_21) -> [return: bb8, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = const 0_u8;
        goto -> bb9;
    }

    bb7: {
        _0 = const 1_u8;
        goto -> bb9;
    }

    bb8: {
        _31 = _7 as *const () (PtrToPtr);
        _32 = _31 as usize (Transmute);
        _33 = AlignOf(*mut i8);
        _34 = Sub(_33, const 1_usize);
        _35 = BitAnd(_32, _34);
        _36 = Eq(_35, const 0_usize);
        assert(_36, "misaligned pointer dereference: address must be a multiple of {} but is {}", _33, _32) -> [success: bb11, unwind unreachable];
    }

    bb9: {
        return;
    }

    bb10: {
        (*_8) = move _23;
        _24 = const 1_u8;
        (*_9) = move _24;
        _0 = const 0_u8;
        goto -> bb9;
    }

    bb11: {
        (*_7) = move _22 as *mut i8 (PtrToPtr);
        _23 = Len((*_21));
        _25 = _8 as *const () (PtrToPtr);
        _26 = _25 as usize (Transmute);
        _27 = AlignOf(usize);
        _28 = Sub(_27, const 1_usize);
        _29 = BitAnd(_26, _28);
        _30 = Eq(_29, const 0_usize);
        assert(_30, "misaligned pointer dereference: address must be a multiple of {} but is {}", _27, _26) -> [success: bb10, unwind unreachable];
    }
}

fn comparator::destructor_callback(_1: *mut c_void) -> () {
    debug raw_cb => _1;
    let mut _0: ();
    let mut _2: std::boxed::Box<comparator::ComparatorCallback>;
    scope 1 {
    }

    bb0: {
        _2 = _1 as std::boxed::Box<comparator::ComparatorCallback> (Transmute);
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn comparator::name_callback(_1: *mut c_void) -> *const i8 {
    debug raw_cb => _1;
    let mut _0: *const i8;
    let mut _2: &mut comparator::ComparatorCallback;
    let mut _3: *mut comparator::ComparatorCallback;
    let _4: &std::ffi::CStr;
    let mut _5: &std::ffi::CString;
    scope 1 {
        debug cb => _2;
        scope 2 {
            debug ptr => _0;
        }
    }

    bb0: {
        _3 = _1 as *mut comparator::ComparatorCallback (PtrToPtr);
        _2 = &mut (*_3);
        _5 = &((*_2).0: std::ffi::CString);
        _4 = <CString as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn compare_callback(_1: *mut c_void, _2: *const i8, _3: usize, _4: *const i8, _5: usize) -> i32 {
    debug raw_cb => _1;
    debug a_raw => _2;
    debug a_len => _3;
    debug b_raw => _4;
    debug b_len => _5;
    let mut _0: i32;
    let mut _6: &mut comparator::ComparatorCallback;
    let mut _7: *mut comparator::ComparatorCallback;
    let _8: &[u8];
    let mut _9: *const u8;
    let _10: &[u8];
    let mut _11: *const u8;
    let mut _12: std::cmp::Ordering;
    let mut _13: for<'a, 'b> fn(&'a [u8], &'b [u8]) -> std::cmp::Ordering;
    let mut _14: i8;
    scope 1 {
        debug cb => _6;
        scope 2 {
            debug a => _8;
            scope 3 {
                debug b => _10;
            }
        }
    }

    bb0: {
        _7 = _1 as *mut comparator::ComparatorCallback (PtrToPtr);
        _6 = &mut (*_7);
        _9 = _2 as *const u8 (PtrToPtr);
        _8 = std::slice::from_raw_parts::<'_, u8>(move _9, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = _4 as *const u8 (PtrToPtr);
        _10 = std::slice::from_raw_parts::<'_, u8>(move _11, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = ((*_6).1: for<'a, 'b> fn(&'a [u8], &'b [u8]) -> std::cmp::Ordering);
        _12 = move _13(_8, _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [255: bb6, 0: bb7, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _0 = const 1_i32;
        goto -> bb8;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = const -1_i32;
        goto -> bb8;
    }

    bb7: {
        _0 = const 0_i32;
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

DBCompressionType::None::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Snappy::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Zlib::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Bz2::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Lz4::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Lz4hc::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompressionType::Zstd::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

fn db::<impl at src/db.rs:36:10: 36:15>::fmt(_1: &DBCompressionType, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;
    let _11: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 7: bb1, otherwise: bb2];
    }

    bb1: {
        _11 = const "Zstd";
        _3 = _11;
        goto -> bb9;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "None";
        _3 = _5;
        goto -> bb9;
    }

    bb4: {
        _6 = const "Snappy";
        _3 = _6;
        goto -> bb9;
    }

    bb5: {
        _7 = const "Zlib";
        _3 = _7;
        goto -> bb9;
    }

    bb6: {
        _8 = const "Bz2";
        _3 = _8;
        goto -> bb9;
    }

    bb7: {
        _9 = const "Lz4";
        _3 = _9;
        goto -> bb9;
    }

    bb8: {
        _10 = const "Lz4hc";
        _3 = _10;
        goto -> bb9;
    }

    bb9: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn db::<impl at src/db.rs:36:23: 36:28>::clone(_1: &DBCompressionType) -> DBCompressionType {
    debug self => _1;
    let mut _0: db::DBCompressionType;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn db::<impl at src/db.rs:36:30: 36:39>::eq(_1: &DBCompressionType, _2: &DBCompressionType) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

DBCompactionStyle::Level::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompactionStyle::Universal::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBCompactionStyle::Fifo::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

fn db::<impl at src/db.rs:47:10: 47:15>::fmt(_1: &DBCompactionStyle, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "Fifo";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Level";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Universal";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn db::<impl at src/db.rs:47:23: 47:28>::clone(_1: &DBCompactionStyle) -> DBCompactionStyle {
    debug self => _1;
    let mut _0: db::DBCompactionStyle;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn db::<impl at src/db.rs:47:30: 47:39>::eq(_1: &DBCompactionStyle, _2: &DBCompactionStyle) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

DBRecoveryMode::TolerateCorruptedTailRecords::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBRecoveryMode::AbsoluteConsistency::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBRecoveryMode::PointInTime::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

DBRecoveryMode::SkipAnyCorruptedRecord::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const _ as isize (IntToInt);
        return;
    }
}

fn db::<impl at src/db.rs:54:10: 54:15>::fmt(_1: &DBRecoveryMode, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "SkipAnyCorruptedRecord";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "TolerateCorruptedTailRecords";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "AbsoluteConsistency";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "PointInTime";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn db::<impl at src/db.rs:54:23: 54:28>::clone(_1: &DBRecoveryMode) -> DBRecoveryMode {
    debug self => _1;
    let mut _0: db::DBRecoveryMode;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn db::<impl at src/db.rs:54:30: 54:39>::eq(_1: &DBRecoveryMode, _2: &DBRecoveryMode) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::new(_1: &DB, _2: &ReadOptions) -> DBRawIterator<'_> {
    debug db => _1;
    debug readopts => _2;
    let mut _0: db::DBRawIterator<'_>;
    let mut _3: *mut ffi::rocksdb_iterator_t;
    let mut _4: *mut ffi::rocksdb_t;
    let mut _5: *const ffi::rocksdb_readoptions_t;
    let mut _6: *mut ffi::rocksdb_readoptions_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_t);
        _6 = ((*_2).0: *mut ffi::rocksdb_readoptions_t);
        _5 = move _6 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _3 = rocksdb_create_iterator(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = DBRawIterator::<'_> { inner: move _3, db: const PhantomData::<&DB> };
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::new_cf(_1: &DB, _2: ColumnFamily<'_>, _3: &ReadOptions) -> Result<DBRawIterator<'_>, Error> {
    debug db => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<db::DBRawIterator<'_>, Error>;
    let mut _4: db::DBRawIterator<'_>;
    let mut _5: *mut ffi::rocksdb_iterator_t;
    let mut _6: *mut ffi::rocksdb_t;
    let mut _7: *const ffi::rocksdb_readoptions_t;
    let mut _8: *mut ffi::rocksdb_readoptions_t;
    let mut _9: *mut ffi::rocksdb_column_family_handle_t;
    scope 1 {
    }

    bb0: {
        _6 = ((*_1).0: *mut ffi::rocksdb_t);
        _8 = ((*_3).0: *mut ffi::rocksdb_readoptions_t);
        _7 = move _8 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _9 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _5 = rocksdb_create_iterator_cf(move _6, move _7, move _9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = DBRawIterator::<'_> { inner: move _5, db: const PhantomData::<&DB> };
        _0 = Result::<DBRawIterator<'_>, Error>::Ok(move _4);
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::valid(_1: &DBRawIterator<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: u8;
    let mut _3: *const ffi::rocksdb_iterator_t;
    let mut _4: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _3 = move _4 as *const ffi::rocksdb_iterator_t (PointerCoercion(MutToConstPointer));
        _2 = rocksdb_iter_valid(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Ne(move _2, const 0_u8);
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::seek_to_first(_1: &mut DBRawIterator<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _2 = rocksdb_iter_seek_to_first(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::seek_to_last(_1: &mut DBRawIterator<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _2 = rocksdb_iter_seek_to_last(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::seek(_1: &mut DBRawIterator<'_>, _2: K) -> () {
    debug self => _1;
    debug key => _2;
    let mut _0: ();
    let _3: &[u8];
    let mut _4: &K;
    let _5: ();
    let mut _6: *mut ffi::rocksdb_iterator_t;
    let mut _7: *const i8;
    let mut _8: *const u8;
    let mut _9: usize;
    scope 1 {
        debug key => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _6 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _8 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = move _8 as *const i8 (PtrToPtr);
        _9 = Len((*_3));
        _5 = rocksdb_iter_seek(move _6, move _7, move _9) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::seek_for_prev(_1: &mut DBRawIterator<'_>, _2: K) -> () {
    debug self => _1;
    debug key => _2;
    let mut _0: ();
    let _3: &[u8];
    let mut _4: &K;
    let _5: ();
    let mut _6: *mut ffi::rocksdb_iterator_t;
    let mut _7: *const i8;
    let mut _8: *const u8;
    let mut _9: usize;
    scope 1 {
        debug key => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _6 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _8 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = move _8 as *const i8 (PtrToPtr);
        _9 = Len((*_3));
        _5 = rocksdb_iter_seek_for_prev(move _6, move _7, move _9) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::next(_1: &mut DBRawIterator<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _2 = rocksdb_iter_next(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::prev(_1: &mut DBRawIterator<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _2 = rocksdb_iter_prev(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::key_inner(_1: &DBRawIterator<'_>) -> Option<&[u8]> {
    debug self => _1;
    let mut _0: std::option::Option<&[u8]>;
    let mut _2: bool;
    let mut _3: usize;
    let mut _5: &mut usize;
    let mut _7: *const i8;
    let mut _8: *const ffi::rocksdb_iterator_t;
    let mut _9: *mut ffi::rocksdb_iterator_t;
    let _10: &[u8];
    let mut _11: usize;
    scope 1 {
        debug key_len => _3;
        let _4: *mut usize;
        scope 2 {
            debug key_len_ptr => _4;
            let _6: *const u8;
            scope 3 {
                debug key_ptr => _6;
            }
        }
    }

    bb0: {
        _2 = DBRawIterator::<'_>::valid(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _3 = const 0_usize;
        _5 = &mut _3;
        _4 = &raw mut (*_5);
        _9 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _8 = move _9 as *const ffi::rocksdb_iterator_t (PointerCoercion(MutToConstPointer));
        _7 = rocksdb_iter_key(move _8, _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = move _7 as *const u8 (PtrToPtr);
        _11 = _3;
        _10 = std::slice::from_raw_parts::<'_, u8>(_6, move _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<&[u8]>::Some(_10);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<&[u8]>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::key(_1: &DBRawIterator<'_>) -> Option<Vec<u8>> {
    debug self => _1;
    let mut _0: std::option::Option<std::vec::Vec<u8>>;
    let mut _2: std::option::Option<&[u8]>;
    scope 1 {
    }

    bb0: {
        _2 = DBRawIterator::<'_>::key_inner(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<&[u8]>::map::<Vec<u8>, {closure@src/db.rs:435:39: 435:44}>(move _2, const ZeroSized: {closure@src/db.rs:435:39: 435:44}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::key::{closure#0}(_1: {closure@src/db.rs:435:39: 435:44}, _2: &[u8]) -> Vec<u8> {
    debug key => _2;
    let mut _0: std::vec::Vec<u8>;

    bb0: {
        _0 = slice::<impl [u8]>::to_vec(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::value_inner(_1: &DBRawIterator<'_>) -> Option<&[u8]> {
    debug self => _1;
    let mut _0: std::option::Option<&[u8]>;
    let mut _2: bool;
    let mut _3: usize;
    let mut _5: &mut usize;
    let mut _7: *const i8;
    let mut _8: *const ffi::rocksdb_iterator_t;
    let mut _9: *mut ffi::rocksdb_iterator_t;
    let _10: &[u8];
    let mut _11: usize;
    scope 1 {
        debug val_len => _3;
        let _4: *mut usize;
        scope 2 {
            debug val_len_ptr => _4;
            let _6: *const u8;
            scope 3 {
                debug val_ptr => _6;
            }
        }
    }

    bb0: {
        _2 = DBRawIterator::<'_>::valid(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _3 = const 0_usize;
        _5 = &mut _3;
        _4 = &raw mut (*_5);
        _9 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _8 = move _9 as *const ffi::rocksdb_iterator_t (PointerCoercion(MutToConstPointer));
        _7 = rocksdb_iter_value(move _8, _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = move _7 as *const u8 (PtrToPtr);
        _11 = _3;
        _10 = std::slice::from_raw_parts::<'_, u8>(_6, move _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<&[u8]>::Some(_10);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<&[u8]>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::value(_1: &DBRawIterator<'_>) -> Option<Vec<u8>> {
    debug self => _1;
    let mut _0: std::option::Option<std::vec::Vec<u8>>;
    let mut _2: std::option::Option<&[u8]>;
    scope 1 {
    }

    bb0: {
        _2 = DBRawIterator::<'_>::value_inner(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<&[u8]>::map::<Vec<u8>, {closure@src/db.rs:459:41: 459:48}>(move _2, const ZeroSized: {closure@src/db.rs:459:41: 459:48}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:217:1: 217:27>::value::{closure#0}(_1: {closure@src/db.rs:459:41: 459:48}, _2: &[u8]) -> Vec<u8> {
    debug value => _2;
    let mut _0: std::vec::Vec<u8>;

    bb0: {
        _0 = slice::<impl [u8]>::to_vec(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:463:1: 463:36>::drop(_1: &mut DBRawIterator<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_iterator_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_iterator_t);
        _2 = rocksdb_iter_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:471:1: 471:24>::new(_1: &DB, _2: &ReadOptions, _3: IteratorMode<'_>) -> DBIterator<'_> {
    debug db => _1;
    debug readopts => _2;
    debug mode => _3;
    let mut _0: db::DBIterator<'_>;
    let mut _4: db::DBIterator<'_>;
    let mut _5: db::DBRawIterator<'_>;
    let mut _6: db::Direction;
    let _7: ();
    let mut _8: &mut db::DBIterator<'_>;
    scope 1 {
        debug rv => _4;
    }

    bb0: {
        _5 = DBRawIterator::<'_>::new(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Direction::Forward;
        _4 = DBIterator::<'_> { raw: move _5, direction: move _6, just_seeked: const false };
        _8 = &mut _4;
        _7 = DBIterator::<'_>::set_mode(move _8, move _3) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move _4;
        return;
    }

    bb3 (cleanup): {
        drop(_4) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:471:1: 471:24>::new_cf(_1: &DB, _2: ColumnFamily<'_>, _3: &ReadOptions, _4: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug db => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    debug mode => _4;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let mut _5: db::DBIterator<'_>;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, db::DBRawIterator<'_>>;
    let mut _7: std::result::Result<db::DBRawIterator<'_>, Error>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, Error>;
    let _10: db::DBRawIterator<'_>;
    let mut _11: db::Direction;
    let _12: ();
    let mut _13: &mut db::DBIterator<'_>;
    let mut _14: db::DBIterator<'_>;
    scope 1 {
        debug rv => _5;
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _7 = DBRawIterator::<'_>::new_cf(_1, _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <Result<DBRawIterator<'_>, Error> as Try>::branch(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _10 = move ((_6 as Continue).0: db::DBRawIterator<'_>);
        _11 = Direction::Forward;
        _5 = DBIterator::<'_> { raw: move _10, direction: move _11, just_seeked: const false };
        _13 = &mut _5;
        _12 = DBIterator::<'_>::set_mode(move _13, move _4) -> [return: bb6, unwind: bb8];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<DBIterator<'_>, Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _9) -> [return: bb7, unwind continue];
    }

    bb6: {
        _14 = move _5;
        _0 = Result::<DBIterator<'_>, Error>::Ok(move _14);
        goto -> bb7;
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_5) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:471:1: 471:24>::set_mode(_1: &mut DBIterator<'_>, _2: IteratorMode<'_>) -> () {
    debug self => _1;
    debug mode => _2;
    let mut _0: ();
    let mut _3: isize;
    let mut _4: isize;
    let _5: ();
    let mut _6: &mut db::DBRawIterator<'_>;
    let mut _7: db::Direction;
    let _8: ();
    let mut _9: &mut db::DBRawIterator<'_>;
    let mut _10: db::Direction;
    let _11: &[u8];
    let _12: ();
    let mut _13: &mut db::DBRawIterator<'_>;
    let mut _14: db::Direction;
    let _15: &[u8];
    let _16: ();
    let mut _17: &mut db::DBRawIterator<'_>;
    let mut _18: db::Direction;
    scope 1 {
        debug key => _11;
    }
    scope 2 {
        debug key => _15;
    }

    bb0: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb6, 2: bb1, otherwise: bb3];
    }

    bb1: {
        _3 = discriminant(((_2 as From).1: db::Direction));
        switchInt(move _3) -> [0: bb8, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _15 = ((_2 as From).0: &[u8]);
        _17 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _16 = DBRawIterator::<'_>::seek_for_prev::<&[u8]>(move _17, _15) -> [return: bb10, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _5 = DBRawIterator::<'_>::seek_to_first(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Direction::Forward;
        ((*_1).1: db::Direction) = move _7;
        goto -> bb11;
    }

    bb6: {
        _9 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _8 = DBRawIterator::<'_>::seek_to_last(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = Direction::Reverse;
        ((*_1).1: db::Direction) = move _10;
        goto -> bb11;
    }

    bb8: {
        _11 = ((_2 as From).0: &[u8]);
        _13 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _12 = DBRawIterator::<'_>::seek::<&[u8]>(move _13, _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _14 = Direction::Forward;
        ((*_1).1: db::Direction) = move _14;
        goto -> bb11;
    }

    bb10: {
        _18 = Direction::Reverse;
        ((*_1).1: db::Direction) = move _18;
        goto -> bb11;
    }

    bb11: {
        ((*_1).2: bool) = const true;
        return;
    }
}

fn db::<impl at src/db.rs:471:1: 471:24>::valid(_1: &DBIterator<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &db::DBRawIterator<'_>;

    bb0: {
        _2 = &((*_1).0: db::DBRawIterator<'_>);
        _0 = DBRawIterator::<'_>::valid(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:525:1: 525:37>::next(_1: &mut DBIterator<'_>) -> Option<(Box<[u8]>, Box<[u8]>)> {
    debug self => _1;
    let mut _0: std::option::Option<(std::boxed::Box<[u8]>, std::boxed::Box<[u8]>)>;
    let _2: ();
    let mut _3: bool;
    let mut _4: isize;
    let mut _5: &mut db::DBRawIterator<'_>;
    let mut _6: &mut db::DBRawIterator<'_>;
    let mut _7: bool;
    let mut _8: &db::DBRawIterator<'_>;
    let mut _9: (std::boxed::Box<[u8]>, std::boxed::Box<[u8]>);
    let mut _10: std::boxed::Box<[u8]>;
    let mut _11: std::vec::Vec<u8>;
    let mut _12: std::option::Option<std::vec::Vec<u8>>;
    let mut _13: &db::DBRawIterator<'_>;
    let mut _14: std::boxed::Box<[u8]>;
    let mut _15: std::vec::Vec<u8>;
    let mut _16: std::option::Option<std::vec::Vec<u8>>;
    let mut _17: &db::DBRawIterator<'_>;

    bb0: {
        _3 = ((*_1).2: bool);
        switchInt(move _3) -> [0: bb1, otherwise: bb5];
    }

    bb1: {
        _4 = discriminant(((*_1).1: db::Direction));
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _2 = DBRawIterator::<'_>::prev(move _6) -> [return: bb6, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = &mut ((*_1).0: db::DBRawIterator<'_>);
        _2 = DBRawIterator::<'_>::next(move _5) -> [return: bb6, unwind continue];
    }

    bb5: {
        ((*_1).2: bool) = const false;
        goto -> bb6;
    }

    bb6: {
        _8 = &((*_1).0: db::DBRawIterator<'_>);
        _7 = DBRawIterator::<'_>::valid(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _7) -> [0: bb15, otherwise: bb8];
    }

    bb8: {
        _13 = &((*_1).0: db::DBRawIterator<'_>);
        _12 = DBRawIterator::<'_>::key(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Option::<Vec<u8>>::unwrap(move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = Vec::<u8>::into_boxed_slice(move _11) -> [return: bb11, unwind continue];
    }

    bb11: {
        _17 = &((*_1).0: db::DBRawIterator<'_>);
        _16 = DBRawIterator::<'_>::value(move _17) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _15 = Option::<Vec<u8>>::unwrap(move _16) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _14 = Vec::<u8>::into_boxed_slice(move _15) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        _9 = (move _10, move _14);
        _0 = Option::<(Box<[u8]>, Box<[u8]>)>::Some(move _9);
        goto -> bb16;
    }

    bb15: {
        _0 = Option::<(Box<[u8]>, Box<[u8]>)>::None;
        goto -> bb16;
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_10) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:552:1: 552:52>::into(_1: DBIterator<'_>) -> DBRawIterator<'_> {
    debug self => _1;
    let mut _0: db::DBRawIterator<'_>;

    bb0: {
        _0 = move (_1.0: db::DBRawIterator<'_>);
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::new(_1: &DB) -> Snapshot<'_> {
    debug db => _1;
    let mut _0: db::Snapshot<'_>;
    let _2: *const ffi::rocksdb_snapshot_t;
    let mut _3: *mut ffi::rocksdb_t;
    scope 1 {
        debug snapshot => _2;
    }
    scope 2 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_t);
        _2 = rocksdb_create_snapshot(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Snapshot::<'_> { db: _1, inner: _2 };
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::iterator(_1: &Snapshot<'_>, _2: IteratorMode<'_>) -> DBIterator<'_> {
    debug self => _1;
    debug mode => _2;
    let mut _0: db::DBIterator<'_>;
    let _3: db::ReadOptions;
    scope 1 {
        debug readopts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Snapshot::<'_>::iterator_opt(_1, move _2, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::iterator_cf(_1: &Snapshot<'_>, _2: ColumnFamily<'_>, _3: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug mode => _3;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let _4: db::ReadOptions;
    scope 1 {
        debug readopts => _4;
    }

    bb0: {
        _4 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Snapshot::<'_>::iterator_cf_opt(_1, _2, move _4, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::iterator_opt(_1: &Snapshot<'_>, _2: IteratorMode<'_>, _3: ReadOptions) -> DBIterator<'_> {
    debug self => _1;
    debug mode => _2;
    debug readopts => _3;
    let mut _0: db::DBIterator<'_>;
    let _4: ();
    let mut _5: &mut db::ReadOptions;
    let _6: &db::ReadOptions;
    let mut _7: &DB;

    bb0: {
        _5 = &mut _3;
        _4 = ReadOptions::set_snapshot(move _5, _1) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _7 = deref_copy ((*_1).0: &DB);
        _6 = &_3;
        _0 = DBIterator::<'_>::new(_7, _6, move _2) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::iterator_cf_opt(_1: &Snapshot<'_>, _2: ColumnFamily<'_>, _3: ReadOptions, _4: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    debug mode => _4;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let _5: ();
    let mut _6: &mut db::ReadOptions;
    let _7: &db::ReadOptions;
    let mut _8: &DB;

    bb0: {
        _6 = &mut _3;
        _5 = ReadOptions::set_snapshot(move _6, _1) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _8 = deref_copy ((*_1).0: &DB);
        _7 = &_3;
        _0 = DBIterator::<'_>::new_cf(_8, _2, _7, move _4) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::raw_iterator(_1: &Snapshot<'_>) -> DBRawIterator<'_> {
    debug self => _1;
    let mut _0: db::DBRawIterator<'_>;
    let _2: db::ReadOptions;
    scope 1 {
        debug readopts => _2;
    }

    bb0: {
        _2 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Snapshot::<'_>::raw_iterator_opt(_1, move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::raw_iterator_cf(_1: &Snapshot<'_>, _2: ColumnFamily<'_>) -> Result<DBRawIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    let mut _0: std::result::Result<db::DBRawIterator<'_>, Error>;
    let _3: db::ReadOptions;
    scope 1 {
        debug readopts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Snapshot::<'_>::raw_iterator_cf_opt(_1, _2, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::raw_iterator_opt(_1: &Snapshot<'_>, _2: ReadOptions) -> DBRawIterator<'_> {
    debug self => _1;
    debug readopts => _2;
    let mut _0: db::DBRawIterator<'_>;
    let _3: ();
    let mut _4: &mut db::ReadOptions;
    let _5: &db::ReadOptions;
    let mut _6: &DB;

    bb0: {
        _4 = &mut _2;
        _3 = ReadOptions::set_snapshot(move _4, _1) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _6 = deref_copy ((*_1).0: &DB);
        _5 = &_2;
        _0 = DBRawIterator::<'_>::new(_6, _5) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::raw_iterator_cf_opt(_1: &Snapshot<'_>, _2: ColumnFamily<'_>, _3: ReadOptions) -> Result<DBRawIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<db::DBRawIterator<'_>, Error>;
    let _4: ();
    let mut _5: &mut db::ReadOptions;
    let _6: &db::ReadOptions;
    let mut _7: &DB;

    bb0: {
        _5 = &mut _3;
        _4 = ReadOptions::set_snapshot(move _5, _1) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _7 = deref_copy ((*_1).0: &DB);
        _6 = &_3;
        _0 = DBRawIterator::<'_>::new_cf(_7, _2, _6) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::get(_1: &Snapshot<'_>, _2: K) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug key => _2;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let _3: db::ReadOptions;
    let mut _4: K;
    let mut _5: bool;
    scope 1 {
        debug readopts => _3;
    }

    bb0: {
        _5 = const false;
        _5 = const true;
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _5 = const false;
        _4 = move _2;
        _0 = Snapshot::<'_>::get_opt::<K>(_1, move _4, move _3) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        resume;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        switchInt(_5) -> [0: bb3, otherwise: bb4];
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::get_cf(_1: &Snapshot<'_>, _2: ColumnFamily<'_>, _3: K) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let _4: db::ReadOptions;
    let mut _5: &[u8];
    let mut _6: &K;
    let mut _7: db::ReadOptions;
    let mut _8: bool;
    scope 1 {
        debug readopts => _4;
    }

    bb0: {
        _8 = const false;
        _4 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _8 = const true;
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _8 = const false;
        _7 = move _4;
        _0 = Snapshot::<'_>::get_cf_opt::<&[u8]>(_1, _2, move _5, move _7) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _8 = const false;
        drop(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        switchInt(_8) -> [0: bb5, otherwise: bb7];
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::get_opt(_1: &Snapshot<'_>, _2: K, _3: ReadOptions) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug key => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let _4: ();
    let mut _5: &mut db::ReadOptions;
    let mut _6: &[u8];
    let mut _7: &K;
    let _8: &db::ReadOptions;
    let mut _9: &DB;

    bb0: {
        _5 = &mut _3;
        _4 = ReadOptions::set_snapshot(move _5, _1) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _9 = deref_copy ((*_1).0: &DB);
        _7 = &_2;
        _6 = <K as AsRef<[u8]>>::as_ref(move _7) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _8 = &_3;
        _0 = db::<impl DB>::get_opt::<&[u8]>(_9, move _6, _8) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:558:1: 558:22>::get_cf_opt(_1: &Snapshot<'_>, _2: ColumnFamily<'_>, _3: K, _4: ReadOptions) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug readopts => _4;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let _5: ();
    let mut _6: &mut db::ReadOptions;
    let mut _7: &[u8];
    let mut _8: &K;
    let _9: &db::ReadOptions;
    let mut _10: &DB;

    bb0: {
        _6 = &mut _4;
        _5 = ReadOptions::set_snapshot(move _6, _1) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _10 = deref_copy ((*_1).0: &DB);
        _8 = &_3;
        _7 = <K as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _9 = &_4;
        _0 = db::<impl DB>::get_cf_opt::<&[u8]>(_10, _2, move _7, _9) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:658:1: 658:31>::drop(_1: &mut Snapshot<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_t;
    let mut _4: *const ffi::rocksdb_snapshot_t;
    let mut _5: &DB;
    scope 1 {
    }

    bb0: {
        _5 = deref_copy ((*_1).0: &DB);
        _3 = ((*_5).0: *mut ffi::rocksdb_t);
        _4 = ((*_1).1: *const ffi::rocksdb_snapshot_t);
        _2 = rocksdb_release_snapshot(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:666:1: 666:28>::new(_1: S, _2: Options) -> ColumnFamilyDescriptor {
    debug name => _1;
    debug options => _2;
    let mut _0: ColumnFamilyDescriptor;
    let mut _3: std::string::String;
    let mut _4: Options;

    bb0: {
        _3 = <S as Into<String>>::into(move _1) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _4 = move _2;
        _0 = ColumnFamilyDescriptor { name: move _3, options: move _4 };
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_default(_1: P) -> Result<DB, Error> {
    debug path => _1;
    let mut _0: std::result::Result<DB, Error>;
    let mut _2: Options;
    let _3: ();
    let mut _4: &mut Options;
    let _5: &Options;
    let mut _6: P;
    let mut _7: bool;
    scope 1 {
        debug opts => _2;
    }

    bb0: {
        _7 = const false;
        _7 = const true;
        _2 = <Options as Default>::default() -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _4 = &mut _2;
        _3 = db_options::<impl Options>::create_if_missing(move _4, const true) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _5 = &_2;
        _7 = const false;
        _6 = move _1;
        _0 = db::<impl DB>::open::<P>(_5, move _6) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        switchInt(_7) -> [0: bb6, otherwise: bb7];
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open(_1: &Options, _2: P) -> Result<DB, Error> {
    debug opts => _1;
    debug path => _2;
    let mut _0: std::result::Result<DB, Error>;
    let mut _3: std::option::Option<&str>;

    bb0: {
        _3 = Option::<&str>::None;
        _0 = db::<impl DB>::open_cf::<P, Option<&str>, &str>(_1, move _2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf(_1: &Options, _2: P, _3: I) -> Result<DB, Error> {
    debug opts => _1;
    debug path => _2;
    debug cfs => _3;
    let mut _0: std::result::Result<DB, Error>;
    let _4: std::iter::Map<<I as std::iter::IntoIterator>::IntoIter, {closure@src/db.rs:703:18: 703:24}>;
    let mut _5: <I as std::iter::IntoIterator>::IntoIter;
    let mut _6: P;
    let mut _7: bool;
    scope 1 {
        debug cfs => _4;
    }

    bb0: {
        _7 = const false;
        _7 = const true;
        _5 = <I as IntoIterator>::into_iter(move _3) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <<I as IntoIterator>::IntoIter as Iterator>::map::<ColumnFamilyDescriptor, {closure@src/db.rs:703:18: 703:24}>(move _5, const ZeroSized: {closure@src/db.rs:703:18: 703:24}) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _7 = const false;
        _6 = move _2;
        _0 = db::<impl DB>::open_cf_descriptors::<P, Map<<I as IntoIterator>::IntoIter, {closure@src/db.rs:703:18: 703:24}>>(_1, move _6, move _4) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        resume;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        switchInt(_7) -> [0: bb4, otherwise: bb5];
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf::{closure#0}(_1: &mut {closure@src/db.rs:703:18: 703:24}, _2: N) -> ColumnFamilyDescriptor {
    debug name => _2;
    let mut _0: ColumnFamilyDescriptor;
    let mut _3: &str;
    let mut _4: &N;
    let mut _5: Options;

    bb0: {
        _4 = &_2;
        _3 = <N as AsRef<str>>::as_ref(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _5 = <Options as Default>::default() -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _0 = db::<impl ColumnFamilyDescriptor>::new::<&str>(move _3, move _5) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors(_1: &Options, _2: P, _3: I) -> Result<DB, Error> {
    debug opts => _1;
    debug path => _2;
    debug cfs => _3;
    let mut _0: std::result::Result<DB, Error>;
    let _4: std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _5: <I as std::iter::IntoIterator>::IntoIter;
    let mut _7: &P;
    let mut _9: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _10: &[u8];
    let _11: &str;
    let mut _12: &std::borrow::Cow<'_, str>;
    let _13: std::borrow::Cow<'_, str>;
    let mut _14: &std::path::Path;
    let mut _15: isize;
    let mut _17: Error;
    let mut _18: std::string::String;
    let _19: &str;
    let mut _20: std::result::Result<(), std::io::Error>;
    let mut _21: &&std::path::Path;
    let mut _22: isize;
    let mut _24: Error;
    let mut _26: std::fmt::Arguments<'_>;
    let mut _27: &[&str];
    let mut _28: &[core::fmt::rt::Argument<'_>];
    let _29: &[core::fmt::rt::Argument<'_>; 1];
    let _30: [core::fmt::rt::Argument<'_>; 1];
    let mut _31: core::fmt::rt::Argument<'_>;
    let _32: &std::io::Error;
    let mut _35: std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _36: std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _37: bool;
    let mut _38: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _41: *const ffi::rocksdb_options_t;
    let mut _42: *mut ffi::rocksdb_options_t;
    let mut _43: *const i8;
    let _44: &std::ffi::CStr;
    let mut _45: &std::ffi::CString;
    let mut _46: *mut *mut i8;
    let mut _47: &mut *mut i8;
    let mut _48: bool;
    let mut _49: *mut i8;
    let mut _50: Error;
    let mut _51: std::string::String;
    let mut _52: *const i8;
    let mut _53: *mut i8;
    let mut _55: bool;
    let mut _56: &mut std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let mut _57: std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let _58: &[ColumnFamilyDescriptor];
    let mut _59: &std::vec::Vec<ColumnFamilyDescriptor>;
    let _60: ();
    let mut _61: &mut std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _62: ColumnFamilyDescriptor;
    let mut _63: std::string::String;
    let mut _64: Options;
    let mut _66: std::iter::Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:755:22: 755:26}>;
    let mut _67: std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let _68: &[ColumnFamilyDescriptor];
    let mut _69: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _71: std::iter::Map<std::slice::Iter<'_, std::ffi::CString>, {closure@src/db.rs:758:56: 758:60}>;
    let mut _72: std::slice::Iter<'_, std::ffi::CString>;
    let _73: &[std::ffi::CString];
    let mut _74: &std::vec::Vec<std::ffi::CString>;
    let mut _76: std::iter::Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:761:58: 761:61}>;
    let mut _77: std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let _78: &[ColumnFamilyDescriptor];
    let mut _79: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _81: std::iter::Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:765:22: 765:26}>;
    let mut _82: std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let _83: &[ColumnFamilyDescriptor];
    let mut _84: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _87: *const ffi::rocksdb_options_t;
    let mut _88: *mut ffi::rocksdb_options_t;
    let mut _89: *const i8;
    let _90: &std::ffi::CStr;
    let mut _91: &std::ffi::CString;
    let mut _92: i32;
    let mut _93: usize;
    let mut _94: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _95: *mut *const i8;
    let mut _96: &mut std::vec::Vec<*const i8>;
    let mut _97: *mut *const ffi::rocksdb_options_t;
    let mut _98: &mut std::vec::Vec<*const ffi::rocksdb_options_t>;
    let mut _99: *mut *mut ffi::rocksdb_column_family_handle_t;
    let mut _100: &mut std::vec::Vec<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _101: *mut *mut i8;
    let mut _102: &mut *mut i8;
    let mut _103: bool;
    let mut _104: *mut i8;
    let mut _105: Error;
    let mut _106: std::string::String;
    let mut _107: *const i8;
    let mut _108: *mut i8;
    let mut _109: std::slice::Iter<'_, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _110: &std::vec::Vec<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _112: std::option::Option<&*mut ffi::rocksdb_column_family_handle_t>;
    let mut _113: &mut std::slice::Iter<'_, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _114: isize;
    let mut _116: bool;
    let mut _117: *mut ffi::rocksdb_column_family_handle_t;
    let mut _118: Error;
    let mut _119: std::string::String;
    let _120: &str;
    let mut _121: std::iter::Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut ffi::rocksdb_column_family_handle_t>>;
    let mut _122: std::iter::Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut ffi::rocksdb_column_family_handle_t>>;
    let mut _123: std::slice::Iter<'_, ColumnFamilyDescriptor>;
    let _124: &[ColumnFamilyDescriptor];
    let mut _125: &std::vec::Vec<ColumnFamilyDescriptor>;
    let mut _126: std::vec::Vec<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _128: std::option::Option<(&ColumnFamilyDescriptor, *mut ffi::rocksdb_column_family_handle_t)>;
    let mut _129: &mut std::iter::Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut ffi::rocksdb_column_family_handle_t>>;
    let mut _130: isize;
    let _133: std::option::Option<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _134: &mut std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _135: &mut std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _136: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _137: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _138: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, Error>;
    let mut _139: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>>;
    let _140: &std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _141: &std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _142: isize;
    let mut _145: std::string::String;
    let mut _146: &std::string::String;
    let mut _147: bool;
    let mut _148: *mut ffi::rocksdb_t;
    let mut _149: Error;
    let mut _150: std::string::String;
    let _151: &str;
    let mut _152: DB;
    let mut _153: *mut ffi::rocksdb_t;
    let mut _154: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _155: std::path::PathBuf;
    let mut _156: &std::path::Path;
    let mut _158: bool;
    let mut _159: bool;
    let mut _160: bool;
    let mut _161: isize;
    let mut _162: isize;
    let mut _163: isize;
    scope 1 {
        debug cfs => _4;
        let _6: &std::path::Path;
        scope 2 {
            debug path => _6;
            let _8: std::ffi::CString;
            let _16: std::ffi::CString;
            scope 3 {
                debug cpath => _8;
                let _33: *mut ffi::rocksdb_t;
                scope 5 {
                    debug e => _23;
                    let _23: std::io::Error;
                    let _25: std::string::String;
                    let mut _157: &[&str; 2];
                    scope 6 {
                        debug res => _25;
                    }
                }
                scope 7 {
                    debug db => _33;
                    let _34: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
                    scope 8 {
                        debug cf_map => _34;
                        let mut _54: std::vec::Vec<ColumnFamilyDescriptor>;
                        scope 9 {
                            let mut _39: *mut i8;
                            scope 10 {
                                debug err => _39;
                                let _40: *mut ffi::rocksdb_t;
                                scope 11 {
                                    debug result => _40;
                                }
                            }
                        }
                        scope 12 {
                            debug cfs_v => _54;
                            let _65: std::vec::Vec<std::ffi::CString>;
                            scope 13 {
                                debug c_cfs => _65;
                                let mut _70: std::vec::Vec<*const i8>;
                                scope 14 {
                                    debug cfnames => _70;
                                    let mut _75: std::vec::Vec<*mut ffi::rocksdb_column_family_handle_t>;
                                    scope 15 {
                                        debug cfhandles => _75;
                                        let mut _80: std::vec::Vec<*const ffi::rocksdb_options_t>;
                                        scope 16 {
                                            debug cfopts => _80;
                                            let mut _111: std::slice::Iter<'_, *mut ffi::rocksdb_column_family_handle_t>;
                                            let mut _127: std::iter::Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut ffi::rocksdb_column_family_handle_t>>;
                                            scope 17 {
                                                let mut _85: *mut i8;
                                                scope 18 {
                                                    debug err => _85;
                                                    let _86: *mut ffi::rocksdb_t;
                                                    scope 19 {
                                                        debug result => _86;
                                                    }
                                                }
                                            }
                                            scope 20 {
                                                debug iter => _111;
                                                let _115: &*mut ffi::rocksdb_column_family_handle_t;
                                                scope 21 {
                                                    debug handle => _115;
                                                }
                                            }
                                            scope 22 {
                                                debug iter => _127;
                                                let _131: &ColumnFamilyDescriptor;
                                                let _132: *mut ffi::rocksdb_column_family_handle_t;
                                                scope 23 {
                                                    debug n => _131;
                                                    debug h => _132;
                                                    let _143: std::result::Result<std::convert::Infallible, Error>;
                                                    let _144: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
                                                    scope 24 {
                                                        debug residual => _143;
                                                        scope 25 {
                                                        }
                                                    }
                                                    scope 26 {
                                                        debug val => _144;
                                                        scope 27 {
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            scope 4 {
                debug c => _16;
            }
        }
    }

    bb0: {
        _158 = const false;
        _160 = const false;
        _159 = const false;
        _5 = <I as IntoIterator>::into_iter(move _3) -> [return: bb1, unwind: bb136];
    }

    bb1: {
        _4 = <<I as IntoIterator>::IntoIter as Iterator>::collect::<Vec<ColumnFamilyDescriptor>>(move _5) -> [return: bb2, unwind: bb136];
    }

    bb2: {
        _158 = const true;
        _7 = &_2;
        _6 = <P as AsRef<Path>>::as_ref(move _7) -> [return: bb3, unwind: bb152];
    }

    bb3: {
        _14 = _6;
        _13 = Path::to_string_lossy(move _14) -> [return: bb4, unwind: bb152];
    }

    bb4: {
        _12 = &_13;
        _11 = <Cow<'_, str> as Deref>::deref(move _12) -> [return: bb5, unwind: bb135];
    }

    bb5: {
        _10 = core::str::<impl str>::as_bytes(_11) -> [return: bb6, unwind: bb135];
    }

    bb6: {
        _9 = CString::new::<&[u8]>(move _10) -> [return: bb7, unwind: bb135];
    }

    bb7: {
        _15 = discriminant(_9);
        switchInt(move _15) -> [0: bb10, 1: bb8, otherwise: bb9];
    }

    bb8: {
        _19 = const "Failed to convert path to CString when opening DB.";
        _18 = <str as ToOwned>::to_owned(_19) -> [return: bb11, unwind: bb150];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _16 = move ((_9 as Ok).0: std::ffi::CString);
        _8 = move _16;
        _161 = discriminant(_9);
        switchInt(move _161) -> [0: bb138, otherwise: bb139];
    }

    bb11: {
        _17 = Error::new(move _18) -> [return: bb12, unwind: bb150];
    }

    bb12: {
        _0 = Result::<DB, Error>::Err(move _17);
        _162 = discriminant(_9);
        switchInt(move _162) -> [0: bb140, otherwise: bb141];
    }

    bb13: {
        _21 = &_6;
        _20 = create_dir_all::<&&Path>(move _21) -> [return: bb14, unwind: bb134];
    }

    bb14: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [1: bb15, otherwise: bb20];
    }

    bb15: {
        _23 = move ((_20 as Err).0: std::io::Error);
        _157 = const _;
        _27 = _157 as &[&str] (PointerCoercion(Unsize));
        _32 = &_23;
        _31 = core::fmt::rt::Argument::<'_>::new_debug::<std::io::Error>(_32) -> [return: bb16, unwind: bb132];
    }

    bb16: {
        _30 = [move _31];
        _29 = &_30;
        _28 = _29 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _26 = Arguments::<'_>::new_v1(move _27, move _28) -> [return: bb17, unwind: bb132];
    }

    bb17: {
        _25 = format(move _26) -> [return: bb18, unwind: bb132];
    }

    bb18: {
        _24 = Error::new(move _25) -> [return: bb19, unwind: bb132];
    }

    bb19: {
        _0 = Result::<DB, Error>::Err(move _24);
        drop(_23) -> [return: bb120, unwind: bb134];
    }

    bb20: {
        drop(_20) -> [return: bb21, unwind: bb134];
    }

    bb21: {
        _36 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::new() -> [return: bb22, unwind: bb134];
    }

    bb22: {
        _35 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::new(move _36) -> [return: bb23, unwind: bb134];
    }

    bb23: {
        _34 = Arc::<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>>::new(move _35) -> [return: bb24, unwind: bb134];
    }

    bb24: {
        _160 = const true;
        _38 = &_4;
        _37 = Vec::<ColumnFamilyDescriptor>::is_empty(move _38) -> [return: bb25, unwind: bb148];
    }

    bb25: {
        switchInt(move _37) -> [0: bb36, otherwise: bb26];
    }

    bb26: {
        _39 = null_mut::<i8>() -> [return: bb27, unwind: bb148];
    }

    bb27: {
        _42 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _41 = move _42 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _45 = &_8;
        _44 = <CString as Deref>::deref(move _45) -> [return: bb28, unwind: bb148];
    }

    bb28: {
        _43 = CStr::as_ptr(_44) -> [return: bb29, unwind: bb148];
    }

    bb29: {
        _47 = &mut _39;
        _46 = &raw mut (*_47);
        _40 = rocksdb_open(move _41, _43, move _46) -> [return: bb30, unwind: bb148];
    }

    bb30: {
        _49 = _39;
        _48 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _49) -> [return: bb31, unwind: bb148];
    }

    bb31: {
        switchInt(move _48) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _33 = _40;
        goto -> bb104;
    }

    bb33: {
        _53 = _39;
        _52 = move _53 as *const i8 (PointerCoercion(MutToConstPointer));
        _51 = error_message(move _52) -> [return: bb34, unwind: bb148];
    }

    bb34: {
        _50 = Error::new(move _51) -> [return: bb35, unwind: bb148];
    }

    bb35: {
        _0 = Result::<DB, Error>::Err(move _50);
        goto -> bb118;
    }

    bb36: {
        _158 = const false;
        _54 = move _4;
        _59 = &_54;
        _58 = <Vec<ColumnFamilyDescriptor> as Deref>::deref(move _59) -> [return: bb37, unwind: bb131];
    }

    bb37: {
        _57 = core::slice::<impl [ColumnFamilyDescriptor]>::iter(_58) -> [return: bb38, unwind: bb131];
    }

    bb38: {
        _56 = &mut _57;
        _55 = <std::slice::Iter<'_, ColumnFamilyDescriptor> as Iterator>::any::<{closure@src/db.rs:745:34: 745:38}>(move _56, const ZeroSized: {closure@src/db.rs:745:34: 745:38}) -> [return: bb39, unwind: bb131];
    }

    bb39: {
        switchInt(move _55) -> [0: bb40, otherwise: bb43];
    }

    bb40: {
        _61 = &mut _54;
        _63 = <String as From<&str>>::from(const "default") -> [return: bb41, unwind: bb131];
    }

    bb41: {
        _64 = <Options as Default>::default() -> [return: bb42, unwind: bb130];
    }

    bb42: {
        _62 = ColumnFamilyDescriptor { name: move _63, options: move _64 };
        _60 = Vec::<ColumnFamilyDescriptor>::push(move _61, move _62) -> [return: bb153, unwind: bb131];
    }

    bb43: {
        _69 = &_54;
        _68 = <Vec<ColumnFamilyDescriptor> as Deref>::deref(move _69) -> [return: bb44, unwind: bb131];
    }

    bb44: {
        _67 = core::slice::<impl [ColumnFamilyDescriptor]>::iter(_68) -> [return: bb45, unwind: bb131];
    }

    bb45: {
        _66 = <std::slice::Iter<'_, ColumnFamilyDescriptor> as Iterator>::map::<CString, {closure@src/db.rs:755:22: 755:26}>(move _67, const ZeroSized: {closure@src/db.rs:755:22: 755:26}) -> [return: bb46, unwind: bb131];
    }

    bb46: {
        _65 = <Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:755:22: 755:26}> as Iterator>::collect::<Vec<CString>>(move _66) -> [return: bb47, unwind: bb131];
    }

    bb47: {
        _74 = &_65;
        _73 = <Vec<CString> as Deref>::deref(move _74) -> [return: bb48, unwind: bb129];
    }

    bb48: {
        _72 = core::slice::<impl [CString]>::iter(_73) -> [return: bb49, unwind: bb129];
    }

    bb49: {
        _71 = <std::slice::Iter<'_, CString> as Iterator>::map::<*const i8, {closure@src/db.rs:758:56: 758:60}>(move _72, const ZeroSized: {closure@src/db.rs:758:56: 758:60}) -> [return: bb50, unwind: bb129];
    }

    bb50: {
        _70 = <Map<std::slice::Iter<'_, CString>, {closure@src/db.rs:758:56: 758:60}> as Iterator>::collect::<Vec<*const i8>>(move _71) -> [return: bb51, unwind: bb129];
    }

    bb51: {
        _79 = &_54;
        _78 = <Vec<ColumnFamilyDescriptor> as Deref>::deref(move _79) -> [return: bb52, unwind: bb128];
    }

    bb52: {
        _77 = core::slice::<impl [ColumnFamilyDescriptor]>::iter(_78) -> [return: bb53, unwind: bb128];
    }

    bb53: {
        _76 = <std::slice::Iter<'_, ColumnFamilyDescriptor> as Iterator>::map::<*mut rocksdb_column_family_handle_t, {closure@src/db.rs:761:58: 761:61}>(move _77, const ZeroSized: {closure@src/db.rs:761:58: 761:61}) -> [return: bb54, unwind: bb128];
    }

    bb54: {
        _75 = <Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:761:58: 761:61}> as Iterator>::collect::<Vec<*mut rocksdb_column_family_handle_t>>(move _76) -> [return: bb55, unwind: bb128];
    }

    bb55: {
        _159 = const true;
        _84 = &_54;
        _83 = <Vec<ColumnFamilyDescriptor> as Deref>::deref(move _84) -> [return: bb56, unwind: bb146];
    }

    bb56: {
        _82 = core::slice::<impl [ColumnFamilyDescriptor]>::iter(_83) -> [return: bb57, unwind: bb146];
    }

    bb57: {
        _81 = <std::slice::Iter<'_, ColumnFamilyDescriptor> as Iterator>::map::<*const rocksdb_options_t, {closure@src/db.rs:765:22: 765:26}>(move _82, const ZeroSized: {closure@src/db.rs:765:22: 765:26}) -> [return: bb58, unwind: bb146];
    }

    bb58: {
        _80 = <Map<std::slice::Iter<'_, ColumnFamilyDescriptor>, {closure@src/db.rs:765:22: 765:26}> as Iterator>::collect::<Vec<*const rocksdb_options_t>>(move _81) -> [return: bb59, unwind: bb146];
    }

    bb59: {
        _85 = null_mut::<i8>() -> [return: bb60, unwind: bb127];
    }

    bb60: {
        _88 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _87 = move _88 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _91 = &_8;
        _90 = <CString as Deref>::deref(move _91) -> [return: bb61, unwind: bb127];
    }

    bb61: {
        _89 = CStr::as_ptr(_90) -> [return: bb62, unwind: bb127];
    }

    bb62: {
        _94 = &_54;
        _93 = Vec::<ColumnFamilyDescriptor>::len(move _94) -> [return: bb63, unwind: bb127];
    }

    bb63: {
        _92 = move _93 as i32 (IntToInt);
        _96 = &mut _70;
        _95 = Vec::<*const i8>::as_mut_ptr(move _96) -> [return: bb64, unwind: bb127];
    }

    bb64: {
        _98 = &mut _80;
        _97 = Vec::<*const rocksdb_options_t>::as_mut_ptr(move _98) -> [return: bb65, unwind: bb127];
    }

    bb65: {
        _100 = &mut _75;
        _99 = Vec::<*mut rocksdb_column_family_handle_t>::as_mut_ptr(move _100) -> [return: bb66, unwind: bb127];
    }

    bb66: {
        _102 = &mut _85;
        _101 = &raw mut (*_102);
        _86 = rocksdb_open_column_families(move _87, move _89, move _92, move _95, move _97, move _99, move _101) -> [return: bb67, unwind: bb127];
    }

    bb67: {
        _104 = _85;
        _103 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _104) -> [return: bb68, unwind: bb127];
    }

    bb68: {
        switchInt(move _103) -> [0: bb70, otherwise: bb69];
    }

    bb69: {
        _33 = _86;
        _110 = &_75;
        _109 = <&Vec<*mut rocksdb_column_family_handle_t> as IntoIterator>::into_iter(move _110) -> [return: bb73, unwind: bb127];
    }

    bb70: {
        _108 = _85;
        _107 = move _108 as *const i8 (PointerCoercion(MutToConstPointer));
        _106 = error_message(move _107) -> [return: bb71, unwind: bb127];
    }

    bb71: {
        _105 = Error::new(move _106) -> [return: bb72, unwind: bb127];
    }

    bb72: {
        _0 = Result::<DB, Error>::Err(move _105);
        goto -> bb113;
    }

    bb73: {
        _111 = move _109;
        goto -> bb74;
    }

    bb74: {
        _113 = &mut _111;
        _112 = <std::slice::Iter<'_, *mut rocksdb_column_family_handle_t> as Iterator>::next(_113) -> [return: bb75, unwind: bb127];
    }

    bb75: {
        _114 = discriminant(_112);
        switchInt(move _114) -> [0: bb77, 1: bb76, otherwise: bb9];
    }

    bb76: {
        _115 = ((_112 as Some).0: &*mut ffi::rocksdb_column_family_handle_t);
        _117 = (*_115);
        _116 = std::ptr::mut_ptr::<impl *mut rocksdb_column_family_handle_t>::is_null(move _117) -> [return: bb78, unwind: bb127];
    }

    bb77: {
        _125 = &_54;
        _124 = <Vec<ColumnFamilyDescriptor> as Deref>::deref(move _125) -> [return: bb82, unwind: bb127];
    }

    bb78: {
        switchInt(move _116) -> [0: bb74, otherwise: bb79];
    }

    bb79: {
        _120 = const "Received null column family handle from DB.";
        _119 = <str as ToOwned>::to_owned(_120) -> [return: bb80, unwind: bb127];
    }

    bb80: {
        _118 = Error::new(move _119) -> [return: bb81, unwind: bb127];
    }

    bb81: {
        _0 = Result::<DB, Error>::Err(move _118);
        goto -> bb113;
    }

    bb82: {
        _123 = core::slice::<impl [ColumnFamilyDescriptor]>::iter(_124) -> [return: bb83, unwind: bb127];
    }

    bb83: {
        _159 = const false;
        _126 = move _75;
        _122 = <std::slice::Iter<'_, ColumnFamilyDescriptor> as Iterator>::zip::<Vec<*mut rocksdb_column_family_handle_t>>(move _123, move _126) -> [return: bb84, unwind: bb127];
    }

    bb84: {
        _121 = <Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut rocksdb_column_family_handle_t>> as IntoIterator>::into_iter(move _122) -> [return: bb85, unwind: bb127];
    }

    bb85: {
        _127 = move _121;
        goto -> bb86;
    }

    bb86: {
        _129 = &mut _127;
        _128 = <Zip<std::slice::Iter<'_, ColumnFamilyDescriptor>, std::vec::IntoIter<*mut rocksdb_column_family_handle_t>> as Iterator>::next(_129) -> [return: bb87, unwind: bb126];
    }

    bb87: {
        _130 = discriminant(_128);
        switchInt(move _130) -> [0: bb89, 1: bb88, otherwise: bb9];
    }

    bb88: {
        _131 = (((_128 as Some).0: (&ColumnFamilyDescriptor, *mut ffi::rocksdb_column_family_handle_t)).0: &ColumnFamilyDescriptor);
        _132 = (((_128 as Some).0: (&ColumnFamilyDescriptor, *mut ffi::rocksdb_column_family_handle_t)).1: *mut ffi::rocksdb_column_family_handle_t);
        _141 = &_34;
        _140 = <Arc<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Deref>::deref(move _141) -> [return: bb90, unwind: bb126];
    }

    bb89: {
        drop(_127) -> [return: bb100, unwind: bb127];
    }

    bb90: {
        _139 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::write(_140) -> [return: bb91, unwind: bb126];
    }

    bb91: {
        _138 = Result::<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>>::map_err::<Error, {closure@src/db.rs:792:30: 792:33}>(move _139, const ZeroSized: {closure@src/db.rs:792:30: 792:33}) -> [return: bb92, unwind: bb126];
    }

    bb92: {
        _137 = <Result<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, Error> as Try>::branch(move _138) -> [return: bb93, unwind: bb126];
    }

    bb93: {
        _142 = discriminant(_137);
        switchInt(move _142) -> [0: bb94, 1: bb95, otherwise: bb9];
    }

    bb94: {
        _144 = move ((_137 as Continue).0: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>);
        _136 = move _144;
        _135 = &mut _136;
        _134 = <RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>> as DerefMut>::deref_mut(move _135) -> [return: bb97, unwind: bb125];
    }

    bb95: {
        _143 = move ((_137 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<DB, Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _143) -> [return: bb96, unwind: bb126];
    }

    bb96: {
        drop(_127) -> [return: bb113, unwind: bb127];
    }

    bb97: {
        _146 = &((*_131).0: std::string::String);
        _145 = <String as Clone>::clone(move _146) -> [return: bb98, unwind: bb125];
    }

    bb98: {
        _133 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::insert(_134, move _145, _132) -> [return: bb99, unwind: bb125];
    }

    bb99: {
        drop(_136) -> [return: bb86, unwind: bb126];
    }

    bb100: {
        drop(_80) -> [return: bb101, unwind: bb146];
    }

    bb101: {
        _159 = const false;
        drop(_70) -> [return: bb102, unwind: bb129];
    }

    bb102: {
        drop(_65) -> [return: bb103, unwind: bb131];
    }

    bb103: {
        drop(_54) -> [return: bb104, unwind: bb148];
    }

    bb104: {
        _148 = _33;
        _147 = std::ptr::mut_ptr::<impl *mut rocksdb_t>::is_null(move _148) -> [return: bb105, unwind: bb148];
    }

    bb105: {
        switchInt(move _147) -> [0: bb109, otherwise: bb106];
    }

    bb106: {
        _151 = const "Could not initialize database.";
        _150 = <str as ToOwned>::to_owned(_151) -> [return: bb107, unwind: bb148];
    }

    bb107: {
        _149 = Error::new(move _150) -> [return: bb108, unwind: bb148];
    }

    bb108: {
        _0 = Result::<DB, Error>::Err(move _149);
        goto -> bb118;
    }

    bb109: {
        _153 = _33;
        _160 = const false;
        _154 = move _34;
        _156 = _6;
        _155 = Path::to_path_buf(move _156) -> [return: bb110, unwind: bb124];
    }

    bb110: {
        _152 = DB { inner: move _153, cfs: move _154, path: move _155 };
        _0 = Result::<DB, Error>::Ok(move _152);
        _160 = const false;
        drop(_8) -> [return: bb111, unwind: bb152];
    }

    bb111: {
        switchInt(_158) -> [0: bb112, otherwise: bb142];
    }

    bb112: {
        _158 = const false;
        drop(_2) -> [return: bb123, unwind continue];
    }

    bb113: {
        drop(_80) -> [return: bb114, unwind: bb146];
    }

    bb114: {
        switchInt(_159) -> [0: bb115, otherwise: bb143];
    }

    bb115: {
        _159 = const false;
        drop(_70) -> [return: bb116, unwind: bb129];
    }

    bb116: {
        drop(_65) -> [return: bb117, unwind: bb131];
    }

    bb117: {
        drop(_54) -> [return: bb118, unwind: bb148];
    }

    bb118: {
        drop(_34) -> [return: bb119, unwind: bb134];
    }

    bb119: {
        _160 = const false;
        goto -> bb120;
    }

    bb120: {
        drop(_8) -> [return: bb121, unwind: bb152];
    }

    bb121: {
        switchInt(_158) -> [0: bb122, otherwise: bb144];
    }

    bb122: {
        _158 = const false;
        drop(_2) -> [return: bb123, unwind continue];
    }

    bb123: {
        return;
    }

    bb124 (cleanup): {
        drop(_154) -> [return: bb148, unwind terminate(cleanup)];
    }

    bb125 (cleanup): {
        drop(_136) -> [return: bb126, unwind terminate(cleanup)];
    }

    bb126 (cleanup): {
        drop(_127) -> [return: bb127, unwind terminate(cleanup)];
    }

    bb127 (cleanup): {
        drop(_80) -> [return: bb146, unwind terminate(cleanup)];
    }

    bb128 (cleanup): {
        drop(_70) -> [return: bb129, unwind terminate(cleanup)];
    }

    bb129 (cleanup): {
        drop(_65) -> [return: bb131, unwind terminate(cleanup)];
    }

    bb130 (cleanup): {
        drop(_63) -> [return: bb131, unwind terminate(cleanup)];
    }

    bb131 (cleanup): {
        drop(_54) -> [return: bb148, unwind terminate(cleanup)];
    }

    bb132 (cleanup): {
        drop(_23) -> [return: bb134, unwind terminate(cleanup)];
    }

    bb133 (cleanup): {
        drop(_13) -> [return: bb134, unwind terminate(cleanup)];
    }

    bb134 (cleanup): {
        drop(_8) -> [return: bb152, unwind terminate(cleanup)];
    }

    bb135 (cleanup): {
        drop(_13) -> [return: bb152, unwind terminate(cleanup)];
    }

    bb136 (cleanup): {
        drop(_2) -> [return: bb137, unwind terminate(cleanup)];
    }

    bb137 (cleanup): {
        resume;
    }

    bb138: {
        drop(_13) -> [return: bb13, unwind: bb134];
    }

    bb139: {
        drop(_9) -> [return: bb138, unwind: bb133];
    }

    bb140: {
        drop(_13) -> [return: bb121, unwind: bb152];
    }

    bb141: {
        drop(_9) -> [return: bb140, unwind: bb135];
    }

    bb142: {
        drop(_4) -> [return: bb112, unwind: bb136];
    }

    bb143: {
        drop(_75) -> [return: bb115, unwind: bb128];
    }

    bb144: {
        drop(_4) -> [return: bb122, unwind: bb136];
    }

    bb145 (cleanup): {
        drop(_75) -> [return: bb128, unwind terminate(cleanup)];
    }

    bb146 (cleanup): {
        switchInt(_159) -> [0: bb128, otherwise: bb145];
    }

    bb147 (cleanup): {
        drop(_34) -> [return: bb134, unwind terminate(cleanup)];
    }

    bb148 (cleanup): {
        switchInt(_160) -> [0: bb134, otherwise: bb147];
    }

    bb149 (cleanup): {
        drop(_9) -> [return: bb135, unwind terminate(cleanup)];
    }

    bb150 (cleanup): {
        _163 = discriminant(_9);
        switchInt(move _163) -> [0: bb135, otherwise: bb149];
    }

    bb151 (cleanup): {
        drop(_4) -> [return: bb136, unwind terminate(cleanup)];
    }

    bb152 (cleanup): {
        switchInt(_158) -> [0: bb136, otherwise: bb151];
    }

    bb153: {
        goto -> bb43;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Failed to create RocksDB directory: `", const "`."];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#0}(_1: &mut {closure@src/db.rs:745:34: 745:38}, _2: &ColumnFamilyDescriptor) -> bool {
    debug cf => _2;
    let mut _0: bool;
    let mut _3: &std::string::String;
    let mut _4: &&str;

    bb0: {
        _3 = &((*_2).0: std::string::String);
        _4 = const _;
        _0 = <String as PartialEq<&str>>::eq(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#0}: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "default";
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#1}(_1: &mut {closure@src/db.rs:755:22: 755:26}, _2: &ColumnFamilyDescriptor) -> CString {
    debug cf => _2;
    let mut _0: std::ffi::CString;
    let mut _3: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _4: &[u8];
    let mut _5: &std::string::String;

    bb0: {
        _5 = &((*_2).0: std::string::String);
        _4 = String::as_bytes(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = CString::new::<&[u8]>(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Result::<CString, NulError>::unwrap(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#2}(_1: &mut {closure@src/db.rs:758:56: 758:60}, _2: &CString) -> *const i8 {
    debug cf => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = <CString as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#3}(_1: &mut {closure@src/db.rs:761:58: 761:61}, _2: &ColumnFamilyDescriptor) -> *mut rocksdb_column_family_handle_t {
    let mut _0: *mut ffi::rocksdb_column_family_handle_t;

    bb0: {
        _0 = null_mut::<rocksdb_column_family_handle_t>() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#4}(_1: &mut {closure@src/db.rs:765:22: 765:26}, _2: &ColumnFamilyDescriptor) -> *const rocksdb_options_t {
    debug cf => _2;
    let mut _0: *const ffi::rocksdb_options_t;
    let mut _3: *mut ffi::rocksdb_options_t;

    bb0: {
        _3 = (((*_2).1: Options).0: *mut ffi::rocksdb_options_t);
        _0 = move _3 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::open_cf_descriptors::{closure#5}(_1: {closure@src/db.rs:792:30: 792:33}, _2: PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>) -> Error {
    debug e => _2;
    let mut _0: Error;
    let mut _3: std::string::String;
    let mut _4: &std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;

    bb0: {
        _4 = &_2;
        _3 = <PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as ToString>::to_string(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = Error::new(move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::list_cf(_1: &Options, _2: P) -> Result<Vec<String>, Error> {
    debug opts => _1;
    debug path => _2;
    let mut _0: std::result::Result<std::vec::Vec<std::string::String>, Error>;
    let _3: std::ffi::CString;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::ffi::CString>;
    let mut _5: std::result::Result<std::ffi::CString, Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, Error>;
    let _8: std::ffi::CString;
    let mut _12: *const ffi::rocksdb_options_t;
    let mut _13: *mut ffi::rocksdb_options_t;
    let mut _14: *const i8;
    let _15: &std::ffi::CStr;
    let mut _16: &std::ffi::CString;
    let mut _17: *mut usize;
    let mut _18: &mut usize;
    let mut _19: *mut *mut i8;
    let mut _20: &mut *mut i8;
    let mut _21: bool;
    let mut _22: *mut i8;
    let mut _23: Error;
    let mut _24: std::string::String;
    let mut _25: *const i8;
    let mut _26: *mut i8;
    let mut _28: std::iter::Map<std::slice::Iter<'_, *mut i8>, {closure@src/db.rs:821:22: 821:27}>;
    let mut _29: std::slice::Iter<'_, *mut i8>;
    let _30: &[*mut i8];
    let mut _31: *const *mut i8;
    let mut _32: usize;
    let _33: ();
    let mut _34: usize;
    let mut _35: std::vec::Vec<std::string::String>;
    scope 1 {
        debug cpath => _3;
        let mut _9: usize;
        scope 6 {
            debug length => _9;
            scope 7 {
                let mut _10: *mut i8;
                scope 8 {
                    debug ptr => _11;
                    let _27: std::vec::Vec<std::string::String>;
                    scope 11 {
                        debug vec => _27;
                    }
                }
                scope 9 {
                    debug err => _10;
                    let _11: *mut *mut i8;
                    scope 10 {
                        debug result => _11;
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = to_cpath::<P>(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<CString, Error> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: std::ffi::CString);
        _3 = move _8;
        _9 = const 0_usize;
        _10 = null_mut::<i8>() -> [return: bb6, unwind: bb22];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<Vec<String>, Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _7) -> [return: bb20, unwind continue];
    }

    bb6: {
        _13 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _12 = move _13 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _16 = &_3;
        _15 = <CString as Deref>::deref(move _16) -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _14 = CStr::as_ptr(_15) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _18 = &mut _9;
        _17 = &raw mut (*_18);
        _20 = &mut _10;
        _19 = &raw mut (*_20);
        _11 = rocksdb_list_column_families(move _12, _14, move _17, move _19) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _22 = _10;
        _21 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _22) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        switchInt(move _21) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _31 = _11 as *const *mut i8 (PointerCoercion(MutToConstPointer));
        _32 = _9;
        _30 = std::slice::from_raw_parts::<'_, *mut i8>(move _31, move _32) -> [return: bb15, unwind: bb22];
    }

    bb12: {
        _26 = _10;
        _25 = move _26 as *const i8 (PointerCoercion(MutToConstPointer));
        _24 = error_message(move _25) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _23 = Error::new(move _24) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _0 = Result::<Vec<String>, Error>::Err(move _23);
        drop(_3) -> [return: bb20, unwind continue];
    }

    bb15: {
        _29 = core::slice::<impl [*mut i8]>::iter(_30) -> [return: bb16, unwind: bb22];
    }

    bb16: {
        _28 = <std::slice::Iter<'_, *mut i8> as Iterator>::map::<String, {closure@src/db.rs:821:22: 821:27}>(move _29, const ZeroSized: {closure@src/db.rs:821:22: 821:27}) -> [return: bb17, unwind: bb22];
    }

    bb17: {
        _27 = <Map<std::slice::Iter<'_, *mut i8>, {closure@src/db.rs:821:22: 821:27}> as Iterator>::collect::<Vec<String>>(move _28) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _34 = _9;
        _33 = rocksdb_list_column_families_destroy(_11, move _34) -> [return: bb19, unwind: bb21];
    }

    bb19: {
        _35 = move _27;
        _0 = Result::<Vec<String>, Error>::Ok(move _35);
        drop(_3) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        drop(_27) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_3) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::list_cf::{closure#0}(_1: &mut {closure@src/db.rs:821:22: 821:27}, _2: &*mut i8) -> String {
    debug ptr => _2;
    let mut _0: std::string::String;
    let mut _3: std::borrow::Cow<'_, str>;
    let _4: &std::ffi::CStr;
    let mut _5: *const i8;
    let mut _6: *mut i8;

    bb0: {
        _6 = (*_2);
        _5 = move _6 as *const i8 (PointerCoercion(MutToConstPointer));
        _4 = CStr::from_ptr::<'_>(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = alloc::ffi::c_str::<impl CStr>::to_string_lossy(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Cow::<'_, str>::into_owned(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::destroy(_1: &Options, _2: P) -> Result<(), Error> {
    debug opts => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), Error>;
    let _3: std::ffi::CString;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::ffi::CString>;
    let mut _5: std::result::Result<std::ffi::CString, Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, Error>;
    let _8: std::ffi::CString;
    let mut _11: *const ffi::rocksdb_options_t;
    let mut _12: *mut ffi::rocksdb_options_t;
    let mut _13: *const i8;
    let _14: &std::ffi::CStr;
    let mut _15: &std::ffi::CString;
    let mut _16: *mut *mut i8;
    let mut _17: &mut *mut i8;
    let mut _18: bool;
    let mut _19: *mut i8;
    let mut _20: Error;
    let mut _21: std::string::String;
    let mut _22: *const i8;
    let mut _23: *mut i8;
    scope 1 {
        debug cpath => _3;
        scope 6 {
            let mut _9: *mut i8;
            scope 7 {
                debug err => _9;
                let _10: ();
                scope 8 {
                    debug result => const ();
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = to_cpath::<P>(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<CString, Error> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: std::ffi::CString);
        _3 = move _8;
        _9 = null_mut::<i8>() -> [return: bb6, unwind: bb16];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<(), Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _7) -> [return: bb15, unwind continue];
    }

    bb6: {
        _12 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _11 = move _12 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _15 = &_3;
        _14 = <CString as Deref>::deref(move _15) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _13 = CStr::as_ptr(_14) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _17 = &mut _9;
        _16 = &raw mut (*_17);
        _10 = rocksdb_destroy_db(move _11, move _13, move _16) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _19 = _9;
        _18 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _19) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        switchInt(move _18) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb15, unwind continue];
    }

    bb12: {
        _23 = _9;
        _22 = move _23 as *const i8 (PointerCoercion(MutToConstPointer));
        _21 = error_message(move _22) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        _20 = Error::new(move _21) -> [return: bb14, unwind: bb16];
    }

    bb14: {
        _0 = Result::<(), Error>::Err(move _20);
        drop(_3) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::repair(_1: Options, _2: P) -> Result<(), Error> {
    debug opts => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), Error>;
    let _3: std::ffi::CString;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::ffi::CString>;
    let mut _5: std::result::Result<std::ffi::CString, Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, Error>;
    let _8: std::ffi::CString;
    let mut _11: *const ffi::rocksdb_options_t;
    let mut _12: *mut ffi::rocksdb_options_t;
    let mut _13: *const i8;
    let _14: &std::ffi::CStr;
    let mut _15: &std::ffi::CString;
    let mut _16: *mut *mut i8;
    let mut _17: &mut *mut i8;
    let mut _18: bool;
    let mut _19: *mut i8;
    let mut _20: Error;
    let mut _21: std::string::String;
    let mut _22: *const i8;
    let mut _23: *mut i8;
    scope 1 {
        debug cpath => _3;
        scope 6 {
            let mut _9: *mut i8;
            scope 7 {
                debug err => _9;
                let _10: ();
                scope 8 {
                    debug result => const ();
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = to_cpath::<P>(move _2) -> [return: bb1, unwind: bb19];
    }

    bb1: {
        _4 = <Result<CString, Error> as Try>::branch(move _5) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: std::ffi::CString);
        _3 = move _8;
        _9 = null_mut::<i8>() -> [return: bb6, unwind: bb18];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<(), Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _7) -> [return: bb21, unwind: bb19];
    }

    bb6: {
        _12 = (_1.0: *mut ffi::rocksdb_options_t);
        _11 = move _12 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _15 = &_3;
        _14 = <CString as Deref>::deref(move _15) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _13 = CStr::as_ptr(_14) -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _17 = &mut _9;
        _16 = &raw mut (*_17);
        _10 = rocksdb_repair_db(move _11, move _13, move _16) -> [return: bb9, unwind: bb18];
    }

    bb9: {
        _19 = _9;
        _18 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _19) -> [return: bb10, unwind: bb18];
    }

    bb10: {
        switchInt(move _18) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb15, unwind: bb19];
    }

    bb12: {
        _23 = _9;
        _22 = move _23 as *const i8 (PointerCoercion(MutToConstPointer));
        _21 = error_message(move _22) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _20 = Error::new(move _21) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _0 = Result::<(), Error>::Err(move _20);
        drop(_3) -> [return: bb16, unwind: bb19];
    }

    bb15: {
        drop(_1) -> [return: bb17, unwind continue];
    }

    bb16: {
        drop(_1) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_1) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21: {
        goto -> bb16;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::path(_1: &DB) -> &Path {
    debug self => _1;
    let mut _0: &std::path::Path;
    let _2: &&std::path::Path;
    let _3: &std::path::Path;
    let mut _4: &std::path::PathBuf;

    bb0: {
        _4 = &((*_1).2: std::path::PathBuf);
        _3 = PathBuf::as_path(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = deref_copy (*_2);
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::flush_opt(_1: &DB, _2: &FlushOptions) -> Result<(), Error> {
    debug self => _1;
    debug flushopts => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _5: *mut ffi::rocksdb_t;
    let mut _6: *const ffi::rocksdb_flushoptions_t;
    let mut _7: *mut ffi::rocksdb_flushoptions_t;
    let mut _8: *mut *mut i8;
    let mut _9: &mut *mut i8;
    let mut _10: bool;
    let mut _11: *mut i8;
    let mut _12: Error;
    let mut _13: std::string::String;
    let mut _14: *const i8;
    let mut _15: *mut i8;
    scope 1 {
        let mut _3: *mut i8;
        scope 2 {
            debug err => _3;
            let _4: ();
            scope 3 {
                debug result => const ();
            }
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ((*_1).0: *mut ffi::rocksdb_t);
        _7 = ((*_2).0: *mut ffi::rocksdb_flushoptions_t);
        _6 = move _7 as *const ffi::rocksdb_flushoptions_t (PointerCoercion(MutToConstPointer));
        _9 = &mut _3;
        _8 = &raw mut (*_9);
        _4 = rocksdb_flush(move _5, move _6, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = _3;
        _10 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _10) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Result::<(), Error>::Ok(const ());
        goto -> bb8;
    }

    bb5: {
        _15 = _3;
        _14 = move _15 as *const i8 (PointerCoercion(MutToConstPointer));
        _13 = error_message(move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = Error::new(move _13) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Result::<(), Error>::Err(move _12);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::flush(_1: &DB) -> Result<(), Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), Error>;
    let _2: &FlushOptions;
    let _3: FlushOptions;

    bb0: {
        _3 = <FlushOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &_3;
        _0 = db::<impl DB>::flush_opt(_1, _2) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::write_opt(_1: &DB, _2: WriteBatch, _3: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug batch => _2;
    debug writeopts => _3;
    let mut _0: std::result::Result<(), Error>;
    let mut _6: *mut ffi::rocksdb_t;
    let mut _7: *const ffi::rocksdb_writeoptions_t;
    let mut _8: *mut ffi::rocksdb_writeoptions_t;
    let mut _9: *mut ffi::rocksdb_writebatch_t;
    let mut _10: *mut *mut i8;
    let mut _11: &mut *mut i8;
    let mut _12: bool;
    let mut _13: *mut i8;
    let mut _14: Error;
    let mut _15: std::string::String;
    let mut _16: *const i8;
    let mut _17: *mut i8;
    scope 1 {
        let mut _4: *mut i8;
        scope 2 {
            debug err => _4;
            let _5: ();
            scope 3 {
                debug result => const ();
            }
        }
    }

    bb0: {
        _4 = null_mut::<i8>() -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _6 = ((*_1).0: *mut ffi::rocksdb_t);
        _8 = ((*_3).0: *mut ffi::rocksdb_writeoptions_t);
        _7 = move _8 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _9 = (_2.0: *mut ffi::rocksdb_writebatch_t);
        _11 = &mut _4;
        _10 = &raw mut (*_11);
        _5 = rocksdb_write(move _6, move _7, move _9, move _10) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _13 = _4;
        _12 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _13) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        switchInt(move _12) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_2) -> [return: bb8, unwind continue];
    }

    bb5: {
        _17 = _4;
        _16 = move _17 as *const i8 (PointerCoercion(MutToConstPointer));
        _15 = error_message(move _16) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _14 = Error::new(move _15) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _0 = Result::<(), Error>::Err(move _14);
        drop(_2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::write(_1: &DB, _2: WriteBatch) -> Result<(), Error> {
    debug self => _1;
    debug batch => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _3: db::WriteBatch;
    let _4: &WriteOptions;
    let _5: WriteOptions;

    bb0: {
        _3 = move _2;
        _5 = <WriteOptions as Default>::default() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _4 = &_5;
        _0 = db::<impl DB>::write_opt(_1, move _3, _4) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::write_without_wal(_1: &DB, _2: WriteBatch) -> Result<(), Error> {
    debug self => _1;
    debug batch => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _3: WriteOptions;
    let _4: ();
    let mut _5: &mut WriteOptions;
    let mut _6: db::WriteBatch;
    let _7: &WriteOptions;
    let mut _8: bool;
    scope 1 {
        debug wo => _3;
    }

    bb0: {
        _8 = const false;
        _8 = const true;
        _3 = db_options::<impl WriteOptions>::new() -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _5 = &mut _3;
        _4 = db_options::<impl WriteOptions>::disable_wal(move _5, const true) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _8 = const false;
        _6 = move _2;
        _7 = &_3;
        _0 = db::<impl DB>::write_opt(_1, move _6, _7) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        switchInt(_8) -> [0: bb6, otherwise: bb7];
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_opt(_1: &DB, _2: K, _3: &ReadOptions) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug key => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let mut _4: bool;
    let mut _5: *mut ffi::rocksdb_readoptions_t;
    let mut _6: Error;
    let mut _7: std::string::String;
    let _8: &str;
    let _9: &[u8];
    let mut _10: &K;
    let mut _15: *mut ffi::rocksdb_t;
    let mut _16: *const ffi::rocksdb_readoptions_t;
    let mut _17: *mut ffi::rocksdb_readoptions_t;
    let mut _18: *const i8;
    let mut _19: *const u8;
    let mut _20: usize;
    let mut _21: *mut usize;
    let mut _22: &mut usize;
    let mut _23: *mut *mut i8;
    let mut _24: &mut *mut i8;
    let mut _25: bool;
    let mut _26: *mut i8;
    let mut _27: Error;
    let mut _28: std::string::String;
    let mut _29: *const i8;
    let mut _30: *mut i8;
    let mut _31: bool;
    let mut _32: std::option::Option<db::DBVector>;
    let mut _33: std::option::Option<db::DBVector>;
    let mut _34: db::DBVector;
    let mut _35: usize;
    scope 1 {
        debug key => _9;
        scope 2 {
            let mut _11: usize;
            scope 3 {
                debug val_len => _11;
                let _12: *mut u8;
                let mut _13: *mut i8;
                scope 4 {
                    debug val => _12;
                }
                scope 5 {
                    debug err => _13;
                    let _14: *mut i8;
                    scope 6 {
                        debug result => _14;
                    }
                }
            }
        }
    }

    bb0: {
        _5 = ((*_3).0: *mut ffi::rocksdb_readoptions_t);
        _4 = std::ptr::mut_ptr::<impl *mut rocksdb_readoptions_t>::is_null(move _5) -> [return: bb1, unwind: bb22];
    }

    bb1: {
        switchInt(move _4) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _8 = const "Unable to create RocksDB read options. This is a fairly trivial call, and its failure may be indicative of a mis-compiled or mis-loaded RocksDB library.";
        _7 = <str as ToOwned>::to_owned(_8) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _6 = Error::new(move _7) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _0 = Result::<Option<DBVector>, Error>::Err(move _6);
        goto -> bb20;
    }

    bb5: {
        _10 = &_2;
        _9 = <K as AsRef<[u8]>>::as_ref(move _10) -> [return: bb6, unwind: bb22];
    }

    bb6: {
        _11 = const 0_usize;
        _13 = null_mut::<i8>() -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _15 = ((*_1).0: *mut ffi::rocksdb_t);
        _17 = ((*_3).0: *mut ffi::rocksdb_readoptions_t);
        _16 = move _17 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _19 = core::slice::<impl [u8]>::as_ptr(_9) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _18 = move _19 as *const i8 (PtrToPtr);
        _20 = Len((*_9));
        _22 = &mut _11;
        _21 = &raw mut (*_22);
        _24 = &mut _13;
        _23 = &raw mut (*_24);
        _14 = rocksdb_get(move _15, move _16, move _18, move _20, move _21, move _23) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _26 = _13;
        _25 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _26) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        switchInt(move _25) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _12 = _14 as *mut u8 (PtrToPtr);
        _31 = std::ptr::mut_ptr::<impl *mut u8>::is_null(_12) -> [return: bb15, unwind: bb22];
    }

    bb12: {
        _30 = _13;
        _29 = move _30 as *const i8 (PointerCoercion(MutToConstPointer));
        _28 = error_message(move _29) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _27 = Error::new(move _28) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _0 = Result::<Option<DBVector>, Error>::Err(move _27);
        goto -> bb20;
    }

    bb15: {
        switchInt(move _31) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _32 = Option::<DBVector>::None;
        _0 = Result::<Option<DBVector>, Error>::Ok(move _32);
        goto -> bb19;
    }

    bb17: {
        _35 = _11;
        _34 = DBVector::from_c(_12, move _35) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _33 = Option::<DBVector>::Some(move _34);
        _0 = Result::<Option<DBVector>, Error>::Ok(move _33);
        goto -> bb19;
    }

    bb19: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_2) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get(_1: &DB, _2: K) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug key => _2;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let mut _3: &[u8];
    let mut _4: &K;
    let _5: &db::ReadOptions;
    let _6: db::ReadOptions;

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _6 = <ReadOptions as Default>::default() -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _5 = &_6;
        _0 = db::<impl DB>::get_opt::<&[u8]>(_1, move _3, _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_6) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: &ReadOptions) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug readopts => _4;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let mut _5: bool;
    let mut _6: *mut ffi::rocksdb_readoptions_t;
    let mut _7: Error;
    let mut _8: std::string::String;
    let _9: &str;
    let _10: &[u8];
    let mut _11: &K;
    let mut _16: *mut ffi::rocksdb_t;
    let mut _17: *const ffi::rocksdb_readoptions_t;
    let mut _18: *mut ffi::rocksdb_readoptions_t;
    let mut _19: *mut ffi::rocksdb_column_family_handle_t;
    let mut _20: *const i8;
    let mut _21: *const u8;
    let mut _22: usize;
    let mut _23: *mut usize;
    let mut _24: &mut usize;
    let mut _25: *mut *mut i8;
    let mut _26: &mut *mut i8;
    let mut _27: bool;
    let mut _28: *mut i8;
    let mut _29: Error;
    let mut _30: std::string::String;
    let mut _31: *const i8;
    let mut _32: *mut i8;
    let mut _33: bool;
    let mut _34: std::option::Option<db::DBVector>;
    let mut _35: std::option::Option<db::DBVector>;
    let mut _36: db::DBVector;
    let mut _37: usize;
    scope 1 {
        debug key => _10;
        scope 2 {
            let mut _12: usize;
            scope 3 {
                debug val_len => _12;
                let _13: *mut u8;
                let mut _14: *mut i8;
                scope 4 {
                    debug val => _13;
                }
                scope 5 {
                    debug err => _14;
                    let _15: *mut i8;
                    scope 6 {
                        debug result => _15;
                    }
                }
            }
        }
    }

    bb0: {
        _6 = ((*_4).0: *mut ffi::rocksdb_readoptions_t);
        _5 = std::ptr::mut_ptr::<impl *mut rocksdb_readoptions_t>::is_null(move _6) -> [return: bb1, unwind: bb22];
    }

    bb1: {
        switchInt(move _5) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _9 = const "Unable to create RocksDB read options. This is a fairly trivial call, and its failure may be indicative of a mis-compiled or mis-loaded RocksDB library.";
        _8 = <str as ToOwned>::to_owned(_9) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _7 = Error::new(move _8) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _0 = Result::<Option<DBVector>, Error>::Err(move _7);
        goto -> bb20;
    }

    bb5: {
        _11 = &_3;
        _10 = <K as AsRef<[u8]>>::as_ref(move _11) -> [return: bb6, unwind: bb22];
    }

    bb6: {
        _12 = const 0_usize;
        _14 = null_mut::<i8>() -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _16 = ((*_1).0: *mut ffi::rocksdb_t);
        _18 = ((*_4).0: *mut ffi::rocksdb_readoptions_t);
        _17 = move _18 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _19 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _21 = core::slice::<impl [u8]>::as_ptr(_10) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _20 = move _21 as *const i8 (PtrToPtr);
        _22 = Len((*_10));
        _24 = &mut _12;
        _23 = &raw mut (*_24);
        _26 = &mut _14;
        _25 = &raw mut (*_26);
        _15 = rocksdb_get_cf(move _16, move _17, move _19, move _20, move _22, move _23, move _25) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _28 = _14;
        _27 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _28) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        switchInt(move _27) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _13 = _15 as *mut u8 (PtrToPtr);
        _33 = std::ptr::mut_ptr::<impl *mut u8>::is_null(_13) -> [return: bb15, unwind: bb22];
    }

    bb12: {
        _32 = _14;
        _31 = move _32 as *const i8 (PointerCoercion(MutToConstPointer));
        _30 = error_message(move _31) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _29 = Error::new(move _30) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _0 = Result::<Option<DBVector>, Error>::Err(move _29);
        goto -> bb20;
    }

    bb15: {
        switchInt(move _33) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _34 = Option::<DBVector>::None;
        _0 = Result::<Option<DBVector>, Error>::Ok(move _34);
        goto -> bb19;
    }

    bb17: {
        _37 = _12;
        _36 = DBVector::from_c(_13, move _37) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _35 = Option::<DBVector>::Some(move _36);
        _0 = Result::<Option<DBVector>, Error>::Ok(move _35);
        goto -> bb19;
    }

    bb19: {
        drop(_3) -> [return: bb21, unwind continue];
    }

    bb20: {
        drop(_3) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_3) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_cf(_1: &DB, _2: ColumnFamily<'_>, _3: K) -> Result<Option<DBVector>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBVector>, Error>;
    let mut _4: &[u8];
    let mut _5: &K;
    let _6: &db::ReadOptions;
    let _7: db::ReadOptions;

    bb0: {
        _5 = &_3;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _7 = <ReadOptions as Default>::default() -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _6 = &_7;
        _0 = db::<impl DB>::get_cf_opt::<&[u8]>(_1, _2, move _4, _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_7) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_pinned_opt(_1: &DB, _2: K, _3: &ReadOptions) -> Result<Option<DBPinnableSlice<'_>>, Error> {
    debug self => _1;
    debug key => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBPinnableSlice<'_>>, Error>;
    let mut _4: bool;
    let mut _5: *mut ffi::rocksdb_readoptions_t;
    let mut _6: Error;
    let mut _7: std::string::String;
    let _8: &str;
    let _9: &[u8];
    let mut _10: &K;
    let mut _13: *mut ffi::rocksdb_t;
    let mut _14: *const ffi::rocksdb_readoptions_t;
    let mut _15: *mut ffi::rocksdb_readoptions_t;
    let mut _16: *const i8;
    let mut _17: *const u8;
    let mut _18: usize;
    let mut _19: *mut *mut i8;
    let mut _20: &mut *mut i8;
    let mut _21: bool;
    let mut _22: *mut i8;
    let mut _23: Error;
    let mut _24: std::string::String;
    let mut _25: *const i8;
    let mut _26: *mut i8;
    let mut _27: bool;
    let mut _28: std::option::Option<db::DBPinnableSlice<'_>>;
    let mut _29: std::option::Option<db::DBPinnableSlice<'_>>;
    let mut _30: db::DBPinnableSlice<'_>;
    scope 1 {
        debug key => _9;
        scope 2 {
            let mut _11: *mut i8;
            scope 3 {
                debug val => _12;
            }
            scope 4 {
                debug err => _11;
                let _12: *mut ffi::rocksdb_pinnableslice_t;
                scope 5 {
                    debug result => _12;
                }
            }
        }
    }

    bb0: {
        _5 = ((*_3).0: *mut ffi::rocksdb_readoptions_t);
        _4 = std::ptr::mut_ptr::<impl *mut rocksdb_readoptions_t>::is_null(move _5) -> [return: bb1, unwind: bb22];
    }

    bb1: {
        switchInt(move _4) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _8 = const "Unable to create RocksDB read options. This is a fairly trivial call, and its failure may be indicative of a mis-compiled or mis-loaded RocksDB library.";
        _7 = <str as ToOwned>::to_owned(_8) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _6 = Error::new(move _7) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Err(move _6);
        goto -> bb20;
    }

    bb5: {
        _10 = &_2;
        _9 = <K as AsRef<[u8]>>::as_ref(move _10) -> [return: bb6, unwind: bb22];
    }

    bb6: {
        _11 = null_mut::<i8>() -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _13 = ((*_1).0: *mut ffi::rocksdb_t);
        _15 = ((*_3).0: *mut ffi::rocksdb_readoptions_t);
        _14 = move _15 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _17 = core::slice::<impl [u8]>::as_ptr(_9) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _16 = move _17 as *const i8 (PtrToPtr);
        _18 = Len((*_9));
        _20 = &mut _11;
        _19 = &raw mut (*_20);
        _12 = rocksdb_get_pinned(move _13, move _14, move _16, move _18, move _19) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _22 = _11;
        _21 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _22) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        switchInt(move _21) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _27 = std::ptr::mut_ptr::<impl *mut rocksdb_pinnableslice_t>::is_null(_12) -> [return: bb15, unwind: bb22];
    }

    bb12: {
        _26 = _11;
        _25 = move _26 as *const i8 (PointerCoercion(MutToConstPointer));
        _24 = error_message(move _25) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _23 = Error::new(move _24) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Err(move _23);
        goto -> bb20;
    }

    bb15: {
        switchInt(move _27) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _28 = Option::<DBPinnableSlice<'_>>::None;
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Ok(move _28);
        goto -> bb19;
    }

    bb17: {
        _30 = DBPinnableSlice::<'_>::from_c(_12) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _29 = Option::<DBPinnableSlice<'_>>::Some(move _30);
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Ok(move _29);
        goto -> bb19;
    }

    bb19: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_2) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_pinned(_1: &DB, _2: K) -> Result<Option<DBPinnableSlice<'_>>, Error> {
    debug self => _1;
    debug key => _2;
    let mut _0: std::result::Result<std::option::Option<db::DBPinnableSlice<'_>>, Error>;
    let mut _3: K;
    let _4: &db::ReadOptions;
    let _5: db::ReadOptions;

    bb0: {
        _3 = move _2;
        _5 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _4 = &_5;
        _0 = db::<impl DB>::get_pinned_opt::<K>(_1, move _3, _4) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_5) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_pinned_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: &ReadOptions) -> Result<Option<DBPinnableSlice<'_>>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug readopts => _4;
    let mut _0: std::result::Result<std::option::Option<db::DBPinnableSlice<'_>>, Error>;
    let mut _5: bool;
    let mut _6: *mut ffi::rocksdb_readoptions_t;
    let mut _7: Error;
    let mut _8: std::string::String;
    let _9: &str;
    let _10: &[u8];
    let mut _11: &K;
    let mut _14: *mut ffi::rocksdb_t;
    let mut _15: *const ffi::rocksdb_readoptions_t;
    let mut _16: *mut ffi::rocksdb_readoptions_t;
    let mut _17: *mut ffi::rocksdb_column_family_handle_t;
    let mut _18: *const i8;
    let mut _19: *const u8;
    let mut _20: usize;
    let mut _21: *mut *mut i8;
    let mut _22: &mut *mut i8;
    let mut _23: bool;
    let mut _24: *mut i8;
    let mut _25: Error;
    let mut _26: std::string::String;
    let mut _27: *const i8;
    let mut _28: *mut i8;
    let mut _29: bool;
    let mut _30: std::option::Option<db::DBPinnableSlice<'_>>;
    let mut _31: std::option::Option<db::DBPinnableSlice<'_>>;
    let mut _32: db::DBPinnableSlice<'_>;
    scope 1 {
        debug key => _10;
        scope 2 {
            let mut _12: *mut i8;
            scope 3 {
                debug val => _13;
            }
            scope 4 {
                debug err => _12;
                let _13: *mut ffi::rocksdb_pinnableslice_t;
                scope 5 {
                    debug result => _13;
                }
            }
        }
    }

    bb0: {
        _6 = ((*_4).0: *mut ffi::rocksdb_readoptions_t);
        _5 = std::ptr::mut_ptr::<impl *mut rocksdb_readoptions_t>::is_null(move _6) -> [return: bb1, unwind: bb22];
    }

    bb1: {
        switchInt(move _5) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _9 = const "Unable to create RocksDB read options. This is a fairly trivial call, and its failure may be indicative of a mis-compiled or mis-loaded RocksDB library.";
        _8 = <str as ToOwned>::to_owned(_9) -> [return: bb3, unwind: bb22];
    }

    bb3: {
        _7 = Error::new(move _8) -> [return: bb4, unwind: bb22];
    }

    bb4: {
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Err(move _7);
        goto -> bb20;
    }

    bb5: {
        _11 = &_3;
        _10 = <K as AsRef<[u8]>>::as_ref(move _11) -> [return: bb6, unwind: bb22];
    }

    bb6: {
        _12 = null_mut::<i8>() -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _14 = ((*_1).0: *mut ffi::rocksdb_t);
        _16 = ((*_4).0: *mut ffi::rocksdb_readoptions_t);
        _15 = move _16 as *const ffi::rocksdb_readoptions_t (PointerCoercion(MutToConstPointer));
        _17 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _19 = core::slice::<impl [u8]>::as_ptr(_10) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _18 = move _19 as *const i8 (PtrToPtr);
        _20 = Len((*_10));
        _22 = &mut _12;
        _21 = &raw mut (*_22);
        _13 = rocksdb_get_pinned_cf(move _14, move _15, move _17, move _18, move _20, move _21) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _24 = _12;
        _23 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _24) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        switchInt(move _23) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _29 = std::ptr::mut_ptr::<impl *mut rocksdb_pinnableslice_t>::is_null(_13) -> [return: bb15, unwind: bb22];
    }

    bb12: {
        _28 = _12;
        _27 = move _28 as *const i8 (PointerCoercion(MutToConstPointer));
        _26 = error_message(move _27) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _25 = Error::new(move _26) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Err(move _25);
        goto -> bb20;
    }

    bb15: {
        switchInt(move _29) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _30 = Option::<DBPinnableSlice<'_>>::None;
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Ok(move _30);
        goto -> bb19;
    }

    bb17: {
        _32 = DBPinnableSlice::<'_>::from_c(_13) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        _31 = Option::<DBPinnableSlice<'_>>::Some(move _32);
        _0 = Result::<Option<DBPinnableSlice<'_>>, Error>::Ok(move _31);
        goto -> bb19;
    }

    bb19: {
        drop(_3) -> [return: bb21, unwind continue];
    }

    bb20: {
        drop(_3) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_3) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::get_pinned_cf(_1: &DB, _2: ColumnFamily<'_>, _3: K) -> Result<Option<DBPinnableSlice<'_>>, Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    let mut _0: std::result::Result<std::option::Option<db::DBPinnableSlice<'_>>, Error>;
    let mut _4: K;
    let _5: &db::ReadOptions;
    let _6: db::ReadOptions;

    bb0: {
        _4 = move _3;
        _6 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _5 = &_6;
        _0 = db::<impl DB>::get_pinned_cf_opt::<K>(_1, _2, move _4, _5) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_6) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_6) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::create_cf(_1: &DB, _2: N, _3: &Options) -> Result<ColumnFamily<'_>, Error> {
    debug self => _1;
    debug name => _2;
    debug opts => _3;
    let mut _0: std::result::Result<ColumnFamily<'_>, Error>;
    let _4: std::ffi::CString;
    let mut _5: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _6: &[u8];
    let _7: &str;
    let mut _8: &N;
    let mut _9: isize;
    let _10: std::ffi::CString;
    let mut _11: Error;
    let mut _12: std::string::String;
    let _13: &str;
    let mut _17: *mut ffi::rocksdb_t;
    let mut _18: *const ffi::rocksdb_options_t;
    let mut _19: *mut ffi::rocksdb_options_t;
    let mut _20: *const i8;
    let _21: &std::ffi::CStr;
    let mut _22: &std::ffi::CString;
    let mut _23: *mut *mut i8;
    let mut _24: &mut *mut i8;
    let mut _25: bool;
    let mut _26: *mut i8;
    let mut _27: Error;
    let mut _28: std::string::String;
    let mut _29: *const i8;
    let mut _30: *mut i8;
    let _31: std::option::Option<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _32: &mut std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _33: &mut std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _34: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _36: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, Error>;
    let mut _37: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>>;
    let _38: &std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _39: &std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _40: isize;
    let mut _43: std::string::String;
    let _44: &str;
    let mut _45: &N;
    let mut _46: isize;
    let mut _47: isize;
    let mut _48: isize;
    scope 1 {
        debug cname => _4;
        let _14: ColumnFamily<'_>;
        scope 3 {
            debug cf => _14;
        }
        scope 4 {
            let mut _15: *mut i8;
            scope 5 {
                debug cf_handle => _16;
                let _41: std::result::Result<std::convert::Infallible, Error>;
                let _42: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
                scope 8 {
                    debug residual => _41;
                    scope 9 {
                    }
                }
                scope 10 {
                    debug val => _42;
                    scope 11 {
                    }
                }
            }
            scope 6 {
                debug err => _15;
                let _16: *mut ffi::rocksdb_column_family_handle_t;
                scope 7 {
                    debug result => _16;
                }
            }
        }
    }
    scope 2 {
        debug c => _10;
    }

    bb0: {
        _8 = &_2;
        _7 = <N as AsRef<str>>::as_ref(move _8) -> [return: bb1, unwind: bb34];
    }

    bb1: {
        _6 = core::str::<impl str>::as_bytes(_7) -> [return: bb2, unwind: bb34];
    }

    bb2: {
        _5 = CString::new::<&[u8]>(move _6) -> [return: bb3, unwind: bb34];
    }

    bb3: {
        _9 = discriminant(_5);
        switchInt(move _9) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _13 = const "Failed to convert path to CString when opening rocksdb";
        _12 = <str as ToOwned>::to_owned(_13) -> [return: bb7, unwind: bb41];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = move ((_5 as Ok).0: std::ffi::CString);
        _4 = move _10;
        _46 = discriminant(_5);
        switchInt(move _46) -> [0: bb36, otherwise: bb37];
    }

    bb7: {
        _11 = Error::new(move _12) -> [return: bb8, unwind: bb41];
    }

    bb8: {
        _0 = Result::<ColumnFamily<'_>, Error>::Err(move _11);
        _47 = discriminant(_5);
        switchInt(move _47) -> [0: bb30, otherwise: bb38];
    }

    bb9: {
        _17 = ((*_1).0: *mut ffi::rocksdb_t);
        _19 = ((*_3).0: *mut ffi::rocksdb_options_t);
        _18 = move _19 as *const ffi::rocksdb_options_t (PointerCoercion(MutToConstPointer));
        _22 = &_4;
        _21 = <CString as Deref>::deref(move _22) -> [return: bb10, unwind: bb33];
    }

    bb10: {
        _20 = CStr::as_ptr(_21) -> [return: bb11, unwind: bb33];
    }

    bb11: {
        _24 = &mut _15;
        _23 = &raw mut (*_24);
        _16 = rocksdb_create_column_family(move _17, move _18, move _20, move _23) -> [return: bb12, unwind: bb33];
    }

    bb12: {
        _26 = _15;
        _25 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _26) -> [return: bb13, unwind: bb33];
    }

    bb13: {
        switchInt(move _25) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _39 = &((*_1).1: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>);
        _38 = <Arc<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Deref>::deref(move _39) -> [return: bb18, unwind: bb33];
    }

    bb15: {
        _30 = _15;
        _29 = move _30 as *const i8 (PointerCoercion(MutToConstPointer));
        _28 = error_message(move _29) -> [return: bb16, unwind: bb33];
    }

    bb16: {
        _27 = Error::new(move _28) -> [return: bb17, unwind: bb33];
    }

    bb17: {
        _0 = Result::<ColumnFamily<'_>, Error>::Err(move _27);
        goto -> bb29;
    }

    bb18: {
        _37 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::write(_38) -> [return: bb19, unwind: bb33];
    }

    bb19: {
        _36 = Result::<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>>::map_err::<Error, {closure@src/db.rs:1072:26: 1072:29}>(move _37, const ZeroSized: {closure@src/db.rs:1072:26: 1072:29}) -> [return: bb20, unwind: bb33];
    }

    bb20: {
        _35 = <Result<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, Error> as Try>::branch(move _36) -> [return: bb21, unwind: bb33];
    }

    bb21: {
        _40 = discriminant(_35);
        switchInt(move _40) -> [0: bb22, 1: bb23, otherwise: bb5];
    }

    bb22: {
        _42 = move ((_35 as Continue).0: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>);
        _34 = move _42;
        _33 = &mut _34;
        _32 = <RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>> as DerefMut>::deref_mut(move _33) -> [return: bb24, unwind: bb32];
    }

    bb23: {
        _41 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<ColumnFamily<'_>, Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _41) -> [return: bb42, unwind: bb33];
    }

    bb24: {
        _45 = &_2;
        _44 = <N as AsRef<str>>::as_ref(move _45) -> [return: bb25, unwind: bb32];
    }

    bb25: {
        _43 = <str as ToString>::to_string(_44) -> [return: bb26, unwind: bb32];
    }

    bb26: {
        _31 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::insert(_32, move _43, _16) -> [return: bb27, unwind: bb32];
    }

    bb27: {
        drop(_34) -> [return: bb39, unwind: bb33];
    }

    bb28: {
        drop(_2) -> [return: bb31, unwind continue];
    }

    bb29: {
        drop(_4) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        drop(_2) -> [return: bb31, unwind continue];
    }

    bb31: {
        return;
    }

    bb32 (cleanup): {
        drop(_34) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_4) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_2) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        _15 = null_mut::<i8>() -> [return: bb9, unwind: bb33];
    }

    bb37: {
        drop(_5) -> [return: bb36, unwind: bb33];
    }

    bb38: {
        drop(_5) -> [return: bb30, unwind: bb34];
    }

    bb39: {
        _14 = ColumnFamily::<'_> { inner: _16, db: const PhantomData::<&DB> };
        _0 = Result::<ColumnFamily<'_>, Error>::Ok(_14);
        drop(_4) -> [return: bb28, unwind: bb34];
    }

    bb40 (cleanup): {
        drop(_5) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        _48 = discriminant(_5);
        switchInt(move _48) -> [0: bb34, otherwise: bb40];
    }

    bb42: {
        goto -> bb29;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::create_cf::{closure#0}(_1: {closure@src/db.rs:1072:26: 1072:29}, _2: PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>) -> Error {
    debug e => _2;
    let mut _0: Error;
    let mut _3: std::string::String;
    let mut _4: &std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;

    bb0: {
        _4 = &_2;
        _3 = <PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as ToString>::to_string(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = Error::new(move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::drop_cf(_1: &DB, _2: &str) -> Result<(), Error> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _3: std::option::Option<*mut ffi::rocksdb_column_family_handle_t>;
    let mut _4: &mut std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _5: &mut std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _6: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _8: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, Error>;
    let mut _9: std::result::Result<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>>;
    let _10: &std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _12: isize;
    let mut _15: &str;
    let mut _16: isize;
    let mut _20: *mut ffi::rocksdb_t;
    let mut _21: *mut *mut i8;
    let mut _22: &mut *mut i8;
    let mut _23: bool;
    let mut _24: *mut i8;
    let mut _25: Error;
    let mut _26: std::string::String;
    let mut _27: *const i8;
    let mut _28: *mut i8;
    let mut _29: Error;
    let mut _30: std::string::String;
    let mut _31: &std::string::String;
    let _32: std::string::String;
    let _33: std::string::String;
    let mut _34: std::fmt::Arguments<'_>;
    let mut _35: &[&str];
    let mut _36: &[core::fmt::rt::Argument<'_>];
    let _37: &[core::fmt::rt::Argument<'_>; 1];
    let _38: [core::fmt::rt::Argument<'_>; 1];
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &&str;
    let mut _41: &[&str; 1];
    scope 1 {
        debug cf => _17;
        let _13: std::result::Result<std::convert::Infallible, Error>;
        let _14: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
        let _17: *mut ffi::rocksdb_column_family_handle_t;
        scope 2 {
            debug residual => _13;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _14;
            scope 5 {
            }
        }
        scope 6 {
            let mut _18: *mut i8;
            scope 7 {
                debug err => _18;
                let _19: ();
                scope 8 {
                    debug result => const ();
                }
            }
        }
    }
    scope 9 {
        debug res => _33;
    }

    bb0: {
        _11 = &((*_1).1: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>);
        _10 = <Arc<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::write(_10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = Result::<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>>::map_err::<Error, {closure@src/db.rs:1087:22: 1087:25}>(move _9, const ZeroSized: {closure@src/db.rs:1087:22: 1087:25}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = <Result<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, Error> as Try>::branch(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_7);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _14 = move ((_7 as Continue).0: std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>);
        _6 = move _14;
        _5 = &mut _6;
        _4 = <RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>> as DerefMut>::deref_mut(move _5) -> [return: bb8, unwind: bb27];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<(), Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _13) -> [return: bb25, unwind continue];
    }

    bb8: {
        _15 = _2;
        _3 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::remove::<str>(_4, move _15) -> [return: bb9, unwind: bb27];
    }

    bb9: {
        _16 = discriminant(_3);
        switchInt(move _16) -> [1: bb10, otherwise: bb18];
    }

    bb10: {
        _17 = ((_3 as Some).0: *mut ffi::rocksdb_column_family_handle_t);
        _18 = null_mut::<i8>() -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _20 = ((*_1).0: *mut ffi::rocksdb_t);
        _22 = &mut _18;
        _21 = &raw mut (*_22);
        _19 = rocksdb_drop_column_family(move _20, _17, move _21) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _24 = _18;
        _23 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _24) -> [return: bb13, unwind: bb27];
    }

    bb13: {
        switchInt(move _23) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = Result::<(), Error>::Ok(const ());
        goto -> bb24;
    }

    bb15: {
        _28 = _18;
        _27 = move _28 as *const i8 (PointerCoercion(MutToConstPointer));
        _26 = error_message(move _27) -> [return: bb16, unwind: bb27];
    }

    bb16: {
        _25 = Error::new(move _26) -> [return: bb17, unwind: bb27];
    }

    bb17: {
        _0 = Result::<(), Error>::Err(move _25);
        drop(_6) -> [return: bb25, unwind continue];
    }

    bb18: {
        _41 = const _;
        _35 = _41 as &[&str] (PointerCoercion(Unsize));
        _40 = &_2;
        _39 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_40) -> [return: bb19, unwind: bb27];
    }

    bb19: {
        _38 = [move _39];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _34 = Arguments::<'_>::new_v1(move _35, move _36) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        _33 = format(move _34) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        _32 = move _33;
        _31 = &_32;
        _30 = <String as ToOwned>::to_owned(move _31) -> [return: bb22, unwind: bb26];
    }

    bb22: {
        _29 = Error::new(move _30) -> [return: bb23, unwind: bb26];
    }

    bb23: {
        _0 = Result::<(), Error>::Err(move _29);
        drop(_32) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        drop(_6) -> [return: bb25, unwind continue];
    }

    bb25: {
        return;
    }

    bb26 (cleanup): {
        drop(_32) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_6) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::drop_cf: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Invalid column family: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::drop_cf::{closure#0}(_1: {closure@src/db.rs:1087:22: 1087:25}, _2: PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>) -> Error {
    debug e => _2;
    let mut _0: Error;
    let mut _3: std::string::String;
    let mut _4: &std::sync::PoisonError<std::sync::RwLockWriteGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;

    bb0: {
        _4 = &_2;
        _3 = <PoisonError<RwLockWriteGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as ToString>::to_string(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = Error::new(move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::cf_handle(_1: &DB, _2: &str) -> Option<ColumnFamily<'_>> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<ColumnFamily<'_>>;
    let mut _3: std::option::Option<&*mut ffi::rocksdb_column_family_handle_t>;
    let _4: &std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _5: &std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let _6: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _7: std::ops::ControlFlow<std::option::Option<std::convert::Infallible>, std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _8: std::option::Option<std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _9: std::result::Result<std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>>;
    let _10: &std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _11: &std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _12: isize;
    let _13: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    scope 1 {
        debug residual => const Option::<Infallible>::None;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _13;
        scope 4 {
        }
    }

    bb0: {
        _11 = &((*_1).1: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>);
        _10 = <Arc<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Deref>::deref(move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::read(_10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = Result::<RwLockReadGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>, PoisonError<RwLockReadGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>>>::ok(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = <Option<RwLockReadGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Try>::branch(move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = discriminant(_7);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = move ((_7 as Continue).0: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>);
        _6 = move _13;
        _5 = &_6;
        _4 = <RwLockReadGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>> as Deref>::deref(move _5) -> [return: bb8, unwind: bb12];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = <Option<ColumnFamily<'_>> as FromResidual<Option<Infallible>>>::from_residual(const Option::<Infallible>::None) -> [return: bb11, unwind continue];
    }

    bb8: {
        _3 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::get::<str>(_4, _2) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _0 = Option::<&*mut rocksdb_column_family_handle_t>::map::<ColumnFamily<'_>, {closure@src/db.rs:1103:45: 1103:48}>(move _3, const ZeroSized: {closure@src/db.rs:1103:45: 1103:48}) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_6) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_6) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::cf_handle::{closure#0}(_1: {closure@src/db.rs:1103:45: 1103:48}, _2: &*mut rocksdb_column_family_handle_t) -> ColumnFamily<'_> {
    debug h => _2;
    let mut _0: ColumnFamily<'_>;
    let mut _3: *mut ffi::rocksdb_column_family_handle_t;

    bb0: {
        _3 = (*_2);
        _0 = ColumnFamily::<'_> { inner: move _3, db: const PhantomData::<&DB> };
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::iterator(_1: &DB, _2: IteratorMode<'_>) -> DBIterator<'_> {
    debug self => _1;
    debug mode => _2;
    let mut _0: db::DBIterator<'_>;
    let _3: db::ReadOptions;
    let _4: &db::ReadOptions;
    scope 1 {
        debug readopts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_3;
        _0 = db::<impl DB>::iterator_opt(_1, move _2, _4) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::iterator_opt(_1: &DB, _2: IteratorMode<'_>, _3: &ReadOptions) -> DBIterator<'_> {
    debug self => _1;
    debug mode => _2;
    debug readopts => _3;
    let mut _0: db::DBIterator<'_>;
    let _4: &&db::ReadOptions;
    let mut _5: &db::ReadOptions;

    bb0: {
        _4 = &_3;
        _5 = deref_copy (*_4);
        _0 = DBIterator::<'_>::new(_1, _5, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::iterator_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: &ReadOptions, _4: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    debug mode => _4;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let _5: &&db::ReadOptions;
    let mut _6: &db::ReadOptions;

    bb0: {
        _5 = &_3;
        _6 = deref_copy (*_5);
        _0 = DBIterator::<'_>::new_cf(_1, _2, _6, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::full_iterator(_1: &DB, _2: IteratorMode<'_>) -> DBIterator<'_> {
    debug self => _1;
    debug mode => _2;
    let mut _0: db::DBIterator<'_>;
    let mut _3: db::ReadOptions;
    let _4: ();
    let mut _5: &mut db::ReadOptions;
    let _6: &db::ReadOptions;
    scope 1 {
        debug opts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _3;
        _4 = ReadOptions::set_total_order_seek(move _5, const true) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _6 = &_3;
        _0 = DBIterator::<'_>::new(_1, _6, move _2) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::prefix_iterator(_1: &DB, _2: P) -> DBIterator<'_> {
    debug self => _1;
    debug prefix => _2;
    let mut _0: db::DBIterator<'_>;
    let mut _3: db::ReadOptions;
    let _4: ();
    let mut _5: &mut db::ReadOptions;
    let _6: &db::ReadOptions;
    let mut _7: db::IteratorMode<'_>;
    let _8: &[u8];
    let mut _9: &P;
    let mut _10: db::Direction;
    scope 1 {
        debug opts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _5 = &mut _3;
        _4 = ReadOptions::set_prefix_same_as_start(move _5, const true) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _6 = &_3;
        _9 = &_2;
        _8 = <P as AsRef<[u8]>>::as_ref(move _9) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _10 = Direction::Forward;
        _7 = IteratorMode::<'_>::From(_8, move _10);
        _0 = DBIterator::<'_>::new(_1, _6, move _7) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_3) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        drop(_2) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::iterator_cf(_1: &DB, _2: ColumnFamily<'_>, _3: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug mode => _3;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let _4: db::ReadOptions;
    let _5: &db::ReadOptions;
    scope 1 {
        debug opts => _4;
    }

    bb0: {
        _4 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &_4;
        _0 = DBIterator::<'_>::new_cf(_1, _2, _5, move _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_4) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::full_iterator_cf(_1: &DB, _2: ColumnFamily<'_>, _3: IteratorMode<'_>) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug mode => _3;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let mut _4: db::ReadOptions;
    let _5: ();
    let mut _6: &mut db::ReadOptions;
    let _7: &db::ReadOptions;
    scope 1 {
        debug opts => _4;
    }

    bb0: {
        _4 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _4;
        _5 = ReadOptions::set_total_order_seek(move _6, const true) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = &_4;
        _0 = DBIterator::<'_>::new_cf(_1, _2, _7, move _3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::prefix_iterator_cf(_1: &DB, _2: ColumnFamily<'_>, _3: P) -> Result<DBIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug prefix => _3;
    let mut _0: std::result::Result<db::DBIterator<'_>, Error>;
    let mut _4: db::ReadOptions;
    let _5: ();
    let mut _6: &mut db::ReadOptions;
    let _7: &db::ReadOptions;
    let mut _8: db::IteratorMode<'_>;
    let _9: &[u8];
    let mut _10: &P;
    let mut _11: db::Direction;
    scope 1 {
        debug opts => _4;
    }

    bb0: {
        _4 = <ReadOptions as Default>::default() -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _6 = &mut _4;
        _5 = ReadOptions::set_prefix_same_as_start(move _6, const true) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _7 = &_4;
        _10 = &_3;
        _9 = <P as AsRef<[u8]>>::as_ref(move _10) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _11 = Direction::Forward;
        _8 = IteratorMode::<'_>::From(_9, move _11);
        _0 = DBIterator::<'_>::new_cf(_1, _2, _7, move _8) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_4) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        drop(_3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_4) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::raw_iterator(_1: &DB) -> DBRawIterator<'_> {
    debug self => _1;
    let mut _0: db::DBRawIterator<'_>;
    let _2: db::ReadOptions;
    let _3: &db::ReadOptions;
    scope 1 {
        debug opts => _2;
    }

    bb0: {
        _2 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_2;
        _0 = DBRawIterator::<'_>::new(_1, _3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::raw_iterator_cf(_1: &DB, _2: ColumnFamily<'_>) -> Result<DBRawIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    let mut _0: std::result::Result<db::DBRawIterator<'_>, Error>;
    let _3: db::ReadOptions;
    let _4: &db::ReadOptions;
    scope 1 {
        debug opts => _3;
    }

    bb0: {
        _3 = <ReadOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_3;
        _0 = DBRawIterator::<'_>::new_cf(_1, _2, _4) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_3) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::raw_iterator_opt(_1: &DB, _2: &ReadOptions) -> DBRawIterator<'_> {
    debug self => _1;
    debug readopts => _2;
    let mut _0: db::DBRawIterator<'_>;

    bb0: {
        _0 = DBRawIterator::<'_>::new(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::raw_iterator_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: &ReadOptions) -> Result<DBRawIterator<'_>, Error> {
    debug self => _1;
    debug cf_handle => _2;
    debug readopts => _3;
    let mut _0: std::result::Result<db::DBRawIterator<'_>, Error>;

    bb0: {
        _0 = DBRawIterator::<'_>::new_cf(_1, _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::snapshot(_1: &DB) -> Snapshot<'_> {
    debug self => _1;
    let mut _0: db::Snapshot<'_>;

    bb0: {
        _0 = Snapshot::<'_>::new(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::put_opt(_1: &DB, _2: K, _3: V, _4: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    debug writeopts => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let mut _6: &K;
    let mut _8: &V;
    let mut _11: *mut ffi::rocksdb_t;
    let mut _12: *const ffi::rocksdb_writeoptions_t;
    let mut _13: *mut ffi::rocksdb_writeoptions_t;
    let mut _14: *const i8;
    let mut _15: *const u8;
    let mut _16: usize;
    let mut _17: *const i8;
    let mut _18: *const u8;
    let mut _19: usize;
    let mut _20: *mut *mut i8;
    let mut _21: &mut *mut i8;
    let mut _22: bool;
    let mut _23: *mut i8;
    let mut _24: Error;
    let mut _25: std::string::String;
    let mut _26: *const i8;
    let mut _27: *mut i8;
    scope 1 {
        debug key => _5;
        let _7: &[u8];
        scope 2 {
            debug value => _7;
            scope 3 {
                let mut _9: *mut i8;
                scope 4 {
                    debug err => _9;
                    let _10: ();
                    scope 5 {
                        debug result => const ();
                    }
                }
            }
        }
    }

    bb0: {
        _6 = &_2;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _8 = &_3;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _9 = null_mut::<i8>() -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _11 = ((*_1).0: *mut ffi::rocksdb_t);
        _13 = ((*_4).0: *mut ffi::rocksdb_writeoptions_t);
        _12 = move _13 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _15 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _14 = move _15 as *const i8 (PtrToPtr);
        _16 = Len((*_5));
        _18 = core::slice::<impl [u8]>::as_ptr(_7) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _17 = move _18 as *const i8 (PtrToPtr);
        _19 = Len((*_7));
        _21 = &mut _9;
        _20 = &raw mut (*_21);
        _10 = rocksdb_put(move _11, move _12, move _14, move _16, move _17, move _19, move _20) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _23 = _9;
        _22 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _23) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        switchInt(move _22) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb12, unwind: bb16];
    }

    bb9: {
        _27 = _9;
        _26 = move _27 as *const i8 (PointerCoercion(MutToConstPointer));
        _25 = error_message(move _26) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _24 = Error::new(move _25) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _0 = Result::<(), Error>::Err(move _24);
        drop(_3) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb13: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::put_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: V, _5: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    debug writeopts => _5;
    let mut _0: std::result::Result<(), Error>;
    let _6: &[u8];
    let mut _7: &K;
    let mut _9: &V;
    let mut _12: *mut ffi::rocksdb_t;
    let mut _13: *const ffi::rocksdb_writeoptions_t;
    let mut _14: *mut ffi::rocksdb_writeoptions_t;
    let mut _15: *mut ffi::rocksdb_column_family_handle_t;
    let mut _16: *const i8;
    let mut _17: *const u8;
    let mut _18: usize;
    let mut _19: *const i8;
    let mut _20: *const u8;
    let mut _21: usize;
    let mut _22: *mut *mut i8;
    let mut _23: &mut *mut i8;
    let mut _24: bool;
    let mut _25: *mut i8;
    let mut _26: Error;
    let mut _27: std::string::String;
    let mut _28: *const i8;
    let mut _29: *mut i8;
    scope 1 {
        debug key => _6;
        let _8: &[u8];
        scope 2 {
            debug value => _8;
            scope 3 {
                let mut _10: *mut i8;
                scope 4 {
                    debug err => _10;
                    let _11: ();
                    scope 5 {
                        debug result => const ();
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_3;
        _6 = <K as AsRef<[u8]>>::as_ref(move _7) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _9 = &_4;
        _8 = <V as AsRef<[u8]>>::as_ref(move _9) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _10 = null_mut::<i8>() -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _12 = ((*_1).0: *mut ffi::rocksdb_t);
        _14 = ((*_5).0: *mut ffi::rocksdb_writeoptions_t);
        _13 = move _14 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _15 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _17 = core::slice::<impl [u8]>::as_ptr(_6) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _16 = move _17 as *const i8 (PtrToPtr);
        _18 = Len((*_6));
        _20 = core::slice::<impl [u8]>::as_ptr(_8) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _19 = move _20 as *const i8 (PtrToPtr);
        _21 = Len((*_8));
        _23 = &mut _10;
        _22 = &raw mut (*_23);
        _11 = rocksdb_put_cf(move _12, move _13, move _15, move _16, move _18, move _19, move _21, move _22) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _25 = _10;
        _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _25) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        switchInt(move _24) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_4) -> [return: bb12, unwind: bb16];
    }

    bb9: {
        _29 = _10;
        _28 = move _29 as *const i8 (PointerCoercion(MutToConstPointer));
        _27 = error_message(move _28) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _26 = Error::new(move _27) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _0 = Result::<(), Error>::Err(move _26);
        drop(_4) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb13: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_4) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::merge_opt(_1: &DB, _2: K, _3: V, _4: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    debug writeopts => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let mut _6: &K;
    let mut _8: &V;
    let mut _11: *mut ffi::rocksdb_t;
    let mut _12: *const ffi::rocksdb_writeoptions_t;
    let mut _13: *mut ffi::rocksdb_writeoptions_t;
    let mut _14: *const i8;
    let mut _15: *const u8;
    let mut _16: usize;
    let mut _17: *const i8;
    let mut _18: *const u8;
    let mut _19: usize;
    let mut _20: *mut *mut i8;
    let mut _21: &mut *mut i8;
    let mut _22: bool;
    let mut _23: *mut i8;
    let mut _24: Error;
    let mut _25: std::string::String;
    let mut _26: *const i8;
    let mut _27: *mut i8;
    scope 1 {
        debug key => _5;
        let _7: &[u8];
        scope 2 {
            debug value => _7;
            scope 3 {
                let mut _9: *mut i8;
                scope 4 {
                    debug err => _9;
                    let _10: ();
                    scope 5 {
                        debug result => const ();
                    }
                }
            }
        }
    }

    bb0: {
        _6 = &_2;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _8 = &_3;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _9 = null_mut::<i8>() -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _11 = ((*_1).0: *mut ffi::rocksdb_t);
        _13 = ((*_4).0: *mut ffi::rocksdb_writeoptions_t);
        _12 = move _13 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _15 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _14 = move _15 as *const i8 (PtrToPtr);
        _16 = Len((*_5));
        _18 = core::slice::<impl [u8]>::as_ptr(_7) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _17 = move _18 as *const i8 (PtrToPtr);
        _19 = Len((*_7));
        _21 = &mut _9;
        _20 = &raw mut (*_21);
        _10 = rocksdb_merge(move _11, move _12, move _14, move _16, move _17, move _19, move _20) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _23 = _9;
        _22 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _23) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        switchInt(move _22) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb12, unwind: bb16];
    }

    bb9: {
        _27 = _9;
        _26 = move _27 as *const i8 (PointerCoercion(MutToConstPointer));
        _25 = error_message(move _26) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _24 = Error::new(move _25) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _0 = Result::<(), Error>::Err(move _24);
        drop(_3) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb13: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_3) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::merge_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: V, _5: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    debug writeopts => _5;
    let mut _0: std::result::Result<(), Error>;
    let _6: &[u8];
    let mut _7: &K;
    let mut _9: &V;
    let mut _12: *mut ffi::rocksdb_t;
    let mut _13: *const ffi::rocksdb_writeoptions_t;
    let mut _14: *mut ffi::rocksdb_writeoptions_t;
    let mut _15: *mut ffi::rocksdb_column_family_handle_t;
    let mut _16: *const i8;
    let mut _17: *const u8;
    let mut _18: usize;
    let mut _19: *const i8;
    let mut _20: *const u8;
    let mut _21: usize;
    let mut _22: *mut *mut i8;
    let mut _23: &mut *mut i8;
    let mut _24: bool;
    let mut _25: *mut i8;
    let mut _26: Error;
    let mut _27: std::string::String;
    let mut _28: *const i8;
    let mut _29: *mut i8;
    scope 1 {
        debug key => _6;
        let _8: &[u8];
        scope 2 {
            debug value => _8;
            scope 3 {
                let mut _10: *mut i8;
                scope 4 {
                    debug err => _10;
                    let _11: ();
                    scope 5 {
                        debug result => const ();
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &_3;
        _6 = <K as AsRef<[u8]>>::as_ref(move _7) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _9 = &_4;
        _8 = <V as AsRef<[u8]>>::as_ref(move _9) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _10 = null_mut::<i8>() -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _12 = ((*_1).0: *mut ffi::rocksdb_t);
        _14 = ((*_5).0: *mut ffi::rocksdb_writeoptions_t);
        _13 = move _14 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _15 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _17 = core::slice::<impl [u8]>::as_ptr(_6) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _16 = move _17 as *const i8 (PtrToPtr);
        _18 = Len((*_6));
        _20 = core::slice::<impl [u8]>::as_ptr(_8) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _19 = move _20 as *const i8 (PtrToPtr);
        _21 = Len((*_8));
        _23 = &mut _10;
        _22 = &raw mut (*_23);
        _11 = rocksdb_merge_cf(move _12, move _13, move _15, move _16, move _18, move _19, move _21, move _22) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _25 = _10;
        _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _25) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        switchInt(move _24) -> [0: bb9, otherwise: bb8];
    }

    bb8: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_4) -> [return: bb12, unwind: bb16];
    }

    bb9: {
        _29 = _10;
        _28 = move _29 as *const i8 (PointerCoercion(MutToConstPointer));
        _27 = error_message(move _28) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _26 = Error::new(move _27) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _0 = Result::<(), Error>::Err(move _26);
        drop(_4) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb13: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_4) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::delete_opt(_1: &DB, _2: K, _3: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug writeopts => _3;
    let mut _0: std::result::Result<(), Error>;
    let _4: &[u8];
    let mut _5: &K;
    let mut _8: *mut ffi::rocksdb_t;
    let mut _9: *const ffi::rocksdb_writeoptions_t;
    let mut _10: *mut ffi::rocksdb_writeoptions_t;
    let mut _11: *const i8;
    let mut _12: *const u8;
    let mut _13: usize;
    let mut _14: *mut *mut i8;
    let mut _15: &mut *mut i8;
    let mut _16: bool;
    let mut _17: *mut i8;
    let mut _18: Error;
    let mut _19: std::string::String;
    let mut _20: *const i8;
    let mut _21: *mut i8;
    scope 1 {
        debug key => _4;
        scope 2 {
            let mut _6: *mut i8;
            scope 3 {
                debug err => _6;
                let _7: ();
                scope 4 {
                    debug result => const ();
                }
            }
        }
    }

    bb0: {
        _5 = &_2;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _6 = null_mut::<i8>() -> [return: bb2, unwind: bb11];
    }

    bb2: {
        _8 = ((*_1).0: *mut ffi::rocksdb_t);
        _10 = ((*_3).0: *mut ffi::rocksdb_writeoptions_t);
        _9 = move _10 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _12 = core::slice::<impl [u8]>::as_ptr(_4) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _11 = move _12 as *const i8 (PtrToPtr);
        _13 = Len((*_4));
        _15 = &mut _6;
        _14 = &raw mut (*_15);
        _7 = rocksdb_delete(move _8, move _9, move _11, move _13, move _14) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _17 = _6;
        _16 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _17) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        switchInt(move _16) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb7: {
        _21 = _6;
        _20 = move _21 as *const i8 (PointerCoercion(MutToConstPointer));
        _19 = error_message(move _20) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _18 = Error::new(move _19) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        _0 = Result::<(), Error>::Err(move _18);
        drop(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_2) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::delete_cf_opt(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: &WriteOptions) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug writeopts => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let mut _6: &K;
    let mut _9: *mut ffi::rocksdb_t;
    let mut _10: *const ffi::rocksdb_writeoptions_t;
    let mut _11: *mut ffi::rocksdb_writeoptions_t;
    let mut _12: *mut ffi::rocksdb_column_family_handle_t;
    let mut _13: *const i8;
    let mut _14: *const u8;
    let mut _15: usize;
    let mut _16: *mut *mut i8;
    let mut _17: &mut *mut i8;
    let mut _18: bool;
    let mut _19: *mut i8;
    let mut _20: Error;
    let mut _21: std::string::String;
    let mut _22: *const i8;
    let mut _23: *mut i8;
    scope 1 {
        debug key => _5;
        scope 2 {
            let mut _7: *mut i8;
            scope 3 {
                debug err => _7;
                let _8: ();
                scope 4 {
                    debug result => const ();
                }
            }
        }
    }

    bb0: {
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb11];
    }

    bb1: {
        _7 = null_mut::<i8>() -> [return: bb2, unwind: bb11];
    }

    bb2: {
        _9 = ((*_1).0: *mut ffi::rocksdb_t);
        _11 = ((*_4).0: *mut ffi::rocksdb_writeoptions_t);
        _10 = move _11 as *const ffi::rocksdb_writeoptions_t (PointerCoercion(MutToConstPointer));
        _12 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _14 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _13 = move _14 as *const i8 (PtrToPtr);
        _15 = Len((*_5));
        _17 = &mut _7;
        _16 = &raw mut (*_17);
        _8 = rocksdb_delete_cf(move _9, move _10, move _12, move _13, move _15, move _16) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _19 = _7;
        _18 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _19) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        switchInt(move _18) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb10, unwind continue];
    }

    bb7: {
        _23 = _7;
        _22 = move _23 as *const i8 (PointerCoercion(MutToConstPointer));
        _21 = error_message(move _22) -> [return: bb8, unwind: bb11];
    }

    bb8: {
        _20 = Error::new(move _21) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        _0 = Result::<(), Error>::Err(move _20);
        drop(_3) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_3) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::put(_1: &DB, _2: K, _3: V) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    let mut _0: std::result::Result<(), Error>;
    let mut _4: &[u8];
    let mut _5: &K;
    let mut _6: &[u8];
    let mut _7: &V;
    let _8: &WriteOptions;
    let _9: WriteOptions;

    bb0: {
        _5 = &_2;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _7 = &_3;
        _6 = <V as AsRef<[u8]>>::as_ref(move _7) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _9 = <WriteOptions as Default>::default() -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _8 = &_9;
        _0 = db::<impl DB>::put_opt::<&[u8], &[u8]>(_1, move _4, move _6, _8) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_9) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        drop(_3) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_9) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::put_cf(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: V) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    let mut _0: std::result::Result<(), Error>;
    let mut _5: &[u8];
    let mut _6: &K;
    let mut _7: &[u8];
    let mut _8: &V;
    let _9: &WriteOptions;
    let _10: WriteOptions;

    bb0: {
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _8 = &_4;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _10 = <WriteOptions as Default>::default() -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _9 = &_10;
        _0 = db::<impl DB>::put_cf_opt::<&[u8], &[u8]>(_1, _2, move _5, move _7, _9) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_10) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_10) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::merge(_1: &DB, _2: K, _3: V) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    let mut _0: std::result::Result<(), Error>;
    let mut _4: &[u8];
    let mut _5: &K;
    let mut _6: &[u8];
    let mut _7: &V;
    let _8: &WriteOptions;
    let _9: WriteOptions;

    bb0: {
        _5 = &_2;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _7 = &_3;
        _6 = <V as AsRef<[u8]>>::as_ref(move _7) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _9 = <WriteOptions as Default>::default() -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _8 = &_9;
        _0 = db::<impl DB>::merge_opt::<&[u8], &[u8]>(_1, move _4, move _6, _8) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_9) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        drop(_3) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_9) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::merge_cf(_1: &DB, _2: ColumnFamily<'_>, _3: K, _4: V) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    let mut _0: std::result::Result<(), Error>;
    let mut _5: &[u8];
    let mut _6: &K;
    let mut _7: &[u8];
    let mut _8: &V;
    let _9: &WriteOptions;
    let _10: WriteOptions;

    bb0: {
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _8 = &_4;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _10 = <WriteOptions as Default>::default() -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _9 = &_10;
        _0 = db::<impl DB>::merge_cf_opt::<&[u8], &[u8]>(_1, _2, move _5, move _7, _9) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        drop(_10) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        drop(_4) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_10) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        drop(_3) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::delete(_1: &DB, _2: K) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    let mut _0: std::result::Result<(), Error>;
    let mut _3: &[u8];
    let mut _4: &K;
    let _5: &WriteOptions;
    let _6: WriteOptions;

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _6 = <WriteOptions as Default>::default() -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _5 = &_6;
        _0 = db::<impl DB>::delete_opt::<&[u8]>(_1, move _3, _5) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_6) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_6) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::delete_cf(_1: &DB, _2: ColumnFamily<'_>, _3: K) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    let mut _0: std::result::Result<(), Error>;
    let mut _4: &[u8];
    let mut _5: &K;
    let _6: &WriteOptions;
    let _7: WriteOptions;

    bb0: {
        _5 = &_3;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _7 = <WriteOptions as Default>::default() -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _6 = &_7;
        _0 = db::<impl DB>::delete_cf_opt::<&[u8]>(_1, _2, move _4, _6) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        drop(_7) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        drop(_3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_7) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range(_1: &DB, _2: Option<S>, _3: Option<E>) -> () {
    debug self => _1;
    debug start => _2;
    debug end => _3;
    let mut _0: ();
    let mut _5: std::option::Option<&S>;
    let mut _6: &std::option::Option<S>;
    let mut _8: std::option::Option<&E>;
    let mut _9: &std::option::Option<E>;
    let _10: ();
    let mut _11: *mut ffi::rocksdb_t;
    let mut _12: *const i8;
    let mut _13: usize;
    let mut _14: *const i8;
    let mut _15: usize;
    scope 1 {
        let _4: std::option::Option<&[u8]>;
        scope 2 {
            debug start => _4;
            let _7: std::option::Option<&[u8]>;
            scope 3 {
                debug end => _7;
            }
        }
    }

    bb0: {
        _6 = &_2;
        _5 = Option::<S>::as_ref(move _6) -> [return: bb1, unwind: bb12];
    }

    bb1: {
        _4 = Option::<&S>::map::<&[u8], {closure@src/db.rs:1390:44: 1390:47}>(move _5, const ZeroSized: {closure@src/db.rs:1390:44: 1390:47}) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _9 = &_3;
        _8 = Option::<E>::as_ref(move _9) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _7 = Option::<&E>::map::<&[u8], {closure@src/db.rs:1391:40: 1391:43}>(move _8, const ZeroSized: {closure@src/db.rs:1391:40: 1391:43}) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _11 = ((*_1).0: *mut ffi::rocksdb_t);
        _12 = opt_bytes_to_ptr::<&[u8]>(_4) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _13 = Option::<&[u8]>::map_or::<usize, {closure@src/db.rs:1396:33: 1396:36}>(_4, const 0_usize, const ZeroSized: {closure@src/db.rs:1396:33: 1396:36}) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _14 = opt_bytes_to_ptr::<&[u8]>(_7) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _15 = Option::<&[u8]>::map_or::<usize, {closure@src/db.rs:1398:31: 1398:34}>(_7, const 0_usize, const ZeroSized: {closure@src/db.rs:1398:31: 1398:34}) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _10 = rocksdb_compact_range(move _11, move _12, move _13, move _14, move _15) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        drop(_3) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_2) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range::{closure#0}(_1: {closure@src/db.rs:1390:44: 1390:47}, _2: &S) -> &[u8] {
    debug s => _2;
    let mut _0: &[u8];

    bb0: {
        _0 = <S as AsRef<[u8]>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range::{closure#1}(_1: {closure@src/db.rs:1391:40: 1391:43}, _2: &E) -> &[u8] {
    debug e => _2;
    let mut _0: &[u8];

    bb0: {
        _0 = <E as AsRef<[u8]>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range::{closure#2}(_1: {closure@src/db.rs:1396:33: 1396:36}, _2: &[u8]) -> usize {
    debug s => _2;
    let mut _0: usize;

    bb0: {
        _0 = Len((*_2));
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range::{closure#3}(_1: {closure@src/db.rs:1398:31: 1398:34}, _2: &[u8]) -> usize {
    debug e => _2;
    let mut _0: usize;

    bb0: {
        _0 = Len((*_2));
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range_cf(_1: &DB, _2: ColumnFamily<'_>, _3: Option<S>, _4: Option<E>) -> () {
    debug self => _1;
    debug cf => _2;
    debug start => _3;
    debug end => _4;
    let mut _0: ();
    let mut _6: std::option::Option<&S>;
    let mut _7: &std::option::Option<S>;
    let mut _9: std::option::Option<&E>;
    let mut _10: &std::option::Option<E>;
    let _11: ();
    let mut _12: *mut ffi::rocksdb_t;
    let mut _13: *mut ffi::rocksdb_column_family_handle_t;
    let mut _14: *const i8;
    let mut _15: usize;
    let mut _16: *const i8;
    let mut _17: usize;
    scope 1 {
        let _5: std::option::Option<&[u8]>;
        scope 2 {
            debug start => _5;
            let _8: std::option::Option<&[u8]>;
            scope 3 {
                debug end => _8;
            }
        }
    }

    bb0: {
        _7 = &_3;
        _6 = Option::<S>::as_ref(move _7) -> [return: bb1, unwind: bb12];
    }

    bb1: {
        _5 = Option::<&S>::map::<&[u8], {closure@src/db.rs:1410:44: 1410:47}>(move _6, const ZeroSized: {closure@src/db.rs:1410:44: 1410:47}) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _10 = &_4;
        _9 = Option::<E>::as_ref(move _10) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _8 = Option::<&E>::map::<&[u8], {closure@src/db.rs:1411:40: 1411:43}>(move _9, const ZeroSized: {closure@src/db.rs:1411:40: 1411:43}) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _12 = ((*_1).0: *mut ffi::rocksdb_t);
        _13 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _14 = opt_bytes_to_ptr::<&[u8]>(_5) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _15 = Option::<&[u8]>::map_or::<usize, {closure@src/db.rs:1417:33: 1417:36}>(_5, const 0_usize, const ZeroSized: {closure@src/db.rs:1417:33: 1417:36}) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _16 = opt_bytes_to_ptr::<&[u8]>(_8) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _17 = Option::<&[u8]>::map_or::<usize, {closure@src/db.rs:1419:31: 1419:34}>(_8, const 0_usize, const ZeroSized: {closure@src/db.rs:1419:31: 1419:34}) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _11 = rocksdb_compact_range_cf(move _12, move _13, move _14, move _15, move _16, move _17) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        drop(_4) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_3) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_4) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range_cf::{closure#0}(_1: {closure@src/db.rs:1410:44: 1410:47}, _2: &S) -> &[u8] {
    debug s => _2;
    let mut _0: &[u8];

    bb0: {
        _0 = <S as AsRef<[u8]>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range_cf::{closure#1}(_1: {closure@src/db.rs:1411:40: 1411:43}, _2: &E) -> &[u8] {
    debug e => _2;
    let mut _0: &[u8];

    bb0: {
        _0 = <E as AsRef<[u8]>>::as_ref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range_cf::{closure#2}(_1: {closure@src/db.rs:1417:33: 1417:36}, _2: &[u8]) -> usize {
    debug s => _2;
    let mut _0: usize;

    bb0: {
        _0 = Len((*_2));
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::compact_range_cf::{closure#3}(_1: {closure@src/db.rs:1419:31: 1419:34}, _2: &[u8]) -> usize {
    debug e => _2;
    let mut _0: usize;

    bb0: {
        _0 = Len((*_2));
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::set_options(_1: &DB, _2: &[(&str, &str)]) -> Result<(), Error> {
    debug self => _1;
    debug opts => _2;
    let mut _0: std::result::Result<(), Error>;
    let _3: std::vec::Vec<(std::ffi::CString, std::ffi::CString)>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, Error>, std::vec::Vec<(std::ffi::CString, std::ffi::CString)>>;
    let mut _5: std::result::Result<std::vec::Vec<(std::ffi::CString, std::ffi::CString)>, Error>;
    let mut _6: std::iter::Map<std::slice::Iter<'_, (&str, &str)>, {closure@src/db.rs:1427:18: 1427:33}>;
    let mut _7: std::slice::Iter<'_, (&str, &str)>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, Error>;
    let _10: std::vec::Vec<(std::ffi::CString, std::ffi::CString)>;
    let mut _12: std::iter::Map<std::slice::Iter<'_, (std::ffi::CString, std::ffi::CString)>, {closure@src/db.rs:1440:59: 1440:64}>;
    let mut _13: std::slice::Iter<'_, (std::ffi::CString, std::ffi::CString)>;
    let _14: &[(std::ffi::CString, std::ffi::CString)];
    let mut _15: &std::vec::Vec<(std::ffi::CString, std::ffi::CString)>;
    let mut _17: std::iter::Map<std::slice::Iter<'_, (std::ffi::CString, std::ffi::CString)>, {closure@src/db.rs:1441:60: 1441:65}>;
    let mut _18: std::slice::Iter<'_, (std::ffi::CString, std::ffi::CString)>;
    let _19: &[(std::ffi::CString, std::ffi::CString)];
    let mut _20: &std::vec::Vec<(std::ffi::CString, std::ffi::CString)>;
    let mut _22: usize;
    let mut _25: *mut ffi::rocksdb_t;
    let mut _26: *const *const i8;
    let mut _27: &std::vec::Vec<*const i8>;
    let mut _28: *const *const i8;
    let mut _29: &std::vec::Vec<*const i8>;
    let mut _30: *mut *mut i8;
    let mut _31: &mut *mut i8;
    let mut _32: bool;
    let mut _33: *mut i8;
    let mut _34: Error;
    let mut _35: std::string::String;
    let mut _36: *const i8;
    let mut _37: *mut i8;
    scope 1 {
        debug copts => _3;
        let _11: std::vec::Vec<*const i8>;
        scope 6 {
            debug cnames => _11;
            let _16: std::vec::Vec<*const i8>;
            scope 7 {
                debug cvalues => _16;
                let _21: i32;
                scope 8 {
                    debug count => _21;
                    scope 9 {
                        let mut _23: *mut i8;
                        scope 10 {
                            debug err => _23;
                            let _24: ();
                            scope 11 {
                                debug result => const ();
                            }
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _7 = core::slice::<impl [(&str, &str)]>::iter(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <std::slice::Iter<'_, (&str, &str)> as Iterator>::map::<Result<(CString, CString), Error>, {closure@src/db.rs:1427:18: 1427:33}>(move _7, const ZeroSized: {closure@src/db.rs:1427:18: 1427:33}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = <Map<std::slice::Iter<'_, (&str, &str)>, {closure@src/db.rs:1427:18: 1427:33}> as Iterator>::collect::<Result<Vec<(CString, CString)>, Error>>(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Result<Vec<(CString, CString)>, Error> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_4 as Continue).0: std::vec::Vec<(std::ffi::CString, std::ffi::CString)>);
        _3 = move _10;
        _15 = &_3;
        _14 = <Vec<(CString, CString)> as Deref>::deref(move _15) -> [return: bb8, unwind: bb32];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, Error>);
        _0 = <Result<(), Error> as FromResidual<Result<Infallible, Error>>>::from_residual(move _9) -> [return: bb29, unwind continue];
    }

    bb8: {
        _13 = core::slice::<impl [(CString, CString)]>::iter(_14) -> [return: bb9, unwind: bb32];
    }

    bb9: {
        _12 = <std::slice::Iter<'_, (CString, CString)> as Iterator>::map::<*const i8, {closure@src/db.rs:1440:59: 1440:64}>(move _13, const ZeroSized: {closure@src/db.rs:1440:59: 1440:64}) -> [return: bb10, unwind: bb32];
    }

    bb10: {
        _11 = <Map<std::slice::Iter<'_, (CString, CString)>, {closure@src/db.rs:1440:59: 1440:64}> as Iterator>::collect::<Vec<*const i8>>(move _12) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _20 = &_3;
        _19 = <Vec<(CString, CString)> as Deref>::deref(move _20) -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _18 = core::slice::<impl [(CString, CString)]>::iter(_19) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _17 = <std::slice::Iter<'_, (CString, CString)> as Iterator>::map::<*const i8, {closure@src/db.rs:1441:60: 1441:65}>(move _18, const ZeroSized: {closure@src/db.rs:1441:60: 1441:65}) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _16 = <Map<std::slice::Iter<'_, (CString, CString)>, {closure@src/db.rs:1441:60: 1441:65}> as Iterator>::collect::<Vec<*const i8>>(move _17) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _22 = Len((*_2));
        _21 = move _22 as i32 (IntToInt);
        _23 = null_mut::<i8>() -> [return: bb16, unwind: bb30];
    }

    bb16: {
        _25 = ((*_1).0: *mut ffi::rocksdb_t);
        _27 = &_11;
        _26 = Vec::<*const i8>::as_ptr(move _27) -> [return: bb17, unwind: bb30];
    }

    bb17: {
        _29 = &_16;
        _28 = Vec::<*const i8>::as_ptr(move _29) -> [return: bb18, unwind: bb30];
    }

    bb18: {
        _31 = &mut _23;
        _30 = &raw mut (*_31);
        _24 = rocksdb_set_options(move _25, _21, move _26, move _28, move _30) -> [return: bb19, unwind: bb30];
    }

    bb19: {
        _33 = _23;
        _32 = std::ptr::mut_ptr::<impl *mut i8>::is_null(move _33) -> [return: bb20, unwind: bb30];
    }

    bb20: {
        switchInt(move _32) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_16) -> [return: bb25, unwind: bb31];
    }

    bb22: {
        _37 = _23;
        _36 = move _37 as *const i8 (PointerCoercion(MutToConstPointer));
        _35 = error_message(move _36) -> [return: bb23, unwind: bb30];
    }

    bb23: {
        _34 = Error::new(move _35) -> [return: bb24, unwind: bb30];
    }

    bb24: {
        _0 = Result::<(), Error>::Err(move _34);
        drop(_16) -> [return: bb27, unwind: bb31];
    }

    bb25: {
        drop(_11) -> [return: bb26, unwind: bb32];
    }

    bb26: {
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb27: {
        drop(_11) -> [return: bb28, unwind: bb32];
    }

    bb28: {
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_16) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_11) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_3) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::set_options::{closure#0}(_1: &mut {closure@src/db.rs:1427:18: 1427:33}, _2: &(&str, &str)) -> Result<(CString, CString), Error> {
    let mut _0: std::result::Result<(std::ffi::CString, std::ffi::CString), Error>;
    let _3: &&str;
    let _4: &&str;
    let mut _6: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _7: &[u8];
    let mut _8: isize;
    let mut _11: Error;
    let mut _13: std::fmt::Arguments<'_>;
    let mut _14: &[&str];
    let mut _15: &[core::fmt::rt::Argument<'_>];
    let _16: &[core::fmt::rt::Argument<'_>; 1];
    let _17: [core::fmt::rt::Argument<'_>; 1];
    let mut _18: core::fmt::rt::Argument<'_>;
    let _19: &std::ffi::NulError;
    let mut _20: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _21: &[u8];
    let mut _22: isize;
    let mut _25: Error;
    let mut _27: std::fmt::Arguments<'_>;
    let mut _28: &[&str];
    let mut _29: &[core::fmt::rt::Argument<'_>];
    let _30: &[core::fmt::rt::Argument<'_>; 1];
    let _31: [core::fmt::rt::Argument<'_>; 1];
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &std::ffi::NulError;
    let mut _34: (std::ffi::CString, std::ffi::CString);
    let mut _35: std::ffi::CString;
    let mut _38: &str;
    let mut _39: &str;
    scope 1 {
        debug name => _3;
        debug value => _4;
        let _5: std::ffi::CString;
        let _9: std::ffi::CString;
        let _10: std::ffi::NulError;
        scope 2 {
            debug cname => _5;
            let _23: std::ffi::CString;
            let _24: std::ffi::NulError;
            scope 6 {
                debug cvalue => _23;
            }
            scope 7 {
                debug cvalue => _23;
            }
            scope 8 {
                debug e => _24;
                let _26: std::string::String;
                let mut _37: &[&str; 2];
                scope 9 {
                    debug res => _26;
                }
            }
        }
        scope 3 {
            debug cname => _9;
        }
        scope 4 {
            debug e => _10;
            let _12: std::string::String;
            let mut _36: &[&str; 2];
            scope 5 {
                debug res => _12;
            }
        }
    }

    bb0: {
        _3 = &((*_2).0: &str);
        _4 = &((*_2).1: &str);
        _38 = deref_copy (*_3);
        _7 = core::str::<impl str>::as_bytes(_38) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = CString::new::<&[u8]>(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _10 = move ((_6 as Err).0: std::ffi::NulError);
        _36 = const _;
        _14 = _36 as &[&str] (PointerCoercion(Unsize));
        _19 = &_10;
        _18 = core::fmt::rt::Argument::<'_>::new_display::<NulError>(_19) -> [return: bb6, unwind: bb22];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = move ((_6 as Ok).0: std::ffi::CString);
        _5 = move _9;
        _39 = deref_copy (*_4);
        _21 = core::str::<impl str>::as_bytes(_39) -> [return: bb10, unwind: bb21];
    }

    bb6: {
        _17 = [move _18];
        _16 = &_17;
        _15 = _16 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _13 = Arguments::<'_>::new_v1(move _14, move _15) -> [return: bb7, unwind: bb22];
    }

    bb7: {
        _12 = format(move _13) -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _11 = Error::new(move _12) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _0 = Result::<(CString, CString), Error>::Err(move _11);
        drop(_10) -> [return: bb19, unwind continue];
    }

    bb10: {
        _20 = CString::new::<&[u8]>(move _21) -> [return: bb11, unwind: bb21];
    }

    bb11: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb13, 1: bb12, otherwise: bb4];
    }

    bb12: {
        _24 = move ((_20 as Err).0: std::ffi::NulError);
        _37 = const _;
        _28 = _37 as &[&str] (PointerCoercion(Unsize));
        _33 = &_24;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<NulError>(_33) -> [return: bb14, unwind: bb20];
    }

    bb13: {
        _23 = move ((_20 as Ok).0: std::ffi::CString);
        _35 = move _5;
        _34 = (move _35, move _23);
        _0 = Result::<(CString, CString), Error>::Ok(move _34);
        goto -> bb19;
    }

    bb14: {
        _31 = [move _32];
        _30 = &_31;
        _29 = _30 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _27 = Arguments::<'_>::new_v1(move _28, move _29) -> [return: bb15, unwind: bb20];
    }

    bb15: {
        _26 = format(move _27) -> [return: bb16, unwind: bb20];
    }

    bb16: {
        _25 = Error::new(move _26) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        _0 = Result::<(CString, CString), Error>::Err(move _25);
        drop(_24) -> [return: bb18, unwind: bb21];
    }

    bb18: {
        drop(_5) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_24) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_5) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        drop(_10) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::set_options::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Invalid option name `", const "`"];
        _0 = &_1;
        return;
    }
}

promoted[1] in db::<impl at src/db.rs:679:1: 679:8>::set_options::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Invalid option value: `", const "`"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::set_options::{closure#1}(_1: &mut {closure@src/db.rs:1440:59: 1440:64}, _2: &(CString, CString)) -> *const i8 {
    debug opt => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;
    let mut _4: &std::ffi::CString;

    bb0: {
        _4 = &((*_2).0: std::ffi::CString);
        _3 = <CString as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::set_options::{closure#2}(_1: &mut {closure@src/db.rs:1441:60: 1441:65}, _2: &(CString, CString)) -> *const i8 {
    debug opt => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;
    let mut _4: &std::ffi::CString;

    bb0: {
        _4 = &((*_2).1: std::ffi::CString);
        _3 = <CString as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::property_value(_1: &DB, _2: &str) -> Result<Option<String>, Error> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<std::option::Option<std::string::String>, Error>;
    let _3: std::ffi::CString;
    let mut _4: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _5: isize;
    let _6: std::ffi::CString;
    let _7: std::ffi::NulError;
    let mut _8: Error;
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &std::ffi::NulError;
    let mut _18: *mut ffi::rocksdb_t;
    let mut _19: *const i8;
    let _20: &std::ffi::CStr;
    let mut _21: &std::ffi::CString;
    let mut _22: bool;
    let mut _23: std::option::Option<std::string::String>;
    let mut _25: std::result::Result<&str, std::str::Utf8Error>;
    let _26: &std::ffi::CStr;
    let mut _27: *const i8;
    let mut _28: isize;
    let mut _31: Error;
    let mut _33: std::fmt::Arguments<'_>;
    let mut _34: &[&str];
    let mut _35: &[core::fmt::rt::Argument<'_>];
    let _36: &[core::fmt::rt::Argument<'_>; 1];
    let _37: [core::fmt::rt::Argument<'_>; 1];
    let mut _38: core::fmt::rt::Argument<'_>;
    let _39: &std::str::Utf8Error;
    let _40: ();
    let mut _41: *mut libc::c_void;
    let mut _42: std::option::Option<std::string::String>;
    let mut _43: std::string::String;
    scope 1 {
        debug prop_name => _3;
        scope 5 {
            let _17: *mut i8;
            scope 6 {
                debug value => _17;
                let _24: std::string::String;
                let _29: &str;
                let _30: std::str::Utf8Error;
                scope 7 {
                    debug str_value => _24;
                }
                scope 8 {
                    debug s => _29;
                }
                scope 9 {
                    debug e => _30;
                    let _32: std::string::String;
                    let mut _45: &[&str; 1];
                    scope 10 {
                        debug res => _32;
                    }
                }
            }
        }
    }
    scope 2 {
        debug c => _6;
    }
    scope 3 {
        debug e => _7;
        let _9: std::string::String;
        let mut _44: &[&str; 1];
        scope 4 {
            debug res => _9;
        }
    }

    bb0: {
        _4 = CString::new::<&str>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = move ((_4 as Err).0: std::ffi::NulError);
        _44 = const _;
        _11 = _44 as &[&str] (PointerCoercion(Unsize));
        _16 = &_7;
        _15 = core::fmt::rt::Argument::<'_>::new_display::<NulError>(_16) -> [return: bb5, unwind: bb29];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = move ((_4 as Ok).0: std::ffi::CString);
        _3 = move _6;
        _18 = ((*_1).0: *mut ffi::rocksdb_t);
        _21 = &_3;
        _20 = <CString as Deref>::deref(move _21) -> [return: bb9, unwind: bb28];
    }

    bb5: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb6, unwind: bb29];
    }

    bb6: {
        _9 = format(move _10) -> [return: bb7, unwind: bb29];
    }

    bb7: {
        _8 = Error::new(move _9) -> [return: bb8, unwind: bb29];
    }

    bb8: {
        _0 = Result::<Option<String>, Error>::Err(move _8);
        drop(_7) -> [return: bb26, unwind continue];
    }

    bb9: {
        _19 = CStr::as_ptr(_20) -> [return: bb10, unwind: bb28];
    }

    bb10: {
        _17 = rocksdb_property_value(move _18, move _19) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _22 = std::ptr::mut_ptr::<impl *mut i8>::is_null(_17) -> [return: bb12, unwind: bb28];
    }

    bb12: {
        switchInt(move _22) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _23 = Option::<String>::None;
        _0 = Result::<Option<String>, Error>::Ok(move _23);
        goto -> bb25;
    }

    bb14: {
        _27 = _17 as *const i8 (PointerCoercion(MutToConstPointer));
        _26 = CStr::from_ptr::<'_>(move _27) -> [return: bb15, unwind: bb28];
    }

    bb15: {
        _25 = CStr::to_str(_26) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _28 = discriminant(_25);
        switchInt(move _28) -> [0: bb18, 1: bb17, otherwise: bb3];
    }

    bb17: {
        _30 = ((_25 as Err).0: std::str::Utf8Error);
        _45 = const _;
        _34 = _45 as &[&str] (PointerCoercion(Unsize));
        _39 = &_30;
        _38 = core::fmt::rt::Argument::<'_>::new_display::<Utf8Error>(_39) -> [return: bb20, unwind: bb28];
    }

    bb18: {
        _29 = ((_25 as Ok).0: &str);
        _24 = <str as ToOwned>::to_owned(_29) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _41 = _17 as *mut libc::c_void (PtrToPtr);
        _40 = free(move _41) -> [return: bb24, unwind: bb27];
    }

    bb20: {
        _37 = [move _38];
        _36 = &_37;
        _35 = _36 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _33 = Arguments::<'_>::new_v1(move _34, move _35) -> [return: bb21, unwind: bb28];
    }

    bb21: {
        _32 = format(move _33) -> [return: bb22, unwind: bb28];
    }

    bb22: {
        _31 = Error::new(move _32) -> [return: bb23, unwind: bb28];
    }

    bb23: {
        _0 = Result::<Option<String>, Error>::Err(move _31);
        goto -> bb25;
    }

    bb24: {
        _43 = move _24;
        _42 = Option::<String>::Some(move _43);
        _0 = Result::<Option<String>, Error>::Ok(move _42);
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb25: {
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_24) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_3) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_7) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::property_value: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property name to CString: "];
        _0 = &_1;
        return;
    }
}

promoted[1] in db::<impl at src/db.rs:679:1: 679:8>::property_value: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property value to string: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::property_value_cf(_1: &DB, _2: ColumnFamily<'_>, _3: &str) -> Result<Option<String>, Error> {
    debug self => _1;
    debug cf => _2;
    debug name => _3;
    let mut _0: std::result::Result<std::option::Option<std::string::String>, Error>;
    let _4: std::ffi::CString;
    let mut _5: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _6: isize;
    let _7: std::ffi::CString;
    let _8: std::ffi::NulError;
    let mut _9: Error;
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 1];
    let _15: [core::fmt::rt::Argument<'_>; 1];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &std::ffi::NulError;
    let mut _19: *mut ffi::rocksdb_t;
    let mut _20: *mut ffi::rocksdb_column_family_handle_t;
    let mut _21: *const i8;
    let _22: &std::ffi::CStr;
    let mut _23: &std::ffi::CString;
    let mut _24: bool;
    let mut _25: std::option::Option<std::string::String>;
    let mut _27: std::result::Result<&str, std::str::Utf8Error>;
    let _28: &std::ffi::CStr;
    let mut _29: *const i8;
    let mut _30: isize;
    let mut _33: Error;
    let mut _35: std::fmt::Arguments<'_>;
    let mut _36: &[&str];
    let mut _37: &[core::fmt::rt::Argument<'_>];
    let _38: &[core::fmt::rt::Argument<'_>; 1];
    let _39: [core::fmt::rt::Argument<'_>; 1];
    let mut _40: core::fmt::rt::Argument<'_>;
    let _41: &std::str::Utf8Error;
    let _42: ();
    let mut _43: *mut libc::c_void;
    let mut _44: std::option::Option<std::string::String>;
    let mut _45: std::string::String;
    scope 1 {
        debug prop_name => _4;
        scope 5 {
            let _18: *mut i8;
            scope 6 {
                debug value => _18;
                let _26: std::string::String;
                let _31: &str;
                let _32: std::str::Utf8Error;
                scope 7 {
                    debug str_value => _26;
                }
                scope 8 {
                    debug s => _31;
                }
                scope 9 {
                    debug e => _32;
                    let _34: std::string::String;
                    let mut _47: &[&str; 1];
                    scope 10 {
                        debug res => _34;
                    }
                }
            }
        }
    }
    scope 2 {
        debug c => _7;
    }
    scope 3 {
        debug e => _8;
        let _10: std::string::String;
        let mut _46: &[&str; 1];
        scope 4 {
            debug res => _10;
        }
    }

    bb0: {
        _5 = CString::new::<&str>(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_5);
        switchInt(move _6) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _8 = move ((_5 as Err).0: std::ffi::NulError);
        _46 = const _;
        _12 = _46 as &[&str] (PointerCoercion(Unsize));
        _17 = &_8;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<NulError>(_17) -> [return: bb5, unwind: bb29];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _7 = move ((_5 as Ok).0: std::ffi::CString);
        _4 = move _7;
        _19 = ((*_1).0: *mut ffi::rocksdb_t);
        _20 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _23 = &_4;
        _22 = <CString as Deref>::deref(move _23) -> [return: bb9, unwind: bb28];
    }

    bb5: {
        _15 = [move _16];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _11 = Arguments::<'_>::new_v1(move _12, move _13) -> [return: bb6, unwind: bb29];
    }

    bb6: {
        _10 = format(move _11) -> [return: bb7, unwind: bb29];
    }

    bb7: {
        _9 = Error::new(move _10) -> [return: bb8, unwind: bb29];
    }

    bb8: {
        _0 = Result::<Option<String>, Error>::Err(move _9);
        drop(_8) -> [return: bb26, unwind continue];
    }

    bb9: {
        _21 = CStr::as_ptr(_22) -> [return: bb10, unwind: bb28];
    }

    bb10: {
        _18 = rocksdb_property_value_cf(move _19, move _20, move _21) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _24 = std::ptr::mut_ptr::<impl *mut i8>::is_null(_18) -> [return: bb12, unwind: bb28];
    }

    bb12: {
        switchInt(move _24) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _25 = Option::<String>::None;
        _0 = Result::<Option<String>, Error>::Ok(move _25);
        goto -> bb25;
    }

    bb14: {
        _29 = _18 as *const i8 (PointerCoercion(MutToConstPointer));
        _28 = CStr::from_ptr::<'_>(move _29) -> [return: bb15, unwind: bb28];
    }

    bb15: {
        _27 = CStr::to_str(_28) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _30 = discriminant(_27);
        switchInt(move _30) -> [0: bb18, 1: bb17, otherwise: bb3];
    }

    bb17: {
        _32 = ((_27 as Err).0: std::str::Utf8Error);
        _47 = const _;
        _36 = _47 as &[&str] (PointerCoercion(Unsize));
        _41 = &_32;
        _40 = core::fmt::rt::Argument::<'_>::new_display::<Utf8Error>(_41) -> [return: bb20, unwind: bb28];
    }

    bb18: {
        _31 = ((_27 as Ok).0: &str);
        _26 = <str as ToOwned>::to_owned(_31) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _43 = _18 as *mut libc::c_void (PtrToPtr);
        _42 = free(move _43) -> [return: bb24, unwind: bb27];
    }

    bb20: {
        _39 = [move _40];
        _38 = &_39;
        _37 = _38 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _35 = Arguments::<'_>::new_v1(move _36, move _37) -> [return: bb21, unwind: bb28];
    }

    bb21: {
        _34 = format(move _35) -> [return: bb22, unwind: bb28];
    }

    bb22: {
        _33 = Error::new(move _34) -> [return: bb23, unwind: bb28];
    }

    bb23: {
        _0 = Result::<Option<String>, Error>::Err(move _33);
        goto -> bb25;
    }

    bb24: {
        _45 = move _26;
        _44 = Option::<String>::Some(move _45);
        _0 = Result::<Option<String>, Error>::Ok(move _44);
        drop(_4) -> [return: bb26, unwind continue];
    }

    bb25: {
        drop(_4) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_26) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_4) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_8) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::property_value_cf: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property name to CString: "];
        _0 = &_1;
        return;
    }
}

promoted[1] in db::<impl at src/db.rs:679:1: 679:8>::property_value_cf: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property value to string: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::property_int_value(_1: &DB, _2: &str) -> Result<Option<u64>, Error> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<std::option::Option<u64>, Error>;
    let mut _3: std::result::Result<std::option::Option<std::string::String>, Error>;
    let mut _4: isize;
    let mut _5: isize;
    let _6: std::string::String;
    let mut _7: std::result::Result<u64, std::num::ParseIntError>;
    let _8: &str;
    let mut _9: &std::string::String;
    let mut _10: isize;
    let mut _12: std::option::Option<u64>;
    let mut _14: Error;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &std::num::ParseIntError;
    let mut _23: std::option::Option<u64>;
    let _24: Error;
    let mut _26: isize;
    scope 1 {
        debug value => _6;
        let _11: u64;
        let _13: std::num::ParseIntError;
        scope 2 {
            debug int_value => _11;
        }
        scope 3 {
            debug e => _13;
            let _15: std::string::String;
            let mut _25: &[&str; 1];
            scope 4 {
                debug res => _15;
            }
        }
    }
    scope 5 {
        debug e => _24;
    }

    bb0: {
        _3 = db::<impl DB>::property_value(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _4 = discriminant(((_3 as Ok).0: std::option::Option<std::string::String>));
        switchInt(move _4) -> [0: bb15, 1: bb5, otherwise: bb3];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _24 = move ((_3 as Err).0: Error);
        _0 = Result::<Option<u64>, Error>::Err(move _24);
        goto -> bb20;
    }

    bb5: {
        _6 = move ((((_3 as Ok).0: std::option::Option<std::string::String>) as Some).0: std::string::String);
        _9 = &_6;
        _8 = <String as Deref>::deref(move _9) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _7 = core::str::<impl str>::parse::<u64>(_8) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb9, 1: bb8, otherwise: bb3];
    }

    bb8: {
        _13 = move ((_7 as Err).0: std::num::ParseIntError);
        _25 = const _;
        _17 = _25 as &[&str] (PointerCoercion(Unsize));
        _22 = &_13;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<ParseIntError>(_22) -> [return: bb10, unwind: bb16];
    }

    bb9: {
        _11 = ((_7 as Ok).0: u64);
        _12 = Option::<u64>::Some(_11);
        _0 = Result::<Option<u64>, Error>::Ok(move _12);
        goto -> bb14;
    }

    bb10: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        _15 = format(move _16) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        _14 = Error::new(move _15) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        _0 = Result::<Option<u64>, Error>::Err(move _14);
        goto -> bb14;
    }

    bb14: {
        drop(_6) -> [return: bb20, unwind continue];
    }

    bb15: {
        _23 = Option::<u64>::None;
        _0 = Result::<Option<u64>, Error>::Ok(move _23);
        goto -> bb20;
    }

    bb16 (cleanup): {
        drop(_6) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }

    bb18: {
        return;
    }

    bb19: {
        goto -> bb18;
    }

    bb20: {
        _26 = discriminant(_3);
        switchInt(move _26) -> [0: bb19, otherwise: bb18];
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::property_int_value: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property value to int: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:679:1: 679:8>::property_int_value_cf(_1: &DB, _2: ColumnFamily<'_>, _3: &str) -> Result<Option<u64>, Error> {
    debug self => _1;
    debug cf => _2;
    debug name => _3;
    let mut _0: std::result::Result<std::option::Option<u64>, Error>;
    let mut _4: std::result::Result<std::option::Option<std::string::String>, Error>;
    let mut _5: isize;
    let mut _6: isize;
    let _7: std::string::String;
    let mut _8: std::result::Result<u64, std::num::ParseIntError>;
    let _9: &str;
    let mut _10: &std::string::String;
    let mut _11: isize;
    let mut _13: std::option::Option<u64>;
    let mut _15: Error;
    let mut _17: std::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[core::fmt::rt::Argument<'_>];
    let _20: &[core::fmt::rt::Argument<'_>; 1];
    let _21: [core::fmt::rt::Argument<'_>; 1];
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &std::num::ParseIntError;
    let mut _24: std::option::Option<u64>;
    let _25: Error;
    let mut _27: isize;
    scope 1 {
        debug value => _7;
        let _12: u64;
        let _14: std::num::ParseIntError;
        scope 2 {
            debug int_value => _12;
        }
        scope 3 {
            debug e => _14;
            let _16: std::string::String;
            let mut _26: &[&str; 1];
            scope 4 {
                debug res => _16;
            }
        }
    }
    scope 5 {
        debug e => _25;
    }

    bb0: {
        _4 = db::<impl DB>::property_value_cf(_1, _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _5 = discriminant(((_4 as Ok).0: std::option::Option<std::string::String>));
        switchInt(move _5) -> [0: bb15, 1: bb5, otherwise: bb3];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _25 = move ((_4 as Err).0: Error);
        _0 = Result::<Option<u64>, Error>::Err(move _25);
        goto -> bb20;
    }

    bb5: {
        _7 = move ((((_4 as Ok).0: std::option::Option<std::string::String>) as Some).0: std::string::String);
        _10 = &_7;
        _9 = <String as Deref>::deref(move _10) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _8 = core::str::<impl str>::parse::<u64>(_9) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb9, 1: bb8, otherwise: bb3];
    }

    bb8: {
        _14 = move ((_8 as Err).0: std::num::ParseIntError);
        _26 = const _;
        _18 = _26 as &[&str] (PointerCoercion(Unsize));
        _23 = &_14;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<ParseIntError>(_23) -> [return: bb10, unwind: bb16];
    }

    bb9: {
        _12 = ((_8 as Ok).0: u64);
        _13 = Option::<u64>::Some(_12);
        _0 = Result::<Option<u64>, Error>::Ok(move _13);
        goto -> bb14;
    }

    bb10: {
        _21 = [move _22];
        _20 = &_21;
        _19 = _20 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_v1(move _18, move _19) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        _16 = format(move _17) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        _15 = Error::new(move _16) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        _0 = Result::<Option<u64>, Error>::Err(move _15);
        goto -> bb14;
    }

    bb14: {
        drop(_7) -> [return: bb20, unwind continue];
    }

    bb15: {
        _24 = Option::<u64>::None;
        _0 = Result::<Option<u64>, Error>::Ok(move _24);
        goto -> bb20;
    }

    bb16 (cleanup): {
        drop(_7) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }

    bb18: {
        return;
    }

    bb19: {
        goto -> bb18;
    }

    bb20: {
        _27 = discriminant(_4);
        switchInt(move _27) -> [0: bb19, otherwise: bb18];
    }
}

promoted[0] in db::<impl at src/db.rs:679:1: 679:8>::property_int_value_cf: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Failed to convert property value to int: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::len(_1: &WriteBatch) -> usize {
    debug self => _1;
    let mut _0: usize;
    let mut _2: i32;
    let mut _3: *mut ffi::rocksdb_writebatch_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _2 = rocksdb_writebatch_count(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = move _2 as usize (IntToInt);
        return;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::size_in_bytes(_1: &WriteBatch) -> usize {
    debug self => _1;
    let mut _0: usize;
    let _3: *const i8;
    let mut _4: *mut ffi::rocksdb_writebatch_t;
    let mut _5: *mut usize;
    let mut _6: &mut usize;
    scope 1 {
        let mut _2: usize;
        scope 2 {
            debug batch_size => _2;
        }
    }

    bb0: {
        _2 = const 0_usize;
        _4 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _6 = &mut _2;
        _5 = &raw mut (*_6);
        _3 = rocksdb_writebatch_data(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = _2;
        return;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::is_empty(_1: &WriteBatch) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: usize;

    bb0: {
        _2 = WriteBatch::len(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Eq(move _2, const 0_usize);
        return;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::put(_1: &mut WriteBatch, _2: K, _3: V) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    let mut _0: std::result::Result<(), Error>;
    let _4: &[u8];
    let mut _5: &K;
    let mut _7: &V;
    let _8: ();
    let mut _9: *mut ffi::rocksdb_writebatch_t;
    let mut _10: *const i8;
    let mut _11: *const u8;
    let mut _12: usize;
    let mut _13: *const i8;
    let mut _14: *const u8;
    let mut _15: usize;
    scope 1 {
        debug key => _4;
        let _6: &[u8];
        scope 2 {
            debug value => _6;
            scope 3 {
            }
        }
    }

    bb0: {
        _5 = &_2;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _7 = &_3;
        _6 = <V as AsRef<[u8]>>::as_ref(move _7) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _9 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _11 = core::slice::<impl [u8]>::as_ptr(_4) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _10 = move _11 as *const i8 (PtrToPtr);
        _12 = Len((*_4));
        _14 = core::slice::<impl [u8]>::as_ptr(_6) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _13 = move _14 as *const i8 (PtrToPtr);
        _15 = Len((*_6));
        _8 = rocksdb_writebatch_put(move _9, move _10, move _12, move _13, move _15) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::put_cf(_1: &mut WriteBatch, _2: ColumnFamily<'_>, _3: K, _4: V) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let mut _6: &K;
    let mut _8: &V;
    let _9: ();
    let mut _10: *mut ffi::rocksdb_writebatch_t;
    let mut _11: *mut ffi::rocksdb_column_family_handle_t;
    let mut _12: *const i8;
    let mut _13: *const u8;
    let mut _14: usize;
    let mut _15: *const i8;
    let mut _16: *const u8;
    let mut _17: usize;
    scope 1 {
        debug key => _5;
        let _7: &[u8];
        scope 2 {
            debug value => _7;
            scope 3 {
            }
        }
    }

    bb0: {
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _8 = &_4;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _10 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _11 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _13 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _12 = move _13 as *const i8 (PtrToPtr);
        _14 = Len((*_5));
        _16 = core::slice::<impl [u8]>::as_ptr(_7) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _15 = move _16 as *const i8 (PtrToPtr);
        _17 = Len((*_7));
        _9 = rocksdb_writebatch_put_cf(move _10, move _11, move _12, move _14, move _15, move _17) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_4) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::merge(_1: &mut WriteBatch, _2: K, _3: V) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    debug value => _3;
    let mut _0: std::result::Result<(), Error>;
    let _4: &[u8];
    let mut _5: &K;
    let mut _7: &V;
    let _8: ();
    let mut _9: *mut ffi::rocksdb_writebatch_t;
    let mut _10: *const i8;
    let mut _11: *const u8;
    let mut _12: usize;
    let mut _13: *const i8;
    let mut _14: *const u8;
    let mut _15: usize;
    scope 1 {
        debug key => _4;
        let _6: &[u8];
        scope 2 {
            debug value => _6;
            scope 3 {
            }
        }
    }

    bb0: {
        _5 = &_2;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _7 = &_3;
        _6 = <V as AsRef<[u8]>>::as_ref(move _7) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _9 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _11 = core::slice::<impl [u8]>::as_ptr(_4) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _10 = move _11 as *const i8 (PtrToPtr);
        _12 = Len((*_4));
        _14 = core::slice::<impl [u8]>::as_ptr(_6) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _13 = move _14 as *const i8 (PtrToPtr);
        _15 = Len((*_6));
        _8 = rocksdb_writebatch_merge(move _9, move _10, move _12, move _13, move _15) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::merge_cf(_1: &mut WriteBatch, _2: ColumnFamily<'_>, _3: K, _4: V) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    debug value => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let mut _6: &K;
    let mut _8: &V;
    let _9: ();
    let mut _10: *mut ffi::rocksdb_writebatch_t;
    let mut _11: *mut ffi::rocksdb_column_family_handle_t;
    let mut _12: *const i8;
    let mut _13: *const u8;
    let mut _14: usize;
    let mut _15: *const i8;
    let mut _16: *const u8;
    let mut _17: usize;
    scope 1 {
        debug key => _5;
        let _7: &[u8];
        scope 2 {
            debug value => _7;
            scope 3 {
            }
        }
    }

    bb0: {
        _6 = &_3;
        _5 = <K as AsRef<[u8]>>::as_ref(move _6) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _8 = &_4;
        _7 = <V as AsRef<[u8]>>::as_ref(move _8) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _10 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _11 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _13 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _12 = move _13 as *const i8 (PtrToPtr);
        _14 = Len((*_5));
        _16 = core::slice::<impl [u8]>::as_ptr(_7) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _15 = move _16 as *const i8 (PtrToPtr);
        _17 = Len((*_7));
        _9 = rocksdb_writebatch_merge_cf(move _10, move _11, move _12, move _14, move _15, move _17) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_4) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::delete(_1: &mut WriteBatch, _2: K) -> Result<(), Error> {
    debug self => _1;
    debug key => _2;
    let mut _0: std::result::Result<(), Error>;
    let _3: &[u8];
    let mut _4: &K;
    let _5: ();
    let mut _6: *mut ffi::rocksdb_writebatch_t;
    let mut _7: *const i8;
    let mut _8: *const u8;
    let mut _9: usize;
    scope 1 {
        debug key => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _6 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _8 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = move _8 as *const i8 (PtrToPtr);
        _9 = Len((*_3));
        _5 = rocksdb_writebatch_delete(move _6, move _7, move _9) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::delete_cf(_1: &mut WriteBatch, _2: ColumnFamily<'_>, _3: K) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug key => _3;
    let mut _0: std::result::Result<(), Error>;
    let _4: &[u8];
    let mut _5: &K;
    let _6: ();
    let mut _7: *mut ffi::rocksdb_writebatch_t;
    let mut _8: *mut ffi::rocksdb_column_family_handle_t;
    let mut _9: *const i8;
    let mut _10: *const u8;
    let mut _11: usize;
    scope 1 {
        debug key => _4;
        scope 2 {
        }
    }

    bb0: {
        _5 = &_3;
        _4 = <K as AsRef<[u8]>>::as_ref(move _5) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _7 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _8 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _10 = core::slice::<impl [u8]>::as_ptr(_4) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _9 = move _10 as *const i8 (PtrToPtr);
        _11 = Len((*_4));
        _6 = rocksdb_writebatch_delete_cf(move _7, move _8, move _9, move _11) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_3) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::delete_range(_1: &mut WriteBatch, _2: K, _3: K) -> Result<(), Error> {
    debug self => _1;
    debug from => _2;
    debug to => _3;
    let mut _0: std::result::Result<(), Error>;
    let _4: &[u8];
    let _5: &[u8];
    let mut _6: (&[u8], &[u8]);
    let mut _7: &[u8];
    let mut _8: &K;
    let mut _9: &[u8];
    let mut _10: &K;
    let _11: ();
    let mut _12: *mut ffi::rocksdb_writebatch_t;
    let mut _13: *const i8;
    let mut _14: *const u8;
    let mut _15: usize;
    let mut _16: *const i8;
    let mut _17: *const u8;
    let mut _18: usize;
    scope 1 {
        debug start_key => _4;
        debug end_key => _5;
        scope 2 {
        }
    }

    bb0: {
        _8 = &_2;
        _7 = <K as AsRef<[u8]>>::as_ref(move _8) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _10 = &_3;
        _9 = <K as AsRef<[u8]>>::as_ref(move _10) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _6 = (move _7, move _9);
        _4 = (_6.0: &[u8]);
        _5 = (_6.1: &[u8]);
        _12 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _14 = core::slice::<impl [u8]>::as_ptr(_4) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _13 = move _14 as *const i8 (PtrToPtr);
        _15 = Len((*_4));
        _17 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _16 = move _17 as *const i8 (PtrToPtr);
        _18 = Len((*_5));
        _11 = rocksdb_writebatch_delete_range(move _12, move _13, move _15, move _16, move _18) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_3) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::delete_range_cf(_1: &mut WriteBatch, _2: ColumnFamily<'_>, _3: K, _4: K) -> Result<(), Error> {
    debug self => _1;
    debug cf => _2;
    debug from => _3;
    debug to => _4;
    let mut _0: std::result::Result<(), Error>;
    let _5: &[u8];
    let _6: &[u8];
    let mut _7: (&[u8], &[u8]);
    let mut _8: &[u8];
    let mut _9: &K;
    let mut _10: &[u8];
    let mut _11: &K;
    let _12: ();
    let mut _13: *mut ffi::rocksdb_writebatch_t;
    let mut _14: *mut ffi::rocksdb_column_family_handle_t;
    let mut _15: *const i8;
    let mut _16: *const u8;
    let mut _17: usize;
    let mut _18: *const i8;
    let mut _19: *const u8;
    let mut _20: usize;
    scope 1 {
        debug start_key => _5;
        debug end_key => _6;
        scope 2 {
        }
    }

    bb0: {
        _9 = &_3;
        _8 = <K as AsRef<[u8]>>::as_ref(move _9) -> [return: bb1, unwind: bb8];
    }

    bb1: {
        _11 = &_4;
        _10 = <K as AsRef<[u8]>>::as_ref(move _11) -> [return: bb2, unwind: bb8];
    }

    bb2: {
        _7 = (move _8, move _10);
        _5 = (_7.0: &[u8]);
        _6 = (_7.1: &[u8]);
        _13 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _14 = (_2.0: *mut ffi::rocksdb_column_family_handle_t);
        _16 = core::slice::<impl [u8]>::as_ptr(_5) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        _15 = move _16 as *const i8 (PtrToPtr);
        _17 = Len((*_5));
        _19 = core::slice::<impl [u8]>::as_ptr(_6) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _18 = move _19 as *const i8 (PtrToPtr);
        _20 = Len((*_6));
        _12 = rocksdb_writebatch_delete_range_cf(move _13, move _14, move _15, move _17, move _18, move _20) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = Result::<(), Error>::Ok(const ());
        drop(_4) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1567:1: 1567:16>::clear(_1: &mut WriteBatch) -> Result<(), Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), Error>;
    let _2: ();
    let mut _3: *mut ffi::rocksdb_writebatch_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _2 = rocksdb_writebatch_clear(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<(), Error>::Ok(const ());
        return;
    }
}

fn db::<impl at src/db.rs:1753:1: 1753:28>::default() -> WriteBatch {
    let mut _0: db::WriteBatch;
    let mut _1: *mut ffi::rocksdb_writebatch_t;
    scope 1 {
    }

    bb0: {
        _1 = rocksdb_writebatch_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = WriteBatch { inner: move _1 };
        return;
    }
}

fn db::<impl at src/db.rs:1761:1: 1761:25>::drop(_1: &mut WriteBatch) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: *mut ffi::rocksdb_writebatch_t;
    scope 1 {
    }

    bb0: {
        _2 = ((*_1).0: *mut ffi::rocksdb_writebatch_t);
        _0 = rocksdb_writebatch_destroy(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1767:1: 1767:17>::drop(_1: &mut DB) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: std::result::Result<std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>, std::sync::PoisonError<std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>>;
    let _3: &std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _4: &std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>;
    let mut _5: isize;
    let mut _7: std::collections::btree_map::Values<'_, std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _8: std::collections::btree_map::Values<'_, std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let _9: &std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _10: &std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
    let mut _12: std::option::Option<&*mut ffi::rocksdb_column_family_handle_t>;
    let mut _13: &mut std::collections::btree_map::Values<'_, std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
    let mut _14: isize;
    let _16: ();
    let mut _17: *mut ffi::rocksdb_column_family_handle_t;
    let _18: ();
    let mut _19: *mut ffi::rocksdb_t;
    let mut _20: bool;
    let mut _21: isize;
    let mut _22: isize;
    scope 1 {
        scope 2 {
            debug cfs => _6;
            let _6: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>;
            let mut _11: std::collections::btree_map::Values<'_, std::string::String, *mut ffi::rocksdb_column_family_handle_t>;
            scope 3 {
                debug iter => _11;
                let _15: &*mut ffi::rocksdb_column_family_handle_t;
                scope 4 {
                    debug cf => _15;
                }
            }
        }
    }

    bb0: {
        _20 = const false;
        _4 = &((*_1).1: std::sync::Arc<std::sync::RwLock<std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>>);
        _3 = <Arc<RwLock<BTreeMap<String, *mut rocksdb_column_family_handle_t>>> as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _20 = const true;
        _2 = RwLock::<BTreeMap<String, *mut rocksdb_column_family_handle_t>>::read(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, otherwise: bb19];
    }

    bb3: {
        _20 = const false;
        _6 = move ((_2 as Ok).0: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>);
        _10 = &_6;
        _9 = <RwLockReadGuard<'_, BTreeMap<String, *mut rocksdb_column_family_handle_t>> as Deref>::deref(move _10) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _8 = BTreeMap::<String, *mut rocksdb_column_family_handle_t>::values(_9) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _7 = <std::collections::btree_map::Values<'_, String, *mut rocksdb_column_family_handle_t> as IntoIterator>::into_iter(move _8) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _11 = move _7;
        goto -> bb7;
    }

    bb7: {
        _13 = &mut _11;
        _12 = <std::collections::btree_map::Values<'_, String, *mut rocksdb_column_family_handle_t> as Iterator>::next(_13) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _15 = ((_12 as Some).0: &*mut ffi::rocksdb_column_family_handle_t);
        _17 = (*_15);
        _16 = rocksdb_column_family_handle_destroy(move _17) -> [return: bb22, unwind: bb13];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        drop(_6) -> [return: bb19, unwind: bb21];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_6) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        _20 = const false;
        _19 = ((*_1).0: *mut ffi::rocksdb_t);
        _18 = rocksdb_close(move _19) -> [return: bb12, unwind continue];
    }

    bb16: {
        switchInt(_20) -> [0: bb15, otherwise: bb17];
    }

    bb17: {
        drop(((_2 as Ok).0: std::sync::RwLockReadGuard<'_, std::collections::BTreeMap<std::string::String, *mut ffi::rocksdb_column_family_handle_t>>)) -> [return: bb15, unwind continue];
    }

    bb18: {
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb19: {
        _21 = discriminant(_2);
        switchInt(move _21) -> [0: bb16, otherwise: bb18];
    }

    bb20 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        _22 = discriminant(_2);
        switchInt(move _22) -> [0: bb14, otherwise: bb20];
    }

    bb22: {
        goto -> bb7;
    }
}

fn db::<impl at src/db.rs:1780:1: 1780:23>::fmt(_1: &DB, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &&std::path::Path;
    let _10: &std::path::Path;
    let mut _11: &[&str; 2];

    bb0: {
        _11 = const _;
        _4 = _11 as &[&str] (PointerCoercion(Unsize));
        _10 = db::<impl DB>::path(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_debug::<&Path>(_9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = Formatter::<'_>::write_fmt(_2, move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

promoted[0] in db::<impl at src/db.rs:1780:1: 1780:23>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "RocksDB { path: ", const " }"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:1786:1: 1786:26>::drop(_1: &mut ReadOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: *mut ffi::rocksdb_readoptions_t;
    scope 1 {
    }

    bb0: {
        _2 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _0 = rocksdb_readoptions_destroy(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::fill_cache(_1: &mut ReadOptions, _2: bool) -> () {
    debug self => _1;
    debug v => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_readoptions_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_readoptions_set_fill_cache(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::set_snapshot(_1: &mut ReadOptions, _2: &Snapshot<'_>) -> () {
    debug self => _1;
    debug snapshot => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_readoptions_t;
    let mut _5: *const ffi::rocksdb_snapshot_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _5 = ((*_2).1: *const ffi::rocksdb_snapshot_t);
        _3 = rocksdb_readoptions_set_snapshot(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::set_iterate_upper_bound(_1: &mut ReadOptions, _2: K) -> () {
    debug self => _1;
    debug key => _2;
    let mut _0: ();
    let _3: &[u8];
    let mut _4: &K;
    let _5: ();
    let mut _6: *mut ffi::rocksdb_readoptions_t;
    let mut _7: *const i8;
    let mut _8: *const u8;
    let mut _9: usize;
    scope 1 {
        debug key => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = &_2;
        _3 = <K as AsRef<[u8]>>::as_ref(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _6 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _8 = core::slice::<impl [u8]>::as_ptr(_3) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _7 = move _8 as *const i8 (PtrToPtr);
        _9 = Len((*_3));
        _5 = rocksdb_readoptions_set_iterate_upper_bound(move _6, move _7, move _9) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::set_prefix_same_as_start(_1: &mut ReadOptions, _2: bool) -> () {
    debug self => _1;
    debug v => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_readoptions_t;
    let mut _4: u8;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _4 = _2 as u8 (IntToInt);
        _0 = rocksdb_readoptions_set_prefix_same_as_start(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::set_total_order_seek(_1: &mut ReadOptions, _2: bool) -> () {
    debug self => _1;
    debug v => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_readoptions_t;
    let mut _4: u8;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _4 = _2 as u8 (IntToInt);
        _0 = rocksdb_readoptions_set_total_order_seek(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1792:1: 1792:17>::set_readahead_size(_1: &mut ReadOptions, _2: usize) -> () {
    debug self => _1;
    debug v => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_readoptions_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_readoptions_t);
        _3 = rocksdb_readoptions_set_readahead_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1847:1: 1847:29>::default() -> ReadOptions {
    let mut _0: db::ReadOptions;
    let mut _1: *mut ffi::rocksdb_readoptions_t;
    scope 1 {
    }

    bb0: {
        _1 = rocksdb_readoptions_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ReadOptions { inner: move _1 };
        return;
    }
}

fn db::<impl at src/db.rs:1867:1: 1867:24>::deref(_1: &DBVector) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];
    let mut _2: *const u8;
    let mut _3: *mut u8;
    let mut _4: usize;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut u8);
        _2 = move _3 as *const u8 (PointerCoercion(MutToConstPointer));
        _4 = ((*_1).1: usize);
        _0 = std::slice::from_raw_parts::<'_, u8>(move _2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1875:1: 1875:30>::as_ref(_1: &DBVector) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];

    bb0: {
        _0 = <DBVector as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1882:1: 1882:23>::drop(_1: &mut DBVector) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut libc::c_void;
    let mut _4: *mut u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut u8);
        _3 = move _4 as *mut libc::c_void (PtrToPtr);
        _2 = free(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1890:1: 1890:14>::from_c(_1: *mut u8, _2: usize) -> DBVector {
    debug val => _1;
    debug val_len => _2;
    let mut _0: db::DBVector;

    bb0: {
        _0 = DBVector { base: _1, len: _2 };
        return;
    }
}

fn db::<impl at src/db.rs:1890:1: 1890:14>::to_utf8(_1: &DBVector) -> Option<&str> {
    debug self => _1;
    let mut _0: std::option::Option<&str>;
    let mut _2: std::result::Result<&str, std::str::Utf8Error>;
    let _3: &[u8];

    bb0: {
        _3 = <DBVector as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = from_utf8(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Result::<&str, Utf8Error>::ok(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn to_cpath(_1: P) -> Result<CString, Error> {
    debug path => _1;
    let mut _0: std::result::Result<std::ffi::CString, Error>;
    let mut _2: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _3: &[u8];
    let _4: &str;
    let mut _5: &std::borrow::Cow<'_, str>;
    let _6: std::borrow::Cow<'_, str>;
    let _7: &std::path::Path;
    let mut _8: &P;
    let mut _9: isize;
    let _10: std::ffi::CString;
    let mut _11: Error;
    let mut _12: std::string::String;
    let _13: &str;
    let mut _14: isize;
    let mut _15: isize;
    scope 1 {
        debug c => _10;
    }

    bb0: {
        _8 = &_1;
        _7 = <P as AsRef<Path>>::as_ref(move _8) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _6 = Path::to_string_lossy(_7) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _5 = &_6;
        _4 = <Cow<'_, str> as Deref>::deref(move _5) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _3 = core::str::<impl str>::as_bytes(_4) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _2 = CString::new::<&[u8]>(move _3) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _9 = discriminant(_2);
        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _13 = const "Failed to convert path to CString when opening DB.";
        _12 = <str as ToOwned>::to_owned(_13) -> [return: bb9, unwind: bb20];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_2 as Ok).0: std::ffi::CString);
        _0 = Result::<CString, Error>::Ok(move _10);
        goto -> bb11;
    }

    bb9: {
        _11 = Error::new(move _12) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _0 = Result::<CString, Error>::Err(move _11);
        goto -> bb11;
    }

    bb11: {
        _14 = discriminant(_2);
        switchInt(move _14) -> [0: bb17, otherwise: bb18];
    }

    bb12: {
        drop(_1) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_6) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_1) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17: {
        drop(_6) -> [return: bb12, unwind: bb15];
    }

    bb18: {
        drop(_2) -> [return: bb17, unwind: bb14];
    }

    bb19 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        _15 = discriminant(_2);
        switchInt(move _15) -> [0: bb14, otherwise: bb19];
    }
}

fn db::<impl at src/db.rs:1939:1: 1939:45>::as_ref(_1: &DBPinnableSlice<'_>) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];

    bb0: {
        _0 = <DBPinnableSlice<'_> as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1946:1: 1946:39>::deref(_1: &DBPinnableSlice<'_>) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];
    let mut _4: *const i8;
    let mut _5: *const ffi::rocksdb_pinnableslice_t;
    let mut _6: *mut ffi::rocksdb_pinnableslice_t;
    let mut _7: *mut usize;
    let mut _8: &mut usize;
    let mut _9: *const u8;
    let mut _10: usize;
    scope 1 {
        let mut _2: usize;
        scope 2 {
            debug val_len => _2;
            let _3: *mut u8;
            scope 3 {
                debug val => _3;
            }
        }
    }

    bb0: {
        _2 = const 0_usize;
        _6 = ((*_1).0: *mut ffi::rocksdb_pinnableslice_t);
        _5 = move _6 as *const ffi::rocksdb_pinnableslice_t (PointerCoercion(MutToConstPointer));
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _4 = rocksdb_pinnableslice_value(move _5, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = move _4 as *mut u8 (PtrToPtr);
        _9 = _3 as *const u8 (PointerCoercion(MutToConstPointer));
        _10 = _2;
        _0 = std::slice::from_raw_parts::<'_, u8>(move _9, move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:1958:1: 1958:38>::drop(_1: &mut DBPinnableSlice<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_pinnableslice_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_pinnableslice_t);
        _2 = rocksdb_pinnableslice_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:1966:1: 1966:29>::from_c(_1: *mut rocksdb_pinnableslice_t) -> DBPinnableSlice<'_> {
    debug ptr => _1;
    let mut _0: db::DBPinnableSlice<'_>;

    bb0: {
        _0 = DBPinnableSlice::<'_> { ptr: _1, db: const PhantomData::<&DB> };
        return;
    }
}

fn new_cache(_1: usize) -> *mut rocksdb_cache_t {
    debug capacity => _1;
    let mut _0: *mut ffi::rocksdb_cache_t;
    scope 1 {
    }

    bb0: {
        _0 = rocksdb_cache_create_lru(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:39:1: 39:22>::drop(_1: &mut Options) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _2 = rocksdb_options_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:47:1: 47:32>::drop(_1: &mut BlockBasedOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_block_based_table_options_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _2 = rocksdb_block_based_options_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:55:1: 55:27>::drop(_1: &mut FlushOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_flushoptions_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_flushoptions_t);
        _2 = rocksdb_flushoptions_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:63:1: 63:27>::drop(_1: &mut WriteOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_writeoptions_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_writeoptions_t);
        _2 = rocksdb_writeoptions_destroy(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::set_block_size(_1: &mut BlockBasedOptions, _2: usize) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_block_based_table_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _3 = rocksdb_block_based_options_set_block_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::set_lru_cache(_1: &mut BlockBasedOptions, _2: usize) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: *mut ffi::rocksdb_cache_t;
    let _4: ();
    let mut _5: *mut ffi::rocksdb_block_based_table_options_t;
    scope 1 {
        debug cache => _3;
        scope 2 {
        }
    }

    bb0: {
        _3 = new_cache(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _4 = rocksdb_block_based_options_set_block_cache(move _5, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::disable_cache(_1: &mut BlockBasedOptions) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_block_based_table_options_t;
    let mut _4: u8;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _4 = const true as u8 (IntToInt);
        _2 = rocksdb_block_based_options_set_no_block_cache(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::set_bloom_filter(_1: &mut BlockBasedOptions, _2: i32, _3: bool) -> () {
    debug self => _1;
    debug bits_per_key => _2;
    debug block_based => _3;
    let mut _0: ();
    let _5: ();
    let mut _6: *mut ffi::rocksdb_block_based_table_options_t;
    let mut _7: *mut ffi::rocksdb_filterpolicy_t;
    scope 1 {
        let _4: *mut ffi::rocksdb_filterpolicy_t;
        scope 2 {
            debug bloom => _4;
        }
    }

    bb0: {
        switchInt(_3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = rocksdb_filterpolicy_create_bloom(_2) -> [return: bb3, unwind continue];
    }

    bb2: {
        _4 = rocksdb_filterpolicy_create_bloom_full(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _7 = _4;
        _5 = rocksdb_block_based_options_set_filter_policy(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::set_cache_index_and_filter_blocks(_1: &mut BlockBasedOptions, _2: bool) -> () {
    debug self => _1;
    debug v => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_block_based_table_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_block_based_options_set_cache_index_and_filter_blocks(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:71:1: 71:23>::set_index_type(_1: &mut BlockBasedOptions, _2: BlockBasedIndexType) -> () {
    debug self => _1;
    debug index_type => _2;
    let mut _0: ();
    let _3: i32;
    let mut _4: isize;
    let mut _5: u8;
    let mut _6: bool;
    let _7: ();
    let mut _8: *mut ffi::rocksdb_block_based_table_options_t;
    scope 1 {
        debug index => _3;
        scope 2 {
        }
    }

    bb0: {
        _4 = discriminant(_2);
        _5 = _4 as u8 (IntToInt);
        _6 = Le(_5, const 2_u8);
        assume(move _6);
        _3 = move _4 as i32 (IntToInt);
        _8 = ((*_1).0: *mut ffi::rocksdb_block_based_table_options_t);
        _7 = rocksdb_block_based_options_set_index_type(move _8, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:130:1: 130:35>::default() -> BlockBasedOptions {
    let mut _0: BlockBasedOptions;
    let _1: *mut ffi::rocksdb_block_based_table_options_t;
    let mut _2: bool;
    let _3: !;
    scope 1 {
        debug block_opts => _1;
    }
    scope 2 {
    }

    bb0: {
        _1 = rocksdb_block_based_options_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_block_based_table_options_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = begin_panic::<&str>(const "Could not create RocksDB block based options") -> unwind continue;
    }

    bb4: {
        _0 = BlockBasedOptions { inner: _1 };
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::increase_parallelism(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug parallelism => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_increase_parallelism(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::optimize_level_style_compaction(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug memtable_memory_budget => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u64;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u64 (IntToInt);
        _3 = rocksdb_options_optimize_level_style_compaction(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::create_if_missing(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug create_if_missing => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_create_if_missing(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::create_missing_column_families(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug create_missing_cfs => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_create_missing_column_families(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compression_type(_1: &mut Options, _2: DBCompressionType) -> () {
    debug self => _1;
    debug t => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: i32;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _6 = discriminant(_2);
        _7 = _6 as u8 (IntToInt);
        _8 = Le(_7, const 7_u8);
        assume(move _8);
        _5 = move _6 as i32 (IntToInt);
        _3 = rocksdb_options_set_compression(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compression_per_level(_1: &mut Options, _2: &[DBCompressionType]) -> () {
    debug self => _1;
    debug level_types => _2;
    let mut _0: ();
    let mut _4: std::iter::Map<std::slice::Iter<'_, db::DBCompressionType>, {closure@src/db_options.rs:254:66: 254:70}>;
    let mut _5: std::slice::Iter<'_, db::DBCompressionType>;
    let mut _6: *mut ffi::rocksdb_options_t;
    let mut _7: *mut i32;
    let mut _8: &mut std::vec::Vec<i32>;
    let mut _9: usize;
    let mut _10: &std::vec::Vec<i32>;
    scope 1 {
        let mut _3: std::vec::Vec<i32>;
        scope 2 {
            debug level_types => _3;
        }
    }

    bb0: {
        _5 = core::slice::<impl [DBCompressionType]>::iter(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <std::slice::Iter<'_, DBCompressionType> as Iterator>::map::<i32, {closure@src/db_options.rs:254:66: 254:70}>(move _5, const ZeroSized: {closure@src/db_options.rs:254:66: 254:70}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <Map<std::slice::Iter<'_, DBCompressionType>, {closure@src/db_options.rs:254:66: 254:70}> as Iterator>::collect::<Vec<i32>>(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _8 = &mut _3;
        _7 = Vec::<i32>::as_mut_ptr(move _8) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _10 = &_3;
        _9 = Vec::<i32>::len(move _10) -> [return: bb5, unwind: bb8];
    }

    bb5: {
        _0 = rocksdb_options_set_compression_per_level(move _6, move _7, move _9) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compression_per_level::{closure#0}(_1: &mut {closure@src/db_options.rs:254:66: 254:70}, _2: &DBCompressionType) -> i32 {
    let mut _0: i32;
    let _3: db::DBCompressionType;
    let mut _4: isize;
    let mut _5: u8;
    let mut _6: bool;
    scope 1 {
        debug t => _3;
    }

    bb0: {
        _3 = (*_2);
        _4 = discriminant(_3);
        _5 = _4 as u8 (IntToInt);
        _6 = Le(_5, const 7_u8);
        assume(move _6);
        _0 = move _4 as i32 (IntToInt);
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compaction_readahead_size(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug compaction_readahead_size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_compaction_readahead_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_merge_operator(_1: &mut Options, _2: &str, _3: for<'a, 'b, 'c> fn(&'a [u8], Option<&'b [u8]>, &'c mut MergeOperands) -> Option<Vec<u8>>, _4: Option<for<'a, 'b, 'c> fn(&'a [u8], Option<&'b [u8]>, &'c mut MergeOperands) -> Option<Vec<u8>>>) -> () {
    debug self => _1;
    debug name => _2;
    debug full_merge_fn => _3;
    debug partial_merge_fn => _4;
    let mut _0: ();
    let _5: std::boxed::Box<merge_operator::MergeOperatorCallback>;
    let mut _6: merge_operator::MergeOperatorCallback;
    let mut _7: std::ffi::CString;
    let mut _8: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _9: &[u8];
    let mut _10: for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>;
    let mut _12: *mut libc::c_void;
    let mut _13: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _14: unsafe extern "C" fn(*mut libc::c_void);
    let mut _15: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8>;
    let mut _16: unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8;
    let mut _17: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8>;
    let mut _18: unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8;
    let mut _19: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize)>;
    let mut _20: std::option::Option<unsafe extern "C" fn(*mut libc::c_void) -> *const i8>;
    let mut _21: unsafe extern "C" fn(*mut libc::c_void) -> *const i8;
    let _22: ();
    let mut _23: *mut ffi::rocksdb_options_t;
    scope 1 {
        debug cb => _5;
        scope 2 {
            let _11: *mut ffi::rocksdb_mergeoperator_t;
            scope 3 {
                debug mo => _11;
            }
        }
    }

    bb0: {
        _9 = core::str::<impl str>::as_bytes(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = CString::new::<&[u8]>(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Result::<CString, NulError>::unwrap(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = Option::<for<'a, 'b, 'c> fn(&'a [u8], Option<&'b [u8]>, &'c mut MergeOperands) -> Option<Vec<u8>>>::unwrap_or(_4, _3) -> [return: bb4, unwind: bb8];
    }

    bb4: {
        _6 = MergeOperatorCallback { name: move _7, full_merge_fn: _3, partial_merge_fn: move _10 };
        _5 = Box::<MergeOperatorCallback>::new(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = move _5 as *mut libc::c_void (Transmute);
        _14 = merge_operator::destructor_callback as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _13 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _14);
        _16 = merge_operator::full_merge_callback as unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8 (PointerCoercion(ReifyFnPointer));
        _15 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8>::Some(move _16);
        _18 = merge_operator::partial_merge_callback as unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8 (PointerCoercion(ReifyFnPointer));
        _17 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize, *const *const i8, *const usize, i32, *mut u8, *mut usize) -> *mut i8>::Some(move _18);
        _19 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize)>::None;
        _21 = merge_operator::name_callback as unsafe extern "C" fn(*mut libc::c_void) -> *const i8 (PointerCoercion(ReifyFnPointer));
        _20 = Option::<unsafe extern "C" fn(*mut c_void) -> *const i8>::Some(move _21);
        _11 = rocksdb_mergeoperator_create(move _12, move _13, move _15, move _17, move _19, move _20) -> [return: bb6, unwind continue];
    }

    bb6: {
        _23 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _22 = rocksdb_options_set_merge_operator(move _23, _11) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_7) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::add_merge_operator(_1: &mut Options, _2: &str, _3: for<'a, 'b, 'c> fn(&'a [u8], Option<&'b [u8]>, &'c mut MergeOperands) -> Option<Vec<u8>>) -> () {
    debug self => _1;
    debug name => _2;
    debug merge_fn => _3;
    let mut _0: ();
    let _4: ();
    let mut _5: std::option::Option<for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>>;

    bb0: {
        _5 = Option::<for<'a, 'b, 'c> fn(&'a [u8], Option<&'b [u8]>, &'c mut MergeOperands) -> Option<Vec<u8>>>::None;
        _4 = db_options::<impl Options>::set_merge_operator(_1, _2, _3, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compaction_filter(_1: &mut Options, _2: &str, _3: F) -> () {
    debug self => _1;
    debug name => _2;
    debug filter_fn => _3;
    let mut _0: ();
    let _4: std::boxed::Box<compaction_filter::CompactionFilterCallback<F>>;
    let mut _5: compaction_filter::CompactionFilterCallback<F>;
    let mut _6: std::ffi::CString;
    let mut _7: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _8: &[u8];
    let mut _9: F;
    let mut _11: *mut libc::c_void;
    let mut _12: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _13: unsafe extern "C" fn(*mut libc::c_void);
    let mut _14: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, i32, *const i8, usize, *const i8, usize, *mut *mut i8, *mut usize, *mut u8) -> u8>;
    let mut _15: unsafe extern "C" fn(*mut libc::c_void, i32, *const i8, usize, *const i8, usize, *mut *mut i8, *mut usize, *mut u8) -> u8;
    let mut _16: std::option::Option<unsafe extern "C" fn(*mut libc::c_void) -> *const i8>;
    let mut _17: unsafe extern "C" fn(*mut libc::c_void) -> *const i8;
    let _18: ();
    let mut _19: *mut ffi::rocksdb_options_t;
    let mut _20: bool;
    scope 1 {
        debug cb => _4;
        scope 2 {
            let _10: *mut ffi::rocksdb_compactionfilter_t;
            scope 3 {
                debug cf => _10;
            }
        }
    }

    bb0: {
        _20 = const false;
        _20 = const true;
        _8 = core::str::<impl str>::as_bytes(_2) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _7 = CString::new::<&[u8]>(move _8) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _6 = Result::<CString, NulError>::unwrap(move _7) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _20 = const false;
        _9 = move _3;
        _5 = CompactionFilterCallback::<F> { name: move _6, filter_fn: move _9 };
        _4 = Box::<CompactionFilterCallback<F>>::new(move _5) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _11 = move _4 as *mut libc::c_void (Transmute);
        _13 = compaction_filter::destructor_callback::<F> as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _12 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _13);
        _15 = compaction_filter::filter_callback::<F> as unsafe extern "C" fn(*mut libc::c_void, i32, *const i8, usize, *const i8, usize, *mut *mut i8, *mut usize, *mut u8) -> u8 (PointerCoercion(ReifyFnPointer));
        _14 = Option::<unsafe extern "C" fn(*mut c_void, i32, *const i8, usize, *const i8, usize, *mut *mut i8, *mut usize, *mut u8) -> u8>::Some(move _15);
        _17 = compaction_filter::name_callback::<F> as unsafe extern "C" fn(*mut libc::c_void) -> *const i8 (PointerCoercion(ReifyFnPointer));
        _16 = Option::<unsafe extern "C" fn(*mut c_void) -> *const i8>::Some(move _17);
        _10 = rocksdb_compactionfilter_create(move _11, move _12, move _14, move _16) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _19 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _18 = rocksdb_options_set_compaction_filter(move _19, _10) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        switchInt(_20) -> [0: bb7, otherwise: bb8];
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_comparator(_1: &mut Options, _2: &str, _3: for<'a, 'b> fn(&'a [u8], &'b [u8]) -> std::cmp::Ordering) -> () {
    debug self => _1;
    debug name => _2;
    debug compare_fn => _3;
    let mut _0: ();
    let _4: std::boxed::Box<comparator::ComparatorCallback>;
    let mut _5: comparator::ComparatorCallback;
    let mut _6: std::ffi::CString;
    let mut _7: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _8: &[u8];
    let mut _10: *mut libc::c_void;
    let mut _11: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _12: unsafe extern "C" fn(*mut libc::c_void);
    let mut _13: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize) -> i32>;
    let mut _14: unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize) -> i32;
    let mut _15: std::option::Option<unsafe extern "C" fn(*mut libc::c_void) -> *const i8>;
    let mut _16: unsafe extern "C" fn(*mut libc::c_void) -> *const i8;
    let _17: ();
    let mut _18: *mut ffi::rocksdb_options_t;
    scope 1 {
        debug cb => _4;
        scope 2 {
            let _9: *mut ffi::rocksdb_comparator_t;
            scope 3 {
                debug cmp => _9;
            }
        }
    }

    bb0: {
        _8 = core::str::<impl str>::as_bytes(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = CString::new::<&[u8]>(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = Result::<CString, NulError>::unwrap(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ComparatorCallback { name: move _6, f: _3 };
        _4 = Box::<ComparatorCallback>::new(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = move _4 as *mut libc::c_void (Transmute);
        _12 = comparator::destructor_callback as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _11 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _12);
        _14 = comparator::compare_callback as unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *const i8, usize) -> i32 (PointerCoercion(ReifyFnPointer));
        _13 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize, *const i8, usize) -> i32>::Some(move _14);
        _16 = comparator::name_callback as unsafe extern "C" fn(*mut libc::c_void) -> *const i8 (PointerCoercion(ReifyFnPointer));
        _15 = Option::<unsafe extern "C" fn(*mut c_void) -> *const i8>::Some(move _16);
        _9 = rocksdb_comparator_create(move _10, move _11, move _13, move _15) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _17 = rocksdb_options_set_comparator(move _18, _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_prefix_extractor(_1: &mut Options, _2: SliceTransform) -> () {
    debug self => _1;
    debug prefix_extractor => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: *mut ffi::rocksdb_slicetransform_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = (_2.0: *mut ffi::rocksdb_slicetransform_t);
        _0 = rocksdb_options_set_prefix_extractor(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::add_comparator(_1: &mut Options, _2: &str, _3: for<'a, 'b> fn(&'a [u8], &'b [u8]) -> std::cmp::Ordering) -> () {
    debug self => _1;
    debug name => _2;
    debug compare_fn => _3;
    let mut _0: ();
    let _4: ();

    bb0: {
        _4 = db_options::<impl Options>::set_comparator(_1, _2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::optimize_for_point_lookup(_1: &mut Options, _2: u64) -> () {
    debug self => _1;
    debug cache_size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_optimize_for_point_lookup(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_open_files(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug nfiles => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_open_files(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_use_fsync(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug useit => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: i32;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = _2 as i32 (IntToInt);
        _0 = rocksdb_options_set_use_fsync(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_bytes_per_sync(_1: &mut Options, _2: u64) -> () {
    debug self => _1;
    debug nbytes => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_bytes_per_sync(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_allow_concurrent_memtable_write(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug allow => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: u8;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = _2 as u8 (IntToInt);
        _0 = rocksdb_options_set_allow_concurrent_memtable_write(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_use_direct_reads(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug enabled => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_use_direct_reads(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_use_direct_io_for_flush_and_compaction(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug enabled => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_use_direct_io_for_flush_and_compaction(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_allow_os_buffer(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug is_allow => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: bool;
    let _5: ();
    let mut _6: bool;

    bb0: {
        _4 = Not(_2);
        _3 = db_options::<impl Options>::set_use_direct_reads(_1, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Not(_2);
        _5 = db_options::<impl Options>::set_use_direct_io_for_flush_and_compaction(_1, move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_table_cache_num_shard_bits(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug nbits => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_table_cache_numshardbits(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_min_write_buffer_number(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug nbuf => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_min_write_buffer_number_to_merge(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_write_buffer_number(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug nbuf => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_write_buffer_number(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_write_buffer_size(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_write_buffer_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_db_write_buffer_size(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_db_write_buffer_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_bytes_for_level_base(_1: &mut Options, _2: u64) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_bytes_for_level_base(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_bytes_for_level_multiplier(_1: &mut Options, _2: f64) -> () {
    debug self => _1;
    debug mul => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_bytes_for_level_multiplier(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_manifest_file_size(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_manifest_file_size(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_target_file_size_base(_1: &mut Options, _2: u64) -> () {
    debug self => _1;
    debug size => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_target_file_size_base(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_min_write_buffer_number_to_merge(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug to_merge => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_min_write_buffer_number_to_merge(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_level_zero_file_num_compaction_trigger(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_level0_file_num_compaction_trigger(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_level_zero_slowdown_writes_trigger(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_level0_slowdown_writes_trigger(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_level_zero_stop_writes_trigger(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_level0_stop_writes_trigger(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_compaction_style(_1: &mut Options, _2: DBCompactionStyle) -> () {
    debug self => _1;
    debug style => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: i32;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _6 = discriminant(_2);
        _7 = _6 as u8 (IntToInt);
        _8 = Le(_7, const 2_u8);
        assume(move _8);
        _5 = move _6 as i32 (IntToInt);
        _3 = rocksdb_options_set_compaction_style(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_background_compactions(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_background_compactions(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_max_background_flushes(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_max_background_flushes(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_disable_auto_compactions(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug disable => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: i32;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = _2 as i32 (IntToInt);
        _0 = rocksdb_options_set_disable_auto_compactions(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_memtable_factory(_1: &mut Options, _2: MemtableFactory) -> () {
    debug self => _1;
    debug factory => _2;
    let mut _0: ();
    let mut _3: isize;
    let _4: ();
    let mut _5: *mut ffi::rocksdb_options_t;
    let _6: usize;
    let _7: i32;
    let _8: i32;
    let _9: ();
    let mut _10: *mut ffi::rocksdb_options_t;
    let _11: usize;
    let _12: ();
    let mut _13: *mut ffi::rocksdb_options_t;
    scope 1 {
    }
    scope 2 {
        debug bucket_count => _6;
        debug height => _7;
        debug branching_factor => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug bucket_count => _11;
        scope 5 {
        }
    }

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _11 = ((_2 as HashLinkList).0: usize);
        _13 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _12 = rocksdb_options_set_hash_link_list_rep(move _13, _11) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = rocksdb_options_set_memtable_vector_rep(move _5) -> [return: bb5, unwind continue];
    }

    bb4: {
        _6 = ((_2 as HashSkipList).0: usize);
        _7 = ((_2 as HashSkipList).1: i32);
        _8 = ((_2 as HashSkipList).2: i32);
        _10 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _9 = rocksdb_options_set_hash_skip_list_rep(move _10, _6, _7, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_block_based_table_factory(_1: &mut Options, _2: &BlockBasedOptions) -> () {
    debug self => _1;
    debug factory => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: *mut ffi::rocksdb_block_based_table_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = ((*_2).0: *mut ffi::rocksdb_block_based_table_options_t);
        _3 = rocksdb_options_set_block_based_table_factory(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_plain_table_factory(_1: &mut Options, _2: &PlainTableFactoryOptions) -> () {
    debug self => _1;
    debug options => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u32;
    let mut _6: i32;
    let mut _7: f64;
    let mut _8: usize;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = ((*_2).0: u32);
        _6 = ((*_2).1: i32);
        _7 = ((*_2).2: f64);
        _8 = ((*_2).3: usize);
        _3 = rocksdb_options_set_plain_table_factory(move _4, move _5, move _6, move _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_report_bg_io_stats(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug enable => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: i32;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as i32 (IntToInt);
        _3 = rocksdb_options_set_report_bg_io_stats(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_wal_recovery_mode(_1: &mut Options, _2: DBRecoveryMode) -> () {
    debug self => _1;
    debug mode => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: i32;
    let mut _6: isize;
    let mut _7: u8;
    let mut _8: bool;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _6 = discriminant(_2);
        _7 = _6 as u8 (IntToInt);
        _8 = Le(_7, const 3_u8);
        assume(move _8);
        _5 = move _6 as i32 (IntToInt);
        _3 = rocksdb_options_set_wal_recovery_mode(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::enable_statistics(_1: &mut Options) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _2 = rocksdb_options_enable_statistics(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::get_statistics(_1: &Options) -> Option<String> {
    debug self => _1;
    let mut _0: std::option::Option<std::string::String>;
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: bool;
    let _6: &str;
    let mut _7: std::result::Result<&str, std::str::Utf8Error>;
    let _8: &std::ffi::CStr;
    let mut _9: *const i8;
    let _10: ();
    let mut _11: *mut libc::c_void;
    let mut _12: std::string::String;
    scope 1 {
        let _2: *mut i8;
        scope 2 {
            debug value => _2;
            let _5: std::string::String;
            scope 3 {
                debug s => _5;
            }
        }
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _2 = rocksdb_options_statistics_get_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = std::ptr::mut_ptr::<impl *mut i8>::is_null(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = Option::<String>::None;
        goto -> bb10;
    }

    bb4: {
        _9 = _2 as *const i8 (PointerCoercion(MutToConstPointer));
        _8 = CStr::from_ptr::<'_>(move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = CStr::to_str(_8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = Result::<&str, Utf8Error>::unwrap(move _7) -> [return: bb7, unwind continue];
    }

    bb7: {
        _5 = <str as ToOwned>::to_owned(_6) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = _2 as *mut libc::c_void (PtrToPtr);
        _10 = free(move _11) -> [return: bb9, unwind: bb11];
    }

    bb9: {
        _12 = move _5;
        _0 = Option::<String>::Some(move _12);
        goto -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        drop(_5) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        resume;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_stats_dump_period_sec(_1: &mut Options, _2: u32) -> () {
    debug self => _1;
    debug period => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_stats_dump_period_sec(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_advise_random_on_open(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug advise => _2;
    let mut _0: ();
    let mut _3: *mut ffi::rocksdb_options_t;
    let mut _4: u8;
    scope 1 {
    }

    bb0: {
        _3 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _4 = _2 as u8 (IntToInt);
        _0 = rocksdb_options_set_advise_random_on_open(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_num_levels(_1: &mut Options, _2: i32) -> () {
    debug self => _1;
    debug n => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_num_levels(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_memtable_prefix_bloom_ratio(_1: &mut Options, _2: f64) -> () {
    debug self => _1;
    debug ratio => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_memtable_prefix_bloom_size_ratio(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_wal_dir(_1: &mut Options, _2: P) -> () {
    debug self => _1;
    debug path => _2;
    let mut _0: ();
    let _3: std::ffi::CString;
    let mut _4: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _5: &[u8];
    let _6: &str;
    let mut _7: &std::borrow::Cow<'_, str>;
    let _8: std::borrow::Cow<'_, str>;
    let _9: &std::path::Path;
    let mut _10: &P;
    let _11: ();
    let mut _12: *mut ffi::rocksdb_options_t;
    let mut _13: *const i8;
    let _14: &std::ffi::CStr;
    let mut _15: &std::ffi::CString;
    scope 1 {
        debug p => _3;
        scope 2 {
        }
    }

    bb0: {
        _10 = &_2;
        _9 = <P as AsRef<Path>>::as_ref(move _10) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _8 = Path::to_string_lossy(_9) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _7 = &_8;
        _6 = <Cow<'_, str> as Deref>::deref(move _7) -> [return: bb3, unwind: bb14];
    }

    bb3: {
        _5 = core::str::<impl str>::as_bytes(_6) -> [return: bb4, unwind: bb14];
    }

    bb4: {
        _4 = CString::new::<&[u8]>(move _5) -> [return: bb5, unwind: bb14];
    }

    bb5: {
        _3 = Result::<CString, NulError>::unwrap(move _4) -> [return: bb6, unwind: bb14];
    }

    bb6: {
        drop(_8) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _12 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _15 = &_3;
        _14 = <CString as Deref>::deref(move _15) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _13 = CStr::as_ptr(_14) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _11 = rocksdb_options_set_wal_dir(move _12, move _13) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_3) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        drop(_2) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        drop(_8) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_skip_stats_update_on_db_open(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug skip => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_skip_stats_update_on_db_open(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_keep_log_file_num(_1: &mut Options, _2: usize) -> () {
    debug self => _1;
    debug nfiles => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _3 = rocksdb_options_set_keep_log_file_num(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_allow_mmap_writes(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug is_enabled => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_allow_mmap_writes(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:140:1: 140:13>::set_allow_mmap_reads(_1: &mut Options, _2: bool) -> () {
    debug self => _1;
    debug is_enabled => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_options_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_options_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_options_set_allow_mmap_reads(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1217:1: 1217:25>::default() -> Options {
    let mut _0: Options;
    let mut _2: bool;
    let _3: !;
    scope 1 {
        let _1: *mut ffi::rocksdb_options_t;
        scope 2 {
            debug opts => _1;
        }
    }

    bb0: {
        _1 = rocksdb_options_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_options_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = begin_panic::<&str>(const "Could not create RocksDB options") -> unwind continue;
    }

    bb4: {
        _0 = Options { inner: _1 };
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1229:1: 1229:18>::new() -> FlushOptions {
    let mut _0: FlushOptions;

    bb0: {
        _0 = <FlushOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1229:1: 1229:18>::set_wait(_1: &mut FlushOptions, _2: bool) -> () {
    debug self => _1;
    debug wait => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_flushoptions_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_flushoptions_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_flushoptions_set_wait(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1253:1: 1253:30>::default() -> FlushOptions {
    let mut _0: FlushOptions;
    let _1: *mut ffi::rocksdb_flushoptions_t;
    let mut _2: bool;
    let _3: !;
    scope 1 {
        debug flush_opts => _1;
    }
    scope 2 {
    }

    bb0: {
        _1 = rocksdb_flushoptions_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_flushoptions_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = begin_panic::<&str>(const "Could not create RocksDB flush options") -> unwind continue;
    }

    bb4: {
        _0 = FlushOptions { inner: _1 };
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1263:1: 1263:18>::new() -> WriteOptions {
    let mut _0: WriteOptions;

    bb0: {
        _0 = <WriteOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1263:1: 1263:18>::set_sync(_1: &mut WriteOptions, _2: bool) -> () {
    debug self => _1;
    debug sync => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_writeoptions_t;
    let mut _5: u8;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_writeoptions_t);
        _5 = _2 as u8 (IntToInt);
        _3 = rocksdb_writeoptions_set_sync(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1263:1: 1263:18>::disable_wal(_1: &mut WriteOptions, _2: bool) -> () {
    debug self => _1;
    debug disable => _2;
    let mut _0: ();
    let _3: ();
    let mut _4: *mut ffi::rocksdb_writeoptions_t;
    let mut _5: i32;
    scope 1 {
    }

    bb0: {
        _4 = ((*_1).0: *mut ffi::rocksdb_writeoptions_t);
        _5 = _2 as i32 (IntToInt);
        _3 = rocksdb_writeoptions_disable_WAL(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db_options::<impl at src/db_options.rs:1281:1: 1281:30>::default() -> WriteOptions {
    let mut _0: WriteOptions;
    let _1: *mut ffi::rocksdb_writeoptions_t;
    let mut _2: bool;
    let _3: !;
    scope 1 {
        debug write_opts => _1;
    }
    scope 2 {
    }

    bb0: {
        _1 = rocksdb_writeoptions_create() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::ptr::mut_ptr::<impl *mut rocksdb_writeoptions_t>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = begin_panic::<&str>(const "Could not create RocksDB write options") -> unwind continue;
    }

    bb4: {
        _0 = WriteOptions { inner: _1 };
        return;
    }
}

fn merge_operator::destructor_callback(_1: *mut c_void) -> () {
    debug raw_cb => _1;
    let mut _0: ();
    let mut _2: std::boxed::Box<merge_operator::MergeOperatorCallback>;
    scope 1 {
    }

    bb0: {
        _2 = _1 as std::boxed::Box<merge_operator::MergeOperatorCallback> (Transmute);
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn merge_operator::name_callback(_1: *mut c_void) -> *const i8 {
    debug raw_cb => _1;
    let mut _0: *const i8;
    let _2: &mut merge_operator::MergeOperatorCallback;
    let mut _3: *mut merge_operator::MergeOperatorCallback;
    let _4: &std::ffi::CStr;
    let mut _5: &std::ffi::CString;
    scope 1 {
        debug cb => _2;
    }

    bb0: {
        _3 = _1 as *mut merge_operator::MergeOperatorCallback (PtrToPtr);
        _2 = &mut (*_3);
        _5 = &((*_2).0: std::ffi::CString);
        _4 = <CString as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn full_merge_callback(_1: *mut c_void, _2: *const i8, _3: usize, _4: *const i8, _5: usize, _6: *const *const i8, _7: *const usize, _8: i32, _9: *mut u8, _10: *mut usize) -> *mut i8 {
    debug raw_cb => _1;
    debug raw_key => _2;
    debug key_len => _3;
    debug existing_value => _4;
    debug existing_value_len => _5;
    debug operands_list => _6;
    debug operands_list_len => _7;
    debug num_operands => _8;
    debug success => _9;
    debug new_value_length => _10;
    let mut _0: *mut i8;
    let _11: &mut merge_operator::MergeOperatorCallback;
    let mut _12: *mut merge_operator::MergeOperatorCallback;
    let mut _14: merge_operator::MergeOperands;
    let mut _16: *const u8;
    let mut _18: bool;
    let mut _19: &[u8];
    let mut _20: *const u8;
    let mut _21: std::option::Option<std::vec::Vec<u8>>;
    let mut _22: for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>;
    let mut _23: std::option::Option<&[u8]>;
    let mut _24: isize;
    let _26: ();
    let mut _27: &mut std::vec::Vec<u8>;
    let mut _29: usize;
    let mut _30: &std::vec::Vec<u8>;
    let mut _31: bool;
    let mut _32: !;
    let mut _33: usize;
    let mut _34: &std::vec::Vec<u8>;
    let mut _35: u8;
    let _36: ();
    let mut _37: *const libc::c_void;
    let mut _38: *mut libc::c_void;
    let mut _39: *const u8;
    let mut _40: &std::vec::Vec<u8>;
    let mut _41: *mut libc::c_void;
    let mut _42: &mut libc::c_void;
    let mut _43: usize;
    let mut _44: &std::vec::Vec<u8>;
    let mut _45: u8;
    let mut _46: *mut i8;
    let mut _47: bool;
    let mut _48: isize;
    let mut _49: isize;
    scope 1 {
        debug cb => _11;
        let _13: &mut merge_operator::MergeOperands;
        scope 2 {
            debug operands => _13;
            let _15: &[u8];
            scope 3 {
                debug key => _15;
                let _17: std::option::Option<&[u8]>;
                scope 4 {
                    debug oldval => _17;
                    scope 5 {
                        debug result => _25;
                        let mut _25: std::vec::Vec<u8>;
                        let _28: *mut libc::c_void;
                        scope 6 {
                            debug buf => _28;
                            let mut _50: *const ();
                            let mut _51: usize;
                            let mut _52: usize;
                            let mut _53: usize;
                            let mut _54: usize;
                            let mut _55: bool;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _47 = const false;
        _12 = _1 as *mut merge_operator::MergeOperatorCallback (PtrToPtr);
        _11 = &mut (*_12);
        _14 = MergeOperands::new(_6, _7, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _13 = &mut _14;
        _16 = _2 as *const u8 (PtrToPtr);
        _15 = std::slice::from_raw_parts::<'_, u8>(move _16, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _18 = std::ptr::const_ptr::<impl *const i8>::is_null(_4) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _18) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _17 = Option::<&[u8]>::None;
        goto -> bb7;
    }

    bb5: {
        _20 = _4 as *const u8 (PtrToPtr);
        _19 = std::slice::from_raw_parts::<'_, u8>(move _20, _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _17 = Option::<&[u8]>::Some(move _19);
        goto -> bb7;
    }

    bb7: {
        _22 = ((*_11).1: for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>);
        _23 = _17;
        _47 = const true;
        _21 = move _22(_15, move _23, _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _24 = discriminant(_21);
        switchInt(move _24) -> [1: bb9, otherwise: bb20];
    }

    bb9: {
        _47 = const false;
        _25 = move ((_21 as Some).0: std::vec::Vec<u8>);
        _27 = &mut _25;
        _26 = Vec::<u8>::shrink_to_fit(move _27) -> [return: bb10, unwind: bb23];
    }

    bb10: {
        _30 = &_25;
        _29 = Vec::<u8>::len(move _30) -> [return: bb11, unwind: bb23];
    }

    bb11: {
        _28 = malloc(move _29) -> [return: bb12, unwind: bb23];
    }

    bb12: {
        _31 = std::ptr::mut_ptr::<impl *mut c_void>::is_null(_28) -> [return: bb13, unwind: bb23];
    }

    bb13: {
        switchInt(move _31) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _32 = core::panicking::panic(const "assertion failed: !buf.is_null()") -> bb23;
    }

    bb15: {
        _34 = &_25;
        _33 = Vec::<u8>::len(move _34) -> [return: bb16, unwind: bb23];
    }

    bb16: {
        _50 = _10 as *const () (PtrToPtr);
        _51 = _50 as usize (Transmute);
        _52 = AlignOf(usize);
        _53 = Sub(_52, const 1_usize);
        _54 = BitAnd(_51, _53);
        _55 = Eq(_54, const 0_usize);
        assert(_55, "misaligned pointer dereference: address must be a multiple of {} but is {}", _52, _51) -> [success: bb31, unwind unreachable];
    }

    bb17: {
        _38 = move _39 as *mut libc::c_void (PtrToPtr);
        _37 = move _38 as *const libc::c_void (PointerCoercion(MutToConstPointer));
        _42 = &mut (*_28);
        _41 = &raw mut (*_42);
        _44 = &_25;
        _43 = Vec::<u8>::len(move _44) -> [return: bb18, unwind: bb23];
    }

    bb18: {
        _36 = std::intrinsics::copy::<c_void>(move _37, move _41, move _43) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        _0 = _28 as *mut i8 (PtrToPtr);
        drop(_25) -> [return: bb22, unwind: bb30];
    }

    bb20: {
        _45 = const 0_u8;
        (*_9) = move _45;
        _46 = null_mut::<i8>() -> [return: bb21, unwind: bb30];
    }

    bb21: {
        _0 = move _46;
        goto -> bb22;
    }

    bb22: {
        _48 = discriminant(_21);
        switchInt(move _48) -> [1: bb26, otherwise: bb25];
    }

    bb23 (cleanup): {
        drop(_25) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        resume;
    }

    bb25: {
        _47 = const false;
        return;
    }

    bb26: {
        switchInt(_47) -> [0: bb25, otherwise: bb27];
    }

    bb27: {
        drop(((_21 as Some).0: std::vec::Vec<u8>)) -> [return: bb25, unwind continue];
    }

    bb28 (cleanup): {
        switchInt(_47) -> [0: bb24, otherwise: bb29];
    }

    bb29 (cleanup): {
        drop(((_21 as Some).0: std::vec::Vec<u8>)) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        _49 = discriminant(_21);
        switchInt(move _49) -> [1: bb28, otherwise: bb24];
    }

    bb31: {
        (*_10) = move _33;
        _35 = const 1_u8;
        (*_9) = move _35;
        _40 = &_25;
        _39 = Vec::<u8>::as_ptr(move _40) -> [return: bb17, unwind: bb23];
    }
}

fn partial_merge_callback(_1: *mut c_void, _2: *const i8, _3: usize, _4: *const *const i8, _5: *const usize, _6: i32, _7: *mut u8, _8: *mut usize) -> *mut i8 {
    debug raw_cb => _1;
    debug raw_key => _2;
    debug key_len => _3;
    debug operands_list => _4;
    debug operands_list_len => _5;
    debug num_operands => _6;
    debug success => _7;
    debug new_value_length => _8;
    let mut _0: *mut i8;
    let _9: &mut merge_operator::MergeOperatorCallback;
    let mut _10: *mut merge_operator::MergeOperatorCallback;
    let mut _12: merge_operator::MergeOperands;
    let mut _14: *const u8;
    let mut _15: std::option::Option<std::vec::Vec<u8>>;
    let mut _16: for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>;
    let mut _17: std::option::Option<&[u8]>;
    let mut _18: isize;
    let _20: ();
    let mut _21: &mut std::vec::Vec<u8>;
    let mut _23: usize;
    let mut _24: &std::vec::Vec<u8>;
    let mut _25: bool;
    let mut _26: !;
    let mut _27: usize;
    let mut _28: &std::vec::Vec<u8>;
    let mut _29: u8;
    let _30: ();
    let mut _31: *const libc::c_void;
    let mut _32: *mut libc::c_void;
    let mut _33: *const u8;
    let mut _34: &std::vec::Vec<u8>;
    let mut _35: *mut libc::c_void;
    let mut _36: &mut libc::c_void;
    let mut _37: usize;
    let mut _38: &std::vec::Vec<u8>;
    let mut _39: u8;
    let mut _40: bool;
    let mut _41: isize;
    let mut _42: isize;
    scope 1 {
        debug cb => _9;
        let _11: &mut merge_operator::MergeOperands;
        scope 2 {
            debug operands => _11;
            let _13: &[u8];
            scope 3 {
                debug key => _13;
                scope 4 {
                    debug result => _19;
                    let mut _19: std::vec::Vec<u8>;
                    let _22: *mut libc::c_void;
                    scope 5 {
                        debug buf => _22;
                        let mut _43: *const ();
                        let mut _44: usize;
                        let mut _45: usize;
                        let mut _46: usize;
                        let mut _47: usize;
                        let mut _48: bool;
                    }
                }
            }
        }
    }

    bb0: {
        _40 = const false;
        _10 = _1 as *mut merge_operator::MergeOperatorCallback (PtrToPtr);
        _9 = &mut (*_10);
        _12 = MergeOperands::new(_4, _5, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = &mut _12;
        _14 = _2 as *const u8 (PtrToPtr);
        _13 = std::slice::from_raw_parts::<'_, u8>(move _14, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _16 = ((*_9).2: for<'a, 'b, 'c> fn(&'a [u8], std::option::Option<&'b [u8]>, &'c mut merge_operator::MergeOperands) -> std::option::Option<std::vec::Vec<u8>>);
        _17 = Option::<&[u8]>::None;
        _40 = const true;
        _15 = move _16(_13, move _17, _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _18 = discriminant(_15);
        switchInt(move _18) -> [1: bb4, otherwise: bb15];
    }

    bb4: {
        _40 = const false;
        _19 = move ((_15 as Some).0: std::vec::Vec<u8>);
        _21 = &mut _19;
        _20 = Vec::<u8>::shrink_to_fit(move _21) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _24 = &_19;
        _23 = Vec::<u8>::len(move _24) -> [return: bb6, unwind: bb17];
    }

    bb6: {
        _22 = malloc(move _23) -> [return: bb7, unwind: bb17];
    }

    bb7: {
        _25 = std::ptr::mut_ptr::<impl *mut c_void>::is_null(_22) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        switchInt(move _25) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _26 = core::panicking::panic(const "assertion failed: !buf.is_null()") -> bb17;
    }

    bb10: {
        _28 = &_19;
        _27 = Vec::<u8>::len(move _28) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _43 = _8 as *const () (PtrToPtr);
        _44 = _43 as usize (Transmute);
        _45 = AlignOf(usize);
        _46 = Sub(_45, const 1_usize);
        _47 = BitAnd(_44, _46);
        _48 = Eq(_47, const 0_usize);
        assert(_48, "misaligned pointer dereference: address must be a multiple of {} but is {}", _45, _44) -> [success: bb25, unwind unreachable];
    }

    bb12: {
        _32 = move _33 as *mut libc::c_void (PtrToPtr);
        _31 = move _32 as *const libc::c_void (PointerCoercion(MutToConstPointer));
        _36 = &mut (*_22);
        _35 = &raw mut (*_36);
        _38 = &_19;
        _37 = Vec::<u8>::len(move _38) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _30 = std::intrinsics::copy::<c_void>(move _31, move _35, move _37) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        _0 = _22 as *mut i8 (PtrToPtr);
        drop(_19) -> [return: bb16, unwind: bb24];
    }

    bb15: {
        _39 = const 0_u8;
        (*_7) = move _39;
        _0 = null_mut::<i8>() -> [return: bb26, unwind: bb24];
    }

    bb16: {
        _41 = discriminant(_15);
        switchInt(move _41) -> [1: bb20, otherwise: bb19];
    }

    bb17 (cleanup): {
        drop(_19) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        _40 = const false;
        return;
    }

    bb20: {
        switchInt(_40) -> [0: bb19, otherwise: bb21];
    }

    bb21: {
        drop(((_15 as Some).0: std::vec::Vec<u8>)) -> [return: bb19, unwind continue];
    }

    bb22 (cleanup): {
        switchInt(_40) -> [0: bb18, otherwise: bb23];
    }

    bb23 (cleanup): {
        drop(((_15 as Some).0: std::vec::Vec<u8>)) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        _42 = discriminant(_15);
        switchInt(move _42) -> [1: bb22, otherwise: bb18];
    }

    bb25: {
        (*_8) = move _27;
        _29 = const 1_u8;
        (*_7) = move _29;
        _34 = &_19;
        _33 = Vec::<u8>::as_ptr(move _34) -> [return: bb12, unwind: bb17];
    }

    bb26: {
        goto -> bb16;
    }
}

fn merge_operator::<impl at src/merge_operator.rs:155:1: 155:19>::new(_1: *const *const i8, _2: *const usize, _3: i32) -> MergeOperands {
    debug operands_list => _1;
    debug operands_list_len => _2;
    debug num_operands => _3;
    let mut _0: merge_operator::MergeOperands;
    let mut _4: bool;
    let mut _5: !;
    let mut _6: usize;

    bb0: {
        _4 = Ge(_3, const 0_i32);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = _3 as usize (IntToInt);
        _0 = MergeOperands { operands_list: _1, operands_list_len: _2, num_operands: move _6, cursor: const 0_usize };
        return;
    }

    bb2: {
        _5 = core::panicking::panic(const "assertion failed: num_operands >= 0") -> unwind continue;
    }
}

fn merge_operator::<impl at src/merge_operator.rs:171:1: 171:44>::next(_1: &mut &mut MergeOperands) -> Option<&[u8]> {
    debug self => _1;
    let mut _0: std::option::Option<&[u8]>;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: usize;
    let mut _6: *const *const i8;
    let mut _8: *const usize;
    let mut _12: usize;
    let mut _13: usize;
    let mut _14: usize;
    let mut _15: (usize, bool);
    let mut _16: (usize, bool);
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: (usize, bool);
    let mut _22: (usize, bool);
    let mut _23: (usize, bool);
    let mut _24: &[u8];
    let mut _25: *const u8;
    let mut _26: *const *const u8;
    let mut _27: &mut merge_operator::MergeOperands;
    let mut _28: &mut merge_operator::MergeOperands;
    let mut _29: &mut merge_operator::MergeOperands;
    let mut _30: &mut merge_operator::MergeOperands;
    let mut _31: &mut merge_operator::MergeOperands;
    let mut _32: &mut merge_operator::MergeOperands;
    let mut _33: &mut merge_operator::MergeOperands;
    let mut _34: &mut merge_operator::MergeOperands;
    let mut _35: &mut merge_operator::MergeOperands;
    scope 1 {
        let _5: usize;
        scope 2 {
            debug base => _5;
            let _7: usize;
            scope 3 {
                debug base_len => _7;
                let _9: usize;
                scope 4 {
                    debug spacing => _9;
                    let _10: usize;
                    scope 5 {
                        debug spacing_len => _10;
                        let _11: *const usize;
                        scope 6 {
                            debug len_ptr => _11;
                            let _17: usize;
                            let mut _42: *const ();
                            let mut _43: usize;
                            let mut _44: usize;
                            let mut _45: usize;
                            let mut _46: usize;
                            let mut _47: bool;
                            scope 7 {
                                debug len => _17;
                                let _18: usize;
                                scope 8 {
                                    debug ptr => _18;
                                    let mut _36: *const ();
                                    let mut _37: usize;
                                    let mut _38: usize;
                                    let mut _39: usize;
                                    let mut _40: usize;
                                    let mut _41: bool;
                                }
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _27 = deref_copy (*_1);
        _3 = ((*_27).3: usize);
        _28 = deref_copy (*_1);
        _4 = ((*_28).2: usize);
        _2 = Eq(move _3, move _4);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = Option::<&[u8]>::None;
        goto -> bb11;
    }

    bb2: {
        _29 = deref_copy (*_1);
        _6 = ((*_29).0: *const *const i8);
        _5 = move _6 as usize (PointerExposeAddress);
        _30 = deref_copy (*_1);
        _8 = ((*_30).1: *const usize);
        _7 = move _8 as usize (PointerExposeAddress);
        _9 = std::mem::size_of::<*const *const u8>() -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = std::mem::size_of::<*const usize>() -> [return: bb4, unwind continue];
    }

    bb4: {
        _31 = deref_copy (*_1);
        _14 = ((*_31).3: usize);
        _15 = CheckedMul(_10, _14);
        assert(!move (_15.1: bool), "attempt to compute `{} * {}`, which would overflow", _10, move _14) -> [success: bb5, unwind continue];
    }

    bb5: {
        _13 = move (_15.0: usize);
        _16 = CheckedAdd(_7, _13);
        assert(!move (_16.1: bool), "attempt to compute `{} + {}`, which would overflow", _7, move _13) -> [success: bb6, unwind continue];
    }

    bb6: {
        _12 = move (_16.0: usize);
        _11 = move _12 as *const usize (PointerFromExposedAddress);
        _42 = _11 as *const () (PtrToPtr);
        _43 = _42 as usize (Transmute);
        _44 = AlignOf(usize);
        _45 = Sub(_44, const 1_usize);
        _46 = BitAnd(_43, _45);
        _47 = Eq(_46, const 0_usize);
        assert(_47, "misaligned pointer dereference: address must be a multiple of {} but is {}", _44, _43) -> [success: bb13, unwind unreachable];
    }

    bb7: {
        _19 = move (_21.0: usize);
        _22 = CheckedAdd(_5, _19);
        assert(!move (_22.1: bool), "attempt to compute `{} + {}`, which would overflow", _5, move _19) -> [success: bb8, unwind continue];
    }

    bb8: {
        _18 = move (_22.0: usize);
        _33 = deref_copy (*_1);
        _23 = CheckedAdd(((*_33).3: usize), const 1_usize);
        _34 = deref_copy (*_1);
        assert(!move (_23.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_34).3: usize), const 1_usize) -> [success: bb9, unwind continue];
    }

    bb9: {
        _35 = deref_copy (*_1);
        ((*_35).3: usize) = move (_23.0: usize);
        _26 = _18 as *const *const u8 (PointerFromExposedAddress);
        _36 = _26 as *const () (PtrToPtr);
        _37 = _36 as usize (Transmute);
        _38 = AlignOf(*const u8);
        _39 = Sub(_38, const 1_usize);
        _40 = BitAnd(_37, _39);
        _41 = Eq(_40, const 0_usize);
        assert(_41, "misaligned pointer dereference: address must be a multiple of {} but is {}", _38, _37) -> [success: bb12, unwind unreachable];
    }

    bb10: {
        _0 = Option::<&[u8]>::Some(move _24);
        goto -> bb11;
    }

    bb11: {
        return;
    }

    bb12: {
        _25 = (*_26);
        _24 = std::slice::from_raw_parts::<'_, u8>(move _25, _17) -> [return: bb10, unwind continue];
    }

    bb13: {
        _17 = (*_11);
        _32 = deref_copy (*_1);
        _20 = ((*_32).3: usize);
        _21 = CheckedMul(_9, _20);
        assert(!move (_21.1: bool), "attempt to compute `{} * {}`, which would overflow", _9, move _20) -> [success: bb7, unwind continue];
    }
}

fn merge_operator::<impl at src/merge_operator.rs:171:1: 171:44>::size_hint(_1: &&mut MergeOperands) -> (usize, Option<usize>) {
    debug self => _1;
    let mut _0: (usize, std::option::Option<usize>);
    let _2: usize;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: (usize, bool);
    let mut _6: std::option::Option<usize>;
    let mut _7: &mut merge_operator::MergeOperands;
    let mut _8: &mut merge_operator::MergeOperands;
    scope 1 {
        debug remaining => _2;
    }

    bb0: {
        _7 = deref_copy (*_1);
        _3 = ((*_7).2: usize);
        _8 = deref_copy (*_1);
        _4 = ((*_8).3: usize);
        _5 = CheckedSub(_3, _4);
        assert(!move (_5.1: bool), "attempt to compute `{} - {}`, which would overflow", move _3, move _4) -> [success: bb1, unwind continue];
    }

    bb1: {
        _2 = move (_5.0: usize);
        _6 = Option::<usize>::Some(_2);
        _0 = (_2, move _6);
        return;
    }
}

fn slice_transform::<impl at src/slice_transform.rs:36:1: 36:20>::create(_1: &str, _2: fn(&[u8]) -> &[u8], _3: Option<for<'a> fn(&'a [u8]) -> bool>) -> SliceTransform {
    debug name => _1;
    debug transform_fn => _2;
    debug in_domain_fn => _3;
    let mut _0: slice_transform::SliceTransform;
    let _4: *mut slice_transform::TransformCallback<'_>;
    let mut _5: std::boxed::Box<slice_transform::TransformCallback<'_>>;
    let mut _6: slice_transform::TransformCallback<'_>;
    let mut _7: std::ffi::CString;
    let mut _8: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _9: &[u8];
    let mut _10: std::option::Option<for<'a> fn(&'a [u8]) -> bool>;
    let mut _12: *mut libc::c_void;
    let mut _13: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _14: unsafe extern "C" fn(*mut libc::c_void);
    let mut _15: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *mut usize) -> *mut i8>;
    let mut _16: unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *mut usize) -> *mut i8;
    let mut _17: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize) -> u8>;
    let mut _18: bool;
    let mut _19: &std::option::Option<for<'a> fn(&'a [u8]) -> bool>;
    let mut _20: unsafe extern "C" fn(*mut libc::c_void, *const i8, usize) -> u8;
    let mut _21: std::option::Option<unsafe extern "C" fn(*mut libc::c_void, *const i8, usize) -> u8>;
    let mut _22: std::option::Option<unsafe extern "C" fn(*mut libc::c_void) -> *const i8>;
    let mut _23: unsafe extern "C" fn(*mut libc::c_void) -> *const i8;
    scope 1 {
        debug cb => _4;
        let _11: *mut ffi::rocksdb_slicetransform_t;
        scope 2 {
            debug st => _11;
        }
        scope 3 {
        }
    }

    bb0: {
        _9 = core::str::<impl str>::as_bytes(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = CString::new::<&[u8]>(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = Result::<CString, NulError>::unwrap(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = _3;
        _6 = TransformCallback::<'_> { name: move _7, transform_fn: _2, in_domain_fn: move _10 };
        _5 = Box::<TransformCallback<'_>>::new(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = Box::<TransformCallback<'_>>::into_raw(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = _4 as *mut libc::c_void (PtrToPtr);
        _14 = slice_transform::slice_transform_destructor_callback as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _13 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _14);
        _16 = slice_transform::transform_callback as unsafe extern "C" fn(*mut libc::c_void, *const i8, usize, *mut usize) -> *mut i8 (PointerCoercion(ReifyFnPointer));
        _15 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize, *mut usize) -> *mut i8>::Some(move _16);
        _19 = &_3;
        _18 = Option::<for<'a> fn(&'a [u8]) -> bool>::is_some(move _19) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _18) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _20 = slice_transform::in_domain_callback as unsafe extern "C" fn(*mut libc::c_void, *const i8, usize) -> u8 (PointerCoercion(ReifyFnPointer));
        _17 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize) -> u8>::Some(move _20);
        goto -> bb9;
    }

    bb8: {
        _17 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize) -> u8>::None;
        goto -> bb9;
    }

    bb9: {
        _21 = Option::<unsafe extern "C" fn(*mut c_void, *const i8, usize) -> u8>::None;
        _23 = slice_transform::slice_transform_name_callback as unsafe extern "C" fn(*mut libc::c_void) -> *const i8 (PointerCoercion(ReifyFnPointer));
        _22 = Option::<unsafe extern "C" fn(*mut c_void) -> *const i8>::Some(move _23);
        _11 = rocksdb_slicetransform_create(move _12, move _13, move _15, move _17, move _21, move _22) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = SliceTransform { inner: _11 };
        return;
    }
}

fn slice_transform::<impl at src/slice_transform.rs:36:1: 36:20>::create_fixed_prefix(_1: usize) -> SliceTransform {
    debug len => _1;
    let mut _0: slice_transform::SliceTransform;
    let mut _2: *mut ffi::rocksdb_slicetransform_t;
    scope 1 {
    }

    bb0: {
        _2 = rocksdb_slicetransform_create_fixed_prefix(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = SliceTransform { inner: move _2 };
        return;
    }
}

fn slice_transform::<impl at src/slice_transform.rs:36:1: 36:20>::create_noop() -> SliceTransform {
    let mut _0: slice_transform::SliceTransform;
    let mut _1: *mut ffi::rocksdb_slicetransform_t;
    scope 1 {
    }

    bb0: {
        _1 = rocksdb_slicetransform_create_noop() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = SliceTransform { inner: move _1 };
        return;
    }
}

fn slice_transform_destructor_callback(_1: *mut c_void) -> () {
    debug raw_cb => _1;
    let mut _0: ();
    let _2: std::boxed::Box<slice_transform::TransformCallback<'_>>;
    let mut _3: *mut slice_transform::TransformCallback<'_>;

    bb0: {
        _3 = _1 as *mut slice_transform::TransformCallback<'_> (PtrToPtr);
        _2 = Box::<TransformCallback<'_>>::from_raw(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn slice_transform_name_callback(_1: *mut c_void) -> *const i8 {
    debug raw_cb => _1;
    let mut _0: *const i8;
    let _2: &mut slice_transform::TransformCallback<'_>;
    let mut _3: *mut slice_transform::TransformCallback<'_>;
    let _4: &std::ffi::CStr;
    let mut _5: &std::ffi::CString;
    scope 1 {
        debug cb => _2;
    }

    bb0: {
        _3 = _1 as *mut slice_transform::TransformCallback<'_> (PtrToPtr);
        _2 = &mut (*_3);
        _5 = &((*_2).0: std::ffi::CString);
        _4 = <CString as Deref>::deref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = CStr::as_ptr(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn transform_callback(_1: *mut c_void, _2: *const i8, _3: usize, _4: *mut usize) -> *mut i8 {
    debug raw_cb => _1;
    debug raw_key => _2;
    debug key_len => _3;
    debug dst_length => _4;
    let mut _0: *mut i8;
    let _5: &mut slice_transform::TransformCallback<'_>;
    let mut _6: *mut slice_transform::TransformCallback<'_>;
    let mut _8: *const u8;
    let mut _10: fn(&[u8]) -> &[u8];
    let mut _11: usize;
    let mut _12: *const u8;
    scope 1 {
        debug cb => _5;
        let _7: &[u8];
        scope 2 {
            debug key => _7;
            let _9: &[u8];
            scope 3 {
                debug prefix => _9;
                let mut _13: *const ();
                let mut _14: usize;
                let mut _15: usize;
                let mut _16: usize;
                let mut _17: usize;
                let mut _18: bool;
            }
        }
    }

    bb0: {
        _6 = _1 as *mut slice_transform::TransformCallback<'_> (PtrToPtr);
        _5 = &mut (*_6);
        _8 = _2 as *const u8 (PtrToPtr);
        _7 = std::slice::from_raw_parts::<'_, u8>(move _8, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = ((*_5).1: fn(&[u8]) -> &[u8]);
        _9 = move _10(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = Len((*_9));
        _13 = _4 as *const () (PtrToPtr);
        _14 = _13 as usize (Transmute);
        _15 = AlignOf(usize);
        _16 = Sub(_15, const 1_usize);
        _17 = BitAnd(_14, _16);
        _18 = Eq(_17, const 0_usize);
        assert(_18, "misaligned pointer dereference: address must be a multiple of {} but is {}", _15, _14) -> [success: bb4, unwind unreachable];
    }

    bb3: {
        _0 = move _12 as *mut i8 (PtrToPtr);
        return;
    }

    bb4: {
        (*_4) = move _11;
        _12 = core::slice::<impl [u8]>::as_ptr(_9) -> [return: bb3, unwind continue];
    }
}

fn in_domain_callback(_1: *mut c_void, _2: *const i8, _3: usize) -> u8 {
    debug raw_cb => _1;
    debug raw_key => _2;
    debug key_len => _3;
    let mut _0: u8;
    let _4: &mut slice_transform::TransformCallback<'_>;
    let mut _5: *mut slice_transform::TransformCallback<'_>;
    let mut _7: *const u8;
    let mut _9: std::option::Option<for<'a> fn(&'a [u8]) -> bool>;
    let mut _10: bool;
    scope 1 {
        debug cb => _4;
        let _6: &[u8];
        scope 2 {
            debug key => _6;
            let _8: for<'a> fn(&'a [u8]) -> bool;
            scope 3 {
                debug in_domain => _8;
            }
        }
    }

    bb0: {
        _5 = _1 as *mut slice_transform::TransformCallback<'_> (PtrToPtr);
        _4 = &mut (*_5);
        _7 = _2 as *const u8 (PtrToPtr);
        _6 = std::slice::from_raw_parts::<'_, u8>(move _7, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = ((*_4).2: std::option::Option<for<'a> fn(&'a [u8]) -> bool>);
        _8 = Option::<for<'a> fn(&'a [u8]) -> bool>::unwrap(move _9) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = _8(_6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = move _10 as u8 (IntToInt);
        return;
    }
}

fn <impl at src/lib.rs:107:10: 107:15>::fmt(_1: &Error, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::string::String;
    let _7: &std::string::String;

    bb0: {
        _3 = const "Error";
        _4 = const "message";
        _7 = &((*_1).0: std::string::String);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:107:17: 107:22>::clone(_1: &Error) -> Error {
    debug self => _1;
    let mut _0: Error;
    let mut _2: std::string::String;
    let _3: &std::string::String;

    bb0: {
        _3 = &((*_1).0: std::string::String);
        _2 = <String as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Error { message: move _2 };
        return;
    }
}

fn <impl at src/lib.rs:107:24: 107:33>::eq(_1: &Error, _2: &Error) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &std::string::String;
    let mut _4: &std::string::String;

    bb0: {
        _3 = &((*_1).0: std::string::String);
        _4 = &((*_2).0: std::string::String);
        _0 = <String as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:112:1: 112:11>::new(_1: String) -> Error {
    debug message => _1;
    let mut _0: Error;

    bb0: {
        _0 = Error { message: move _1 };
        return;
    }
}

fn <impl at src/lib.rs:112:1: 112:11>::into_string(_1: Error) -> String {
    debug self => _1;
    let mut _0: std::string::String;

    bb0: {
        _0 = <Error as Into<String>>::into(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:122:1: 122:26>::as_ref(_1: &Error) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &std::string::String;

    bb0: {
        _2 = &((*_1).0: std::string::String);
        _0 = <String as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:128:1: 128:28>::from(_1: Error) -> String {
    debug e => _1;
    let mut _0: std::string::String;

    bb0: {
        _0 = move (_1.0: std::string::String);
        return;
    }
}

fn <impl at src/lib.rs:134:1: 134:28>::description(_1: &Error) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &std::string::String;

    bb0: {
        _2 = &((*_1).0: std::string::String);
        _0 = <String as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:140:1: 140:28>::fmt(_1: &Error, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug formatter => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &std::string::String;

    bb0: {
        _3 = &((*_1).0: std::string::String);
        _0 = <String as std::fmt::Display>::fmt(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn <impl at src/lib.rs:286:16: 286:21>::clone(_1: &ColumnFamily<'_>) -> ColumnFamily<'_> {
    debug self => _1;
    let mut _0: ColumnFamily<'_>;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn Decision::Change(_1: &[u8]) -> Decision {
    let mut _0: compaction_filter::Decision;

    bb0: {
        _0 = Decision::Change(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Decision::Change(_1: &[u8]) -> Decision {
    let mut _0: compaction_filter::Decision;

    bb0: {
        _0 = Decision::Change(move _1);
        return;
    }
}

fn IteratorMode::From(_1: &[u8], _2: Direction) -> IteratorMode<'_> {
    let mut _0: db::IteratorMode<'_>;

    bb0: {
        _0 = IteratorMode::<'_>::From(move _1, move _2);
        return;
    }
}

// MIR FOR CTFE
fn IteratorMode::From(_1: &[u8], _2: Direction) -> IteratorMode<'_> {
    let mut _0: db::IteratorMode<'_>;

    bb0: {
        _0 = IteratorMode::<'_>::From(move _1, move _2);
        return;
    }
}
