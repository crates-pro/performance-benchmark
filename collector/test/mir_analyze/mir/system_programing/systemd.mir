// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
fn usec_from_duration(_1: Duration) -> u64 {
    debug duration => _1;
    let mut _0: u64;
    let _2: u64;
    let mut _3: u32;
    let mut _4: &std::time::Duration;
    let mut _5: u64;
    let mut _6: u64;
    let mut _7: &std::time::Duration;
    let mut _8: (u64, bool);
    let mut _9: (u64, bool);
    scope 1 {
        debug sub_usecs => _2;
    }

    bb0: {
        _4 = &_1;
        _3 = Duration::subsec_micros(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = move _3 as u64 (IntToInt);
        _7 = &_1;
        _6 = Duration::as_secs(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = CheckedMul(_6, const 1000000_u64);
        assert(!move (_8.1: bool), "attempt to compute `{} * {}`, which would overflow", move _6, const 1000000_u64) -> [success: bb3, unwind continue];
    }

    bb3: {
        _5 = move (_8.0: u64);
        _9 = CheckedAdd(_5, _2);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _5, _2) -> [success: bb4, unwind continue];
    }

    bb4: {
        _0 = move (_9.0: u64);
        return;
    }
}

fn ffi_result(_1: i32) -> std::result::Result<i32, std::io::Error> {
    debug ret => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _2: bool;
    let mut _3: std::io::Error;
    let mut _4: i32;
    let mut _5: bool;

    bb0: {
        _2 = Lt(_1, const 0_i32);
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _5 = Eq(_1, const i32::MIN);
        assert(!move _5, "attempt to negate `{}`, which would overflow", _1) -> [success: bb2, unwind continue];
    }

    bb2: {
        _4 = Neg(_1);
        _3 = std::io::Error::from_raw_os_error(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<i32, std::io::Error>::Err(move _3);
        goto -> bb5;
    }

    bb4: {
        _0 = std::result::Result::<i32, std::io::Error>::Ok(_1);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn free_cstring(_1: *mut i8) -> Option<String> {
    debug ptr => _1;
    let mut _0: std::option::Option<std::string::String>;
    let mut _2: bool;
    let _3: usize;
    let mut _4: *const i8;
    let mut _6: *const u8;
    let mut _7: *mut u8;
    let mut _9: std::borrow::Cow<'_, str>;
    let _10: ();
    let mut _11: *mut libc::c_void;
    let mut _12: std::string::String;
    scope 1 {
        debug len => _3;
        let _5: &[u8];
        scope 2 {
            debug char_slice => _5;
            let _8: std::string::String;
            scope 3 {
                debug s => _8;
            }
        }
    }

    bb0: {
        _2 = std::ptr::mut_ptr::<impl *mut i8>::is_null(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<String>::None;
        goto -> bb9;
    }

    bb3: {
        _4 = _1 as *const i8 (PointerCoercion(MutToConstPointer));
        _3 = strlen(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = _1 as *mut u8 (PtrToPtr);
        _6 = move _7 as *const u8 (PointerCoercion(MutToConstPointer));
        _5 = std::slice::from_raw_parts::<'_, u8>(move _6, _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = String::from_utf8_lossy(_5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Cow::<'_, str>::into_owned(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = _1 as *mut libc::c_void (PtrToPtr);
        _10 = free(move _11) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _12 = move _8;
        _0 = Option::<String>::Some(move _12);
        goto -> bb9;
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_8) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn collect_and_send(_1: T) -> i32 {
    debug args => _1;
    let mut _0: i32;
    let _2: std::vec::Vec<ffi::const_iovec>;
    let mut _3: std::iter::Map<T, {closure@src/journal.rs:28:14: 28:17}>;
    let mut _4: *const ffi::const_iovec;
    let mut _5: &std::vec::Vec<ffi::const_iovec>;
    let mut _6: i32;
    let mut _7: usize;
    let mut _8: &std::vec::Vec<ffi::const_iovec>;
    scope 1 {
        debug iovecs => _2;
        scope 2 {
        }
    }

    bb0: {
        _3 = <T as Iterator>::map::<const_iovec, {closure@src/journal.rs:28:14: 28:17}>(move _1, const ZeroSized: {closure@src/journal.rs:28:14: 28:17}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Map<T, {closure@src/journal.rs:28:14: 28:17}> as Iterator>::collect::<Vec<const_iovec>>(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = &_2;
        _4 = Vec::<const_iovec>::as_ptr(move _5) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _8 = &_2;
        _7 = Vec::<const_iovec>::len(move _8) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _6 = move _7 as i32 (IntToInt);
        _0 = sd_journal_sendv(move _4, move _6) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn collect_and_send::{closure#0}(_1: &mut {closure@src/journal.rs:28:14: 28:17}, _2: S) -> const_iovec {
    debug x => _2;
    let mut _0: ffi::const_iovec;
    scope 1 {
    }

    bb0: {
        _0 = const_iovec::from_str::<S>(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::send(_1: &[&str]) -> i32 {
    debug args => _1;
    let mut _0: i32;
    let mut _2: std::slice::Iter<'_, &str>;

    bb0: {
        _2 = core::slice::<impl [&str]>::iter(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = collect_and_send::<std::slice::Iter<'_, &str>, &&str>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn print(_1: u32, _2: &str) -> i32 {
    debug lvl => _1;
    debug s => _2;
    let mut _0: i32;
    let mut _3: &[&str];
    let _4: &[&str; 2];
    let _5: [&str; 2];
    let _6: &str;
    let _7: &std::string::String;
    let _8: std::string::String;
    let _9: std::string::String;
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &u32;
    let _17: &str;
    let _18: &std::string::String;
    let _19: std::string::String;
    let _20: std::string::String;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&str;
    let mut _28: &[&str; 1];
    let mut _29: &[&str; 1];
    scope 1 {
        debug res => _9;
    }
    scope 2 {
        debug res => _20;
    }

    bb0: {
        _29 = const _;
        _11 = _29 as &[&str] (PointerCoercion(Unsize));
        _16 = &_1;
        _15 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_16) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = format(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = move _9;
        _7 = &_8;
        _6 = <String as Deref>::deref(_7) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _28 = const _;
        _22 = _28 as &[&str] (PointerCoercion(Unsize));
        _27 = &_2;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_27) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _20 = format(move _21) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _19 = move _20;
        _18 = &_19;
        _17 = <String as Deref>::deref(_18) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _5 = [_6, _17];
        _4 = &_5;
        _3 = _4 as &[&str] (PointerCoercion(Unsize));
        _0 = journal::send(move _3) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        drop(_19) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_8) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_19) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_8) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

promoted[0] in print: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "MESSAGE="];
        _0 = &_1;
        return;
    }
}

promoted[1] in print: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "PRIORITY="];
        _0 = &_1;
        return;
    }
}

SyslogLevel::Err::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 3_isize;
        return;
    }
}

SyslogLevel::Warning::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 4_isize;
        return;
    }
}

SyslogLevel::Notice::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 5_isize;
        return;
    }
}

SyslogLevel::Info::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 6_isize;
        return;
    }
}

SyslogLevel::Debug::{constant#0}: isize = {
    let mut _0: isize;

    bb0: {
        _0 = const 7_isize;
        return;
    }
}

fn journal::<impl at src/journal.rs:57:1: 57:38>::from(_1: Level) -> SyslogLevel {
    debug level => _1;
    let mut _0: journal::SyslogLevel;
    let mut _2: usize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [1: bb3, 2: bb4, 3: bb5, 4: bb6, 5: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = SyslogLevel::Debug;
        goto -> bb7;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = SyslogLevel::Err;
        goto -> bb7;
    }

    bb4: {
        _0 = SyslogLevel::Warning;
        goto -> bb7;
    }

    bb5: {
        _0 = SyslogLevel::Notice;
        goto -> bb7;
    }

    bb6: {
        _0 = SyslogLevel::Info;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn journal::log(_1: usize, _2: &str, _3: u32, _4: &str, _5: &Arguments<'_>) -> () {
    debug level => _1;
    debug file => _2;
    debug line => _3;
    debug module_path => _4;
    debug args => _5;
    let mut _0: ();
    let _6: i32;
    let mut _7: &[&str];
    let _8: &[&str; 5];
    let _9: [&str; 5];
    let _10: &str;
    let _11: &std::string::String;
    let _12: std::string::String;
    let _13: std::string::String;
    let mut _14: std::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: &[core::fmt::rt::Argument<'_>];
    let _17: &[core::fmt::rt::Argument<'_>; 1];
    let _18: [core::fmt::rt::Argument<'_>; 1];
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &usize;
    let _21: &str;
    let _22: &std::string::String;
    let _23: std::string::String;
    let _24: std::string::String;
    let mut _25: std::fmt::Arguments<'_>;
    let mut _26: &[&str];
    let mut _27: &[core::fmt::rt::Argument<'_>];
    let _28: &[core::fmt::rt::Argument<'_>; 1];
    let _29: [core::fmt::rt::Argument<'_>; 1];
    let mut _30: core::fmt::rt::Argument<'_>;
    let _31: &&std::fmt::Arguments<'_>;
    let _32: &str;
    let _33: &std::string::String;
    let _34: std::string::String;
    let _35: std::string::String;
    let mut _36: std::fmt::Arguments<'_>;
    let mut _37: &[&str];
    let mut _38: &[core::fmt::rt::Argument<'_>];
    let _39: &[core::fmt::rt::Argument<'_>; 1];
    let _40: [core::fmt::rt::Argument<'_>; 1];
    let mut _41: core::fmt::rt::Argument<'_>;
    let _42: &u32;
    let _43: &str;
    let _44: &std::string::String;
    let _45: std::string::String;
    let _46: std::string::String;
    let mut _47: std::fmt::Arguments<'_>;
    let mut _48: &[&str];
    let mut _49: &[core::fmt::rt::Argument<'_>];
    let _50: &[core::fmt::rt::Argument<'_>; 1];
    let _51: [core::fmt::rt::Argument<'_>; 1];
    let mut _52: core::fmt::rt::Argument<'_>;
    let _53: &&str;
    let _54: &str;
    let _55: &std::string::String;
    let _56: std::string::String;
    let _57: std::string::String;
    let mut _58: std::fmt::Arguments<'_>;
    let mut _59: &[&str];
    let mut _60: &[core::fmt::rt::Argument<'_>];
    let _61: &[core::fmt::rt::Argument<'_>; 1];
    let _62: [core::fmt::rt::Argument<'_>; 1];
    let mut _63: core::fmt::rt::Argument<'_>;
    let _64: &&str;
    let mut _65: &[&str; 1];
    let mut _66: &[&str; 1];
    let mut _67: &[&str; 1];
    let mut _68: &[&str; 1];
    let mut _69: &[&str; 1];
    scope 1 {
        debug res => _13;
    }
    scope 2 {
        debug res => _24;
    }
    scope 3 {
        debug res => _35;
    }
    scope 4 {
        debug res => _46;
    }
    scope 5 {
        debug res => _57;
    }

    bb0: {
        _69 = const _;
        _15 = _69 as &[&str] (PointerCoercion(Unsize));
        _20 = &_1;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_20) -> [return: bb1, unwind continue];
    }

    bb1: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = Arguments::<'_>::new_v1(move _15, move _16) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = format(move _14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = move _13;
        _11 = &_12;
        _10 = <String as Deref>::deref(_11) -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _68 = const _;
        _26 = _68 as &[&str] (PointerCoercion(Unsize));
        _31 = &_5;
        _30 = core::fmt::rt::Argument::<'_>::new_display::<&Arguments<'_>>(_31) -> [return: bb5, unwind: bb31];
    }

    bb5: {
        _29 = [move _30];
        _28 = &_29;
        _27 = _28 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _25 = Arguments::<'_>::new_v1(move _26, move _27) -> [return: bb6, unwind: bb31];
    }

    bb6: {
        _24 = format(move _25) -> [return: bb7, unwind: bb31];
    }

    bb7: {
        _23 = move _24;
        _22 = &_23;
        _21 = <String as Deref>::deref(_22) -> [return: bb8, unwind: bb30];
    }

    bb8: {
        _67 = const _;
        _37 = _67 as &[&str] (PointerCoercion(Unsize));
        _42 = &_3;
        _41 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_42) -> [return: bb9, unwind: bb30];
    }

    bb9: {
        _40 = [move _41];
        _39 = &_40;
        _38 = _39 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _36 = Arguments::<'_>::new_v1(move _37, move _38) -> [return: bb10, unwind: bb30];
    }

    bb10: {
        _35 = format(move _36) -> [return: bb11, unwind: bb30];
    }

    bb11: {
        _34 = move _35;
        _33 = &_34;
        _32 = <String as Deref>::deref(_33) -> [return: bb12, unwind: bb29];
    }

    bb12: {
        _66 = const _;
        _48 = _66 as &[&str] (PointerCoercion(Unsize));
        _53 = &_2;
        _52 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_53) -> [return: bb13, unwind: bb29];
    }

    bb13: {
        _51 = [move _52];
        _50 = &_51;
        _49 = _50 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _47 = Arguments::<'_>::new_v1(move _48, move _49) -> [return: bb14, unwind: bb29];
    }

    bb14: {
        _46 = format(move _47) -> [return: bb15, unwind: bb29];
    }

    bb15: {
        _45 = move _46;
        _44 = &_45;
        _43 = <String as Deref>::deref(_44) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _65 = const _;
        _59 = _65 as &[&str] (PointerCoercion(Unsize));
        _64 = &_4;
        _63 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_64) -> [return: bb17, unwind: bb28];
    }

    bb17: {
        _62 = [move _63];
        _61 = &_62;
        _60 = _61 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _58 = Arguments::<'_>::new_v1(move _59, move _60) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _57 = format(move _58) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _56 = move _57;
        _55 = &_56;
        _54 = <String as Deref>::deref(_55) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        _9 = [_10, _21, _32, _43, _54];
        _8 = &_9;
        _7 = _8 as &[&str] (PointerCoercion(Unsize));
        _6 = journal::send(move _7) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        drop(_56) -> [return: bb22, unwind: bb28];
    }

    bb22: {
        drop(_45) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        drop(_34) -> [return: bb24, unwind: bb30];
    }

    bb24: {
        drop(_23) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        drop(_12) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_56) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_45) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_34) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_23) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_12) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }
}

promoted[0] in journal::log: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_MODULE="];
        _0 = &_1;
        return;
    }
}

promoted[1] in journal::log: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_FILE="];
        _0 = &_1;
        return;
    }
}

promoted[2] in journal::log: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_LINE="];
        _0 = &_1;
        return;
    }
}

promoted[3] in journal::log: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "MESSAGE="];
        _0 = &_1;
        return;
    }
}

promoted[4] in journal::log: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "PRIORITY="];
        _0 = &_1;
        return;
    }
}

fn log_record(_1: &Record<'_>) -> () {
    debug record => _1;
    let mut _0: ();
    let _2: [std::string::String; 3];
    let mut _3: std::string::String;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 1];
    let _9: [core::fmt::rt::Argument<'_>; 1];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &usize;
    let _12: usize;
    let _13: journal::SyslogLevel;
    let mut _14: log::Level;
    let mut _15: isize;
    let mut _16: u8;
    let mut _17: bool;
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: std::string::String;
    let _21: std::string::String;
    let mut _22: std::fmt::Arguments<'_>;
    let mut _23: &[&str];
    let mut _24: &[core::fmt::rt::Argument<'_>];
    let _25: &[core::fmt::rt::Argument<'_>; 1];
    let _26: [core::fmt::rt::Argument<'_>; 1];
    let mut _27: core::fmt::rt::Argument<'_>;
    let _28: &&std::fmt::Arguments<'_>;
    let _29: &std::fmt::Arguments<'_>;
    let _30: std::string::String;
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 1];
    let _35: [core::fmt::rt::Argument<'_>; 1];
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &&str;
    let _38: &str;
    let mut _40: std::option::Option<std::string::String>;
    let mut _41: std::option::Option<u32>;
    let mut _42: std::option::Option<std::string::String>;
    let mut _43: std::option::Option<&str>;
    let mut _44: std::option::Option<std::string::String>;
    let mut _45: std::option::Option<&str>;
    let _46: i32;
    let mut _47: std::iter::Chain<std::slice::Iter<'_, std::string::String>, std::iter::Flatten<std::slice::Iter<'_, std::option::Option<std::string::String>>>>;
    let mut _48: std::slice::Iter<'_, std::string::String>;
    let mut _49: &[std::string::String];
    let mut _50: &[std::string::String; 3];
    let mut _51: std::iter::Flatten<std::slice::Iter<'_, std::option::Option<std::string::String>>>;
    let mut _52: std::slice::Iter<'_, std::option::Option<std::string::String>>;
    let mut _53: &[std::option::Option<std::string::String>];
    let mut _54: &[std::option::Option<std::string::String>; 3];
    let mut _55: &[&str; 1];
    let mut _56: &[&str; 1];
    let mut _57: &[&str; 1];
    scope 1 {
        debug keys => _2;
        let _39: [std::option::Option<std::string::String>; 3];
        scope 5 {
            debug opt_keys => _39;
        }
    }
    scope 2 {
        debug res => _4;
    }
    scope 3 {
        debug res => _21;
    }
    scope 4 {
        debug res => _30;
    }

    bb0: {
        _57 = const _;
        _6 = _57 as &[&str] (PointerCoercion(Unsize));
        _14 = Record::<'_>::level(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _13 = <SyslogLevel as From<Level>>::from(move _14) -> [return: bb2, unwind continue];
    }

    bb2: {
        _15 = discriminant(_13);
        _16 = _15 as u8 (IntToInt);
        _17 = Ge(_16, const 3_u8);
        _18 = Le(_16, const 7_u8);
        _19 = BitAnd(move _17, move _18);
        assume(move _19);
        _12 = move _15 as usize (IntToInt);
        _11 = &_12;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = [move _10];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = format(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = move _4;
        _56 = const _;
        _23 = _56 as &[&str] (PointerCoercion(Unsize));
        _29 = Record::<'_>::args(_1) -> [return: bb6, unwind: bb32];
    }

    bb6: {
        _28 = &_29;
        _27 = core::fmt::rt::Argument::<'_>::new_display::<&Arguments<'_>>(_28) -> [return: bb7, unwind: bb32];
    }

    bb7: {
        _26 = [move _27];
        _25 = &_26;
        _24 = _25 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _22 = Arguments::<'_>::new_v1(move _23, move _24) -> [return: bb8, unwind: bb32];
    }

    bb8: {
        _21 = format(move _22) -> [return: bb9, unwind: bb32];
    }

    bb9: {
        _20 = move _21;
        _55 = const _;
        _32 = _55 as &[&str] (PointerCoercion(Unsize));
        _38 = Record::<'_>::target(_1) -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _37 = &_38;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_37) -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _35 = [move _36];
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _30 = format(move _31) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _2 = [move _3, move _20, move _30];
        _41 = Record::<'_>::line(_1) -> [return: bb14, unwind: bb30];
    }

    bb14: {
        _40 = Option::<u32>::map::<String, {closure@src/journal.rs:88:27: 88:33}>(move _41, const ZeroSized: {closure@src/journal.rs:88:27: 88:33}) -> [return: bb15, unwind: bb30];
    }

    bb15: {
        _43 = Record::<'_>::file(_1) -> [return: bb16, unwind: bb29];
    }

    bb16: {
        _42 = Option::<&str>::map::<String, {closure@src/journal.rs:89:27: 89:33}>(move _43, const ZeroSized: {closure@src/journal.rs:89:27: 89:33}) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _45 = Record::<'_>::module_path(_1) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        _44 = Option::<&str>::map::<String, {closure@src/journal.rs:92:18: 92:24}>(move _45, const ZeroSized: {closure@src/journal.rs:92:18: 92:24}) -> [return: bb19, unwind: bb28];
    }

    bb19: {
        _39 = [move _40, move _42, move _44];
        _50 = &_2;
        _49 = move _50 as &[std::string::String] (PointerCoercion(Unsize));
        _48 = core::slice::<impl [String]>::iter(move _49) -> [return: bb20, unwind: bb27];
    }

    bb20: {
        _54 = &_39;
        _53 = move _54 as &[std::option::Option<std::string::String>] (PointerCoercion(Unsize));
        _52 = core::slice::<impl [Option<String>]>::iter(move _53) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        _51 = <std::slice::Iter<'_, Option<String>> as Iterator>::flatten(move _52) -> [return: bb22, unwind: bb27];
    }

    bb22: {
        _47 = <std::slice::Iter<'_, String> as Iterator>::chain::<Flatten<std::slice::Iter<'_, Option<String>>>>(move _48, move _51) -> [return: bb23, unwind: bb27];
    }

    bb23: {
        _46 = collect_and_send::<std::iter::Chain<std::slice::Iter<'_, String>, Flatten<std::slice::Iter<'_, Option<String>>>>, &String>(move _47) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        drop(_39) -> [return: bb25, unwind: bb30];
    }

    bb25: {
        drop(_2) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_39) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_42) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_40) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_2) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_20) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_3) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }
}

promoted[0] in log_record: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "TARGET="];
        _0 = &_1;
        return;
    }
}

promoted[1] in log_record: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "MESSAGE="];
        _0 = &_1;
        return;
    }
}

promoted[2] in log_record: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "PRIORITY="];
        _0 = &_1;
        return;
    }
}

fn log_record::{closure#0}(_1: {closure@src/journal.rs:88:27: 88:33}, _2: u32) -> String {
    debug line => _2;
    let mut _0: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &u32;
    let mut _10: &[&str; 1];
    scope 1 {
        debug res => _0;
    }

    bb0: {
        _10 = const _;
        _4 = _10 as &[&str] (PointerCoercion(Unsize));
        _9 = &_2;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = format(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

promoted[0] in log_record::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_LINE="];
        _0 = &_1;
        return;
    }
}

fn log_record::{closure#1}(_1: {closure@src/journal.rs:89:27: 89:33}, _2: &str) -> String {
    debug file => _2;
    let mut _0: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &&str;
    let mut _10: &[&str; 1];
    scope 1 {
        debug res => _0;
    }

    bb0: {
        _10 = const _;
        _4 = _10 as &[&str] (PointerCoercion(Unsize));
        _9 = &_2;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = format(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

promoted[0] in log_record::{closure#1}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_FILE="];
        _0 = &_1;
        return;
    }
}

fn log_record::{closure#2}(_1: {closure@src/journal.rs:92:18: 92:24}, _2: &str) -> String {
    debug path => _2;
    let mut _0: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &&str;
    let mut _10: &[&str; 1];
    scope 1 {
        debug res => _0;
    }

    bb0: {
        _10 = const _;
        _4 = _10 as &[&str] (PointerCoercion(Unsize));
        _9 = &_2;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_9) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = format(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

promoted[0] in log_record::{closure#2}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "CODE_FUNC="];
        _0 = &_1;
        return;
    }
}

fn journal::<impl at src/journal.rs:100:1: 100:24>::enabled(_1: &JournalLog, _2: &log::Metadata<'_>) -> bool {
    debug self => _1;
    debug _metadata => _2;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn journal::<impl at src/journal.rs:100:1: 100:24>::log(_1: &JournalLog, _2: &Record<'_>) -> () {
    debug self => _1;
    debug record => _2;
    let mut _0: ();
    let _3: ();

    bb0: {
        _3 = log_record(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:100:1: 100:24>::flush(_1: &JournalLog) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

static LOGGER: JournalLog = {
    let mut _0: journal::JournalLog;

    bb0: {
        _0 = JournalLog;
        return;
    }
}

fn journal::<impl at src/journal.rs:115:1: 115:16>::init() -> std::result::Result<(), SetLoggerError> {
    let mut _0: std::result::Result<(), log::SetLoggerError>;
    let mut _1: &dyn log::Log;
    let _2: &journal::JournalLog;

    bb0: {
        _2 = const {alloc7: &JournalLog};
        _1 = _2 as &dyn log::Log (PointerCoercion(Unsize));
        _0 = set_logger(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc7 (static: LOGGER, size: 0, align: 1) {}

fn duration_from_usec(_1: u64) -> Duration {
    debug usec => _1;
    let mut _0: std::time::Duration;
    let _2: u64;
    let mut _3: bool;
    let mut _5: u64;
    let mut _6: bool;
    let mut _8: (u32, bool);
    scope 1 {
        debug secs => _2;
        let _4: u32;
        scope 2 {
            debug sub_usec => _4;
            let _7: u32;
            scope 3 {
                debug sub_nsec => _7;
            }
        }
    }

    bb0: {
        _3 = Eq(const 1000000_u64, const 0_u64);
        assert(!move _3, "attempt to divide `{}` by zero", _1) -> [success: bb1, unwind continue];
    }

    bb1: {
        _2 = Div(_1, const 1000000_u64);
        _6 = Eq(const 1000000_u64, const 0_u64);
        assert(!move _6, "attempt to calculate the remainder of `{}` with a divisor of zero", _1) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = Rem(_1, const 1000000_u64);
        _4 = move _5 as u32 (IntToInt);
        _8 = CheckedMul(_4, const 1000_u32);
        assert(!move (_8.1: bool), "attempt to compute `{} * {}`, which would overflow", _4, const 1000_u32) -> [success: bb3, unwind continue];
    }

    bb3: {
        _7 = move (_8.0: u32);
        _0 = Duration::new(_2, _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn system_time_from_realtime_usec(_1: u64) -> SystemTime {
    debug usec => _1;
    let mut _0: std::time::SystemTime;
    let _2: std::time::Duration;
    scope 1 {
        debug d => _2;
    }

    bb0: {
        _2 = duration_from_usec(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <SystemTime as Add<Duration>>::add(const _, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::from_ptr(_1: *mut sd_journal) -> Journal {
    debug ptr => _1;
    let mut _0: journal::Journal;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: !;
    let mut _5: std::ptr::NonNull<ffi::journal::sd_journal>;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _3 = std::ptr::mut_ptr::<impl *mut sd_journal>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _4 = core::panicking::panic(const "assertion failed: !ptr.is_null()") -> unwind continue;
    }

    bb4: {
        _5 = NonNull::<sd_journal>::new_unchecked(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Journal(move _5);
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ptr(_1: &Journal) -> *mut sd_journal {
    debug self => _1;
    let mut _0: *mut ffi::journal::sd_journal;
    let mut _2: std::ptr::NonNull<ffi::journal::sd_journal>;

    bb0: {
        _2 = ((*_1).0: std::ptr::NonNull<ffi::journal::sd_journal>);
        _0 = NonNull::<sd_journal>::as_ptr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::drop(_1: &mut Journal) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::journal::sd_journal;
    let mut _4: &journal::Journal;
    scope 1 {
    }

    bb0: {
        _4 = &(*_1);
        _3 = <Journal as ForeignType>::as_ptr(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_journal_close(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref(_1: &Journal) -> &JournalRef {
    debug self => _1;
    let mut _0: &journal::JournalRef;
    let mut _2: *mut ffi::journal::sd_journal;
    scope 1 {
    }

    bb0: {
        _2 = <Journal as ForeignType>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <JournalRef as ForeignTypeRef>::from_ptr::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref_mut(_1: &mut Journal) -> &mut JournalRef {
    debug self => _1;
    let mut _0: &mut journal::JournalRef;
    let mut _2: *mut ffi::journal::sd_journal;
    let mut _3: &journal::Journal;
    scope 1 {
    }

    bb0: {
        _3 = &(*_1);
        _2 = <Journal as ForeignType>::as_ptr(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <JournalRef as ForeignTypeRef>::from_ptr_mut::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow(_1: &Journal) -> &JournalRef {
    debug self => _1;
    let mut _0: &journal::JournalRef;

    bb0: {
        _0 = <Journal as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow_mut(_1: &mut Journal) -> &mut JournalRef {
    debug self => _1;
    let mut _0: &mut journal::JournalRef;

    bb0: {
        _0 = <Journal as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ref(_1: &Journal) -> &JournalRef {
    debug self => _1;
    let mut _0: &journal::JournalRef;

    bb0: {
        _0 = <Journal as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_mut(_1: &mut Journal) -> &mut JournalRef {
    debug self => _1;
    let mut _0: &mut journal::JournalRef;

    bb0: {
        _0 = <Journal as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:149:10: 149:15>::fmt(_1: &JournalEntryField<'_>, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&[u8];
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&usize;
    let _10: &usize;

    bb0: {
        _3 = const "JournalEntryField";
        _4 = const "data";
        _6 = &((*_1).0: &[u8]);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "eq_offs";
        _10 = &((*_1).1: usize);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:149:17: 149:26>::eq(_1: &JournalEntryField<'_>, _2: &JournalEntryField<'_>) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &&[u8];
    let mut _5: &&[u8];
    let mut _6: usize;
    let mut _7: usize;

    bb0: {
        _4 = &((*_1).0: &[u8]);
        _5 = &((*_2).0: &[u8]);
        _3 = <&[u8] as PartialEq>::eq(move _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = ((*_1).1: usize);
        _7 = ((*_2).1: usize);
        _0 = Eq(move _6, move _7);
        goto -> bb4;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn journal::<impl at src/journal.rs:149:28: 149:30>::assert_receiver_is_total_eq(_1: &JournalEntryField<'_>) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn journal::<impl at src/journal.rs:156:1: 156:31>::data(_1: &JournalEntryField<'_>) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];

    bb0: {
        _0 = deref_copy ((*_1).0: &[u8]);
        return;
    }
}

fn journal::<impl at src/journal.rs:156:1: 156:31>::name(_1: &JournalEntryField<'_>) -> &[u8] {
    debug self => _1;
    let mut _0: &[u8];
    let mut _2: std::ops::RangeTo<usize>;
    let mut _3: usize;
    let mut _4: &[u8];

    bb0: {
        _4 = deref_copy ((*_1).0: &[u8]);
        _3 = ((*_1).1: usize);
        _2 = RangeTo::<usize> { end: move _3 };
        _0 = <[u8] as Index<RangeTo<usize>>>::index(_4, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:156:1: 156:31>::value(_1: &JournalEntryField<'_>) -> Option<&[u8]> {
    debug self => _1;
    let mut _0: std::option::Option<&[u8]>;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: usize;
    let _5: &[u8];
    let mut _6: std::ops::RangeFrom<usize>;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: (usize, bool);
    let mut _10: &[u8];
    let mut _11: &[u8];

    bb0: {
        _3 = ((*_1).1: usize);
        _10 = deref_copy ((*_1).0: &[u8]);
        _4 = Len((*_10));
        _2 = Ne(move _3, move _4);
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _11 = deref_copy ((*_1).0: &[u8]);
        _8 = ((*_1).1: usize);
        _9 = CheckedAdd(_8, const 1_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 1_usize) -> [success: bb2, unwind continue];
    }

    bb2: {
        _7 = move (_9.0: usize);
        _6 = RangeFrom::<usize> { start: move _7 };
        _5 = <[u8] as Index<RangeFrom<usize>>>::index(_11, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = Option::<&[u8]>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<&[u8]>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn journal::<impl at src/journal.rs:183:1: 183:50>::from(_1: &[u8]) -> JournalEntryField<'_> {
    debug data => _1;
    let mut _0: journal::JournalEntryField<'_>;
    let _2: usize;
    let mut _3: std::option::Option<usize>;
    let mut _4: isize;
    let _5: usize;
    let mut _6: usize;
    scope 1 {
        debug eq_offs => _2;
    }
    scope 2 {
        debug v => _5;
    }

    bb0: {
        _3 = memchr::memchr(const 61_u8, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _2 = Len((*_1));
        goto -> bb5;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: usize);
        _2 = _5;
        goto -> bb5;
    }

    bb5: {
        _6 = _2;
        _0 = JournalEntryField::<'_> { data: _1, eq_offs: move _6 };
        return;
    }
}

fn journal::<impl at src/journal.rs:234:10: 234:15>::clone(_1: &JournalFiles) -> JournalFiles {
    debug self => _1;
    let mut _0: journal::JournalFiles;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn journal::<impl at src/journal.rs:234:23: 234:28>::fmt(_1: &JournalFiles, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "All";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "System";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "CurrentUser";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn journal::<impl at src/journal.rs:234:30: 234:39>::eq(_1: &JournalFiles, _2: &JournalFiles) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn journal::<impl at src/journal.rs:234:41: 234:43>::assert_receiver_is_total_eq(_1: &JournalFiles) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn journal::<impl at src/journal.rs:234:45: 234:55>::partial_cmp(_1: &JournalFiles, _2: &JournalFiles) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as PartialOrd>::partial_cmp(_5, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:234:57: 234:60>::cmp(_1: &JournalFiles, _2: &JournalFiles) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let _3: isize;
    let _5: &isize;
    let _6: &isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = &_3;
        _6 = &_4;
        _0 = <isize as Ord>::cmp(_5, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:245:1: 245:18>::as_flags(_1: JournalFiles) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const 0_i32;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const _;
        goto -> bb5;
    }

    bb4: {
        _0 = const _;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn journal::<impl at src/journal.rs:265:1: 265:47>::fmt(_1: &DisplayEntryData<'_>, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _4: std::result::Result<(), std::fmt::Error>;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: isize;
    let mut _8: std::cell::RefMut<'_, &mut journal::JournalRef>;
    let mut _9: &std::cell::RefCell<&mut journal::JournalRef>;
    let _10: ();
    let mut _11: &mut &mut journal::JournalRef;
    let mut _12: &mut std::cell::RefMut<'_, &mut journal::JournalRef>;
    let mut _13: std::result::Result<std::option::Option<journal::JournalEntryField<'_>>, std::io::Error>;
    let mut _14: &mut &mut journal::JournalRef;
    let mut _15: &mut std::cell::RefMut<'_, &mut journal::JournalRef>;
    let mut _16: isize;
    let mut _17: isize;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _20: std::result::Result<(), std::fmt::Error>;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&str;
    let _28: &str;
    let mut _29: std::result::Result<&str, std::str::Utf8Error>;
    let _30: &[u8];
    let mut _31: &journal::JournalEntryField<'_>;
    let mut _32: isize;
    let mut _34: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _35: std::result::Result<(), std::fmt::Error>;
    let mut _36: std::fmt::Arguments<'_>;
    let mut _37: &[&str];
    let mut _38: &[core::fmt::rt::Argument<'_>];
    let _39: &[core::fmt::rt::Argument<'_>; 1];
    let _40: [core::fmt::rt::Argument<'_>; 1];
    let mut _41: core::fmt::rt::Argument<'_>;
    let _42: &std::io::Error;
    let mut _43: isize;
    let mut _44: std::fmt::Arguments<'_>;
    let mut _45: &[&str];
    let mut _49: &[&str; 1];
    let mut _50: &mut journal::JournalRef;
    let mut _51: &mut journal::JournalRef;
    scope 1 {
        debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 2 {
        }
    }
    scope 3 {
        debug val => const ();
        scope 4 {
        }
    }
    scope 5 {
        debug j => _8;
        let _18: journal::JournalEntryField<'_>;
        let _33: std::io::Error;
        let mut _46: &[&str; 1];
        scope 6 {
            debug v => _18;
            let mut _48: &[&str; 2];
            scope 7 {
                debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
                scope 8 {
                }
            }
            scope 9 {
                debug val => const ();
                scope 10 {
                }
            }
        }
        scope 11 {
            debug e => _33;
            let mut _47: &[&str; 2];
            scope 12 {
                debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
                scope 13 {
                }
            }
            scope 14 {
                debug val => const ();
                scope 15 {
                }
            }
        }
    }

    bb0: {
        _49 = const _;
        _6 = _49 as &[&str] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_const(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _9 = &((*_1).0: std::cell::RefCell<&mut journal::JournalRef>);
        _8 = RefCell::<&mut JournalRef>::borrow_mut(move _9) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb32, unwind continue];
    }

    bb7: {
        _12 = &mut _8;
        _11 = <RefMut<'_, &mut JournalRef> as DerefMut>::deref_mut(move _12) -> [return: bb8, unwind: bb34];
    }

    bb8: {
        _50 = deref_copy (*_11);
        _10 = JournalRef::restart_data(_50) -> [return: bb38, unwind: bb34];
    }

    bb9: {
        _15 = &mut _8;
        _14 = <RefMut<'_, &mut JournalRef> as DerefMut>::deref_mut(move _15) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _51 = deref_copy (*_14);
        _13 = JournalRef::enumerate_data(_51) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _17 = discriminant(_13);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb5];
    }

    bb12: {
        _16 = discriminant(((_13 as Ok).0: std::option::Option<journal::JournalEntryField<'_>>));
        switchInt(move _16) -> [0: bb36, 1: bb14, otherwise: bb5];
    }

    bb13: {
        _33 = move ((_13 as Err).0: std::io::Error);
        _47 = const _;
        _37 = _47 as &[&str] (PointerCoercion(Unsize));
        _42 = &_33;
        _41 = core::fmt::rt::Argument::<'_>::new_debug::<std::io::Error>(_42) -> [return: bb23, unwind: bb33];
    }

    bb14: {
        _18 = move ((((_13 as Ok).0: std::option::Option<journal::JournalEntryField<'_>>) as Some).0: journal::JournalEntryField<'_>);
        _48 = const _;
        _22 = _48 as &[&str] (PointerCoercion(Unsize));
        _31 = &_18;
        _30 = JournalEntryField::<'_>::data(move _31) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _29 = from_utf8(_30) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _28 = std::result::Result::<&str, std::str::Utf8Error>::unwrap(move _29) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _27 = &_28;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_27) -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _20 = Formatter::<'_>::write_fmt(_2, move _21) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _19 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _20) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _32 = discriminant(_19);
        switchInt(move _32) -> [0: bb9, 1: bb22, otherwise: bb5];
    }

    bb22: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb39, unwind: bb34];
    }

    bb23: {
        _40 = [move _41];
        _39 = &_40;
        _38 = _39 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _36 = Arguments::<'_>::new_v1(move _37, move _38) -> [return: bb24, unwind: bb33];
    }

    bb24: {
        _35 = Formatter::<'_>::write_fmt(_2, move _36) -> [return: bb25, unwind: bb33];
    }

    bb25: {
        _34 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _35) -> [return: bb26, unwind: bb33];
    }

    bb26: {
        _43 = discriminant(_34);
        switchInt(move _43) -> [0: bb27, 1: bb28, otherwise: bb5];
    }

    bb27: {
        drop(_33) -> [return: bb36, unwind: bb34];
    }

    bb28: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb29, unwind: bb33];
    }

    bb29: {
        drop(_33) -> [return: bb37, unwind: bb34];
    }

    bb30: {
        _0 = Formatter::<'_>::write_fmt(_2, move _44) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        drop(_8) -> [return: bb32, unwind continue];
    }

    bb32: {
        return;
    }

    bb33 (cleanup): {
        drop(_33) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_8) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        _46 = const _;
        _45 = _46 as &[&str] (PointerCoercion(Unsize));
        _44 = Arguments::<'_>::new_const(move _45) -> [return: bb30, unwind: bb34];
    }

    bb37: {
        drop(_8) -> [return: bb32, unwind continue];
    }

    bb38: {
        goto -> bb9;
    }

    bb39: {
        goto -> bb37;
    }
}

promoted[0] in journal::<impl at src/journal.rs:265:1: 265:47>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "}\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in journal::<impl at src/journal.rs:265:1: 265:47>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "E: ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in journal::<impl at src/journal.rs:265:1: 265:47>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const " \"", const "\",\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in journal::<impl at src/journal.rs:265:1: 265:47>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "{\n"];
        _0 = &_1;
        return;
    }
}

fn journal::<impl at src/journal.rs:288:1: 288:59>::from(_1: &mut JournalRef) -> DisplayEntryData<'_> {
    debug v => _1;
    let mut _0: journal::DisplayEntryData<'_>;
    let mut _2: std::cell::RefCell<&mut journal::JournalRef>;

    bb0: {
        _2 = RefCell::<&mut JournalRef>::new(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = DisplayEntryData::<'_> { journal: move _2 };
        return;
    }
}

fn journal::<impl at src/journal.rs:303:10: 303:15>::clone(_1: &JournalSeek) -> JournalSeek {
    debug self => _1;
    let mut _0: journal::JournalSeek;
    let mut _2: isize;
    let _3: &id128::Id128;
    let _4: &u64;
    let mut _5: id128::Id128;
    let mut _6: u64;
    let _7: &u64;
    let mut _8: u64;
    let _9: &std::string::String;
    let mut _10: std::string::String;
    scope 1 {
        debug __self_0 => _3;
        debug __self_1 => _4;
    }
    scope 2 {
        debug __self_0 => _7;
    }
    scope 3 {
        debug __self_0 => _9;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb5, 3: bb7, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = &(((*_1) as Cursor).0: std::string::String);
        _10 = <String as Clone>::clone(_9) -> [return: bb8, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = JournalSeek::Head;
        goto -> bb9;
    }

    bb4: {
        _0 = JournalSeek::Tail;
        goto -> bb9;
    }

    bb5: {
        _3 = &(((*_1) as ClockMonotonic).0: id128::Id128);
        _4 = &(((*_1) as ClockMonotonic).1: u64);
        _5 = <Id128 as Clone>::clone(_3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = (*_4);
        _0 = JournalSeek::ClockMonotonic { boot_id: move _5, usec: move _6 };
        goto -> bb9;
    }

    bb7: {
        _7 = &(((*_1) as ClockRealtime).0: u64);
        _8 = (*_7);
        _0 = JournalSeek::ClockRealtime { usec: move _8 };
        goto -> bb9;
    }

    bb8: {
        _0 = JournalSeek::Cursor { cursor: move _10 };
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:303:17: 303:22>::fmt(_1: &JournalSeek, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &str;
    let _5: &str;
    let _6: &id128::Id128;
    let _7: &u64;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &str;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &&u64;
    let _14: &u64;
    let _15: &str;
    let _16: &str;
    let mut _17: &dyn std::fmt::Debug;
    let _18: &&u64;
    let _19: &std::string::String;
    let _20: &str;
    let _21: &str;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &&std::string::String;
    scope 1 {
        debug __self_0 => _6;
        debug __self_1 => _7;
    }
    scope 2 {
        debug __self_0 => _14;
    }
    scope 3 {
        debug __self_0 => _19;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _19 = &(((*_1) as Cursor).0: std::string::String);
        _20 = const "Cursor";
        _21 = const "cursor";
        _23 = &_19;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _20, _21, move _22) -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = const "Head";
        _0 = Formatter::<'_>::write_str(_2, _4) -> [return: bb7, unwind continue];
    }

    bb4: {
        _5 = const "Tail";
        _0 = Formatter::<'_>::write_str(_2, _5) -> [return: bb7, unwind continue];
    }

    bb5: {
        _6 = &(((*_1) as ClockMonotonic).0: id128::Id128);
        _7 = &(((*_1) as ClockMonotonic).1: u64);
        _8 = const "ClockMonotonic";
        _9 = const "boot_id";
        _10 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = const "usec";
        _13 = &_7;
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _8, _9, move _10, _11, move _12) -> [return: bb7, unwind continue];
    }

    bb6: {
        _14 = &(((*_1) as ClockRealtime).0: u64);
        _15 = const "ClockRealtime";
        _16 = const "usec";
        _18 = &_14;
        _17 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _15, _16, move _17) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn journal::<impl at src/journal.rs:303:24: 303:33>::eq(_1: &JournalSeek, _2: &JournalSeek) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    let mut _5: bool;
    let mut _6: (&journal::JournalSeek, &journal::JournalSeek);
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _10: isize;
    let mut _15: bool;
    let mut _16: u64;
    let mut _17: u64;
    let mut _20: u64;
    let mut _21: u64;
    let mut _24: &journal::JournalSeek;
    let mut _25: &journal::JournalSeek;
    let mut _26: &journal::JournalSeek;
    let mut _27: &journal::JournalSeek;
    let mut _28: &journal::JournalSeek;
    let mut _29: &journal::JournalSeek;
    let mut _30: &journal::JournalSeek;
    let mut _31: &journal::JournalSeek;
    let mut _32: &journal::JournalSeek;
    let mut _33: &journal::JournalSeek;
    let mut _34: &journal::JournalSeek;
    let mut _35: &journal::JournalSeek;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _11: &id128::Id128;
            let _12: &u64;
            let _13: &id128::Id128;
            let _14: &u64;
            let _18: &u64;
            let _19: &u64;
            let _22: &std::string::String;
            let _23: &std::string::String;
            scope 3 {
                debug __self_0 => _11;
                debug __self_1 => _12;
                debug __arg1_0 => _13;
                debug __arg1_1 => _14;
            }
            scope 4 {
                debug __self_0 => _18;
                debug __arg1_0 => _19;
            }
            scope 5 {
                debug __self_0 => _22;
                debug __arg1_0 => _23;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = Eq(_3, _4);
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = (_1, _2);
        _24 = deref_copy (_6.0: &journal::JournalSeek);
        _10 = discriminant((*_24));
        switchInt(move _10) -> [2: bb4, 3: bb5, 4: bb6, otherwise: bb3];
    }

    bb2: {
        _0 = const false;
        goto -> bb13;
    }

    bb3: {
        _0 = const true;
        goto -> bb13;
    }

    bb4: {
        _25 = deref_copy (_6.1: &journal::JournalSeek);
        _7 = discriminant((*_25));
        switchInt(move _7) -> [2: bb7, otherwise: bb3];
    }

    bb5: {
        _26 = deref_copy (_6.1: &journal::JournalSeek);
        _8 = discriminant((*_26));
        switchInt(move _8) -> [3: bb11, otherwise: bb3];
    }

    bb6: {
        _27 = deref_copy (_6.1: &journal::JournalSeek);
        _9 = discriminant((*_27));
        switchInt(move _9) -> [4: bb12, otherwise: bb3];
    }

    bb7: {
        _28 = deref_copy (_6.0: &journal::JournalSeek);
        _11 = &(((*_28) as ClockMonotonic).0: id128::Id128);
        _29 = deref_copy (_6.0: &journal::JournalSeek);
        _12 = &(((*_29) as ClockMonotonic).1: u64);
        _30 = deref_copy (_6.1: &journal::JournalSeek);
        _13 = &(((*_30) as ClockMonotonic).0: id128::Id128);
        _31 = deref_copy (_6.1: &journal::JournalSeek);
        _14 = &(((*_31) as ClockMonotonic).1: u64);
        _15 = <Id128 as PartialEq>::eq(_11, _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _15) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _16 = (*_12);
        _17 = (*_14);
        _0 = Eq(move _16, move _17);
        goto -> bb13;
    }

    bb10: {
        _0 = const false;
        goto -> bb13;
    }

    bb11: {
        _32 = deref_copy (_6.0: &journal::JournalSeek);
        _18 = &(((*_32) as ClockRealtime).0: u64);
        _33 = deref_copy (_6.1: &journal::JournalSeek);
        _19 = &(((*_33) as ClockRealtime).0: u64);
        _20 = (*_18);
        _21 = (*_19);
        _0 = Eq(move _20, move _21);
        goto -> bb13;
    }

    bb12: {
        _34 = deref_copy (_6.0: &journal::JournalSeek);
        _22 = &(((*_34) as Cursor).0: std::string::String);
        _35 = deref_copy (_6.1: &journal::JournalSeek);
        _23 = &(((*_35) as Cursor).0: std::string::String);
        _0 = <String as PartialEq>::eq(_22, _23) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

fn journal::<impl at src/journal.rs:303:35: 303:37>::assert_receiver_is_total_eq(_1: &JournalSeek) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
            scope 3 {
            }
        }
    }

    bb0: {
        return;
    }
}

fn journal::<impl at src/journal.rs:303:39: 303:49>::partial_cmp(_1: &JournalSeek, _2: &JournalSeek) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let _3: isize;
    let mut _5: (&journal::JournalSeek, &journal::JournalSeek);
    let mut _6: isize;
    let mut _7: isize;
    let mut _8: isize;
    let mut _9: isize;
    let mut _14: std::option::Option<std::cmp::Ordering>;
    let mut _15: i8;
    let mut _16: isize;
    let _21: &isize;
    let _22: &isize;
    let mut _23: &journal::JournalSeek;
    let mut _24: &journal::JournalSeek;
    let mut _25: &journal::JournalSeek;
    let mut _26: &journal::JournalSeek;
    let mut _27: &journal::JournalSeek;
    let mut _28: &journal::JournalSeek;
    let mut _29: &journal::JournalSeek;
    let mut _30: &journal::JournalSeek;
    let mut _31: &journal::JournalSeek;
    let mut _32: &journal::JournalSeek;
    let mut _33: &journal::JournalSeek;
    let mut _34: &journal::JournalSeek;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _10: &id128::Id128;
            let _11: &u64;
            let _12: &id128::Id128;
            let _13: &u64;
            let _17: &u64;
            let _18: &u64;
            let _19: &std::string::String;
            let _20: &std::string::String;
            scope 3 {
                debug __self_0 => _10;
                debug __self_1 => _11;
                debug __arg1_0 => _12;
                debug __arg1_1 => _13;
                scope 4 {
                    debug cmp => _14;
                }
            }
            scope 5 {
                debug __self_0 => _17;
                debug __arg1_0 => _18;
            }
            scope 6 {
                debug __self_0 => _19;
                debug __arg1_0 => _20;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _5 = (_1, _2);
        _23 = deref_copy (_5.0: &journal::JournalSeek);
        _9 = discriminant((*_23));
        switchInt(move _9) -> [2: bb2, 3: bb3, 4: bb4, otherwise: bb1];
    }

    bb1: {
        _21 = &_3;
        _22 = &_4;
        _0 = <isize as PartialOrd>::partial_cmp(_21, _22) -> [return: bb12, unwind continue];
    }

    bb2: {
        _24 = deref_copy (_5.1: &journal::JournalSeek);
        _6 = discriminant((*_24));
        switchInt(move _6) -> [2: bb5, otherwise: bb1];
    }

    bb3: {
        _25 = deref_copy (_5.1: &journal::JournalSeek);
        _7 = discriminant((*_25));
        switchInt(move _7) -> [3: bb10, otherwise: bb1];
    }

    bb4: {
        _26 = deref_copy (_5.1: &journal::JournalSeek);
        _8 = discriminant((*_26));
        switchInt(move _8) -> [4: bb11, otherwise: bb1];
    }

    bb5: {
        _27 = deref_copy (_5.0: &journal::JournalSeek);
        _10 = &(((*_27) as ClockMonotonic).0: id128::Id128);
        _28 = deref_copy (_5.0: &journal::JournalSeek);
        _11 = &(((*_28) as ClockMonotonic).1: u64);
        _29 = deref_copy (_5.1: &journal::JournalSeek);
        _12 = &(((*_29) as ClockMonotonic).0: id128::Id128);
        _30 = deref_copy (_5.1: &journal::JournalSeek);
        _13 = &(((*_30) as ClockMonotonic).1: u64);
        _14 = <Id128 as PartialOrd>::partial_cmp(_10, _12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [1: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = _14;
        goto -> bb12;
    }

    bb8: {
        _15 = discriminant(((_14 as Some).0: std::cmp::Ordering));
        switchInt(move _15) -> [0: bb9, otherwise: bb7];
    }

    bb9: {
        _0 = <u64 as PartialOrd>::partial_cmp(_11, _13) -> [return: bb12, unwind continue];
    }

    bb10: {
        _31 = deref_copy (_5.0: &journal::JournalSeek);
        _17 = &(((*_31) as ClockRealtime).0: u64);
        _32 = deref_copy (_5.1: &journal::JournalSeek);
        _18 = &(((*_32) as ClockRealtime).0: u64);
        _0 = <u64 as PartialOrd>::partial_cmp(_17, _18) -> [return: bb12, unwind continue];
    }

    bb11: {
        _33 = deref_copy (_5.0: &journal::JournalSeek);
        _19 = &(((*_33) as Cursor).0: std::string::String);
        _34 = deref_copy (_5.1: &journal::JournalSeek);
        _20 = &(((*_34) as Cursor).0: std::string::String);
        _0 = <String as PartialOrd>::partial_cmp(_19, _20) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn journal::<impl at src/journal.rs:303:51: 303:54>::cmp(_1: &JournalSeek, _2: &JournalSeek) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let _3: isize;
    let mut _5: std::cmp::Ordering;
    let _6: &isize;
    let _7: &isize;
    let mut _8: i8;
    let mut _9: (&journal::JournalSeek, &journal::JournalSeek);
    let mut _10: isize;
    let mut _11: isize;
    let mut _12: isize;
    let mut _13: isize;
    let mut _18: std::cmp::Ordering;
    let mut _19: i8;
    let mut _24: &journal::JournalSeek;
    let mut _25: &journal::JournalSeek;
    let mut _26: &journal::JournalSeek;
    let mut _27: &journal::JournalSeek;
    let mut _28: &journal::JournalSeek;
    let mut _29: &journal::JournalSeek;
    let mut _30: &journal::JournalSeek;
    let mut _31: &journal::JournalSeek;
    let mut _32: &journal::JournalSeek;
    let mut _33: &journal::JournalSeek;
    let mut _34: &journal::JournalSeek;
    let mut _35: &journal::JournalSeek;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
            let _14: &id128::Id128;
            let _15: &u64;
            let _16: &id128::Id128;
            let _17: &u64;
            let _20: &u64;
            let _21: &u64;
            let _22: &std::string::String;
            let _23: &std::string::String;
            scope 3 {
                debug __self_0 => _14;
                debug __self_1 => _15;
                debug __arg1_0 => _16;
                debug __arg1_1 => _17;
                scope 4 {
                    debug cmp => _18;
                }
            }
            scope 5 {
                debug __self_0 => _20;
                debug __arg1_0 => _21;
            }
            scope 6 {
                debug __self_0 => _22;
                debug __arg1_0 => _23;
            }
            scope 7 {
                debug cmp => _5;
            }
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _6 = &_3;
        _7 = &_4;
        _5 = <isize as Ord>::cmp(_6, _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = discriminant(_5);
        switchInt(move _8) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = _5;
        goto -> bb14;
    }

    bb3: {
        _9 = (_1, _2);
        _24 = deref_copy (_9.0: &journal::JournalSeek);
        _13 = discriminant((*_24));
        switchInt(move _13) -> [2: bb5, 3: bb6, 4: bb7, otherwise: bb4];
    }

    bb4: {
        _0 = Equal;
        goto -> bb14;
    }

    bb5: {
        _25 = deref_copy (_9.1: &journal::JournalSeek);
        _10 = discriminant((*_25));
        switchInt(move _10) -> [2: bb8, otherwise: bb4];
    }

    bb6: {
        _26 = deref_copy (_9.1: &journal::JournalSeek);
        _11 = discriminant((*_26));
        switchInt(move _11) -> [3: bb12, otherwise: bb4];
    }

    bb7: {
        _27 = deref_copy (_9.1: &journal::JournalSeek);
        _12 = discriminant((*_27));
        switchInt(move _12) -> [4: bb13, otherwise: bb4];
    }

    bb8: {
        _28 = deref_copy (_9.0: &journal::JournalSeek);
        _14 = &(((*_28) as ClockMonotonic).0: id128::Id128);
        _29 = deref_copy (_9.0: &journal::JournalSeek);
        _15 = &(((*_29) as ClockMonotonic).1: u64);
        _30 = deref_copy (_9.1: &journal::JournalSeek);
        _16 = &(((*_30) as ClockMonotonic).0: id128::Id128);
        _31 = deref_copy (_9.1: &journal::JournalSeek);
        _17 = &(((*_31) as ClockMonotonic).1: u64);
        _18 = <Id128 as Ord>::cmp(_14, _16) -> [return: bb9, unwind continue];
    }

    bb9: {
        _19 = discriminant(_18);
        switchInt(move _19) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = _18;
        goto -> bb14;
    }

    bb11: {
        _0 = <u64 as Ord>::cmp(_15, _17) -> [return: bb14, unwind continue];
    }

    bb12: {
        _32 = deref_copy (_9.0: &journal::JournalSeek);
        _20 = &(((*_32) as ClockRealtime).0: u64);
        _33 = deref_copy (_9.1: &journal::JournalSeek);
        _21 = &(((*_33) as ClockRealtime).0: u64);
        _0 = <u64 as Ord>::cmp(_20, _21) -> [return: bb14, unwind continue];
    }

    bb13: {
        _34 = deref_copy (_9.0: &journal::JournalSeek);
        _22 = &(((*_34) as Cursor).0: std::string::String);
        _35 = deref_copy (_9.1: &journal::JournalSeek);
        _23 = &(((*_35) as Cursor).0: std::string::String);
        _0 = <String as Ord>::cmp(_22, _23) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

fn journal::<impl at src/journal.rs:312:10: 312:15>::clone(_1: &JournalWaitResult) -> JournalWaitResult {
    debug self => _1;
    let mut _0: journal::JournalWaitResult;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = JournalWaitResult::Invalidate;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = JournalWaitResult::Nop;
        goto -> bb5;
    }

    bb4: {
        _0 = JournalWaitResult::Append;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn journal::<impl at src/journal.rs:312:17: 312:22>::fmt(_1: &JournalWaitResult, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "Invalidate";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Nop";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Append";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn journal::<impl at src/journal.rs:334:10: 334:15>::clone(_1: &journal::OpenOptions) -> journal::OpenOptions {
    debug self => _1;
    let mut _0: journal::OpenOptions;
    let mut _2: bool;
    let _3: &bool;
    let mut _4: bool;
    let _5: &bool;
    let mut _6: bool;
    let _7: &bool;
    let mut _8: bool;
    let _9: &bool;
    let mut _10: bool;
    let _11: &bool;
    let mut _12: bool;
    let _13: &bool;
    let mut _14: i32;
    let _15: &i32;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _5 = &((*_1).1: bool);
        _4 = (*_5);
        _7 = &((*_1).2: bool);
        _6 = (*_7);
        _9 = &((*_1).3: bool);
        _8 = (*_9);
        _11 = &((*_1).4: bool);
        _10 = (*_11);
        _13 = &((*_1).5: bool);
        _12 = (*_13);
        _15 = &((*_1).6: i32);
        _14 = (*_15);
        _0 = journal::OpenOptions { current_user: move _2, system: move _4, local_only: move _6, runtime_only: move _8, all_namespaces: move _10, include_default_namespace: move _12, extra_raw_flags: move _14 };
        return;
    }
}

fn journal::<impl at src/journal.rs:334:17: 334:22>::fmt(_1: &journal::OpenOptions, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 7];
    let _5: [&dyn std::fmt::Debug; 7];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &bool;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &bool;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &bool;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &bool;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &bool;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&i32;
    let _20: &i32;
    let _21: &str;
    let mut _22: &[&str];
    let mut _23: &[&str; 7];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _23 = const _;
        _7 = &((*_1).0: bool);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: bool);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: bool);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: bool);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _17 = &((*_1).5: bool);
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _20 = &((*_1).6: i32);
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16, move _18];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _21 = const "OpenOptions";
        _22 = _23 as &[&str] (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_fields_finish(_2, _21, move _22, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in journal::<impl at src/journal.rs:334:17: 334:22>::fmt: &[&str; 7] = {
    let mut _0: &[&str; 7];
    let mut _1: [&str; 7];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;
    let mut _12: &str;
    let mut _13: &str;

    bb0: {
        _3 = const "system";
        _2 = &(*_3);
        _5 = const "local_only";
        _4 = &(*_5);
        _7 = const "runtime_only";
        _6 = &(*_7);
        _9 = const "all_namespaces";
        _8 = &(*_9);
        _11 = const "include_default_namespace";
        _10 = &(*_11);
        _13 = const "extra_raw_flags";
        _12 = &(*_13);
        _1 = [const "current_user", move _2, move _4, move _6, move _8, move _10, move _12];
        _0 = &_1;
        return;
    }
}

fn journal::<impl at src/journal.rs:334:24: 334:31>::default() -> journal::OpenOptions {
    let mut _0: journal::OpenOptions;
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: i32;

    bb0: {
        _1 = <bool as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <bool as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <bool as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <bool as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <bool as Default>::default() -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = <bool as Default>::default() -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = <i32 as Default>::default() -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = journal::OpenOptions { current_user: move _1, system: move _2, local_only: move _3, runtime_only: move _4, all_namespaces: move _5, include_default_namespace: move _6, extra_raw_flags: move _7 };
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::current_user(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug current_user => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).0: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::system(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug system => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).1: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::local_only(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug local_only => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).2: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::runtime_only(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug runtime_only => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).3: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::all_namespaces(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug all_namespaces => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).4: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::include_default_namespace(_1: &mut journal::OpenOptions, _2: bool) -> &mut journal::OpenOptions {
    debug self => _1;
    debug include_default_namespace => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).5: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::extra_raw_flags(_1: &mut journal::OpenOptions, _2: i32) -> &mut journal::OpenOptions {
    debug self => _1;
    debug extra_raw_flags => _2;
    let mut _0: &mut journal::OpenOptions;

    bb0: {
        ((*_1).6: i32) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:345:1: 345:17>::open(_1: &journal::OpenOptions) -> std::result::Result<Journal, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;

    bb0: {
        _0 = Journal::open_with_opts::<&CStr>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:434:10: 434:15>::clone(_1: &OpenDirectoryOptions) -> OpenDirectoryOptions {
    debug self => _1;
    let mut _0: journal::OpenDirectoryOptions;
    let mut _2: bool;
    let _3: &bool;
    let mut _4: bool;
    let _5: &bool;
    let mut _6: bool;
    let _7: &bool;
    let mut _8: i32;
    let _9: &i32;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _5 = &((*_1).1: bool);
        _4 = (*_5);
        _7 = &((*_1).2: bool);
        _6 = (*_7);
        _9 = &((*_1).3: i32);
        _8 = (*_9);
        _0 = OpenDirectoryOptions { os_root: move _2, current_user: move _4, system: move _6, extra_raw_flags: move _8 };
        return;
    }
}

fn journal::<impl at src/journal.rs:434:17: 434:22>::fmt(_1: &OpenDirectoryOptions, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &bool;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &bool;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&i32;
    let _16: &i32;

    bb0: {
        _3 = const "OpenDirectoryOptions";
        _4 = const "os_root";
        _6 = &((*_1).0: bool);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "current_user";
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "system";
        _12 = &((*_1).2: bool);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "extra_raw_flags";
        _16 = &((*_1).3: i32);
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field4_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:434:24: 434:31>::default() -> OpenDirectoryOptions {
    let mut _0: journal::OpenDirectoryOptions;
    let mut _1: bool;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: i32;

    bb0: {
        _1 = <bool as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <bool as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <bool as Default>::default() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <i32 as Default>::default() -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = OpenDirectoryOptions { os_root: move _1, current_user: move _2, system: move _3, extra_raw_flags: move _4 };
        return;
    }
}

fn journal::<impl at src/journal.rs:442:1: 442:26>::os_root(_1: &mut OpenDirectoryOptions, _2: bool) -> &mut OpenDirectoryOptions {
    debug self => _1;
    debug os_root => _2;
    let mut _0: &mut journal::OpenDirectoryOptions;

    bb0: {
        ((*_1).0: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:442:1: 442:26>::current_user(_1: &mut OpenDirectoryOptions, _2: bool) -> &mut OpenDirectoryOptions {
    debug self => _1;
    debug current_user => _2;
    let mut _0: &mut journal::OpenDirectoryOptions;

    bb0: {
        ((*_1).1: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:442:1: 442:26>::system(_1: &mut OpenDirectoryOptions, _2: bool) -> &mut OpenDirectoryOptions {
    debug self => _1;
    debug system => _2;
    let mut _0: &mut journal::OpenDirectoryOptions;

    bb0: {
        ((*_1).2: bool) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:442:1: 442:26>::extra_raw_flags(_1: &mut OpenDirectoryOptions, _2: i32) -> &mut OpenDirectoryOptions {
    debug self => _1;
    debug extra_raw_flags => _2;
    let mut _0: &mut journal::OpenDirectoryOptions;

    bb0: {
        ((*_1).3: i32) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:442:1: 442:26>::open_directory(_1: &OpenDirectoryOptions, _2: A) -> std::result::Result<Journal, std::io::Error> {
    debug self => _1;
    debug directory => _2;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;

    bb0: {
        _0 = Journal::open_with_opts_dir::<A>(move _2, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:492:10: 492:15>::clone(_1: &OpenFilesOptions) -> OpenFilesOptions {
    debug self => _1;
    let mut _0: journal::OpenFilesOptions;
    let mut _2: i32;
    let _3: &i32;

    bb0: {
        _3 = &((*_1).0: i32);
        _2 = (*_3);
        _0 = OpenFilesOptions { extra_raw_flags: move _2 };
        return;
    }
}

fn journal::<impl at src/journal.rs:492:17: 492:22>::fmt(_1: &OpenFilesOptions, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&i32;
    let _7: &i32;

    bb0: {
        _3 = const "OpenFilesOptions";
        _4 = const "extra_raw_flags";
        _7 = &((*_1).0: i32);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:492:24: 492:31>::default() -> OpenFilesOptions {
    let mut _0: journal::OpenFilesOptions;
    let mut _1: i32;

    bb0: {
        _1 = <i32 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = OpenFilesOptions { extra_raw_flags: move _1 };
        return;
    }
}

fn journal::<impl at src/journal.rs:497:1: 497:22>::extra_raw_flags(_1: &mut OpenFilesOptions, _2: i32) -> &mut OpenFilesOptions {
    debug self => _1;
    debug extra_raw_flags => _2;
    let mut _0: &mut journal::OpenFilesOptions;

    bb0: {
        ((*_1).0: i32) = _2;
        _0 = _1;
        return;
    }
}

fn journal::<impl at src/journal.rs:497:1: 497:22>::open_files(_1: &OpenFilesOptions, _2: I) -> std::result::Result<Journal, std::io::Error> {
    debug self => _1;
    debug files => _2;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;

    bb0: {
        _0 = Journal::open_with_opts_files::<A, I>(move _2, _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:525:1: 525:13>::open_with_opts(_1: &journal::OpenOptions) -> std::result::Result<Journal, std::io::Error> {
    debug opts => _1;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;
    let mut _2: i32;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _12: std::result::Result<i32, std::io::Error>;
    let mut _13: i32;
    let mut _14: *mut *mut ffi::journal::sd_journal;
    let mut _15: &mut std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    let mut _16: i32;
    let mut _17: isize;
    let mut _20: journal::Journal;
    let mut _21: *mut ffi::journal::sd_journal;
    let mut _22: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    scope 1 {
        debug flags => _2;
        let mut _10: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
        scope 2 {
            debug jp => _10;
            let _18: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _19: i32;
            scope 3 {
            }
            scope 4 {
                debug residual => _18;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _19;
                scope 7 {
                }
            }
            scope 8 {
            }
        }
    }

    bb0: {
        _2 = ((*_1).6: i32);
        _3 = ((*_1).0: bool);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _2 = BitOr(_2, const _);
        goto -> bb2;
    }

    bb2: {
        _4 = ((*_1).1: bool);
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _2 = BitOr(_2, const _);
        goto -> bb4;
    }

    bb4: {
        _5 = ((*_1).2: bool);
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _2 = BitOr(_2, const _);
        goto -> bb6;
    }

    bb6: {
        _6 = ((*_1).2: bool);
        switchInt(move _6) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _2 = BitOr(_2, const _);
        goto -> bb8;
    }

    bb8: {
        _7 = ((*_1).3: bool);
        switchInt(move _7) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _2 = BitOr(_2, const _);
        goto -> bb10;
    }

    bb10: {
        _8 = ((*_1).4: bool);
        switchInt(move _8) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _2 = BitOr(_2, const _);
        goto -> bb12;
    }

    bb12: {
        _9 = ((*_1).5: bool);
        switchInt(move _9) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _2 = BitOr(_2, const _);
        goto -> bb14;
    }

    bb14: {
        _10 = MaybeUninit::<*mut sd_journal>::uninit() -> [return: bb15, unwind continue];
    }

    bb15: {
        _15 = &mut _10;
        _14 = MaybeUninit::<*mut sd_journal>::as_mut_ptr(move _15) -> [return: bb16, unwind continue];
    }

    bb16: {
        _16 = _2;
        _13 = sd_journal_open(move _14, move _16) -> [return: bb17, unwind continue];
    }

    bb17: {
        _12 = ffi_result(move _13) -> [return: bb18, unwind continue];
    }

    bb18: {
        _11 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _12) -> [return: bb19, unwind continue];
    }

    bb19: {
        _17 = discriminant(_11);
        switchInt(move _17) -> [0: bb20, 1: bb22, otherwise: bb21];
    }

    bb20: {
        _19 = ((_11 as Continue).0: i32);
        _22 = _10;
        _21 = MaybeUninit::<*mut sd_journal>::assume_init(move _22) -> [return: bb23, unwind continue];
    }

    bb21: {
        unreachable;
    }

    bb22: {
        _18 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Journal, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _18) -> [return: bb25, unwind continue];
    }

    bb23: {
        _20 = <Journal as ForeignType>::from_ptr(move _21) -> [return: bb24, unwind continue];
    }

    bb24: {
        _0 = std::result::Result::<Journal, std::io::Error>::Ok(move _20);
        goto -> bb25;
    }

    bb25: {
        return;
    }
}

fn journal::<impl at src/journal.rs:525:1: 525:13>::open_with_opts_dir(_1: A, _2: &OpenDirectoryOptions) -> std::result::Result<Journal, std::io::Error> {
    debug directory => _1;
    debug opts => _2;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;
    let mut _3: i32;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _10: std::result::Result<i32, std::io::Error>;
    let mut _11: i32;
    let mut _12: *mut *mut ffi::journal::sd_journal;
    let mut _13: &mut std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    let mut _14: *const i8;
    let _15: &std::ffi::CStr;
    let mut _16: &<A as cstr_argument::CStrArgument>::Output;
    let mut _17: i32;
    let mut _18: isize;
    let mut _21: journal::Journal;
    let mut _22: *mut ffi::journal::sd_journal;
    let mut _23: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    scope 1 {
        debug flags => _3;
        let _7: <A as cstr_argument::CStrArgument>::Output;
        scope 2 {
            debug d_path => _7;
            let mut _8: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
            scope 3 {
                debug jp => _8;
                let _19: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _20: i32;
                scope 4 {
                }
                scope 5 {
                    debug residual => _19;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _20;
                    scope 8 {
                    }
                }
                scope 9 {
                }
            }
        }
    }

    bb0: {
        _3 = ((*_2).3: i32);
        _4 = ((*_2).0: bool);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = BitOr(_3, const _);
        goto -> bb2;
    }

    bb2: {
        _5 = ((*_2).1: bool);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _3 = BitOr(_3, const _);
        goto -> bb4;
    }

    bb4: {
        _6 = ((*_2).2: bool);
        switchInt(move _6) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _3 = BitOr(_3, const _);
        goto -> bb6;
    }

    bb6: {
        _7 = <A as CStrArgument>::into_cstr(move _1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = MaybeUninit::<*mut sd_journal>::uninit() -> [return: bb8, unwind: bb22];
    }

    bb8: {
        _13 = &mut _8;
        _12 = MaybeUninit::<*mut sd_journal>::as_mut_ptr(move _13) -> [return: bb9, unwind: bb22];
    }

    bb9: {
        _16 = &_7;
        _15 = <<A as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _16) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        _14 = CStr::as_ptr(_15) -> [return: bb11, unwind: bb22];
    }

    bb11: {
        _17 = _3;
        _11 = sd_journal_open_directory(move _12, move _14, move _17) -> [return: bb12, unwind: bb22];
    }

    bb12: {
        _10 = ffi_result(move _11) -> [return: bb13, unwind: bb22];
    }

    bb13: {
        _9 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _10) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        _18 = discriminant(_9);
        switchInt(move _18) -> [0: bb15, 1: bb17, otherwise: bb16];
    }

    bb15: {
        _20 = ((_9 as Continue).0: i32);
        _23 = _8;
        _22 = MaybeUninit::<*mut sd_journal>::assume_init(move _23) -> [return: bb19, unwind: bb22];
    }

    bb16: {
        unreachable;
    }

    bb17: {
        _19 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Journal, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _19) -> [return: bb18, unwind: bb22];
    }

    bb18: {
        drop(_7) -> [return: bb21, unwind continue];
    }

    bb19: {
        _21 = <Journal as ForeignType>::from_ptr(move _22) -> [return: bb20, unwind: bb22];
    }

    bb20: {
        _0 = std::result::Result::<Journal, std::io::Error>::Ok(move _21);
        drop(_7) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_7) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        resume;
    }
}

fn journal::<impl at src/journal.rs:525:1: 525:13>::open_with_opts_files(_1: I, _2: &OpenFilesOptions) -> std::result::Result<Journal, std::io::Error> {
    debug files => _1;
    debug opts => _2;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;
    let mut _3: std::vec::Vec<<A as cstr_argument::CStrArgument>::Output>;
    let mut _4: <I as std::iter::IntoIterator>::IntoIter;
    let mut _5: I;
    let mut _7: std::option::Option<A>;
    let mut _8: &mut <I as std::iter::IntoIterator>::IntoIter;
    let mut _9: isize;
    let _11: ();
    let mut _12: &mut std::vec::Vec<<A as cstr_argument::CStrArgument>::Output>;
    let mut _13: <A as cstr_argument::CStrArgument>::Output;
    let mut _15: std::slice::Iter<'_, <A as cstr_argument::CStrArgument>::Output>;
    let mut _16: &std::vec::Vec<<A as cstr_argument::CStrArgument>::Output>;
    let mut _18: std::option::Option<&<A as cstr_argument::CStrArgument>::Output>;
    let mut _19: &mut std::slice::Iter<'_, <A as cstr_argument::CStrArgument>::Output>;
    let mut _20: isize;
    let _22: ();
    let mut _23: &mut std::vec::Vec<*const i8>;
    let mut _24: *const i8;
    let _25: &std::ffi::CStr;
    let _26: ();
    let mut _27: &mut std::vec::Vec<*const i8>;
    let mut _28: *const i8;
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _31: std::result::Result<i32, std::io::Error>;
    let mut _32: i32;
    let mut _33: *mut *mut ffi::journal::sd_journal;
    let mut _34: &mut std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    let mut _35: *const *const i8;
    let mut _36: &std::vec::Vec<*const i8>;
    let mut _37: i32;
    let mut _38: isize;
    let mut _41: journal::Journal;
    let mut _42: *mut ffi::journal::sd_journal;
    let mut _43: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
    let mut _44: bool;
    scope 1 {
        debug file_cstrs => _3;
        let mut _6: <I as std::iter::IntoIterator>::IntoIter;
        let mut _14: std::vec::Vec<*const i8>;
        scope 2 {
            debug iter => _6;
            let _10: A;
            scope 3 {
                debug i => _10;
            }
        }
        scope 4 {
            debug file_ptrs => _14;
            let mut _17: std::slice::Iter<'_, <A as cstr_argument::CStrArgument>::Output>;
            let mut _29: std::mem::MaybeUninit<*mut ffi::journal::sd_journal>;
            scope 5 {
                debug iter => _17;
                let _21: &<A as cstr_argument::CStrArgument>::Output;
                scope 6 {
                    debug i => _21;
                }
            }
            scope 7 {
                debug jp => _29;
                let _39: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _40: i32;
                scope 8 {
                }
                scope 9 {
                    debug residual => _39;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _40;
                    scope 12 {
                    }
                }
                scope 13 {
                }
            }
        }
    }

    bb0: {
        _44 = const false;
        _44 = const true;
        _3 = Vec::<<A as CStrArgument>::Output>::new() -> [return: bb1, unwind: bb39];
    }

    bb1: {
        _44 = const false;
        _5 = move _1;
        _4 = <I as IntoIterator>::into_iter(move _5) -> [return: bb2, unwind: bb36];
    }

    bb2: {
        _6 = move _4;
        goto -> bb3;
    }

    bb3: {
        _8 = &mut _6;
        _7 = <<I as IntoIterator>::IntoIter as Iterator>::next(_8) -> [return: bb4, unwind: bb35];
    }

    bb4: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _10 = move ((_7 as Some).0: A);
        _12 = &mut _3;
        _13 = <A as CStrArgument>::into_cstr(move _10) -> [return: bb8, unwind: bb35];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        drop(_6) -> [return: bb9, unwind: bb36];
    }

    bb8: {
        _11 = Vec::<<A as CStrArgument>::Output>::push(move _12, move _13) -> [return: bb40, unwind: bb35];
    }

    bb9: {
        _14 = Vec::<*const i8>::new() -> [return: bb10, unwind: bb36];
    }

    bb10: {
        _16 = &_3;
        _15 = <&Vec<<A as CStrArgument>::Output> as IntoIterator>::into_iter(move _16) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _17 = move _15;
        goto -> bb12;
    }

    bb12: {
        _19 = &mut _17;
        _18 = <std::slice::Iter<'_, <A as CStrArgument>::Output> as Iterator>::next(_19) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb15, 1: bb14, otherwise: bb6];
    }

    bb14: {
        _21 = ((_18 as Some).0: &<A as cstr_argument::CStrArgument>::Output);
        _23 = &mut _14;
        _25 = <<A as CStrArgument>::Output as AsRef<CStr>>::as_ref(_21) -> [return: bb16, unwind: bb34];
    }

    bb15: {
        _27 = &mut _14;
        _28 = null::<i8>() -> [return: bb18, unwind: bb34];
    }

    bb16: {
        _24 = CStr::as_ptr(_25) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _22 = Vec::<*const i8>::push(move _23, move _24) -> [return: bb41, unwind: bb34];
    }

    bb18: {
        _26 = Vec::<*const i8>::push(move _27, move _28) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _29 = MaybeUninit::<*mut sd_journal>::uninit() -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _34 = &mut _29;
        _33 = MaybeUninit::<*mut sd_journal>::as_mut_ptr(move _34) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _36 = &_14;
        _35 = Vec::<*const i8>::as_ptr(move _36) -> [return: bb22, unwind: bb34];
    }

    bb22: {
        _37 = ((*_2).0: i32);
        _32 = sd_journal_open_files(move _33, move _35, move _37) -> [return: bb23, unwind: bb34];
    }

    bb23: {
        _31 = ffi_result(move _32) -> [return: bb24, unwind: bb34];
    }

    bb24: {
        _30 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _31) -> [return: bb25, unwind: bb34];
    }

    bb25: {
        _38 = discriminant(_30);
        switchInt(move _38) -> [0: bb26, 1: bb27, otherwise: bb6];
    }

    bb26: {
        _40 = ((_30 as Continue).0: i32);
        _43 = _29;
        _42 = MaybeUninit::<*mut sd_journal>::assume_init(move _43) -> [return: bb29, unwind: bb34];
    }

    bb27: {
        _39 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Journal, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _39) -> [return: bb28, unwind: bb34];
    }

    bb28: {
        drop(_14) -> [return: bb32, unwind: bb36];
    }

    bb29: {
        _41 = <Journal as ForeignType>::from_ptr(move _42) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        _0 = std::result::Result::<Journal, std::io::Error>::Ok(move _41);
        drop(_14) -> [return: bb31, unwind: bb36];
    }

    bb31: {
        drop(_3) -> [return: bb33, unwind: bb39];
    }

    bb32: {
        drop(_3) -> [return: bb33, unwind: bb39];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_14) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_6) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_3) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        resume;
    }

    bb38 (cleanup): {
        drop(_1) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        switchInt(_44) -> [0: bb37, otherwise: bb38];
    }

    bb40: {
        goto -> bb3;
    }

    bb41: {
        goto -> bb12;
    }
}

fn journal::<impl at src/journal.rs:525:1: 525:13>::open(_1: JournalFiles, _2: bool, _3: bool) -> std::result::Result<Journal, std::io::Error> {
    debug files => _1;
    debug runtime_only => _2;
    debug local_only => _3;
    let mut _0: std::result::Result<journal::Journal, std::io::Error>;
    let mut _4: &journal::OpenOptions;
    let _5: &mut journal::OpenOptions;
    let mut _6: &mut journal::OpenOptions;
    let mut _7: &mut journal::OpenOptions;
    let mut _8: &mut journal::OpenOptions;
    let mut _9: journal::OpenOptions;
    let mut _10: i32;

    bb0: {
        _9 = <journal::OpenOptions as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _9;
        _10 = JournalFiles::as_flags(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = journal::OpenOptions::extra_raw_flags(move _8, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = journal::OpenOptions::local_only(_7, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = journal::OpenOptions::runtime_only(_6, _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = &(*_5);
        _0 = journal::OpenOptions::open(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::fd(_1: &JournalRef) -> std::result::Result<i32, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _8: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_get_fd(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<i32, std::io::Error>::Ok(_8);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<i32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::data_threshold(_1: &mut JournalRef) -> std::result::Result<usize, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<usize, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<usize>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: &journal::JournalRef;
    let mut _8: *mut usize;
    let mut _9: &mut std::mem::MaybeUninit<usize>;
    let mut _10: isize;
    let mut _13: usize;
    let mut _14: std::mem::MaybeUninit<usize>;
    scope 1 {
        debug curr_thresh => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<usize>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &(*_1);
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = MaybeUninit::<usize>::as_mut_ptr(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_journal_get_data_threshold(move _6, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_3 as Continue).0: i32);
        _14 = _2;
        _13 = MaybeUninit::<usize>::assume_init(move _14) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<usize, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<usize, std::io::Error>::Ok(move _13);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::set_data_threshold(_1: &mut JournalRef, _2: usize) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug new_theshold => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: &journal::JournalRef;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _10: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = sd_journal_set_data_threshold(move _6, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::get_data(_1: &mut JournalRef, _2: A) -> std::result::Result<Option<JournalEntryField<'_>>, std::io::Error> {
    debug self => _1;
    debug field => _2;
    let mut _0: std::result::Result<std::option::Option<journal::JournalEntryField<'_>>, std::io::Error>;
    let mut _3: std::mem::MaybeUninit<*mut u8>;
    let mut _6: A;
    let mut _7: std::result::Result<i32, std::io::Error>;
    let mut _8: i32;
    let mut _9: *mut ffi::journal::sd_journal;
    let mut _10: &journal::JournalRef;
    let mut _11: *const i8;
    let _12: &std::ffi::CStr;
    let mut _13: &<A as cstr_argument::CStrArgument>::Output;
    let mut _14: *mut *mut u8;
    let mut _15: &mut std::mem::MaybeUninit<*mut u8>;
    let mut _16: *mut usize;
    let mut _17: &mut std::mem::MaybeUninit<usize>;
    let mut _18: isize;
    let mut _19: std::option::Option<journal::JournalEntryField<'_>>;
    let mut _20: journal::JournalEntryField<'_>;
    let _21: &[u8];
    let mut _22: *const u8;
    let mut _23: *mut u8;
    let mut _24: std::mem::MaybeUninit<*mut u8>;
    let mut _25: usize;
    let mut _26: std::mem::MaybeUninit<usize>;
    let mut _29: bool;
    let mut _30: &std::io::ErrorKind;
    let _31: std::io::ErrorKind;
    let mut _32: std::option::Option<journal::JournalEntryField<'_>>;
    let mut _35: &std::io::Error;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: isize;
    let mut _39: isize;
    scope 1 {
        debug data => _3;
        let mut _4: std::mem::MaybeUninit<usize>;
        scope 2 {
            debug data_len => _4;
            let _5: <A as cstr_argument::CStrArgument>::Output;
            scope 3 {
                debug f => _5;
                let _27: &std::io::Error;
                let _28: &&std::io::Error;
                let _33: std::io::Error;
                let mut _34: &std::io::ErrorKind;
                scope 4 {
                }
                scope 5 {
                }
                scope 6 {
                    debug e => _27;
                    debug e => _28;
                }
                scope 7 {
                    debug e => _33;
                }
            }
        }
    }

    bb0: {
        _37 = const false;
        _36 = const false;
        _37 = const true;
        _3 = MaybeUninit::<*mut u8>::uninit() -> [return: bb1, unwind: bb34];
    }

    bb1: {
        _4 = MaybeUninit::<usize>::uninit() -> [return: bb2, unwind: bb34];
    }

    bb2: {
        _37 = const false;
        _6 = move _2;
        _5 = <A as CStrArgument>::into_cstr(move _6) -> [return: bb3, unwind: bb34];
    }

    bb3: {
        _10 = &(*_1);
        _9 = <JournalRef as ForeignTypeRef>::as_ptr(move _10) -> [return: bb4, unwind: bb25];
    }

    bb4: {
        _13 = &_5;
        _12 = <<A as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _13) -> [return: bb5, unwind: bb25];
    }

    bb5: {
        _11 = CStr::as_ptr(_12) -> [return: bb6, unwind: bb25];
    }

    bb6: {
        _15 = &mut _3;
        _14 = MaybeUninit::<*mut u8>::as_mut_ptr(move _15) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _17 = &mut _4;
        _16 = MaybeUninit::<usize>::as_mut_ptr(move _17) -> [return: bb8, unwind: bb25];
    }

    bb8: {
        _8 = sd_journal_get_data(move _9, move _11, move _14, move _16) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _7 = ffi_result(move _8) -> [return: bb10, unwind: bb25];
    }

    bb10: {
        _36 = const true;
        _18 = discriminant(_7);
        switchInt(move _18) -> [0: bb12, 1: bb17, otherwise: bb11];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _24 = _3;
        _23 = MaybeUninit::<*mut u8>::assume_init(move _24) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _22 = move _23 as *const u8 (PointerCoercion(MutToConstPointer));
        _26 = _4;
        _25 = MaybeUninit::<usize>::assume_init(move _26) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _21 = std::slice::from_raw_parts::<'_, u8>(move _22, move _25) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _20 = <&[u8] as Into<JournalEntryField<'_>>>::into(_21) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _19 = Option::<JournalEntryField<'_>>::Some(move _20);
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Ok(move _19);
        goto -> bb22;
    }

    bb17: {
        _27 = &((_7 as Err).0: std::io::Error);
        _28 = &_27;
        _35 = deref_copy (*_28);
        _31 = std::io::Error::kind(_35) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _30 = &_31;
        _34 = const _;
        _29 = <ErrorKind as PartialEq>::eq(move _30, _34) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        switchInt(move _29) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _32 = Option::<JournalEntryField<'_>>::None;
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Ok(move _32);
        goto -> bb22;
    }

    bb21: {
        _36 = const false;
        _33 = move ((_7 as Err).0: std::io::Error);
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Err(move _33);
        goto -> bb22;
    }

    bb22: {
        drop(_5) -> [return: bb23, unwind: bb32];
    }

    bb23: {
        _38 = discriminant(_7);
        switchInt(move _38) -> [1: bb28, otherwise: bb27];
    }

    bb24 (cleanup): {
        drop(_5) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_5) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        resume;
    }

    bb27: {
        _36 = const false;
        return;
    }

    bb28: {
        switchInt(_36) -> [0: bb27, otherwise: bb29];
    }

    bb29: {
        drop(((_7 as Err).0: std::io::Error)) -> [return: bb27, unwind: bb34];
    }

    bb30 (cleanup): {
        switchInt(_36) -> [0: bb34, otherwise: bb31];
    }

    bb31 (cleanup): {
        drop(((_7 as Err).0: std::io::Error)) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        _39 = discriminant(_7);
        switchInt(move _39) -> [1: bb30, otherwise: bb34];
    }

    bb33 (cleanup): {
        drop(_2) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        switchInt(_37) -> [0: bb26, otherwise: bb33];
    }
}

promoted[0] in journal::<impl at src/journal.rs:665:1: 665:16>::get_data: &ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = NotFound;
        _0 = &_1;
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::restart_data(_1: &mut JournalRef) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: *mut ffi::journal::sd_journal;
    let mut _3: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _3 = &(*_1);
        _2 = <JournalRef as ForeignTypeRef>::as_ptr(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = sd_journal_restart_data(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::enumerate_data(_1: &mut JournalRef) -> std::result::Result<Option<JournalEntryField<'_>>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<journal::JournalEntryField<'_>>, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<*const u8>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: &journal::JournalRef;
    let mut _8: *mut *const u8;
    let mut _9: &mut std::mem::MaybeUninit<*const u8>;
    let mut _10: *mut usize;
    let mut _11: &mut std::mem::MaybeUninit<usize>;
    let mut _12: isize;
    let mut _15: std::option::Option<journal::JournalEntryField<'_>>;
    let mut _17: *const u8;
    let mut _18: std::mem::MaybeUninit<*const u8>;
    let mut _19: usize;
    let mut _20: std::mem::MaybeUninit<usize>;
    let mut _21: std::option::Option<journal::JournalEntryField<'_>>;
    let mut _22: journal::JournalEntryField<'_>;
    scope 1 {
        debug data => _2;
        let mut _3: std::mem::MaybeUninit<usize>;
        scope 2 {
            debug data_len => _3;
            let _4: std::result::Result<i32, std::io::Error>;
            scope 3 {
                debug r => _4;
                let _13: std::io::Error;
                let _14: i32;
                scope 5 {
                    debug v => _14;
                    let _16: &[u8];
                    scope 8 {
                        debug b => _16;
                    }
                    scope 9 {
                    }
                }
                scope 6 {
                    debug e => _13;
                }
                scope 7 {
                    debug v => _14;
                }
            }
            scope 4 {
            }
        }
    }

    bb0: {
        _2 = MaybeUninit::<*const u8>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = MaybeUninit::<usize>::uninit() -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &(*_1);
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _2;
        _8 = MaybeUninit::<*const u8>::as_mut_ptr(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = &mut _3;
        _10 = MaybeUninit::<usize>::as_mut_ptr(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = sd_journal_enumerate_data(move _6, move _8, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _4 = ffi_result(move _5) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _14 = ((_4 as Ok).0: i32);
        switchInt(move _14) -> [0: bb11, otherwise: bb12];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _13 = move ((_4 as Err).0: std::io::Error);
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Err(move _13);
        goto -> bb17;
    }

    bb11: {
        _15 = Option::<JournalEntryField<'_>>::None;
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Ok(move _15);
        goto -> bb17;
    }

    bb12: {
        _18 = _2;
        _17 = MaybeUninit::<*const u8>::assume_init(move _18) -> [return: bb13, unwind continue];
    }

    bb13: {
        _20 = _3;
        _19 = MaybeUninit::<usize>::assume_init(move _20) -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = std::slice::from_raw_parts::<'_, u8>(move _17, move _19) -> [return: bb15, unwind continue];
    }

    bb15: {
        _22 = <&[u8] as Into<JournalEntryField<'_>>>::into(_16) -> [return: bb16, unwind continue];
    }

    bb16: {
        _21 = Option::<JournalEntryField<'_>>::Some(move _22);
        _0 = std::result::Result::<Option<JournalEntryField<'_>>, std::io::Error>::Ok(move _21);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::display_entry_data(_1: &mut JournalRef) -> DisplayEntryData<'_> {
    debug self => _1;
    let mut _0: journal::DisplayEntryData<'_>;

    bb0: {
        _0 = <&mut JournalRef as Into<DisplayEntryData<'_>>>::into(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::collect_entry(_1: &mut JournalRef) -> std::result::Result<BTreeMap<String, String>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::collections::BTreeMap<std::string::String, std::string::String>, std::io::Error>;
    let mut _2: std::collections::BTreeMap<std::string::String, std::string::String>;
    let _3: ();
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::option::Option<journal::JournalEntryField<'_>>>;
    let mut _5: std::result::Result<std::option::Option<journal::JournalEntryField<'_>>, std::io::Error>;
    let mut _6: isize;
    let mut _9: isize;
    let _11: std::option::Option<std::string::String>;
    let mut _12: &mut std::collections::BTreeMap<std::string::String, std::string::String>;
    let mut _13: std::string::String;
    let mut _14: std::borrow::Cow<'_, str>;
    let _15: &[u8];
    let mut _16: &journal::JournalEntryField<'_>;
    let mut _17: std::string::String;
    let mut _18: std::borrow::Cow<'_, str>;
    let _19: &[u8];
    let mut _20: std::option::Option<&[u8]>;
    let mut _21: &journal::JournalEntryField<'_>;
    let mut _22: std::collections::BTreeMap<std::string::String, std::string::String>;
    let mut _23: bool;
    scope 1 {
        debug ret => _2;
        scope 2 {
            debug d => _10;
            let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _8: std::option::Option<journal::JournalEntryField<'_>>;
            let _10: journal::JournalEntryField<'_>;
            scope 3 {
                debug residual => _7;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _8;
                scope 6 {
                }
            }
        }
    }

    bb0: {
        _23 = const false;
        _2 = BTreeMap::<String, String>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = JournalRef::restart_data(_1) -> [return: bb24, unwind: bb20];
    }

    bb2: {
        _5 = JournalRef::enumerate_data(_1) -> [return: bb3, unwind: bb20];
    }

    bb3: {
        _4 = <std::result::Result<Option<JournalEntryField<'_>>, std::io::Error> as Try>::branch(move _5) -> [return: bb4, unwind: bb20];
    }

    bb4: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = move ((_4 as Continue).0: std::option::Option<journal::JournalEntryField<'_>>);
        _9 = discriminant(_8);
        switchInt(move _9) -> [1: bb10, otherwise: bb9];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<BTreeMap<String, String>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb8, unwind: bb20];
    }

    bb8: {
        drop(_2) -> [return: bb19, unwind continue];
    }

    bb9: {
        _22 = move _2;
        _0 = std::result::Result::<BTreeMap<String, String>, std::io::Error>::Ok(move _22);
        goto -> bb19;
    }

    bb10: {
        _10 = move ((_8 as Some).0: journal::JournalEntryField<'_>);
        _12 = &mut _2;
        _16 = &_10;
        _15 = JournalEntryField::<'_>::name(move _16) -> [return: bb11, unwind: bb20];
    }

    bb11: {
        _14 = String::from_utf8_lossy(_15) -> [return: bb12, unwind: bb20];
    }

    bb12: {
        _13 = <Cow<'_, str> as Into<String>>::into(move _14) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _23 = const true;
        _21 = &_10;
        _20 = JournalEntryField::<'_>::value(move _21) -> [return: bb14, unwind: bb23];
    }

    bb14: {
        _19 = Option::<&[u8]>::unwrap(move _20) -> [return: bb15, unwind: bb23];
    }

    bb15: {
        _18 = String::from_utf8_lossy(_19) -> [return: bb16, unwind: bb23];
    }

    bb16: {
        _17 = <Cow<'_, str> as Into<String>>::into(move _18) -> [return: bb17, unwind: bb23];
    }

    bb17: {
        _23 = const false;
        _11 = BTreeMap::<String, String>::insert(move _12, move _13, move _17) -> [return: bb18, unwind: bb23];
    }

    bb18: {
        _23 = const false;
        drop(_11) -> [return: bb2, unwind: bb20];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_2) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }

    bb22 (cleanup): {
        drop(_13) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_23) -> [0: bb20, otherwise: bb22];
    }

    bb24: {
        goto -> bb2;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::next(_1: &mut JournalRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: std::result::Result<i32, std::io::Error>;
    let mut _3: i32;
    let mut _4: *mut ffi::journal::sd_journal;
    let mut _5: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _5 = &(*_1);
        _4 = <JournalRef as ForeignTypeRef>::as_ptr(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = sd_journal_next(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = ffi_result(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<i32, std::io::Error>::map::<u64, {closure@src/journal.rs:804:18: 804:21}>(move _2, const ZeroSized: {closure@src/journal.rs:804:18: 804:21}) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::next::{closure#0}(_1: {closure@src/journal.rs:804:18: 804:21}, _2: i32) -> u64 {
    debug v => _2;
    let mut _0: u64;
    let mut _3: std::result::Result<u64, std::num::TryFromIntError>;

    bb0: {
        _3 = <i32 as TryInto<u64>>::try_into(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<u64, TryFromIntError>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::next_skip(_1: &mut JournalRef, _2: u64) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    debug skip_count => _2;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_next_skip(move _5, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<i32, std::io::Error>::map::<u64, {closure@src/journal.rs:812:18: 812:21}>(move _3, const ZeroSized: {closure@src/journal.rs:812:18: 812:21}) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::next_skip::{closure#0}(_1: {closure@src/journal.rs:812:18: 812:21}, _2: i32) -> u64 {
    debug v => _2;
    let mut _0: u64;
    let mut _3: std::result::Result<u64, std::num::TryFromIntError>;

    bb0: {
        _3 = <i32 as TryInto<u64>>::try_into(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<u64, TryFromIntError>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::previous(_1: &mut JournalRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: std::result::Result<i32, std::io::Error>;
    let mut _3: i32;
    let mut _4: *mut ffi::journal::sd_journal;
    let mut _5: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _5 = &(*_1);
        _4 = <JournalRef as ForeignTypeRef>::as_ptr(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = sd_journal_previous(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = ffi_result(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<i32, std::io::Error>::map::<u64, {closure@src/journal.rs:820:18: 820:21}>(move _2, const ZeroSized: {closure@src/journal.rs:820:18: 820:21}) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::previous::{closure#0}(_1: {closure@src/journal.rs:820:18: 820:21}, _2: i32) -> u64 {
    debug v => _2;
    let mut _0: u64;
    let mut _3: std::result::Result<u64, std::num::TryFromIntError>;

    bb0: {
        _3 = <i32 as TryInto<u64>>::try_into(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<u64, TryFromIntError>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::previous_skip(_1: &mut JournalRef, _2: u64) -> std::result::Result<usize, std::io::Error> {
    debug self => _1;
    debug skip_count => _2;
    let mut _0: std::result::Result<usize, std::io::Error>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_previous_skip(move _5, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<i32, std::io::Error>::map::<usize, {closure@src/journal.rs:828:18: 828:21}>(move _3, const ZeroSized: {closure@src/journal.rs:828:18: 828:21}) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::previous_skip::{closure#0}(_1: {closure@src/journal.rs:828:18: 828:21}, _2: i32) -> usize {
    debug v => _2;
    let mut _0: usize;
    let mut _3: std::result::Result<usize, std::num::TryFromIntError>;

    bb0: {
        _3 = <i32 as TryInto<usize>>::try_into(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<usize, TryFromIntError>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::next_entry(_1: &mut JournalRef) -> std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, u64>;
    let mut _3: std::result::Result<u64, std::io::Error>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _6: u64;
    let mut _7: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    let mut _8: std::result::Result<std::collections::BTreeMap<std::string::String, std::string::String>, std::io::Error>;
    scope 1 {
        debug residual => _5;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _6;
        scope 4 {
        }
    }

    bb0: {
        _3 = JournalRef::next(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<u64, std::io::Error> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: u64);
        switchInt(move _6) -> [0: bb8, otherwise: bb9];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _5) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<BTreeMap<String, String>, std::io::Error>::map::<Option<BTreeMap<String, String>>, fn(BTreeMap<String, String>) -> Option<BTreeMap<String, String>> {Option::<BTreeMap<String, String>>::Some}>(move _8, Option::<BTreeMap<String, String>>::Some) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8: {
        _7 = Option::<BTreeMap<String, String>>::None;
        _0 = std::result::Result::<Option<BTreeMap<String, String>>, std::io::Error>::Ok(move _7);
        goto -> bb7;
    }

    bb9: {
        _8 = JournalRef::collect_entry(_1) -> [return: bb6, unwind continue];
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::previous_entry(_1: &mut JournalRef) -> std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, u64>;
    let mut _3: std::result::Result<u64, std::io::Error>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _6: u64;
    let mut _7: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    let mut _8: std::result::Result<std::collections::BTreeMap<std::string::String, std::string::String>, std::io::Error>;
    scope 1 {
        debug residual => _5;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _6;
        scope 4 {
        }
    }

    bb0: {
        _3 = JournalRef::previous(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<u64, std::io::Error> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: u64);
        switchInt(move _6) -> [0: bb8, otherwise: bb9];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _5) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<BTreeMap<String, String>, std::io::Error>::map::<Option<BTreeMap<String, String>>, fn(BTreeMap<String, String>) -> Option<BTreeMap<String, String>> {Option::<BTreeMap<String, String>>::Some}>(move _8, Option::<BTreeMap<String, String>>::Some) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8: {
        _7 = Option::<BTreeMap<String, String>>::None;
        _0 = std::result::Result::<Option<BTreeMap<String, String>>, std::io::Error>::Ok(move _7);
        goto -> bb7;
    }

    bb9: {
        _8 = JournalRef::collect_entry(_1) -> [return: bb6, unwind continue];
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::wait(_1: &mut JournalRef, _2: Option<Duration>) -> std::result::Result<JournalWaitResult, std::io::Error> {
    debug self => _1;
    debug wait_time => _2;
    let mut _0: std::result::Result<journal::JournalWaitResult, std::io::Error>;
    let _3: u64;
    let mut _4: std::option::Option<u64>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _6: std::result::Result<i32, std::io::Error>;
    let mut _7: i32;
    let mut _8: *mut ffi::journal::sd_journal;
    let mut _9: &journal::JournalRef;
    let mut _10: isize;
    let mut _13: journal::JournalWaitResult;
    let mut _14: journal::JournalWaitResult;
    let mut _15: journal::JournalWaitResult;
    let mut _16: std::io::Error;
    let mut _17: std::io::ErrorKind;
    scope 1 {
        debug time => _3;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = Option::<Duration>::map::<u64, fn(Duration) -> u64 {usec_from_duration}>(_2, usec_from_duration) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Option::<u64>::unwrap_or(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &(*_1);
        _8 = <JournalRef as ForeignTypeRef>::as_ptr(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = sd_journal_wait(move _8, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = ffi_result(move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_5 as Continue).0: i32);
        switchInt(_12) -> [0: bb11, 1: bb12, 2: bb13, otherwise: bb10];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<JournalWaitResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb15, unwind continue];
    }

    bb10: {
        _17 = InvalidData;
        _16 = std::io::Error::new::<&str>(move _17, const "Failed to wait for changes") -> [return: bb14, unwind continue];
    }

    bb11: {
        _13 = JournalWaitResult::Nop;
        _0 = std::result::Result::<JournalWaitResult, std::io::Error>::Ok(move _13);
        goto -> bb15;
    }

    bb12: {
        _14 = JournalWaitResult::Append;
        _0 = std::result::Result::<JournalWaitResult, std::io::Error>::Ok(move _14);
        goto -> bb15;
    }

    bb13: {
        _15 = JournalWaitResult::Invalidate;
        _0 = std::result::Result::<JournalWaitResult, std::io::Error>::Ok(move _15);
        goto -> bb15;
    }

    bb14: {
        _0 = std::result::Result::<JournalWaitResult, std::io::Error>::Err(move _16);
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::await_next_entry(_1: &mut JournalRef, _2: Option<Duration>) -> std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> {
    debug self => _1;
    debug wait_time => _2;
    let mut _0: std::result::Result<std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>, std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, journal::JournalWaitResult>;
    let mut _4: std::result::Result<journal::JournalWaitResult, std::io::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _7: journal::JournalWaitResult;
    let mut _8: isize;
    let mut _9: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    scope 1 {
        debug residual => _6;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _7;
        scope 4 {
        }
    }

    bb0: {
        _4 = JournalRef::wait(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<JournalWaitResult, std::io::Error> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: journal::JournalWaitResult);
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb7, 1: bb8, 2: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _6) -> [return: bb9, unwind continue];
    }

    bb6: {
        _0 = JournalRef::next_entry(_1) -> [return: bb9, unwind continue];
    }

    bb7: {
        _9 = Option::<BTreeMap<String, String>>::None;
        _0 = std::result::Result::<Option<BTreeMap<String, String>>, std::io::Error>::Ok(move _9);
        goto -> bb9;
    }

    bb8: {
        _0 = JournalRef::next_entry(_1) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::watch_all_elements(_1: &mut JournalRef, _2: F) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>>;
    let mut _5: std::result::Result<std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>, std::io::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _8: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    let mut _10: isize;
    let mut _12: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>>;
    let mut _14: std::result::Result<std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>, std::io::Error>;
    let mut _15: std::option::Option<std::time::Duration>;
    let mut _16: isize;
    let mut _19: isize;
    let mut _21: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _22: std::result::Result<(), std::io::Error>;
    let mut _23: &mut F;
    let mut _24: (std::collections::BTreeMap<std::string::String, std::string::String>,);
    let mut _25: std::collections::BTreeMap<std::string::String, std::string::String>;
    let mut _26: isize;
    let mut _28: bool;
    let mut _29: isize;
    scope 1 {
        debug candidate => _3;
        let _9: std::collections::BTreeMap<std::string::String, std::string::String>;
        let _11: std::collections::BTreeMap<std::string::String, std::string::String>;
        scope 6 {
            debug rec => _9;
            let _27: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 13 {
                debug residual => _27;
                scope 14 {
                }
            }
            scope 15 {
                debug val => const ();
                scope 16 {
                }
            }
        }
        scope 7 {
            debug rec => _11;
        }
        scope 8 {
            debug r => _20;
            let _17: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _18: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>;
            let _20: std::collections::BTreeMap<std::string::String, std::string::String>;
            scope 9 {
                debug residual => _17;
                scope 10 {
                }
            }
            scope 11 {
                debug val => _18;
                scope 12 {
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _28 = const false;
        goto -> bb1;
    }

    bb1: {
        _5 = JournalRef::next_entry(_1) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _4 = <std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> as Try>::branch(move _5) -> [return: bb3, unwind: bb24];
    }

    bb3: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _8 = move ((_4 as Continue).0: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>);
        _28 = const true;
        _3 = move _8;
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb8, 1: bb7, otherwise: bb5];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb29, unwind: bb24];
    }

    bb7: {
        _28 = const false;
        _11 = move ((_3 as Some).0: std::collections::BTreeMap<std::string::String, std::string::String>);
        _9 = move _11;
        goto -> bb15;
    }

    bb8: {
        _15 = Option::<Duration>::None;
        _14 = JournalRef::await_next_entry(_1, move _15) -> [return: bb9, unwind: bb28];
    }

    bb9: {
        _13 = <std::result::Result<Option<BTreeMap<String, String>>, std::io::Error> as Try>::branch(move _14) -> [return: bb10, unwind: bb28];
    }

    bb10: {
        _16 = discriminant(_13);
        switchInt(move _16) -> [0: bb11, 1: bb12, otherwise: bb5];
    }

    bb11: {
        _18 = move ((_13 as Continue).0: std::option::Option<std::collections::BTreeMap<std::string::String, std::string::String>>);
        _12 = move _18;
        _19 = discriminant(_12);
        switchInt(move _19) -> [1: bb14, otherwise: bb13];
    }

    bb12: {
        _17 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _17) -> [return: bb30, unwind: bb28];
    }

    bb13: {
        drop(_12) -> [return: bb8, unwind: bb28];
    }

    bb14: {
        _20 = move ((_12 as Some).0: std::collections::BTreeMap<std::string::String, std::string::String>);
        _9 = move _20;
        goto -> bb15;
    }

    bb15: {
        _23 = &mut _2;
        _25 = move _9;
        _24 = (move _25,);
        _22 = <F as FnMut<(BTreeMap<String, String>,)>>::call_mut(move _23, move _24) -> [return: bb16, unwind: bb28];
    }

    bb16: {
        _21 = <std::result::Result<(), std::io::Error> as Try>::branch(move _22) -> [return: bb17, unwind: bb28];
    }

    bb17: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb18, 1: bb19, otherwise: bb5];
    }

    bb18: {
        _28 = const false;
        goto -> bb1;
    }

    bb19: {
        _27 = move ((_21 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _27) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        _28 = const false;
        goto -> bb22;
    }

    bb21: {
        _28 = const false;
        goto -> bb22;
    }

    bb22: {
        drop(_2) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26 (cleanup): {
        switchInt(_28) -> [0: bb24, otherwise: bb27];
    }

    bb27 (cleanup): {
        drop(((_3 as Some).0: std::collections::BTreeMap<std::string::String, std::string::String>)) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        _29 = discriminant(_3);
        switchInt(move _29) -> [1: bb26, otherwise: bb24];
    }

    bb29: {
        goto -> bb21;
    }

    bb30: {
        goto -> bb21;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek_head(_1: &mut JournalRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _9: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_seek_head(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek_tail(_1: &mut JournalRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _9: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_seek_tail(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek_monotonic_usec(_1: &mut JournalRef, _2: Id128, _3: u64) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug boot_id => _2;
    debug usec => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::journal::sd_journal;
    let mut _8: &journal::JournalRef;
    let mut _9: ffi::id128::sd_id128_t;
    let mut _10: &ffi::id128::sd_id128_t;
    let mut _11: &id128::Id128;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _14: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _8 = &(*_1);
        _7 = <JournalRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = &_2;
        _10 = Id128::as_raw(move _11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = (*_10);
        _6 = sd_journal_seek_monotonic_usec(move _7, move _9, _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _14 = ((_4 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek_realtime_usec(_1: &mut JournalRef, _2: u64) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug usec => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: &journal::JournalRef;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _10: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = sd_journal_seek_realtime_usec(move _6, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _10 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek_cursor(_1: &mut JournalRef, _2: A) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug cursor => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: <A as cstr_argument::CStrArgument>::Output;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::journal::sd_journal;
    let mut _8: &journal::JournalRef;
    let mut _9: *const i8;
    let _10: &std::ffi::CStr;
    let mut _11: &<A as cstr_argument::CStrArgument>::Output;
    let mut _12: isize;
    scope 1 {
        debug c => _3;
        let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _14: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _13;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _14;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = <A as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &(*_1);
        _7 = <JournalRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _11 = &_3;
        _10 = <<A as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _11) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _9 = CStr::as_ptr(_10) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _6 = sd_journal_seek_cursor(move _7, move _9) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _5 = ffi_result(move _6) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _14 = ((_4 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        drop(_3) -> [return: bb12, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        drop(_3) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::seek(_1: &mut JournalRef, _2: JournalSeek) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug seek => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: isize;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _5: std::result::Result<(), std::io::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _9: std::result::Result<(), std::io::Error>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _12: id128::Id128;
    let _13: u64;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _15: std::result::Result<(), std::io::Error>;
    let mut _16: isize;
    let _18: u64;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _20: std::result::Result<(), std::io::Error>;
    let mut _21: isize;
    let _23: std::string::String;
    let mut _24: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _25: std::result::Result<(), std::io::Error>;
    let mut _26: isize;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => const ();
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _11;
        scope 6 {
        }
    }
    scope 7 {
        debug val => const ();
        scope 8 {
        }
    }
    scope 9 {
        debug boot_id => _12;
        debug usec => _13;
        let _17: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 10 {
            debug residual => _17;
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
    }
    scope 14 {
        debug usec => _18;
        let _22: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 15 {
            debug residual => _22;
            scope 16 {
            }
        }
        scope 17 {
            debug val => const ();
            scope 18 {
            }
        }
    }
    scope 19 {
        debug cursor => _23;
        let _27: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 20 {
            debug residual => _27;
            scope 21 {
            }
        }
        scope 22 {
            debug val => const ();
            scope 23 {
            }
        }
    }

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb7, 2: bb11, 3: bb15, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _23 = move ((_2 as Cursor).0: std::string::String);
        _25 = JournalRef::seek_cursor::<String>(_1, move _23) -> [return: bb19, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = JournalRef::seek_head(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<(), std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb22, 1: bb6, otherwise: bb2];
    }

    bb6: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb23, unwind continue];
    }

    bb7: {
        _9 = JournalRef::seek_tail(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = <std::result::Result<(), std::io::Error> as Try>::branch(move _9) -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb22, 1: bb10, otherwise: bb2];
    }

    bb10: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb23, unwind continue];
    }

    bb11: {
        _12 = ((_2 as ClockMonotonic).0: id128::Id128);
        _13 = ((_2 as ClockMonotonic).1: u64);
        _15 = JournalRef::seek_monotonic_usec(_1, _12, _13) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = <std::result::Result<(), std::io::Error> as Try>::branch(move _15) -> [return: bb13, unwind continue];
    }

    bb13: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [0: bb22, 1: bb14, otherwise: bb2];
    }

    bb14: {
        _17 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _17) -> [return: bb23, unwind continue];
    }

    bb15: {
        _18 = ((_2 as ClockRealtime).0: u64);
        _20 = JournalRef::seek_realtime_usec(_1, _18) -> [return: bb16, unwind continue];
    }

    bb16: {
        _19 = <std::result::Result<(), std::io::Error> as Try>::branch(move _20) -> [return: bb17, unwind continue];
    }

    bb17: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb22, 1: bb18, otherwise: bb2];
    }

    bb18: {
        _22 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _22) -> [return: bb23, unwind continue];
    }

    bb19: {
        _24 = <std::result::Result<(), std::io::Error> as Try>::branch(move _25) -> [return: bb20, unwind continue];
    }

    bb20: {
        _26 = discriminant(_24);
        switchInt(move _26) -> [0: bb22, 1: bb21, otherwise: bb2];
    }

    bb21: {
        _27 = move ((_24 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _27) -> [return: bb23, unwind continue];
    }

    bb22: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb23;
    }

    bb23: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::cursor(_1: &JournalRef) -> std::result::Result<String, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _2: *const i8;
    let mut _3: *mut i8;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::journal::sd_journal;
    let mut _8: *mut *const i8;
    let mut _9: &mut *const i8;
    let mut _10: isize;
    let mut _14: std::option::Option<std::string::String>;
    let mut _15: *mut i8;
    let mut _16: *const i8;
    scope 1 {
        debug c_cursor => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        let _13: std::string::String;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
        scope 7 {
            debug cursor => _13;
        }
        scope 8 {
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = move _3 as *const i8 (PointerCoercion(MutToConstPointer));
        _7 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = &raw mut (*_9);
        _6 = sd_journal_get_cursor(move _7, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_4 as Continue).0: i32);
        _16 = _2;
        _15 = move _16 as *mut i8 (PtrToPtr);
        _14 = free_cstring(_15) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb11, unwind continue];
    }

    bb9: {
        _13 = Option::<String>::unwrap(move _14) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _13);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::test_cursor(_1: &JournalRef, _2: A) -> std::result::Result<bool, std::io::Error> {
    debug self => _1;
    debug cursor => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _3: <A as cstr_argument::CStrArgument>::Output;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: *const i8;
    let _8: &std::ffi::CStr;
    let mut _9: &<A as cstr_argument::CStrArgument>::Output;
    scope 1 {
        debug c => _3;
        scope 2 {
        }
    }

    bb0: {
        _3 = <A as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _9 = &_3;
        _8 = <<A as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _9) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _7 = CStr::as_ptr(_8) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _5 = sd_journal_test_cursor(move _6, move _7) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _4 = ffi_result(move _5) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _0 = std::result::Result::<i32, std::io::Error>::map::<bool, {closure@src/journal.rs:987:14: 987:17}>(move _4, const ZeroSized: {closure@src/journal.rs:987:14: 987:17}) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        drop(_3) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_3) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::test_cursor::{closure#0}(_1: {closure@src/journal.rs:987:14: 987:17}, _2: i32) -> bool {
    debug v => _2;
    let mut _0: bool;

    bb0: {
        _0 = Ne(_2, const 0_i32);
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::timestamp(_1: &JournalRef) -> std::result::Result<SystemTime, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: std::time::SystemTime;
    let mut _13: u64;
    scope 1 {
        debug timestamp_us => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_journal_get_realtime_usec(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = system_time_from_realtime_usec(move _13) -> [return: bb8, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SystemTime, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = std::result::Result::<SystemTime, std::io::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::monotonic_timestamp(_1: &JournalRef) -> std::result::Result<(u64, Id128), std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(u64, id128::Id128), std::io::Error>;
    let mut _2: u64;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::journal::sd_journal;
    let mut _8: *mut u64;
    let mut _9: &mut u64;
    let mut _10: *mut ffi::id128::sd_id128_t;
    let mut _11: &mut ffi::id128::sd_id128_t;
    let mut _12: isize;
    let mut _15: (u64, id128::Id128);
    let mut _16: u64;
    let mut _17: id128::Id128;
    scope 1 {
        debug monotonic_timestamp_us => _2;
        let mut _3: id128::Id128;
        scope 2 {
            debug id => _3;
            let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _14: i32;
            scope 3 {
            }
            scope 4 {
                debug residual => _13;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _14;
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _3 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = &raw mut (*_9);
        _11 = &mut (_3.0: ffi::id128::sd_id128_t);
        _10 = &raw mut (*_11);
        _6 = sd_journal_get_monotonic_usec(move _7, move _8, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _14 = ((_4 as Continue).0: i32);
        _16 = _2;
        _17 = _3;
        _15 = (move _16, move _17);
        _0 = std::result::Result::<(u64, Id128), std::io::Error>::Ok(move _15);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(u64, Id128), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::monotonic_timestamp_current_boot(_1: &JournalRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::journal::sd_journal;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: *mut ffi::id128::sd_id128_t;
    let mut _10: isize;
    let mut _13: u64;
    scope 1 {
        debug monotonic_timestamp_us => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = <JournalRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _9 = null_mut::<sd_id128_t>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = sd_journal_get_monotonic_usec(move _6, move _7, move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_3 as Continue).0: i32);
        _13 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _13);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::match_add(_1: &mut JournalRef, _2: &str, _3: T) -> std::result::Result<&mut JournalRef, std::io::Error> {
    debug self => _1;
    debug key => _2;
    debug val => _3;
    let mut _0: std::result::Result<&mut journal::JournalRef, std::io::Error>;
    let mut _4: std::vec::Vec<u8>;
    let _5: ();
    let mut _6: &mut std::vec::Vec<u8>;
    let _7: ();
    let mut _8: &mut std::vec::Vec<u8>;
    let mut _9: std::vec::Vec<u8>;
    let mut _10: T;
    let mut _12: *const u8;
    let mut _13: &std::vec::Vec<u8>;
    let mut _15: &std::vec::Vec<u8>;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _17: std::result::Result<i32, std::io::Error>;
    let mut _18: i32;
    let mut _19: *mut ffi::journal::sd_journal;
    let mut _20: &journal::JournalRef;
    let mut _21: isize;
    let mut _24: bool;
    scope 1 {
        debug filter => _4;
        let _11: *const libc::c_void;
        scope 2 {
            debug data => _11;
            let _14: usize;
            scope 3 {
                debug datalen => _14;
                let _22: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _23: i32;
                scope 4 {
                }
                scope 5 {
                    debug residual => _22;
                    scope 6 {
                    }
                }
                scope 7 {
                    debug val => _23;
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _24 = const false;
        _24 = const true;
        _4 = <Vec<u8> as From<&str>>::from(_2) -> [return: bb1, unwind: bb19];
    }

    bb1: {
        _6 = &mut _4;
        _5 = Vec::<u8>::push(move _6, const 61_u8) -> [return: bb2, unwind: bb16];
    }

    bb2: {
        _8 = &mut _4;
        _24 = const false;
        _10 = move _3;
        _9 = <T as Into<Vec<u8>>>::into(move _10) -> [return: bb3, unwind: bb16];
    }

    bb3: {
        _7 = <Vec<u8> as Extend<u8>>::extend::<Vec<u8>>(move _8, move _9) -> [return: bb4, unwind: bb16];
    }

    bb4: {
        _13 = &_4;
        _12 = Vec::<u8>::as_ptr(move _13) -> [return: bb5, unwind: bb16];
    }

    bb5: {
        _11 = move _12 as *const libc::c_void (PtrToPtr);
        _15 = &_4;
        _14 = Vec::<u8>::len(move _15) -> [return: bb6, unwind: bb16];
    }

    bb6: {
        _20 = &(*_1);
        _19 = <JournalRef as ForeignTypeRef>::as_ptr(move _20) -> [return: bb7, unwind: bb16];
    }

    bb7: {
        _18 = sd_journal_add_match(move _19, _11, _14) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _17 = ffi_result(move _18) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _16 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _17) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _21 = discriminant(_16);
        switchInt(move _21) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _23 = ((_16 as Continue).0: i32);
        _0 = std::result::Result::<&mut JournalRef, std::io::Error>::Ok(_1);
        drop(_4) -> [return: bb15, unwind: bb19];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _22 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&mut JournalRef, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _22) -> [return: bb14, unwind: bb16];
    }

    bb14: {
        drop(_4) -> [return: bb15, unwind: bb19];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_4) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_24) -> [0: bb17, otherwise: bb18];
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::match_or(_1: &mut JournalRef) -> std::result::Result<&mut JournalRef, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&mut journal::JournalRef, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _9: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_add_disjunction(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<&mut JournalRef, std::io::Error>::Ok(_1);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&mut JournalRef, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::match_and(_1: &mut JournalRef) -> std::result::Result<&mut JournalRef, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&mut journal::JournalRef, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::journal::sd_journal;
    let mut _6: &journal::JournalRef;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _9: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = <JournalRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_journal_add_conjunction(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<&mut JournalRef, std::io::Error>::Ok(_1);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&mut JournalRef, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn journal::<impl at src/journal.rs:665:1: 665:16>::match_flush(_1: &mut JournalRef) -> std::result::Result<&mut JournalRef, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&mut journal::JournalRef, std::io::Error>;
    let _2: ();
    let mut _3: *mut ffi::journal::sd_journal;
    let mut _4: &journal::JournalRef;
    scope 1 {
    }

    bb0: {
        _4 = &(*_1);
        _3 = <JournalRef as ForeignTypeRef>::as_ptr(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_journal_flush_matches(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = std::result::Result::<&mut JournalRef, std::io::Error>::Ok(_1);
        return;
    }
}

fn journal::<impl at src/journal.rs:1057:1: 1057:28>::as_raw_fd(_1: &JournalRef) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: std::result::Result<i32, std::io::Error>;

    bb0: {
        _2 = JournalRef::fd(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<i32, std::io::Error>::unwrap(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

const LISTEN_FDS_START: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 3_i32;
        return;
    }
}

const STATE_READY: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "READY";
        return;
    }
}

const STATE_RELOADING: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "RELOADING";
        return;
    }
}

const STATE_STOPPING: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "STOPPING";
        return;
    }
}

const STATE_STATUS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "STATUS";
        return;
    }
}

const STATE_ERRNO: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "ERRNO";
        return;
    }
}

const STATE_BUSERROR: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "BUSERROR";
        return;
    }
}

const STATE_MAINPID: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "MAINPID";
        return;
    }
}

const STATE_WATCHDOG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "WATCHDOG";
        return;
    }
}

const STATE_WATCHDOG_USEC: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "WATCHDOG_USEC";
        return;
    }
}

const STATE_EXTEND_TIMEOUT_USEC: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "EXTEND_TIMEOUT_USEC";
        return;
    }
}

const STATE_FDSTORE: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "FDSTORE";
        return;
    }
}

const STATE_FDSTOREREMOVE: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "FDSTOREREMOVE";
        return;
    }
}

const STATE_FDNAME: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "FDNAME";
        return;
    }
}

fn daemon::<impl at src/daemon.rs:68:10: 68:15>::fmt(_1: &ListenFds, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&i32;
    let _7: &i32;

    bb0: {
        _3 = const "ListenFds";
        _4 = const "num_fds";
        _7 = &((*_1).0: i32);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn daemon::<impl at src/daemon.rs:73:1: 73:15>::new(_1: bool) -> std::result::Result<ListenFds, std::io::Error> {
    debug unset_environment => _1;
    let mut _0: std::result::Result<daemon::ListenFds, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _7: i32;
    let _8: ();
    let _9: ();
    let _10: ();
    let mut _11: daemon::ListenFds;
    scope 1 {
        debug num_fds => _7;
    }
    scope 2 {
    }
    scope 3 {
        debug residual => _6;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _7;
        scope 6 {
        }
    }

    bb0: {
        _4 = sd_listen_fds(const 0_i32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = ffi_result(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = ((_2 as Continue).0: i32);
        switchInt(_1) -> [0: bb10, otherwise: bb7];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<ListenFds, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _6) -> [return: bb11, unwind continue];
    }

    bb7: {
        _8 = remove_var::<&str>(const "LISTEN_FDS") -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = remove_var::<&str>(const "LISTEN_PID") -> [return: bb9, unwind continue];
    }

    bb9: {
        _10 = remove_var::<&str>(const "LISTEN_FDNAMES") -> [return: bb10, unwind continue];
    }

    bb10: {
        _11 = ListenFds { num_fds: _7 };
        _0 = std::result::Result::<ListenFds, std::io::Error>::Ok(move _11);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn daemon::<impl at src/daemon.rs:73:1: 73:15>::len(_1: &ListenFds) -> i32 {
    debug self => _1;
    let mut _0: i32;

    bb0: {
        _0 = ((*_1).0: i32);
        return;
    }
}

fn daemon::<impl at src/daemon.rs:73:1: 73:15>::is_empty(_1: &ListenFds) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: i32;

    bb0: {
        _2 = ListenFds::len(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Eq(move _2, const 0_i32);
        return;
    }
}

fn daemon::<impl at src/daemon.rs:73:1: 73:15>::iter(_1: &ListenFds) -> ListenFdsRange {
    debug self => _1;
    let mut _0: daemon::ListenFdsRange;
    let mut _2: i32;

    bb0: {
        _2 = ((*_1).0: i32);
        _0 = ListenFdsRange { current: const 0_i32, num_fds: move _2 };
        return;
    }
}

fn daemon::<impl at src/daemon.rs:106:10: 106:15>::clone(_1: &ListenFdsRange) -> ListenFdsRange {
    debug self => _1;
    let mut _0: daemon::ListenFdsRange;
    let mut _2: i32;
    let _3: &i32;
    let mut _4: i32;
    let _5: &i32;

    bb0: {
        _3 = &((*_1).0: i32);
        _2 = (*_3);
        _5 = &((*_1).1: i32);
        _4 = (*_5);
        _0 = ListenFdsRange { current: move _2, num_fds: move _4 };
        return;
    }
}

fn daemon::<impl at src/daemon.rs:106:17: 106:22>::fmt(_1: &ListenFdsRange, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &i32;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&i32;
    let _10: &i32;

    bb0: {
        _3 = const "ListenFdsRange";
        _4 = const "current";
        _6 = &((*_1).0: i32);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "num_fds";
        _10 = &((*_1).1: i32);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn daemon::<impl at src/daemon.rs:112:1: 112:33>::next(_1: &mut ListenFdsRange) -> Option<i32> {
    debug self => _1;
    let mut _0: std::option::Option<i32>;
    let mut _2: bool;
    let mut _3: i32;
    let mut _4: i32;
    let _5: i32;
    let mut _6: i32;
    let mut _7: (i32, bool);
    let mut _8: (i32, bool);
    scope 1 {
        debug fd => _5;
    }

    bb0: {
        _3 = ((*_1).0: i32);
        _4 = ((*_1).1: i32);
        _2 = Lt(move _3, move _4);
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _6 = ((*_1).0: i32);
        _7 = CheckedAdd(const _, _6);
        assert(!move (_7.1: bool), "attempt to compute `{} + {}`, which would overflow", const _, move _6) -> [success: bb2, unwind continue];
    }

    bb2: {
        _5 = move (_7.0: i32);
        _8 = CheckedAdd(((*_1).0: i32), const 1_i32);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", ((*_1).0: i32), const 1_i32) -> [success: bb3, unwind continue];
    }

    bb3: {
        ((*_1).0: i32) = move (_8.0: i32);
        _0 = Option::<i32>::Some(_5);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<i32>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn listen_fds(_1: bool) -> std::result::Result<ListenFds, std::io::Error> {
    debug unset_environment => _1;
    let mut _0: std::result::Result<daemon::ListenFds, std::io::Error>;

    bb0: {
        _0 = ListenFds::new(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn daemon::is_fifo(_1: i32, _2: Option<S>) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug path => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _3: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *const i8;
    let mut _8: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _9: *const i8;
    let mut _10: isize;
    let mut _13: bool;
    let mut _14: bool;
    scope 1 {
        debug path => _3;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
            debug result => _12;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _11;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _12;
            scope 7 {
            }
        }
    }

    bb0: {
        _14 = const false;
        _3 = Option::<S>::map::<<S as CStrArgument>::Output, {closure@src/daemon.rs:136:25: 136:28}>(move _2, const ZeroSized: {closure@src/daemon.rs:136:25: 136:28}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = const true;
        _8 = move _3;
        _9 = null::<i8>() -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _14 = const false;
        _7 = Option::<<S as CStrArgument>::Output>::map_or::<*const i8, {closure@src/daemon.rs:139:29: 139:32}>(move _8, move _9, const ZeroSized: {closure@src/daemon.rs:139:29: 139:32}) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _14 = const false;
        _6 = sd_is_fifo(_1, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_4 as Continue).0: i32);
        _13 = Ne(_12, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _13);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_8) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_14) -> [0: bb11, otherwise: bb12];
    }
}

fn daemon::is_fifo::{closure#0}(_1: {closure@src/daemon.rs:136:25: 136:28}, _2: S) -> <S as CStrArgument>::Output {
    debug x => _2;
    let mut _0: <S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _0 = <S as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn daemon::is_fifo::{closure#1}(_1: {closure@src/daemon.rs:139:29: 139:32}, _2: <S as CStrArgument>::Output) -> *const i8 {
    debug x => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;
    let mut _4: &<S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _4 = &_2;
        _3 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn is_special(_1: i32, _2: Option<S>) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug path => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _3: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *const i8;
    let mut _8: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _9: *const i8;
    let mut _10: isize;
    let mut _13: bool;
    let mut _14: bool;
    scope 1 {
        debug path => _3;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
            debug result => _12;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _11;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _12;
            scope 7 {
            }
        }
    }

    bb0: {
        _14 = const false;
        _3 = Option::<S>::map::<<S as CStrArgument>::Output, {closure@src/daemon.rs:147:25: 147:28}>(move _2, const ZeroSized: {closure@src/daemon.rs:147:25: 147:28}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = const true;
        _8 = move _3;
        _9 = null::<i8>() -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _14 = const false;
        _7 = Option::<<S as CStrArgument>::Output>::map_or::<*const i8, {closure@src/daemon.rs:150:29: 150:32}>(move _8, move _9, const ZeroSized: {closure@src/daemon.rs:150:29: 150:32}) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _14 = const false;
        _6 = sd_is_special(_1, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_4 as Continue).0: i32);
        _13 = Ne(_12, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _13);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_8) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_14) -> [0: bb11, otherwise: bb12];
    }
}

fn is_special::{closure#0}(_1: {closure@src/daemon.rs:147:25: 147:28}, _2: S) -> <S as CStrArgument>::Output {
    debug x => _2;
    let mut _0: <S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _0 = <S as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn is_special::{closure#1}(_1: {closure@src/daemon.rs:150:29: 150:32}, _2: <S as CStrArgument>::Output) -> *const i8 {
    debug x => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;
    let mut _4: &<S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _4 = &_2;
        _3 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn get_c_socktype(_1: Option<SocketType>) -> i32 {
    debug socktype => _1;
    let mut _0: i32;
    let mut _2: isize;
    let mut _3: isize;

    bb0: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [0: bb1, 1: bb2, otherwise: bb3];
    }

    bb1: {
        _0 = const 0_i32;
        goto -> bb7;
    }

    bb2: {
        _2 = discriminant(((_1 as Some).0: daemon::SocketType));
        switchInt(move _2) -> [0: bb4, 1: bb5, 2: bb6, otherwise: bb3];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = const _;
        goto -> bb7;
    }

    bb5: {
        _0 = const _;
        goto -> bb7;
    }

    bb6: {
        _0 = const _;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn get_c_listening(_1: Listening) -> i32 {
    debug listening => _1;
    let mut _0: i32;
    let mut _2: isize;

    bb0: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const -1_i32;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _0 = const 1_i32;
        goto -> bb5;
    }

    bb4: {
        _0 = const 0_i32;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn daemon::is_socket(_1: i32, _2: Option<u32>, _3: Option<SocketType>, _4: Listening) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug family => _2;
    debug socktype => _3;
    debug listening => _4;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _5: i32;
    let mut _6: u32;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _10: std::result::Result<i32, std::io::Error>;
    let mut _11: i32;
    let mut _12: isize;
    let mut _15: bool;
    scope 1 {
        debug c_family => _5;
        let _7: i32;
        scope 2 {
            debug c_socktype => _7;
            let _8: i32;
            scope 3 {
                debug c_listening => _8;
                let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _14: i32;
                scope 4 {
                    debug result => _14;
                }
                scope 5 {
                }
                scope 6 {
                    debug residual => _13;
                    scope 7 {
                    }
                }
                scope 8 {
                    debug val => _14;
                    scope 9 {
                    }
                }
            }
        }
    }

    bb0: {
        _6 = Option::<u32>::unwrap_or(_2, const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = move _6 as i32 (IntToInt);
        _7 = get_c_socktype(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = get_c_listening(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = sd_is_socket(_1, _5, _7, _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = ffi_result(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _14 = ((_9 as Continue).0: i32);
        _15 = Ne(_14, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _15);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn is_socket_inet(_1: i32, _2: Option<u32>, _3: Option<SocketType>, _4: Listening, _5: Option<u16>) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug family => _2;
    debug socktype => _3;
    debug listening => _4;
    debug port => _5;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _6: i32;
    let mut _7: u32;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _12: std::result::Result<i32, std::io::Error>;
    let mut _13: i32;
    let mut _14: isize;
    let mut _17: bool;
    scope 1 {
        debug c_family => _6;
        let _8: i32;
        scope 2 {
            debug c_socktype => _8;
            let _9: i32;
            scope 3 {
                debug c_listening => _9;
                let _10: u16;
                scope 4 {
                    debug c_port => _10;
                    let _15: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let _16: i32;
                    scope 5 {
                        debug result => _16;
                    }
                    scope 6 {
                    }
                    scope 7 {
                        debug residual => _15;
                        scope 8 {
                        }
                    }
                    scope 9 {
                        debug val => _16;
                        scope 10 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = Option::<u32>::unwrap_or(_2, const 0_u32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = move _7 as i32 (IntToInt);
        _8 = get_c_socktype(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = get_c_listening(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = Option::<u16>::unwrap_or(_5, const 0_u16) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = sd_is_socket_inet(_1, _6, _8, _9, _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = ffi_result(move _13) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _14 = discriminant(_11);
        switchInt(move _14) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _16 = ((_11 as Continue).0: i32);
        _17 = Ne(_16, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _17);
        goto -> bb11;
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _15 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn tcp_listener(_1: i32) -> std::result::Result<TcpListener, std::io::Error> {
    debug fd => _1;
    let mut _0: std::result::Result<std::net::TcpListener, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, bool>;
    let mut _3: std::result::Result<bool, std::io::Error>;
    let mut _4: std::option::Option<u32>;
    let mut _5: std::option::Option<daemon::SocketType>;
    let mut _6: daemon::SocketType;
    let mut _7: daemon::Listening;
    let mut _8: std::option::Option<u16>;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _11: bool;
    let mut _12: std::io::Error;
    let mut _13: std::io::ErrorKind;
    let mut _14: std::net::TcpListener;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }
    scope 5 {
    }

    bb0: {
        _4 = Option::<u32>::None;
        _6 = SocketType::Stream;
        _5 = Option::<SocketType>::Some(move _6);
        _7 = Listening::IsListening;
        _8 = Option::<u16>::None;
        _3 = is_socket_inet(_1, move _4, move _5, move _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<bool, std::io::Error> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = discriminant(_2);
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _11 = ((_2 as Continue).0: bool);
        switchInt(_11) -> [0: bb10, otherwise: bb9];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<TcpListener, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<TcpListener, std::io::Error>::Err(move _12);
        goto -> bb8;
    }

    bb7: {
        _0 = std::result::Result::<TcpListener, std::io::Error>::Ok(move _14);
        goto -> bb8;
    }

    bb8: {
        return;
    }

    bb9: {
        _14 = <TcpListener as FromRawFd>::from_raw_fd(_1) -> [return: bb7, unwind continue];
    }

    bb10: {
        _13 = InvalidInput;
        _12 = std::io::Error::new::<&str>(move _13, const "Socket type was not as expected") -> [return: bb6, unwind continue];
    }
}

fn is_socket_unix(_1: i32, _2: Option<SocketType>, _3: Listening, _4: Option<S>) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug socktype => _2;
    debug listening => _3;
    debug path => _4;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _5: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _10: std::option::Option<&<S as cstr_argument::CStrArgument>::Output>;
    let mut _11: &std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _12: isize;
    let mut _15: usize;
    let _16: &[u8];
    let mut _17: *const i8;
    let mut _18: *const i8;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _20: std::result::Result<i32, std::io::Error>;
    let mut _21: i32;
    let mut _22: *const i8;
    let mut _23: usize;
    let mut _24: isize;
    let mut _27: bool;
    scope 1 {
        debug path_cstr => _5;
        let _6: i32;
        scope 2 {
            debug c_socktype => _6;
            let _7: i32;
            scope 3 {
                debug c_listening => _7;
                let _8: *const i8;
                scope 4 {
                    debug c_path => _8;
                    let _9: usize;
                    scope 5 {
                        debug c_length => _9;
                        let _13: &<S as cstr_argument::CStrArgument>::Output;
                        let _25: std::result::Result<std::convert::Infallible, std::io::Error>;
                        let _26: i32;
                        scope 6 {
                            debug p => _13;
                            let _14: &std::ffi::CStr;
                            scope 7 {
                                debug path_ref => _14;
                            }
                        }
                        scope 8 {
                            debug result => _26;
                        }
                        scope 9 {
                        }
                        scope 10 {
                            debug residual => _25;
                            scope 11 {
                            }
                        }
                        scope 12 {
                            debug val => _26;
                            scope 13 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _5 = Option::<S>::map::<<S as CStrArgument>::Output, {closure@src/daemon.rs:246:30: 246:33}>(move _4, const ZeroSized: {closure@src/daemon.rs:246:30: 246:33}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = get_c_socktype(move _2) -> [return: bb2, unwind: bb20];
    }

    bb2: {
        _7 = get_c_listening(move _3) -> [return: bb3, unwind: bb20];
    }

    bb3: {
        _11 = &_5;
        _10 = Option::<<S as CStrArgument>::Output>::as_ref(move _11) -> [return: bb4, unwind: bb20];
    }

    bb4: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _18 = null::<i8>() -> [return: bb11, unwind: bb20];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _13 = ((_10 as Some).0: &<S as cstr_argument::CStrArgument>::Output);
        _14 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(_13) -> [return: bb8, unwind: bb20];
    }

    bb8: {
        _16 = CStr::to_bytes(_14) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _15 = Len((*_16));
        _9 = move _15;
        _17 = CStr::as_ptr(_14) -> [return: bb10, unwind: bb20];
    }

    bb10: {
        _8 = move _17;
        goto -> bb12;
    }

    bb11: {
        _8 = move _18;
        _9 = const 0_usize;
        goto -> bb12;
    }

    bb12: {
        _22 = _8;
        _23 = _9;
        _21 = sd_is_socket_unix(_1, _6, _7, move _22, move _23) -> [return: bb13, unwind: bb20];
    }

    bb13: {
        _20 = ffi_result(move _21) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _19 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _20) -> [return: bb15, unwind: bb20];
    }

    bb15: {
        _24 = discriminant(_19);
        switchInt(move _24) -> [0: bb16, 1: bb17, otherwise: bb6];
    }

    bb16: {
        _26 = ((_19 as Continue).0: i32);
        _27 = Ne(_26, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _27);
        drop(_5) -> [return: bb19, unwind continue];
    }

    bb17: {
        _25 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _25) -> [return: bb18, unwind: bb20];
    }

    bb18: {
        drop(_5) -> [return: bb19, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_5) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }
}

fn is_socket_unix::{closure#0}(_1: {closure@src/daemon.rs:246:30: 246:33}, _2: S) -> <S as CStrArgument>::Output {
    debug p => _2;
    let mut _0: <S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _0 = <S as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn is_mq(_1: i32, _2: Option<S>) -> std::result::Result<bool, std::io::Error> {
    debug fd => _1;
    debug path => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _3: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *const i8;
    let mut _8: std::option::Option<<S as cstr_argument::CStrArgument>::Output>;
    let mut _9: *const i8;
    let mut _10: isize;
    let mut _13: bool;
    let mut _14: bool;
    scope 1 {
        debug path => _3;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
            debug result => _12;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _11;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _12;
            scope 7 {
            }
        }
    }

    bb0: {
        _14 = const false;
        _3 = Option::<S>::map::<<S as CStrArgument>::Output, {closure@src/daemon.rs:276:25: 276:28}>(move _2, const ZeroSized: {closure@src/daemon.rs:276:25: 276:28}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = const true;
        _8 = move _3;
        _9 = null::<i8>() -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _14 = const false;
        _7 = Option::<<S as CStrArgument>::Output>::map_or::<*const i8, {closure@src/daemon.rs:279:29: 279:32}>(move _8, move _9, const ZeroSized: {closure@src/daemon.rs:279:29: 279:32}) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _14 = const false;
        _6 = sd_is_mq(_1, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_4 as Continue).0: i32);
        _13 = Ne(_12, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _13);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_8) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_14) -> [0: bb11, otherwise: bb12];
    }
}

fn is_mq::{closure#0}(_1: {closure@src/daemon.rs:276:25: 276:28}, _2: S) -> <S as CStrArgument>::Output {
    debug x => _2;
    let mut _0: <S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _0 = <S as CStrArgument>::into_cstr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn is_mq::{closure#1}(_1: {closure@src/daemon.rs:279:29: 279:32}, _2: <S as CStrArgument>::Output) -> *const i8 {
    debug x => _2;
    let mut _0: *const i8;
    let _3: &std::ffi::CStr;
    let mut _4: &<S as cstr_argument::CStrArgument>::Output;

    bb0: {
        _4 = &_2;
        _3 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _4) -> [return: bb1, unwind: bb4];
    }

    bb1: {
        _0 = CStr::as_ptr(_3) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        drop(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn state_to_c_string(_1: I) -> CString {
    debug state => _1;
    let mut _0: std::ffi::CString;
    let mut _2: std::vec::Vec<std::string::String>;
    let mut _3: I;
    let mut _4: I;
    let mut _6: std::option::Option<&(K, V)>;
    let mut _7: &mut I;
    let mut _8: isize;
    let _11: ();
    let mut _12: &mut std::vec::Vec<std::string::String>;
    let mut _13: std::string::String;
    let _14: &[&str];
    let mut _15: &std::vec::Vec<&str>;
    let _16: std::vec::Vec<&str>;
    let mut _17: std::boxed::Box<[&str]>;
    let mut _18: std::boxed::Box<[&str; 2]>;
    let mut _19: usize;
    let mut _20: usize;
    let mut _21: *mut u8;
    let mut _22: std::boxed::Box<[&str; 2]>;
    let mut _23: &str;
    let _24: &str;
    let _25: &str;
    let _27: &[std::string::String];
    let mut _28: &std::vec::Vec<std::string::String>;
    let _29: &str;
    let mut _30: std::result::Result<std::ffi::CString, std::ffi::NulError>;
    let mut _31: &[u8];
    let mut _32: &std::string::String;
    let mut _33: &(K, V);
    let mut _34: &(K, V);
    let mut _35: bool;
    let mut _36: *const [&str; 2];
    scope 1 {
        debug state_vec => _2;
        let mut _5: I;
        let _26: std::string::String;
        scope 2 {
            debug iter => _5;
            let _9: &K;
            let _10: &V;
            scope 3 {
                debug key => _9;
                debug value => _10;
                let mut _37: *const ();
                let mut _38: usize;
                let mut _39: usize;
                let mut _40: usize;
                let mut _41: usize;
                let mut _42: bool;
                scope 4 {
                }
            }
        }
        scope 5 {
            debug state_str => _26;
        }
    }

    bb0: {
        _35 = const false;
        _35 = const true;
        _2 = Vec::<String>::new() -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _35 = const false;
        _4 = move _1;
        _3 = <I as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        _5 = move _3;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <I as Iterator>::next(_7) -> [return: bb4, unwind: bb26];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _33 = deref_copy ((_6 as Some).0: &(K, V));
        _9 = &((*_33).0: K);
        _34 = deref_copy ((_6 as Some).0: &(K, V));
        _10 = &((*_34).1: V);
        _12 = &mut _2;
        _19 = SizeOf([&str; 2]);
        _20 = AlignOf([&str; 2]);
        _21 = alloc::alloc::exchange_malloc(move _19, move _20) -> [return: bb8, unwind: bb26];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        drop(_5) -> [return: bb15, unwind: bb27];
    }

    bb8: {
        _22 = ShallowInitBox(move _21, [&str; 2]);
        _23 = <K as AsRef<str>>::as_ref(_9) -> [return: bb9, unwind: bb25];
    }

    bb9: {
        _24 = <V as AsRef<str>>::as_ref(_10) -> [return: bb10, unwind: bb25];
    }

    bb10: {
        _36 = (((_22.0: std::ptr::Unique<[&str; 2]>).0: std::ptr::NonNull<[&str; 2]>).0: *const [&str; 2]);
        _37 = _36 as *const () (PtrToPtr);
        _38 = _37 as usize (Transmute);
        _39 = AlignOf([&str; 2]);
        _40 = Sub(_39, const 1_usize);
        _41 = BitAnd(_38, _40);
        _42 = Eq(_41, const 0_usize);
        assert(_42, "misaligned pointer dereference: address must be a multiple of {} but is {}", _39, _38) -> [success: bb31, unwind unreachable];
    }

    bb11: {
        _15 = &_16;
        _14 = <Vec<&str> as Deref>::deref(move _15) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        _25 = const "=";
        _13 = slice::<impl [&str]>::join::<&str>(_14, _25) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _11 = Vec::<String>::push(move _12, move _13) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        drop(_16) -> [return: bb3, unwind: bb26];
    }

    bb15: {
        _28 = &_2;
        _27 = <Vec<String> as Deref>::deref(move _28) -> [return: bb16, unwind: bb27];
    }

    bb16: {
        _29 = const "\n";
        _26 = slice::<impl [String]>::join::<&str>(_27, _29) -> [return: bb17, unwind: bb27];
    }

    bb17: {
        _32 = &_26;
        _31 = String::as_bytes(move _32) -> [return: bb18, unwind: bb23];
    }

    bb18: {
        _30 = CString::new::<&[u8]>(move _31) -> [return: bb19, unwind: bb23];
    }

    bb19: {
        _0 = std::result::Result::<CString, std::ffi::NulError>::unwrap(move _30) -> [return: bb20, unwind: bb23];
    }

    bb20: {
        drop(_26) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        drop(_2) -> [return: bb22, unwind: bb30];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_26) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_16) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_22) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_5) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_2) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29 (cleanup): {
        drop(_1) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_35) -> [0: bb28, otherwise: bb29];
    }

    bb31: {
        (*_36) = [move _23, _24];
        _18 = move _22;
        _17 = move _18 as std::boxed::Box<[&str]> (PointerCoercion(Unsize));
        _16 = slice::<impl [&str]>::into_vec::<std::alloc::Global>(move _17) -> [return: bb11, unwind: bb26];
    }
}

fn notify(_1: bool, _2: I) -> std::result::Result<bool, std::io::Error> {
    debug unset_environment => _1;
    debug state => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _3: std::ffi::CString;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: i32;
    let mut _8: *const i8;
    let _9: &std::ffi::CStr;
    let mut _10: &std::ffi::CString;
    let mut _11: isize;
    let mut _14: bool;
    scope 1 {
        debug c_state => _3;
        let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _13: i32;
        scope 2 {
            debug result => _13;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _12;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _13;
            scope 7 {
            }
        }
    }

    bb0: {
        _3 = state_to_c_string::<'_, I, K, V>(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = _1 as i32 (IntToInt);
        _10 = &_3;
        _9 = <CString as Deref>::deref(move _10) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _8 = CStr::as_ptr(_9) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _6 = sd_notify(move _7, move _8) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _11 = discriminant(_4);
        switchInt(move _11) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _13 = ((_4 as Continue).0: i32);
        _14 = Ne(_13, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _14);
        drop(_3) -> [return: bb11, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _12 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_3) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn pid_notify(_1: i32, _2: bool, _3: I) -> std::result::Result<bool, std::io::Error> {
    debug pid => _1;
    debug unset_environment => _2;
    debug state => _3;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _4: std::ffi::CString;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _6: std::result::Result<i32, std::io::Error>;
    let mut _7: i32;
    let mut _8: i32;
    let mut _9: *const i8;
    let _10: &std::ffi::CStr;
    let mut _11: &std::ffi::CString;
    let mut _12: isize;
    let mut _15: bool;
    scope 1 {
        debug c_state => _4;
        let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _14: i32;
        scope 2 {
            debug result => _14;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _13;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _14;
            scope 7 {
            }
        }
    }

    bb0: {
        _4 = state_to_c_string::<'_, I, K, V>(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _2 as i32 (IntToInt);
        _11 = &_4;
        _10 = <CString as Deref>::deref(move _11) -> [return: bb2, unwind: bb12];
    }

    bb2: {
        _9 = CStr::as_ptr(_10) -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _7 = sd_pid_notify(_1, move _8, move _9) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _6 = ffi_result(move _7) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _5 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _6) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _14 = ((_5 as Continue).0: i32);
        _15 = Ne(_14, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _15);
        drop(_4) -> [return: bb11, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _13 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_4) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_4) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn pid_notify_with_fds(_1: i32, _2: bool, _3: I, _4: &[i32]) -> std::result::Result<bool, std::io::Error> {
    debug pid => _1;
    debug unset_environment => _2;
    debug state => _3;
    debug fds => _4;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let _5: std::ffi::CString;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _7: std::result::Result<i32, std::io::Error>;
    let mut _8: i32;
    let mut _9: i32;
    let mut _10: *const i8;
    let _11: &std::ffi::CStr;
    let mut _12: &std::ffi::CString;
    let mut _13: *const i32;
    let mut _14: u32;
    let mut _15: usize;
    let mut _16: isize;
    let mut _19: bool;
    scope 1 {
        debug c_state => _5;
        let _17: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _18: i32;
        scope 2 {
            debug result => _18;
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _17;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _18;
            scope 7 {
            }
        }
    }

    bb0: {
        _5 = state_to_c_string::<'_, I, K, V>(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = _2 as i32 (IntToInt);
        _12 = &_5;
        _11 = <CString as Deref>::deref(move _12) -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _10 = CStr::as_ptr(_11) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _13 = core::slice::<impl [i32]>::as_ptr(_4) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _15 = Len((*_4));
        _14 = move _15 as u32 (IntToInt);
        _8 = sd_pid_notify_with_fds(_1, move _9, move _10, move _13, move _14) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _7 = ffi_result(move _8) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _6 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _7) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _16 = discriminant(_6);
        switchInt(move _16) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _18 = ((_6 as Continue).0: i32);
        _19 = Ne(_18, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _19);
        drop(_5) -> [return: bb12, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _17 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _17) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        drop(_5) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_5) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn booted() -> std::result::Result<bool, std::io::Error> {
    let mut _0: std::result::Result<bool, std::io::Error>;
    let mut _1: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _2: std::result::Result<i32, std::io::Error>;
    let mut _3: i32;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _6: i32;
    let mut _7: bool;
    scope 1 {
        debug result => _6;
    }
    scope 2 {
    }
    scope 3 {
        debug residual => _5;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _6;
        scope 6 {
        }
    }

    bb0: {
        _3 = sd_booted() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = ffi_result(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = discriminant(_1);
        switchInt(move _4) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _6 = ((_1 as Continue).0: i32);
        _7 = Ne(_6, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _7);
        goto -> bb7;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _5 = move ((_1 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _5) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn watchdog_enabled(_1: bool) -> std::result::Result<u64, std::io::Error> {
    debug unset_environment => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: i32;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug timeout => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = _1 as i32 (IntToInt);
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_watchdog_enabled(move _6, move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = ffi_result(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb7;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn id128::<impl at src/id128.rs:11:10: 11:15>::clone(_1: &Id128) -> Id128 {
    debug self => _1;
    let mut _0: id128::Id128;
    scope 1 {
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn id128::<impl at src/id128.rs:11:23: 11:32>::eq(_1: &Id128, _2: &Id128) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: &ffi::id128::sd_id128_t;
    let mut _4: &ffi::id128::sd_id128_t;

    bb0: {
        _3 = &((*_1).0: ffi::id128::sd_id128_t);
        _4 = &((*_2).0: ffi::id128::sd_id128_t);
        _0 = <sd_id128_t as PartialEq>::eq(move _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn id128::<impl at src/id128.rs:11:34: 11:36>::assert_receiver_is_total_eq(_1: &Id128) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
    }

    bb0: {
        return;
    }
}

fn id128::<impl at src/id128.rs:11:38: 11:48>::partial_cmp(_1: &Id128, _2: &Id128) -> Option<std::cmp::Ordering> {
    debug self => _1;
    debug other => _2;
    let mut _0: std::option::Option<std::cmp::Ordering>;
    let _3: &ffi::id128::sd_id128_t;
    let _4: &ffi::id128::sd_id128_t;

    bb0: {
        _3 = &((*_1).0: ffi::id128::sd_id128_t);
        _4 = &((*_2).0: ffi::id128::sd_id128_t);
        _0 = <sd_id128_t as PartialOrd>::partial_cmp(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn id128::<impl at src/id128.rs:11:50: 11:53>::cmp(_1: &Id128, _2: &Id128) -> std::cmp::Ordering {
    debug self => _1;
    debug other => _2;
    let mut _0: std::cmp::Ordering;
    let _3: &ffi::id128::sd_id128_t;
    let _4: &ffi::id128::sd_id128_t;

    bb0: {
        _3 = &((*_1).0: ffi::id128::sd_id128_t);
        _4 = &((*_2).0: ffi::id128::sd_id128_t);
        _0 = <sd_id128_t as Ord>::cmp(_3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn id128::<impl at src/id128.rs:16:1: 16:26>::fmt(_1: &Id128, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _4: std::result::Result<(), std::fmt::Error>;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: isize;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _9: std::result::Result<(), std::fmt::Error>;
    let mut _10: isize;
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[&str; 1];
    let mut _14: &[&str; 1];
    scope 1 {
        debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 2 {
        }
    }
    scope 3 {
        debug val => const ();
        scope 4 {
        }
    }
    scope 5 {
        debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
        scope 6 {
        }
    }
    scope 7 {
        debug val => const ();
        scope 8 {
        }
    }

    bb0: {
        _14 = const _;
        _6 = _14 as &[&str] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_const(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Formatter::<'_>::write_fmt(_2, move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = discriminant(_3);
        switchInt(move _7) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _9 = <Id128 as std::fmt::Display>::fmt(_1, _2) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb12, unwind continue];
    }

    bb7: {
        _8 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb9, 1: bb10, otherwise: bb5];
    }

    bb9: {
        _13 = const _;
        _12 = _13 as &[&str] (PointerCoercion(Unsize));
        _11 = Arguments::<'_>::new_const(move _12) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb12, unwind continue];
    }

    bb11: {
        _0 = Formatter::<'_>::write_fmt(_2, move _11) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

promoted[0] in id128::<impl at src/id128.rs:16:1: 16:26>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const " }"];
        _0 = &_1;
        return;
    }
}

promoted[1] in id128::<impl at src/id128.rs:16:1: 16:26>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Id128 { "];
        _0 = &_1;
        return;
    }
}

fn id128::<impl at src/id128.rs:24:1: 24:28>::fmt(_1: &Id128, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::slice::Iter<'_, u8>;
    let mut _4: std::slice::Iter<'_, u8>;
    let mut _5: &[u8];
    let mut _6: &[u8; 16];
    let mut _7: std::slice::Iter<'_, u8>;
    let mut _8: std::option::Option<&u8>;
    let mut _9: &mut std::slice::Iter<'_, u8>;
    let mut _10: isize;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::fmt::Error>>;
    let mut _13: std::result::Result<(), std::fmt::Error>;
    let mut _14: std::fmt::Arguments<'_>;
    let mut _15: &[&str];
    let mut _16: &[core::fmt::rt::Argument<'_>];
    let _17: &[core::fmt::rt::Argument<'_>; 1];
    let _18: [core::fmt::rt::Argument<'_>; 1];
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &&u8;
    let mut _21: &[core::fmt::rt::Placeholder];
    let _22: &[core::fmt::rt::Placeholder; 1];
    let _23: [core::fmt::rt::Placeholder; 1];
    let mut _24: core::fmt::rt::Placeholder;
    let mut _25: core::fmt::rt::Alignment;
    let mut _26: core::fmt::rt::Count;
    let mut _27: core::fmt::rt::Count;
    let mut _28: core::fmt::rt::UnsafeArg;
    let mut _29: isize;
    scope 1 {
        debug iter => _7;
        let _11: &u8;
        scope 2 {
            debug b => _11;
            let mut _30: &[&str; 1];
            scope 3 {
            }
            scope 4 {
                debug residual => const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error);
                scope 5 {
                }
            }
            scope 6 {
                debug val => const ();
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _6 = &(((*_1).0: ffi::id128::sd_id128_t).0: [u8; 16]);
        _5 = move _6 as &[u8] (PointerCoercion(Unsize));
        _4 = core::slice::<impl [u8]>::iter(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::slice::Iter<'_, u8> as IntoIterator>::into_iter(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = move _3;
        goto -> bb3;
    }

    bb3: {
        _9 = &mut _7;
        _8 = <std::slice::Iter<'_, u8> as Iterator>::next(_9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _11 = ((_8 as Some).0: &u8);
        _30 = const _;
        _15 = _30 as &[&str] (PointerCoercion(Unsize));
        _20 = &_11;
        _19 = core::fmt::rt::Argument::<'_>::new_lower_hex::<&u8>(_20) -> [return: bb8, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = std::result::Result::<(), std::fmt::Error>::Ok(const ());
        goto -> bb15;
    }

    bb8: {
        _18 = [move _19];
        _17 = &_18;
        _16 = _17 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _25 = core::fmt::rt::Alignment::Unknown;
        _26 = core::fmt::rt::Count::Implied;
        _27 = core::fmt::rt::Count::Is(const 2_usize);
        _24 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _25, const 8_u32, move _26, move _27) -> [return: bb9, unwind continue];
    }

    bb9: {
        _23 = [move _24];
        _22 = &_23;
        _21 = _22 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _28 = core::fmt::rt::UnsafeArg::new() -> [return: bb10, unwind continue];
    }

    bb10: {
        _14 = Arguments::<'_>::new_v1_formatted(move _15, move _16, move _21, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Formatter::<'_>::write_fmt(_2, move _14) -> [return: bb12, unwind continue];
    }

    bb12: {
        _12 = <std::result::Result<(), std::fmt::Error> as Try>::branch(move _13) -> [return: bb13, unwind continue];
    }

    bb13: {
        _29 = discriminant(_12);
        switchInt(move _29) -> [0: bb3, 1: bb14, otherwise: bb6];
    }

    bb14: {
        _0 = <std::result::Result<(), std::fmt::Error> as FromResidual<std::result::Result<Infallible, std::fmt::Error>>>::from_residual(const std::result::Result::<Infallible, std::fmt::Error>::Err(std::fmt::Error)) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }
}

promoted[0] in id128::<impl at src/id128.rs:24:1: 24:28>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn id128::<impl at src/id128.rs:33:1: 33:23>::default() -> Id128 {
    let mut _0: id128::Id128;
    let mut _1: ffi::id128::sd_id128_t;
    let mut _2: [u8; 16];

    bb0: {
        _2 = [const 0_u8; 16];
        _1 = sd_id128_t { bytes: move _2 };
        _0 = Id128 { inner: move _1 };
        return;
    }
}

id128::<impl at src/id128.rs:33:1: 33:23>::default::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 16_usize;
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_cstr(_1: &CStr) -> std::result::Result<Id128, std::io::Error> {
    debug s => _1;
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _2: id128::Id128;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *const i8;
    let mut _7: *mut ffi::id128::sd_id128_t;
    let mut _8: &mut ffi::id128::sd_id128_t;
    let mut _9: isize;
    let mut _12: id128::Id128;
    scope 1 {
        debug r => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = CStr::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut (_2.0: ffi::id128::sd_id128_t);
        _7 = &raw mut (*_8);
        _5 = sd_id128_from_string(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_random() -> std::result::Result<Id128, std::io::Error> {
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _1: id128::Id128;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::id128::sd_id128_t;
    let mut _6: &mut ffi::id128::sd_id128_t;
    let mut _7: isize;
    let mut _10: id128::Id128;
    scope 1 {
        debug r => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
    }

    bb0: {
        _1 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut (_1.0: ffi::id128::sd_id128_t);
        _5 = &raw mut (*_6);
        _4 = sd_id128_randomize(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _10 = _1;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _10);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_machine() -> std::result::Result<Id128, std::io::Error> {
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _1: id128::Id128;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::id128::sd_id128_t;
    let mut _6: &mut ffi::id128::sd_id128_t;
    let mut _7: isize;
    let mut _10: id128::Id128;
    scope 1 {
        debug r => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
    }

    bb0: {
        _1 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut (_1.0: ffi::id128::sd_id128_t);
        _5 = &raw mut (*_6);
        _4 = sd_id128_get_machine(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _10 = _1;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _10);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_machine_app_specific(_1: &Id128) -> std::result::Result<Id128, std::io::Error> {
    debug app_id => _1;
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _2: id128::Id128;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: ffi::id128::sd_id128_t;
    let mut _7: &ffi::id128::sd_id128_t;
    let mut _8: *mut ffi::id128::sd_id128_t;
    let mut _9: &mut ffi::id128::sd_id128_t;
    let mut _10: isize;
    let mut _13: id128::Id128;
    scope 1 {
        debug r => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Id128::as_raw(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = (*_7);
        _9 = &mut (_2.0: ffi::id128::sd_id128_t);
        _8 = &raw mut (*_9);
        _5 = sd_id128_get_machine_app_specific(move _6, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_3 as Continue).0: i32);
        _13 = _2;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _13);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_boot() -> std::result::Result<Id128, std::io::Error> {
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _1: id128::Id128;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::id128::sd_id128_t;
    let mut _6: &mut ffi::id128::sd_id128_t;
    let mut _7: isize;
    let mut _10: id128::Id128;
    scope 1 {
        debug r => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
    }

    bb0: {
        _1 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut (_1.0: ffi::id128::sd_id128_t);
        _5 = &raw mut (*_6);
        _4 = sd_id128_get_boot(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _9 = ((_2 as Continue).0: i32);
        _10 = _1;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _10);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::from_boot_app_specific(_1: &Id128) -> std::result::Result<Id128, std::io::Error> {
    debug app_id => _1;
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _2: id128::Id128;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: ffi::id128::sd_id128_t;
    let mut _7: &ffi::id128::sd_id128_t;
    let mut _8: *mut ffi::id128::sd_id128_t;
    let mut _9: &mut ffi::id128::sd_id128_t;
    let mut _10: isize;
    let mut _13: id128::Id128;
    scope 1 {
        debug r => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Id128::as_raw(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = (*_7);
        _9 = &mut (_2.0: ffi::id128::sd_id128_t);
        _8 = &raw mut (*_9);
        _5 = sd_id128_get_boot_app_specific(move _6, move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_3 as Continue).0: i32);
        _13 = _2;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _13);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::as_bytes(_1: &Id128) -> &[u8; 16] {
    debug self => _1;
    let mut _0: &[u8; 16];

    bb0: {
        _0 = &(((*_1).0: ffi::id128::sd_id128_t).0: [u8; 16]);
        return;
    }
}

id128::<impl at src/id128.rs:63:1: 63:11>::as_bytes::{constant#0}: usize = {
    let mut _0: usize;

    bb0: {
        _0 = const 16_usize;
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::as_raw(_1: &Id128) -> &sd_id128_t {
    debug self => _1;
    let mut _0: &ffi::id128::sd_id128_t;

    bb0: {
        _0 = &((*_1).0: ffi::id128::sd_id128_t);
        return;
    }
}

fn id128::<impl at src/id128.rs:63:1: 63:11>::as_raw_mut(_1: &mut Id128) -> &mut sd_id128_t {
    debug self => _1;
    let mut _0: &mut ffi::id128::sd_id128_t;

    bb0: {
        _0 = &mut ((*_1).0: ffi::id128::sd_id128_t);
        return;
    }
}

fn get_unit(_1: UnitType, _2: Option<i32>) -> std::result::Result<String, std::io::Error> {
    debug unit_type => _1;
    debug pid => _2;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _3: *mut i8;
    let mut _5: isize;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _7: std::result::Result<i32, std::io::Error>;
    let mut _8: i32;
    let mut _9: *mut *mut i8;
    let mut _10: &mut *mut i8;
    let mut _11: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _15: std::result::Result<i32, std::io::Error>;
    let mut _16: i32;
    let mut _17: *mut *mut i8;
    let mut _18: &mut *mut i8;
    let mut _19: isize;
    let mut _23: std::option::Option<std::string::String>;
    let mut _24: *mut i8;
    scope 1 {
        debug c_unit_name => _3;
        let _4: i32;
        scope 2 {
            debug p => _4;
            let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _13: i32;
            let _20: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _21: i32;
            let _22: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _12;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _13;
                scope 7 {
                }
            }
            scope 8 {
            }
            scope 9 {
                debug residual => _20;
                scope 10 {
                }
            }
            scope 11 {
                debug val => _21;
                scope 12 {
                }
            }
            scope 13 {
                debug unit_name => _22;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<i32>::unwrap_or(_2, const 0_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_1);
        switchInt(move _5) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _18 = &mut _3;
        _17 = &raw mut (*_18);
        _16 = sd_pid_get_unit(_4, move _17) -> [return: bb11, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = &mut _3;
        _9 = &raw mut (*_10);
        _8 = sd_pid_get_user_unit(_4, move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = ffi_result(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = discriminant(_6);
        switchInt(move _11) -> [0: bb9, 1: bb10, otherwise: bb4];
    }

    bb9: {
        _13 = ((_6 as Continue).0: i32);
        goto -> bb16;
    }

    bb10: {
        _12 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb19, unwind continue];
    }

    bb11: {
        _15 = ffi_result(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _15) -> [return: bb13, unwind continue];
    }

    bb13: {
        _19 = discriminant(_14);
        switchInt(move _19) -> [0: bb14, 1: bb15, otherwise: bb4];
    }

    bb14: {
        _21 = ((_14 as Continue).0: i32);
        goto -> bb16;
    }

    bb15: {
        _20 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _20) -> [return: bb19, unwind continue];
    }

    bb16: {
        _24 = _3;
        _23 = free_cstring(move _24) -> [return: bb17, unwind continue];
    }

    bb17: {
        _22 = Option::<String>::unwrap(move _23) -> [return: bb18, unwind continue];
    }

    bb18: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _22);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn get_slice(_1: UnitType, _2: Option<i32>) -> std::result::Result<String, std::io::Error> {
    debug slice_type => _1;
    debug pid => _2;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _3: *mut i8;
    let mut _5: isize;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _7: std::result::Result<i32, std::io::Error>;
    let mut _8: i32;
    let mut _9: *mut *mut i8;
    let mut _10: &mut *mut i8;
    let mut _11: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _15: std::result::Result<i32, std::io::Error>;
    let mut _16: i32;
    let mut _17: *mut *mut i8;
    let mut _18: &mut *mut i8;
    let mut _19: isize;
    let mut _23: std::option::Option<std::string::String>;
    let mut _24: *mut i8;
    scope 1 {
        debug c_slice_name => _3;
        let _4: i32;
        scope 2 {
            debug p => _4;
            let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _13: i32;
            let _20: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _21: i32;
            let _22: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _12;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _13;
                scope 7 {
                }
            }
            scope 8 {
            }
            scope 9 {
                debug residual => _20;
                scope 10 {
                }
            }
            scope 11 {
                debug val => _21;
                scope 12 {
                }
            }
            scope 13 {
                debug slice_id => _22;
            }
            scope 14 {
            }
        }
    }

    bb0: {
        _3 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Option::<i32>::unwrap_or(_2, const 0_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_1);
        switchInt(move _5) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _18 = &mut _3;
        _17 = &raw mut (*_18);
        _16 = sd_pid_get_slice(_4, move _17) -> [return: bb11, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = &mut _3;
        _9 = &raw mut (*_10);
        _8 = sd_pid_get_user_slice(_4, move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _7 = ffi_result(move _8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = discriminant(_6);
        switchInt(move _11) -> [0: bb9, 1: bb10, otherwise: bb4];
    }

    bb9: {
        _13 = ((_6 as Continue).0: i32);
        goto -> bb16;
    }

    bb10: {
        _12 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb19, unwind continue];
    }

    bb11: {
        _15 = ffi_result(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _15) -> [return: bb13, unwind continue];
    }

    bb13: {
        _19 = discriminant(_14);
        switchInt(move _19) -> [0: bb14, 1: bb15, otherwise: bb4];
    }

    bb14: {
        _21 = ((_14 as Continue).0: i32);
        goto -> bb16;
    }

    bb15: {
        _20 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _20) -> [return: bb19, unwind continue];
    }

    bb16: {
        _24 = _3;
        _23 = free_cstring(move _24) -> [return: bb17, unwind continue];
    }

    bb17: {
        _22 = Option::<String>::unwrap(move _23) -> [return: bb18, unwind continue];
    }

    bb18: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _22);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

fn get_machine_name(_1: Option<i32>) -> std::result::Result<String, std::io::Error> {
    debug pid => _1;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _2: *mut i8;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut *mut i8;
    let mut _8: &mut *mut i8;
    let mut _9: isize;
    let mut _13: std::option::Option<std::string::String>;
    let mut _14: *mut i8;
    scope 1 {
        debug c_machine_name => _2;
        let _3: i32;
        scope 2 {
            debug p => _3;
            let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _11: i32;
            let _12: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _10;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _11;
                scope 7 {
                }
            }
            scope 8 {
                debug machine_id => _12;
            }
            scope 9 {
            }
        }
    }

    bb0: {
        _2 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Option::<i32>::unwrap_or(_1, const 0_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _6 = sd_pid_get_machine_name(_3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_4 as Continue).0: i32);
        _14 = _2;
        _13 = free_cstring(move _14) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb11, unwind continue];
    }

    bb9: {
        _12 = Option::<String>::unwrap(move _13) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _12);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn get_cgroup(_1: Option<i32>) -> std::result::Result<String, std::io::Error> {
    debug pid => _1;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _2: *mut i8;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut *mut i8;
    let mut _8: &mut *mut i8;
    let mut _9: isize;
    let mut _13: std::option::Option<std::string::String>;
    let mut _14: *mut i8;
    scope 1 {
        debug c_cgroup => _2;
        let _3: i32;
        scope 2 {
            debug p => _3;
            let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _11: i32;
            let _12: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _10;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _11;
                scope 7 {
                }
            }
            scope 8 {
                debug cg => _12;
            }
            scope 9 {
            }
        }
    }

    bb0: {
        _2 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Option::<i32>::unwrap_or(_1, const 0_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _6 = sd_pid_get_cgroup(_3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_4 as Continue).0: i32);
        _14 = _2;
        _13 = free_cstring(move _14) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb11, unwind continue];
    }

    bb9: {
        _12 = Option::<String>::unwrap(move _13) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _12);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn get_session(_1: Option<i32>) -> std::result::Result<String, std::io::Error> {
    debug pid => _1;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let mut _2: *mut i8;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut *mut i8;
    let mut _8: &mut *mut i8;
    let mut _9: isize;
    let mut _13: std::option::Option<std::string::String>;
    let mut _14: *mut i8;
    scope 1 {
        debug c_session => _2;
        let _3: i32;
        scope 2 {
            debug p => _3;
            let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _11: i32;
            let _12: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _10;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _11;
                scope 7 {
                }
            }
            scope 8 {
                debug ss => _12;
            }
            scope 9 {
            }
        }
    }

    bb0: {
        _2 = null_mut::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Option::<i32>::unwrap_or(_1, const 0_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _6 = sd_pid_get_session(_3, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ffi_result(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_4 as Continue).0: i32);
        _14 = _2;
        _13 = free_cstring(move _14) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb11, unwind continue];
    }

    bb9: {
        _12 = Option::<String>::unwrap(move _13) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _12);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn get_seat(_1: S) -> std::result::Result<String, std::io::Error> {
    debug session => _1;
    let mut _0: std::result::Result<std::string::String, std::io::Error>;
    let _2: <S as cstr_argument::CStrArgument>::Output;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *const i8;
    let _8: &std::ffi::CStr;
    let mut _9: &<S as cstr_argument::CStrArgument>::Output;
    let mut _10: *mut *mut i8;
    let mut _11: &mut *mut i8;
    let mut _12: isize;
    let mut _16: std::option::Option<std::string::String>;
    let mut _17: *mut i8;
    scope 1 {
        debug session => _2;
        let mut _3: *mut i8;
        scope 2 {
            debug c_seat => _3;
            let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _14: i32;
            let _15: std::string::String;
            scope 3 {
            }
            scope 4 {
                debug residual => _13;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _14;
                scope 7 {
                }
            }
            scope 8 {
                debug ss => _15;
            }
            scope 9 {
            }
        }
    }

    bb0: {
        _2 = <S as CStrArgument>::into_cstr(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = null_mut::<i8>() -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _9 = &_2;
        _8 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _9) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _7 = CStr::as_ptr(_8) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _11 = &mut _3;
        _10 = &raw mut (*_11);
        _6 = sd_session_get_seat(move _7, move _10) -> [return: bb5, unwind: bb15];
    }

    bb5: {
        _5 = ffi_result(move _6) -> [return: bb6, unwind: bb15];
    }

    bb6: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _14 = ((_4 as Continue).0: i32);
        _17 = _3;
        _16 = free_cstring(move _17) -> [return: bb12, unwind: bb15];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<String, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb12: {
        _15 = Option::<String>::unwrap(move _16) -> [return: bb13, unwind: bb15];
    }

    bb13: {
        _0 = std::result::Result::<String, std::io::Error>::Ok(move _15);
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }
}

fn get_vt(_1: S) -> std::result::Result<u32, std::io::Error> {
    debug session => _1;
    let mut _0: std::result::Result<u32, std::io::Error>;
    let _2: <S as cstr_argument::CStrArgument>::Output;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *const i8;
    let _8: &std::ffi::CStr;
    let mut _9: &<S as cstr_argument::CStrArgument>::Output;
    let mut _10: isize;
    let mut _13: u32;
    scope 1 {
        debug session => _2;
        let _3: *mut u32;
        scope 2 {
            debug c_vt => _3;
            let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _12: i32;
            scope 3 {
            }
            scope 4 {
                debug residual => _11;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _12;
                scope 7 {
                }
            }
            scope 8 {
                let mut _14: *const ();
                let mut _15: usize;
                let mut _16: usize;
                let mut _17: usize;
                let mut _18: usize;
                let mut _19: bool;
            }
        }
    }

    bb0: {
        _2 = <S as CStrArgument>::into_cstr(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = null_mut::<u32>() -> [return: bb2, unwind: bb13];
    }

    bb2: {
        _9 = &_2;
        _8 = <<S as CStrArgument>::Output as AsRef<CStr>>::as_ref(move _9) -> [return: bb3, unwind: bb13];
    }

    bb3: {
        _7 = CStr::as_ptr(_8) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _6 = sd_session_get_vt(move _7, _3) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _5 = ffi_result(move _6) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _12 = ((_4 as Continue).0: i32);
        _14 = _3 as *const () (PtrToPtr);
        _15 = _14 as usize (Transmute);
        _16 = AlignOf(u32);
        _17 = Sub(_16, const 1_usize);
        _18 = BitAnd(_15, _17);
        _19 = Eq(_18, const 0_usize);
        assert(_19, "misaligned pointer dereference: address must be a multiple of {} but is {}", _16, _15) -> [success: bb15, unwind unreachable];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb11, unwind: bb13];
    }

    bb11: {
        drop(_2) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        _13 = (*_3);
        _0 = std::result::Result::<u32, std::io::Error>::Ok(move _13);
        drop(_2) -> [return: bb12, unwind continue];
    }
}

fn get_owner_uid(_1: Option<i32>) -> std::result::Result<u32, std::io::Error> {
    debug pid => _1;
    let mut _0: std::result::Result<u32, std::io::Error>;
    let mut _2: u32;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut u32;
    let mut _8: &mut u32;
    let mut _9: isize;
    let mut _12: u32;
    scope 1 {
        debug c_owner_uid => _2;
        let _3: i32;
        scope 2 {
            debug p => _3;
            let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _11: i32;
            scope 3 {
            }
            scope 4 {
                debug residual => _10;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _11;
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _2 = const 0_u32;
        _3 = Option::<i32>::unwrap_or(_1, const 0_i32) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _6 = sd_pid_get_owner_uid(_3, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = ffi_result(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_4 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u32, std::io::Error>::Ok(move _12);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:73:1: 73:49>::to_message(_1: &T, _2: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug m => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: u8;
    let mut _4: *const libc::c_void;
    let mut _5: *const T;
    scope 1 {
    }

    bb0: {
        _3 = <T as SdBusMessageDirect>::dbus_type() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &raw const (*_1);
        _4 = _5 as *const libc::c_void (PtrToPtr);
        _0 = MessageRef::append_basic_raw(_2, move _3, _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:79:1: 79:64>::from_message(_1: &mut MessageIter<'_>) -> std::result::Result<Option<T>, std::io::Error> {
    debug m => _1;
    let mut _0: std::result::Result<std::option::Option<T>, std::io::Error>;
    let _2: u8;
    scope 1 {
        debug t => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = <T as SdBusMessageDirect>::dbus_type() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = MessageIter::<'_>::read_basic_raw::<T, T, {closure@src/bus/types.rs:85:38: 85:41}>(_1, _2, const ZeroSized: {closure@src/bus/types.rs:85:38: 85:41}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:79:1: 79:64>::from_message::{closure#0}(_1: {closure@src/bus/types.rs:85:38: 85:41}, _2: T) -> T {
    debug x => _2;
    let mut _0: T;

    bb0: {
        _0 = move _2;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 121_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 110_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 113_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 105_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 117_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 120_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 116_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:117:9: 117:48>::dbus_type() -> u8 {
    let mut _0: u8;

    bb0: {
        _0 = const 100_u8;
        return;
    }
}

fn types::<impl at src/bus/types.rs:139:1: 139:29>::to_message(_1: &bool, _2: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug m => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: i32;
    let mut _4: bool;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _6: std::result::Result<(), std::io::Error>;
    let mut _7: *const libc::c_void;
    let mut _8: *const i32;
    let _9: &i32;
    let mut _10: isize;
    scope 1 {
        debug i => _3;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => const ();
            scope 6 {
            }
        }
    }

    bb0: {
        _4 = (*_1);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _3 = const 1_i32;
        goto -> bb3;
    }

    bb2: {
        _3 = const 0_i32;
        goto -> bb3;
    }

    bb3: {
        _9 = &_3;
        _8 = &raw const (*_9);
        _7 = _8 as *const libc::c_void (PtrToPtr);
        _6 = MessageRef::append_basic_raw(_2, const 98_u8, _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = <std::result::Result<(), std::io::Error> as Try>::branch(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_5);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:147:1: 147:39>::from_message(_1: &mut MessageIter<'_>) -> std::result::Result<Option<bool>, std::io::Error> {
    debug m => _1;
    let mut _0: std::result::Result<std::option::Option<bool>, std::io::Error>;
    scope 1 {
    }

    bb0: {
        _0 = MessageIter::<'_>::read_basic_raw::<i32, bool, {closure@src/bus/types.rs:152:41: 152:51}>(_1, const 98_u8, const ZeroSized: {closure@src/bus/types.rs:152:41: 152:51}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:147:1: 147:39>::from_message::{closure#0}(_1: {closure@src/bus/types.rs:152:41: 152:51}, _2: i32) -> bool {
    debug x => _2;
    let mut _0: bool;

    bb0: {
        _0 = Ne(_2, const 0_i32);
        return;
    }
}

fn types::<impl at src/bus/types.rs:162:1: 162:31>::to_message(_1: &UnixFd, _2: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug m => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: i32;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _5: std::result::Result<(), std::io::Error>;
    let mut _6: *const libc::c_void;
    let mut _7: *const i32;
    let _8: &i32;
    let mut _9: isize;
    scope 1 {
        debug i => _3;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => const ();
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = ((*_1).0: i32);
        _8 = &_3;
        _7 = &raw const (*_8);
        _6 = _7 as *const libc::c_void (PtrToPtr);
        _5 = MessageRef::append_basic_raw(_2, const 104_u8, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <std::result::Result<(), std::io::Error> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb6;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:170:1: 170:41>::from_message(_1: &mut MessageIter<'_>) -> std::result::Result<Option<UnixFd>, std::io::Error> {
    debug m => _1;
    let mut _0: std::result::Result<std::option::Option<bus::types::UnixFd>, std::io::Error>;
    scope 1 {
    }

    bb0: {
        _0 = MessageIter::<'_>::read_basic_raw::<i32, UnixFd, fn(i32) -> UnixFd {UnixFd}>(_1, const 104_u8, UnixFd) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:179:1: 179:48>::to_message(_1: &&ObjectPath, _2: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug m => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _4: std::result::Result<(), std::io::Error>;
    let mut _5: *const libc::c_void;
    let mut _6: *const i8;
    let _7: &std::ffi::CStr;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, std::io::Error>;
    let mut _10: &bus::ObjectPath;
    scope 1 {
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => const ();
        scope 5 {
        }
    }

    bb0: {
        _10 = deref_copy (*_1);
        _7 = <ObjectPath as Deref>::deref(_10) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = CStr::as_ptr(_7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = move _6 as *const libc::c_void (PtrToPtr);
        _4 = MessageRef::append_basic_raw(_2, const 111_u8, _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<(), std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:191:1: 191:54>::from_message(_1: &mut MessageIter<'_>) -> std::result::Result<Option<&ObjectPath>, std::io::Error> {
    debug m => _1;
    let mut _0: std::result::Result<std::option::Option<&bus::ObjectPath>, std::io::Error>;
    scope 1 {
    }

    bb0: {
        _0 = MessageIter::<'_>::read_basic_raw::<*const i8, &ObjectPath, {closure@src/bus/types.rs:197:36: 197:54}>(_1, const 111_u8, const ZeroSized: {closure@src/bus/types.rs:197:36: 197:54}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:191:1: 191:54>::from_message::{closure#0}(_1: {closure@src/bus/types.rs:197:36: 197:54}, _2: *const i8) -> &ObjectPath {
    debug x => _2;
    let mut _0: &bus::ObjectPath;

    bb0: {
        _0 = ObjectPath::from_ptr_unchecked::<'_>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:204:1: 204:41>::to_message(_1: &&Utf8CStr, _2: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug m => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: *const libc::c_void;
    let mut _4: *const i8;
    let mut _5: &utf8_cstr::Utf8CStr;
    scope 1 {
    }

    bb0: {
        _5 = deref_copy (*_1);
        _4 = Utf8CStr::as_ptr(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = move _4 as *const libc::c_void (PtrToPtr);
        _0 = MessageRef::append_basic_raw(_2, const 115_u8, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:210:1: 210:47>::from_message(_1: &mut MessageIter<'_>) -> std::result::Result<Option<&Utf8CStr>, std::io::Error> {
    debug m => _1;
    let mut _0: std::result::Result<std::option::Option<&utf8_cstr::Utf8CStr>, std::io::Error>;
    scope 1 {
    }

    bb0: {
        _0 = MessageIter::<'_>::read_basic_raw::<*const i8, &Utf8CStr, {closure@src/bus/types.rs:216:36: 216:54}>(_1, const 115_u8, const ZeroSized: {closure@src/bus/types.rs:216:36: 216:54}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn types::<impl at src/bus/types.rs:210:1: 210:47>::from_message::{closure#0}(_1: {closure@src/bus/types.rs:216:36: 216:54}, _2: *const i8) -> &Utf8CStr {
    debug x => _2;
    let mut _0: &utf8_cstr::Utf8CStr;
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = CStr::from_ptr::<'_>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Utf8CStr::from_cstr_unchecked(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:61:10: 61:15>::fmt(_1: &ObjectPath, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::ffi::CStr;
    let _7: &std::ffi::CStr;

    bb0: {
        _3 = const "ObjectPath";
        _4 = const "inner";
        _7 = &((*_1).0: std::ffi::CStr);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:66:1: 66:16>::from_bytes(_1: &[u8]) -> std::result::Result<&ObjectPath, &str> {
    debug b => _1;
    let mut _0: std::result::Result<&bus::ObjectPath, &str>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: u8;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let _8: &str;
    let mut _9: std::slice::Windows<'_, u8>;
    let mut _10: std::slice::Windows<'_, u8>;
    let mut _11: std::slice::Windows<'_, u8>;
    let mut _12: std::option::Option<&[u8]>;
    let mut _13: &mut std::slice::Windows<'_, u8>;
    let mut _14: isize;
    let _17: usize;
    let mut _18: usize;
    let mut _19: bool;
    let _21: usize;
    let mut _22: usize;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let mut _28: bool;
    let mut _29: bool;
    let _30: &str;
    let mut _31: usize;
    let _32: &str;
    let _33: &bus::ObjectPath;
    let _34: &str;
    let _35: &str;
    scope 1 {
        debug iter => _11;
        let _15: &[u8];
        scope 2 {
            debug w => _15;
            let _16: u8;
            scope 3 {
                debug prev => _16;
                let _20: u8;
                scope 4 {
                    debug c => _20;
                    scope 5 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = core::slice::<impl [u8]>::is_empty(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = const "Path must have at least 1 character ('/')";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_3);
        goto -> bb30;
    }

    bb3: {
        _5 = const 0_usize;
        _6 = Len((*_1));
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> [success: bb4, unwind continue];
    }

    bb4: {
        _4 = (*_1)[_5];
        switchInt(move _4) -> [47: bb6, otherwise: bb5];
    }

    bb5: {
        _8 = const "Path must begin with '/'";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_8);
        goto -> bb30;
    }

    bb6: {
        _10 = core::slice::<impl [u8]>::windows(_1, const 2_usize) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = <Windows<'_, u8> as IntoIterator>::into_iter(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = move _9;
        goto -> bb9;
    }

    bb9: {
        _13 = &mut _11;
        _12 = <Windows<'_, u8> as Iterator>::next(_13) -> [return: bb10, unwind continue];
    }

    bb10: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb13, 1: bb11, otherwise: bb12];
    }

    bb11: {
        _15 = ((_12 as Some).0: &[u8]);
        _17 = const 0_usize;
        _18 = Len((*_15));
        _19 = Lt(_17, _18);
        assert(move _19, "index out of bounds: the length is {} but the index is {}", move _18, _17) -> [success: bb14, unwind continue];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _35 = const "Path must be terminated in a '\\0' byte (for use by sd-bus)";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_35);
        goto -> bb30;
    }

    bb14: {
        _16 = (*_15)[_17];
        _21 = const 1_usize;
        _22 = Len((*_15));
        _23 = Lt(_21, _22);
        assert(move _23, "index out of bounds: the length is {} but the index is {}", move _22, _21) -> [success: bb15, unwind continue];
    }

    bb15: {
        _20 = (*_15)[_21];
        switchInt(_20) -> [47: bb23, 95: bb9, 0: bb25, otherwise: bb16];
    }

    bb16: {
        _28 = Le(const 65_u8, _20);
        switchInt(move _28) -> [0: bb17, otherwise: bb22];
    }

    bb17: {
        _26 = Le(const 97_u8, _20);
        switchInt(move _26) -> [0: bb18, otherwise: bb21];
    }

    bb18: {
        _24 = Le(const 48_u8, _20);
        switchInt(move _24) -> [0: bb19, otherwise: bb20];
    }

    bb19: {
        _34 = const "Invalid character in path, only '[A-Z][a-z][0-9]_/' allowed";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_34);
        goto -> bb30;
    }

    bb20: {
        _25 = Le(_20, const 57_u8);
        switchInt(move _25) -> [0: bb19, otherwise: bb9];
    }

    bb21: {
        _27 = Le(_20, const 122_u8);
        switchInt(move _27) -> [0: bb18, otherwise: bb9];
    }

    bb22: {
        _29 = Le(_20, const 90_u8);
        switchInt(move _29) -> [0: bb17, otherwise: bb9];
    }

    bb23: {
        switchInt(move _16) -> [47: bb24, otherwise: bb9];
    }

    bb24: {
        _30 = const "Path must not have 2 '/' next to each other";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_30);
        goto -> bb30;
    }

    bb25: {
        switchInt(move _16) -> [47: bb26, otherwise: bb28];
    }

    bb26: {
        _31 = Len((*_1));
        switchInt(move _31) -> [2: bb28, otherwise: bb27];
    }

    bb27: {
        _32 = const "Path must not end in '/' unless it is the root path";
        _0 = std::result::Result::<&ObjectPath, &str>::Err(_32);
        goto -> bb30;
    }

    bb28: {
        _33 = ObjectPath::from_bytes_unchecked(_1) -> [return: bb29, unwind continue];
    }

    bb29: {
        _0 = std::result::Result::<&ObjectPath, &str>::Ok(_33);
        goto -> bb30;
    }

    bb30: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:66:1: 66:16>::from_bytes_unchecked(_1: &[u8]) -> &ObjectPath {
    debug b => _1;
    let mut _0: &bus::ObjectPath;
    let _2: *const bus::ObjectPath;
    let mut _3: *const [u8];

    bb0: {
        _3 = &raw const (*_1);
        _2 = move _3 as *const bus::ObjectPath (PtrToPtr);
        _0 = &(*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:66:1: 66:16>::from_ptr_unchecked(_1: *const i8) -> &ObjectPath {
    debug b => _1;
    let mut _0: &bus::ObjectPath;
    let _2: &[u8];
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = CStr::from_ptr::<'_>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = CStr::to_bytes(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = ObjectPath::from_bytes_unchecked(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:129:1: 129:26>::deref(_1: &ObjectPath) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;

    bb0: {
        _0 = &((*_1).0: std::ffi::CStr);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:154:10: 154:15>::fmt(_1: &InterfaceName, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::ffi::CStr;
    let _7: &std::ffi::CStr;

    bb0: {
        _3 = const "InterfaceName";
        _4 = const "inner";
        _7 = &((*_1).0: std::ffi::CStr);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:159:1: 159:19>::from_bytes(_1: &[u8]) -> std::result::Result<&InterfaceName, &str> {
    debug b => _1;
    let mut _0: std::result::Result<&bus::InterfaceName, &str>;
    let mut _2: bool;
    let _3: &str;
    let _4: usize;
    let mut _5: usize;
    let mut _6: bool;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let _11: &str;
    let _12: &str;
    let mut _13: i32;
    let mut _14: std::slice::Windows<'_, u8>;
    let mut _15: std::slice::Windows<'_, u8>;
    let mut _17: std::option::Option<&[u8]>;
    let mut _18: &mut std::slice::Windows<'_, u8>;
    let mut _19: isize;
    let _22: usize;
    let mut _23: usize;
    let mut _24: bool;
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let mut _29: bool;
    let mut _30: bool;
    let mut _31: bool;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let _35: &str;
    let mut _36: (i32, bool);
    let _37: &str;
    let mut _38: usize;
    let _39: &str;
    let mut _40: bool;
    let mut _41: i32;
    let _42: &str;
    let _43: &bus::InterfaceName;
    let _44: &str;
    let _45: &str;
    scope 1 {
        debug periods => _13;
        let mut _16: std::slice::Windows<'_, u8>;
        scope 2 {
            debug iter => _16;
            let _20: &[u8];
            scope 3 {
                debug w => _20;
                let _21: u8;
                scope 4 {
                    debug prev => _21;
                    let _25: u8;
                    scope 5 {
                        debug c => _25;
                        scope 6 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = core::slice::<impl [u8]>::is_empty(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = const "Name must have more than 0 characters";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_3);
        goto -> bb41;
    }

    bb3: {
        _4 = const 0_usize;
        _5 = Len((*_1));
        _6 = Lt(_4, _5);
        assert(move _6, "index out of bounds: the length is {} but the index is {}", move _5, _4) -> [success: bb4, unwind continue];
    }

    bb4: {
        switchInt((*_1)[_4]) -> [46: bb10, 95: bb11, otherwise: bb5];
    }

    bb5: {
        _9 = Le(const 65_u8, (*_1)[_4]);
        switchInt(move _9) -> [0: bb6, otherwise: bb9];
    }

    bb6: {
        _7 = Le(const 97_u8, (*_1)[_4]);
        switchInt(move _7) -> [0: bb7, otherwise: bb8];
    }

    bb7: {
        _12 = const "Name must only begin with '[A-Z][a-z]_'";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_12);
        goto -> bb41;
    }

    bb8: {
        _8 = Le((*_1)[_4], const 122_u8);
        switchInt(move _8) -> [0: bb7, otherwise: bb11];
    }

    bb9: {
        _10 = Le((*_1)[_4], const 90_u8);
        switchInt(move _10) -> [0: bb6, otherwise: bb11];
    }

    bb10: {
        _11 = const "Name must not begin with '.'";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_11);
        goto -> bb41;
    }

    bb11: {
        _13 = const 0_i32;
        _15 = core::slice::<impl [u8]>::windows(_1, const 2_usize) -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = <Windows<'_, u8> as IntoIterator>::into_iter(move _15) -> [return: bb13, unwind continue];
    }

    bb13: {
        _16 = move _14;
        goto -> bb14;
    }

    bb14: {
        _18 = &mut _16;
        _17 = <Windows<'_, u8> as Iterator>::next(_18) -> [return: bb15, unwind continue];
    }

    bb15: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb18, 1: bb16, otherwise: bb17];
    }

    bb16: {
        _20 = ((_17 as Some).0: &[u8]);
        _22 = const 0_usize;
        _23 = Len((*_20));
        _24 = Lt(_22, _23);
        assert(move _24, "index out of bounds: the length is {} but the index is {}", move _23, _22) -> [success: bb19, unwind continue];
    }

    bb17: {
        unreachable;
    }

    bb18: {
        _45 = const "Name must be terminated in a '\\0' byte (for use by sd-bus)";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_45);
        goto -> bb41;
    }

    bb19: {
        _21 = (*_20)[_22];
        _26 = const 1_usize;
        _27 = Len((*_20));
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb20, unwind continue];
    }

    bb20: {
        _25 = (*_20)[_26];
        switchInt(_25) -> [46: bb29, 95: bb14, 0: bb34, otherwise: bb21];
    }

    bb21: {
        _33 = Le(const 65_u8, _25);
        switchInt(move _33) -> [0: bb22, otherwise: bb28];
    }

    bb22: {
        _31 = Le(const 97_u8, _25);
        switchInt(move _31) -> [0: bb23, otherwise: bb27];
    }

    bb23: {
        _29 = Le(const 48_u8, _25);
        switchInt(move _29) -> [0: bb25, otherwise: bb26];
    }

    bb24: {
        switchInt(move _21) -> [46: bb33, otherwise: bb14];
    }

    bb25: {
        _44 = const "Invalid character in interface name, only '[A-Z][a-z][0-9]_\\.' allowed";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_44);
        goto -> bb41;
    }

    bb26: {
        _30 = Le(_25, const 57_u8);
        switchInt(move _30) -> [0: bb25, otherwise: bb24];
    }

    bb27: {
        _32 = Le(_25, const 122_u8);
        switchInt(move _32) -> [0: bb23, otherwise: bb14];
    }

    bb28: {
        _34 = Le(_25, const 90_u8);
        switchInt(move _34) -> [0: bb22, otherwise: bb14];
    }

    bb29: {
        switchInt(move _21) -> [46: bb30, otherwise: bb31];
    }

    bb30: {
        _35 = const "Name must not have 2 '.' next to each other";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_35);
        goto -> bb41;
    }

    bb31: {
        _36 = CheckedAdd(_13, const 1_i32);
        assert(!move (_36.1: bool), "attempt to compute `{} + {}`, which would overflow", _13, const 1_i32) -> [success: bb32, unwind continue];
    }

    bb32: {
        _13 = move (_36.0: i32);
        goto -> bb14;
    }

    bb33: {
        _37 = const "Name element must not start with '[0-9]'";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_37);
        goto -> bb41;
    }

    bb34: {
        switchInt(move _21) -> [46: bb35, otherwise: bb37];
    }

    bb35: {
        _38 = Len((*_1));
        switchInt(move _38) -> [1: bb37, otherwise: bb36];
    }

    bb36: {
        _39 = const "Name must not end in '.'";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_39);
        goto -> bb41;
    }

    bb37: {
        _41 = _13;
        _40 = Lt(move _41, const 1_i32);
        switchInt(move _40) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _42 = const "Name must have at least 2 elements";
        _0 = std::result::Result::<&InterfaceName, &str>::Err(_42);
        goto -> bb41;
    }

    bb39: {
        _43 = InterfaceName::from_bytes_unchecked(_1) -> [return: bb40, unwind continue];
    }

    bb40: {
        _0 = std::result::Result::<&InterfaceName, &str>::Ok(_43);
        goto -> bb41;
    }

    bb41: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:159:1: 159:19>::from_bytes_unchecked(_1: &[u8]) -> &InterfaceName {
    debug b => _1;
    let mut _0: &bus::InterfaceName;
    let _2: *const bus::InterfaceName;
    let mut _3: *const [u8];

    bb0: {
        _3 = &raw const (*_1);
        _2 = move _3 as *const bus::InterfaceName (PtrToPtr);
        _0 = &(*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:159:1: 159:19>::from_ptr_unchecked(_1: *const i8) -> &InterfaceName {
    debug b => _1;
    let mut _0: &bus::InterfaceName;
    let _2: &[u8];
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = CStr::from_ptr::<'_>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = CStr::to_bytes_with_nul(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = InterfaceName::from_bytes_unchecked(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:251:1: 251:29>::deref(_1: &InterfaceName) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;

    bb0: {
        _0 = &((*_1).0: std::ffi::CStr);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:270:10: 270:15>::fmt(_1: &BusName, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::ffi::CStr;
    let _7: &std::ffi::CStr;

    bb0: {
        _3 = const "BusName";
        _4 = const "inner";
        _7 = &((*_1).0: std::ffi::CStr);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:275:1: 275:13>::from_bytes(_1: &[u8]) -> std::result::Result<&BusName, &str> {
    debug b => _1;
    let mut _0: std::result::Result<&bus::BusName, &str>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let mut _5: usize;
    let _6: &str;
    let mut _7: bool;
    let _8: usize;
    let mut _9: usize;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let _15: &str;
    let _16: &str;
    let mut _18: std::slice::Windows<'_, u8>;
    let mut _19: std::slice::Windows<'_, u8>;
    let mut _21: std::option::Option<&[u8]>;
    let mut _22: &mut std::slice::Windows<'_, u8>;
    let mut _23: isize;
    let _26: usize;
    let mut _27: usize;
    let mut _28: bool;
    let _30: usize;
    let mut _31: usize;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    let _39: &str;
    let mut _40: (i32, bool);
    let mut _41: bool;
    let _42: &str;
    let mut _43: usize;
    let _44: &str;
    let mut _45: bool;
    let mut _46: i32;
    let _47: &str;
    let _48: &bus::BusName;
    let _49: &str;
    let _50: &str;
    scope 1 {
        debug is_unique => _7;
        let mut _17: i32;
        scope 2 {
            debug periods => _17;
            let mut _20: std::slice::Windows<'_, u8>;
            scope 3 {
                debug iter => _20;
                let _24: &[u8];
                scope 4 {
                    debug w => _24;
                    let _25: u8;
                    scope 5 {
                        debug prev => _25;
                        let _29: u8;
                        scope 6 {
                            debug c => _29;
                            scope 7 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = core::slice::<impl [u8]>::is_empty(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _3 = const "Name must have more than 0 characters";
        _0 = std::result::Result::<&BusName, &str>::Err(_3);
        goto -> bb46;
    }

    bb3: {
        _5 = Len((*_1));
        _4 = Gt(move _5, const 256_usize);
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _6 = const "Must be shorter than 255 characters";
        _0 = std::result::Result::<&BusName, &str>::Err(_6);
        goto -> bb46;
    }

    bb5: {
        _7 = const false;
        _8 = const 0_usize;
        _9 = Len((*_1));
        _10 = Lt(_8, _9);
        assert(move _10, "index out of bounds: the length is {} but the index is {}", move _9, _8) -> [success: bb6, unwind continue];
    }

    bb6: {
        switchInt((*_1)[_8]) -> [46: bb12, 95: bb14, 45: bb14, 58: bb13, otherwise: bb7];
    }

    bb7: {
        _13 = Le(const 65_u8, (*_1)[_8]);
        switchInt(move _13) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        _11 = Le(const 97_u8, (*_1)[_8]);
        switchInt(move _11) -> [0: bb9, otherwise: bb10];
    }

    bb9: {
        _16 = const "Name must only begin with '[A-Z][a-z]_'";
        _0 = std::result::Result::<&BusName, &str>::Err(_16);
        goto -> bb46;
    }

    bb10: {
        _12 = Le((*_1)[_8], const 122_u8);
        switchInt(move _12) -> [0: bb9, otherwise: bb14];
    }

    bb11: {
        _14 = Le((*_1)[_8], const 90_u8);
        switchInt(move _14) -> [0: bb8, otherwise: bb14];
    }

    bb12: {
        _15 = const "Name must not begin with '.'";
        _0 = std::result::Result::<&BusName, &str>::Err(_15);
        goto -> bb46;
    }

    bb13: {
        _7 = const true;
        goto -> bb14;
    }

    bb14: {
        _17 = const 0_i32;
        _19 = core::slice::<impl [u8]>::windows(_1, const 2_usize) -> [return: bb15, unwind continue];
    }

    bb15: {
        _18 = <Windows<'_, u8> as IntoIterator>::into_iter(move _19) -> [return: bb16, unwind continue];
    }

    bb16: {
        _20 = move _18;
        goto -> bb17;
    }

    bb17: {
        _22 = &mut _20;
        _21 = <Windows<'_, u8> as Iterator>::next(_22) -> [return: bb18, unwind continue];
    }

    bb18: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb21, 1: bb19, otherwise: bb20];
    }

    bb19: {
        _24 = ((_21 as Some).0: &[u8]);
        _26 = const 0_usize;
        _27 = Len((*_24));
        _28 = Lt(_26, _27);
        assert(move _28, "index out of bounds: the length is {} but the index is {}", move _27, _26) -> [success: bb22, unwind continue];
    }

    bb20: {
        unreachable;
    }

    bb21: {
        _50 = const "Name must be terminated in a '\\0' byte (for use by sd-bus)";
        _0 = std::result::Result::<&BusName, &str>::Err(_50);
        goto -> bb46;
    }

    bb22: {
        _25 = (*_24)[_26];
        _30 = const 1_usize;
        _31 = Len((*_24));
        _32 = Lt(_30, _31);
        assert(move _32, "index out of bounds: the length is {} but the index is {}", move _31, _30) -> [success: bb23, unwind continue];
    }

    bb23: {
        _29 = (*_24)[_30];
        switchInt(_29) -> [46: bb32, 95: bb17, 45: bb17, 0: bb39, otherwise: bb24];
    }

    bb24: {
        _37 = Le(const 65_u8, _29);
        switchInt(move _37) -> [0: bb25, otherwise: bb31];
    }

    bb25: {
        _35 = Le(const 97_u8, _29);
        switchInt(move _35) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _33 = Le(const 48_u8, _29);
        switchInt(move _33) -> [0: bb28, otherwise: bb29];
    }

    bb27: {
        switchInt(move _25) -> [46: bb37, otherwise: bb17];
    }

    bb28: {
        _49 = const "Invalid character in bus name, only '[A-Z][a-z][0-9]_\\.' allowed";
        _0 = std::result::Result::<&BusName, &str>::Err(_49);
        goto -> bb46;
    }

    bb29: {
        _34 = Le(_29, const 57_u8);
        switchInt(move _34) -> [0: bb28, otherwise: bb27];
    }

    bb30: {
        _36 = Le(_29, const 122_u8);
        switchInt(move _36) -> [0: bb26, otherwise: bb17];
    }

    bb31: {
        _38 = Le(_29, const 90_u8);
        switchInt(move _38) -> [0: bb25, otherwise: bb17];
    }

    bb32: {
        switchInt(move _25) -> [46: bb34, otherwise: bb33];
    }

    bb33: {
        switchInt(move _25) -> [58: bb34, otherwise: bb35];
    }

    bb34: {
        _39 = const "Elements may not be empty";
        _0 = std::result::Result::<&BusName, &str>::Err(_39);
        goto -> bb46;
    }

    bb35: {
        _40 = CheckedAdd(_17, const 1_i32);
        assert(!move (_40.1: bool), "attempt to compute `{} + {}`, which would overflow", _17, const 1_i32) -> [success: bb36, unwind continue];
    }

    bb36: {
        _17 = move (_40.0: i32);
        goto -> bb17;
    }

    bb37: {
        _41 = _7;
        switchInt(move _41) -> [0: bb38, otherwise: bb17];
    }

    bb38: {
        _42 = const "Name element must not start with '[0-9]'";
        _0 = std::result::Result::<&BusName, &str>::Err(_42);
        goto -> bb46;
    }

    bb39: {
        switchInt(move _25) -> [46: bb40, otherwise: bb42];
    }

    bb40: {
        _43 = Len((*_1));
        switchInt(move _43) -> [1: bb42, otherwise: bb41];
    }

    bb41: {
        _44 = const "Name must not end in '.'";
        _0 = std::result::Result::<&BusName, &str>::Err(_44);
        goto -> bb46;
    }

    bb42: {
        _46 = _17;
        _45 = Lt(move _46, const 1_i32);
        switchInt(move _45) -> [0: bb44, otherwise: bb43];
    }

    bb43: {
        _47 = const "Name must have at least 2 elements";
        _0 = std::result::Result::<&BusName, &str>::Err(_47);
        goto -> bb46;
    }

    bb44: {
        _48 = BusName::from_bytes_unchecked(_1) -> [return: bb45, unwind continue];
    }

    bb45: {
        _0 = std::result::Result::<&BusName, &str>::Ok(_48);
        goto -> bb46;
    }

    bb46: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:275:1: 275:13>::from_bytes_unchecked(_1: &[u8]) -> &BusName {
    debug b => _1;
    let mut _0: &bus::BusName;
    let _2: *const bus::BusName;
    let mut _3: *const [u8];

    bb0: {
        _3 = &raw const (*_1);
        _2 = move _3 as *const bus::BusName (PtrToPtr);
        _0 = &(*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:275:1: 275:13>::from_ptr_unchecked(_1: *const i8) -> &BusName {
    debug b => _1;
    let mut _0: &bus::BusName;
    let _2: &[u8];
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = CStr::from_ptr::<'_>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = CStr::to_bytes(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = BusName::from_bytes_unchecked(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:378:1: 378:23>::deref(_1: &BusName) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;

    bb0: {
        _0 = &((*_1).0: std::ffi::CStr);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:398:10: 398:15>::fmt(_1: &MemberName, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::ffi::CStr;
    let _7: &std::ffi::CStr;

    bb0: {
        _3 = const "MemberName";
        _4 = const "inner";
        _7 = &((*_1).0: std::ffi::CStr);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:403:1: 403:16>::from_bytes(_1: &[u8]) -> std::result::Result<&MemberName, &str> {
    debug b => _1;
    let mut _0: std::result::Result<&bus::MemberName, &str>;
    let mut _2: bool;
    let mut _3: usize;
    let _4: &str;
    let mut _5: bool;
    let mut _6: usize;
    let _7: &str;
    let _8: usize;
    let mut _9: usize;
    let mut _10: bool;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let _15: &str;
    let mut _16: std::slice::Iter<'_, u8>;
    let mut _17: std::slice::Iter<'_, u8>;
    let mut _18: std::option::Option<&u8>;
    let mut _19: &mut std::slice::Iter<'_, u8>;
    let mut _20: isize;
    let mut _22: bool;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: bool;
    let mut _27: bool;
    let _28: &bus::MemberName;
    let _29: &str;
    let _30: &str;
    scope 1 {
        debug iter => _17;
        let _21: &u8;
        scope 2 {
            debug c => _21;
            scope 3 {
            }
        }
    }

    bb0: {
        _3 = Len((*_1));
        _2 = Lt(move _3, const 2_usize);
        switchInt(move _2) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _4 = const "Name must have more than 0 characters";
        _0 = std::result::Result::<&MemberName, &str>::Err(_4);
        goto -> bb27;
    }

    bb2: {
        _6 = Len((*_1));
        _5 = Gt(move _6, const 256_usize);
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _7 = const "Must be shorter than 255 characters";
        _0 = std::result::Result::<&MemberName, &str>::Err(_7);
        goto -> bb27;
    }

    bb4: {
        _8 = const 0_usize;
        _9 = Len((*_1));
        _10 = Lt(_8, _9);
        assert(move _10, "index out of bounds: the length is {} but the index is {}", move _9, _8) -> [success: bb5, unwind continue];
    }

    bb5: {
        _13 = Le(const 65_u8, (*_1)[_8]);
        switchInt(move _13) -> [0: bb6, otherwise: bb10];
    }

    bb6: {
        _11 = Le(const 97_u8, (*_1)[_8]);
        switchInt(move _11) -> [0: bb7, otherwise: bb9];
    }

    bb7: {
        switchInt((*_1)[_8]) -> [95: bb11, otherwise: bb8];
    }

    bb8: {
        _15 = const "Must begin with '[A-Z][a-z]_'";
        _0 = std::result::Result::<&MemberName, &str>::Err(_15);
        goto -> bb27;
    }

    bb9: {
        _12 = Le((*_1)[_8], const 122_u8);
        switchInt(move _12) -> [0: bb7, otherwise: bb11];
    }

    bb10: {
        _14 = Le((*_1)[_8], const 90_u8);
        switchInt(move _14) -> [0: bb6, otherwise: bb11];
    }

    bb11: {
        _16 = <&[u8] as IntoIterator>::into_iter(_1) -> [return: bb12, unwind continue];
    }

    bb12: {
        _17 = move _16;
        goto -> bb13;
    }

    bb13: {
        _19 = &mut _17;
        _18 = <std::slice::Iter<'_, u8> as Iterator>::next(_19) -> [return: bb14, unwind continue];
    }

    bb14: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb17, 1: bb15, otherwise: bb16];
    }

    bb15: {
        _21 = ((_18 as Some).0: &u8);
        _26 = Le(const 65_u8, (*_21));
        switchInt(move _26) -> [0: bb18, otherwise: bb24];
    }

    bb16: {
        unreachable;
    }

    bb17: {
        _30 = const "Name must be terminated in a '\\0' byte (for use by sd-bus)";
        _0 = std::result::Result::<&MemberName, &str>::Err(_30);
        goto -> bb27;
    }

    bb18: {
        _24 = Le(const 97_u8, (*_21));
        switchInt(move _24) -> [0: bb19, otherwise: bb23];
    }

    bb19: {
        _22 = Le(const 48_u8, (*_21));
        switchInt(move _22) -> [0: bb20, otherwise: bb22];
    }

    bb20: {
        switchInt((*_21)) -> [95: bb13, 0: bb25, otherwise: bb21];
    }

    bb21: {
        _29 = const "Invalid character in member name, only '[A-Z][a-z][0-9]_' allowed";
        _0 = std::result::Result::<&MemberName, &str>::Err(_29);
        goto -> bb27;
    }

    bb22: {
        _23 = Le((*_21), const 57_u8);
        switchInt(move _23) -> [0: bb20, otherwise: bb13];
    }

    bb23: {
        _25 = Le((*_21), const 122_u8);
        switchInt(move _25) -> [0: bb19, otherwise: bb13];
    }

    bb24: {
        _27 = Le((*_21), const 90_u8);
        switchInt(move _27) -> [0: bb18, otherwise: bb13];
    }

    bb25: {
        _28 = MemberName::from_bytes_unchecked(_1) -> [return: bb26, unwind continue];
    }

    bb26: {
        _0 = std::result::Result::<&MemberName, &str>::Ok(_28);
        goto -> bb27;
    }

    bb27: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:403:1: 403:16>::from_bytes_unchecked(_1: &[u8]) -> &MemberName {
    debug b => _1;
    let mut _0: &bus::MemberName;
    let _2: *const bus::MemberName;
    let mut _3: *const [u8];

    bb0: {
        _3 = &raw const (*_1);
        _2 = move _3 as *const bus::MemberName (PtrToPtr);
        _0 = &(*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:403:1: 403:16>::from_ptr_unchecked(_1: *const i8) -> &MemberName {
    debug b => _1;
    let mut _0: &bus::MemberName;
    let _2: &[u8];
    let _3: &std::ffi::CStr;

    bb0: {
        _3 = CStr::from_ptr::<'_>(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = CStr::to_bytes(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = MemberName::from_bytes_unchecked(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:468:1: 468:26>::deref(_1: &MemberName) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;

    bb0: {
        _0 = &((*_1).0: std::ffi::CStr);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:527:10: 527:15>::fmt(_1: &MessageType, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: u8;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "Signal";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "MethodCall";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "MethodReturn";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "MethodError";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:527:23: 527:28>::clone(_1: &MessageType) -> MessageType {
    debug self => _1;
    let mut _0: bus::MessageType;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:527:30: 527:39>::eq(_1: &MessageType, _2: &MessageType) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: u8;
    scope 1 {
        debug __self_tag => _3;
        let _4: u8;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:527:41: 527:43>::assert_receiver_is_total_eq(_1: &MessageType) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:536:1: 536:17>::from_raw(_1: u8) -> MessageType {
    debug raw => _1;
    let mut _0: bus::MessageType;
    let mut _2: i32;
    let mut _3: !;

    bb0: {
        _2 = _1 as i32 (IntToInt);
        switchInt(_2) -> [1: bb2, 2: bb3, 3: bb4, 4: bb5, otherwise: bb1];
    }

    bb1: {
        _3 = begin_panic::<&str>(const "explicit panic") -> unwind continue;
    }

    bb2: {
        _0 = MessageType::MethodCall;
        goto -> bb6;
    }

    bb3: {
        _0 = MessageType::MethodReturn;
        goto -> bb6;
    }

    bb4: {
        _0 = MessageType::MethodError;
        goto -> bb6;
    }

    bb5: {
        _0 = MessageType::Signal;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:571:1: 571:14>::from_ptr(_1: *const sd_bus_error) -> &RawError {
    debug ptr => _1;
    let mut _0: &bus::RawError;
    let _2: *const bus::RawError;

    bb0: {
        _2 = _1 as *const bus::RawError (PtrToPtr);
        _0 = &(*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::from_raw(_1: RawError) -> bus::Error {
    debug raw => _1;
    let mut _0: bus::Error;
    let _2: usize;
    let _3: &[u8];
    let _4: &std::ffi::CStr;
    let mut _5: *const i8;
    let mut _7: bool;
    let mut _8: *const i8;
    let _9: &[u8];
    let _10: &std::ffi::CStr;
    let mut _11: *const i8;
    let mut _12: bus::RawError;
    let mut _13: usize;
    scope 1 {
        debug n => _2;
        let _6: usize;
        scope 2 {
            debug m => _6;
        }
    }

    bb0: {
        _5 = ((_1.0: ffi::bus::sd_bus_error).0: *const i8);
        _4 = CStr::from_ptr::<'_>(move _5) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        _3 = CStr::to_bytes_with_nul(_4) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _2 = Len((*_3));
        _8 = ((_1.0: ffi::bus::sd_bus_error).1: *const i8);
        _7 = std::ptr::const_ptr::<impl *const i8>::is_null(move _8) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _6 = const 0_usize;
        goto -> bb8;
    }

    bb5: {
        _11 = ((_1.0: ffi::bus::sd_bus_error).1: *const i8);
        _10 = CStr::from_ptr::<'_>(move _11) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _9 = CStr::to_bytes_with_nul(_10) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _6 = Len((*_9));
        goto -> bb8;
    }

    bb8: {
        _12 = move _1;
        _13 = _6;
        _0 = bus::Error { raw: move _12, name_len: _2, message_len: move _13 };
        return;
    }

    bb9 (cleanup): {
        drop(_1) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::new(_1: &Utf8CStr, _2: Option<&Utf8CStr>) -> bus::Error {
    debug name => _1;
    debug message => _2;
    let mut _0: bus::Error;
    let _3: bus::RawError;
    let mut _4: bus::RawError;
    let mut _5: usize;
    let mut _6: usize;
    let _7: &str;
    let mut _8: (usize, bool);
    let mut _9: usize;
    scope 1 {
        debug v => _3;
    }

    bb0: {
        _3 = RawError::with(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = move _3;
        _7 = <Utf8CStr as Deref>::deref(_1) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _6 = core::str::<impl str>::len(_7) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _8 = CheckedAdd(_6, const 1_usize);
        assert(!move (_8.1: bool), "attempt to compute `{} + {}`, which would overflow", move _6, const 1_usize) -> [success: bb4, unwind: bb6];
    }

    bb4: {
        _5 = move (_8.0: usize);
        _9 = Option::<&Utf8CStr>::map_or::<usize, {closure@src/bus/mod.rs:616:44: 616:47}>(_2, const 0_usize, const ZeroSized: {closure@src/bus/mod.rs:616:44: 616:47}) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = bus::Error { raw: move _4, name_len: move _5, message_len: move _9 };
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::new::{closure#0}(_1: {closure@src/bus/mod.rs:616:44: 616:47}, _2: &Utf8CStr) -> usize {
    debug x => _2;
    let mut _0: usize;
    let mut _3: usize;
    let _4: &str;
    let mut _5: (usize, bool);

    bb0: {
        _4 = <Utf8CStr as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = core::str::<impl str>::len(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = CheckedAdd(_3, const 1_usize);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", move _3, const 1_usize) -> [success: bb3, unwind continue];
    }

    bb3: {
        _0 = move (_5.0: usize);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::name(_1: &bus::Error) -> &Utf8CStr {
    debug self => _1;
    let mut _0: &utf8_cstr::Utf8CStr;
    let mut _2: *const i8;
    let mut _3: usize;
    scope 1 {
    }

    bb0: {
        _2 = ((((*_1).0: bus::RawError).0: ffi::bus::sd_bus_error).0: *const i8);
        _3 = ((*_1).1: usize);
        _0 = Utf8CStr::from_raw_parts::<'_>(move _2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::message(_1: &bus::Error) -> Option<&Utf8CStr> {
    debug self => _1;
    let mut _0: std::option::Option<&utf8_cstr::Utf8CStr>;
    let _2: *const i8;
    let mut _3: bool;
    let _4: &utf8_cstr::Utf8CStr;
    let mut _5: *const i8;
    let mut _6: usize;
    scope 1 {
        debug p => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = ((((*_1).0: bus::RawError).0: ffi::bus::sd_bus_error).1: *const i8);
        _3 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<&Utf8CStr>::None;
        goto -> bb5;
    }

    bb3: {
        _5 = ((((*_1).0: bus::RawError).0: ffi::bus::sd_bus_error).1: *const i8);
        _6 = ((*_1).2: usize);
        _4 = Utf8CStr::from_raw_parts::<'_>(move _5, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<&Utf8CStr>::Some(_4);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::as_ptr(_1: &bus::Error) -> *const sd_bus_error {
    debug self => _1;
    let mut _0: *const ffi::bus::sd_bus_error;
    let mut _2: &bus::RawError;

    bb0: {
        _2 = &((*_1).0: bus::RawError);
        _0 = RawError::as_ptr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:591:1: 591:11>::move_into(_1: bus::Error, _2: *mut sd_bus_error) -> () {
    debug self => _1;
    debug dest => _2;
    let mut _0: ();
    let _3: ffi::bus::sd_bus_error;
    let mut _4: *const ffi::bus::sd_bus_error;
    let _5: &ffi::bus::sd_bus_error;
    let _6: ();
    let mut _7: bus::Error;
    let mut _8: bool;
    scope 1 {
        debug x => _3;
        let mut _9: *const ();
        let mut _10: usize;
        let mut _11: usize;
        let mut _12: usize;
        let mut _13: usize;
        let mut _14: bool;
    }

    bb0: {
        _8 = const false;
        _8 = const true;
        _5 = &((_1.0: bus::RawError).0: ffi::bus::sd_bus_error);
        _4 = &raw const (*_5);
        _3 = std::ptr::read::<sd_bus_error>(move _4) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _8 = const false;
        _7 = move _1;
        _6 = std::mem::forget::<bus::Error>(move _7) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _9 = _2 as *const () (PtrToPtr);
        _10 = _9 as usize (Transmute);
        _11 = AlignOf(ffi::bus::sd_bus_error);
        _12 = Sub(_11, const 1_usize);
        _13 = BitAnd(_10, _12);
        _14 = Eq(_13, const 0_usize);
        assert(_14, "misaligned pointer dereference: address must be a multiple of {} but is {}", _11, _10) -> [success: bb6, unwind unreachable];
    }

    bb3 (cleanup): {
        resume;
    }

    bb4 (cleanup): {
        drop(_1) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        switchInt(_8) -> [0: bb3, otherwise: bb4];
    }

    bb6: {
        (*_2) = move _3;
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:644:1: 644:35>::description(_1: &bus::Error) -> &str {
    debug self => _1;
    let mut _0: &str;
    let _2: &str;
    let mut _3: std::option::Option<&utf8_cstr::Utf8CStr>;
    let mut _4: isize;
    let _5: &utf8_cstr::Utf8CStr;
    let _6: &str;
    let _7: &str;
    let _8: &utf8_cstr::Utf8CStr;
    scope 1 {
        debug m => _5;
    }

    bb0: {
        _3 = bus::Error::message(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _8 = bus::Error::name(_1) -> [return: bb6, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: &utf8_cstr::Utf8CStr);
        _6 = <Utf8CStr as AsRef<str>>::as_ref(_5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = _6;
        goto -> bb8;
    }

    bb6: {
        _7 = <Utf8CStr as AsRef<str>>::as_ref(_8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _2 = _7;
        goto -> bb8;
    }

    bb8: {
        _0 = _2;
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:653:1: 653:26>::fmt(_1: &bus::Error, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: std::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&utf8_cstr::Utf8CStr;
    let _12: &utf8_cstr::Utf8CStr;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::option::Option<&utf8_cstr::Utf8CStr>;
    let _16: std::option::Option<&utf8_cstr::Utf8CStr>;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &i32;

    bb0: {
        _8 = const "Error";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "name";
        _12 = bus::Error::name(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = &_12;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = const "message";
        _16 = bus::Error::message(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _13, move _14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = const "need_free";
        _19 = &((((*_1).0: bus::RawError).0: ffi::bus::sd_bus_error).2: i32);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _17, move _18) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:664:1: 664:28>::fmt(_1: &bus::Error, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: std::option::Option<&utf8_cstr::Utf8CStr>;
    let mut _4: isize;
    let _5: &utf8_cstr::Utf8CStr;
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 2];
    let _10: [core::fmt::rt::Argument<'_>; 2];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &&utf8_cstr::Utf8CStr;
    let _13: &utf8_cstr::Utf8CStr;
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &&utf8_cstr::Utf8CStr;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &&utf8_cstr::Utf8CStr;
    let _23: &utf8_cstr::Utf8CStr;
    let mut _24: &[&str; 1];
    scope 1 {
        debug m => _5;
        let mut _25: &[&str; 2];
    }

    bb0: {
        _3 = bus::Error::message(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _24 = const _;
        _17 = _24 as &[&str] (PointerCoercion(Unsize));
        _23 = bus::Error::name(_1) -> [return: bb9, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = ((_3 as Some).0: &utf8_cstr::Utf8CStr);
        _25 = const _;
        _7 = _25 as &[&str] (PointerCoercion(Unsize));
        _13 = bus::Error::name(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _12 = &_13;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<&Utf8CStr>(_12) -> [return: bb6, unwind continue];
    }

    bb6: {
        _15 = &_5;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<&Utf8CStr>(_15) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = [move _11, move _14];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_v1(move _7, move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb12, unwind continue];
    }

    bb9: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<&Utf8CStr>(_22) -> [return: bb10, unwind continue];
    }

    bb10: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = Formatter::<'_>::write_fmt(_2, move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

promoted[0] in bus::<impl at src/bus/mod.rs:664:1: 664:28>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "Dbus Error: "];
        _0 = &_1;
        return;
    }
}

promoted[1] in bus::<impl at src/bus/mod.rs:664:1: 664:28>::fmt: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "Dbus Error: ", const ": "];
        _0 = &_1;
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:673:1: 673:26>::default() -> RawError {
    let mut _0: bus::RawError;
    let mut _1: ffi::bus::sd_bus_error;
    let mut _2: *const i8;
    let mut _3: *const i8;

    bb0: {
        _2 = null::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = null::<i8>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _1 = sd_bus_error { name: move _2, message: move _3, need_free: const 0_i32 };
        _0 = RawError { inner: move _1 };
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:686:1: 686:47>::from(_1: sd_bus_error) -> RawError {
    debug inner => _1;
    let mut _0: bus::RawError;

    bb0: {
        _0 = RawError { inner: move _1 };
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::new() -> RawError {
    let mut _0: bus::RawError;

    bb0: {
        _0 = <RawError as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::into_result(_1: RawError) -> std::result::Result<(), bus::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), bus::Error>;
    let mut _2: bool;
    let mut _3: &bus::RawError;
    let mut _4: bus::Error;
    let mut _5: bus::RawError;
    let mut _6: bool;
    scope 1 {
    }

    bb0: {
        _6 = const false;
        _6 = const true;
        _3 = &_1;
        _2 = RawError::is_set(move _3) -> [return: bb1, unwind: bb10];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _6 = const false;
        _5 = move _1;
        _4 = bus::Error::from_raw(move _5) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _0 = std::result::Result::<(), bus::Error>::Err(move _4);
        goto -> bb5;
    }

    bb4: {
        _0 = std::result::Result::<(), bus::Error>::Ok(const ());
        goto -> bb5;
    }

    bb5: {
        switchInt(_6) -> [0: bb6, otherwise: bb8];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8: {
        drop(_1) -> [return: bb6, unwind continue];
    }

    bb9 (cleanup): {
        drop(_1) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_6) -> [0: bb7, otherwise: bb9];
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::with(_1: &Utf8CStr, _2: Option<&Utf8CStr>) -> RawError {
    debug name => _1;
    debug message => _2;
    let mut _0: bus::RawError;
    let mut _3: bus::RawError;
    let _4: ();
    let mut _5: &mut bus::RawError;
    scope 1 {
        debug v => _3;
    }

    bb0: {
        _3 = <RawError as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _3;
        _4 = RawError::set(move _5, _1, _2) -> [return: bb2, unwind: bb3];
    }

    bb2: {
        _0 = move _3;
        return;
    }

    bb3 (cleanup): {
        drop(_3) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::set(_1: &mut RawError, _2: &Utf8CStr, _3: Option<&Utf8CStr>) -> () {
    debug self => _1;
    debug name => _2;
    debug message => _3;
    let mut _0: ();
    let _4: i32;
    let mut _5: *mut ffi::bus::sd_bus_error;
    let mut _6: &mut ffi::bus::sd_bus_error;
    let mut _7: *const i8;
    let mut _8: *const i8;
    let mut _9: *const i8;
    scope 1 {
    }

    bb0: {
        _6 = &mut ((*_1).0: ffi::bus::sd_bus_error);
        _5 = &raw mut (*_6);
        _7 = Utf8CStr::as_ptr(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = null::<i8>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = Option::<&Utf8CStr>::map_or::<*const i8, {closure@src/bus/mod.rs:721:45: 721:48}>(_3, move _9, const ZeroSized: {closure@src/bus/mod.rs:721:45: 721:48}) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = sd_bus_error_set(move _5, move _7, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::set::{closure#0}(_1: {closure@src/bus/mod.rs:721:45: 721:48}, _2: &Utf8CStr) -> *const i8 {
    debug x => _2;
    let mut _0: *const i8;

    bb0: {
        _0 = Utf8CStr::as_ptr(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::is_set(_1: &RawError) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: *const i8;

    bb0: {
        _3 = (((*_1).0: ffi::bus::sd_bus_error).0: *const i8);
        _2 = std::ptr::const_ptr::<impl *const i8>::is_null(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Not(move _2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::as_mut_ptr(_1: &mut RawError) -> *mut sd_bus_error {
    debug self => _1;
    let mut _0: *mut ffi::bus::sd_bus_error;
    let mut _2: &mut ffi::bus::sd_bus_error;

    bb0: {
        _2 = &mut ((*_1).0: ffi::bus::sd_bus_error);
        _0 = &raw mut (*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::as_ptr(_1: &RawError) -> *const sd_bus_error {
    debug self => _1;
    let mut _0: *const ffi::bus::sd_bus_error;
    let _2: &ffi::bus::sd_bus_error;

    bb0: {
        _2 = &((*_1).0: ffi::bus::sd_bus_error);
        _0 = &raw const (*_2);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::name(_1: &RawError) -> Option<&InterfaceName> {
    debug self => _1;
    let mut _0: std::option::Option<&bus::InterfaceName>;
    let mut _2: bool;
    let _3: &bus::InterfaceName;
    let mut _4: *const i8;
    scope 1 {
    }

    bb0: {
        _2 = RawError::is_set(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _4 = (((*_1).0: ffi::bus::sd_bus_error).0: *const i8);
        _3 = InterfaceName::from_ptr_unchecked::<'_>(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = Option::<&InterfaceName>::Some(_3);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<&InterfaceName>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::message(_1: &RawError) -> Option<&Utf8CStr> {
    debug self => _1;
    let mut _0: std::option::Option<&utf8_cstr::Utf8CStr>;
    let mut _2: bool;
    let _3: &utf8_cstr::Utf8CStr;
    let mut _4: *const i8;
    scope 1 {
    }

    bb0: {
        _2 = RawError::is_set(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _4 = (((*_1).0: ffi::bus::sd_bus_error).0: *const i8);
        _3 = Utf8CStr::from_ptr_unchecked::<'_>(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = Option::<&Utf8CStr>::Some(_3);
        goto -> bb5;
    }

    bb4: {
        _0 = Option::<&Utf8CStr>::None;
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:692:1: 692:14>::errno(_1: &RawError) -> Option<i32> {
    debug self => _1;
    let mut _0: std::option::Option<i32>;
    let mut _2: bool;
    let mut _3: i32;
    let mut _4: *const ffi::bus::sd_bus_error;
    scope 1 {
    }

    bb0: {
        _2 = RawError::is_set(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _4 = RawError::as_ptr(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = sd_bus_error_get_errno(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Option::<i32>::Some(move _3);
        goto -> bb6;
    }

    bb5: {
        _0 = Option::<i32>::None;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:775:1: 775:23>::drop(_1: &mut RawError) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: ();
    let mut _3: *mut ffi::bus::sd_bus_error;
    let mut _4: &mut ffi::bus::sd_bus_error;
    scope 1 {
    }

    bb0: {
        _4 = &mut ((*_1).0: ffi::bus::sd_bus_error);
        _3 = &raw mut (*_4);
        _2 = sd_bus_error_free(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:782:1: 782:24>::clone(_1: &RawError) -> RawError {
    debug self => _1;
    let mut _0: bus::RawError;
    let mut _2: std::mem::MaybeUninit<ffi::bus::sd_bus_error>;
    let _3: i32;
    let mut _4: *mut ffi::bus::sd_bus_error;
    let mut _5: &mut std::mem::MaybeUninit<ffi::bus::sd_bus_error>;
    let mut _6: *const ffi::bus::sd_bus_error;
    let _7: &ffi::bus::sd_bus_error;
    let mut _9: std::mem::MaybeUninit<ffi::bus::sd_bus_error>;
    scope 1 {
        debug e => _2;
        let _8: ffi::bus::sd_bus_error;
        scope 2 {
        }
        scope 3 {
            debug e => _8;
        }
        scope 4 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<sd_bus_error>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _2;
        _4 = MaybeUninit::<sd_bus_error>::as_mut_ptr(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &((*_1).0: ffi::bus::sd_bus_error);
        _6 = &raw const (*_7);
        _3 = sd_bus_error_copy(move _4, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = move _2;
        _8 = MaybeUninit::<sd_bus_error>::assume_init(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = <sd_bus_error as Into<RawError>>::into(move _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:792:1: 792:29>::fmt(_1: &RawError, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: std::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &std::option::Option<&bus::InterfaceName>;
    let _12: std::option::Option<&bus::InterfaceName>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::option::Option<&utf8_cstr::Utf8CStr>;
    let _16: std::option::Option<&utf8_cstr::Utf8CStr>;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &i32;

    bb0: {
        _8 = const "RawError";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "name";
        _12 = RawError::name(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = &_12;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = const "message";
        _16 = RawError::message(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _13, move _14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = const "need_free";
        _19 = &(((*_1).0: ffi::bus::sd_bus_error).2: i32);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _17, move _18) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:803:1: 803:31>::fmt(_1: &RawError, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: std::fmt::DebugStruct<'_, '_>;
    let _8: &str;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &std::option::Option<&bus::InterfaceName>;
    let _12: std::option::Option<&bus::InterfaceName>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::option::Option<&utf8_cstr::Utf8CStr>;
    let _16: std::option::Option<&utf8_cstr::Utf8CStr>;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &i32;

    bb0: {
        _8 = const "RawError";
        _7 = Formatter::<'_>::debug_struct(_2, _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _7;
        _9 = const "name";
        _12 = RawError::name(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = &_12;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(move _6, _9, move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = const "message";
        _16 = RawError::message(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _13, move _14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = const "need_free";
        _19 = &(((*_1).0: ffi::bus::sd_bus_error).2: i32);
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _17, move _18) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn raw_message_handler(_1: *mut sd_bus_message, _2: *mut c_void, _3: *mut sd_bus_error) -> i32 {
    debug msg => _1;
    debug userdata => _2;
    debug ret_error => _3;
    let mut _0: i32;
    let _4: std::boxed::Box<F>;
    let mut _5: *mut F;
    let mut _7: &std::boxed::Box<F>;
    let mut _8: (&mut bus::MessageRef,);
    let mut _9: &mut bus::MessageRef;
    let mut _10: isize;
    let _12: ();
    scope 1 {
        debug m => _4;
        let _6: std::result::Result<(), bus::Error>;
        scope 3 {
            debug e => _6;
            let _11: bus::Error;
            scope 5 {
                debug e => _11;
                scope 6 {
                }
            }
        }
        scope 4 {
        }
    }
    scope 2 {
    }

    bb0: {
        _5 = _2 as *mut F (PtrToPtr);
        _4 = Box::<F>::from_raw(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_4;
        _9 = <MessageRef as ForeignTypeRef>::from_ptr_mut::<'_>(_1) -> [return: bb2, unwind: bb9];
    }

    bb2: {
        _8 = (_9,);
        _6 = <Box<F> as Fn<(&mut MessageRef,)>>::call(move _7, move _8) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _10 = discriminant(_6);
        switchInt(move _10) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _0 = const 0_i32;
        goto -> bb11;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _11 = move ((_6 as Err).0: bus::Error);
        _12 = bus::Error::move_into(move _11, _3) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _0 = const 0_i32;
        goto -> bb11;
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        drop(_4) -> [return: bb8, unwind continue];
    }
}

fn raw_destroy_cb_message_handler(_1: *mut c_void) -> () {
    debug userdata => _1;
    let mut _0: ();
    let mut _2: std::boxed::Box<F>;
    let mut _3: *mut F;
    scope 1 {
    }
    scope 2 {
    }

    bb0: {
        _3 = _1 as *mut F (PtrToPtr);
        _2 = Box::<F>::from_raw(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::from_ptr(_1: *mut sd_bus) -> Bus {
    debug ptr => _1;
    let mut _0: bus::Bus;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: !;
    let mut _5: std::ptr::NonNull<ffi::bus::sd_bus>;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _3 = std::ptr::mut_ptr::<impl *mut sd_bus>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _4 = core::panicking::panic(const "assertion failed: !ptr.is_null()") -> unwind continue;
    }

    bb4: {
        _5 = NonNull::<sd_bus>::new_unchecked(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Bus(move _5);
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ptr(_1: &Bus) -> *mut sd_bus {
    debug self => _1;
    let mut _0: *mut ffi::bus::sd_bus;
    let mut _2: std::ptr::NonNull<ffi::bus::sd_bus>;

    bb0: {
        _2 = ((*_1).0: std::ptr::NonNull<ffi::bus::sd_bus>);
        _0 = NonNull::<sd_bus>::as_ptr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::drop(_1: &mut Bus) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: *mut ffi::bus::sd_bus;
    let mut _3: *mut ffi::bus::sd_bus;
    let mut _4: &bus::Bus;
    scope 1 {
    }

    bb0: {
        _4 = &(*_1);
        _3 = <Bus as ForeignType>::as_ptr(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_unref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref(_1: &Bus) -> &BusRef {
    debug self => _1;
    let mut _0: &bus::BusRef;
    let mut _2: *mut ffi::bus::sd_bus;
    scope 1 {
    }

    bb0: {
        _2 = <Bus as ForeignType>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <BusRef as ForeignTypeRef>::from_ptr::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref_mut(_1: &mut Bus) -> &mut BusRef {
    debug self => _1;
    let mut _0: &mut bus::BusRef;
    let mut _2: *mut ffi::bus::sd_bus;
    let mut _3: &bus::Bus;
    scope 1 {
    }

    bb0: {
        _3 = &(*_1);
        _2 = <Bus as ForeignType>::as_ptr(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <BusRef as ForeignTypeRef>::from_ptr_mut::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow(_1: &Bus) -> &BusRef {
    debug self => _1;
    let mut _0: &bus::BusRef;

    bb0: {
        _0 = <Bus as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow_mut(_1: &mut Bus) -> &mut BusRef {
    debug self => _1;
    let mut _0: &mut bus::BusRef;

    bb0: {
        _0 = <Bus as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ref(_1: &Bus) -> &BusRef {
    debug self => _1;
    let mut _0: &bus::BusRef;

    bb0: {
        _0 = <Bus as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_mut(_1: &mut Bus) -> &mut BusRef {
    debug self => _1;
    let mut _0: &mut bus::BusRef;

    bb0: {
        _0 = <Bus as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::clone(_1: &Bus) -> Bus {
    debug self => _1;
    let mut _0: bus::Bus;
    let mut _3: *mut ffi::bus::sd_bus;
    scope 1 {
        let _2: *mut ffi::bus::sd_bus;
        scope 2 {
            debug ptr => _2;
        }
    }

    bb0: {
        _3 = <Bus as ForeignType>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_ref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Bus as ForeignType>::from_ptr(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::to_owned(_1: &BusRef) -> Bus {
    debug self => _1;
    let mut _0: bus::Bus;
    let mut _3: *mut ffi::bus::sd_bus;
    scope 1 {
        let _2: *mut ffi::bus::sd_bus;
        scope 2 {
            debug ptr => _2;
        }
    }

    bb0: {
        _3 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_ref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Bus as ForeignType>::from_ptr(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:863:1: 863:9>::default() -> std::result::Result<Bus, std::io::Error> {
    let mut _0: std::result::Result<bus::Bus, std::io::Error>;
    let mut _1: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut *mut ffi::bus::sd_bus;
    let mut _6: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _7: isize;
    let mut _10: bus::Bus;
    let mut _11: *mut ffi::bus::sd_bus;
    let mut _12: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    scope 1 {
        debug b => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _1 = MaybeUninit::<*mut sd_bus>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _1;
        _5 = MaybeUninit::<*mut sd_bus>::as_mut_ptr(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = sd_bus_default(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = ffi_result(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _9 = ((_2 as Continue).0: i32);
        _12 = _1;
        _11 = MaybeUninit::<*mut sd_bus>::assume_init(move _12) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Bus, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb11, unwind continue];
    }

    bb9: {
        _10 = <Bus as ForeignType>::from_ptr(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<Bus, std::io::Error>::Ok(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:863:1: 863:9>::default_user() -> std::result::Result<Bus, std::io::Error> {
    let mut _0: std::result::Result<bus::Bus, std::io::Error>;
    let mut _1: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut *mut ffi::bus::sd_bus;
    let mut _6: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _7: isize;
    let mut _10: bus::Bus;
    let mut _11: *mut ffi::bus::sd_bus;
    let mut _12: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    scope 1 {
        debug b => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _1 = MaybeUninit::<*mut sd_bus>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _1;
        _5 = MaybeUninit::<*mut sd_bus>::as_mut_ptr(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = sd_bus_default_user(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = ffi_result(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _9 = ((_2 as Continue).0: i32);
        _12 = _1;
        _11 = MaybeUninit::<*mut sd_bus>::assume_init(move _12) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Bus, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb11, unwind continue];
    }

    bb9: {
        _10 = <Bus as ForeignType>::from_ptr(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<Bus, std::io::Error>::Ok(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:863:1: 863:9>::default_system() -> std::result::Result<Bus, std::io::Error> {
    let mut _0: std::result::Result<bus::Bus, std::io::Error>;
    let mut _1: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut *mut ffi::bus::sd_bus;
    let mut _6: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    let mut _7: isize;
    let mut _10: bus::Bus;
    let mut _11: *mut ffi::bus::sd_bus;
    let mut _12: std::mem::MaybeUninit<*mut ffi::bus::sd_bus>;
    scope 1 {
        debug b => _1;
        let _8: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _9: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _8;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _9;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _1 = MaybeUninit::<*mut sd_bus>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut _1;
        _5 = MaybeUninit::<*mut sd_bus>::as_mut_ptr(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = sd_bus_default_system(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = ffi_result(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = discriminant(_2);
        switchInt(move _7) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _9 = ((_2 as Continue).0: i32);
        _12 = _1;
        _11 = MaybeUninit::<*mut sd_bus>::assume_init(move _12) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _8 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Bus, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _8) -> [return: bb11, unwind continue];
    }

    bb9: {
        _10 = <Bus as ForeignType>::from_ptr(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<Bus, std::io::Error>::Ok(move _10);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:886:1: 886:27>::fmt(_1: &BusRef, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _8: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _9: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _10: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _11: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _12: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _13: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _14: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _15: std::fmt::DebugStruct<'_, '_>;
    let _16: &str;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &std::result::Result<&bus::BusName, std::io::Error>;
    let _20: std::result::Result<&bus::BusName, std::io::Error>;
    let _21: &str;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &std::result::Result<id128::Id128, std::io::Error>;
    let _24: std::result::Result<id128::Id128, std::io::Error>;
    let _25: &str;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _28: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _29: &str;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &std::result::Result<i32, std::io::Error>;
    let _32: std::result::Result<i32, std::io::Error>;
    let _33: &str;
    let mut _34: &dyn std::fmt::Debug;
    let _35: &std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _36: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _37: &str;
    let mut _38: &dyn std::fmt::Debug;
    let _39: &std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _40: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let _41: &str;
    let mut _42: &dyn std::fmt::Debug;
    let _43: &std::result::Result<i32, std::io::Error>;
    let _44: std::result::Result<i32, std::io::Error>;
    let _45: &str;
    let mut _46: &dyn std::fmt::Debug;
    let _47: &std::result::Result<i32, std::io::Error>;
    let _48: std::result::Result<i32, std::io::Error>;
    let _49: &str;
    let mut _50: &dyn std::fmt::Debug;
    let _51: &std::result::Result<u64, std::io::Error>;
    let _52: std::result::Result<u64, std::io::Error>;
    let _53: &str;
    let mut _54: &dyn std::fmt::Debug;
    let _55: &std::result::Result<u64, std::io::Error>;
    let _56: std::result::Result<u64, std::io::Error>;
    let _57: &str;
    let mut _58: &dyn std::fmt::Debug;
    let _59: &std::result::Result<u64, std::io::Error>;
    let _60: std::result::Result<u64, std::io::Error>;

    bb0: {
        _16 = const "BusRef";
        _15 = Formatter::<'_>::debug_struct(_2, _16) -> [return: bb1, unwind continue];
    }

    bb1: {
        _14 = &mut _15;
        _17 = const "unique_name";
        _20 = BusRef::unique_name(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = DebugStruct::<'_, '_>::field(move _14, _17, move _18) -> [return: bb3, unwind: bb46];
    }

    bb3: {
        _21 = const "bus_id";
        _24 = BusRef::bus_id(_1) -> [return: bb4, unwind: bb46];
    }

    bb4: {
        _23 = &_24;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _12 = DebugStruct::<'_, '_>::field(_13, _21, move _22) -> [return: bb5, unwind: bb45];
    }

    bb5: {
        _25 = const "scope";
        _28 = BusRef::scope(_1) -> [return: bb6, unwind: bb45];
    }

    bb6: {
        _27 = &_28;
        _26 = _27 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = DebugStruct::<'_, '_>::field(_12, _25, move _26) -> [return: bb7, unwind: bb44];
    }

    bb7: {
        _29 = const "tid";
        _32 = BusRef::tid(_1) -> [return: bb8, unwind: bb44];
    }

    bb8: {
        _31 = &_32;
        _30 = _31 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = DebugStruct::<'_, '_>::field(_11, _29, move _30) -> [return: bb9, unwind: bb43];
    }

    bb9: {
        _33 = const "description";
        _36 = BusRef::description(_1) -> [return: bb10, unwind: bb43];
    }

    bb10: {
        _35 = &_36;
        _34 = _35 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = DebugStruct::<'_, '_>::field(_10, _33, move _34) -> [return: bb11, unwind: bb42];
    }

    bb11: {
        _37 = const "address";
        _40 = BusRef::address(_1) -> [return: bb12, unwind: bb42];
    }

    bb12: {
        _39 = &_40;
        _38 = _39 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = DebugStruct::<'_, '_>::field(_9, _37, move _38) -> [return: bb13, unwind: bb41];
    }

    bb13: {
        _41 = const "fd";
        _44 = BusRef::fd(_1) -> [return: bb14, unwind: bb41];
    }

    bb14: {
        _43 = &_44;
        _42 = _43 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = DebugStruct::<'_, '_>::field(_8, _41, move _42) -> [return: bb15, unwind: bb40];
    }

    bb15: {
        _45 = const "events";
        _48 = BusRef::events(_1) -> [return: bb16, unwind: bb40];
    }

    bb16: {
        _47 = &_48;
        _46 = _47 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _6 = DebugStruct::<'_, '_>::field(_7, _45, move _46) -> [return: bb17, unwind: bb39];
    }

    bb17: {
        _49 = const "n_queued_read";
        _52 = BusRef::n_queued_read(_1) -> [return: bb18, unwind: bb39];
    }

    bb18: {
        _51 = &_52;
        _50 = _51 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(_6, _49, move _50) -> [return: bb19, unwind: bb38];
    }

    bb19: {
        _53 = const "n_queued_write";
        _56 = BusRef::n_queued_write(_1) -> [return: bb20, unwind: bb38];
    }

    bb20: {
        _55 = &_56;
        _54 = _55 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _53, move _54) -> [return: bb21, unwind: bb37];
    }

    bb21: {
        _57 = const "method_call_timeout";
        _60 = BusRef::method_call_timeout(_1) -> [return: bb22, unwind: bb37];
    }

    bb22: {
        _59 = &_60;
        _58 = _59 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _57, move _58) -> [return: bb23, unwind: bb36];
    }

    bb23: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb24, unwind: bb36];
    }

    bb24: {
        drop(_60) -> [return: bb25, unwind: bb37];
    }

    bb25: {
        drop(_56) -> [return: bb26, unwind: bb38];
    }

    bb26: {
        drop(_52) -> [return: bb27, unwind: bb39];
    }

    bb27: {
        drop(_48) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        drop(_44) -> [return: bb29, unwind: bb41];
    }

    bb29: {
        drop(_40) -> [return: bb30, unwind: bb42];
    }

    bb30: {
        drop(_36) -> [return: bb31, unwind: bb43];
    }

    bb31: {
        drop(_32) -> [return: bb32, unwind: bb44];
    }

    bb32: {
        drop(_28) -> [return: bb33, unwind: bb45];
    }

    bb33: {
        drop(_24) -> [return: bb34, unwind: bb46];
    }

    bb34: {
        drop(_20) -> [return: bb35, unwind continue];
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_60) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_56) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_52) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_48) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_44) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_40) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_36) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_32) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_28) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_24) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_20) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::fd(_1: &BusRef) -> std::result::Result<i32, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::bus::sd_bus;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _8: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_bus_get_fd(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<i32, std::io::Error>::Ok(_8);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<i32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::events(_1: &BusRef) -> std::result::Result<i32, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::bus::sd_bus;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _8: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_bus_get_events(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = discriminant(_2);
        switchInt(move _6) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _8 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<i32, std::io::Error>::Ok(_8);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _7 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<i32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _7) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::timeout(_1: &BusRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<u64>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut u64;
    let mut _8: &mut std::mem::MaybeUninit<u64>;
    let mut _9: isize;
    let mut _13: std::mem::MaybeUninit<u64>;
    scope 1 {
        debug b => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        let _12: u64;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
        scope 7 {
            debug b => _12;
        }
        scope 8 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<u64>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = MaybeUninit::<u64>::as_mut_ptr(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_bus_get_timeout(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = MaybeUninit::<u64>::assume_init(move _13) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<u64, std::io::Error>::Ok(_12);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::process(_1: &mut BusRef) -> std::result::Result<Option<Option<Message>>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::option::Option<bus::Message>>, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: &bus::BusRef;
    let mut _8: *mut *mut ffi::bus::sd_bus_message;
    let mut _9: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _10: isize;
    let mut _13: bool;
    let mut _15: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _16: bool;
    let mut _17: std::option::Option<std::option::Option<bus::Message>>;
    let mut _18: std::option::Option<bus::Message>;
    let mut _19: std::option::Option<std::option::Option<bus::Message>>;
    let mut _20: std::option::Option<bus::Message>;
    let mut _21: bus::Message;
    let mut _22: std::option::Option<std::option::Option<bus::Message>>;
    scope 1 {
        debug b => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
            debug r => _12;
            let _14: *mut ffi::bus::sd_bus_message;
            scope 8 {
                debug b => _14;
                scope 10 {
                }
            }
            scope 9 {
            }
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _11;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _12;
            scope 7 {
            }
        }
    }

    bb0: {
        _2 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &(*_1);
        _6 = <BusRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_bus_process(move _6, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_3 as Continue).0: i32);
        _13 = Gt(_12, const 0_i32);
        switchInt(move _13) -> [0: bb16, otherwise: bb10];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Option<Option<Message>>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb17, unwind continue];
    }

    bb10: {
        _15 = _2;
        _14 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _15) -> [return: bb11, unwind continue];
    }

    bb11: {
        _16 = std::ptr::mut_ptr::<impl *mut sd_bus_message>::is_null(_14) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _16) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _18 = Option::<Message>::None;
        _17 = Option::<Option<Message>>::Some(move _18);
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _17);
        goto -> bb17;
    }

    bb14: {
        _21 = <Message as ForeignType>::from_ptr(_14) -> [return: bb15, unwind continue];
    }

    bb15: {
        _20 = Option::<Message>::Some(move _21);
        _19 = Option::<Option<Message>>::Some(move _20);
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _19);
        goto -> bb17;
    }

    bb16: {
        _22 = Option::<Option<Message>>::None;
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _22);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::process_priority(_1: &mut BusRef, _2: i64) -> std::result::Result<Option<Option<Message>>, std::io::Error> {
    debug self => _1;
    debug max_priority => _2;
    let mut _0: std::result::Result<std::option::Option<std::option::Option<bus::Message>>, std::io::Error>;
    let mut _3: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus;
    let mut _8: &bus::BusRef;
    let mut _9: *mut *mut ffi::bus::sd_bus_message;
    let mut _10: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _11: isize;
    let mut _14: bool;
    let mut _16: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _17: bool;
    let mut _18: std::option::Option<std::option::Option<bus::Message>>;
    let mut _19: std::option::Option<bus::Message>;
    let mut _20: std::option::Option<std::option::Option<bus::Message>>;
    let mut _21: std::option::Option<bus::Message>;
    let mut _22: bus::Message;
    let mut _23: std::option::Option<std::option::Option<bus::Message>>;
    scope 1 {
        debug b => _3;
        let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _13: i32;
        scope 2 {
            debug r => _13;
            let _15: *mut ffi::bus::sd_bus_message;
            scope 8 {
                debug b => _15;
                scope 10 {
                }
            }
            scope 9 {
            }
        }
        scope 3 {
        }
        scope 4 {
            debug residual => _12;
            scope 5 {
            }
        }
        scope 6 {
            debug val => _13;
            scope 7 {
            }
        }
    }

    bb0: {
        _3 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &(*_1);
        _7 = <BusRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &mut _3;
        _9 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = sd_bus_process_priority(move _7, _2, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = discriminant(_4);
        switchInt(move _11) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _13 = ((_4 as Continue).0: i32);
        _14 = Gt(_13, const 0_i32);
        switchInt(move _14) -> [0: bb16, otherwise: bb10];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _12 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Option<Option<Message>>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb17, unwind continue];
    }

    bb10: {
        _16 = _3;
        _15 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        _17 = std::ptr::mut_ptr::<impl *mut sd_bus_message>::is_null(_15) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _17) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _19 = Option::<Message>::None;
        _18 = Option::<Option<Message>>::Some(move _19);
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _18);
        goto -> bb17;
    }

    bb14: {
        _22 = <Message as ForeignType>::from_ptr(_15) -> [return: bb15, unwind continue];
    }

    bb15: {
        _21 = Option::<Message>::Some(move _22);
        _20 = Option::<Option<Message>>::Some(move _21);
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _20);
        goto -> bb17;
    }

    bb16: {
        _23 = Option::<Option<Message>>::None;
        _0 = std::result::Result::<Option<Option<Message>>, std::io::Error>::Ok(move _23);
        goto -> bb17;
    }

    bb17: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::wait(_1: &mut BusRef, _2: Option<Duration>) -> std::result::Result<bool, std::io::Error> {
    debug self => _1;
    debug timeout => _2;
    let mut _0: std::result::Result<bool, std::io::Error>;
    let mut _3: bool;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus;
    let mut _8: &bus::BusRef;
    let mut _9: u64;
    let mut _10: std::option::Option<u64>;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _13: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }

    bb0: {
        _8 = &(*_1);
        _7 = <BusRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = Option::<Duration>::map::<u64, fn(Duration) -> u64 {usec_from_duration}>(_2, usec_from_duration) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = Option::<u64>::unwrap_or(move _10, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = sd_bus_wait(move _7, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = discriminant(_4);
        switchInt(move _11) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _13 = ((_4 as Continue).0: i32);
        _3 = Gt(_13, const 0_i32);
        _0 = std::result::Result::<bool, std::io::Error>::Ok(move _3);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _12 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::unique_name(_1: &BusRef) -> std::result::Result<&BusName, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&bus::BusName, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<*const i8>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut *const i8;
    let mut _8: &mut std::mem::MaybeUninit<*const i8>;
    let mut _9: isize;
    let mut _13: std::mem::MaybeUninit<*const i8>;
    let _14: &bus::BusName;
    scope 1 {
        debug e => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        let _12: *const i8;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
        scope 7 {
            debug e => _12;
            scope 9 {
            }
        }
        scope 8 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<*const i8>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = MaybeUninit::<*const i8>::as_mut_ptr(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_bus_get_unique_name(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = MaybeUninit::<*const i8>::_init(move _13) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&BusName, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb12, unwind continue];
    }

    bb10: {
        _14 = BusName::from_ptr_unchecked::<'_>(_12) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = std::result::Result::<&BusName, std::io::Error>::Ok(_14);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::scope(_1: &BusRef) -> std::result::Result<&CStr, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let mut _2: *const i8;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut *const i8;
    let mut _8: &mut *const i8;
    let mut _9: isize;
    let _12: &std::ffi::CStr;
    let mut _13: *const i8;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _2 = null::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_scope(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = CStr::from_ptr::<'_>(move _13) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&CStr, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb10, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<&CStr, std::io::Error>::Ok(_12);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::tid(_1: &BusRef) -> std::result::Result<i32, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<i32, std::io::Error>;
    let mut _2: i32;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut i32;
    let mut _8: &mut i32;
    let mut _9: isize;
    let mut _12: i32;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_i32;
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_tid(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<i32, std::io::Error>::Ok(move _12);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<i32, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::description(_1: &BusRef) -> std::result::Result<&CStr, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let mut _2: *const i8;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut *const i8;
    let mut _8: &mut *const i8;
    let mut _9: isize;
    let _12: &std::ffi::CStr;
    let mut _13: *const i8;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _2 = null::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_description(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = CStr::from_ptr::<'_>(move _13) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&CStr, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb10, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<&CStr, std::io::Error>::Ok(_12);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::address(_1: &BusRef) -> std::result::Result<&CStr, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<&std::ffi::CStr, std::io::Error>;
    let mut _2: *const i8;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut *const i8;
    let mut _8: &mut *const i8;
    let mut _9: isize;
    let _12: &std::ffi::CStr;
    let mut _13: *const i8;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _2 = null::<i8>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_address(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _13 = _2;
        _12 = CStr::from_ptr::<'_>(move _13) -> [return: bb9, unwind continue];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<&CStr, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb10, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<&CStr, std::io::Error>::Ok(_12);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::n_queued_write(_1: &BusRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <u64 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_n_queued_write(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::n_queued_read(_1: &BusRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <u64 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_n_queued_read(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::method_call_timeout(_1: &BusRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug ret => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <u64 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_method_call_timeout(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::bus_id(_1: &BusRef) -> std::result::Result<Id128, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<id128::Id128, std::io::Error>;
    let mut _2: id128::Id128;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut ffi::id128::sd_id128_t;
    let mut _8: &mut ffi::id128::sd_id128_t;
    let mut _9: &mut id128::Id128;
    let mut _10: isize;
    let mut _13: id128::Id128;
    scope 1 {
        debug id => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = <Id128 as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = Id128::as_raw_mut(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = &raw mut (*_8);
        _5 = sd_bus_get_bus_id(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_3 as Continue).0: i32);
        _13 = _2;
        _0 = std::result::Result::<Id128, std::io::Error>::Ok(move _13);
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Id128, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::new_signal(_1: &mut BusRef, _2: &ObjectPath, _3: &InterfaceName, _4: &MemberName) -> std::result::Result<Message, std::io::Error> {
    debug self => _1;
    debug path => _2;
    debug interface => _3;
    debug member => _4;
    let mut _0: std::result::Result<bus::Message, std::io::Error>;
    let mut _5: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _7: std::result::Result<i32, std::io::Error>;
    let mut _8: i32;
    let mut _9: *mut ffi::bus::sd_bus;
    let mut _10: &bus::BusRef;
    let mut _11: *mut *mut ffi::bus::sd_bus_message;
    let mut _12: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _13: *const i8;
    let _14: &std::ffi::CStr;
    let mut _15: *const i8;
    let _16: &std::ffi::CStr;
    let mut _17: *const i8;
    let _18: &std::ffi::CStr;
    let mut _19: isize;
    let mut _23: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _24: bus::Message;
    scope 1 {
        debug m => _5;
        let _20: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _21: i32;
        let _22: *mut ffi::bus::sd_bus_message;
        scope 2 {
        }
        scope 3 {
            debug residual => _20;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _21;
            scope 6 {
            }
        }
        scope 7 {
            debug m => _22;
            scope 9 {
            }
        }
        scope 8 {
        }
    }

    bb0: {
        _5 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &(*_1);
        _9 = <BusRef as ForeignTypeRef>::as_ptr(move _10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _12 = &mut _5;
        _11 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _12) -> [return: bb3, unwind continue];
    }

    bb3: {
        _14 = <ObjectPath as Deref>::deref(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = CStr::as_ptr(_14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _16 = <InterfaceName as Deref>::deref(_3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _15 = CStr::as_ptr(_16) -> [return: bb7, unwind continue];
    }

    bb7: {
        _18 = <MemberName as Deref>::deref(_4) -> [return: bb8, unwind continue];
    }

    bb8: {
        _17 = CStr::as_ptr(_18) -> [return: bb9, unwind continue];
    }

    bb9: {
        _8 = sd_bus_message_new_signal(move _9, move _11, _13, _15, _17) -> [return: bb10, unwind continue];
    }

    bb10: {
        _7 = ffi_result(move _8) -> [return: bb11, unwind continue];
    }

    bb11: {
        _6 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _7) -> [return: bb12, unwind continue];
    }

    bb12: {
        _19 = discriminant(_6);
        switchInt(move _19) -> [0: bb13, 1: bb15, otherwise: bb14];
    }

    bb13: {
        _21 = ((_6 as Continue).0: i32);
        _23 = _5;
        _22 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _23) -> [return: bb16, unwind continue];
    }

    bb14: {
        unreachable;
    }

    bb15: {
        _20 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Message, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _20) -> [return: bb18, unwind continue];
    }

    bb16: {
        _24 = <Message as ForeignType>::from_ptr(_22) -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = std::result::Result::<Message, std::io::Error>::Ok(move _24);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::new_method_call(_1: &mut BusRef, _2: &BusName, _3: &ObjectPath, _4: &InterfaceName, _5: &MemberName) -> std::result::Result<Message, std::io::Error> {
    debug self => _1;
    debug dest => _2;
    debug path => _3;
    debug interface => _4;
    debug member => _5;
    let mut _0: std::result::Result<bus::Message, std::io::Error>;
    let mut _6: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _8: std::result::Result<i32, std::io::Error>;
    let mut _9: i32;
    let mut _10: *mut ffi::bus::sd_bus;
    let mut _11: &bus::BusRef;
    let mut _12: *mut *mut ffi::bus::sd_bus_message;
    let mut _13: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _14: *const i8;
    let mut _15: *const bus::BusName;
    let mut _16: *const i8;
    let mut _17: *const bus::ObjectPath;
    let mut _18: *const i8;
    let mut _19: *const bus::InterfaceName;
    let mut _20: *const i8;
    let mut _21: *const bus::MemberName;
    let mut _22: isize;
    let mut _26: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _27: bus::Message;
    scope 1 {
        debug m => _6;
        let _23: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _24: i32;
        let _25: *mut ffi::bus::sd_bus_message;
        scope 2 {
        }
        scope 3 {
            debug residual => _23;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _24;
            scope 6 {
            }
        }
        scope 7 {
            debug m => _25;
            scope 9 {
            }
        }
        scope 8 {
        }
    }

    bb0: {
        _6 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = &(*_1);
        _10 = <BusRef as ForeignTypeRef>::as_ptr(move _11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = &mut _6;
        _12 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _13) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = &raw const (*_2);
        _14 = _15 as *const i8 (PtrToPtr);
        _17 = &raw const (*_3);
        _16 = _17 as *const i8 (PtrToPtr);
        _19 = &raw const (*_4);
        _18 = _19 as *const i8 (PtrToPtr);
        _21 = &raw const (*_5);
        _20 = _21 as *const i8 (PtrToPtr);
        _9 = sd_bus_message_new_method_call(move _10, move _12, _14, _16, _18, _20) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = ffi_result(move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _22 = discriminant(_7);
        switchInt(move _22) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _24 = ((_7 as Continue).0: i32);
        _26 = _6;
        _25 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _26) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _23 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Message, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _23) -> [return: bb12, unwind continue];
    }

    bb10: {
        _27 = <Message as ForeignType>::from_ptr(_25) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = std::result::Result::<Message, std::io::Error>::Ok(move _27);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::request_name(_1: &mut BusRef, _2: &BusName, _3: u64) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug name => _2;
    debug flags => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus;
    let mut _8: &bus::BusRef;
    let mut _9: *const i8;
    let mut _10: *const bus::BusName;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _13: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }

    bb0: {
        _8 = &(*_1);
        _7 = <BusRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &raw const (*_2);
        _9 = _10 as *const i8 (PtrToPtr);
        _6 = sd_bus_request_name(move _7, _9, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = ffi_result(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = discriminant(_4);
        switchInt(move _11) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = ((_4 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _12 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::request_name_async(_1: &mut BusRef, _2: &BusName, _3: u64, _4: F) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug name => _2;
    debug flags => _3;
    debug callback => _4;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _5: extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _9: std::boxed::Box<F>;
    let mut _10: F;
    let mut _11: std::result::Result<i32, std::io::Error>;
    let mut _12: i32;
    let mut _13: *mut ffi::bus::sd_bus;
    let mut _14: &bus::BusRef;
    let mut _15: *mut *mut ffi::bus::sd_bus_slot;
    let mut _16: &mut *mut ffi::bus::sd_bus_slot;
    let mut _17: *const i8;
    let mut _18: *const bus::BusName;
    let mut _19: std::option::Option<unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32>;
    let mut _20: unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _21: *mut libc::c_void;
    let mut _22: isize;
    let _24: std::boxed::Box<F>;
    let mut _25: std::io::Error;
    let _26: i32;
    let mut _27: *mut ffi::bus::sd_bus_slot;
    let mut _28: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _29: unsafe extern "C" fn(*mut libc::c_void);
    let _30: i32;
    let mut _31: *mut ffi::bus::sd_bus_slot;
    let mut _32: bool;
    scope 1 {
        debug f => _5;
        let _6: extern "C" fn(*mut libc::c_void);
        scope 2 {
            debug d => _6;
            let mut _7: *mut ffi::bus::sd_bus_slot;
            scope 3 {
                debug slot => _7;
                let _8: *mut F;
                scope 4 {
                    debug b => _8;
                    let _23: std::io::Error;
                    scope 5 {
                    }
                    scope 6 {
                        debug e => _23;
                        scope 7 {
                        }
                    }
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _32 = const false;
        _32 = const true;
        _5 = bus::raw_message_handler::<F> as extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(ReifyFnPointer));
        _6 = bus::raw_destroy_cb_message_handler::<F> as extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _7 = null_mut::<sd_bus_slot>() -> [return: bb1, unwind: bb18];
    }

    bb1: {
        _32 = const false;
        _10 = move _4;
        _9 = Box::<F>::new(move _10) -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _8 = Box::<F>::into_raw(move _9) -> [return: bb3, unwind: bb18];
    }

    bb3: {
        _14 = &(*_1);
        _13 = <BusRef as ForeignTypeRef>::as_ptr(move _14) -> [return: bb4, unwind: bb18];
    }

    bb4: {
        _16 = &mut _7;
        _15 = &raw mut (*_16);
        _18 = &raw const (*_2);
        _17 = _18 as *const i8 (PtrToPtr);
        _20 = _5 as unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(UnsafeFnPointer));
        _19 = Option::<unsafe extern "C" fn(*mut sd_bus_message, *mut c_void, *mut sd_bus_error) -> i32>::Some(move _20);
        _21 = _8 as *mut libc::c_void (PtrToPtr);
        _12 = sd_bus_request_name_async(move _13, move _15, _17, _3, move _19, move _21) -> [return: bb5, unwind: bb18];
    }

    bb5: {
        _11 = ffi_result(move _12) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        _22 = discriminant(_11);
        switchInt(move _22) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _27 = _7;
        _29 = _6 as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(UnsafeFnPointer));
        _28 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _29);
        _26 = sd_bus_slot_set_destroy_callback(move _27, move _28) -> [return: bb12, unwind: bb18];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _23 = move ((_11 as Err).0: std::io::Error);
        _24 = Box::<F>::from_raw(_8) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        drop(_24) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _25 = move _23;
        _0 = std::result::Result::<(), std::io::Error>::Err(move _25);
        goto -> bb14;
    }

    bb12: {
        _31 = _7;
        _30 = sd_bus_slot_set_floating(move _31, const 1_i32) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb14;
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_23) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        drop(_4) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_32) -> [0: bb16, otherwise: bb17];
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::release_name(_1: &BusRef, _2: &BusName) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *const i8;
    let mut _8: *const bus::BusName;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _11: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &raw const (*_2);
        _7 = _8 as *const i8 (PtrToPtr);
        _5 = sd_bus_release_name(move _6, _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::add_object(_1: &BusRef, _2: &ObjectPath, _3: F) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug path => _2;
    debug callback => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _4: extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _8: std::boxed::Box<F>;
    let mut _9: F;
    let mut _10: std::result::Result<i32, std::io::Error>;
    let mut _11: i32;
    let mut _12: *mut ffi::bus::sd_bus;
    let mut _13: *mut *mut ffi::bus::sd_bus_slot;
    let mut _14: &mut *mut ffi::bus::sd_bus_slot;
    let mut _15: *const i8;
    let mut _16: *const bus::ObjectPath;
    let mut _17: std::option::Option<unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32>;
    let mut _18: unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _19: *mut libc::c_void;
    let mut _20: isize;
    let _22: std::boxed::Box<F>;
    let mut _23: std::io::Error;
    let _24: i32;
    let mut _25: *mut ffi::bus::sd_bus_slot;
    let mut _26: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _27: unsafe extern "C" fn(*mut libc::c_void);
    let _28: i32;
    let mut _29: *mut ffi::bus::sd_bus_slot;
    let mut _30: bool;
    scope 1 {
        debug f => _4;
        let _5: extern "C" fn(*mut libc::c_void);
        scope 2 {
            debug d => _5;
            let mut _6: *mut ffi::bus::sd_bus_slot;
            scope 3 {
                debug slot => _6;
                let _7: *mut F;
                scope 4 {
                    debug b => _7;
                    let _21: std::io::Error;
                    scope 5 {
                    }
                    scope 6 {
                        debug e => _21;
                        scope 7 {
                        }
                    }
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _30 = const false;
        _30 = const true;
        _4 = bus::raw_message_handler::<F> as extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(ReifyFnPointer));
        _5 = bus::raw_destroy_cb_message_handler::<F> as extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _6 = null_mut::<sd_bus_slot>() -> [return: bb1, unwind: bb18];
    }

    bb1: {
        _30 = const false;
        _9 = move _3;
        _8 = Box::<F>::new(move _9) -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _7 = Box::<F>::into_raw(move _8) -> [return: bb3, unwind: bb18];
    }

    bb3: {
        _12 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb4, unwind: bb18];
    }

    bb4: {
        _14 = &mut _6;
        _13 = &raw mut (*_14);
        _16 = &raw const (*_2);
        _15 = _16 as *const i8 (PtrToPtr);
        _18 = _4 as unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(UnsafeFnPointer));
        _17 = Option::<unsafe extern "C" fn(*mut sd_bus_message, *mut c_void, *mut sd_bus_error) -> i32>::Some(move _18);
        _19 = _7 as *mut libc::c_void (PtrToPtr);
        _11 = sd_bus_add_object(move _12, move _13, _15, move _17, move _19) -> [return: bb5, unwind: bb18];
    }

    bb5: {
        _10 = ffi_result(move _11) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        _20 = discriminant(_10);
        switchInt(move _20) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _25 = _6;
        _27 = _5 as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(UnsafeFnPointer));
        _26 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _27);
        _24 = sd_bus_slot_set_destroy_callback(move _25, move _26) -> [return: bb12, unwind: bb18];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _21 = move ((_10 as Err).0: std::io::Error);
        _22 = Box::<F>::from_raw(_7) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        drop(_22) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _23 = move _21;
        _0 = std::result::Result::<(), std::io::Error>::Err(move _23);
        goto -> bb14;
    }

    bb12: {
        _29 = _6;
        _28 = sd_bus_slot_set_floating(move _29, const 1_i32) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb14;
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_21) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_30) -> [0: bb16, otherwise: bb17];
    }
}

fn bus::<impl at src/bus/mod.rs:919:1: 919:12>::add_object_manager(_1: &BusRef, _2: &ObjectPath) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut *mut ffi::bus::sd_bus_slot;
    let mut _8: *const i8;
    let mut _9: *const bus::ObjectPath;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _12: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _11;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _6 = <BusRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = null_mut::<*mut sd_bus_slot>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &raw const (*_2);
        _8 = _9 as *const i8 (PtrToPtr);
        _5 = sd_bus_add_object_manager(move _6, move _7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = ffi_result(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb9;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1313:1: 1313:24>::as_raw_fd(_1: &BusRef) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: std::result::Result<i32, std::io::Error>;

    bb0: {
        _2 = BusRef::fd(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::result::Result::<i32, std::io::Error>::unwrap(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::from_ptr(_1: *mut sd_bus_message) -> Message {
    debug ptr => _1;
    let mut _0: bus::Message;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: !;
    let mut _5: std::ptr::NonNull<ffi::bus::sd_bus_message>;

    bb0: {
        _2 = const true;
        switchInt(move _2) -> [0: bb4, otherwise: bb1];
    }

    bb1: {
        _3 = std::ptr::mut_ptr::<impl *mut sd_bus_message>::is_null(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _4 = core::panicking::panic(const "assertion failed: !ptr.is_null()") -> unwind continue;
    }

    bb4: {
        _5 = NonNull::<sd_bus_message>::new_unchecked(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = Message(move _5);
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ptr(_1: &Message) -> *mut sd_bus_message {
    debug self => _1;
    let mut _0: *mut ffi::bus::sd_bus_message;
    let mut _2: std::ptr::NonNull<ffi::bus::sd_bus_message>;

    bb0: {
        _2 = ((*_1).0: std::ptr::NonNull<ffi::bus::sd_bus_message>);
        _0 = NonNull::<sd_bus_message>::as_ptr(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::drop(_1: &mut Message) -> () {
    debug self => _1;
    let mut _0: ();
    let _2: *mut ffi::bus::sd_bus_message;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: &bus::Message;
    scope 1 {
    }

    bb0: {
        _4 = &(*_1);
        _3 = <Message as ForeignType>::as_ptr(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_unref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref(_1: &Message) -> &MessageRef {
    debug self => _1;
    let mut _0: &bus::MessageRef;
    let mut _2: *mut ffi::bus::sd_bus_message;
    scope 1 {
    }

    bb0: {
        _2 = <Message as ForeignType>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <MessageRef as ForeignTypeRef>::from_ptr::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::deref_mut(_1: &mut Message) -> &mut MessageRef {
    debug self => _1;
    let mut _0: &mut bus::MessageRef;
    let mut _2: *mut ffi::bus::sd_bus_message;
    let mut _3: &bus::Message;
    scope 1 {
    }

    bb0: {
        _3 = &(*_1);
        _2 = <Message as ForeignType>::as_ptr(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <MessageRef as ForeignTypeRef>::from_ptr_mut::<'_>(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow(_1: &Message) -> &MessageRef {
    debug self => _1;
    let mut _0: &bus::MessageRef;

    bb0: {
        _0 = <Message as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::borrow_mut(_1: &mut Message) -> &mut MessageRef {
    debug self => _1;
    let mut _0: &mut bus::MessageRef;

    bb0: {
        _0 = <Message as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_ref(_1: &Message) -> &MessageRef {
    debug self => _1;
    let mut _0: &bus::MessageRef;

    bb0: {
        _0 = <Message as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::as_mut(_1: &mut Message) -> &mut MessageRef {
    debug self => _1;
    let mut _0: &mut bus::MessageRef;

    bb0: {
        _0 = <Message as DerefMut>::deref_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::clone(_1: &Message) -> Message {
    debug self => _1;
    let mut _0: bus::Message;
    let mut _3: *mut ffi::bus::sd_bus_message;
    scope 1 {
        let _2: *mut ffi::bus::sd_bus_message;
        scope 2 {
            debug ptr => _2;
        }
    }

    bb0: {
        _3 = <Message as ForeignType>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_ref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Message as ForeignType>::from_ptr(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/foreign-types-0.5.0/src/lib.rs:248:9: 248:50>::to_owned(_1: &MessageRef) -> Message {
    debug self => _1;
    let mut _0: bus::Message;
    let mut _3: *mut ffi::bus::sd_bus_message;
    scope 1 {
        let _2: *mut ffi::bus::sd_bus_message;
        scope 2 {
            debug ptr => _2;
        }
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_ref(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Message as ForeignType>::from_ptr(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1367:1: 1367:31>::fmt(_1: &MessageRef, _2: &mut Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug fmt => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _4: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _5: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _6: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _7: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _8: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _9: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _10: &mut std::fmt::DebugStruct<'_, '_>;
    let mut _11: std::fmt::DebugStruct<'_, '_>;
    let _12: &str;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &bus::MessageType;
    let _16: bus::MessageType;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&std::ffi::CStr;
    let _20: &std::ffi::CStr;
    let _21: &str;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &&std::ffi::CStr;
    let _24: &std::ffi::CStr;
    let _25: &str;
    let mut _26: &dyn std::fmt::Debug;
    let _27: &&std::ffi::CStr;
    let _28: &std::ffi::CStr;
    let _29: &str;
    let mut _30: &dyn std::fmt::Debug;
    let _31: &&std::ffi::CStr;
    let _32: &std::ffi::CStr;
    let _33: &str;
    let mut _34: &dyn std::fmt::Debug;
    let _35: &&std::ffi::CStr;
    let _36: &std::ffi::CStr;
    let _37: &str;
    let mut _38: &dyn std::fmt::Debug;
    let _39: &&std::ffi::CStr;
    let _40: &std::ffi::CStr;

    bb0: {
        _12 = const "Message";
        _11 = Formatter::<'_>::debug_struct(_2, _12) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &mut _11;
        _13 = const "type";
        _16 = MessageRef::type_(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _15 = &_16;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = DebugStruct::<'_, '_>::field(move _10, _13, move _14) -> [return: bb3, unwind continue];
    }

    bb3: {
        _17 = const "signature";
        _20 = MessageRef::signature(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _19 = &_20;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _8 = DebugStruct::<'_, '_>::field(_9, _17, move _18) -> [return: bb5, unwind continue];
    }

    bb5: {
        _21 = const "path";
        _24 = MessageRef::path(_1) -> [return: bb6, unwind continue];
    }

    bb6: {
        _23 = &_24;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = DebugStruct::<'_, '_>::field(_8, _21, move _22) -> [return: bb7, unwind continue];
    }

    bb7: {
        _25 = const "member";
        _28 = MessageRef::member(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _27 = &_28;
        _26 = _27 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _6 = DebugStruct::<'_, '_>::field(_7, _25, move _26) -> [return: bb9, unwind continue];
    }

    bb9: {
        _29 = const "interface";
        _32 = MessageRef::interface(_1) -> [return: bb10, unwind continue];
    }

    bb10: {
        _31 = &_32;
        _30 = _31 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = DebugStruct::<'_, '_>::field(_6, _29, move _30) -> [return: bb11, unwind continue];
    }

    bb11: {
        _33 = const "sender";
        _36 = MessageRef::sender(_1) -> [return: bb12, unwind continue];
    }

    bb12: {
        _35 = &_36;
        _34 = _35 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _4 = DebugStruct::<'_, '_>::field(_5, _33, move _34) -> [return: bb13, unwind continue];
    }

    bb13: {
        _37 = const "destination";
        _40 = MessageRef::destination(_1) -> [return: bb14, unwind continue];
    }

    bb14: {
        _39 = &_40;
        _38 = _39 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _3 = DebugStruct::<'_, '_>::field(_4, _37, move _38) -> [return: bb15, unwind continue];
    }

    bb15: {
        _0 = DebugStruct::<'_, '_>::finish(_3) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::bus(_1: &MessageRef) -> &BusRef {
    debug self => _1;
    let mut _0: &bus::BusRef;
    let mut _2: *mut ffi::bus::sd_bus;
    let mut _3: *mut ffi::bus::sd_bus_message;
    scope 1 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_bus(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <BusRef as ForeignTypeRef>::from_ptr::<'_>(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::set_destination(_1: &mut MessageRef, _2: &BusName) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug dest => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: &bus::MessageRef;
    let mut _8: *const i8;
    let mut _9: *const bus::BusName;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _12: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _11;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = &raw const (*_2);
        _8 = _9 as *const i8 (PtrToPtr);
        _5 = sd_bus_message_set_destination(move _6, _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::set_auto_start(_1: &mut MessageRef, _2: bool) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug yes => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: &bus::MessageRef;
    let mut _8: i32;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _11: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _7 = &(*_1);
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = _2 as i32 (IntToInt);
        _5 = sd_bus_message_set_auto_start(move _6, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::type_(_1: &MessageRef) -> MessageType {
    debug self => _1;
    let mut _0: bus::MessageType;
    let mut _2: u8;
    let _3: i32;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: *mut u8;
    let mut _8: &mut u8;
    let mut _9: u8;
    scope 1 {
        debug t => _2;
        scope 2 {
        }
    }

    bb0: {
        _2 = const 0_u8;
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_message_get_type(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = std::result::Result::<i32, std::io::Error>::unwrap(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = _2;
        _0 = MessageType::from_raw(move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::path(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_path(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::interface(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_interface(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::member(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_member(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::sender(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_sender(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::destination(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_destination(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::signature(_1: &MessageRef) -> &CStr {
    debug self => _1;
    let mut _0: &std::ffi::CStr;
    let _2: *const i8;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: bool;
    let mut _5: !;
    scope 1 {
        debug p => _2;
        scope 3 {
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_signature(move _3, const 1_i32) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = std::ptr::const_ptr::<impl *const i8>::is_null(_2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = core::panicking::panic(const "assertion failed: !p.is_null()") -> unwind continue;
    }

    bb5: {
        _0 = CStr::from_ptr::<'_>(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::is_empty(_1: &MessageRef) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: i32;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::bus::sd_bus_message;
    scope 1 {
    }

    bb0: {
        _5 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = sd_bus_message_is_empty(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = ffi_result(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = std::result::Result::<i32, std::io::Error>::unwrap(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Ne(move _2, const 0_i32);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::error(_1: &MessageRef) -> &RawError {
    debug self => _1;
    let mut _0: &bus::RawError;
    let mut _2: *const ffi::bus::sd_bus_error;
    let mut _3: *mut ffi::bus::sd_bus_message;
    scope 1 {
    }

    bb0: {
        _3 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = sd_bus_message_get_error(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = RawError::from_ptr::<'_>(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::errno(_1: &MessageRef) -> i32 {
    debug self => _1;
    let mut _0: i32;
    let mut _2: *mut ffi::bus::sd_bus_message;
    scope 1 {
    }

    bb0: {
        _2 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = sd_bus_message_get_errno(move _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::monotonic_usec(_1: &MessageRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug usec => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_message_get_monotonic_usec(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::realtime_usec(_1: &MessageRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug usec => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_message_get_realtime_usec(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::seqnum(_1: &MessageRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: u64;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: *mut u64;
    let mut _8: &mut u64;
    let mut _9: isize;
    let mut _12: u64;
    scope 1 {
        debug seqnum => _2;
        let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _11: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _10;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _11;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = const 0_u64;
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &mut _2;
        _7 = &raw mut (*_8);
        _5 = sd_bus_message_get_seqnum(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ffi_result(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_3);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_3 as Continue).0: i32);
        _12 = _2;
        _0 = std::result::Result::<u64, std::io::Error>::Ok(move _12);
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::send(_1: &mut MessageRef) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<u64>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: &bus::MessageRef;
    let mut _9: *mut u64;
    let mut _10: &mut std::mem::MaybeUninit<u64>;
    let mut _11: isize;
    let mut _15: std::mem::MaybeUninit<u64>;
    scope 1 {
        debug m => _2;
        let _12: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _13: i32;
        let _14: u64;
        scope 2 {
        }
        scope 3 {
            debug residual => _12;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _13;
            scope 6 {
            }
        }
        scope 7 {
            debug m => _14;
        }
        scope 8 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<u64>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = null_mut::<sd_bus>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = &(*_1);
        _7 = <MessageRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _10 = &mut _2;
        _9 = MaybeUninit::<u64>::as_mut_ptr(move _10) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = sd_bus_send(move _6, move _7, move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = ffi_result(move _5) -> [return: bb6, unwind continue];
    }

    bb6: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = discriminant(_3);
        switchInt(move _11) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _13 = ((_3 as Continue).0: i32);
        _15 = _2;
        _14 = MaybeUninit::<u64>::_init(move _15) -> [return: bb11, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _12 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _12) -> [return: bb12, unwind continue];
    }

    bb11: {
        _0 = std::result::Result::<u64, std::io::Error>::Ok(_14);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::send_no_reply(_1: &mut MessageRef) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::bus::sd_bus;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: &bus::MessageRef;
    let mut _8: *mut u64;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _11: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _5 = null_mut::<sd_bus>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &(*_1);
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = null_mut::<u64>() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = sd_bus_send(move _5, move _6, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = ffi_result(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = discriminant(_2);
        switchInt(move _9) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _11 = ((_2 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _10 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::send_to(_1: &mut MessageRef, _2: &BusName) -> std::result::Result<u64, std::io::Error> {
    debug self => _1;
    debug dest => _2;
    let mut _0: std::result::Result<u64, std::io::Error>;
    let mut _3: std::mem::MaybeUninit<u64>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus;
    let mut _8: *mut ffi::bus::sd_bus_message;
    let mut _9: &bus::MessageRef;
    let mut _10: *const i8;
    let mut _11: *const bus::BusName;
    let mut _12: *mut u64;
    let mut _13: &mut std::mem::MaybeUninit<u64>;
    let mut _14: isize;
    let mut _18: std::mem::MaybeUninit<u64>;
    scope 1 {
        debug c => _3;
        let _15: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _16: i32;
        let _17: u64;
        scope 2 {
        }
        scope 3 {
            debug residual => _15;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _16;
            scope 6 {
            }
        }
        scope 7 {
            debug c => _17;
        }
        scope 8 {
        }
    }

    bb0: {
        _3 = MaybeUninit::<u64>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = null_mut::<sd_bus>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &(*_1);
        _8 = <MessageRef as ForeignTypeRef>::as_ptr(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = &raw const (*_2);
        _10 = _11 as *const i8 (PtrToPtr);
        _13 = &mut _3;
        _12 = MaybeUninit::<u64>::as_mut_ptr(move _13) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = sd_bus_send_to(move _7, move _8, _10, move _12) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = ffi_result(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb7, unwind continue];
    }

    bb7: {
        _14 = discriminant(_4);
        switchInt(move _14) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _16 = ((_4 as Continue).0: i32);
        _18 = _3;
        _17 = MaybeUninit::<u64>::assume_init(move _18) -> [return: bb11, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _15 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<u64, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _15) -> [return: bb12, unwind continue];
    }

    bb11: {
        _0 = std::result::Result::<u64, std::io::Error>::Ok(_17);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::send_to_no_reply(_1: &mut MessageRef, _2: &BusName) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug dest => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: &bus::MessageRef;
    let mut _9: *const i8;
    let mut _10: *const bus::BusName;
    let mut _11: *mut u64;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _14: i32;
    scope 1 {
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _6 = null_mut::<sd_bus>() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &(*_1);
        _7 = <MessageRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &raw const (*_2);
        _9 = _10 as *const i8 (PtrToPtr);
        _11 = null_mut::<u64>() -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_bus_send_to(move _6, move _7, _9, move _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = discriminant(_3);
        switchInt(move _12) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _14 = ((_3 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb10;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _13 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::call(_1: &mut MessageRef, _2: u64) -> std::result::Result<Message, bus::Error> {
    debug self => _1;
    debug usec => _2;
    let mut _0: std::result::Result<bus::Message, bus::Error>;
    let mut _3: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let _5: i32;
    let mut _6: *mut ffi::bus::sd_bus;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: &bus::MessageRef;
    let mut _9: *mut ffi::bus::sd_bus_error;
    let mut _10: &mut bus::RawError;
    let mut _11: *mut *mut ffi::bus::sd_bus_message;
    let mut _12: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _13: std::result::Result<(), bus::Error>;
    let mut _14: bus::RawError;
    let mut _15: {closure@src/bus/mod.rs:1688:18: 1688:21};
    let mut _16: &std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _17: bool;
    scope 1 {
        debug r => _3;
        let mut _4: bus::RawError;
        scope 2 {
            debug e => _4;
            scope 3 {
            }
        }
    }

    bb0: {
        _17 = const false;
        _3 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _17 = const true;
        _4 = RawError::new() -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = null_mut::<sd_bus>() -> [return: bb3, unwind: bb12];
    }

    bb3: {
        _8 = &(*_1);
        _7 = <MessageRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb4, unwind: bb12];
    }

    bb4: {
        _10 = &mut _4;
        _9 = RawError::as_mut_ptr(move _10) -> [return: bb5, unwind: bb12];
    }

    bb5: {
        _12 = &mut _3;
        _11 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _12) -> [return: bb6, unwind: bb12];
    }

    bb6: {
        _5 = sd_bus_call(move _6, move _7, _2, move _9, move _11) -> [return: bb7, unwind: bb12];
    }

    bb7: {
        _17 = const false;
        _14 = move _4;
        _13 = RawError::into_result(move _14) -> [return: bb8, unwind: bb12];
    }

    bb8: {
        _16 = &_3;
        _15 = {closure@src/bus/mod.rs:1688:18: 1688:21} { r: move _16 };
        _0 = std::result::Result::<(), bus::Error>::map::<Message, {closure@src/bus/mod.rs:1688:18: 1688:21}>(move _13, move _15) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _17 = const false;
        return;
    }

    bb10 (cleanup): {
        resume;
    }

    bb11 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        switchInt(_17) -> [0: bb10, otherwise: bb11];
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::call::{closure#0}(_1: {closure@src/bus/mod.rs:1688:18: 1688:21}, _2: ()) -> Message {
    debug r => (*(_1.0: &std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>));
    let mut _0: bus::Message;
    let mut _3: *mut ffi::bus::sd_bus_message;
    let mut _4: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _5: &std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    scope 1 {
    }

    bb0: {
        _5 = deref_copy (_1.0: &std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>);
        _4 = (*_5);
        _3 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <Message as ForeignType>::from_ptr(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::call_async(_1: &mut MessageRef, _2: F, _3: u64) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug callback => _2;
    debug usec => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _4: extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _7: std::boxed::Box<F>;
    let mut _9: std::result::Result<i32, std::io::Error>;
    let mut _10: i32;
    let mut _11: *mut ffi::bus::sd_bus;
    let mut _12: *mut *mut ffi::bus::sd_bus_slot;
    let mut _13: &mut *mut ffi::bus::sd_bus_slot;
    let mut _14: *mut ffi::bus::sd_bus_message;
    let mut _15: &bus::MessageRef;
    let mut _16: std::option::Option<unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32>;
    let mut _17: unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32;
    let mut _18: *mut libc::c_void;
    let mut _19: isize;
    let _21: std::boxed::Box<F>;
    let mut _22: std::io::Error;
    let _23: i32;
    let mut _24: *mut ffi::bus::sd_bus_slot;
    let mut _25: std::option::Option<unsafe extern "C" fn(*mut libc::c_void)>;
    let mut _26: unsafe extern "C" fn(*mut libc::c_void);
    let _27: i32;
    let mut _28: *mut ffi::bus::sd_bus_slot;
    scope 1 {
        debug f => _4;
        let _5: extern "C" fn(*mut libc::c_void);
        scope 2 {
            debug d => _5;
            let _6: *mut F;
            scope 3 {
                debug b => _6;
                let mut _8: *mut ffi::bus::sd_bus_slot;
                scope 4 {
                    debug slot => _8;
                    let _20: std::io::Error;
                    scope 5 {
                    }
                    scope 6 {
                        debug e => _20;
                        scope 7 {
                        }
                    }
                    scope 8 {
                    }
                }
            }
        }
    }

    bb0: {
        _4 = bus::raw_message_handler::<F> as extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(ReifyFnPointer));
        _5 = bus::raw_destroy_cb_message_handler::<F> as extern "C" fn(*mut libc::c_void) (PointerCoercion(ReifyFnPointer));
        _7 = Box::<F>::new(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = Box::<F>::into_raw(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = null_mut::<sd_bus_slot>() -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = null_mut::<sd_bus>() -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = &mut _8;
        _12 = &raw mut (*_13);
        _15 = &(*_1);
        _14 = <MessageRef as ForeignTypeRef>::as_ptr(move _15) -> [return: bb5, unwind continue];
    }

    bb5: {
        _17 = _4 as unsafe extern "C" fn(*mut ffi::bus::sd_bus_message, *mut libc::c_void, *mut ffi::bus::sd_bus_error) -> i32 (PointerCoercion(UnsafeFnPointer));
        _16 = Option::<unsafe extern "C" fn(*mut sd_bus_message, *mut c_void, *mut sd_bus_error) -> i32>::Some(move _17);
        _18 = _6 as *mut libc::c_void (PtrToPtr);
        _10 = sd_bus_call_async(move _11, move _12, move _14, move _16, move _18, _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = ffi_result(move _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        _19 = discriminant(_9);
        switchInt(move _19) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _24 = _8;
        _26 = _5 as unsafe extern "C" fn(*mut libc::c_void) (PointerCoercion(UnsafeFnPointer));
        _25 = Option::<unsafe extern "C" fn(*mut c_void)>::Some(move _26);
        _23 = sd_bus_slot_set_destroy_callback(move _24, move _25) -> [return: bb13, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _20 = move ((_9 as Err).0: std::io::Error);
        _21 = Box::<F>::from_raw(_6) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        drop(_21) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        _22 = move _20;
        _0 = std::result::Result::<(), std::io::Error>::Err(move _22);
        goto -> bb15;
    }

    bb13: {
        _28 = _8;
        _27 = sd_bus_slot_set_floating(move _28, const 1_i32) -> [return: bb14, unwind continue];
    }

    bb14: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb15;
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_20) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::new_method_error(_1: &mut MessageRef, _2: &bus::Error) -> std::result::Result<Message, std::io::Error> {
    debug self => _1;
    debug error => _2;
    let mut _0: std::result::Result<bus::Message, std::io::Error>;
    let mut _3: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: &bus::MessageRef;
    let mut _9: *mut *mut ffi::bus::sd_bus_message;
    let mut _10: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _11: *const ffi::bus::sd_bus_error;
    let mut _12: isize;
    let mut _15: bus::Message;
    let mut _16: *mut ffi::bus::sd_bus_message;
    let mut _17: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    scope 1 {
        debug m => _3;
        let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _14: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _13;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _14;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _3 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = &(*_1);
        _7 = <MessageRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = &mut _3;
        _9 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _10) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = bus::Error::as_ptr(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = sd_bus_message_new_method_error(move _7, move _9, move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = ffi_result(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _14 = ((_4 as Continue).0: i32);
        _17 = _3;
        _16 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _17) -> [return: bb11, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Message, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb13, unwind continue];
    }

    bb11: {
        _15 = <Message as ForeignType>::from_ptr(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = std::result::Result::<Message, std::io::Error>::Ok(move _15);
        goto -> bb13;
    }

    bb13: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::new_method_return(_1: &mut MessageRef) -> std::result::Result<Message, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<bus::Message, std::io::Error>;
    let mut _2: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _4: std::result::Result<i32, std::io::Error>;
    let mut _5: i32;
    let mut _6: *mut ffi::bus::sd_bus_message;
    let mut _7: &bus::MessageRef;
    let mut _8: *mut *mut ffi::bus::sd_bus_message;
    let mut _9: &mut std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    let mut _10: isize;
    let mut _13: bus::Message;
    let mut _14: *mut ffi::bus::sd_bus_message;
    let mut _15: std::mem::MaybeUninit<*mut ffi::bus::sd_bus_message>;
    scope 1 {
        debug m => _2;
        let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _12: i32;
        scope 2 {
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
        scope 7 {
        }
    }

    bb0: {
        _2 = MaybeUninit::<*mut sd_bus_message>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &(*_1);
        _6 = <MessageRef as ForeignTypeRef>::as_ptr(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &mut _2;
        _8 = MaybeUninit::<*mut sd_bus_message>::as_mut_ptr(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = sd_bus_message_new_method_return(move _6, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = ffi_result(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _4) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_3);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_3 as Continue).0: i32);
        _15 = _2;
        _14 = MaybeUninit::<*mut sd_bus_message>::assume_init(move _15) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Message, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb12, unwind continue];
    }

    bb10: {
        _13 = <Message as ForeignType>::from_ptr(move _14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = std::result::Result::<Message, std::io::Error>::Ok(move _13);
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::append_basic_raw(_1: &mut MessageRef, _2: u8, _3: *const c_void) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug dbus_type => _2;
    debug v => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: &bus::MessageRef;
    let mut _9: i8;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _12: i32;
    scope 1 {
        debug residual => _11;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _12;
        scope 4 {
        }
    }

    bb0: {
        _8 = &(*_1);
        _7 = <MessageRef as ForeignTypeRef>::as_ptr(move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = _2 as i8 (IntToInt);
        _6 = sd_bus_message_append_basic(move _7, move _9, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = ffi_result(move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _10 = discriminant(_4);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_4 as Continue).0: i32);
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        goto -> bb8;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::append(_1: &mut MessageRef, _2: V) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug v => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _3: &V;

    bb0: {
        _3 = &_2;
        _0 = <V as ToSdBusMessage>::to_message(move _3, _1) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn bus::<impl at src/bus/mod.rs:1381:1: 1381:16>::iter(_1: &mut MessageRef) -> std::result::Result<MessageIter<'_>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<bus::MessageIter<'_>, std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _3: std::result::Result<i32, std::io::Error>;
    let mut _4: i32;
    let mut _5: *mut ffi::bus::sd_bus_message;
    let mut _6: &bus::MessageRef;
    let mut _7: *mut i8;
    let mut _8: *mut *const i8;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _11: i32;
    let mut _12: bus::MessageIter<'_>;
    let mut _13: *mut ffi::bus::sd_bus_message;
    let mut _14: &bus::MessageRef;
    scope 1 {
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _6 = &(*_1);
        _5 = <MessageRef as ForeignTypeRef>::as_ptr(move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = null_mut::<i8>() -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = null_mut::<*const i8>() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = sd_bus_message_peek_type(move _5, move _7, move _8) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = ffi_result(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = discriminant(_2);
        switchInt(move _9) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _11 = ((_2 as Continue).0: i32);
        _14 = &(*_1);
        _13 = <MessageRef as ForeignTypeRef>::as_ptr(move _14) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _10 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<MessageIter<'_>, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _10) -> [return: bb11, unwind continue];
    }

    bb10: {
        _12 = MessageIter::<'_> { raw: move _13, life: const PhantomData::<&MessageRef> };
        _0 = std::result::Result::<MessageIter<'_>, std::io::Error>::Ok(move _12);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1823:1: 1823:25>::as_mut_ptr(_1: &mut MessageIter<'_>) -> *mut sd_bus_message {
    debug self => _1;
    let mut _0: *mut ffi::bus::sd_bus_message;

    bb0: {
        _0 = ((*_1).0: *mut ffi::bus::sd_bus_message);
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1823:1: 1823:25>::read_basic_raw(_1: &mut MessageIter<'_>, _2: u8, _3: F) -> std::result::Result<Option<T>, std::io::Error> {
    debug self => _1;
    debug dbus_type => _2;
    debug cons => _3;
    let mut _0: std::result::Result<std::option::Option<T>, std::io::Error>;
    let mut _4: std::mem::MaybeUninit<R>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: i8;
    let mut _9: *mut libc::c_void;
    let mut _10: *mut R;
    let mut _11: &mut std::mem::MaybeUninit<R>;
    let mut _12: isize;
    let mut _13: std::option::Option<T>;
    let mut _14: T;
    let mut _15: F;
    let mut _16: (R,);
    let mut _17: R;
    let mut _18: std::mem::MaybeUninit<R>;
    let mut _19: std::option::Option<T>;
    let mut _21: bool;
    let mut _22: bool;
    scope 1 {
        debug v => _4;
        let _20: std::io::Error;
        scope 2 {
            debug e => _20;
        }
    }

    bb0: {
        _21 = const false;
        _22 = const false;
        _21 = const true;
        _4 = MaybeUninit::<R>::uninit() -> [return: bb1, unwind: bb20];
    }

    bb1: {
        _7 = MessageIter::<'_>::as_mut_ptr(_1) -> [return: bb2, unwind: bb20];
    }

    bb2: {
        _8 = _2 as i8 (IntToInt);
        _11 = &mut _4;
        _10 = MaybeUninit::<R>::as_mut_ptr(move _11) -> [return: bb3, unwind: bb20];
    }

    bb3: {
        _9 = move _10 as *mut libc::c_void (PtrToPtr);
        _6 = sd_bus_message_read_basic(move _7, move _8, _9) -> [return: bb4, unwind: bb20];
    }

    bb4: {
        _5 = ffi_result(move _6) -> [return: bb5, unwind: bb20];
    }

    bb5: {
        _12 = discriminant(_5);
        switchInt(move _12) -> [0: bb6, 1: bb7, otherwise: bb8];
    }

    bb6: {
        switchInt(((_5 as Ok).0: i32)) -> [1: bb9, otherwise: bb12];
    }

    bb7: {
        _20 = move ((_5 as Err).0: std::io::Error);
        _0 = std::result::Result::<Option<T>, std::io::Error>::Err(move _20);
        goto -> bb13;
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _21 = const false;
        _22 = const true;
        _15 = move _3;
        _18 = move _4;
        _17 = MaybeUninit::<R>::assume_init(move _18) -> [return: bb10, unwind: bb18];
    }

    bb10: {
        _16 = (move _17,);
        _22 = const false;
        _14 = <F as FnOnce<(R,)>>::call_once(move _15, move _16) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _22 = const false;
        _13 = Option::<T>::Some(move _14);
        _0 = std::result::Result::<Option<T>, std::io::Error>::Ok(move _13);
        goto -> bb13;
    }

    bb12: {
        _19 = Option::<T>::None;
        _0 = std::result::Result::<Option<T>, std::io::Error>::Ok(move _19);
        goto -> bb13;
    }

    bb13: {
        switchInt(_21) -> [0: bb14, otherwise: bb16];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        drop(_3) -> [return: bb14, unwind continue];
    }

    bb17 (cleanup): {
        drop(_15) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_22) -> [0: bb20, otherwise: bb17];
    }

    bb19 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        switchInt(_21) -> [0: bb15, otherwise: bb19];
    }
}

fn bus::<impl at src/bus/mod.rs:1823:1: 1823:25>::peek_type(_1: &mut MessageIter<'_>) -> std::result::Result<(i8, &str), std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(i8, &str), std::io::Error>;
    let mut _2: std::mem::MaybeUninit<i8>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, i32>;
    let mut _5: std::result::Result<i32, std::io::Error>;
    let mut _6: i32;
    let mut _7: *mut ffi::bus::sd_bus_message;
    let mut _8: *mut i8;
    let mut _9: &mut std::mem::MaybeUninit<i8>;
    let mut _10: *mut *const i8;
    let mut _11: &mut std::mem::MaybeUninit<*const i8>;
    let mut _12: isize;
    let mut _16: std::mem::MaybeUninit<*const i8>;
    let mut _18: bool;
    let _19: &str;
    let _20: &[u8];
    let _21: &std::ffi::CStr;
    let mut _23: std::mem::MaybeUninit<i8>;
    let mut _24: (i8, &str);
    let mut _25: &str;
    scope 1 {
        debug t => _2;
        let mut _3: std::mem::MaybeUninit<*const i8>;
        scope 2 {
            debug cont => _3;
            let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _14: i32;
            let _15: *const i8;
            scope 3 {
            }
            scope 4 {
                debug residual => _13;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _14;
                scope 7 {
                }
            }
            scope 8 {
                debug cont => _15;
                let _17: &str;
                scope 10 {
                    debug s => _17;
                    let _22: i8;
                    scope 12 {
                        debug t => _22;
                    }
                    scope 13 {
                    }
                }
                scope 11 {
                }
            }
            scope 9 {
            }
        }
    }

    bb0: {
        _2 = MaybeUninit::<i8>::uninit() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = MaybeUninit::<*const i8>::uninit() -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = MessageIter::<'_>::as_mut_ptr(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _2;
        _8 = MaybeUninit::<i8>::as_mut_ptr(move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _11 = &mut _3;
        _10 = MaybeUninit::<*const i8>::as_mut_ptr(move _11) -> [return: bb5, unwind continue];
    }

    bb5: {
        _6 = sd_bus_message_peek_type(move _7, move _8, move _10) -> [return: bb6, unwind continue];
    }

    bb6: {
        _5 = ffi_result(move _6) -> [return: bb7, unwind continue];
    }

    bb7: {
        _4 = <std::result::Result<i32, std::io::Error> as Try>::branch(move _5) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = discriminant(_4);
        switchInt(move _12) -> [0: bb9, 1: bb11, otherwise: bb10];
    }

    bb9: {
        _14 = ((_4 as Continue).0: i32);
        _16 = _3;
        _15 = MaybeUninit::<*const i8>::assume_init(move _16) -> [return: bb12, unwind continue];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _13 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(i8, &str), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb21, unwind continue];
    }

    bb12: {
        _18 = std::ptr::const_ptr::<impl *const i8>::is_null(_15) -> [return: bb13, unwind continue];
    }

    bb13: {
        switchInt(move _18) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _17 = const "";
        goto -> bb19;
    }

    bb15: {
        _21 = CStr::from_ptr::<'_>(_15) -> [return: bb16, unwind continue];
    }

    bb16: {
        _20 = CStr::to_bytes(_21) -> [return: bb17, unwind continue];
    }

    bb17: {
        _19 = from_utf8_unchecked(_20) -> [return: bb18, unwind continue];
    }

    bb18: {
        _17 = _19;
        goto -> bb19;
    }

    bb19: {
        _23 = _2;
        _22 = MaybeUninit::<i8>::assume_init(move _23) -> [return: bb20, unwind continue];
    }

    bb20: {
        _25 = _17;
        _24 = (_22, move _25);
        _0 = std::result::Result::<(i8, &str), std::io::Error>::Ok(move _24);
        goto -> bb21;
    }

    bb21: {
        return;
    }
}

fn bus::<impl at src/bus/mod.rs:1823:1: 1823:25>::next(_1: &mut MessageIter<'_>) -> std::result::Result<Option<V>, std::io::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<V>, std::io::Error>;

    bb0: {
        _0 = <V as FromSdBusMessage<'_>>::from_message(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn escape_name(_1: &str) -> String {
    debug s => _1;
    let mut _0: std::string::String;
    let mut _2: std::string::String;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: (usize, bool);
    let mut _6: std::iter::Enumerate<std::str::Bytes<'_>>;
    let mut _7: std::iter::Enumerate<std::str::Bytes<'_>>;
    let mut _8: std::str::Bytes<'_>;
    let _10: ();
    let mut _11: std::option::Option<(usize, u8)>;
    let mut _12: &mut std::iter::Enumerate<std::str::Bytes<'_>>;
    let mut _13: isize;
    let mut _16: &mut std::string::String;
    let mut _17: bool;
    let mut _18: &mut std::string::String;
    let mut _19: char;
    let mut _20: u8;
    let mut _21: &mut std::string::String;
    let mut _22: char;
    let mut _23: u8;
    let mut _24: bool;
    let mut _25: &u8;
    let mut _26: &mut std::string::String;
    let mut _27: char;
    let mut _28: u8;
    let mut _29: &mut std::string::String;
    let _30: &str;
    let _31: &std::string::String;
    let _32: std::string::String;
    let mut _34: std::fmt::Arguments<'_>;
    let mut _35: &[&str];
    let mut _36: &[core::fmt::rt::Argument<'_>];
    let _37: &[core::fmt::rt::Argument<'_>; 1];
    let _38: [core::fmt::rt::Argument<'_>; 1];
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &u8;
    let mut _41: &[core::fmt::rt::Placeholder];
    let _42: &[core::fmt::rt::Placeholder; 1];
    let _43: [core::fmt::rt::Placeholder; 1];
    let mut _44: core::fmt::rt::Placeholder;
    let mut _45: core::fmt::rt::Alignment;
    let mut _46: core::fmt::rt::Count;
    let mut _47: core::fmt::rt::Count;
    let mut _48: core::fmt::rt::UnsafeArg;
    scope 1 {
        debug escaped => _2;
        let mut _9: std::iter::Enumerate<std::str::Bytes<'_>>;
        scope 2 {
            debug iter => _9;
            let _14: usize;
            let _15: u8;
            scope 3 {
                debug index => _14;
                debug b => _15;
                let _33: std::string::String;
                let mut _49: &[&str; 1];
                scope 4 {
                    debug res => _33;
                }
                scope 5 {
                }
            }
        }
    }

    bb0: {
        _4 = core::str::<impl str>::len(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = CheckedMul(_4, const 2_usize);
        assert(!move (_5.1: bool), "attempt to compute `{} * {}`, which would overflow", move _4, const 2_usize) -> [success: bb2, unwind continue];
    }

    bb2: {
        _3 = move (_5.0: usize);
        _2 = String::with_capacity(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = core::str::<impl str>::bytes(_1) -> [return: bb4, unwind: bb31];
    }

    bb4: {
        _7 = <std::str::Bytes<'_> as Iterator>::enumerate(move _8) -> [return: bb5, unwind: bb31];
    }

    bb5: {
        _6 = <Enumerate<std::str::Bytes<'_>> as IntoIterator>::into_iter(move _7) -> [return: bb6, unwind: bb31];
    }

    bb6: {
        _9 = move _6;
        goto -> bb7;
    }

    bb7: {
        _12 = &mut _9;
        _11 = <Enumerate<std::str::Bytes<'_>> as Iterator>::next(_12) -> [return: bb8, unwind: bb31];
    }

    bb8: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _14 = (((_11 as Some).0: (usize, u8)).0: usize);
        _15 = (((_11 as Some).0: (usize, u8)).1: u8);
        switchInt(_15) -> [47: bb12, 46: bb13, 95: bb16, 58: bb16, otherwise: bb18];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _0 = move _2;
        return;
    }

    bb12: {
        _16 = &mut _2;
        _10 = String::push(move _16, const '-') -> [return: bb33, unwind: bb31];
    }

    bb13: {
        _17 = Lt(const 0_usize, _14);
        switchInt(move _17) -> [0: bb18, otherwise: bb14];
    }

    bb14: {
        _18 = &mut _2;
        _20 = _15;
        _19 = <char as From<u8>>::from(move _20) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _10 = String::push(move _18, move _19) -> [return: bb34, unwind: bb31];
    }

    bb16: {
        _21 = &mut _2;
        _23 = _15;
        _22 = <char as From<u8>>::from(move _23) -> [return: bb17, unwind: bb31];
    }

    bb17: {
        _10 = String::push(move _21, move _22) -> [return: bb35, unwind: bb31];
    }

    bb18: {
        _25 = &_15;
        _24 = core::num::<impl u8>::is_ascii_alphanumeric(move _25) -> [return: bb19, unwind: bb31];
    }

    bb19: {
        switchInt(move _24) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _26 = &mut _2;
        _28 = _15;
        _27 = <char as From<u8>>::from(move _28) -> [return: bb22, unwind: bb31];
    }

    bb21: {
        _29 = &mut _2;
        _49 = const _;
        _35 = _49 as &[&str] (PointerCoercion(Unsize));
        _40 = &_15;
        _39 = core::fmt::rt::Argument::<'_>::new_lower_hex::<u8>(_40) -> [return: bb23, unwind: bb31];
    }

    bb22: {
        _10 = String::push(move _26, move _27) -> [return: bb36, unwind: bb31];
    }

    bb23: {
        _38 = [move _39];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _45 = core::fmt::rt::Alignment::Unknown;
        _46 = core::fmt::rt::Count::Implied;
        _47 = core::fmt::rt::Count::Is(const 2_usize);
        _44 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _45, const 8_u32, move _46, move _47) -> [return: bb24, unwind: bb31];
    }

    bb24: {
        _43 = [move _44];
        _42 = &_43;
        _41 = _42 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _48 = core::fmt::rt::UnsafeArg::new() -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _34 = Arguments::<'_>::new_v1_formatted(move _35, move _36, move _41, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb26, unwind: bb31];
    }

    bb26: {
        _33 = format(move _34) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _32 = move _33;
        _31 = &_32;
        _30 = <String as Deref>::deref(_31) -> [return: bb28, unwind: bb30];
    }

    bb28: {
        _10 = String::push_str(move _29, _30) -> [return: bb29, unwind: bb30];
    }

    bb29: {
        drop(_32) -> [return: bb7, unwind: bb31];
    }

    bb30 (cleanup): {
        drop(_32) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_2) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        goto -> bb7;
    }

    bb34: {
        goto -> bb7;
    }

    bb35: {
        goto -> bb7;
    }

    bb36: {
        goto -> bb7;
    }
}

promoted[0] in escape_name: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\\x"];
        _0 = &_1;
        return;
    }
}

fn Journal(_1: NonNull<sd_journal>) -> Journal {
    let mut _0: journal::Journal;

    bb0: {
        _0 = Journal(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Journal(_1: NonNull<sd_journal>) -> Journal {
    let mut _0: journal::Journal;

    bb0: {
        _0 = Journal(move _1);
        return;
    }
}

fn JournalRef(_1: Opaque) -> JournalRef {
    let mut _0: journal::JournalRef;

    bb0: {
        _0 = JournalRef(move _1);
        return;
    }
}

// MIR FOR CTFE
fn JournalRef(_1: Opaque) -> JournalRef {
    let mut _0: journal::JournalRef;

    bb0: {
        _0 = JournalRef(move _1);
        return;
    }
}

fn UnixFd(_1: i32) -> UnixFd {
    let mut _0: bus::types::UnixFd;

    bb0: {
        _0 = UnixFd(move _1);
        return;
    }
}

// MIR FOR CTFE
fn UnixFd(_1: i32) -> UnixFd {
    let mut _0: bus::types::UnixFd;

    bb0: {
        _0 = UnixFd(move _1);
        return;
    }
}

fn Bus(_1: NonNull<sd_bus>) -> Bus {
    let mut _0: bus::Bus;

    bb0: {
        _0 = Bus(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Bus(_1: NonNull<sd_bus>) -> Bus {
    let mut _0: bus::Bus;

    bb0: {
        _0 = Bus(move _1);
        return;
    }
}

fn BusRef(_1: Opaque) -> BusRef {
    let mut _0: bus::BusRef;

    bb0: {
        _0 = BusRef(move _1);
        return;
    }
}

// MIR FOR CTFE
fn BusRef(_1: Opaque) -> BusRef {
    let mut _0: bus::BusRef;

    bb0: {
        _0 = BusRef(move _1);
        return;
    }
}

fn Message(_1: NonNull<sd_bus_message>) -> Message {
    let mut _0: bus::Message;

    bb0: {
        _0 = Message(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Message(_1: NonNull<sd_bus_message>) -> Message {
    let mut _0: bus::Message;

    bb0: {
        _0 = Message(move _1);
        return;
    }
}

fn MessageRef(_1: Opaque) -> MessageRef {
    let mut _0: bus::MessageRef;

    bb0: {
        _0 = MessageRef(move _1);
        return;
    }
}

// MIR FOR CTFE
fn MessageRef(_1: Opaque) -> MessageRef {
    let mut _0: bus::MessageRef;

    bb0: {
        _0 = MessageRef(move _1);
        return;
    }
}
