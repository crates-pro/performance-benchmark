// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
const DB_MAX_SIZE: u64 = {
    let mut _0: u64;
    let mut _1: u64;
    let mut _2: (u64, bool);
    let mut _3: (u64, bool);

    bb0: {
        StorageLive(_1);
        _2 = CheckedMul(const 8_u64, const 1024_u64);
        assert(!move (_2.1: bool), "attempt to compute `{} * {}`, which would overflow", const 8_u64, const 1024_u64) -> [success: bb1, unwind continue];
    }

    bb1: {
        _1 = move (_2.0: u64);
        _3 = CheckedMul(_1, const 1024_u64);
        assert(!move (_3.1: bool), "attempt to compute `{} * {}`, which would overflow", move _1, const 1024_u64) -> [success: bb2, unwind continue];
    }

    bb2: {
        _0 = move (_3.0: u64);
        StorageDead(_1);
        return;
    }
}

const DB_VERSION: i32 = {
    let mut _0: i32;

    bb0: {
        _0 = const 3_i32;
        return;
    }
}

fn zo_data_dir() -> Result<PathBuf, anyhow::Error> {
    let mut _0: std::result::Result<std::path::PathBuf, anyhow::Error>;
    let _1: std::path::PathBuf;
    let mut _2: std::option::Option<std::ffi::OsString>;
    let mut _3: isize;
    let _4: std::ffi::OsString;
    let mut _5: std::option::Option<std::path::PathBuf>;
    let mut _6: isize;
    let mut _7: std::path::PathBuf;
    let _8: ();
    let mut _9: &mut std::path::PathBuf;
    let mut _10: anyhow::Error;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _12: std::result::Result<(), anyhow::Error>;
    let mut _13: std::result::Result<(), std::io::Error>;
    let mut _14: &std::path::PathBuf;
    let mut _15: isize;
    let mut _17: std::path::PathBuf;
    scope 1 {
        debug data_dir => _1;
        let _16: std::result::Result<std::convert::Infallible, anyhow::Error>;
        scope 4 {
            debug residual => _16;
            scope 5 {
            }
        }
        scope 6 {
            debug val => const ();
            scope 7 {
            }
        }
    }
    scope 2 {
        debug data_osstr => _4;
    }
    scope 3 {
        debug data_dir => _7;
    }

    bb0: {
        _2 = var_os::<&str>(const "_ZO_DATA_DIR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _5 = data_local_dir() -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _4 = move ((_2 as Some).0: std::ffi::OsString);
        _1 = <PathBuf as From<OsString>>::from(move _4) -> [return: bb20, unwind continue];
    }

    bb5: {
        _6 = discriminant(_5);
        switchInt(move _6) -> [0: bb6, 1: bb7, otherwise: bb3];
    }

    bb6: {
        _10 = new_adhoc::<&str>(const "could not find database directory, please set _ZO_DATA_DIR manually") -> [return: bb9, unwind continue];
    }

    bb7: {
        _7 = move ((_5 as Some).0: std::path::PathBuf);
        _9 = &mut _7;
        _8 = PathBuf::push::<&str>(move _9, const "zoxide") -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _1 = move _7;
        goto -> bb20;
    }

    bb9: {
        _0 = Result::<PathBuf, anyhow::Error>::Err(move _10);
        goto -> bb16;
    }

    bb10: {
        _12 = <Result<(), std::io::Error> as anyhow::Context<(), std::io::Error>>::context::<&str>(move _13, const "could not create data directory") -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _11 = <Result<(), anyhow::Error> as Try>::branch(move _12) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _15 = discriminant(_11);
        switchInt(move _15) -> [0: bb13, 1: bb14, otherwise: bb3];
    }

    bb13: {
        _17 = move _1;
        _0 = Result::<PathBuf, anyhow::Error>::Ok(move _17);
        goto -> bb16;
    }

    bb14: {
        _16 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<PathBuf, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _16) -> [return: bb15, unwind: bb17];
    }

    bb15: {
        drop(_1) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_1) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        drop(_7) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20: {
        _14 = &_1;
        _13 = create_dir_all::<&PathBuf>(move _14) -> [return: bb10, unwind: bb17];
    }
}

fn zo_exclude_dirs() -> Vec<PathBuf> {
    let mut _0: std::vec::Vec<std::path::PathBuf>;
    let mut _1: std::option::Option<std::ffi::OsString>;
    let mut _2: isize;
    let _3: std::ffi::OsString;
    let mut _4: std::env::SplitPaths<'_>;
    let _5: &std::ffi::OsString;
    scope 1 {
        debug dirs_osstr => _3;
    }

    bb0: {
        _1 = var_os::<&str>(const "_ZO_EXCLUDE_DIRS") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Vec::<PathBuf>::new() -> [return: bb8, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _3 = move ((_1 as Some).0: std::ffi::OsString);
        _5 = &_3;
        _4 = split_paths::<OsString>(_5) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        _0 = <SplitPaths<'_> as Iterator>::collect::<Vec<PathBuf>>(move _4) -> [return: bb6, unwind: bb7];
    }

    bb6: {
        drop(_3) -> [return: bb8, unwind continue];
    }

    bb7 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        resume;
    }
}

fn zo_maxage() -> Result<f64, anyhow::Error> {
    let mut _0: std::result::Result<f64, anyhow::Error>;
    let mut _1: std::option::Option<std::ffi::OsString>;
    let mut _2: isize;
    let _3: std::ffi::OsString;
    let mut _4: std::option::Option<&str>;
    let _5: &std::ffi::OsStr;
    let mut _6: &std::ffi::OsString;
    let mut _7: isize;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, i64>;
    let mut _10: std::result::Result<i64, anyhow::Error>;
    let mut _11: std::result::Result<i64, std::num::ParseIntError>;
    let mut _12: isize;
    let mut _15: f64;
    let mut _16: anyhow::Error;
    scope 1 {
        debug maxage_osstr => _3;
        let _8: &str;
        scope 2 {
            debug maxage_str => _8;
            let _13: std::result::Result<std::convert::Infallible, anyhow::Error>;
            let _14: i64;
            scope 3 {
                debug maxage => _14;
            }
            scope 4 {
                debug residual => _13;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _14;
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _1 = var_os::<&str>(const "_ZO_MAXAGE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = Result::<f64, anyhow::Error>::Ok(const 1000f64);
        goto -> bb16;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _3 = move ((_1 as Some).0: std::ffi::OsString);
        _6 = &_3;
        _5 = <OsString as Deref>::deref(move _6) -> [return: bb5, unwind: bb17];
    }

    bb5: {
        _4 = OsStr::to_str(_5) -> [return: bb6, unwind: bb17];
    }

    bb6: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb7, 1: bb8, otherwise: bb3];
    }

    bb7: {
        _16 = new_adhoc::<&str>(const "invalid Unicode in _ZO_MAXAGE") -> [return: bb14, unwind: bb17];
    }

    bb8: {
        _8 = ((_4 as Some).0: &str);
        _11 = core::str::<impl str>::parse::<i64>(_8) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _10 = <Result<i64, ParseIntError> as anyhow::Context<i64, ParseIntError>>::context::<&str>(move _11, const "unable to parse _ZO_MAXAGE as integer") -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _9 = <Result<i64, anyhow::Error> as Try>::branch(move _10) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _12 = discriminant(_9);
        switchInt(move _12) -> [0: bb12, 1: bb13, otherwise: bb3];
    }

    bb12: {
        _14 = ((_9 as Continue).0: i64);
        _15 = _14 as f64 (IntToFloat);
        _0 = Result::<f64, anyhow::Error>::Ok(move _15);
        drop(_3) -> [return: bb16, unwind continue];
    }

    bb13: {
        _13 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<f64, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _13) -> [return: bb19, unwind: bb17];
    }

    bb14: {
        _0 = Result::<f64, anyhow::Error>::Err(move _16);
        goto -> bb15;
    }

    bb15: {
        drop(_3) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        goto -> bb15;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::open(_1: P) -> Result<DB, anyhow::Error> {
    debug path => _1;
    let mut _0: std::result::Result<db::DB, anyhow::Error>;
    let _2: db::DBData;
    let mut _3: std::result::Result<std::fs::File, std::io::Error>;
    let mut _4: &P;
    let mut _5: isize;
    let _6: std::fs::File;
    let mut _8: &std::fs::File;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DBData>;
    let mut _10: std::result::Result<db::DBData, anyhow::Error>;
    let mut _11: std::result::Result<db::DBData, std::boxed::Box<bincode::ErrorKind>>;
    let mut _12: &bincode::Config;
    let _13: &mut bincode::Config;
    let mut _14: &mut bincode::Config;
    let mut _15: bincode::Config;
    let mut _16: std::io::BufReader<&std::fs::File>;
    let mut _17: isize;
    let _20: std::io::Error;
    let mut _21: std::io::ErrorKind;
    let mut _22: &std::io::Error;
    let mut _23: isize;
    let mut _24: std::result::Result<db::DB, std::io::Error>;
    let mut _25: std::io::Error;
    let mut _26: bool;
    let mut _27: i32;
    let mut _28: anyhow::Error;
    let mut _30: std::fmt::Arguments<'_>;
    let mut _31: &[&str];
    let mut _32: &[core::fmt::rt::Argument<'_>];
    let _33: &[core::fmt::rt::Argument<'_>; 1];
    let _34: [core::fmt::rt::Argument<'_>; 1];
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &i32;
    let mut _37: db::DB;
    let mut _38: db::DBData;
    let mut _39: std::path::PathBuf;
    let _40: &std::path::Path;
    let mut _41: &P;
    let mut _42: std::option::Option<std::path::PathBuf>;
    let mut _44: bool;
    let mut _45: bool;
    let mut _46: bool;
    scope 1 {
        debug data => _2;
        let _29: std::string::String;
        let mut _43: &[&str; 2];
        scope 9 {
            debug res => _29;
        }
    }
    scope 2 {
        debug file => _6;
        let _7: std::io::BufReader<&std::fs::File>;
        scope 3 {
            debug reader => _7;
            let _18: std::result::Result<std::convert::Infallible, anyhow::Error>;
            let _19: db::DBData;
            scope 4 {
                debug residual => _18;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _19;
                scope 7 {
                }
            }
        }
    }
    scope 8 {
        debug err => _20;
    }

    bb0: {
        _44 = const false;
        _46 = const false;
        _45 = const false;
        _4 = &_1;
        _3 = File::open::<&P>(move _4) -> [return: bb1, unwind: bb32];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _45 = const true;
        _20 = move ((_3 as Err).0: std::io::Error);
        _22 = &_20;
        _21 = std::io::Error::kind(move _22) -> [return: bb14, unwind: bb38];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = move ((_3 as Ok).0: std::fs::File);
        _8 = &_6;
        _7 = BufReader::<&File>::new(move _8) -> [return: bb5, unwind: bb31];
    }

    bb5: {
        _46 = const true;
        _15 = config() -> [return: bb6, unwind: bb40];
    }

    bb6: {
        _14 = &mut _15;
        _13 = Config::limit(move _14, const _) -> [return: bb7, unwind: bb40];
    }

    bb7: {
        _12 = &(*_13);
        _46 = const false;
        _16 = move _7;
        _11 = Config::deserialize_from::<BufReader<&File>, DBData>(move _12, move _16) -> [return: bb8, unwind: bb40];
    }

    bb8: {
        _10 = <Result<DBData, Box<bincode::ErrorKind>> as anyhow::Context<DBData, Box<bincode::ErrorKind>>>::context::<&str>(move _11, const "could not deserialize database") -> [return: bb9, unwind: bb40];
    }

    bb9: {
        _9 = <Result<DBData, anyhow::Error> as Try>::branch(move _10) -> [return: bb10, unwind: bb40];
    }

    bb10: {
        _17 = discriminant(_9);
        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb3];
    }

    bb11: {
        _19 = move ((_9 as Continue).0: db::DBData);
        _44 = const true;
        _2 = move _19;
        _46 = const false;
        drop(_6) -> [return: bb34, unwind: bb32];
    }

    bb12: {
        _18 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<DB, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _18) -> [return: bb13, unwind: bb31];
    }

    bb13: {
        _46 = const false;
        drop(_6) -> [return: bb28, unwind: bb32];
    }

    bb14: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _45 = const false;
        _25 = move _20;
        _24 = Result::<DB, std::io::Error>::Err(move _25);
        _0 = <Result<DB, std::io::Error> as anyhow::Context<DB, std::io::Error>>::context::<&str>(move _24, const "could not open database file") -> [return: bb17, unwind: bb38];
    }

    bb16: {
        _2 = <DBData as Default>::default() -> [return: bb18, unwind: bb38];
    }

    bb17: {
        _45 = const false;
        goto -> bb28;
    }

    bb18: {
        _44 = const true;
        drop(_20) -> [return: bb19, unwind: bb32];
    }

    bb19: {
        _45 = const false;
        goto -> bb34;
    }

    bb20: {
        _43 = const _;
        _31 = _43 as &[&str] (PointerCoercion(Unsize));
        _36 = &(_2.0: i32);
        _35 = core::fmt::rt::Argument::<'_>::new_display::<i32>(_36) -> [return: bb21, unwind: bb36];
    }

    bb21: {
        _34 = [move _35];
        _33 = &_34;
        _32 = _33 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _30 = Arguments::<'_>::new_v1(move _31, move _32) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        _29 = format(move _30) -> [return: bb23, unwind: bb36];
    }

    bb23: {
        _28 = new_adhoc::<std::string::String>(move _29) -> [return: bb24, unwind: bb36];
    }

    bb24: {
        _0 = Result::<DB, anyhow::Error>::Err(move _28);
        drop(_2) -> [return: bb28, unwind: bb32];
    }

    bb25: {
        _44 = const false;
        _38 = move _2;
        _41 = &_1;
        _40 = <P as AsRef<Path>>::as_ref(move _41) -> [return: bb26, unwind: bb30];
    }

    bb26: {
        _39 = Path::to_path_buf(_40) -> [return: bb27, unwind: bb30];
    }

    bb27: {
        _42 = std::option::Option::<PathBuf>::None;
        _37 = DB { data: move _38, modified: const false, path: move _39, path_old: move _42 };
        _0 = Result::<DB, anyhow::Error>::Ok(move _37);
        _44 = const false;
        drop(_1) -> [return: bb29, unwind continue];
    }

    bb28: {
        _44 = const false;
        drop(_1) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_38) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_6) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_1) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }

    bb34: {
        _27 = (_2.0: i32);
        _26 = Ne(move _27, const _);
        switchInt(move _26) -> [0: bb25, otherwise: bb20];
    }

    bb35 (cleanup): {
        drop(_2) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        switchInt(_44) -> [0: bb32, otherwise: bb35];
    }

    bb37 (cleanup): {
        drop(_20) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_45) -> [0: bb32, otherwise: bb37];
    }

    bb39 (cleanup): {
        drop(_7) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        switchInt(_46) -> [0: bb31, otherwise: bb39];
    }
}

promoted[0] in db::<impl at src/db.rs:23:1: 23:8>::open: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "database version '", const "' is unsupported"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::open_and_migrate(_1: P1, _2: P2) -> Result<DB, anyhow::Error> {
    debug path_old => _1;
    debug path => _2;
    let mut _0: std::result::Result<db::DB, anyhow::Error>;
    let _3: std::fs::File;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::fs::File>;
    let mut _5: std::result::Result<std::fs::File, anyhow::Error>;
    let mut _6: std::result::Result<std::fs::File, std::io::Error>;
    let mut _7: &P1;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _10: std::fs::File;
    let mut _12: &std::fs::File;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::vec::Vec<dir::Dir>>;
    let mut _15: std::result::Result<std::vec::Vec<dir::Dir>, anyhow::Error>;
    let mut _16: std::result::Result<std::vec::Vec<dir::Dir>, std::boxed::Box<bincode::ErrorKind>>;
    let mut _17: &bincode::Config;
    let _18: &mut bincode::Config;
    let mut _19: &mut bincode::Config;
    let mut _20: bincode::Config;
    let mut _21: std::io::BufReader<&std::fs::File>;
    let mut _22: isize;
    let mut _26: std::vec::Vec<dir::Dir>;
    let mut _27: db::DB;
    let mut _28: db::DBData;
    let mut _29: std::path::PathBuf;
    let _30: &std::path::Path;
    let mut _31: &P2;
    let mut _32: std::option::Option<std::path::PathBuf>;
    let mut _33: std::path::PathBuf;
    let _34: &std::path::Path;
    let mut _35: &P1;
    let mut _36: bool;
    let mut _37: bool;
    scope 1 {
        debug file => _3;
        let _11: std::io::BufReader<&std::fs::File>;
        scope 6 {
            debug reader => _11;
            let _13: std::vec::Vec<dir::Dir>;
            let _23: std::result::Result<std::convert::Infallible, anyhow::Error>;
            let _24: std::vec::Vec<dir::Dir>;
            scope 7 {
                debug dirs => _13;
                let _25: db::DBData;
                scope 12 {
                    debug data => _25;
                }
            }
            scope 8 {
                debug residual => _23;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _24;
                scope 11 {
                }
            }
        }
    }
    scope 2 {
        debug residual => _9;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _10;
        scope 5 {
        }
    }

    bb0: {
        _37 = const false;
        _36 = const false;
        _7 = &_1;
        _6 = File::open::<&P1>(move _7) -> [return: bb1, unwind: bb28];
    }

    bb1: {
        _5 = <Result<File, std::io::Error> as anyhow::Context<File, std::io::Error>>::context::<&str>(move _6, const "could not open old database file") -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _4 = <Result<File, anyhow::Error> as Try>::branch(move _5) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _8 = discriminant(_4);
        switchInt(move _8) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _10 = move ((_4 as Continue).0: std::fs::File);
        _3 = move _10;
        _12 = &_3;
        _11 = BufReader::<&File>::new(move _12) -> [return: bb7, unwind: bb27];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _9 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<DB, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _9) -> [return: bb35, unwind: bb28];
    }

    bb7: {
        _37 = const true;
        _20 = config() -> [return: bb8, unwind: bb34];
    }

    bb8: {
        _19 = &mut _20;
        _18 = Config::limit(move _19, const _) -> [return: bb9, unwind: bb34];
    }

    bb9: {
        _17 = &(*_18);
        _37 = const false;
        _21 = move _11;
        _16 = Config::deserialize_from::<BufReader<&File>, Vec<Dir>>(move _17, move _21) -> [return: bb10, unwind: bb34];
    }

    bb10: {
        _15 = <Result<Vec<Dir>, Box<bincode::ErrorKind>> as anyhow::Context<Vec<Dir>, Box<bincode::ErrorKind>>>::context::<&str>(move _16, const "could not deserialize old database") -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _14 = <Result<Vec<Dir>, anyhow::Error> as Try>::branch(move _15) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _22 = discriminant(_14);
        switchInt(move _22) -> [0: bb13, 1: bb14, otherwise: bb5];
    }

    bb13: {
        _24 = move ((_14 as Continue).0: std::vec::Vec<dir::Dir>);
        _36 = const true;
        _13 = move _24;
        _36 = const false;
        _26 = move _13;
        _25 = DBData { version: const _, dirs: move _26 };
        _28 = move _25;
        _31 = &_2;
        _30 = <P2 as AsRef<Path>>::as_ref(move _31) -> [return: bb16, unwind: bb26];
    }

    bb14: {
        _23 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<DB, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _23) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _36 = const false;
        _37 = const false;
        drop(_3) -> [return: bb22, unwind: bb28];
    }

    bb16: {
        _29 = Path::to_path_buf(_30) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _35 = &_1;
        _34 = <P1 as AsRef<Path>>::as_ref(move _35) -> [return: bb18, unwind: bb25];
    }

    bb18: {
        _33 = Path::to_path_buf(_34) -> [return: bb19, unwind: bb25];
    }

    bb19: {
        _32 = std::option::Option::<PathBuf>::Some(move _33);
        _27 = DB { data: move _28, modified: const true, path: move _29, path_old: move _32 };
        _0 = Result::<DB, anyhow::Error>::Ok(move _27);
        _36 = const false;
        _37 = const false;
        drop(_3) -> [return: bb20, unwind: bb28];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind: bb29];
    }

    bb21: {
        drop(_1) -> [return: bb24, unwind continue];
    }

    bb22: {
        drop(_2) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        drop(_1) -> [return: bb24, unwind continue];
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_29) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_28) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        drop(_2) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        drop(_1) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        resume;
    }

    bb31 (cleanup): {
        drop(_13) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        switchInt(_36) -> [0: bb34, otherwise: bb31];
    }

    bb33 (cleanup): {
        drop(_11) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        switchInt(_37) -> [0: bb27, otherwise: bb33];
    }

    bb35: {
        goto -> bb22;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::save(_1: &mut DB) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let mut _2: bool;
    let _3: std::path::PathBuf;
    let mut _4: &db::DB;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::fs::File>;
    let mut _7: std::result::Result<std::fs::File, anyhow::Error>;
    let mut _8: std::result::Result<std::fs::File, std::io::Error>;
    let mut _9: &std::fs::OpenOptions;
    let _10: &mut std::fs::OpenOptions;
    let mut _11: &mut std::fs::OpenOptions;
    let mut _12: &mut std::fs::OpenOptions;
    let mut _13: std::fs::OpenOptions;
    let mut _14: &std::path::PathBuf;
    let mut _15: isize;
    let mut _19: &std::fs::File;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _21: std::result::Result<(), anyhow::Error>;
    let mut _22: std::result::Result<(), std::boxed::Box<bincode::ErrorKind>>;
    let _23: &db::DBData;
    let mut _24: isize;
    let mut _26: std::result::Result<(), std::io::Error>;
    let mut _27: &std::path::PathBuf;
    let mut _28: &std::path::PathBuf;
    let mut _29: isize;
    let mut _31: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _32: std::result::Result<(), anyhow::Error>;
    let mut _33: std::result::Result<(), std::io::Error>;
    let mut _34: &std::path::PathBuf;
    let mut _35: isize;
    let mut _37: std::result::Result<(), std::io::Error>;
    let mut _38: std::io::Error;
    let mut _39: bool;
    let mut _40: bool;
    let mut _41: isize;
    scope 1 {
        debug path_tmp => _3;
        let _5: std::fs::File;
        let _16: std::result::Result<std::convert::Infallible, anyhow::Error>;
        let _17: std::fs::File;
        scope 2 {
            debug file_tmp => _5;
            let _18: std::io::BufWriter<&std::fs::File>;
            scope 7 {
                debug writer => _18;
                let _25: std::result::Result<std::convert::Infallible, anyhow::Error>;
                scope 8 {
                    debug residual => _25;
                    scope 9 {
                    }
                }
                scope 10 {
                    debug val => const ();
                    scope 11 {
                    }
                }
                scope 12 {
                    debug e => _30;
                    let _30: std::io::Error;
                    let _36: std::result::Result<std::convert::Infallible, anyhow::Error>;
                    scope 13 {
                        debug residual => _36;
                        scope 14 {
                        }
                    }
                    scope 15 {
                        debug val => const ();
                        scope 16 {
                        }
                    }
                }
            }
        }
        scope 3 {
            debug residual => _16;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _17;
            scope 6 {
            }
        }
    }

    bb0: {
        _39 = const false;
        _40 = const false;
        _2 = ((*_1).1: bool);
        switchInt(move _2) -> [0: bb30, otherwise: bb1];
    }

    bb1: {
        _4 = &(*_1);
        _3 = DB::get_path_tmp(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _13 = OpenOptions::new() -> [return: bb3, unwind: bb39];
    }

    bb3: {
        _12 = &mut _13;
        _11 = OpenOptions::write(move _12, const true) -> [return: bb4, unwind: bb39];
    }

    bb4: {
        _10 = OpenOptions::create_new(_11, const true) -> [return: bb5, unwind: bb39];
    }

    bb5: {
        _9 = &(*_10);
        _14 = &_3;
        _8 = OpenOptions::open::<&PathBuf>(move _9, move _14) -> [return: bb6, unwind: bb39];
    }

    bb6: {
        _7 = <Result<File, std::io::Error> as anyhow::Context<File, std::io::Error>>::context::<&str>(move _8, const "could not open temporary database file") -> [return: bb7, unwind: bb39];
    }

    bb7: {
        _6 = <Result<File, anyhow::Error> as Try>::branch(move _7) -> [return: bb8, unwind: bb39];
    }

    bb8: {
        _15 = discriminant(_6);
        switchInt(move _15) -> [0: bb9, 1: bb11, otherwise: bb10];
    }

    bb9: {
        _17 = move ((_6 as Continue).0: std::fs::File);
        _5 = move _17;
        _19 = &_5;
        _18 = BufWriter::<&File>::new(move _19) -> [return: bb12, unwind: bb38];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _16 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _16) -> [return: bb48, unwind: bb39];
    }

    bb12: {
        _23 = &((*_1).0: db::DBData);
        _22 = serialize_into::<BufWriter<&File>, DBData>(move _18, _23) -> [return: bb13, unwind: bb38];
    }

    bb13: {
        _21 = <Result<(), Box<bincode::ErrorKind>> as anyhow::Context<(), Box<bincode::ErrorKind>>>::context::<&str>(move _22, const "could not serialize database") -> [return: bb14, unwind: bb38];
    }

    bb14: {
        _20 = <Result<(), anyhow::Error> as Try>::branch(move _21) -> [return: bb15, unwind: bb38];
    }

    bb15: {
        _24 = discriminant(_20);
        switchInt(move _24) -> [0: bb16, 1: bb17, otherwise: bb10];
    }

    bb16: {
        _27 = &_3;
        _28 = &((*_1).2: std::path::PathBuf);
        _26 = rename::<&PathBuf, &PathBuf>(move _27, move _28) -> [return: bb19, unwind: bb38];
    }

    bb17: {
        _25 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _25) -> [return: bb18, unwind: bb38];
    }

    bb18: {
        drop(_5) -> [return: bb34, unwind: bb39];
    }

    bb19: {
        _40 = const true;
        _29 = discriminant(_26);
        switchInt(move _29) -> [1: bb20, otherwise: bb26];
    }

    bb20: {
        _40 = const false;
        _39 = const true;
        _30 = move ((_26 as Err).0: std::io::Error);
        _34 = &_3;
        _33 = remove_file::<&PathBuf>(move _34) -> [return: bb21, unwind: bb44];
    }

    bb21: {
        _32 = <Result<(), std::io::Error> as anyhow::Context<(), std::io::Error>>::context::<&str>(move _33, const "could not move or delete temporary database file") -> [return: bb22, unwind: bb44];
    }

    bb22: {
        _31 = <Result<(), anyhow::Error> as Try>::branch(move _32) -> [return: bb23, unwind: bb44];
    }

    bb23: {
        _35 = discriminant(_31);
        switchInt(move _35) -> [0: bb24, 1: bb25, otherwise: bb10];
    }

    bb24: {
        _39 = const false;
        _38 = move _30;
        _37 = Result::<(), std::io::Error>::Err(move _38);
        _0 = <Result<(), std::io::Error> as anyhow::Context<(), std::io::Error>>::context::<&str>(move _37, const "could not move temporary database file") -> [return: bb49, unwind: bb44];
    }

    bb25: {
        _36 = move ((_31 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _36) -> [return: bb50, unwind: bb44];
    }

    bb26: {
        drop(_5) -> [return: bb27, unwind: bb37];
    }

    bb27: {
        drop(_3) -> [return: bb28, unwind: bb47];
    }

    bb28: {
        drop(_26) -> [return: bb29, unwind continue];
    }

    bb29: {
        _40 = const false;
        goto -> bb30;
    }

    bb30: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        goto -> bb35;
    }

    bb31: {
        _39 = const false;
        drop(_5) -> [return: bb32, unwind: bb37];
    }

    bb32: {
        drop(_3) -> [return: bb33, unwind: bb47];
    }

    bb33: {
        _40 = const false;
        goto -> bb35;
    }

    bb34: {
        drop(_3) -> [return: bb35, unwind continue];
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_5) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_3) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_5) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_3) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        resume;
    }

    bb41: {
        drop(_30) -> [return: bb31, unwind: bb36];
    }

    bb42: {
        switchInt(_39) -> [0: bb31, otherwise: bb41];
    }

    bb43 (cleanup): {
        drop(_30) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        switchInt(_39) -> [0: bb36, otherwise: bb43];
    }

    bb45 (cleanup): {
        switchInt(_40) -> [0: bb40, otherwise: bb46];
    }

    bb46 (cleanup): {
        drop(((_26 as Err).0: std::io::Error)) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        _41 = discriminant(_26);
        switchInt(move _41) -> [1: bb45, otherwise: bb40];
    }

    bb48: {
        goto -> bb34;
    }

    bb49: {
        goto -> bb42;
    }

    bb50: {
        goto -> bb42;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::import(_1: &mut DB, _2: P, _3: bool) -> Result<(), anyhow::Error> {
    debug self => _1;
    debug path => _2;
    debug merge => _3;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let mut _4: bool;
    let mut _5: &std::vec::Vec<dir::Dir>;
    let mut _6: anyhow::Error;
    let _7: std::fs::File;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::fs::File>;
    let mut _9: std::result::Result<std::fs::File, anyhow::Error>;
    let mut _10: std::result::Result<std::fs::File, std::io::Error>;
    let mut _11: P;
    let mut _12: isize;
    let _13: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _14: std::fs::File;
    let mut _16: std::fs::File;
    let mut _17: std::iter::Enumerate<std::io::Lines<std::io::BufReader<std::fs::File>>>;
    let mut _18: std::iter::Enumerate<std::io::Lines<std::io::BufReader<std::fs::File>>>;
    let mut _19: std::io::Lines<std::io::BufReader<std::fs::File>>;
    let mut _21: std::option::Option<(usize, std::result::Result<std::string::String, std::io::Error>)>;
    let mut _22: &mut std::iter::Enumerate<std::io::Lines<std::io::BufReader<std::fs::File>>>;
    let mut _23: isize;
    let mut _27: (usize, bool);
    let mut _29: isize;
    let _31: ();
    let mut _32: std::fmt::Arguments<'_>;
    let mut _33: &[&str];
    let mut _34: &[core::fmt::rt::Argument<'_>];
    let _35: &[core::fmt::rt::Argument<'_>; 2];
    let _36: [core::fmt::rt::Argument<'_>; 2];
    let mut _37: core::fmt::rt::Argument<'_>;
    let _38: &usize;
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &std::result::Result<std::string::String, std::io::Error>;
    let mut _42: std::str::RSplitN<'_, char>;
    let _43: &str;
    let mut _44: &std::string::String;
    let mut _45: &[&str];
    let mut _46: &std::vec::Vec<&str>;
    let mut _47: bool;
    let mut _48: usize;
    let mut _49: usize;
    let mut _50: bool;
    let mut _51: usize;
    let mut _52: usize;
    let mut _53: bool;
    let mut _54: usize;
    let mut _55: usize;
    let mut _56: bool;
    let mut _60: std::result::Result<i64, std::num::ParseIntError>;
    let mut _61: isize;
    let _64: ();
    let mut _65: std::fmt::Arguments<'_>;
    let mut _66: &[&str];
    let mut _67: &[core::fmt::rt::Argument<'_>];
    let _68: &[core::fmt::rt::Argument<'_>; 3];
    let _69: [core::fmt::rt::Argument<'_>; 3];
    let mut _70: core::fmt::rt::Argument<'_>;
    let _71: &&&str;
    let mut _72: core::fmt::rt::Argument<'_>;
    let _73: &usize;
    let mut _74: core::fmt::rt::Argument<'_>;
    let _75: &std::num::ParseIntError;
    let mut _76: std::result::Result<f64, std::num::ParseFloatError>;
    let mut _77: isize;
    let _80: ();
    let mut _81: std::fmt::Arguments<'_>;
    let mut _82: &[&str];
    let mut _83: &[core::fmt::rt::Argument<'_>];
    let _84: &[core::fmt::rt::Argument<'_>; 3];
    let _85: [core::fmt::rt::Argument<'_>; 3];
    let mut _86: core::fmt::rt::Argument<'_>;
    let _87: &&&str;
    let mut _88: core::fmt::rt::Argument<'_>;
    let _89: &usize;
    let mut _90: core::fmt::rt::Argument<'_>;
    let _91: &std::num::ParseFloatError;
    let mut _93: std::result::Result<std::path::PathBuf, std::io::Error>;
    let _94: &std::path::Path;
    let mut _95: &&str;
    let mut _96: isize;
    let _99: ();
    let mut _100: std::fmt::Arguments<'_>;
    let mut _101: &[&str];
    let mut _102: &[core::fmt::rt::Argument<'_>];
    let _103: &[core::fmt::rt::Argument<'_>; 3];
    let _104: [core::fmt::rt::Argument<'_>; 3];
    let mut _105: core::fmt::rt::Argument<'_>;
    let _106: &&&str;
    let mut _107: core::fmt::rt::Argument<'_>;
    let _108: &usize;
    let mut _109: core::fmt::rt::Argument<'_>;
    let _110: &std::io::Error;
    let mut _111: std::option::Option<&mut dir::Dir>;
    let mut _112: &mut std::slice::IterMut<'_, dir::Dir>;
    let mut _113: std::slice::IterMut<'_, dir::Dir>;
    let mut _114: &mut [dir::Dir];
    let mut _115: &mut std::vec::Vec<dir::Dir>;
    let mut _116: {closure@src/db.rs:157:60: 157:65};
    let mut _117: &std::path::PathBuf;
    let mut _118: isize;
    let mut _120: i64;
    let mut _121: i64;
    let _122: ();
    let mut _123: &mut std::vec::Vec<dir::Dir>;
    let mut _124: dir::Dir;
    let mut _125: std::path::PathBuf;
    let _127: ();
    let mut _128: std::fmt::Arguments<'_>;
    let mut _129: &[&str];
    let mut _130: &[core::fmt::rt::Argument<'_>];
    let _131: &[core::fmt::rt::Argument<'_>; 2];
    let _132: [core::fmt::rt::Argument<'_>; 2];
    let mut _133: core::fmt::rt::Argument<'_>;
    let _134: &usize;
    let mut _135: core::fmt::rt::Argument<'_>;
    let _136: &&[&str];
    let mut _142: &str;
    let mut _143: &str;
    let mut _144: bool;
    let mut _145: bool;
    let mut _146: bool;
    let mut _147: bool;
    let mut _148: isize;
    let mut _149: isize;
    let mut _150: isize;
    scope 1 {
        debug z_db_file => _7;
        let _15: std::io::BufReader<std::fs::File>;
        scope 6 {
            debug reader => _15;
            let mut _20: std::iter::Enumerate<std::io::Lines<std::io::BufReader<std::fs::File>>>;
            scope 7 {
                debug iter => _20;
                let _24: usize;
                let _25: std::result::Result<std::string::String, std::io::Error>;
                scope 8 {
                    debug idx => _24;
                    debug read_line => _25;
                    let _26: usize;
                    scope 9 {
                        debug line_number => _26;
                        let _28: std::string::String;
                        let mut _137: &[&str; 3];
                        scope 10 {
                            debug line => _28;
                            let _41: std::vec::Vec<&str>;
                            scope 12 {
                                debug split_line => _41;
                                let _57: &&str;
                                let _58: &&str;
                                let _59: &&str;
                                let _126: &[&str];
                                scope 13 {
                                    debug epoch_str => _57;
                                    debug rank_str => _58;
                                    debug path_str => _59;
                                    let _62: i64;
                                    let _63: std::num::ParseIntError;
                                    scope 14 {
                                        debug epoch => _62;
                                        let _78: f64;
                                        let _79: std::num::ParseFloatError;
                                        scope 17 {
                                            debug rank => _78;
                                            let _92: std::path::PathBuf;
                                            let _97: std::path::PathBuf;
                                            let _98: std::io::Error;
                                            scope 20 {
                                                debug path_abs => _92;
                                                scope 23 {
                                                    debug dir => _119;
                                                    let _119: &mut dir::Dir;
                                                }
                                            }
                                            scope 21 {
                                                debug path => _97;
                                            }
                                            scope 22 {
                                                debug e => _98;
                                                let mut _141: &[&str; 4];
                                            }
                                        }
                                        scope 18 {
                                            debug rank => _78;
                                        }
                                        scope 19 {
                                            debug e => _79;
                                            let mut _140: &[&str; 4];
                                        }
                                    }
                                    scope 15 {
                                        debug epoch => _62;
                                    }
                                    scope 16 {
                                        debug e => _63;
                                        let mut _139: &[&str; 4];
                                    }
                                }
                                scope 24 {
                                    debug line => _126;
                                    let mut _138: &[&str; 3];
                                }
                            }
                        }
                        scope 11 {
                            debug line => _30;
                            let _30: std::string::String;
                        }
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _13;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _14;
        scope 5 {
        }
    }

    bb0: {
        _145 = const false;
        _147 = const false;
        _146 = const false;
        _144 = const false;
        _145 = const true;
        _5 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _4 = Vec::<Dir>::is_empty(move _5) -> [return: bb1, unwind: bb102];
    }

    bb1: {
        switchInt(move _4) -> [0: bb2, otherwise: bb5];
    }

    bb2: {
        switchInt(_3) -> [0: bb3, otherwise: bb5];
    }

    bb3: {
        _6 = new_adhoc::<&str>(const "To prevent conflicts, you can only import from z with an empty zoxide database!\nIf you wish to merge the two, specify the `--merge` flag.") -> [return: bb4, unwind: bb102];
    }

    bb4: {
        _0 = Result::<(), anyhow::Error>::Err(move _6);
        goto -> bb92;
    }

    bb5: {
        _145 = const false;
        _11 = move _2;
        _10 = File::open::<P>(move _11) -> [return: bb6, unwind: bb102];
    }

    bb6: {
        _9 = <Result<File, std::io::Error> as anyhow::Context<File, std::io::Error>>::context::<&str>(move _10, const "could not open z database file") -> [return: bb7, unwind: bb102];
    }

    bb7: {
        _8 = <Result<File, anyhow::Error> as Try>::branch(move _9) -> [return: bb8, unwind: bb102];
    }

    bb8: {
        _12 = discriminant(_8);
        switchInt(move _12) -> [0: bb9, 1: bb11, otherwise: bb10];
    }

    bb9: {
        _14 = move ((_8 as Continue).0: std::fs::File);
        _147 = const true;
        _7 = move _14;
        _147 = const false;
        _16 = move _7;
        _15 = BufReader::<File>::new(move _16) -> [return: bb13, unwind: bb100];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _13 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _13) -> [return: bb12, unwind: bb102];
    }

    bb12: {
        _147 = const false;
        goto -> bb92;
    }

    bb13: {
        _19 = <BufReader<File> as BufRead>::lines(move _15) -> [return: bb14, unwind: bb100];
    }

    bb14: {
        _18 = <std::io::Lines<BufReader<File>> as Iterator>::enumerate(move _19) -> [return: bb15, unwind: bb100];
    }

    bb15: {
        _17 = <Enumerate<std::io::Lines<BufReader<File>>> as IntoIterator>::into_iter(move _18) -> [return: bb16, unwind: bb100];
    }

    bb16: {
        _20 = move _17;
        goto -> bb17;
    }

    bb17: {
        _22 = &mut _20;
        _21 = <Enumerate<std::io::Lines<BufReader<File>>> as Iterator>::next(_22) -> [return: bb18, unwind: bb83];
    }

    bb18: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb20, 1: bb19, otherwise: bb10];
    }

    bb19: {
        _24 = (((_21 as Some).0: (usize, std::result::Result<std::string::String, std::io::Error>)).0: usize);
        _144 = const true;
        _25 = move (((_21 as Some).0: (usize, std::result::Result<std::string::String, std::io::Error>)).1: std::result::Result<std::string::String, std::io::Error>);
        _27 = CheckedAdd(_24, const 1_usize);
        assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", _24, const 1_usize) -> [success: bb21, unwind: bb98];
    }

    bb20: {
        drop(_20) -> [return: bb78, unwind: bb100];
    }

    bb21: {
        _26 = move (_27.0: usize);
        _29 = discriminant(_25);
        switchInt(move _29) -> [0: bb22, otherwise: bb23];
    }

    bb22: {
        _144 = const false;
        _30 = move ((_25 as Ok).0: std::string::String);
        _28 = move _30;
        _44 = &_28;
        _43 = <std::string::String as Deref>::deref(move _44) -> [return: bb27, unwind: bb82];
    }

    bb23: {
        _137 = const _;
        _33 = _137 as &[&str] (PointerCoercion(Unsize));
        _38 = &_26;
        _37 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_38) -> [return: bb24, unwind: bb98];
    }

    bb24: {
        _40 = &_25;
        _39 = core::fmt::rt::Argument::<'_>::new_debug::<Result<std::string::String, std::io::Error>>(_40) -> [return: bb25, unwind: bb98];
    }

    bb25: {
        _36 = [move _37, move _39];
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _32 = Arguments::<'_>::new_v1(move _33, move _34) -> [return: bb26, unwind: bb98];
    }

    bb26: {
        _31 = _eprint(move _32) -> [return: bb103, unwind: bb98];
    }

    bb27: {
        _42 = core::str::<impl str>::rsplitn::<'_, char>(_43, const 3_usize, const '|') -> [return: bb28, unwind: bb82];
    }

    bb28: {
        _41 = <std::str::RSplitN<'_, char> as Iterator>::collect::<Vec<&str>>(move _42) -> [return: bb29, unwind: bb82];
    }

    bb29: {
        _46 = &_41;
        _45 = Vec::<&str>::as_slice(move _46) -> [return: bb30, unwind: bb81];
    }

    bb30: {
        _54 = Len((*_45));
        _55 = const 3_usize;
        _56 = Eq(move _54, move _55);
        switchInt(move _56) -> [0: bb31, otherwise: bb36];
    }

    bb31: {
        _51 = Len((*_45));
        _52 = const 0_usize;
        _53 = Eq(move _51, move _52);
        switchInt(move _53) -> [0: bb32, otherwise: bb71];
    }

    bb32: {
        _48 = Len((*_45));
        _49 = const 1_usize;
        _50 = Eq(move _48, move _49);
        switchInt(move _50) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        _47 = <str as PartialEq>::eq((*_45)[0 of 1], const "") -> [return: bb35, unwind: bb81];
    }

    bb34: {
        _126 = _45;
        _138 = const _;
        _129 = _138 as &[&str] (PointerCoercion(Unsize));
        _134 = &_26;
        _133 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_134) -> [return: bb68, unwind: bb81];
    }

    bb35: {
        switchInt(move _47) -> [0: bb34, otherwise: bb71];
    }

    bb36: {
        _57 = &(*_45)[0 of 3];
        _58 = &(*_45)[1 of 3];
        _59 = &(*_45)[2 of 3];
        _142 = deref_copy (*_57);
        _60 = core::str::<impl str>::parse::<i64>(_142) -> [return: bb37, unwind: bb81];
    }

    bb37: {
        _61 = discriminant(_60);
        switchInt(move _61) -> [0: bb39, 1: bb38, otherwise: bb10];
    }

    bb38: {
        _63 = move ((_60 as Err).0: std::num::ParseIntError);
        _139 = const _;
        _66 = _139 as &[&str] (PointerCoercion(Unsize));
        _71 = &_57;
        _70 = core::fmt::rt::Argument::<'_>::new_display::<&&str>(_71) -> [return: bb40, unwind: bb81];
    }

    bb39: {
        _62 = ((_60 as Ok).0: i64);
        _143 = deref_copy (*_58);
        _76 = core::str::<impl str>::parse::<f64>(_143) -> [return: bb44, unwind: bb81];
    }

    bb40: {
        _73 = &_26;
        _72 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_73) -> [return: bb41, unwind: bb81];
    }

    bb41: {
        _75 = &_63;
        _74 = core::fmt::rt::Argument::<'_>::new_display::<ParseIntError>(_75) -> [return: bb42, unwind: bb81];
    }

    bb42: {
        _69 = [move _70, move _72, move _74];
        _68 = &_69;
        _67 = _68 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _65 = Arguments::<'_>::new_v1(move _66, move _67) -> [return: bb43, unwind: bb81];
    }

    bb43: {
        _64 = _eprint(move _65) -> [return: bb104, unwind: bb81];
    }

    bb44: {
        _77 = discriminant(_76);
        switchInt(move _77) -> [0: bb46, 1: bb45, otherwise: bb10];
    }

    bb45: {
        _79 = move ((_76 as Err).0: std::num::ParseFloatError);
        _140 = const _;
        _82 = _140 as &[&str] (PointerCoercion(Unsize));
        _87 = &_58;
        _86 = core::fmt::rt::Argument::<'_>::new_display::<&&str>(_87) -> [return: bb47, unwind: bb81];
    }

    bb46: {
        _78 = ((_76 as Ok).0: f64);
        _95 = _59;
        _94 = Path::new::<&str>(move _95) -> [return: bb51, unwind: bb81];
    }

    bb47: {
        _89 = &_26;
        _88 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_89) -> [return: bb48, unwind: bb81];
    }

    bb48: {
        _91 = &_79;
        _90 = core::fmt::rt::Argument::<'_>::new_display::<ParseFloatError>(_91) -> [return: bb49, unwind: bb81];
    }

    bb49: {
        _85 = [move _86, move _88, move _90];
        _84 = &_85;
        _83 = _84 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _81 = Arguments::<'_>::new_v1(move _82, move _83) -> [return: bb50, unwind: bb81];
    }

    bb50: {
        _80 = _eprint(move _81) -> [return: bb105, unwind: bb81];
    }

    bb51: {
        _93 = Path::canonicalize(_94) -> [return: bb52, unwind: bb81];
    }

    bb52: {
        _96 = discriminant(_93);
        switchInt(move _96) -> [0: bb54, 1: bb53, otherwise: bb10];
    }

    bb53: {
        _98 = move ((_93 as Err).0: std::io::Error);
        _141 = const _;
        _101 = _141 as &[&str] (PointerCoercion(Unsize));
        _106 = &_59;
        _105 = core::fmt::rt::Argument::<'_>::new_display::<&&str>(_106) -> [return: bb55, unwind: bb80];
    }

    bb54: {
        _97 = move ((_93 as Ok).0: std::path::PathBuf);
        _146 = const true;
        _92 = move _97;
        switchInt(_3) -> [0: bb66, otherwise: bb60];
    }

    bb55: {
        _108 = &_26;
        _107 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_108) -> [return: bb56, unwind: bb80];
    }

    bb56: {
        _110 = &_98;
        _109 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_110) -> [return: bb57, unwind: bb80];
    }

    bb57: {
        _104 = [move _105, move _107, move _109];
        _103 = &_104;
        _102 = _103 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _100 = Arguments::<'_>::new_v1(move _101, move _102) -> [return: bb58, unwind: bb80];
    }

    bb58: {
        _99 = _eprint(move _100) -> [return: bb59, unwind: bb80];
    }

    bb59: {
        drop(_98) -> [return: bb74, unwind: bb81];
    }

    bb60: {
        _115 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _114 = <Vec<Dir> as DerefMut>::deref_mut(move _115) -> [return: bb61, unwind: bb94];
    }

    bb61: {
        _113 = core::slice::<impl [Dir]>::iter_mut(_114) -> [return: bb62, unwind: bb94];
    }

    bb62: {
        _112 = &mut _113;
        _117 = &_92;
        _116 = {closure@src/db.rs:157:60: 157:65} { path_abs: move _117 };
        _111 = <std::slice::IterMut<'_, Dir> as Iterator>::find::<{closure@src/db.rs:157:60: 157:65}>(move _112, move _116) -> [return: bb63, unwind: bb94];
    }

    bb63: {
        _118 = discriminant(_111);
        switchInt(move _118) -> [1: bb64, otherwise: bb66];
    }

    bb64: {
        _119 = move ((_111 as Some).0: &mut dir::Dir);
        ((*_119).1: f64) = Add(((*_119).1: f64), _78);
        _121 = ((*_119).2: i64);
        _120 = <i64 as Ord>::max(_62, move _121) -> [return: bb65, unwind: bb94];
    }

    bb65: {
        ((*_119).2: i64) = move _120;
        drop(_92) -> [return: bb74, unwind: bb81];
    }

    bb66: {
        _123 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _146 = const false;
        _125 = move _92;
        _124 = Dir { path: move _125, rank: _78, last_accessed: _62 };
        _122 = Vec::<Dir>::push(move _123, move _124) -> [return: bb67, unwind: bb94];
    }

    bb67: {
        _146 = const false;
        goto -> bb71;
    }

    bb68: {
        _136 = &_126;
        _135 = core::fmt::rt::Argument::<'_>::new_debug::<&[&str]>(_136) -> [return: bb69, unwind: bb81];
    }

    bb69: {
        _132 = [move _133, move _135];
        _131 = &_132;
        _130 = _131 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _128 = Arguments::<'_>::new_v1(move _129, move _130) -> [return: bb70, unwind: bb81];
    }

    bb70: {
        _127 = _eprint(move _128) -> [return: bb106, unwind: bb81];
    }

    bb71: {
        drop(_41) -> [return: bb72, unwind: bb82];
    }

    bb72: {
        drop(_28) -> [return: bb73, unwind: bb98];
    }

    bb73: {
        _148 = discriminant(_25);
        switchInt(move _148) -> [0: bb85, otherwise: bb86];
    }

    bb74: {
        _146 = const false;
        goto -> bb75;
    }

    bb75: {
        drop(_41) -> [return: bb76, unwind: bb82];
    }

    bb76: {
        drop(_28) -> [return: bb77, unwind: bb98];
    }

    bb77: {
        _149 = discriminant(_25);
        switchInt(move _149) -> [0: bb88, otherwise: bb90];
    }

    bb78: {
        ((*_1).1: bool) = const true;
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        _147 = const false;
        goto -> bb79;
    }

    bb79: {
        return;
    }

    bb80 (cleanup): {
        drop(_98) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb81 (cleanup): {
        drop(_41) -> [return: bb82, unwind terminate(cleanup)];
    }

    bb82 (cleanup): {
        drop(_28) -> [return: bb98, unwind terminate(cleanup)];
    }

    bb83 (cleanup): {
        drop(_20) -> [return: bb100, unwind terminate(cleanup)];
    }

    bb84 (cleanup): {
        resume;
    }

    bb85: {
        _144 = const false;
        goto -> bb17;
    }

    bb86: {
        drop(_25) -> [return: bb85, unwind: bb83];
    }

    bb87: {
        _144 = const false;
        goto -> bb17;
    }

    bb88: {
        switchInt(_144) -> [0: bb87, otherwise: bb89];
    }

    bb89: {
        drop(((_25 as Ok).0: std::string::String)) -> [return: bb87, unwind: bb83];
    }

    bb90: {
        drop(_25) -> [return: bb87, unwind: bb83];
    }

    bb91: {
        drop(_2) -> [return: bb79, unwind continue];
    }

    bb92: {
        switchInt(_145) -> [0: bb79, otherwise: bb91];
    }

    bb93 (cleanup): {
        drop(_92) -> [return: bb81, unwind terminate(cleanup)];
    }

    bb94 (cleanup): {
        switchInt(_146) -> [0: bb81, otherwise: bb93];
    }

    bb95 (cleanup): {
        switchInt(_144) -> [0: bb83, otherwise: bb96];
    }

    bb96 (cleanup): {
        drop(((_25 as Ok).0: std::string::String)) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb97 (cleanup): {
        drop(_25) -> [return: bb83, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        _150 = discriminant(_25);
        switchInt(move _150) -> [0: bb95, otherwise: bb97];
    }

    bb99 (cleanup): {
        drop(_7) -> [return: bb102, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        switchInt(_147) -> [0: bb102, otherwise: bb99];
    }

    bb101 (cleanup): {
        drop(_2) -> [return: bb84, unwind terminate(cleanup)];
    }

    bb102 (cleanup): {
        switchInt(_145) -> [0: bb84, otherwise: bb101];
    }

    bb103: {
        goto -> bb77;
    }

    bb104: {
        goto -> bb75;
    }

    bb105: {
        goto -> bb75;
    }

    bb106: {
        goto -> bb75;
    }
}

promoted[0] in db::<impl at src/db.rs:23:1: 23:8>::import: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "could not read entry at line ", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in db::<impl at src/db.rs:23:1: 23:8>::import: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "invalid entry at line ", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in db::<impl at src/db.rs:23:1: 23:8>::import: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "invalid epoch '", const "' at line ", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in db::<impl at src/db.rs:23:1: 23:8>::import: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "invalid rank '", const "' at line ", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in db::<impl at src/db.rs:23:1: 23:8>::import: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "invalid path '", const "' at line ", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::import::{closure#0}(_1: &mut {closure@src/db.rs:157:60: 157:65}, _2: &&mut Dir) -> bool {
    debug dir => _2;
    debug path_abs => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let mut _3: &std::path::PathBuf;
    let mut _4: &mut dir::Dir;
    let mut _5: &std::path::PathBuf;

    bb0: {
        _4 = deref_copy (*_2);
        _3 = &((*_4).0: std::path::PathBuf);
        _5 = deref_copy ((*_1).0: &std::path::PathBuf);
        _0 = <PathBuf as PartialEq>::eq(move _3, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::add(_1: &mut DB, _2: P, _3: f64, _4: i64) -> Result<(), anyhow::Error> {
    debug self => _1;
    debug path => _2;
    debug max_age => _3;
    debug now => _4;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let _5: std::path::PathBuf;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::path::PathBuf>;
    let mut _7: std::result::Result<std::path::PathBuf, anyhow::Error>;
    let mut _8: std::result::Result<std::path::PathBuf, std::io::Error>;
    let _9: &std::path::Path;
    let mut _10: &P;
    let mut _11: {closure@src/db.rs:189:27: 189:29};
    let mut _12: &P;
    let mut _13: isize;
    let _14: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _15: std::path::PathBuf;
    let _16: ();
    let mut _17: std::option::Option<&mut dir::Dir>;
    let mut _18: &mut std::slice::IterMut<'_, dir::Dir>;
    let mut _19: std::slice::IterMut<'_, dir::Dir>;
    let mut _20: &mut [dir::Dir];
    let mut _21: &mut std::vec::Vec<dir::Dir>;
    let mut _22: {closure@src/db.rs:191:46: 191:51};
    let mut _23: &std::path::PathBuf;
    let mut _24: isize;
    let mut _25: &mut std::vec::Vec<dir::Dir>;
    let mut _26: dir::Dir;
    let mut _27: std::path::PathBuf;
    let mut _30: std::iter::Map<std::slice::Iter<'_, dir::Dir>, {closure@src/db.rs:203:49: 203:54}>;
    let mut _31: std::slice::Iter<'_, dir::Dir>;
    let _32: &[dir::Dir];
    let mut _33: &std::vec::Vec<dir::Dir>;
    let mut _34: bool;
    let mut _36: f64;
    let mut _37: std::slice::IterMut<'_, dir::Dir>;
    let mut _38: &mut std::vec::Vec<dir::Dir>;
    let mut _40: std::option::Option<&mut dir::Dir>;
    let mut _41: &mut std::slice::IterMut<'_, dir::Dir>;
    let mut _42: isize;
    let _44: ();
    let mut _45: &mut std::vec::Vec<dir::Dir>;
    let mut _46: bool;
    scope 1 {
        debug path_abs => _5;
        let _28: &mut dir::Dir;
        let _29: f64;
        scope 6 {
            debug dir => _28;
        }
        scope 7 {
            debug sum_age => _29;
            let _35: f64;
            scope 8 {
                debug factor => _35;
                let mut _39: std::slice::IterMut<'_, dir::Dir>;
                scope 9 {
                    debug iter => _39;
                    let _43: &mut dir::Dir;
                    scope 10 {
                        debug dir => _43;
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _14;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _15;
        scope 5 {
        }
    }

    bb0: {
        _46 = const false;
        _10 = &_2;
        _9 = <P as AsRef<Path>>::as_ref(move _10) -> [return: bb1, unwind: bb28];
    }

    bb1: {
        _8 = Path::canonicalize(_9) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _12 = &_2;
        _11 = {closure@src/db.rs:189:27: 189:29} { path: move _12 };
        _7 = <Result<PathBuf, std::io::Error> as anyhow::Context<PathBuf, std::io::Error>>::with_context::<anyhow::Error, {closure@src/db.rs:189:27: 189:29}>(move _8, move _11) -> [return: bb3, unwind: bb28];
    }

    bb3: {
        _6 = <Result<PathBuf, anyhow::Error> as Try>::branch(move _7) -> [return: bb4, unwind: bb28];
    }

    bb4: {
        _13 = discriminant(_6);
        switchInt(move _13) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _15 = move ((_6 as Continue).0: std::path::PathBuf);
        _46 = const true;
        _5 = move _15;
        _21 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _20 = <Vec<Dir> as DerefMut>::deref_mut(move _21) -> [return: bb9, unwind: bb32];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _14) -> [return: bb8, unwind: bb28];
    }

    bb8: {
        _46 = const false;
        drop(_2) -> [return: bb27, unwind continue];
    }

    bb9: {
        _19 = core::slice::<impl [Dir]>::iter_mut(_20) -> [return: bb10, unwind: bb32];
    }

    bb10: {
        _18 = &mut _19;
        _23 = &_5;
        _22 = {closure@src/db.rs:191:46: 191:51} { path_abs: move _23 };
        _17 = <std::slice::IterMut<'_, Dir> as Iterator>::find::<{closure@src/db.rs:191:46: 191:51}>(move _18, move _22) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _24 = discriminant(_17);
        switchInt(move _24) -> [0: bb13, 1: bb12, otherwise: bb6];
    }

    bb12: {
        _28 = move ((_17 as Some).0: &mut dir::Dir);
        ((*_28).2: i64) = _4;
        ((*_28).1: f64) = Add(((*_28).1: f64), const 1f64);
        goto -> bb14;
    }

    bb13: {
        _25 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _46 = const false;
        _27 = move _5;
        _26 = Dir { path: move _27, rank: const 1f64, last_accessed: _4 };
        _16 = Vec::<Dir>::push(move _25, move _26) -> [return: bb33, unwind: bb32];
    }

    bb14: {
        _33 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _32 = <Vec<Dir> as Deref>::deref(move _33) -> [return: bb15, unwind: bb32];
    }

    bb15: {
        _31 = core::slice::<impl [Dir]>::iter(_32) -> [return: bb16, unwind: bb32];
    }

    bb16: {
        _30 = <std::slice::Iter<'_, Dir> as Iterator>::map::<f64, {closure@src/db.rs:203:49: 203:54}>(move _31, const ZeroSized: {closure@src/db.rs:203:49: 203:54}) -> [return: bb17, unwind: bb32];
    }

    bb17: {
        _29 = <std::iter::Map<std::slice::Iter<'_, Dir>, {closure@src/db.rs:203:49: 203:54}> as Iterator>::sum::<f64>(move _30) -> [return: bb18, unwind: bb32];
    }

    bb18: {
        _34 = Gt(_29, _3);
        switchInt(move _34) -> [0: bb25, otherwise: bb19];
    }

    bb19: {
        _36 = Mul(const 0.90000000000000002f64, _3);
        _35 = Div(move _36, _29);
        _38 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _37 = <&mut Vec<Dir> as IntoIterator>::into_iter(move _38) -> [return: bb20, unwind: bb32];
    }

    bb20: {
        _39 = move _37;
        goto -> bb21;
    }

    bb21: {
        _41 = &mut _39;
        _40 = <std::slice::IterMut<'_, Dir> as Iterator>::next(_41) -> [return: bb22, unwind: bb32];
    }

    bb22: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb24, 1: bb23, otherwise: bb6];
    }

    bb23: {
        _43 = move ((_40 as Some).0: &mut dir::Dir);
        ((*_43).1: f64) = Mul(((*_43).1: f64), _35);
        goto -> bb21;
    }

    bb24: {
        _45 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _44 = Vec::<Dir>::retain::<{closure@src/db.rs:211:35: 211:40}>(move _45, const ZeroSized: {closure@src/db.rs:211:35: 211:40}) -> [return: bb34, unwind: bb32];
    }

    bb25: {
        ((*_1).1: bool) = const true;
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        switchInt(_46) -> [0: bb26, otherwise: bb30];
    }

    bb26: {
        _46 = const false;
        drop(_2) -> [return: bb27, unwind continue];
    }

    bb27: {
        return;
    }

    bb28 (cleanup): {
        drop(_2) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        resume;
    }

    bb30: {
        drop(_5) -> [return: bb26, unwind: bb28];
    }

    bb31 (cleanup): {
        drop(_5) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        switchInt(_46) -> [0: bb28, otherwise: bb31];
    }

    bb33: {
        goto -> bb14;
    }

    bb34: {
        goto -> bb25;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::add::{closure#0}(_1: {closure@src/db.rs:189:27: 189:29}) -> anyhow::Error {
    debug path => (*(_1.0: &P));
    let mut _0: anyhow::Error;
    let _2: std::string::String;
    let mut _3: std::fmt::Arguments<'_>;
    let mut _4: &[&str];
    let mut _5: &[core::fmt::rt::Argument<'_>];
    let _6: &[core::fmt::rt::Argument<'_>; 1];
    let _7: [core::fmt::rt::Argument<'_>; 1];
    let mut _8: core::fmt::rt::Argument<'_>;
    let _9: &std::path::Display<'_>;
    let _10: std::path::Display<'_>;
    let _11: &std::path::Path;
    let mut _12: &[&str; 1];
    let mut _13: &P;
    scope 1 {
        debug res => _2;
    }

    bb0: {
        _12 = const _;
        _4 = _12 as &[&str] (PointerCoercion(Unsize));
        _13 = deref_copy (_1.0: &P);
        _11 = <P as AsRef<Path>>::as_ref(_13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = Path::display(_11) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &_10;
        _8 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = [move _8];
        _6 = &_7;
        _5 = _6 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _3 = Arguments::<'_>::new_v1(move _4, move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = format(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = new_adhoc::<std::string::String>(move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in db::<impl at src/db.rs:23:1: 23:8>::add::{closure#0}: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "could not access directory: "];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::add::{closure#1}(_1: &mut {closure@src/db.rs:191:46: 191:51}, _2: &&mut Dir) -> bool {
    debug dir => _2;
    debug path_abs => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let mut _3: &std::path::PathBuf;
    let mut _4: &mut dir::Dir;
    let mut _5: &std::path::PathBuf;

    bb0: {
        _4 = deref_copy (*_2);
        _3 = &((*_4).0: std::path::PathBuf);
        _5 = deref_copy ((*_1).0: &std::path::PathBuf);
        _0 = <PathBuf as PartialEq>::eq(move _3, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::add::{closure#2}(_1: &mut {closure@src/db.rs:203:49: 203:54}, _2: &Dir) -> f64 {
    debug dir => _2;
    let mut _0: f64;

    bb0: {
        _0 = ((*_2).1: f64);
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::add::{closure#3}(_1: &mut {closure@src/db.rs:211:35: 211:40}, _2: &Dir) -> bool {
    debug dir => _2;
    let mut _0: bool;
    let mut _3: f64;

    bb0: {
        _3 = ((*_2).1: f64);
        _0 = Ge(move _3, const 1f64);
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query(_1: &mut DB, _2: &[std::string::String], _3: i64) -> std::option::Option<Dir> {
    debug self => _1;
    debug keywords => _2;
    debug now => _3;
    let mut _0: std::option::Option<dir::Dir>;
    let _4: usize;
    let _5: &dir::Dir;
    let mut _6: std::ops::ControlFlow<std::option::Option<std::convert::Infallible>, (usize, &dir::Dir, f64)>;
    let mut _7: std::option::Option<(usize, &dir::Dir, f64)>;
    let mut _8: std::iter::Map<std::iter::Filter<std::iter::Enumerate<std::slice::Iter<'_, dir::Dir>>, {closure@src/db.rs:224:21: 224:31}>, {closure@src/db.rs:225:18: 225:30}>;
    let mut _9: std::iter::Filter<std::iter::Enumerate<std::slice::Iter<'_, dir::Dir>>, {closure@src/db.rs:224:21: 224:31}>;
    let mut _10: std::iter::Enumerate<std::slice::Iter<'_, dir::Dir>>;
    let mut _11: std::slice::Iter<'_, dir::Dir>;
    let _12: &[dir::Dir];
    let mut _13: &std::vec::Vec<dir::Dir>;
    let mut _14: {closure@src/db.rs:224:21: 224:31};
    let mut _15: &&[std::string::String];
    let mut _16: {closure@src/db.rs:225:18: 225:30};
    let mut _17: &i64;
    let mut _18: isize;
    let _19: (usize, &dir::Dir, f64);
    let mut _20: bool;
    let mut _21: dir::Dir;
    let _22: dir::Dir;
    let mut _23: &mut std::vec::Vec<dir::Dir>;
    let mut _24: &[std::string::String];
    let mut _25: i64;
    scope 1 {
        debug idx => _4;
        debug dir => _5;
    }
    scope 2 {
        debug residual => const std::option::Option::<Infallible>::None;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _19;
        scope 5 {
        }
    }

    bb0: {
        _13 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _12 = <Vec<Dir> as Deref>::deref(move _13) -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = core::slice::<impl [Dir]>::iter(_12) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = <std::slice::Iter<'_, Dir> as Iterator>::enumerate(move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = &_2;
        _14 = {closure@src/db.rs:224:21: 224:31} { keywords: move _15 };
        _9 = <Enumerate<std::slice::Iter<'_, Dir>> as Iterator>::filter::<{closure@src/db.rs:224:21: 224:31}>(move _10, move _14) -> [return: bb4, unwind continue];
    }

    bb4: {
        _17 = &_3;
        _16 = {closure@src/db.rs:225:18: 225:30} { now: move _17 };
        _8 = <Filter<Enumerate<std::slice::Iter<'_, Dir>>, {closure@src/db.rs:224:21: 224:31}> as Iterator>::map::<(usize, &Dir, f64), {closure@src/db.rs:225:18: 225:30}>(move _9, move _16) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = <std::iter::Map<Filter<Enumerate<std::slice::Iter<'_, Dir>>, {closure@src/db.rs:224:21: 224:31}>, {closure@src/db.rs:225:18: 225:30}> as Iterator>::max_by::<{closure@src/db.rs:226:21: 226:59}>(move _8, const ZeroSized: {closure@src/db.rs:226:21: 226:59}) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = <std::option::Option<(usize, &Dir, f64)> as Try>::branch(move _7) -> [return: bb7, unwind continue];
    }

    bb7: {
        _18 = discriminant(_6);
        switchInt(move _18) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _19 = ((_6 as Continue).0: (usize, &dir::Dir, f64));
        _4 = (_19.0: usize);
        _5 = (_19.1: &dir::Dir);
        _20 = Dir::is_dir(_5) -> [return: bb11, unwind continue];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _0 = <std::option::Option<Dir> as FromResidual<std::option::Option<Infallible>>>::from_residual(const std::option::Option::<Infallible>::None) -> [return: bb17, unwind continue];
    }

    bb11: {
        switchInt(move _20) -> [0: bb14, otherwise: bb12];
    }

    bb12: {
        _21 = <Dir as ToOwned>::to_owned(_5) -> [return: bb13, unwind continue];
    }

    bb13: {
        _0 = std::option::Option::<Dir>::Some(move _21);
        goto -> bb17;
    }

    bb14: {
        _23 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _22 = Vec::<Dir>::swap_remove(move _23, _4) -> [return: bb15, unwind continue];
    }

    bb15: {
        drop(_22) -> [return: bb16, unwind continue];
    }

    bb16: {
        ((*_1).1: bool) = const true;
        _24 = _2;
        _25 = _3;
        _0 = DB::query(_1, move _24, move _25) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query::{closure#0}(_1: &mut {closure@src/db.rs:224:21: 224:31}, _2: &(usize, &Dir)) -> bool {
    debug keywords => (*((*_1).0: &&[std::string::String]));
    let mut _0: bool;
    let _3: &&dir::Dir;
    let mut _4: &dir::Dir;
    let mut _5: &&[std::string::String];
    let mut _6: &[std::string::String];
    scope 1 {
        debug dir => _3;
    }

    bb0: {
        _3 = &((*_2).1: &dir::Dir);
        _4 = deref_copy (*_3);
        _5 = deref_copy ((*_1).0: &&[std::string::String]);
        _6 = deref_copy (*_5);
        _0 = Dir::is_match(_4, _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query::{closure#1}(_1: &mut {closure@src/db.rs:225:18: 225:30}, _2: (usize, &Dir)) -> (usize, &Dir, f64) {
    debug now => (*((*_1).0: &i64));
    let mut _0: (usize, &dir::Dir, f64);
    let _3: usize;
    let _4: &dir::Dir;
    let mut _5: f64;
    let mut _6: i64;
    let mut _7: &i64;
    scope 1 {
        debug idx => _3;
        debug dir => _4;
    }

    bb0: {
        _3 = (_2.0: usize);
        _4 = (_2.1: &dir::Dir);
        _7 = deref_copy ((*_1).0: &i64);
        _6 = (*_7);
        _5 = Dir::get_frecency(_4, move _6) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = (_3, _4, move _5);
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query::{closure#2}(_1: &mut {closure@src/db.rs:226:21: 226:59}, _2: &(usize, &Dir, f64), _3: &(usize, &Dir, f64)) -> std::cmp::Ordering {
    let mut _0: std::cmp::Ordering;
    let _4: &f64;
    let _5: &f64;
    let mut _6: std::option::Option<std::cmp::Ordering>;
    let mut _7: std::cmp::Ordering;
    scope 1 {
        debug frecency1 => _4;
        debug frecency2 => _5;
    }

    bb0: {
        _4 = &((*_2).2: f64);
        _5 = &((*_3).2: f64);
        _6 = <f64 as PartialOrd>::partial_cmp(_4, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = Equal;
        _0 = std::option::Option::<std::cmp::Ordering>::unwrap_or(move _6, move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query_all(_1: &mut DB, _2: &[std::string::String]) -> Vec<Dir> {
    debug self => _1;
    debug keywords => _2;
    let mut _0: std::vec::Vec<dir::Dir>;
    let _3: usize;
    let mut _4: &std::vec::Vec<dir::Dir>;
    let _5: ();
    let mut _6: &mut std::vec::Vec<dir::Dir>;
    let mut _7: bool;
    let mut _8: usize;
    let mut _9: &std::vec::Vec<dir::Dir>;
    let mut _10: std::iter::Cloned<std::iter::Filter<std::slice::Iter<'_, dir::Dir>, {closure@src/db.rs:250:21: 250:26}>>;
    let mut _11: std::iter::Filter<std::slice::Iter<'_, dir::Dir>, {closure@src/db.rs:250:21: 250:26}>;
    let mut _12: std::slice::Iter<'_, dir::Dir>;
    let _13: &[dir::Dir];
    let mut _14: &std::vec::Vec<dir::Dir>;
    let mut _15: {closure@src/db.rs:250:21: 250:26};
    let mut _16: &&[std::string::String];
    scope 1 {
        debug orig_len => _3;
    }

    bb0: {
        _4 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _3 = Vec::<Dir>::len(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _5 = Vec::<Dir>::retain::<for<'a> fn(&'a Dir) -> bool {Dir::is_dir}>(move _6, Dir::is_dir) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _8 = Vec::<Dir>::len(move _9) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = Ne(_3, move _8);
        switchInt(move _7) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        ((*_1).1: bool) = const true;
        goto -> bb5;
    }

    bb5: {
        _14 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _13 = <Vec<Dir> as Deref>::deref(move _14) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = core::slice::<impl [Dir]>::iter(_13) -> [return: bb7, unwind continue];
    }

    bb7: {
        _16 = &_2;
        _15 = {closure@src/db.rs:250:21: 250:26} { keywords: move _16 };
        _11 = <std::slice::Iter<'_, Dir> as Iterator>::filter::<{closure@src/db.rs:250:21: 250:26}>(move _12, move _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = <Filter<std::slice::Iter<'_, Dir>, {closure@src/db.rs:250:21: 250:26}> as Iterator>::cloned::<'_, Dir>(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = <Cloned<Filter<std::slice::Iter<'_, Dir>, {closure@src/db.rs:250:21: 250:26}>> as Iterator>::collect::<Vec<Dir>>(move _10) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::query_all::{closure#0}(_1: &mut {closure@src/db.rs:250:21: 250:26}, _2: &&Dir) -> bool {
    debug dir => _2;
    debug keywords => (*((*_1).0: &&[std::string::String]));
    let mut _0: bool;
    let mut _3: &dir::Dir;
    let mut _4: &&[std::string::String];
    let mut _5: &[std::string::String];

    bb0: {
        _3 = deref_copy (*_2);
        _4 = deref_copy ((*_1).0: &&[std::string::String]);
        _5 = deref_copy (*_4);
        _0 = Dir::is_match(_3, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::remove(_1: &mut DB, _2: P) -> Result<(), anyhow::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let _3: std::path::PathBuf;
    let mut _4: std::result::Result<std::path::PathBuf, std::io::Error>;
    let _5: &std::path::Path;
    let mut _6: &P;
    let mut _7: isize;
    let _8: std::path::PathBuf;
    let _9: &std::path::Path;
    let mut _10: &P;
    let mut _11: std::option::Option<usize>;
    let mut _12: &mut std::slice::Iter<'_, dir::Dir>;
    let mut _13: std::slice::Iter<'_, dir::Dir>;
    let _14: &[dir::Dir];
    let mut _15: &std::vec::Vec<dir::Dir>;
    let mut _16: {closure@src/db.rs:261:59: 261:64};
    let mut _17: &std::path::PathBuf;
    let mut _18: isize;
    let _20: dir::Dir;
    let mut _21: &mut std::vec::Vec<dir::Dir>;
    let mut _22: isize;
    let mut _23: isize;
    scope 1 {
        debug path_abs => _3;
        scope 3 {
            debug idx => _19;
            let _19: usize;
        }
    }
    scope 2 {
        debug path_abs => _8;
    }

    bb0: {
        _6 = &_2;
        _5 = <P as AsRef<Path>>::as_ref(move _6) -> [return: bb1, unwind: bb17];
    }

    bb1: {
        _4 = Path::canonicalize(_5) -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _10 = &_2;
        _9 = <P as AsRef<Path>>::as_ref(move _10) -> [return: bb6, unwind: bb23];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_4 as Ok).0: std::path::PathBuf);
        _3 = move _8;
        goto -> bb21;
    }

    bb6: {
        _3 = Path::to_path_buf(_9) -> [return: bb24, unwind: bb23];
    }

    bb7: {
        _13 = core::slice::<impl [Dir]>::iter(_14) -> [return: bb8, unwind: bb16];
    }

    bb8: {
        _12 = &mut _13;
        _17 = &_3;
        _16 = {closure@src/db.rs:261:59: 261:64} { path_abs: move _17 };
        _11 = <std::slice::Iter<'_, Dir> as Iterator>::position::<{closure@src/db.rs:261:59: 261:64}>(move _12, move _16) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _18 = discriminant(_11);
        switchInt(move _18) -> [1: bb10, otherwise: bb13];
    }

    bb10: {
        _19 = ((_11 as Some).0: usize);
        _21 = &mut (((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _20 = Vec::<Dir>::swap_remove(move _21, _19) -> [return: bb11, unwind: bb16];
    }

    bb11: {
        drop(_20) -> [return: bb12, unwind: bb16];
    }

    bb12: {
        ((*_1).1: bool) = const true;
        goto -> bb13;
    }

    bb13: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        drop(_3) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        _15 = &(((*_1).0: db::DBData).1: std::vec::Vec<dir::Dir>);
        _14 = <Vec<Dir> as Deref>::deref(move _15) -> [return: bb7, unwind: bb16];
    }

    bb20: {
        drop(_4) -> [return: bb19, unwind: bb16];
    }

    bb21: {
        _22 = discriminant(_4);
        switchInt(move _22) -> [0: bb19, otherwise: bb20];
    }

    bb22 (cleanup): {
        drop(_4) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        _23 = discriminant(_4);
        switchInt(move _23) -> [0: bb17, otherwise: bb22];
    }

    bb24: {
        goto -> bb21;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::remove::{closure#0}(_1: &mut {closure@src/db.rs:261:59: 261:64}, _2: &Dir) -> bool {
    debug dir => _2;
    debug path_abs => (*((*_1).0: &std::path::PathBuf));
    let mut _0: bool;
    let mut _3: &std::path::PathBuf;
    let mut _4: &std::path::PathBuf;

    bb0: {
        _3 = &((*_2).0: std::path::PathBuf);
        _4 = deref_copy ((*_1).0: &std::path::PathBuf);
        _0 = <PathBuf as PartialEq>::eq(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn db::<impl at src/db.rs:23:1: 23:8>::get_path_tmp(_1: &DB) -> PathBuf {
    debug self => _1;
    let mut _0: std::path::PathBuf;
    let _2: std::string::String;
    let _3: std::string::String;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let _10: &uuid::Uuid;
    let _11: uuid::Uuid;
    let mut _13: &std::path::PathBuf;
    let _14: ();
    let mut _15: &mut std::path::PathBuf;
    let mut _16: std::string::String;
    let mut _17: &[&str; 2];
    let mut _18: bool;
    scope 1 {
        debug file_name => _2;
        let mut _12: std::path::PathBuf;
        scope 3 {
            debug path_tmp => _12;
        }
    }
    scope 2 {
        debug res => _3;
    }

    bb0: {
        _18 = const false;
        _17 = const _;
        _5 = _17 as &[&str] (PointerCoercion(Unsize));
        _11 = uuid::v4::<impl Uuid>::new_v4() -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &_11;
        _9 = core::fmt::rt::Argument::<'_>::new_display::<Uuid>(_10) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_v1(move _5, move _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = format(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _18 = const true;
        _2 = move _3;
        _13 = &((*_1).2: std::path::PathBuf);
        _12 = <PathBuf as Clone>::clone(move _13) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _15 = &mut _12;
        _18 = const false;
        _16 = move _2;
        _14 = PathBuf::set_file_name::<std::string::String>(move _15, move _16) -> [return: bb6, unwind: bb7];
    }

    bb6: {
        _0 = move _12;
        _18 = const false;
        return;
    }

    bb7 (cleanup): {
        drop(_12) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_18) -> [0: bb8, otherwise: bb9];
    }
}

promoted[0] in db::<impl at src/db.rs:23:1: 23:8>::get_path_tmp: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const ".", const ".zo"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:279:1: 279:17>::drop(_1: &mut DB) -> () {
    debug self => _1;
    let mut _0: ();
    let mut _2: std::result::Result<(), anyhow::Error>;
    let mut _3: isize;
    let _5: ();
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 1];
    let _10: [core::fmt::rt::Argument<'_>; 1];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &anyhow::Error;
    let mut _13: &[core::fmt::rt::Placeholder];
    let _14: &[core::fmt::rt::Placeholder; 1];
    let _15: [core::fmt::rt::Placeholder; 1];
    let mut _16: core::fmt::rt::Placeholder;
    let mut _17: core::fmt::rt::Alignment;
    let mut _18: core::fmt::rt::Count;
    let mut _19: core::fmt::rt::Count;
    let mut _20: core::fmt::rt::UnsafeArg;
    let mut _21: &std::option::Option<std::path::PathBuf>;
    let mut _22: isize;
    let mut _24: std::result::Result<(), anyhow::Error>;
    let mut _25: std::result::Result<(), std::io::Error>;
    let mut _26: isize;
    let _28: ();
    let mut _29: std::fmt::Arguments<'_>;
    let mut _30: &[&str];
    let mut _31: &[core::fmt::rt::Argument<'_>];
    let _32: &[core::fmt::rt::Argument<'_>; 1];
    let _33: [core::fmt::rt::Argument<'_>; 1];
    let mut _34: core::fmt::rt::Argument<'_>;
    let _35: &anyhow::Error;
    let mut _36: &[core::fmt::rt::Placeholder];
    let _37: &[core::fmt::rt::Placeholder; 1];
    let _38: [core::fmt::rt::Placeholder; 1];
    let mut _39: core::fmt::rt::Placeholder;
    let mut _40: core::fmt::rt::Alignment;
    let mut _41: core::fmt::rt::Count;
    let mut _42: core::fmt::rt::Count;
    let mut _43: core::fmt::rt::UnsafeArg;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: isize;
    let mut _49: isize;
    let mut _50: isize;
    scope 1 {
        debug e => _4;
        let _4: anyhow::Error;
        let mut _45: &[&str; 2];
        scope 2 {
        }
    }
    scope 3 {
        debug path_old => _23;
        let _23: &std::path::PathBuf;
        scope 4 {
            debug e => _27;
            let _27: anyhow::Error;
            let mut _44: &[&str; 2];
            scope 5 {
            }
        }
    }

    bb0: {
        _47 = const false;
        _46 = const false;
        _47 = const true;
        _2 = DB::save(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [1: bb2, otherwise: bb8];
    }

    bb2: {
        _47 = const false;
        _4 = move ((_2 as Err).0: anyhow::Error);
        _45 = const _;
        _7 = _45 as &[&str] (PointerCoercion(Unsize));
        _12 = &_4;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<anyhow::Error>(_12) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _10 = [move _11];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::Alignment::Unknown;
        _18 = core::fmt::rt::Count::Implied;
        _19 = core::fmt::rt::Count::Implied;
        _16 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _17, const 4_u32, move _18, move _19) -> [return: bb4, unwind: bb19];
    }

    bb4: {
        _15 = [move _16];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _20 = core::fmt::rt::UnsafeArg::new() -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _6 = Arguments::<'_>::new_v1_formatted(move _7, move _8, move _13, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _5 = _eprint(move _6) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        drop(_4) -> [return: bb28, unwind: bb31];
    }

    bb8: {
        _21 = &((*_1).3: std::option::Option<std::path::PathBuf>);
        _22 = discriminant((*_21));
        switchInt(move _22) -> [1: bb9, otherwise: bb28];
    }

    bb9: {
        _23 = &(((*_21) as Some).0: std::path::PathBuf);
        _25 = remove_file::<&PathBuf>(_23) -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _24 = <Result<(), std::io::Error> as anyhow::Context<(), std::io::Error>>::context::<&str>(move _25, const "could not remove old database") -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _46 = const true;
        _26 = discriminant(_24);
        switchInt(move _26) -> [1: bb12, otherwise: bb24];
    }

    bb12: {
        _46 = const false;
        _27 = move ((_24 as Err).0: anyhow::Error);
        _44 = const _;
        _30 = _44 as &[&str] (PointerCoercion(Unsize));
        _35 = &_27;
        _34 = core::fmt::rt::Argument::<'_>::new_display::<anyhow::Error>(_35) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _33 = [move _34];
        _32 = &_33;
        _31 = _32 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _40 = core::fmt::rt::Alignment::Unknown;
        _41 = core::fmt::rt::Count::Implied;
        _42 = core::fmt::rt::Count::Implied;
        _39 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _40, const 4_u32, move _41, move _42) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _38 = [move _39];
        _37 = &_38;
        _36 = _37 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _43 = core::fmt::rt::UnsafeArg::new() -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _29 = Arguments::<'_>::new_v1_formatted(move _30, move _31, move _36, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb16, unwind: bb18];
    }

    bb16: {
        _28 = _eprint(move _29) -> [return: bb17, unwind: bb18];
    }

    bb17: {
        drop(_27) -> [return: bb24, unwind: bb31];
    }

    bb18 (cleanup): {
        drop(_27) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        drop(_4) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        resume;
    }

    bb21: {
        _46 = const false;
        goto -> bb28;
    }

    bb22: {
        switchInt(_46) -> [0: bb21, otherwise: bb23];
    }

    bb23: {
        drop(((_24 as Err).0: anyhow::Error)) -> [return: bb21, unwind: bb31];
    }

    bb24: {
        _48 = discriminant(_24);
        switchInt(move _48) -> [1: bb22, otherwise: bb21];
    }

    bb25: {
        _47 = const false;
        return;
    }

    bb26: {
        switchInt(_47) -> [0: bb25, otherwise: bb27];
    }

    bb27: {
        drop(((_2 as Err).0: anyhow::Error)) -> [return: bb25, unwind continue];
    }

    bb28: {
        _49 = discriminant(_2);
        switchInt(move _49) -> [1: bb26, otherwise: bb25];
    }

    bb29 (cleanup): {
        switchInt(_47) -> [0: bb20, otherwise: bb30];
    }

    bb30 (cleanup): {
        drop(((_2 as Err).0: anyhow::Error)) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        _50 = discriminant(_2);
        switchInt(move _50) -> [1: bb29, otherwise: bb20];
    }
}

promoted[0] in db::<impl at src/db.rs:279:1: 279:17>::drop: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in db::<impl at src/db.rs:279:1: 279:17>::drop: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn db::<impl at src/db.rs:292:10: 292:15>::fmt(_1: &DBData, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &i32;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::vec::Vec<dir::Dir>;
    let _10: &std::vec::Vec<dir::Dir>;

    bb0: {
        _3 = const "DBData";
        _4 = const "version";
        _6 = &((*_1).0: i32);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "dirs";
        _10 = &((*_1).1: std::vec::Vec<dir::Dir>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const _IMPL_DESERIALIZE_FOR_DBData: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize(_1: __D) -> Result<DBData, <__D as Deserializer<'_>>::Error> {
    debug __deserializer => _1;
    let mut _0: std::result::Result<db::DBData, <__D as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserializer<'_>>::Error>;

    bb0: {
        _0 = <__D as Deserializer<'_>>::deserialize_struct::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor<'_>>(move _1, const "DBData", const _, const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<DBData>, lifetime: PhantomData::<&()> }}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::expecting(_1: &_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug __formatter => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "field identifier";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_u64(_1: _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor, _2: u64) -> Result<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field, __E>;
    let mut _3: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _4: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _5: __E;
    let mut _6: db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Unexpected<'_>;
    let mut _7: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _8: &&str;

    bb0: {
        switchInt(_2) -> [0: bb2, 1: bb3, otherwise: bb1];
    }

    bb1: {
        _6 = Unexpected::<'_>::Unsigned(_2);
        _8 = const _;
        _7 = _8 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _5 = <__E as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_value(move _6, move _7) -> [return: bb4, unwind continue];
    }

    bb2: {
        _3 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _3);
        goto -> bb5;
    }

    bb3: {
        _4 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _4);
        goto -> bb5;
    }

    bb4: {
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Err(move _5);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_u64: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "field index 0 <= i < 2";
        _0 = &_1;
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_str(_1: _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor, _2: &str) -> Result<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field, __E>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _6: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _7: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;

    bb0: {
        _4 = <str as PartialEq>::eq(_2, const "version") -> [return: bb6, unwind continue];
    }

    bb1: {
        _5 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _5);
        goto -> bb7;
    }

    bb2: {
        _3 = <str as PartialEq>::eq(_2, const "dirs") -> [return: bb5, unwind continue];
    }

    bb3: {
        _6 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _6);
        goto -> bb7;
    }

    bb4: {
        _7 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__ignore;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _7);
        goto -> bb7;
    }

    bb5: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb6: {
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb7: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_bytes(_1: _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor, _2: &[u8]) -> Result<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field, __E>;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _10: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
    let mut _11: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;

    bb0: {
        _6 = Len((*_2));
        _7 = const 7_usize;
        _8 = Eq(move _6, move _7);
        switchInt(move _8) -> [0: bb9, otherwise: bb1];
    }

    bb1: {
        switchInt((*_2)[0 of 7]) -> [118: bb2, otherwise: bb8];
    }

    bb2: {
        switchInt((*_2)[1 of 7]) -> [101: bb3, otherwise: bb8];
    }

    bb3: {
        switchInt((*_2)[2 of 7]) -> [114: bb4, otherwise: bb8];
    }

    bb4: {
        switchInt((*_2)[3 of 7]) -> [115: bb5, otherwise: bb8];
    }

    bb5: {
        switchInt((*_2)[4 of 7]) -> [105: bb6, otherwise: bb8];
    }

    bb6: {
        switchInt((*_2)[5 of 7]) -> [111: bb7, otherwise: bb8];
    }

    bb7: {
        switchInt((*_2)[6 of 7]) -> [110: bb14, otherwise: bb8];
    }

    bb8: {
        _11 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__ignore;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _11);
        goto -> bb16;
    }

    bb9: {
        _3 = Len((*_2));
        _4 = const 4_usize;
        _5 = Eq(move _3, move _4);
        switchInt(move _5) -> [0: bb8, otherwise: bb10];
    }

    bb10: {
        switchInt((*_2)[0 of 4]) -> [100: bb11, otherwise: bb8];
    }

    bb11: {
        switchInt((*_2)[1 of 4]) -> [105: bb12, otherwise: bb8];
    }

    bb12: {
        switchInt((*_2)[2 of 4]) -> [114: bb13, otherwise: bb8];
    }

    bb13: {
        switchInt((*_2)[3 of 4]) -> [115: bb15, otherwise: bb8];
    }

    bb14: {
        _9 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _9);
        goto -> bb16;
    }

    bb15: {
        _10 = _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, __E>::Ok(move _10);
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::deserialize(_1: __D) -> Result<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field, <__D as Deserializer<'_>>::Error> {
    debug __deserializer => _1;
    let mut _0: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field, <__D as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserializer<'_>>::Error>;

    bb0: {
        _0 = <__D as Deserializer<'_>>::deserialize_identifier::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor>(move _1, const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__FieldVisitor) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::expecting(_1: &_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor<'_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug __formatter => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "struct DBData";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_seq(_1: _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor<'_>, _2: __A) -> Result<DBData, <__A as SeqAccess<'_>>::Error> {
    debug self => const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<DBData>, lifetime: PhantomData::<&()> }};
    debug __seq => _2;
    let mut _0: std::result::Result<db::DBData, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _3: std::result::Result<std::option::Option<i32>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _4: &mut __A;
    let mut _5: isize;
    let _6: std::option::Option<i32>;
    let _7: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _8: isize;
    let _9: i32;
    let mut _10: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _11: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _12: std::result::Result<std::option::Option<std::vec::Vec<dir::Dir>>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _13: &mut __A;
    let mut _14: isize;
    let mut _17: isize;
    let mut _19: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _20: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _21: db::DBData;
    let mut _22: &&str;
    scope 1 {
        debug __field0 => _9;
        let _15: std::option::Option<std::vec::Vec<dir::Dir>>;
        let _16: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
        let _18: std::vec::Vec<dir::Dir>;
        let mut _23: &&str;
        scope 5 {
            debug __field1 => _18;
        }
        scope 6 {
            debug __val => _15;
        }
        scope 7 {
            debug __err => _16;
        }
        scope 8 {
            debug __value => _18;
        }
    }
    scope 2 {
        debug __val => _6;
    }
    scope 3 {
        debug __err => _7;
    }
    scope 4 {
        debug __value => _9;
    }

    bb0: {
        _4 = &mut _2;
        _3 = <__A as SeqAccess<'_>>::next_element::<i32>(_4) -> [return: bb1, unwind: bb16];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = move ((_3 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as SeqAccess<'_>>::Error>::Err(move _7);
        goto -> bb14;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = ((_3 as Ok).0: std::option::Option<i32>);
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb6, otherwise: bb3];
    }

    bb5: {
        _22 = const _;
        _11 = _22 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _10 = <<__A as SeqAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_length(const 0_usize, move _11) -> [return: bb7, unwind: bb16];
    }

    bb6: {
        _9 = ((_6 as Some).0: i32);
        _13 = &mut _2;
        _12 = <__A as SeqAccess<'_>>::next_element::<Vec<Dir>>(_13) -> [return: bb8, unwind: bb16];
    }

    bb7: {
        _0 = Result::<DBData, <__A as SeqAccess<'_>>::Error>::Err(move _10);
        goto -> bb14;
    }

    bb8: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb10, 1: bb9, otherwise: bb3];
    }

    bb9: {
        _16 = move ((_12 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as SeqAccess<'_>>::Error>::Err(move _16);
        goto -> bb14;
    }

    bb10: {
        _15 = move ((_12 as Ok).0: std::option::Option<std::vec::Vec<dir::Dir>>);
        _17 = discriminant(_15);
        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb3];
    }

    bb11: {
        _23 = const _;
        _20 = _23 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _19 = <<__A as SeqAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_length(const 1_usize, move _20) -> [return: bb13, unwind: bb16];
    }

    bb12: {
        _18 = move ((_15 as Some).0: std::vec::Vec<dir::Dir>);
        _21 = DBData { version: _9, dirs: move _18 };
        _0 = Result::<DBData, <__A as SeqAccess<'_>>::Error>::Ok(move _21);
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb13: {
        _0 = Result::<DBData, <__A as SeqAccess<'_>>::Error>::Err(move _19);
        goto -> bb14;
    }

    bb14: {
        drop(_2) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_2) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        resume;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_seq: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "struct DBData with 2 elements";
        _0 = &_1;
        return;
    }
}

promoted[1] in _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_seq: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "struct DBData with 2 elements";
        _0 = &_1;
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::<impl at src/db.rs:292:17: 292:28>::visit_map(_1: _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor<'_>, _2: __A) -> Result<DBData, <__A as MapAccess<'_>>::Error> {
    debug self => const _IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<DBData>, lifetime: PhantomData::<&()> }};
    debug __map => _2;
    let mut _0: std::result::Result<db::DBData, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _3: std::option::Option<i32>;
    let mut _5: std::result::Result<std::option::Option<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _6: &mut __A;
    let mut _7: isize;
    let mut _10: isize;
    let mut _12: isize;
    let mut _13: bool;
    let _14: &std::option::Option<i32>;
    let mut _15: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
    let mut _16: std::option::Option<i32>;
    let mut _17: std::result::Result<i32, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _18: &mut __A;
    let mut _19: isize;
    let mut _22: bool;
    let _23: &std::option::Option<std::vec::Vec<dir::Dir>>;
    let mut _24: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
    let mut _25: std::option::Option<std::vec::Vec<dir::Dir>>;
    let mut _26: std::result::Result<std::vec::Vec<dir::Dir>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _27: &mut __A;
    let mut _28: isize;
    let mut _31: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::IgnoredAny, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _32: &mut __A;
    let mut _33: isize;
    let mut _36: isize;
    let mut _38: std::result::Result<i32, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _39: isize;
    let mut _43: isize;
    let mut _45: std::result::Result<std::vec::Vec<dir::Dir>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _46: isize;
    let mut _49: db::DBData;
    let mut _50: i32;
    let mut _51: std::vec::Vec<dir::Dir>;
    let mut _52: bool;
    let mut _53: isize;
    let mut _54: isize;
    scope 1 {
        debug __field0 => _3;
        let mut _4: std::option::Option<std::vec::Vec<dir::Dir>>;
        scope 2 {
            debug __field1 => _4;
            let _35: i32;
            let _37: i32;
            let _40: i32;
            let _41: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
            scope 3 {
                debug __key => _11;
                let _8: std::option::Option<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field>;
                let _9: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                let _11: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field;
                let _20: i32;
                let _21: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                let _29: std::vec::Vec<dir::Dir>;
                let _30: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                let _34: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                scope 4 {
                    debug __val => _8;
                }
                scope 5 {
                    debug __err => _9;
                }
                scope 6 {
                    debug __val => _20;
                }
                scope 7 {
                    debug __err => _21;
                }
                scope 8 {
                    debug __val => _29;
                }
                scope 9 {
                    debug __err => _30;
                }
                scope 10 {
                }
                scope 11 {
                    debug __val => const IgnoredAny;
                }
                scope 12 {
                    debug __err => _34;
                }
            }
            scope 13 {
                debug __field0 => _35;
                let _42: std::vec::Vec<dir::Dir>;
                let _44: std::vec::Vec<dir::Dir>;
                let _47: std::vec::Vec<dir::Dir>;
                let _48: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                scope 17 {
                    debug __field1 => _42;
                }
                scope 18 {
                    debug __field1 => _44;
                }
                scope 19 {
                    debug __val => _47;
                }
                scope 20 {
                    debug __err => _48;
                }
            }
            scope 14 {
                debug __field0 => _37;
            }
            scope 15 {
                debug __val => _40;
            }
            scope 16 {
                debug __err => _41;
            }
        }
    }

    bb0: {
        _52 = const false;
        _3 = std::option::Option::<i32>::None;
        _52 = const true;
        _4 = std::option::Option::<Vec<Dir>>::None;
        goto -> bb1;
    }

    bb1: {
        _6 = &mut _2;
        _5 = <__A as MapAccess<'_>>::next_key::<_IMPL_DESERIALIZE_FOR_DBData::<impl Deserialize<'de> for DBData>::deserialize::__Field>(_6) -> [return: bb2, unwind: bb50];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _9 = move ((_5 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _9);
        goto -> bb47;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_5 as Ok).0: std::option::Option<db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field>);
        _10 = discriminant(_8);
        switchInt(move _10) -> [1: bb7, otherwise: bb6];
    }

    bb6: {
        _36 = discriminant(_3);
        switchInt(move _36) -> [0: bb29, 1: bb30, otherwise: bb4];
    }

    bb7: {
        _11 = move ((_8 as Some).0: db::_IMPL_DESERIALIZE_FOR_DBData::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for db::DBData>::deserialize::__Field);
        _12 = discriminant(_11);
        switchInt(move _12) -> [0: bb9, 1: bb17, otherwise: bb8];
    }

    bb8: {
        _32 = &mut _2;
        _31 = <__A as MapAccess<'_>>::next_value::<IgnoredAny>(_32) -> [return: bb27, unwind: bb50];
    }

    bb9: {
        _14 = &_3;
        _13 = std::option::Option::<i32>::is_some(_14) -> [return: bb10, unwind: bb50];
    }

    bb10: {
        switchInt(move _13) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _15 = <<__A as MapAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::duplicate_field(const "version") -> [return: bb12, unwind: bb50];
    }

    bb12: {
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _15);
        goto -> bb47;
    }

    bb13: {
        _18 = &mut _2;
        _17 = <__A as MapAccess<'_>>::next_value::<i32>(_18) -> [return: bb14, unwind: bb50];
    }

    bb14: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb16, 1: bb15, otherwise: bb4];
    }

    bb15: {
        _21 = move ((_17 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _21);
        goto -> bb47;
    }

    bb16: {
        _20 = ((_17 as Ok).0: i32);
        _16 = std::option::Option::<i32>::Some(_20);
        _3 = move _16;
        goto -> bb1;
    }

    bb17: {
        _23 = &_4;
        _22 = std::option::Option::<Vec<Dir>>::is_some(_23) -> [return: bb18, unwind: bb50];
    }

    bb18: {
        switchInt(move _22) -> [0: bb21, otherwise: bb19];
    }

    bb19: {
        _24 = <<__A as MapAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::duplicate_field(const "dirs") -> [return: bb20, unwind: bb50];
    }

    bb20: {
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _24);
        goto -> bb47;
    }

    bb21: {
        _27 = &mut _2;
        _26 = <__A as MapAccess<'_>>::next_value::<Vec<Dir>>(_27) -> [return: bb22, unwind: bb50];
    }

    bb22: {
        _28 = discriminant(_26);
        switchInt(move _28) -> [0: bb24, 1: bb23, otherwise: bb4];
    }

    bb23: {
        _30 = move ((_26 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _30);
        goto -> bb47;
    }

    bb24: {
        _29 = move ((_26 as Ok).0: std::vec::Vec<dir::Dir>);
        _25 = std::option::Option::<Vec<Dir>>::Some(move _29);
        drop(_4) -> [return: bb25, unwind: bb26];
    }

    bb25: {
        _52 = const true;
        _4 = move _25;
        goto -> bb1;
    }

    bb26 (cleanup): {
        _52 = const true;
        _4 = move _25;
        goto -> bb50;
    }

    bb27: {
        _33 = discriminant(_31);
        switchInt(move _33) -> [0: bb1, 1: bb28, otherwise: bb4];
    }

    bb28: {
        _34 = move ((_31 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _34);
        goto -> bb47;
    }

    bb29: {
        _38 = _IMPL_DESERIALIZE_FOR_DBData::_serde::private::de::missing_field::<'_, i32, <__A as MapAccess<'_>>::Error>(const "version") -> [return: bb31, unwind: bb50];
    }

    bb30: {
        _37 = ((_3 as Some).0: i32);
        _35 = _37;
        goto -> bb34;
    }

    bb31: {
        _39 = discriminant(_38);
        switchInt(move _39) -> [0: bb33, 1: bb32, otherwise: bb4];
    }

    bb32: {
        _41 = move ((_38 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _41);
        goto -> bb47;
    }

    bb33: {
        _40 = ((_38 as Ok).0: i32);
        _35 = _40;
        goto -> bb34;
    }

    bb34: {
        _43 = discriminant(_4);
        switchInt(move _43) -> [0: bb35, 1: bb36, otherwise: bb4];
    }

    bb35: {
        _45 = _IMPL_DESERIALIZE_FOR_DBData::_serde::private::de::missing_field::<'_, Vec<Dir>, <__A as MapAccess<'_>>::Error>(const "dirs") -> [return: bb37, unwind: bb50];
    }

    bb36: {
        _52 = const false;
        _44 = move ((_4 as Some).0: std::vec::Vec<dir::Dir>);
        _42 = move _44;
        goto -> bb40;
    }

    bb37: {
        _46 = discriminant(_45);
        switchInt(move _46) -> [0: bb39, 1: bb38, otherwise: bb4];
    }

    bb38: {
        _48 = move ((_45 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Err(move _48);
        goto -> bb47;
    }

    bb39: {
        _47 = move ((_45 as Ok).0: std::vec::Vec<dir::Dir>);
        _42 = move _47;
        goto -> bb40;
    }

    bb40: {
        _50 = _35;
        _51 = move _42;
        _49 = DBData { version: move _50, dirs: move _51 };
        _0 = Result::<DBData, <__A as MapAccess<'_>>::Error>::Ok(move _49);
        _52 = const false;
        drop(_2) -> [return: bb41, unwind continue];
    }

    bb41: {
        return;
    }

    bb42 (cleanup): {
        drop(_2) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        resume;
    }

    bb44: {
        _52 = const false;
        drop(_2) -> [return: bb41, unwind continue];
    }

    bb45: {
        switchInt(_52) -> [0: bb44, otherwise: bb46];
    }

    bb46: {
        drop(((_4 as Some).0: std::vec::Vec<dir::Dir>)) -> [return: bb44, unwind: bb42];
    }

    bb47: {
        _53 = discriminant(_4);
        switchInt(move _53) -> [1: bb45, otherwise: bb44];
    }

    bb48 (cleanup): {
        switchInt(_52) -> [0: bb42, otherwise: bb49];
    }

    bb49 (cleanup): {
        drop(((_4 as Some).0: std::vec::Vec<dir::Dir>)) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        _54 = discriminant(_4);
        switchInt(move _54) -> [1: bb48, otherwise: bb42];
    }
}

const _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::FIELDS: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 2];
    let _2: &[&str; 2];
    let _3: [&str; 2];
    let mut _4: &[&str; 2];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_DBData::<impl at src/db.rs:292:17: 292:28>::deserialize::FIELDS: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "version", const "dirs"];
        _0 = &_1;
        return;
    }
}

const _IMPL_SERIALIZE_FOR_DBData: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn _IMPL_SERIALIZE_FOR_DBData::<impl at src/db.rs:292:30: 292:39>::serialize(_1: &DBData, _2: __S) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error> {
    debug self => _1;
    debug __serializer => _2;
    let mut _0: std::result::Result<<__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Ok, <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _3: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let mut _4: std::result::Result<<__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct, <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _5: __S;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: (usize, bool);
    let mut _10: (usize, bool);
    let mut _11: isize;
    let _12: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _13: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
    let mut _14: std::result::Result<(), <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _15: &mut <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _16: &i32;
    let mut _17: isize;
    let mut _19: std::result::Result<(), <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _20: &mut <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _21: &std::vec::Vec<dir::Dir>;
    let mut _22: isize;
    let mut _24: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let mut _25: bool;
    let mut _26: bool;
    scope 1 {
        debug __serde_state => _3;
        let _18: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
        let _23: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
        scope 4 {
            debug __val => const ();
        }
        scope 5 {
            debug __err => _18;
        }
        scope 6 {
            debug __val => const ();
        }
        scope 7 {
            debug __err => _23;
        }
    }
    scope 2 {
        debug __val => _12;
    }
    scope 3 {
        debug __err => _13;
    }

    bb0: {
        _25 = const false;
        _26 = const false;
        _26 = const true;
        _5 = move _2;
        _8 = const false as usize (IntToInt);
        _9 = CheckedAdd(_8, const 1_usize);
        assert(!move (_9.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 1_usize) -> [success: bb1, unwind: bb21];
    }

    bb1: {
        _7 = move (_9.0: usize);
        _10 = CheckedAdd(_7, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _7, const 1_usize) -> [success: bb2, unwind: bb21];
    }

    bb2: {
        _6 = move (_10.0: usize);
        _26 = const false;
        _4 = <__S as Serializer>::serialize_struct(move _5, const "DBData", move _6) -> [return: bb3, unwind: bb21];
    }

    bb3: {
        _26 = const false;
        _11 = discriminant(_4);
        switchInt(move _11) -> [0: bb6, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _13 = move ((_4 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _13);
        goto -> bb15;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _12 = move ((_4 as Ok).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct);
        _25 = const true;
        _3 = move _12;
        _15 = &mut _3;
        _16 = &((*_1).0: i32);
        _14 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::serialize_field::<i32>(_15, const "version", _16) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _17 = discriminant(_14);
        switchInt(move _17) -> [0: bb9, 1: bb8, otherwise: bb5];
    }

    bb8: {
        _18 = move ((_14 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _18);
        goto -> bb14;
    }

    bb9: {
        _20 = &mut _3;
        _21 = &((*_1).1: std::vec::Vec<dir::Dir>);
        _19 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::serialize_field::<Vec<Dir>>(_20, const "dirs", _21) -> [return: bb10, unwind: bb19];
    }

    bb10: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [0: bb12, 1: bb11, otherwise: bb5];
    }

    bb11: {
        _23 = move ((_19 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _23);
        goto -> bb14;
    }

    bb12: {
        _25 = const false;
        _24 = move _3;
        _0 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::end(move _24) -> [return: bb13, unwind: bb19];
    }

    bb13: {
        _25 = const false;
        goto -> bb16;
    }

    bb14: {
        drop(_3) -> [return: bb15, unwind continue];
    }

    bb15: {
        _25 = const false;
        goto -> bb16;
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        resume;
    }

    bb18 (cleanup): {
        drop(_3) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_25) -> [0: bb17, otherwise: bb18];
    }

    bb20 (cleanup): {
        drop(_5) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        switchInt(_26) -> [0: bb17, otherwise: bb20];
    }
}

fn db::<impl at src/db.rs:298:1: 298:24>::default() -> DBData {
    let mut _0: db::DBData;
    let mut _1: std::vec::Vec<dir::Dir>;

    bb0: {
        _1 = Vec::<Dir>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = DBData { version: const _, dirs: move _1 };
        return;
    }
}

fn dir::<impl at src/dir.rs:7:10: 7:15>::clone(_1: &Dir) -> Dir {
    debug self => _1;
    let mut _0: dir::Dir;
    let mut _2: std::path::PathBuf;
    let _3: &std::path::PathBuf;
    let mut _4: f64;
    let _5: &f64;
    let mut _6: i64;
    let _7: &i64;

    bb0: {
        _3 = &((*_1).0: std::path::PathBuf);
        _2 = <PathBuf as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: f64);
        _4 = (*_5);
        _7 = &((*_1).2: i64);
        _6 = (*_7);
        _0 = Dir { path: move _2, rank: move _4, last_accessed: move _6 };
        return;
    }
}

fn dir::<impl at src/dir.rs:7:17: 7:22>::fmt(_1: &Dir, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::path::PathBuf;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &f64;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&i64;
    let _13: &i64;

    bb0: {
        _3 = const "Dir";
        _4 = const "path";
        _6 = &((*_1).0: std::path::PathBuf);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "rank";
        _9 = &((*_1).1: f64);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "last_accessed";
        _13 = &((*_1).2: i64);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn dir::<impl at src/dir.rs:7:24: 7:31>::default() -> Dir {
    let mut _0: dir::Dir;
    let mut _1: std::path::PathBuf;
    let mut _2: f64;
    let mut _3: i64;

    bb0: {
        _1 = <PathBuf as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <f64 as Default>::default() -> [return: bb2, unwind: bb4];
    }

    bb2: {
        _3 = <i64 as Default>::default() -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = Dir { path: move _1, rank: move _2, last_accessed: move _3 };
        return;
    }

    bb4 (cleanup): {
        drop(_1) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

const _IMPL_DESERIALIZE_FOR_Dir: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize(_1: __D) -> Result<Dir, <__D as Deserializer<'_>>::Error> {
    debug __deserializer => _1;
    let mut _0: std::result::Result<dir::Dir, <__D as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserializer<'_>>::Error>;

    bb0: {
        _0 = <__D as Deserializer<'_>>::deserialize_struct::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor<'_>>(move _1, const "Dir", const _, const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<Dir>, lifetime: PhantomData::<&()> }}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::expecting(_1: &_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug __formatter => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "field identifier";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_u64(_1: _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor, _2: u64) -> Result<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field, __E>;
    let mut _3: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _4: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _5: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _6: __E;
    let mut _7: db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Unexpected<'_>;
    let mut _8: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _9: &&str;

    bb0: {
        switchInt(_2) -> [0: bb2, 1: bb3, 2: bb4, otherwise: bb1];
    }

    bb1: {
        _7 = Unexpected::<'_>::Unsigned(_2);
        _9 = const _;
        _8 = _9 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _6 = <__E as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_value(move _7, move _8) -> [return: bb5, unwind continue];
    }

    bb2: {
        _3 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _3);
        goto -> bb6;
    }

    bb3: {
        _4 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _4);
        goto -> bb6;
    }

    bb4: {
        _5 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field2;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _5);
        goto -> bb6;
    }

    bb5: {
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Err(move _6);
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_u64: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "field index 0 <= i < 3";
        _0 = &_1;
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_str(_1: _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor, _2: &str) -> Result<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field, __E>;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _7: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _8: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _9: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;

    bb0: {
        _5 = <str as PartialEq>::eq(_2, const "path") -> [return: bb9, unwind continue];
    }

    bb1: {
        _6 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _6);
        goto -> bb10;
    }

    bb2: {
        _4 = <str as PartialEq>::eq(_2, const "rank") -> [return: bb8, unwind continue];
    }

    bb3: {
        _7 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _7);
        goto -> bb10;
    }

    bb4: {
        _3 = <str as PartialEq>::eq(_2, const "last_accessed") -> [return: bb7, unwind continue];
    }

    bb5: {
        _8 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field2;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _8);
        goto -> bb10;
    }

    bb6: {
        _9 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__ignore;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _9);
        goto -> bb10;
    }

    bb7: {
        switchInt(move _3) -> [0: bb6, otherwise: bb5];
    }

    bb8: {
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb9: {
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb10: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_bytes(_1: _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor, _2: &[u8]) -> Result<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E> {
    debug self => const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor;
    debug __value => _2;
    let mut _0: std::result::Result<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field, __E>;
    let mut _3: usize;
    let mut _4: usize;
    let mut _5: bool;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: bool;
    let mut _9: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _10: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _11: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
    let mut _12: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;

    bb0: {
        _6 = Len((*_2));
        _7 = const 4_usize;
        _8 = Eq(move _6, move _7);
        switchInt(move _8) -> [0: bb9, otherwise: bb1];
    }

    bb1: {
        switchInt((*_2)[0 of 4]) -> [112: bb2, 114: bb6, otherwise: bb5];
    }

    bb2: {
        switchInt((*_2)[1 of 4]) -> [97: bb3, otherwise: bb5];
    }

    bb3: {
        switchInt((*_2)[2 of 4]) -> [116: bb4, otherwise: bb5];
    }

    bb4: {
        switchInt((*_2)[3 of 4]) -> [104: bb23, otherwise: bb5];
    }

    bb5: {
        _12 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__ignore;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _12);
        goto -> bb26;
    }

    bb6: {
        switchInt((*_2)[1 of 4]) -> [97: bb7, otherwise: bb5];
    }

    bb7: {
        switchInt((*_2)[2 of 4]) -> [110: bb8, otherwise: bb5];
    }

    bb8: {
        switchInt((*_2)[3 of 4]) -> [107: bb24, otherwise: bb5];
    }

    bb9: {
        _3 = Len((*_2));
        _4 = const 13_usize;
        _5 = Eq(move _3, move _4);
        switchInt(move _5) -> [0: bb5, otherwise: bb10];
    }

    bb10: {
        switchInt((*_2)[0 of 13]) -> [108: bb11, otherwise: bb5];
    }

    bb11: {
        switchInt((*_2)[1 of 13]) -> [97: bb12, otherwise: bb5];
    }

    bb12: {
        switchInt((*_2)[2 of 13]) -> [115: bb13, otherwise: bb5];
    }

    bb13: {
        switchInt((*_2)[3 of 13]) -> [116: bb14, otherwise: bb5];
    }

    bb14: {
        switchInt((*_2)[4 of 13]) -> [95: bb15, otherwise: bb5];
    }

    bb15: {
        switchInt((*_2)[5 of 13]) -> [97: bb16, otherwise: bb5];
    }

    bb16: {
        switchInt((*_2)[6 of 13]) -> [99: bb17, otherwise: bb5];
    }

    bb17: {
        switchInt((*_2)[7 of 13]) -> [99: bb18, otherwise: bb5];
    }

    bb18: {
        switchInt((*_2)[8 of 13]) -> [101: bb19, otherwise: bb5];
    }

    bb19: {
        switchInt((*_2)[9 of 13]) -> [115: bb20, otherwise: bb5];
    }

    bb20: {
        switchInt((*_2)[10 of 13]) -> [115: bb21, otherwise: bb5];
    }

    bb21: {
        switchInt((*_2)[11 of 13]) -> [101: bb22, otherwise: bb5];
    }

    bb22: {
        switchInt((*_2)[12 of 13]) -> [100: bb25, otherwise: bb5];
    }

    bb23: {
        _9 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field0;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _9);
        goto -> bb26;
    }

    bb24: {
        _10 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field1;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _10);
        goto -> bb26;
    }

    bb25: {
        _11 = _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field::__field2;
        _0 = Result::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, __E>::Ok(move _11);
        goto -> bb26;
    }

    bb26: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::deserialize(_1: __D) -> Result<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field, <__D as Deserializer<'_>>::Error> {
    debug __deserializer => _1;
    let mut _0: std::result::Result<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field, <__D as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserializer<'_>>::Error>;

    bb0: {
        _0 = <__D as Deserializer<'_>>::deserialize_identifier::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor>(move _1, const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__FieldVisitor) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::expecting(_1: &_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor<'_>, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug __formatter => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;

    bb0: {
        _3 = const "struct Dir";
        _0 = Formatter::<'_>::write_str(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_seq(_1: _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor<'_>, _2: __A) -> Result<Dir, <__A as SeqAccess<'_>>::Error> {
    debug self => const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<Dir>, lifetime: PhantomData::<&()> }};
    debug __seq => _2;
    let mut _0: std::result::Result<dir::Dir, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let _3: std::path::PathBuf;
    let mut _4: std::result::Result<std::option::Option<std::path::PathBuf>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _5: &mut __A;
    let mut _6: isize;
    let _7: std::option::Option<std::path::PathBuf>;
    let _8: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _9: isize;
    let _10: std::path::PathBuf;
    let mut _11: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _12: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _13: std::result::Result<std::option::Option<f64>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _14: &mut __A;
    let mut _15: isize;
    let mut _18: isize;
    let mut _20: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _21: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _22: std::result::Result<std::option::Option<i64>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error>;
    let mut _23: &mut __A;
    let mut _24: isize;
    let mut _27: isize;
    let mut _29: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
    let mut _30: &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected;
    let mut _31: dir::Dir;
    let mut _32: std::path::PathBuf;
    let mut _33: &&str;
    scope 1 {
        debug __field0 => _3;
        let _16: std::option::Option<f64>;
        let _17: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
        let _19: f64;
        let mut _34: &&str;
        scope 5 {
            debug __field1 => _19;
            let _25: std::option::Option<i64>;
            let _26: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error;
            let _28: i64;
            let mut _35: &&str;
            scope 9 {
                debug __field2 => _28;
            }
            scope 10 {
                debug __val => _25;
            }
            scope 11 {
                debug __err => _26;
            }
            scope 12 {
                debug __value => _28;
            }
        }
        scope 6 {
            debug __val => _16;
        }
        scope 7 {
            debug __err => _17;
        }
        scope 8 {
            debug __value => _19;
        }
    }
    scope 2 {
        debug __val => _7;
    }
    scope 3 {
        debug __err => _8;
    }
    scope 4 {
        debug __value => _10;
    }

    bb0: {
        _5 = &mut _2;
        _4 = <__A as SeqAccess<'_>>::next_element::<PathBuf>(_5) -> [return: bb1, unwind: bb24];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _8 = move ((_4 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _8);
        goto -> bb21;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _7 = move ((_4 as Ok).0: std::option::Option<std::path::PathBuf>);
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb5, 1: bb6, otherwise: bb3];
    }

    bb5: {
        _33 = const _;
        _12 = _33 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _11 = <<__A as SeqAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_length(const 0_usize, move _12) -> [return: bb7, unwind: bb24];
    }

    bb6: {
        _10 = move ((_7 as Some).0: std::path::PathBuf);
        _3 = move _10;
        _14 = &mut _2;
        _13 = <__A as SeqAccess<'_>>::next_element::<f64>(_14) -> [return: bb8, unwind: bb23];
    }

    bb7: {
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _11);
        goto -> bb21;
    }

    bb8: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb10, 1: bb9, otherwise: bb3];
    }

    bb9: {
        _17 = move ((_13 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _17);
        goto -> bb20;
    }

    bb10: {
        _16 = ((_13 as Ok).0: std::option::Option<f64>);
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb11, 1: bb12, otherwise: bb3];
    }

    bb11: {
        _34 = const _;
        _21 = _34 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _20 = <<__A as SeqAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_length(const 1_usize, move _21) -> [return: bb13, unwind: bb23];
    }

    bb12: {
        _19 = ((_16 as Some).0: f64);
        _23 = &mut _2;
        _22 = <__A as SeqAccess<'_>>::next_element::<i64>(_23) -> [return: bb14, unwind: bb23];
    }

    bb13: {
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _20);
        goto -> bb20;
    }

    bb14: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [0: bb16, 1: bb15, otherwise: bb3];
    }

    bb15: {
        _26 = move ((_22 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::SeqAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _26);
        goto -> bb20;
    }

    bb16: {
        _25 = ((_22 as Ok).0: std::option::Option<i64>);
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb17, 1: bb18, otherwise: bb3];
    }

    bb17: {
        _35 = const _;
        _30 = _35 as &dyn db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::Expected (PointerCoercion(Unsize));
        _29 = <<__A as SeqAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::invalid_length(const 2_usize, move _30) -> [return: bb19, unwind: bb23];
    }

    bb18: {
        _28 = ((_25 as Some).0: i64);
        _32 = move _3;
        _31 = Dir { path: move _32, rank: _19, last_accessed: _28 };
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Ok(move _31);
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb19: {
        _0 = Result::<Dir, <__A as SeqAccess<'_>>::Error>::Err(move _29);
        goto -> bb20;
    }

    bb20: {
        drop(_3) -> [return: bb21, unwind: bb24];
    }

    bb21: {
        drop(_2) -> [return: bb22, unwind continue];
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        drop(_3) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_seq: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "struct Dir with 3 elements";
        _0 = &_1;
        return;
    }
}

promoted[1] in _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_seq: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "struct Dir with 3 elements";
        _0 = &_1;
        return;
    }
}

promoted[2] in _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_seq: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "struct Dir with 3 elements";
        _0 = &_1;
        return;
    }
}

fn _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::<impl at src/dir.rs:7:33: 7:44>::visit_map(_1: _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor<'_>, _2: __A) -> Result<Dir, <__A as MapAccess<'_>>::Error> {
    debug self => const _IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Visitor::<'_> {{ marker: PhantomData::<Dir>, lifetime: PhantomData::<&()> }};
    debug __map => _2;
    let mut _0: std::result::Result<dir::Dir, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _3: std::option::Option<std::path::PathBuf>;
    let mut _6: std::result::Result<std::option::Option<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field>, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _7: &mut __A;
    let mut _8: isize;
    let mut _11: isize;
    let mut _13: isize;
    let mut _14: bool;
    let _15: &std::option::Option<std::path::PathBuf>;
    let mut _16: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
    let mut _17: std::option::Option<std::path::PathBuf>;
    let mut _18: std::result::Result<std::path::PathBuf, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _19: &mut __A;
    let mut _20: isize;
    let mut _23: bool;
    let _24: &std::option::Option<f64>;
    let mut _25: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
    let mut _26: std::option::Option<f64>;
    let mut _27: std::result::Result<f64, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _28: &mut __A;
    let mut _29: isize;
    let mut _32: bool;
    let _33: &std::option::Option<i64>;
    let mut _34: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
    let mut _35: std::option::Option<i64>;
    let mut _36: std::result::Result<i64, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _37: &mut __A;
    let mut _38: isize;
    let mut _41: std::result::Result<db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::IgnoredAny, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _42: &mut __A;
    let mut _43: isize;
    let mut _46: isize;
    let mut _48: std::result::Result<std::path::PathBuf, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _49: isize;
    let mut _53: isize;
    let mut _55: std::result::Result<f64, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _56: isize;
    let mut _60: isize;
    let mut _62: std::result::Result<i64, <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error>;
    let mut _63: isize;
    let mut _66: dir::Dir;
    let mut _67: std::path::PathBuf;
    let mut _68: f64;
    let mut _69: i64;
    let mut _70: bool;
    let mut _71: isize;
    let mut _72: isize;
    scope 1 {
        debug __field0 => _3;
        let mut _4: std::option::Option<f64>;
        scope 2 {
            debug __field1 => _4;
            let mut _5: std::option::Option<i64>;
            scope 3 {
                debug __field2 => _5;
                let _45: std::path::PathBuf;
                let _47: std::path::PathBuf;
                let _50: std::path::PathBuf;
                let _51: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                scope 4 {
                    debug __key => _12;
                    let _9: std::option::Option<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field>;
                    let _10: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    let _12: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field;
                    let _21: std::path::PathBuf;
                    let _22: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    let _30: f64;
                    let _31: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    let _39: i64;
                    let _40: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    let _44: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    scope 5 {
                        debug __val => _9;
                    }
                    scope 6 {
                        debug __err => _10;
                    }
                    scope 7 {
                        debug __val => _21;
                    }
                    scope 8 {
                        debug __err => _22;
                    }
                    scope 9 {
                        debug __val => _30;
                    }
                    scope 10 {
                        debug __err => _31;
                    }
                    scope 11 {
                        debug __val => _39;
                    }
                    scope 12 {
                        debug __err => _40;
                    }
                    scope 13 {
                    }
                    scope 14 {
                        debug __val => const IgnoredAny;
                    }
                    scope 15 {
                        debug __err => _44;
                    }
                }
                scope 16 {
                    debug __field0 => _45;
                    let _52: f64;
                    let _54: f64;
                    let _57: f64;
                    let _58: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                    scope 20 {
                        debug __field1 => _52;
                        let _59: i64;
                        let _61: i64;
                        let _64: i64;
                        let _65: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error;
                        scope 24 {
                            debug __field2 => _59;
                        }
                        scope 25 {
                            debug __field2 => _61;
                        }
                        scope 26 {
                            debug __val => _64;
                        }
                        scope 27 {
                            debug __err => _65;
                        }
                    }
                    scope 21 {
                        debug __field1 => _54;
                    }
                    scope 22 {
                        debug __val => _57;
                    }
                    scope 23 {
                        debug __err => _58;
                    }
                }
                scope 17 {
                    debug __field0 => _47;
                }
                scope 18 {
                    debug __val => _50;
                }
                scope 19 {
                    debug __err => _51;
                }
            }
        }
    }

    bb0: {
        _70 = const false;
        _70 = const true;
        _3 = std::option::Option::<PathBuf>::None;
        _4 = std::option::Option::<f64>::None;
        _5 = std::option::Option::<i64>::None;
        goto -> bb1;
    }

    bb1: {
        _7 = &mut _2;
        _6 = <__A as MapAccess<'_>>::next_key::<_IMPL_DESERIALIZE_FOR_Dir::<impl Deserialize<'de> for Dir>::deserialize::__Field>(_7) -> [return: bb2, unwind: bb66];
    }

    bb2: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _10 = move ((_6 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _10);
        goto -> bb56;
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = move ((_6 as Ok).0: std::option::Option<dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field>);
        _11 = discriminant(_9);
        switchInt(move _11) -> [1: bb7, otherwise: bb6];
    }

    bb6: {
        _46 = discriminant(_3);
        switchInt(move _46) -> [0: bb37, 1: bb38, otherwise: bb4];
    }

    bb7: {
        _12 = move ((_9 as Some).0: dir::_IMPL_DESERIALIZE_FOR_Dir::<impl db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Deserialize<'de> for dir::Dir>::deserialize::__Field);
        _13 = discriminant(_12);
        switchInt(move _13) -> [0: bb9, 1: bb19, 2: bb27, otherwise: bb8];
    }

    bb8: {
        _42 = &mut _2;
        _41 = <__A as MapAccess<'_>>::next_value::<IgnoredAny>(_42) -> [return: bb35, unwind: bb66];
    }

    bb9: {
        _15 = &_3;
        _14 = std::option::Option::<PathBuf>::is_some(_15) -> [return: bb10, unwind: bb66];
    }

    bb10: {
        switchInt(move _14) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _16 = <<__A as MapAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::duplicate_field(const "path") -> [return: bb12, unwind: bb66];
    }

    bb12: {
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _16);
        goto -> bb56;
    }

    bb13: {
        _19 = &mut _2;
        _18 = <__A as MapAccess<'_>>::next_value::<PathBuf>(_19) -> [return: bb14, unwind: bb66];
    }

    bb14: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb16, 1: bb15, otherwise: bb4];
    }

    bb15: {
        _22 = move ((_18 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _22);
        goto -> bb56;
    }

    bb16: {
        _21 = move ((_18 as Ok).0: std::path::PathBuf);
        _17 = std::option::Option::<PathBuf>::Some(move _21);
        drop(_3) -> [return: bb17, unwind: bb18];
    }

    bb17: {
        _70 = const true;
        _3 = move _17;
        goto -> bb1;
    }

    bb18 (cleanup): {
        _70 = const true;
        _3 = move _17;
        goto -> bb66;
    }

    bb19: {
        _24 = &_4;
        _23 = std::option::Option::<f64>::is_some(_24) -> [return: bb20, unwind: bb66];
    }

    bb20: {
        switchInt(move _23) -> [0: bb23, otherwise: bb21];
    }

    bb21: {
        _25 = <<__A as MapAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::duplicate_field(const "rank") -> [return: bb22, unwind: bb66];
    }

    bb22: {
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _25);
        goto -> bb56;
    }

    bb23: {
        _28 = &mut _2;
        _27 = <__A as MapAccess<'_>>::next_value::<f64>(_28) -> [return: bb24, unwind: bb66];
    }

    bb24: {
        _29 = discriminant(_27);
        switchInt(move _29) -> [0: bb26, 1: bb25, otherwise: bb4];
    }

    bb25: {
        _31 = move ((_27 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _31);
        goto -> bb56;
    }

    bb26: {
        _30 = ((_27 as Ok).0: f64);
        _26 = std::option::Option::<f64>::Some(_30);
        _4 = move _26;
        goto -> bb1;
    }

    bb27: {
        _33 = &_5;
        _32 = std::option::Option::<i64>::is_some(_33) -> [return: bb28, unwind: bb66];
    }

    bb28: {
        switchInt(move _32) -> [0: bb31, otherwise: bb29];
    }

    bb29: {
        _34 = <<__A as MapAccess<'_>>::Error as _IMPL_DESERIALIZE_FOR_DBData::_serde::de::Error>::duplicate_field(const "last_accessed") -> [return: bb30, unwind: bb66];
    }

    bb30: {
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _34);
        goto -> bb56;
    }

    bb31: {
        _37 = &mut _2;
        _36 = <__A as MapAccess<'_>>::next_value::<i64>(_37) -> [return: bb32, unwind: bb66];
    }

    bb32: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb34, 1: bb33, otherwise: bb4];
    }

    bb33: {
        _40 = move ((_36 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _40);
        goto -> bb56;
    }

    bb34: {
        _39 = ((_36 as Ok).0: i64);
        _35 = std::option::Option::<i64>::Some(_39);
        _5 = move _35;
        goto -> bb1;
    }

    bb35: {
        _43 = discriminant(_41);
        switchInt(move _43) -> [0: bb1, 1: bb36, otherwise: bb4];
    }

    bb36: {
        _44 = move ((_41 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _44);
        goto -> bb56;
    }

    bb37: {
        _48 = _IMPL_DESERIALIZE_FOR_DBData::_serde::private::de::missing_field::<'_, PathBuf, <__A as MapAccess<'_>>::Error>(const "path") -> [return: bb39, unwind: bb66];
    }

    bb38: {
        _70 = const false;
        _47 = move ((_3 as Some).0: std::path::PathBuf);
        _45 = move _47;
        goto -> bb42;
    }

    bb39: {
        _49 = discriminant(_48);
        switchInt(move _49) -> [0: bb41, 1: bb40, otherwise: bb4];
    }

    bb40: {
        _51 = move ((_48 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _51);
        goto -> bb56;
    }

    bb41: {
        _50 = move ((_48 as Ok).0: std::path::PathBuf);
        _45 = move _50;
        goto -> bb42;
    }

    bb42: {
        _53 = discriminant(_4);
        switchInt(move _53) -> [0: bb43, 1: bb44, otherwise: bb4];
    }

    bb43: {
        _55 = _IMPL_DESERIALIZE_FOR_DBData::_serde::private::de::missing_field::<'_, f64, <__A as MapAccess<'_>>::Error>(const "rank") -> [return: bb45, unwind: bb58];
    }

    bb44: {
        _54 = ((_4 as Some).0: f64);
        _52 = _54;
        goto -> bb48;
    }

    bb45: {
        _56 = discriminant(_55);
        switchInt(move _56) -> [0: bb47, 1: bb46, otherwise: bb4];
    }

    bb46: {
        _58 = move ((_55 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _58);
        goto -> bb55;
    }

    bb47: {
        _57 = ((_55 as Ok).0: f64);
        _52 = _57;
        goto -> bb48;
    }

    bb48: {
        _60 = discriminant(_5);
        switchInt(move _60) -> [0: bb49, 1: bb50, otherwise: bb4];
    }

    bb49: {
        _62 = _IMPL_DESERIALIZE_FOR_DBData::_serde::private::de::missing_field::<'_, i64, <__A as MapAccess<'_>>::Error>(const "last_accessed") -> [return: bb51, unwind: bb58];
    }

    bb50: {
        _61 = ((_5 as Some).0: i64);
        _59 = _61;
        goto -> bb54;
    }

    bb51: {
        _63 = discriminant(_62);
        switchInt(move _63) -> [0: bb53, 1: bb52, otherwise: bb4];
    }

    bb52: {
        _65 = move ((_62 as Err).0: <__A as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::de::MapAccess<'_>>::Error);
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Err(move _65);
        goto -> bb55;
    }

    bb53: {
        _64 = ((_62 as Ok).0: i64);
        _59 = _64;
        goto -> bb54;
    }

    bb54: {
        _67 = move _45;
        _68 = _52;
        _69 = _59;
        _66 = Dir { path: move _67, rank: move _68, last_accessed: move _69 };
        _0 = Result::<Dir, <__A as MapAccess<'_>>::Error>::Ok(move _66);
        _70 = const false;
        drop(_2) -> [return: bb57, unwind continue];
    }

    bb55: {
        drop(_45) -> [return: bb56, unwind: bb66];
    }

    bb56: {
        _71 = discriminant(_3);
        switchInt(move _71) -> [1: bb62, otherwise: bb61];
    }

    bb57: {
        return;
    }

    bb58 (cleanup): {
        drop(_45) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_2) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        resume;
    }

    bb61: {
        _70 = const false;
        drop(_2) -> [return: bb57, unwind continue];
    }

    bb62: {
        switchInt(_70) -> [0: bb61, otherwise: bb63];
    }

    bb63: {
        drop(((_3 as Some).0: std::path::PathBuf)) -> [return: bb61, unwind: bb59];
    }

    bb64 (cleanup): {
        switchInt(_70) -> [0: bb59, otherwise: bb65];
    }

    bb65 (cleanup): {
        drop(((_3 as Some).0: std::path::PathBuf)) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        _72 = discriminant(_3);
        switchInt(move _72) -> [1: bb64, otherwise: bb59];
    }
}

const _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::FIELDS: &[&str] = {
    let mut _0: &[&str];
    let mut _1: &[&str; 3];
    let _2: &[&str; 3];
    let _3: [&str; 3];
    let mut _4: &[&str; 3];

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _4 = const _;
        _2 = &(*_4);
        _1 = &(*_2);
        _0 = move _1 as &[&str] (PointerCoercion(Unsize));
        StorageDead(_2);
        StorageDead(_1);
        return;
    }
}

promoted[0] in _IMPL_DESERIALIZE_FOR_Dir::<impl at src/dir.rs:7:33: 7:44>::deserialize::FIELDS: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "path", const "rank", const "last_accessed"];
        _0 = &_1;
        return;
    }
}

const _IMPL_SERIALIZE_FOR_Dir: () = {
    let mut _0: ();

    bb0: {
        _0 = const ();
        return;
    }
}

fn _IMPL_SERIALIZE_FOR_Dir::<impl at src/dir.rs:7:46: 7:55>::serialize(_1: &Dir, _2: __S) -> Result<<__S as Serializer>::Ok, <__S as Serializer>::Error> {
    debug self => _1;
    debug __serializer => _2;
    let mut _0: std::result::Result<<__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Ok, <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _3: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let mut _4: std::result::Result<<__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct, <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _5: __S;
    let mut _6: usize;
    let mut _7: usize;
    let mut _8: usize;
    let mut _9: usize;
    let mut _10: (usize, bool);
    let mut _11: (usize, bool);
    let mut _12: (usize, bool);
    let mut _13: isize;
    let _14: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _15: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
    let mut _16: std::result::Result<(), <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _17: &mut <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _18: &std::path::PathBuf;
    let mut _19: isize;
    let mut _21: std::result::Result<(), <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _22: &mut <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _23: &f64;
    let mut _24: isize;
    let mut _26: std::result::Result<(), <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error>;
    let mut _27: &mut <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let _28: &i64;
    let mut _29: isize;
    let mut _31: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct;
    let mut _32: bool;
    let mut _33: bool;
    scope 1 {
        debug __serde_state => _3;
        let _20: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
        let _25: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
        let _30: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error;
        scope 4 {
            debug __val => const ();
        }
        scope 5 {
            debug __err => _20;
        }
        scope 6 {
            debug __val => const ();
        }
        scope 7 {
            debug __err => _25;
        }
        scope 8 {
            debug __val => const ();
        }
        scope 9 {
            debug __err => _30;
        }
    }
    scope 2 {
        debug __val => _14;
    }
    scope 3 {
        debug __err => _15;
    }

    bb0: {
        _32 = const false;
        _33 = const false;
        _33 = const true;
        _5 = move _2;
        _9 = const false as usize (IntToInt);
        _10 = CheckedAdd(_9, const 1_usize);
        assert(!move (_10.1: bool), "attempt to compute `{} + {}`, which would overflow", move _9, const 1_usize) -> [success: bb1, unwind: bb25];
    }

    bb1: {
        _8 = move (_10.0: usize);
        _11 = CheckedAdd(_8, const 1_usize);
        assert(!move (_11.1: bool), "attempt to compute `{} + {}`, which would overflow", move _8, const 1_usize) -> [success: bb2, unwind: bb25];
    }

    bb2: {
        _7 = move (_11.0: usize);
        _12 = CheckedAdd(_7, const 1_usize);
        assert(!move (_12.1: bool), "attempt to compute `{} + {}`, which would overflow", move _7, const 1_usize) -> [success: bb3, unwind: bb25];
    }

    bb3: {
        _6 = move (_12.0: usize);
        _33 = const false;
        _4 = <__S as Serializer>::serialize_struct(move _5, const "Dir", move _6) -> [return: bb4, unwind: bb25];
    }

    bb4: {
        _33 = const false;
        _13 = discriminant(_4);
        switchInt(move _13) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _15 = move ((_4 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _15);
        goto -> bb19;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _14 = move ((_4 as Ok).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::SerializeStruct);
        _32 = const true;
        _3 = move _14;
        _17 = &mut _3;
        _18 = &((*_1).0: std::path::PathBuf);
        _16 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::serialize_field::<PathBuf>(_17, const "path", _18) -> [return: bb8, unwind: bb23];
    }

    bb8: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb10, 1: bb9, otherwise: bb6];
    }

    bb9: {
        _20 = move ((_16 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _20);
        goto -> bb18;
    }

    bb10: {
        _22 = &mut _3;
        _23 = &((*_1).1: f64);
        _21 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::serialize_field::<f64>(_22, const "rank", _23) -> [return: bb11, unwind: bb23];
    }

    bb11: {
        _24 = discriminant(_21);
        switchInt(move _24) -> [0: bb13, 1: bb12, otherwise: bb6];
    }

    bb12: {
        _25 = move ((_21 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _25);
        goto -> bb18;
    }

    bb13: {
        _27 = &mut _3;
        _28 = &((*_1).2: i64);
        _26 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::serialize_field::<i64>(_27, const "last_accessed", _28) -> [return: bb14, unwind: bb23];
    }

    bb14: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb16, 1: bb15, otherwise: bb6];
    }

    bb15: {
        _30 = move ((_26 as Err).0: <__S as db::_IMPL_DESERIALIZE_FOR_DBData::_serde::Serializer>::Error);
        _0 = Result::<<__S as Serializer>::Ok, <__S as Serializer>::Error>::Err(move _30);
        goto -> bb18;
    }

    bb16: {
        _32 = const false;
        _31 = move _3;
        _0 = <<__S as Serializer>::SerializeStruct as SerializeStruct>::end(move _31) -> [return: bb17, unwind: bb23];
    }

    bb17: {
        _32 = const false;
        goto -> bb20;
    }

    bb18: {
        drop(_3) -> [return: bb19, unwind continue];
    }

    bb19: {
        _32 = const false;
        goto -> bb20;
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        resume;
    }

    bb22 (cleanup): {
        drop(_3) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_32) -> [0: bb21, otherwise: bb22];
    }

    bb24 (cleanup): {
        drop(_5) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        switchInt(_33) -> [0: bb21, otherwise: bb24];
    }
}

fn dir::<impl at src/dir.rs:14:1: 14:9>::is_dir(_1: &Dir) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &std::path::Path;
    let mut _3: &std::path::PathBuf;

    bb0: {
        _3 = &((*_1).0: std::path::PathBuf);
        _2 = <PathBuf as Deref>::deref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::is_dir(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn dir::<impl at src/dir.rs:14:1: 14:9>::is_match(_1: &Dir, _2: &[std::string::String]) -> bool {
    debug self => _1;
    debug query => _2;
    let mut _0: bool;
    let _3: std::vec::Vec<u8>;
    let _4: &[u8];
    let _5: &std::ffi::OsStr;
    let _6: &std::path::Path;
    let mut _7: &std::path::PathBuf;
    let mut _9: &std::vec::Vec<u8>;
    let mut _10: std::slice::Iter<'_, std::string::String>;
    let mut _11: std::slice::Iter<'_, std::string::String>;
    let mut _13: std::option::Option<&std::string::String>;
    let mut _14: &mut std::slice::Iter<'_, std::string::String>;
    let mut _15: isize;
    let mut _18: std::option::Option<usize>;
    let mut _19: &[u8];
    let mut _20: isize;
    let _22: &[u8];
    let mut _23: &[u8];
    let mut _24: std::ops::RangeFrom<usize>;
    let mut _25: usize;
    let mut _26: usize;
    let mut _27: (usize, bool);
    scope 1 {
        debug path_bytes => _3;
        let mut _8: &[u8];
        scope 2 {
            debug subpath => _8;
            let mut _12: std::slice::Iter<'_, std::string::String>;
            scope 3 {
                debug iter => _12;
                let _16: &std::string::String;
                scope 4 {
                    debug subquery => _16;
                    let _17: &[u8];
                    scope 5 {
                        debug subquery_bytes => _17;
                        let _21: usize;
                        scope 6 {
                            debug idx => _21;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _7 = &((*_1).0: std::path::PathBuf);
        _6 = <PathBuf as Deref>::deref(move _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = Path::as_os_str(_6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = <OsStr as OsStrExt>::as_bytes(_5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = <[u8] as ByteSlice>::to_lowercase(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = &_3;
        _8 = Vec::<u8>::as_slice(move _9) -> [return: bb5, unwind: bb20];
    }

    bb5: {
        _11 = core::slice::<impl [std::string::String]>::iter(_2) -> [return: bb6, unwind: bb20];
    }

    bb6: {
        _10 = <std::slice::Iter<'_, std::string::String> as IntoIterator>::into_iter(move _11) -> [return: bb7, unwind: bb20];
    }

    bb7: {
        _12 = move _10;
        goto -> bb8;
    }

    bb8: {
        _14 = &mut _12;
        _13 = <std::slice::Iter<'_, std::string::String> as Iterator>::next(_14) -> [return: bb9, unwind: bb20];
    }

    bb9: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb10, otherwise: bb11];
    }

    bb10: {
        _16 = ((_13 as Some).0: &std::string::String);
        _17 = std::string::String::as_bytes(_16) -> [return: bb13, unwind: bb20];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _0 = const true;
        drop(_3) -> [return: bb19, unwind continue];
    }

    bb13: {
        _19 = _8;
        _18 = <[u8] as ByteSlice>::find::<&[u8]>(move _19, _17) -> [return: bb14, unwind: bb20];
    }

    bb14: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb15, 1: bb16, otherwise: bb11];
    }

    bb15: {
        _0 = const false;
        drop(_3) -> [return: bb19, unwind continue];
    }

    bb16: {
        _21 = ((_18 as Some).0: usize);
        _23 = _8;
        _26 = Len((*_17));
        _27 = CheckedAdd(_21, _26);
        assert(!move (_27.1: bool), "attempt to compute `{} + {}`, which would overflow", _21, move _26) -> [success: bb17, unwind: bb20];
    }

    bb17: {
        _25 = move (_27.0: usize);
        _24 = RangeFrom::<usize> { start: move _25 };
        _22 = <[u8] as Index<RangeFrom<usize>>>::index(move _23, move _24) -> [return: bb18, unwind: bb20];
    }

    bb18: {
        _8 = _22;
        goto -> bb8;
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_3) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        resume;
    }
}

fn dir::<impl at src/dir.rs:14:1: 14:9>::get_frecency(_1: &Dir, _2: i64) -> f64 {
    debug self => _1;
    debug now => _2;
    let mut _0: f64;
    let _3: i64;
    let mut _4: i64;
    let mut _5: (i64, bool);
    let mut _6: bool;
    let mut _7: f64;
    let mut _8: bool;
    let mut _9: f64;
    let mut _10: bool;
    let mut _11: f64;
    let mut _12: f64;
    scope 1 {
        debug duration => _3;
    }

    bb0: {
        _4 = ((*_1).2: i64);
        _5 = CheckedSub(_2, _4);
        assert(!move (_5.1: bool), "attempt to compute `{} - {}`, which would overflow", _2, move _4) -> [success: bb1, unwind continue];
    }

    bb1: {
        _3 = move (_5.0: i64);
        _6 = Lt(_3, const _);
        switchInt(move _6) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _7 = ((*_1).1: f64);
        _0 = Mul(move _7, const 4f64);
        goto -> bb8;
    }

    bb3: {
        _8 = Lt(_3, const _);
        switchInt(move _8) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _9 = ((*_1).1: f64);
        _0 = Mul(move _9, const 2f64);
        goto -> bb8;
    }

    bb5: {
        _10 = Lt(_3, const _);
        switchInt(move _10) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _11 = ((*_1).1: f64);
        _0 = Div(move _11, const 2f64);
        goto -> bb8;
    }

    bb7: {
        _12 = ((*_1).1: f64);
        _0 = Div(move _12, const 4f64);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

const HOUR: i64 = {
    let mut _0: i64;
    let mut _1: (i64, bool);

    bb0: {
        _1 = CheckedMul(const 60_i64, const 60_i64);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const 60_i64, const 60_i64) -> [success: bb1, unwind continue];
    }

    bb1: {
        _0 = move (_1.0: i64);
        return;
    }
}

const DAY: i64 = {
    let mut _0: i64;
    let mut _1: (i64, bool);

    bb0: {
        _1 = CheckedMul(const 24_i64, const _);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const 24_i64, const _) -> [success: bb1, unwind continue];
    }

    bb1: {
        _0 = move (_1.0: i64);
        return;
    }
}

const WEEK: i64 = {
    let mut _0: i64;
    let mut _1: (i64, bool);

    bb0: {
        _1 = CheckedMul(const 7_i64, const _);
        assert(!move (_1.1: bool), "attempt to compute `{} * {}`, which would overflow", const 7_i64, const _) -> [success: bb1, unwind continue];
    }

    bb1: {
        _0 = move (_1.0: i64);
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:10: 10:15>::fmt(_1: &add::Add, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::option::Option<std::path::PathBuf>;
    let _7: &std::option::Option<std::path::PathBuf>;

    bb0: {
        _3 = const "Add";
        _4 = const "path";
        _7 = &((*_1).0: std::option::Option<std::path::PathBuf>);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _1 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <add::Add as StructOptInternal>::augment_clap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::from_clap(_1: &ArgMatches<'_>) -> add::Add {
    debug matches => _1;
    let mut _0: subcommand::add::Add;
    let mut _2: std::option::Option<std::path::PathBuf>;
    let mut _3: std::option::Option<&str>;

    bb0: {
        _3 = ArgMatches::<'_>::value_of::<&str>(_1, const "path") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::option::Option::<&str>::map::<PathBuf, {closure@src/subcommand/add.rs:13:5: 13:9}>(move _3, const ZeroSized: {closure@src/subcommand/add.rs:13:5: 13:9}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = add::Add { path: move _2 };
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::from_clap::{closure#0}(_1: {closure@src/subcommand/add.rs:13:5: 13:9}, _2: &str) -> PathBuf {
    debug s => _2;
    let mut _0: std::path::PathBuf;
    let mut _3: std::result::Result<std::path::PathBuf, std::convert::Infallible>;

    bb0: {
        _3 = <PathBuf as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<PathBuf, Infallible>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let _9: &str;
    let mut _10: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
        }
    }

    bb0: {
        _10 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "Add a new directory or increment its rank") -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = const true;
        _4 = move _2;
        _9 = const "path";
        _8 = Arg::<'_, '_>::with_name(_9) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _7 = Arg::<'_, '_>::takes_value(move _8, const true) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _6 = Arg::<'_, '_>::multiple(move _7, const false) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _5 = Arg::<'_, '_>::validator::<{closure@src/subcommand/add.rs:13:5: 13:9}>(move _6, const ZeroSized: {closure@src/subcommand/add.rs:13:5: 13:9}) -> [return: bb5, unwind: bb10];
    }

    bb5: {
        _10 = const false;
        _3 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _4, move _5) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _10 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _3, const "0.3.0") -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        resume;
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_10) -> [0: bb8, otherwise: bb9];
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::augment_clap::{closure#0}(_1: &{closure@src/subcommand/add.rs:13:5: 13:9}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::convert::Infallible>;
    let mut _4: std::result::Result<std::path::PathBuf, std::convert::Infallible>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <PathBuf as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<PathBuf, Infallible>::map::<(), {closure@src/subcommand/add.rs:13:5: 13:9}>(move _4, const ZeroSized: {closure@src/subcommand/add.rs:13:5: 13:9}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), Infallible>::map_err::<std::string::String, {closure@src/subcommand/add.rs:13:5: 13:9}>(const Result::<(), Infallible>::Ok(()), const ZeroSized: {closure@src/subcommand/add.rs:13:5: 13:9}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::augment_clap::{closure#0}::{closure#0}(_1: {closure@src/subcommand/add.rs:13:5: 13:9}, _2: PathBuf) -> () {
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::augment_clap::{closure#0}::{closure#1}(_1: {closure@src/subcommand/add.rs:13:5: 13:9}, _2: Infallible) -> std::string::String {
    debug e => const ZeroSized: Infallible;
    let mut _0: std::string::String;
    let mut _3: &std::convert::Infallible;

    bb0: {
        _3 = &_2;
        _0 = <Infallible as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:10:17: 10:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn add::<impl at src/subcommand/add.rs:16:1: 16:9>::run(_1: &add::Add) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let mut _2: db::DB;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DB>;
    let mut _4: std::result::Result<db::DB, anyhow::Error>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _7: db::DB;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, i64>;
    let mut _9: std::result::Result<i64, anyhow::Error>;
    let mut _10: isize;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, f64>;
    let mut _14: std::result::Result<f64, anyhow::Error>;
    let mut _15: isize;
    let mut _20: &std::option::Option<std::path::PathBuf>;
    let mut _21: isize;
    let mut _23: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::path::PathBuf>;
    let mut _24: std::result::Result<std::path::PathBuf, anyhow::Error>;
    let mut _25: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _26: isize;
    let mut _29: bool;
    let _30: &[std::path::PathBuf];
    let mut _31: &std::vec::Vec<std::path::PathBuf>;
    let _32: &std::path::PathBuf;
    let mut _33: &mut db::DB;
    let mut _34: std::path::PathBuf;
    let mut _35: bool;
    scope 1 {
        debug db => _2;
        let _11: std::result::Result<std::convert::Infallible, anyhow::Error>;
        let _12: i64;
        scope 6 {
            debug now => _12;
            let _16: std::result::Result<std::convert::Infallible, anyhow::Error>;
            let _17: f64;
            scope 11 {
                debug maxage => _17;
                let _18: std::vec::Vec<std::path::PathBuf>;
                scope 16 {
                    debug excluded_dirs => _18;
                    let _19: std::path::PathBuf;
                    let _22: &std::path::PathBuf;
                    let _27: std::result::Result<std::convert::Infallible, anyhow::Error>;
                    let _28: std::path::PathBuf;
                    scope 17 {
                        debug path => _19;
                    }
                    scope 18 {
                        debug path => _22;
                    }
                    scope 19 {
                        debug residual => _27;
                        scope 20 {
                        }
                    }
                    scope 21 {
                        debug val => _28;
                        scope 22 {
                        }
                    }
                }
            }
            scope 12 {
                debug residual => _16;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _17;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _11;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _12;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _35 = const false;
        _4 = get_db() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <Result<DB, anyhow::Error> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Continue).0: db::DB);
        _2 = move _7;
        _9 = get_current_time() -> [return: bb6, unwind: bb34];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _6) -> [return: bb32, unwind continue];
    }

    bb6: {
        _8 = <Result<i64, anyhow::Error> as Try>::branch(move _9) -> [return: bb7, unwind: bb34];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _12 = ((_8 as Continue).0: i64);
        _14 = zo_maxage() -> [return: bb10, unwind: bb34];
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _11) -> [return: bb38, unwind: bb34];
    }

    bb10: {
        _13 = <Result<f64, anyhow::Error> as Try>::branch(move _14) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _17 = ((_13 as Continue).0: f64);
        _18 = zo_exclude_dirs() -> [return: bb14, unwind: bb34];
    }

    bb13: {
        _16 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _16) -> [return: bb39, unwind: bb34];
    }

    bb14: {
        _20 = &((*_1).0: std::option::Option<std::path::PathBuf>);
        _21 = discriminant((*_20));
        switchInt(move _21) -> [0: bb15, 1: bb16, otherwise: bb4];
    }

    bb15: {
        _25 = current_dir() -> [return: bb18, unwind: bb33];
    }

    bb16: {
        _22 = &(((*_20) as Some).0: std::path::PathBuf);
        _19 = <PathBuf as Clone>::clone(_22) -> [return: bb17, unwind: bb33];
    }

    bb17: {
        _35 = const true;
        goto -> bb23;
    }

    bb18: {
        _24 = <Result<PathBuf, std::io::Error> as anyhow::Context<PathBuf, std::io::Error>>::context::<&str>(move _25, const "unable to fetch current directory") -> [return: bb19, unwind: bb33];
    }

    bb19: {
        _23 = <Result<PathBuf, anyhow::Error> as Try>::branch(move _24) -> [return: bb20, unwind: bb33];
    }

    bb20: {
        _26 = discriminant(_23);
        switchInt(move _26) -> [0: bb21, 1: bb22, otherwise: bb4];
    }

    bb21: {
        _28 = move ((_23 as Continue).0: std::path::PathBuf);
        _35 = const true;
        _19 = move _28;
        goto -> bb23;
    }

    bb22: {
        _27 = move ((_23 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _27) -> [return: bb40, unwind: bb33];
    }

    bb23: {
        _31 = &_18;
        _30 = <Vec<PathBuf> as Deref>::deref(move _31) -> [return: bb24, unwind: bb37];
    }

    bb24: {
        _32 = &_19;
        _29 = core::slice::<impl [PathBuf]>::contains(_30, _32) -> [return: bb25, unwind: bb37];
    }

    bb25: {
        switchInt(move _29) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        drop(_19) -> [return: bb30, unwind: bb33];
    }

    bb27: {
        _33 = &mut _2;
        _35 = const false;
        _34 = move _19;
        _0 = DB::add::<PathBuf>(move _33, move _34, _17, _12) -> [return: bb28, unwind: bb37];
    }

    bb28: {
        _35 = const false;
        drop(_18) -> [return: bb29, unwind: bb34];
    }

    bb29: {
        drop(_2) -> [return: bb32, unwind continue];
    }

    bb30: {
        _35 = const false;
        drop(_18) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        drop(_2) -> [return: bb32, unwind continue];
    }

    bb32: {
        return;
    }

    bb33 (cleanup): {
        drop(_18) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_2) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36 (cleanup): {
        drop(_19) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        switchInt(_35) -> [0: bb33, otherwise: bb36];
    }

    bb38: {
        goto -> bb31;
    }

    bb39: {
        goto -> bb31;
    }

    bb40: {
        goto -> bb30;
    }
}

fn import::<impl at src/subcommand/import.rs:8:10: 8:15>::fmt(_1: &Import, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::path::PathBuf;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&bool;
    let _10: &bool;

    bb0: {
        _3 = const "Import";
        _4 = const "path";
        _6 = &((*_1).0: std::path::PathBuf);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "merge";
        _10 = &((*_1).1: bool);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _1 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <Import as StructOptInternal>::augment_clap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::from_clap(_1: &ArgMatches<'_>) -> Import {
    debug matches => _1;
    let mut _0: subcommand::import::Import;
    let mut _2: std::path::PathBuf;
    let mut _3: std::option::Option<std::path::PathBuf>;
    let mut _4: std::option::Option<&str>;
    let mut _5: bool;

    bb0: {
        _4 = ArgMatches::<'_>::value_of::<&str>(_1, const "path") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::option::Option::<&str>::map::<PathBuf, {closure@src/subcommand/import.rs:11:5: 11:9}>(move _4, const ZeroSized: {closure@src/subcommand/import.rs:11:5: 11:9}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = std::option::Option::<PathBuf>::unwrap(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ArgMatches::<'_>::is_present::<&str>(_1, const "merge") -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = Import { path: move _2, merge: move _5 };
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::from_clap::{closure#0}(_1: {closure@src/subcommand/import.rs:11:5: 11:9}, _2: &str) -> PathBuf {
    debug s => _2;
    let mut _0: std::path::PathBuf;
    let mut _3: std::result::Result<std::path::PathBuf, std::convert::Infallible>;

    bb0: {
        _3 = <PathBuf as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<PathBuf, Infallible>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let mut _9: clap::Arg<'_, '_>;
    let _10: &str;
    let mut _12: clap::App<'_, '_>;
    let mut _13: clap::Arg<'_, '_>;
    let mut _14: clap::Arg<'_, '_>;
    let mut _15: clap::Arg<'_, '_>;
    let mut _16: clap::Arg<'_, '_>;
    let mut _17: clap::Arg<'_, '_>;
    let _18: &str;
    let _19: &str;
    let _20: &str;
    let mut _21: bool;
    let mut _22: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
            let _11: clap::App<'_, '_>;
            scope 3 {
                debug app => _11;
            }
        }
    }

    bb0: {
        _22 = const false;
        _21 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "Import from z database") -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const true;
        _4 = move _2;
        _10 = const "path";
        _9 = Arg::<'_, '_>::with_name(_10) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _8 = Arg::<'_, '_>::takes_value(move _9, const true) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _7 = Arg::<'_, '_>::multiple(move _8, const false) -> [return: bb4, unwind: bb19];
    }

    bb4: {
        _6 = Arg::<'_, '_>::required(move _7, const true) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _5 = Arg::<'_, '_>::validator::<{closure@src/subcommand/import.rs:11:5: 11:9}>(move _6, const ZeroSized: {closure@src/subcommand/import.rs:11:5: 11:9}) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _22 = const false;
        _3 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _4, move _5) -> [return: bb7, unwind: bb19];
    }

    bb7: {
        _22 = const false;
        _21 = const true;
        _12 = move _3;
        _18 = const "merge";
        _17 = Arg::<'_, '_>::with_name(_18) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _16 = Arg::<'_, '_>::takes_value(move _17, const false) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _15 = Arg::<'_, '_>::multiple(move _16, const false) -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _19 = const "merge";
        _14 = Arg::<'_, '_>::long(move _15, _19) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _20 = const "Merge entries into existing database";
        _13 = Arg::<'_, '_>::help(move _14, _20) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _21 = const false;
        _11 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _12, move _13) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _21 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _11, const "0.3.0") -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_12) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_21) -> [0: bb15, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_4) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_22) -> [0: bb15, otherwise: bb18];
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::augment_clap::{closure#0}(_1: &{closure@src/subcommand/import.rs:11:5: 11:9}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::convert::Infallible>;
    let mut _4: std::result::Result<std::path::PathBuf, std::convert::Infallible>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <PathBuf as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<PathBuf, Infallible>::map::<(), {closure@src/subcommand/import.rs:11:5: 11:9}>(move _4, const ZeroSized: {closure@src/subcommand/import.rs:11:5: 11:9}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), Infallible>::map_err::<std::string::String, {closure@src/subcommand/import.rs:11:5: 11:9}>(const Result::<(), Infallible>::Ok(()), const ZeroSized: {closure@src/subcommand/import.rs:11:5: 11:9}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::augment_clap::{closure#0}::{closure#0}(_1: {closure@src/subcommand/import.rs:11:5: 11:9}, _2: PathBuf) -> () {
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::augment_clap::{closure#0}::{closure#1}(_1: {closure@src/subcommand/import.rs:11:5: 11:9}, _2: Infallible) -> std::string::String {
    debug e => const ZeroSized: Infallible;
    let mut _0: std::string::String;
    let mut _3: &std::convert::Infallible;

    bb0: {
        _3 = &_2;
        _0 = <Infallible as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:8:17: 8:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn import::<impl at src/subcommand/import.rs:17:1: 17:12>::run(_1: &Import) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let mut _2: &mut db::DB;
    let mut _3: db::DB;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DB>;
    let mut _5: std::result::Result<db::DB, anyhow::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _8: db::DB;
    let mut _9: &std::path::PathBuf;
    let mut _10: bool;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _5 = get_db() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<DB, anyhow::Error> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: db::DB);
        _3 = move _8;
        _2 = &mut _3;
        _9 = &((*_1).0: std::path::PathBuf);
        _10 = ((*_1).1: bool);
        _0 = DB::import::<&PathBuf>(move _2, move _9, move _10) -> [return: bb6, unwind: bb8];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn init::<impl at src/subcommand/init.rs:7:10: 7:15>::fmt(_1: &Init, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &subcommand::init::Shell;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &bool;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&subcommand::init::Hook;
    let _13: &subcommand::init::Hook;

    bb0: {
        _3 = const "Init";
        _4 = const "shell";
        _6 = &((*_1).0: subcommand::init::Shell);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "no_define_aliases";
        _9 = &((*_1).1: bool);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "hook";
        _13 = &((*_1).2: subcommand::init::Hook);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _1 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <Init as StructOptInternal>::augment_clap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::from_clap(_1: &ArgMatches<'_>) -> Init {
    debug matches => _1;
    let mut _0: subcommand::init::Init;
    let mut _2: subcommand::init::Shell;
    let mut _3: std::option::Option<subcommand::init::Shell>;
    let mut _4: std::option::Option<&str>;
    let mut _5: bool;
    let mut _6: subcommand::init::Hook;
    let mut _7: std::option::Option<subcommand::init::Hook>;
    let mut _8: std::option::Option<&str>;

    bb0: {
        _4 = ArgMatches::<'_>::value_of::<&str>(_1, const "shell") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::option::Option::<&str>::map::<init::Shell, {closure@src/subcommand/init.rs:10:5: 10:6}>(move _4, const ZeroSized: {closure@src/subcommand/init.rs:10:5: 10:6}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = std::option::Option::<init::Shell>::unwrap(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = ArgMatches::<'_>::is_present::<&str>(_1, const "no-define-aliases") -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = ArgMatches::<'_>::value_of::<&str>(_1, const "hook") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = std::option::Option::<&str>::map::<Hook, {closure@src/subcommand/init.rs:19:5: 19:6}>(move _8, const ZeroSized: {closure@src/subcommand/init.rs:19:5: 19:6}) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = std::option::Option::<Hook>::unwrap(move _7) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Init { shell: move _2, no_define_aliases: move _5, hook: move _6 };
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::from_clap::{closure#0}(_1: {closure@src/subcommand/init.rs:10:5: 10:6}, _2: &str) -> init::Shell {
    debug s => _2;
    let mut _0: subcommand::init::Shell;
    let mut _3: std::result::Result<subcommand::init::Shell, std::string::String>;

    bb0: {
        _3 = <init::Shell as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<init::Shell, std::string::String>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::from_clap::{closure#1}(_1: {closure@src/subcommand/init.rs:19:5: 19:6}, _2: &str) -> Hook {
    debug s => _2;
    let mut _0: subcommand::init::Hook;
    let mut _3: std::result::Result<subcommand::init::Hook, std::string::String>;

    bb0: {
        _3 = <Hook as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<Hook, std::string::String>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let mut _9: clap::Arg<'_, '_>;
    let mut _10: clap::Arg<'_, '_>;
    let mut _11: clap::Arg<'_, '_>;
    let _12: &str;
    let mut _13: &[&str];
    let _14: &[&str; 4];
    let _15: [&str; 4];
    let mut _17: clap::App<'_, '_>;
    let mut _18: clap::Arg<'_, '_>;
    let mut _19: clap::Arg<'_, '_>;
    let mut _20: clap::Arg<'_, '_>;
    let mut _21: clap::Arg<'_, '_>;
    let mut _22: clap::Arg<'_, '_>;
    let _23: &str;
    let _24: &str;
    let _25: &str;
    let mut _27: clap::App<'_, '_>;
    let mut _28: clap::Arg<'_, '_>;
    let mut _29: clap::Arg<'_, '_>;
    let mut _30: clap::Arg<'_, '_>;
    let mut _31: clap::Arg<'_, '_>;
    let mut _32: clap::Arg<'_, '_>;
    let mut _33: clap::Arg<'_, '_>;
    let mut _34: clap::Arg<'_, '_>;
    let mut _35: clap::Arg<'_, '_>;
    let mut _36: clap::Arg<'_, '_>;
    let mut _37: clap::Arg<'_, '_>;
    let _38: &str;
    let _39: &str;
    let _40: &str;
    let mut _41: &[&str];
    let _42: &[&str; 3];
    let _43: [&str; 3];
    let _44: &str;
    let mut _45: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: bool;
    let mut _49: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
            let _16: clap::App<'_, '_>;
            scope 3 {
                debug app => _16;
                let _26: clap::App<'_, '_>;
                scope 4 {
                    debug app => _26;
                }
            }
        }
    }

    bb0: {
        _49 = const false;
        _48 = const false;
        _47 = const false;
        _46 = const false;
        _45 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "Generates shell configuration") -> [return: bb1, unwind continue];
    }

    bb1: {
        _49 = const true;
        _4 = move _2;
        _12 = const "shell";
        _11 = Arg::<'_, '_>::with_name(_12) -> [return: bb2, unwind: bb40];
    }

    bb2: {
        _10 = Arg::<'_, '_>::takes_value(move _11, const true) -> [return: bb3, unwind: bb40];
    }

    bb3: {
        _9 = Arg::<'_, '_>::multiple(move _10, const false) -> [return: bb4, unwind: bb40];
    }

    bb4: {
        _8 = Arg::<'_, '_>::required(move _9, const true) -> [return: bb5, unwind: bb40];
    }

    bb5: {
        _7 = Arg::<'_, '_>::validator::<{closure@src/subcommand/init.rs:10:5: 10:6}>(move _8, const ZeroSized: {closure@src/subcommand/init.rs:10:5: 10:6}) -> [return: bb6, unwind: bb40];
    }

    bb6: {
        _48 = const true;
        _15 = init::Shell::variants() -> [return: bb7, unwind: bb38];
    }

    bb7: {
        _14 = &_15;
        _13 = _14 as &[&str] (PointerCoercion(Unsize));
        _48 = const false;
        _6 = Arg::<'_, '_>::possible_values(move _7, move _13) -> [return: bb8, unwind: bb38];
    }

    bb8: {
        _48 = const false;
        _5 = Arg::<'_, '_>::case_insensitive(move _6, const true) -> [return: bb9, unwind: bb40];
    }

    bb9: {
        _49 = const false;
        _3 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _4, move _5) -> [return: bb10, unwind: bb40];
    }

    bb10: {
        _49 = const false;
        _47 = const true;
        _17 = move _3;
        _23 = const "no-define-aliases";
        _22 = Arg::<'_, '_>::with_name(_23) -> [return: bb11, unwind: bb36];
    }

    bb11: {
        _21 = Arg::<'_, '_>::takes_value(move _22, const false) -> [return: bb12, unwind: bb36];
    }

    bb12: {
        _20 = Arg::<'_, '_>::multiple(move _21, const false) -> [return: bb13, unwind: bb36];
    }

    bb13: {
        _24 = const "no-define-aliases";
        _19 = Arg::<'_, '_>::long(move _20, _24) -> [return: bb14, unwind: bb36];
    }

    bb14: {
        _25 = const "Prevents zoxide from defining any aliases other than 'z'";
        _18 = Arg::<'_, '_>::help(move _19, _25) -> [return: bb15, unwind: bb36];
    }

    bb15: {
        _47 = const false;
        _16 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _17, move _18) -> [return: bb16, unwind: bb36];
    }

    bb16: {
        _47 = const false;
        _46 = const true;
        _27 = move _16;
        _38 = const "hook";
        _37 = Arg::<'_, '_>::with_name(_38) -> [return: bb17, unwind: bb34];
    }

    bb17: {
        _36 = Arg::<'_, '_>::takes_value(move _37, const true) -> [return: bb18, unwind: bb34];
    }

    bb18: {
        _35 = Arg::<'_, '_>::multiple(move _36, const false) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        _34 = Arg::<'_, '_>::required(move _35, const false) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _33 = Arg::<'_, '_>::validator::<{closure@src/subcommand/init.rs:19:5: 19:6}>(move _34, const ZeroSized: {closure@src/subcommand/init.rs:19:5: 19:6}) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _39 = const "hook";
        _32 = Arg::<'_, '_>::long(move _33, _39) -> [return: bb22, unwind: bb34];
    }

    bb22: {
        _40 = const "Chooses event on which an entry is added to the database";
        _31 = Arg::<'_, '_>::help(move _32, _40) -> [return: bb23, unwind: bb34];
    }

    bb23: {
        _45 = const true;
        _43 = Hook::variants() -> [return: bb24, unwind: bb32];
    }

    bb24: {
        _42 = &_43;
        _41 = _42 as &[&str] (PointerCoercion(Unsize));
        _45 = const false;
        _30 = Arg::<'_, '_>::possible_values(move _31, move _41) -> [return: bb25, unwind: bb32];
    }

    bb25: {
        _45 = const false;
        _44 = const "prompt";
        _29 = Arg::<'_, '_>::default_value(move _30, _44) -> [return: bb26, unwind: bb34];
    }

    bb26: {
        _28 = Arg::<'_, '_>::case_insensitive(move _29, const true) -> [return: bb27, unwind: bb34];
    }

    bb27: {
        _46 = const false;
        _26 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _27, move _28) -> [return: bb28, unwind: bb34];
    }

    bb28: {
        _46 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _26, const "0.3.0") -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        resume;
    }

    bb31 (cleanup): {
        drop(_31) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        switchInt(_45) -> [0: bb34, otherwise: bb31];
    }

    bb33 (cleanup): {
        drop(_27) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        switchInt(_46) -> [0: bb30, otherwise: bb33];
    }

    bb35 (cleanup): {
        drop(_17) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        switchInt(_47) -> [0: bb30, otherwise: bb35];
    }

    bb37 (cleanup): {
        drop(_7) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_48) -> [0: bb40, otherwise: bb37];
    }

    bb39 (cleanup): {
        drop(_4) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        switchInt(_49) -> [0: bb30, otherwise: bb39];
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#0}(_1: &{closure@src/subcommand/init.rs:10:5: 10:6}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::string::String>;
    let mut _4: std::result::Result<subcommand::init::Shell, std::string::String>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <init::Shell as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<init::Shell, std::string::String>::map::<(), {closure@src/subcommand/init.rs:10:5: 10:6}>(move _4, const ZeroSized: {closure@src/subcommand/init.rs:10:5: 10:6}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), std::string::String>::map_err::<std::string::String, {closure@src/subcommand/init.rs:10:5: 10:6}>(move _3, const ZeroSized: {closure@src/subcommand/init.rs:10:5: 10:6}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#0}::{closure#0}(_1: {closure@src/subcommand/init.rs:10:5: 10:6}, _2: init::Shell) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#0}::{closure#1}(_1: {closure@src/subcommand/init.rs:10:5: 10:6}, _2: std::string::String) -> std::string::String {
    debug e => _2;
    let mut _0: std::string::String;
    let mut _3: &std::string::String;

    bb0: {
        _3 = &_2;
        _0 = <std::string::String as ToString>::to_string(move _3) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#1}(_1: &{closure@src/subcommand/init.rs:19:5: 19:6}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::string::String>;
    let mut _4: std::result::Result<subcommand::init::Hook, std::string::String>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <Hook as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<Hook, std::string::String>::map::<(), {closure@src/subcommand/init.rs:19:5: 19:6}>(move _4, const ZeroSized: {closure@src/subcommand/init.rs:19:5: 19:6}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), std::string::String>::map_err::<std::string::String, {closure@src/subcommand/init.rs:19:5: 19:6}>(move _3, const ZeroSized: {closure@src/subcommand/init.rs:19:5: 19:6}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#1}::{closure#0}(_1: {closure@src/subcommand/init.rs:19:5: 19:6}, _2: Hook) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::augment_clap::{closure#1}::{closure#1}(_1: {closure@src/subcommand/init.rs:19:5: 19:6}, _2: std::string::String) -> std::string::String {
    debug e => _2;
    let mut _0: std::string::String;
    let mut _3: &std::string::String;

    bb0: {
        _3 = &_2;
        _0 = <std::string::String as ToString>::to_string(move _3) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        drop(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }

    bb3 (cleanup): {
        drop(_2) -> [return: bb4, unwind terminate(cleanup)];
    }

    bb4 (cleanup): {
        resume;
    }
}

fn init::<impl at src/subcommand/init.rs:7:17: 7:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:29:1: 29:10>::run(_1: &Init) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let _2: subcommand::init::ShellConfig;
    let mut _3: isize;
    let mut _6: &std::io::Stdout;
    let _7: ();
    let mut _8: std::result::Result<(), std::io::Error>;
    let mut _9: &mut std::io::StdoutLock<'_>;
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[core::fmt::rt::Argument<'_>];
    let _13: &[core::fmt::rt::Argument<'_>; 1];
    let _14: [core::fmt::rt::Argument<'_>; 1];
    let mut _15: core::fmt::rt::Argument<'_>;
    let _16: &&str;
    let mut _17: bool;
    let _18: ();
    let mut _19: std::result::Result<(), std::io::Error>;
    let mut _20: &mut std::io::StdoutLock<'_>;
    let mut _21: std::fmt::Arguments<'_>;
    let mut _22: &[&str];
    let mut _23: &[core::fmt::rt::Argument<'_>];
    let _24: &[core::fmt::rt::Argument<'_>; 1];
    let _25: [core::fmt::rt::Argument<'_>; 1];
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&str;
    let _28: ();
    let mut _29: isize;
    let mut _30: std::result::Result<(), std::io::Error>;
    let mut _31: &mut std::io::StdoutLock<'_>;
    let mut _32: std::fmt::Arguments<'_>;
    let mut _33: &[&str];
    let mut _34: &[core::fmt::rt::Argument<'_>];
    let _35: &[core::fmt::rt::Argument<'_>; 1];
    let _36: [core::fmt::rt::Argument<'_>; 1];
    let mut _37: core::fmt::rt::Argument<'_>;
    let _38: &&str;
    let mut _39: isize;
    let mut _41: std::result::Result<(), std::io::Error>;
    let mut _42: &mut std::io::StdoutLock<'_>;
    let mut _43: std::fmt::Arguments<'_>;
    let mut _44: &[&str];
    let mut _45: &[core::fmt::rt::Argument<'_>];
    let _46: &[core::fmt::rt::Argument<'_>; 1];
    let _47: [core::fmt::rt::Argument<'_>; 1];
    let mut _48: core::fmt::rt::Argument<'_>;
    let _49: &&str;
    let mut _50: anyhow::Error;
    scope 1 {
        debug config => _2;
        let _4: std::io::Stdout;
        scope 2 {
            debug stdout => _4;
            let mut _5: std::io::StdoutLock<'_>;
            scope 3 {
                debug handle => _5;
                let _40: &str;
                let mut _52: &[&str; 2];
                let mut _53: &[&str; 2];
                let mut _54: &[&str; 2];
                scope 4 {
                    debug pwd_hook => _40;
                    let mut _51: &[&str; 2];
                }
            }
        }
    }

    bb0: {
        _3 = discriminant(((*_1).0: subcommand::init::Shell));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _2 = const _;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _2 = const _;
        goto -> bb6;
    }

    bb4: {
        _2 = const _;
        goto -> bb6;
    }

    bb5: {
        _2 = const _;
        goto -> bb6;
    }

    bb6: {
        _4 = stdout() -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = &_4;
        _5 = Stdout::lock(move _6) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = &mut _5;
        _54 = const _;
        _11 = _54 as &[&str] (PointerCoercion(Unsize));
        _16 = &(_2.0: &str);
        _15 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_16) -> [return: bb9, unwind: bb31];
    }

    bb9: {
        _14 = [move _15];
        _13 = &_14;
        _12 = _13 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _10 = Arguments::<'_>::new_v1(move _11, move _12) -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _8 = <StdoutLock<'_> as std::io::Write>::write_fmt(move _9, move _10) -> [return: bb11, unwind: bb31];
    }

    bb11: {
        _7 = Result::<(), std::io::Error>::unwrap(move _8) -> [return: bb12, unwind: bb31];
    }

    bb12: {
        _17 = ((*_1).1: bool);
        switchInt(move _17) -> [0: bb13, otherwise: bb17];
    }

    bb13: {
        _20 = &mut _5;
        _53 = const _;
        _22 = _53 as &[&str] (PointerCoercion(Unsize));
        _27 = &(_2.1: &str);
        _26 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_27) -> [return: bb14, unwind: bb31];
    }

    bb14: {
        _25 = [move _26];
        _24 = &_25;
        _23 = _24 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _21 = Arguments::<'_>::new_v1(move _22, move _23) -> [return: bb15, unwind: bb31];
    }

    bb15: {
        _19 = <StdoutLock<'_> as std::io::Write>::write_fmt(move _20, move _21) -> [return: bb16, unwind: bb31];
    }

    bb16: {
        _18 = Result::<(), std::io::Error>::unwrap(move _19) -> [return: bb33, unwind: bb31];
    }

    bb17: {
        _29 = discriminant(((*_1).2: subcommand::init::Hook));
        switchInt(move _29) -> [0: bb29, 1: bb19, 2: bb18, otherwise: bb2];
    }

    bb18: {
        _39 = discriminant(((_2.2: subcommand::init::HookConfig).1: std::option::Option<&str>));
        switchInt(move _39) -> [0: bb23, 1: bb24, otherwise: bb2];
    }

    bb19: {
        _31 = &mut _5;
        _52 = const _;
        _33 = _52 as &[&str] (PointerCoercion(Unsize));
        _38 = &((_2.2: subcommand::init::HookConfig).0: &str);
        _37 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_38) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _36 = [move _37];
        _35 = &_36;
        _34 = _35 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _32 = Arguments::<'_>::new_v1(move _33, move _34) -> [return: bb21, unwind: bb31];
    }

    bb21: {
        _30 = <StdoutLock<'_> as std::io::Write>::write_fmt(move _31, move _32) -> [return: bb22, unwind: bb31];
    }

    bb22: {
        _28 = Result::<(), std::io::Error>::unwrap(move _30) -> [return: bb34, unwind: bb31];
    }

    bb23: {
        _50 = new_adhoc::<&str>(const "PWD hooks are currently unsupported on this shell.") -> [return: bb28, unwind: bb31];
    }

    bb24: {
        _40 = ((((_2.2: subcommand::init::HookConfig).1: std::option::Option<&str>) as Some).0: &str);
        _42 = &mut _5;
        _51 = const _;
        _44 = _51 as &[&str] (PointerCoercion(Unsize));
        _49 = &_40;
        _48 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_49) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _47 = [move _48];
        _46 = &_47;
        _45 = _46 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _43 = Arguments::<'_>::new_v1(move _44, move _45) -> [return: bb26, unwind: bb31];
    }

    bb26: {
        _41 = <StdoutLock<'_> as std::io::Write>::write_fmt(move _42, move _43) -> [return: bb27, unwind: bb31];
    }

    bb27: {
        _28 = Result::<(), std::io::Error>::unwrap(move _41) -> [return: bb35, unwind: bb31];
    }

    bb28: {
        _0 = Result::<(), anyhow::Error>::Err(move _50);
        drop(_5) -> [return: bb30, unwind continue];
    }

    bb29: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        drop(_5) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_5) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        goto -> bb17;
    }

    bb34: {
        goto -> bb29;
    }

    bb35: {
        goto -> bb29;
    }
}

promoted[0] in init::<impl at src/subcommand/init.rs:29:1: 29:10>::run: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in init::<impl at src/subcommand/init.rs:29:1: 29:10>::run: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in init::<impl at src/subcommand/init.rs:29:1: 29:10>::run: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[3] in init::<impl at src/subcommand/init.rs:29:1: 29:10>::run: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:63:14: 63:19>::fmt(_1: &init::Shell, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = const "zsh";
        _3 = _8;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "bash";
        _3 = _5;
        goto -> bb6;
    }

    bb4: {
        _6 = const "fish";
        _3 = _6;
        goto -> bb6;
    }

    bb5: {
        _7 = const "posix";
        _3 = _7;
        goto -> bb6;
    }

    bb6: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:313:9: 313:40>::from_str(_1: &str) -> Result<init::Shell, std::string::String> {
    debug s => _1;
    let mut _0: std::result::Result<subcommand::init::Shell, std::string::String>;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let _7: &str;
    let mut _8: bool;
    let _9: &str;
    let mut _10: subcommand::init::Shell;
    let mut _11: bool;
    let _12: &str;
    let mut _13: bool;
    let _14: &str;
    let mut _15: subcommand::init::Shell;
    let mut _16: bool;
    let _17: &str;
    let mut _18: bool;
    let _19: &str;
    let mut _20: subcommand::init::Shell;
    let mut _21: bool;
    let _22: &str;
    let mut _23: bool;
    let _24: &str;
    let mut _25: subcommand::init::Shell;
    let mut _26: std::string::String;
    let _27: std::vec::Vec<&str>;
    let mut _28: std::boxed::Box<[&str]>;
    let mut _29: usize;
    let mut _30: usize;
    let mut _31: *mut u8;
    let mut _32: std::boxed::Box<[&str; 4]>;
    let _33: &str;
    let _34: &str;
    let _35: &str;
    let mut _37: std::fmt::Arguments<'_>;
    let mut _38: &[&str];
    let mut _39: &[core::fmt::rt::Argument<'_>];
    let _40: &[core::fmt::rt::Argument<'_>; 1];
    let _41: [core::fmt::rt::Argument<'_>; 1];
    let mut _42: core::fmt::rt::Argument<'_>;
    let _43: &std::string::String;
    let _44: std::string::String;
    let _45: &[&str];
    let mut _46: &std::vec::Vec<&str>;
    let _47: &str;
    let mut _49: *const [&str; 4];
    let mut _50: *const ();
    let mut _51: usize;
    let mut _52: usize;
    let mut _53: usize;
    let mut _54: usize;
    let mut _55: bool;
    scope 1 {
        debug v => _27;
        let _36: std::string::String;
        let mut _48: &[&str; 1];
        scope 3 {
            debug res => _36;
        }
    }
    scope 2 {
    }

    bb0: {
        _5 = <str as PartialEq>::eq(_1, const "bash") -> [return: bb12, unwind continue];
    }

    bb1: {
        _7 = const "bash";
        _6 = core::str::<impl str>::eq_ignore_ascii_case(_1, _7) -> [return: bb14, unwind continue];
    }

    bb2: {
        _9 = const "bash";
        _8 = core::str::<impl str>::eq_ignore_ascii_case(_1, _9) -> [return: bb15, unwind continue];
    }

    bb3: {
        _12 = const "fish";
        _11 = core::str::<impl str>::eq_ignore_ascii_case(_1, _12) -> [return: bb18, unwind continue];
    }

    bb4: {
        _14 = const "fish";
        _13 = core::str::<impl str>::eq_ignore_ascii_case(_1, _14) -> [return: bb19, unwind continue];
    }

    bb5: {
        _17 = const "posix";
        _16 = core::str::<impl str>::eq_ignore_ascii_case(_1, _17) -> [return: bb22, unwind continue];
    }

    bb6: {
        _19 = const "posix";
        _18 = core::str::<impl str>::eq_ignore_ascii_case(_1, _19) -> [return: bb23, unwind continue];
    }

    bb7: {
        _22 = const "zsh";
        _21 = core::str::<impl str>::eq_ignore_ascii_case(_1, _22) -> [return: bb26, unwind continue];
    }

    bb8: {
        _24 = const "zsh";
        _23 = core::str::<impl str>::eq_ignore_ascii_case(_1, _24) -> [return: bb27, unwind continue];
    }

    bb9: {
        switchInt(move _2) -> [0: bb8, otherwise: bb7];
    }

    bb10: {
        switchInt(move _3) -> [0: bb6, otherwise: bb5];
    }

    bb11: {
        switchInt(move _4) -> [0: bb4, otherwise: bb3];
    }

    bb12: {
        switchInt(move _5) -> [0: bb2, otherwise: bb1];
    }

    bb13: {
        _10 = init::Shell::bash;
        _0 = Result::<init::Shell, std::string::String>::Ok(move _10);
        goto -> bb38;
    }

    bb14: {
        switchInt(move _6) -> [0: bb2, otherwise: bb13];
    }

    bb15: {
        switchInt(move _8) -> [0: bb16, otherwise: bb13];
    }

    bb16: {
        _4 = <str as PartialEq>::eq(_1, const "fish") -> [return: bb11, unwind continue];
    }

    bb17: {
        _15 = init::Shell::fish;
        _0 = Result::<init::Shell, std::string::String>::Ok(move _15);
        goto -> bb38;
    }

    bb18: {
        switchInt(move _11) -> [0: bb4, otherwise: bb17];
    }

    bb19: {
        switchInt(move _13) -> [0: bb20, otherwise: bb17];
    }

    bb20: {
        _3 = <str as PartialEq>::eq(_1, const "posix") -> [return: bb10, unwind continue];
    }

    bb21: {
        _20 = init::Shell::posix;
        _0 = Result::<init::Shell, std::string::String>::Ok(move _20);
        goto -> bb38;
    }

    bb22: {
        switchInt(move _16) -> [0: bb6, otherwise: bb21];
    }

    bb23: {
        switchInt(move _18) -> [0: bb24, otherwise: bb21];
    }

    bb24: {
        _2 = <str as PartialEq>::eq(_1, const "zsh") -> [return: bb9, unwind continue];
    }

    bb25: {
        _25 = init::Shell::zsh;
        _0 = Result::<init::Shell, std::string::String>::Ok(move _25);
        goto -> bb38;
    }

    bb26: {
        switchInt(move _21) -> [0: bb8, otherwise: bb25];
    }

    bb27: {
        switchInt(move _23) -> [0: bb28, otherwise: bb25];
    }

    bb28: {
        _29 = SizeOf([&str; 4]);
        _30 = AlignOf([&str; 4]);
        _31 = alloc::alloc::exchange_malloc(move _29, move _30) -> [return: bb29, unwind continue];
    }

    bb29: {
        _32 = ShallowInitBox(move _31, [&str; 4]);
        _33 = const "fish";
        _34 = const "posix";
        _35 = const "zsh";
        _49 = (((_32.0: std::ptr::Unique<[&str; 4]>).0: std::ptr::NonNull<[&str; 4]>).0: *const [&str; 4]);
        _50 = _49 as *const () (PtrToPtr);
        _51 = _50 as usize (Transmute);
        _52 = AlignOf([&str; 4]);
        _53 = Sub(_52, const 1_usize);
        _54 = BitAnd(_51, _53);
        _55 = Eq(_54, const 0_usize);
        assert(_55, "misaligned pointer dereference: address must be a multiple of {} but is {}", _52, _51) -> [success: bb43, unwind unreachable];
    }

    bb30: {
        _48 = const _;
        _38 = _48 as &[&str] (PointerCoercion(Unsize));
        _46 = &_27;
        _45 = <Vec<&str> as Deref>::deref(move _46) -> [return: bb31, unwind: bb41];
    }

    bb31: {
        _47 = const ", ";
        _44 = slice::<impl [&str]>::join::<&str>(_45, _47) -> [return: bb32, unwind: bb41];
    }

    bb32: {
        _43 = &_44;
        _42 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_43) -> [return: bb33, unwind: bb40];
    }

    bb33: {
        _41 = [move _42];
        _40 = &_41;
        _39 = _40 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _37 = Arguments::<'_>::new_v1(move _38, move _39) -> [return: bb34, unwind: bb40];
    }

    bb34: {
        _36 = format(move _37) -> [return: bb35, unwind: bb40];
    }

    bb35: {
        drop(_44) -> [return: bb36, unwind: bb39];
    }

    bb36: {
        _26 = move _36;
        drop(_27) -> [return: bb37, unwind continue];
    }

    bb37: {
        _0 = Result::<init::Shell, std::string::String>::Err(move _26);
        goto -> bb38;
    }

    bb38: {
        return;
    }

    bb39 (cleanup): {
        drop(_36) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        drop(_44) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_27) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        resume;
    }

    bb43: {
        (*_49) = [const "bash", _33, _34, _35];
        _28 = move _32 as std::boxed::Box<[&str]> (PointerCoercion(Unsize));
        _27 = slice::<impl [&str]>::into_vec::<std::alloc::Global>(move _28) -> [return: bb30, unwind continue];
    }
}

promoted[0] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:313:9: 313:40>::from_str: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "valid values: "];
        _0 = &_1;
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt(_1: &init::Shell, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: std::fmt::Arguments<'_>;
    let mut _9: &[&str];
    let mut _10: std::fmt::Arguments<'_>;
    let mut _11: &[&str];
    let mut _12: &[&str; 1];
    let mut _13: &[&str; 1];
    let mut _14: &[&str; 1];
    let mut _15: &[&str; 1];

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb5, 2: bb7, 3: bb1, otherwise: bb2];
    }

    bb1: {
        _12 = const _;
        _11 = _12 as &[&str] (PointerCoercion(Unsize));
        _10 = Arguments::<'_>::new_const(move _11) -> [return: bb9, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _15 = const _;
        _5 = _15 as &[&str] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_const(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb10, unwind continue];
    }

    bb5: {
        _14 = const _;
        _7 = _14 as &[&str] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_const(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb10, unwind continue];
    }

    bb7: {
        _13 = const _;
        _9 = _13 as &[&str] (PointerCoercion(Unsize));
        _8 = Arguments::<'_>::new_const(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = Formatter::<'_>::write_fmt(_2, move _8) -> [return: bb10, unwind continue];
    }

    bb9: {
        _0 = Formatter::<'_>::write_fmt(_2, move _10) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

promoted[0] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "zsh"];
        _0 = &_1;
        return;
    }
}

promoted[1] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "posix"];
        _0 = &_1;
        return;
    }
}

promoted[2] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "fish"];
        _0 = &_1;
        return;
    }
}

promoted[3] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "bash"];
        _0 = &_1;
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:339:9: 339:16>::variants() -> [&str; 4] {
    let mut _0: [&str; 4];

    bb0: {
        _0 = [const "bash", const "fish", const "posix", const "zsh"];
        return;
    }
}

init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:339:9: 339:16>::variants::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: usize;
    let mut _2: usize;
    let mut _3: (usize, bool);
    let mut _4: (usize, bool);
    let mut _5: (usize, bool);

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _3 = CheckedAdd(const 1_usize, const 1_usize);
        assert(!move (_3.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, const 1_usize) -> [success: bb1, unwind continue];
    }

    bb1: {
        _2 = move (_3.0: usize);
        _4 = CheckedAdd(const 1_usize, _2);
        assert(!move (_4.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, move _2) -> [success: bb2, unwind continue];
    }

    bb2: {
        _1 = move (_4.0: usize);
        StorageDead(_2);
        _5 = CheckedAdd(const 1_usize, _1);
        assert(!move (_5.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, move _1) -> [success: bb3, unwind continue];
    }

    bb3: {
        _0 = move (_5.0: usize);
        StorageDead(_1);
        return;
    }
}

fn init::<impl at src/subcommand/init.rs:74:14: 74:19>::fmt(_1: &Hook, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "pwd";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "none";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "prompt";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:313:9: 313:40>::from_str(_1: &str) -> Result<Hook, std::string::String> {
    debug s => _1;
    let mut _0: std::result::Result<subcommand::init::Hook, std::string::String>;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let _6: &str;
    let mut _7: bool;
    let _8: &str;
    let mut _9: subcommand::init::Hook;
    let mut _10: bool;
    let _11: &str;
    let mut _12: bool;
    let _13: &str;
    let mut _14: subcommand::init::Hook;
    let mut _15: bool;
    let _16: &str;
    let mut _17: bool;
    let _18: &str;
    let mut _19: subcommand::init::Hook;
    let mut _20: std::string::String;
    let _21: std::vec::Vec<&str>;
    let mut _22: std::boxed::Box<[&str]>;
    let mut _23: usize;
    let mut _24: usize;
    let mut _25: *mut u8;
    let mut _26: std::boxed::Box<[&str; 3]>;
    let _27: &str;
    let _28: &str;
    let mut _30: std::fmt::Arguments<'_>;
    let mut _31: &[&str];
    let mut _32: &[core::fmt::rt::Argument<'_>];
    let _33: &[core::fmt::rt::Argument<'_>; 1];
    let _34: [core::fmt::rt::Argument<'_>; 1];
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &std::string::String;
    let _37: std::string::String;
    let _38: &[&str];
    let mut _39: &std::vec::Vec<&str>;
    let _40: &str;
    let mut _42: *const [&str; 3];
    let mut _43: *const ();
    let mut _44: usize;
    let mut _45: usize;
    let mut _46: usize;
    let mut _47: usize;
    let mut _48: bool;
    scope 1 {
        debug v => _21;
        let _29: std::string::String;
        let mut _41: &[&str; 1];
        scope 3 {
            debug res => _29;
        }
    }
    scope 2 {
    }

    bb0: {
        _4 = <str as PartialEq>::eq(_1, const "none") -> [return: bb9, unwind continue];
    }

    bb1: {
        _6 = const "none";
        _5 = core::str::<impl str>::eq_ignore_ascii_case(_1, _6) -> [return: bb11, unwind continue];
    }

    bb2: {
        _8 = const "none";
        _7 = core::str::<impl str>::eq_ignore_ascii_case(_1, _8) -> [return: bb12, unwind continue];
    }

    bb3: {
        _11 = const "prompt";
        _10 = core::str::<impl str>::eq_ignore_ascii_case(_1, _11) -> [return: bb15, unwind continue];
    }

    bb4: {
        _13 = const "prompt";
        _12 = core::str::<impl str>::eq_ignore_ascii_case(_1, _13) -> [return: bb16, unwind continue];
    }

    bb5: {
        _16 = const "pwd";
        _15 = core::str::<impl str>::eq_ignore_ascii_case(_1, _16) -> [return: bb19, unwind continue];
    }

    bb6: {
        _18 = const "pwd";
        _17 = core::str::<impl str>::eq_ignore_ascii_case(_1, _18) -> [return: bb20, unwind continue];
    }

    bb7: {
        switchInt(move _2) -> [0: bb6, otherwise: bb5];
    }

    bb8: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb9: {
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb10: {
        _9 = Hook::none;
        _0 = Result::<Hook, std::string::String>::Ok(move _9);
        goto -> bb31;
    }

    bb11: {
        switchInt(move _5) -> [0: bb2, otherwise: bb10];
    }

    bb12: {
        switchInt(move _7) -> [0: bb13, otherwise: bb10];
    }

    bb13: {
        _3 = <str as PartialEq>::eq(_1, const "prompt") -> [return: bb8, unwind continue];
    }

    bb14: {
        _14 = Hook::prompt;
        _0 = Result::<Hook, std::string::String>::Ok(move _14);
        goto -> bb31;
    }

    bb15: {
        switchInt(move _10) -> [0: bb4, otherwise: bb14];
    }

    bb16: {
        switchInt(move _12) -> [0: bb17, otherwise: bb14];
    }

    bb17: {
        _2 = <str as PartialEq>::eq(_1, const "pwd") -> [return: bb7, unwind continue];
    }

    bb18: {
        _19 = Hook::pwd;
        _0 = Result::<Hook, std::string::String>::Ok(move _19);
        goto -> bb31;
    }

    bb19: {
        switchInt(move _15) -> [0: bb6, otherwise: bb18];
    }

    bb20: {
        switchInt(move _17) -> [0: bb21, otherwise: bb18];
    }

    bb21: {
        _23 = SizeOf([&str; 3]);
        _24 = AlignOf([&str; 3]);
        _25 = alloc::alloc::exchange_malloc(move _23, move _24) -> [return: bb22, unwind continue];
    }

    bb22: {
        _26 = ShallowInitBox(move _25, [&str; 3]);
        _27 = const "prompt";
        _28 = const "pwd";
        _42 = (((_26.0: std::ptr::Unique<[&str; 3]>).0: std::ptr::NonNull<[&str; 3]>).0: *const [&str; 3]);
        _43 = _42 as *const () (PtrToPtr);
        _44 = _43 as usize (Transmute);
        _45 = AlignOf([&str; 3]);
        _46 = Sub(_45, const 1_usize);
        _47 = BitAnd(_44, _46);
        _48 = Eq(_47, const 0_usize);
        assert(_48, "misaligned pointer dereference: address must be a multiple of {} but is {}", _45, _44) -> [success: bb36, unwind unreachable];
    }

    bb23: {
        _41 = const _;
        _31 = _41 as &[&str] (PointerCoercion(Unsize));
        _39 = &_21;
        _38 = <Vec<&str> as Deref>::deref(move _39) -> [return: bb24, unwind: bb34];
    }

    bb24: {
        _40 = const ", ";
        _37 = slice::<impl [&str]>::join::<&str>(_38, _40) -> [return: bb25, unwind: bb34];
    }

    bb25: {
        _36 = &_37;
        _35 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_36) -> [return: bb26, unwind: bb33];
    }

    bb26: {
        _34 = [move _35];
        _33 = &_34;
        _32 = _33 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _30 = Arguments::<'_>::new_v1(move _31, move _32) -> [return: bb27, unwind: bb33];
    }

    bb27: {
        _29 = format(move _30) -> [return: bb28, unwind: bb33];
    }

    bb28: {
        drop(_37) -> [return: bb29, unwind: bb32];
    }

    bb29: {
        _20 = move _29;
        drop(_21) -> [return: bb30, unwind continue];
    }

    bb30: {
        _0 = Result::<Hook, std::string::String>::Err(move _20);
        goto -> bb31;
    }

    bb31: {
        return;
    }

    bb32 (cleanup): {
        drop(_29) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_37) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        drop(_21) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        (*_42) = [const "none", _27, _28];
        _22 = move _26 as std::boxed::Box<[&str]> (PointerCoercion(Unsize));
        _21 = slice::<impl [&str]>::into_vec::<std::alloc::Global>(move _22) -> [return: bb23, unwind continue];
    }
}

promoted[0] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:313:9: 313:40>::from_str: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "valid values: "];
        _0 = &_1;
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt(_1: &Hook, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: std::fmt::Arguments<'_>;
    let mut _9: &[&str];
    let mut _10: &[&str; 1];
    let mut _11: &[&str; 1];
    let mut _12: &[&str; 1];

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb5, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _10 = const _;
        _9 = _10 as &[&str] (PointerCoercion(Unsize));
        _8 = Arguments::<'_>::new_const(move _9) -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _12 = const _;
        _5 = _12 as &[&str] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_const(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Formatter::<'_>::write_fmt(_2, move _4) -> [return: bb8, unwind continue];
    }

    bb5: {
        _11 = const _;
        _7 = _11 as &[&str] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_const(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _0 = Formatter::<'_>::write_fmt(_2, move _6) -> [return: bb8, unwind continue];
    }

    bb7: {
        _0 = Formatter::<'_>::write_fmt(_2, move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

promoted[0] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "pwd"];
        _0 = &_1;
        return;
    }
}

promoted[1] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "prompt"];
        _0 = &_1;
        return;
    }
}

promoted[2] in init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:332:9: 332:40>::fmt: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "none"];
        _0 = &_1;
        return;
    }
}

fn init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:339:9: 339:16>::variants() -> [&str; 3] {
    let mut _0: [&str; 3];

    bb0: {
        _0 = [const "none", const "prompt", const "pwd"];
        return;
    }
}

init::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/clap-2.33.0/src/macros.rs:339:9: 339:16>::variants::{constant#0}: usize = {
    let mut _0: usize;
    let mut _1: usize;
    let mut _2: (usize, bool);
    let mut _3: (usize, bool);

    bb0: {
        StorageLive(_1);
        _2 = CheckedAdd(const 1_usize, const 1_usize);
        assert(!move (_2.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, const 1_usize) -> [success: bb1, unwind continue];
    }

    bb1: {
        _1 = move (_2.0: usize);
        _3 = CheckedAdd(const 1_usize, _1);
        assert(!move (_3.1: bool), "attempt to compute `{} + {}`, which would overflow", const 1_usize, move _1) -> [success: bb2, unwind continue];
    }

    bb2: {
        _0 = move (_3.0: usize);
        StorageDead(_1);
        return;
    }
}

const BASH_CONFIG: ShellConfig = {
    let mut _0: subcommand::init::ShellConfig;
    let mut _1: subcommand::init::HookConfig;
    let mut _2: std::option::Option<&str>;
    let mut _3: &str;
    let _4: &str;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = const _;
        _3 = &(*_4);
        _2 = std::option::Option::<&str>::Some(move _3);
        StorageDead(_3);
        _1 = HookConfig { prompt: const _, pwd: move _2 };
        StorageDead(_2);
        _0 = ShellConfig { z: const _, alias: const _, hook: move _1 };
        StorageDead(_4);
        StorageDead(_1);
        return;
    }
}

const FISH_CONFIG: ShellConfig = {
    let mut _0: subcommand::init::ShellConfig;
    let mut _1: subcommand::init::HookConfig;
    let mut _2: std::option::Option<&str>;
    let mut _3: &str;
    let _4: &str;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = const _;
        _3 = &(*_4);
        _2 = std::option::Option::<&str>::Some(move _3);
        StorageDead(_3);
        _1 = HookConfig { prompt: const _, pwd: move _2 };
        StorageDead(_2);
        _0 = ShellConfig { z: const _, alias: const _, hook: move _1 };
        StorageDead(_4);
        StorageDead(_1);
        return;
    }
}

const POSIX_CONFIG: ShellConfig = {
    let mut _0: subcommand::init::ShellConfig;
    let mut _1: subcommand::init::HookConfig;
    let mut _2: std::option::Option<&str>;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        _2 = std::option::Option::<&str>::None;
        _1 = HookConfig { prompt: const _, pwd: move _2 };
        StorageDead(_2);
        _0 = ShellConfig { z: const _, alias: const _, hook: move _1 };
        StorageDead(_1);
        return;
    }
}

const ZSH_CONFIG: ShellConfig = {
    let mut _0: subcommand::init::ShellConfig;
    let mut _1: subcommand::init::HookConfig;
    let mut _2: std::option::Option<&str>;
    let mut _3: &str;
    let _4: &str;

    bb0: {
        StorageLive(_1);
        StorageLive(_2);
        StorageLive(_3);
        StorageLive(_4);
        _4 = const _;
        _3 = &(*_4);
        _2 = std::option::Option::<&str>::Some(move _3);
        StorageDead(_3);
        _1 = HookConfig { prompt: const _, pwd: move _2 };
        StorageDead(_2);
        _0 = ShellConfig { z: const _, alias: const _, hook: move _1 };
        StorageDead(_4);
        StorageDead(_1);
        return;
    }
}

const BASH_Z: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_z_cd() {\n    cd \"$@\" || return \"$?\"\n\n    if [ -n \"$_ZO_ECHO\" ]; then\n        echo \"$PWD\"\n    fi\n}\n\nz() {\n    if [ \"$#\" -eq 0 ]; then\n        _z_cd ~ || return \"$?\"\n    elif [ \"$#\" -eq 1 ] && [ \"$1\" = '-' ]; then\n        if [ -n \"$OLDPWD\" ]; then\n            _z_cd \"$OLDPWD\" || return \"$?\"\n        else\n            echo \"zoxide: \\$OLDPWD is not set\"\n            return 1\n        fi\n    else\n        result=\"$(zoxide query \"$@\")\" || return \"$?\"\n        case \"$result\" in\n            \"query: \"*)\n                _z_cd \"${result#query: }\" || return \"$?\"\n                ;;\n            *)\n                if [ -n \"$result\" ]; then\n                    echo \"$result\"\n                fi\n                ;;\n        esac\n    fi\n}\n";
        return;
    }
}

const FISH_Z: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nfunction _z_cd\n    cd \"$argv\"\n    or return \"$status\"\n\n    commandline -f repaint\n\n    if [ -n \"$_ZO_ECHO\" ]\n        echo \"$PWD\"\n    end\nend\n\nfunction z\n    set argc (count \"$argv\")\n\n    if [ \"$argc\" -eq 0 ]\n        _z_cd \"$HOME\"\n        or return \"$status\"\n\n    else if [ \"$argc\" -eq 1 ]; and [ \"$argv[1]\" = '-' ]\n        _z_cd '-'\n        or return \"$status\"\n\n    else\n        # TODO: use string-collect from fish 3.1.0 once it has wider adoption\n        set -l IFS ''\n        set -l result (zoxide query $argv)\n\n        switch \"$result\"\n            case 'query: *'\n                _z_cd (string sub -s 8 \"$result\")\n                or return \"$status\"\n            case '*'\n                if [ -n \"$result\" ]\n                    echo \"$result\"\n                end\n        end\n    end\nend\n";
        return;
    }
}

const POSIX_Z: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const _;
        return;
    }
}

const ZSH_Z: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const _;
        return;
    }
}

const BASH_ALIAS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nalias zi='z -i'\nalias za='zoxide add'\nalias zq='zoxide query'\nalias zr='zoxide remove'\n";
        return;
    }
}

const FISH_ALIAS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nabbr -a zi 'z -i'\nabbr -a za 'zoxide add'\nabbr -a zq 'zoxide query'\nabbr -a zr 'zoxide remove'\n";
        return;
    }
}

const POSIX_ALIAS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const _;
        return;
    }
}

const ZSH_ALIAS: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const _;
        return;
    }
}

const BASH_HOOK_PROMPT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_zoxide_hook() {\n    zoxide add\n}\n\ncase \"$PROMPT_COMMAND\" in\n    *_zoxide_hook*) ;;\n    *) PROMPT_COMMAND=\"_zoxide_hook${PROMPT_COMMAND:+;${PROMPT_COMMAND}}\" ;;\nesac\n";
        return;
    }
}

const FISH_HOOK_PROMPT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nfunction _zoxide_hook --on-event fish_prompt\n    zoxide add\nend\n";
        return;
    }
}

const POSIX_HOOK_PROMPT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_zoxide_hook() {\n    zoxide add > /dev/null\n}\n\ncase \"$PS1\" in\n    *\\$\\(_zoxide_hook\\)*) ;;\n    *) PS1=\"\\$(_zoxide_hook)${PS1}\" ;;\nesac\n";
        return;
    }
}

const ZSH_HOOK_PROMPT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_zoxide_hook() {\n    zoxide add\n}\n\n[[ -n \"${precmd_functions[(r)_zoxide_hook]}\" ]] || {\n    precmd_functions+=(_zoxide_hook)\n}\n";
        return;
    }
}

const BASH_HOOK_PWD: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_zoxide_hook() {\n    if [ -z \"${_ZO_PWD}\" ]; then\n        _ZO_PWD=\"${PWD}\"\n    elif [ \"${_ZO_PWD}\" != \"${PWD}\" ]; then\n        _ZO_PWD=\"${PWD}\"\n        zoxide add\n    fi\n}\n\ncase \"$PROMPT_COMMAND\" in\n    *_zoxide_hook*) ;;\n    *) PROMPT_COMMAND=\"_zoxide_hook${PROMPT_COMMAND:+;${PROMPT_COMMAND}}\" ;;\nesac\n";
        return;
    }
}

const FISH_HOOK_PWD: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nfunction _zoxide_hook --on-variable PWD\n    zoxide add\nend\n";
        return;
    }
}

const ZSH_HOOK_PWD: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n_zoxide_hook() {\n    zoxide add\n}\n\nchpwd_functions=(${chpwd_functions[@]} \"_zoxide_hook\")\n";
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:10: 9:15>::fmt(_1: &Query, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &std::vec::Vec<std::string::String>;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&bool;
    let _10: &bool;

    bb0: {
        _3 = const "Query";
        _4 = const "keywords";
        _6 = &((*_1).0: std::vec::Vec<std::string::String>);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "interactive";
        _10 = &((*_1).1: bool);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _1 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <Query as StructOptInternal>::augment_clap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::from_clap(_1: &ArgMatches<'_>) -> Query {
    debug matches => _1;
    let mut _0: subcommand::query::Query;
    let mut _2: std::vec::Vec<std::string::String>;
    let mut _3: std::option::Option<clap::Values<'_>>;
    let mut _4: bool;

    bb0: {
        _3 = ArgMatches::<'_>::values_of::<&str>(_1, const "keywords") -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = std::option::Option::<clap::Values<'_>>::map_or_else::<Vec<std::string::String>, fn() -> Vec<std::string::String> {Vec::<std::string::String>::new}, {closure@src/subcommand/query.rs:12:15: 12:18}>(move _3, Vec::<std::string::String>::new, const ZeroSized: {closure@src/subcommand/query.rs:12:15: 12:18}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = ArgMatches::<'_>::is_present::<&str>(_1, const "interactive") -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = Query { keywords: move _2, interactive: move _4 };
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::from_clap::{closure#0}(_1: {closure@src/subcommand/query.rs:12:15: 12:18}, _2: clap::Values<'_>) -> Vec<std::string::String> {
    debug v => _2;
    let mut _0: std::vec::Vec<std::string::String>;
    let mut _3: std::iter::Map<clap::Values<'_>, {closure@src/subcommand/query.rs:12:5: 12:13}>;

    bb0: {
        _3 = <clap::Values<'_> as Iterator>::map::<std::string::String, {closure@src/subcommand/query.rs:12:5: 12:13}>(move _2, const ZeroSized: {closure@src/subcommand/query.rs:12:5: 12:13}) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <std::iter::Map<clap::Values<'_>, {closure@src/subcommand/query.rs:12:5: 12:13}> as Iterator>::collect::<Vec<std::string::String>>(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::from_clap::{closure#0}::{closure#0}(_1: &mut {closure@src/subcommand/query.rs:12:5: 12:13}, _2: &str) -> std::string::String {
    debug s => _2;
    let mut _0: std::string::String;
    let mut _3: std::result::Result<std::string::String, std::convert::Infallible>;

    bb0: {
        _3 = <std::string::String as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<std::string::String, Infallible>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let _9: &str;
    let mut _11: clap::App<'_, '_>;
    let mut _12: clap::Arg<'_, '_>;
    let mut _13: clap::Arg<'_, '_>;
    let mut _14: clap::Arg<'_, '_>;
    let mut _15: clap::Arg<'_, '_>;
    let mut _16: clap::Arg<'_, '_>;
    let mut _17: clap::Arg<'_, '_>;
    let _18: &str;
    let _19: &str;
    let _20: &str;
    let mut _21: bool;
    let mut _22: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
            let _10: clap::App<'_, '_>;
            scope 3 {
                debug app => _10;
            }
        }
    }

    bb0: {
        _22 = const false;
        _21 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "Search for a directory") -> [return: bb1, unwind continue];
    }

    bb1: {
        _22 = const true;
        _4 = move _2;
        _9 = const "keywords";
        _8 = Arg::<'_, '_>::with_name(_9) -> [return: bb2, unwind: bb19];
    }

    bb2: {
        _7 = Arg::<'_, '_>::takes_value(move _8, const true) -> [return: bb3, unwind: bb19];
    }

    bb3: {
        _6 = Arg::<'_, '_>::multiple(move _7, const true) -> [return: bb4, unwind: bb19];
    }

    bb4: {
        _5 = Arg::<'_, '_>::validator::<{closure@src/subcommand/query.rs:12:5: 12:13}>(move _6, const ZeroSized: {closure@src/subcommand/query.rs:12:5: 12:13}) -> [return: bb5, unwind: bb19];
    }

    bb5: {
        _22 = const false;
        _3 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _4, move _5) -> [return: bb6, unwind: bb19];
    }

    bb6: {
        _22 = const false;
        _21 = const true;
        _11 = move _3;
        _18 = const "interactive";
        _17 = Arg::<'_, '_>::with_name(_18) -> [return: bb7, unwind: bb17];
    }

    bb7: {
        _16 = Arg::<'_, '_>::takes_value(move _17, const false) -> [return: bb8, unwind: bb17];
    }

    bb8: {
        _15 = Arg::<'_, '_>::multiple(move _16, const false) -> [return: bb9, unwind: bb17];
    }

    bb9: {
        _14 = Arg::<'_, '_>::short::<&str>(move _15, const "interactive") -> [return: bb10, unwind: bb17];
    }

    bb10: {
        _19 = const "interactive";
        _13 = Arg::<'_, '_>::long(move _14, _19) -> [return: bb11, unwind: bb17];
    }

    bb11: {
        _20 = const "Opens an interactive selection menu using fzf";
        _12 = Arg::<'_, '_>::help(move _13, _20) -> [return: bb12, unwind: bb17];
    }

    bb12: {
        _21 = const false;
        _10 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _11, move _12) -> [return: bb13, unwind: bb17];
    }

    bb13: {
        _21 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _10, const "0.3.0") -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        resume;
    }

    bb16 (cleanup): {
        drop(_11) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        switchInt(_21) -> [0: bb15, otherwise: bb16];
    }

    bb18 (cleanup): {
        drop(_4) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        switchInt(_22) -> [0: bb15, otherwise: bb18];
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::augment_clap::{closure#0}(_1: &{closure@src/subcommand/query.rs:12:5: 12:13}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::convert::Infallible>;
    let mut _4: std::result::Result<std::string::String, std::convert::Infallible>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <std::string::String as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<std::string::String, Infallible>::map::<(), {closure@src/subcommand/query.rs:12:5: 12:13}>(move _4, const ZeroSized: {closure@src/subcommand/query.rs:12:5: 12:13}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), Infallible>::map_err::<std::string::String, {closure@src/subcommand/query.rs:12:5: 12:13}>(const Result::<(), Infallible>::Ok(()), const ZeroSized: {closure@src/subcommand/query.rs:12:5: 12:13}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::augment_clap::{closure#0}::{closure#0}(_1: {closure@src/subcommand/query.rs:12:5: 12:13}, _2: std::string::String) -> () {
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::augment_clap::{closure#0}::{closure#1}(_1: {closure@src/subcommand/query.rs:12:5: 12:13}, _2: Infallible) -> std::string::String {
    debug e => const ZeroSized: Infallible;
    let mut _0: std::string::String;
    let mut _3: &std::convert::Infallible;

    bb0: {
        _3 = &_2;
        _0 = <Infallible as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:9:17: 9:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn query::<impl at src/subcommand/query.rs:17:1: 17:11>::run(_1: Query) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let _2: std::option::Option<std::vec::Vec<u8>>;
    let mut _3: bool;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::option::Option<std::vec::Vec<u8>>>;
    let mut _5: std::result::Result<std::option::Option<std::vec::Vec<u8>>, anyhow::Error>;
    let mut _6: &mut subcommand::query::Query;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _9: std::option::Option<std::vec::Vec<u8>>;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::option::Option<std::vec::Vec<u8>>>;
    let mut _11: std::result::Result<std::option::Option<std::vec::Vec<u8>>, anyhow::Error>;
    let mut _12: &mut subcommand::query::Query;
    let mut _13: isize;
    let _14: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _15: std::option::Option<std::vec::Vec<u8>>;
    let mut _16: isize;
    let mut _20: &std::io::Stdout;
    let _21: ();
    let mut _22: std::result::Result<(), std::io::Error>;
    let mut _23: &mut std::io::StdoutLock<'_>;
    let mut _24: &[u8];
    let _25: &[u8; 7];
    let _26: ();
    let mut _27: std::result::Result<(), std::io::Error>;
    let mut _28: &mut std::io::StdoutLock<'_>;
    let _29: &[u8];
    let _30: &std::vec::Vec<u8>;
    let _31: ();
    let mut _32: std::result::Result<(), std::io::Error>;
    let mut _33: &mut std::io::StdoutLock<'_>;
    let mut _34: &[u8];
    let _35: &[u8; 1];
    let mut _36: anyhow::Error;
    scope 1 {
        debug path_opt => _2;
        let _17: std::vec::Vec<u8>;
        scope 10 {
            debug path => _17;
            let _18: std::io::Stdout;
            scope 11 {
                debug stdout => _18;
                let mut _19: std::io::StdoutLock<'_>;
                scope 12 {
                    debug handle => _19;
                }
            }
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }
    scope 6 {
        debug residual => _14;
        scope 7 {
        }
    }
    scope 8 {
        debug val => _15;
        scope 9 {
        }
    }

    bb0: {
        _3 = (_1.1: bool);
        switchInt(move _3) -> [0: bb7, otherwise: bb1];
    }

    bb1: {
        _6 = &mut _1;
        _5 = Query::query_interactive(move _6) -> [return: bb2, unwind: bb31];
    }

    bb2: {
        _4 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as Try>::branch(move _5) -> [return: bb3, unwind: bb31];
    }

    bb3: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _9 = move ((_4 as Continue).0: std::option::Option<std::vec::Vec<u8>>);
        _2 = move _9;
        goto -> bb12;
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _8) -> [return: bb33, unwind: bb31];
    }

    bb7: {
        _12 = &mut _1;
        _11 = Query::query(move _12) -> [return: bb8, unwind: bb31];
    }

    bb8: {
        _10 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as Try>::branch(move _11) -> [return: bb9, unwind: bb31];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb5];
    }

    bb10: {
        _15 = move ((_10 as Continue).0: std::option::Option<std::vec::Vec<u8>>);
        _2 = move _15;
        goto -> bb12;
    }

    bb11: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _14) -> [return: bb34, unwind: bb31];
    }

    bb12: {
        _16 = discriminant(_2);
        switchInt(move _16) -> [0: bb13, 1: bb14, otherwise: bb5];
    }

    bb13: {
        _36 = new_adhoc::<&str>(const "no match found") -> [return: bb26, unwind: bb31];
    }

    bb14: {
        _17 = move ((_2 as Some).0: std::vec::Vec<u8>);
        _18 = stdout() -> [return: bb15, unwind: bb30];
    }

    bb15: {
        _20 = &_18;
        _19 = Stdout::lock(move _20) -> [return: bb16, unwind: bb30];
    }

    bb16: {
        _23 = &mut _19;
        _25 = const b"query: ";
        _24 = _25 as &[u8] (PointerCoercion(Unsize));
        _22 = <StdoutLock<'_> as std::io::Write>::write_all(move _23, move _24) -> [return: bb17, unwind: bb29];
    }

    bb17: {
        _21 = Result::<(), std::io::Error>::unwrap(move _22) -> [return: bb18, unwind: bb29];
    }

    bb18: {
        _28 = &mut _19;
        _30 = &_17;
        _29 = <Vec<u8> as Deref>::deref(_30) -> [return: bb19, unwind: bb29];
    }

    bb19: {
        _27 = <StdoutLock<'_> as std::io::Write>::write_all(move _28, _29) -> [return: bb20, unwind: bb29];
    }

    bb20: {
        _26 = Result::<(), std::io::Error>::unwrap(move _27) -> [return: bb21, unwind: bb29];
    }

    bb21: {
        _33 = &mut _19;
        _35 = const b"\n";
        _34 = _35 as &[u8] (PointerCoercion(Unsize));
        _32 = <StdoutLock<'_> as std::io::Write>::write_all(move _33, move _34) -> [return: bb22, unwind: bb29];
    }

    bb22: {
        _31 = Result::<(), std::io::Error>::unwrap(move _32) -> [return: bb23, unwind: bb29];
    }

    bb23: {
        drop(_19) -> [return: bb24, unwind: bb30];
    }

    bb24: {
        drop(_17) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        drop(_1) -> [return: bb28, unwind continue];
    }

    bb26: {
        _0 = Result::<(), anyhow::Error>::Err(move _36);
        goto -> bb27;
    }

    bb27: {
        drop(_1) -> [return: bb28, unwind continue];
    }

    bb28: {
        return;
    }

    bb29 (cleanup): {
        drop(_19) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        drop(_17) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        drop(_1) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        goto -> bb27;
    }

    bb34: {
        goto -> bb27;
    }
}

alloc4 (size: 1, align: 1) {
    0a                                              │ .
}

alloc3 (size: 7, align: 1) {
    71 75 65 72 79 3a 20                            │ query: 
}

fn query::<impl at src/subcommand/query.rs:17:1: 17:11>::query(_1: &mut Query) -> Result<std::option::Option<Vec<u8>>, anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::vec::Vec<u8>>, anyhow::Error>;
    let mut _2: &[std::string::String];
    let mut _3: &std::vec::Vec<std::string::String>;
    let mut _4: usize;
    let mut _5: usize;
    let mut _6: bool;
    let mut _8: bool;
    let _9: &std::path::Path;
    let mut _10: std::option::Option<std::vec::Vec<u8>>;
    let mut _11: std::vec::Vec<u8>;
    let _12: &[u8];
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, i64>;
    let mut _14: std::result::Result<i64, anyhow::Error>;
    let mut _15: isize;
    let _16: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _17: i64;
    let mut _18: std::slice::IterMut<'_, std::string::String>;
    let mut _19: &mut std::vec::Vec<std::string::String>;
    let mut _21: std::option::Option<&mut std::string::String>;
    let mut _22: &mut std::slice::IterMut<'_, std::string::String>;
    let mut _23: isize;
    let mut _25: std::string::String;
    let _26: &str;
    let mut _27: &std::string::String;
    let mut _29: std::option::Option<dir::Dir>;
    let mut _30: &mut db::DB;
    let mut _31: db::DB;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DB>;
    let mut _33: std::result::Result<db::DB, anyhow::Error>;
    let mut _34: isize;
    let _37: &[std::string::String];
    let _38: &std::vec::Vec<std::string::String>;
    let mut _39: std::option::Option<std::vec::Vec<u8>>;
    scope 1 {
        debug path => _7;
        let _7: &std::string::String;
    }
    scope 2 {
        debug now => _17;
        let mut _20: std::slice::IterMut<'_, std::string::String>;
        let _28: std::option::Option<std::vec::Vec<u8>>;
        let _35: std::result::Result<std::convert::Infallible, anyhow::Error>;
        let _36: db::DB;
        scope 7 {
            debug iter => _20;
            let _24: &mut std::string::String;
            scope 8 {
                debug keyword => _24;
            }
        }
        scope 9 {
            debug path_opt => _28;
        }
        scope 10 {
            debug residual => _35;
            scope 11 {
            }
        }
        scope 12 {
            debug val => _36;
            scope 13 {
            }
        }
    }
    scope 3 {
        debug residual => _16;
        scope 4 {
        }
    }
    scope 5 {
        debug val => _17;
        scope 6 {
        }
    }

    bb0: {
        _3 = &((*_1).0: std::vec::Vec<std::string::String>);
        _2 = Vec::<std::string::String>::as_slice(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = Len((*_2));
        _5 = const 1_usize;
        _6 = Eq(move _4, move _5);
        switchInt(move _6) -> [0: bb8, otherwise: bb2];
    }

    bb2: {
        _7 = &(*_2)[0 of 1];
        _9 = Path::new::<std::string::String>(_7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = Path::is_dir(_9) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _8) -> [0: bb8, otherwise: bb5];
    }

    bb5: {
        _12 = std::string::String::as_bytes(_7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = slice::<impl [u8]>::to_vec(_12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = std::option::Option::<Vec<u8>>::Some(move _11);
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Ok(move _10);
        goto -> bb30;
    }

    bb8: {
        _14 = get_current_time() -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = <Result<i64, anyhow::Error> as Try>::branch(move _14) -> [return: bb10, unwind continue];
    }

    bb10: {
        _15 = discriminant(_13);
        switchInt(move _15) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _17 = ((_13 as Continue).0: i64);
        _19 = &mut ((*_1).0: std::vec::Vec<std::string::String>);
        _18 = <&mut Vec<std::string::String> as IntoIterator>::into_iter(move _19) -> [return: bb14, unwind continue];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _16 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _16) -> [return: bb30, unwind continue];
    }

    bb14: {
        _20 = move _18;
        goto -> bb15;
    }

    bb15: {
        _22 = &mut _20;
        _21 = <std::slice::IterMut<'_, std::string::String> as Iterator>::next(_22) -> [return: bb16, unwind continue];
    }

    bb16: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb18, 1: bb17, otherwise: bb12];
    }

    bb17: {
        _24 = move ((_21 as Some).0: &mut std::string::String);
        _27 = &(*_24);
        _26 = <std::string::String as Deref>::deref(move _27) -> [return: bb19, unwind continue];
    }

    bb18: {
        _33 = get_db() -> [return: bb23, unwind continue];
    }

    bb19: {
        _25 = str::<impl str>::to_lowercase(_26) -> [return: bb20, unwind continue];
    }

    bb20: {
        drop((*_24)) -> [return: bb21, unwind: bb22];
    }

    bb21: {
        (*_24) = move _25;
        goto -> bb15;
    }

    bb22 (cleanup): {
        (*_24) = move _25;
        goto -> bb32;
    }

    bb23: {
        _32 = <Result<DB, anyhow::Error> as Try>::branch(move _33) -> [return: bb24, unwind continue];
    }

    bb24: {
        _34 = discriminant(_32);
        switchInt(move _34) -> [0: bb25, 1: bb26, otherwise: bb12];
    }

    bb25: {
        _36 = move ((_32 as Continue).0: db::DB);
        _31 = move _36;
        _30 = &mut _31;
        _38 = &((*_1).0: std::vec::Vec<std::string::String>);
        _37 = <Vec<std::string::String> as Deref>::deref(_38) -> [return: bb27, unwind: bb31];
    }

    bb26: {
        _35 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _35) -> [return: bb30, unwind continue];
    }

    bb27: {
        _29 = DB::query(move _30, _37, _17) -> [return: bb28, unwind: bb31];
    }

    bb28: {
        _28 = std::option::Option::<Dir>::map::<Vec<u8>, {closure@src/subcommand/query.rs:52:71: 52:76}>(move _29, const ZeroSized: {closure@src/subcommand/query.rs:52:71: 52:76}) -> [return: bb29, unwind: bb31];
    }

    bb29: {
        drop(_31) -> [return: bb33, unwind: bb34];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_31) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        resume;
    }

    bb33: {
        _39 = move _28;
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Ok(move _39);
        goto -> bb30;
    }

    bb34 (cleanup): {
        drop(_28) -> [return: bb32, unwind terminate(cleanup)];
    }
}

fn query::<impl at src/subcommand/query.rs:17:1: 17:11>::query::{closure#0}(_1: {closure@src/subcommand/query.rs:52:71: 52:76}, _2: Dir) -> Vec<u8> {
    debug dir => _2;
    let mut _0: std::vec::Vec<u8>;
    let _3: &[u8];
    let mut _4: std::option::Option<&[u8]>;
    let _5: &std::path::PathBuf;
    scope 1 {
        debug path_bytes => _3;
    }

    bb0: {
        _5 = &(_2.0: std::path::PathBuf);
        _4 = path_to_bytes::<PathBuf>(_5) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _3 = std::option::Option::<&[u8]>::unwrap(move _4) -> [return: bb2, unwind: bb5];
    }

    bb2: {
        _0 = slice::<impl [u8]>::to_vec(_3) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        drop(_2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }

    bb5 (cleanup): {
        drop(_2) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn query::<impl at src/subcommand/query.rs:17:1: 17:11>::query_interactive(_1: &mut Query) -> Result<std::option::Option<Vec<u8>>, anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::vec::Vec<u8>>, anyhow::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, i64>;
    let mut _3: std::result::Result<i64, anyhow::Error>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _6: i64;
    let mut _7: std::slice::IterMut<'_, std::string::String>;
    let mut _8: &mut std::vec::Vec<std::string::String>;
    let mut _10: std::option::Option<&mut std::string::String>;
    let mut _11: &mut std::slice::IterMut<'_, std::string::String>;
    let mut _12: isize;
    let mut _14: std::string::String;
    let _15: &str;
    let mut _16: &std::string::String;
    let mut _18: &mut db::DB;
    let mut _19: db::DB;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DB>;
    let mut _21: std::result::Result<db::DB, anyhow::Error>;
    let mut _22: isize;
    let _25: &[std::string::String];
    let _26: &std::vec::Vec<std::string::String>;
    let mut _27: std::vec::Vec<dir::Dir>;
    let mut _28: bool;
    scope 1 {
        debug now => _6;
        let mut _9: std::slice::IterMut<'_, std::string::String>;
        let _17: std::vec::Vec<dir::Dir>;
        let _23: std::result::Result<std::convert::Infallible, anyhow::Error>;
        let _24: db::DB;
        scope 6 {
            debug iter => _9;
            let _13: &mut std::string::String;
            scope 7 {
                debug keyword => _13;
            }
        }
        scope 8 {
            debug dirs => _17;
        }
        scope 9 {
            debug residual => _23;
            scope 10 {
            }
        }
        scope 11 {
            debug val => _24;
            scope 12 {
            }
        }
    }
    scope 2 {
        debug residual => _5;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _6;
        scope 5 {
        }
    }

    bb0: {
        _28 = const false;
        _3 = get_current_time() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<i64, anyhow::Error> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: i64);
        _8 = &mut ((*_1).0: std::vec::Vec<std::string::String>);
        _7 = <&mut Vec<std::string::String> as IntoIterator>::into_iter(move _8) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _5) -> [return: bb23, unwind continue];
    }

    bb6: {
        _9 = move _7;
        goto -> bb7;
    }

    bb7: {
        _11 = &mut _9;
        _10 = <std::slice::IterMut<'_, std::string::String> as Iterator>::next(_11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb10, 1: bb9, otherwise: bb4];
    }

    bb9: {
        _13 = move ((_10 as Some).0: &mut std::string::String);
        _16 = &(*_13);
        _15 = <std::string::String as Deref>::deref(move _16) -> [return: bb11, unwind continue];
    }

    bb10: {
        _21 = get_db() -> [return: bb15, unwind continue];
    }

    bb11: {
        _14 = str::<impl str>::to_lowercase(_15) -> [return: bb12, unwind continue];
    }

    bb12: {
        drop((*_13)) -> [return: bb13, unwind: bb14];
    }

    bb13: {
        (*_13) = move _14;
        goto -> bb7;
    }

    bb14 (cleanup): {
        (*_13) = move _14;
        goto -> bb25;
    }

    bb15: {
        _20 = <Result<DB, anyhow::Error> as Try>::branch(move _21) -> [return: bb16, unwind continue];
    }

    bb16: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb17, 1: bb18, otherwise: bb4];
    }

    bb17: {
        _24 = move ((_20 as Continue).0: db::DB);
        _19 = move _24;
        _18 = &mut _19;
        _26 = &((*_1).0: std::vec::Vec<std::string::String>);
        _25 = <Vec<std::string::String> as Deref>::deref(_26) -> [return: bb20, unwind: bb24];
    }

    bb18: {
        _23 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _23) -> [return: bb19, unwind continue];
    }

    bb19: {
        _28 = const false;
        goto -> bb23;
    }

    bb20: {
        _17 = DB::query_all(move _18, _25) -> [return: bb21, unwind: bb24];
    }

    bb21: {
        _28 = const true;
        drop(_19) -> [return: bb26, unwind: bb28];
    }

    bb22: {
        _28 = const false;
        goto -> bb23;
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_19) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }

    bb26: {
        _28 = const false;
        _27 = move _17;
        _0 = fzf_helper(_6, move _27) -> [return: bb22, unwind: bb28];
    }

    bb27 (cleanup): {
        drop(_17) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_28) -> [0: bb25, otherwise: bb27];
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:10: 8:15>::fmt(_1: &Remove, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&std::path::PathBuf;
    let _7: &std::path::PathBuf;

    bb0: {
        _3 = const "Remove";
        _4 = const "path";
        _7 = &((*_1).0: std::path::PathBuf);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _1 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = <Remove as StructOptInternal>::augment_clap(move _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::from_clap(_1: &ArgMatches<'_>) -> Remove {
    debug matches => _1;
    let mut _0: subcommand::remove::Remove;
    let mut _2: std::path::PathBuf;
    let mut _3: std::option::Option<std::path::PathBuf>;
    let mut _4: std::option::Option<&str>;

    bb0: {
        _4 = ArgMatches::<'_>::value_of::<&str>(_1, const "path") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = std::option::Option::<&str>::map::<PathBuf, {closure@src/subcommand/remove.rs:11:5: 11:9}>(move _4, const ZeroSized: {closure@src/subcommand/remove.rs:11:5: 11:9}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = std::option::Option::<PathBuf>::unwrap(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = Remove { path: move _2 };
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::from_clap::{closure#0}(_1: {closure@src/subcommand/remove.rs:11:5: 11:9}, _2: &str) -> PathBuf {
    debug s => _2;
    let mut _0: std::path::PathBuf;
    let mut _3: std::result::Result<std::path::PathBuf, std::convert::Infallible>;

    bb0: {
        _3 = <PathBuf as FromStr>::from_str(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Result::<PathBuf, Infallible>::unwrap(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let mut _9: clap::Arg<'_, '_>;
    let _10: &str;
    let mut _11: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
        }
    }

    bb0: {
        _11 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "Remove a directory") -> [return: bb1, unwind continue];
    }

    bb1: {
        _11 = const true;
        _4 = move _2;
        _10 = const "path";
        _9 = Arg::<'_, '_>::with_name(_10) -> [return: bb2, unwind: bb11];
    }

    bb2: {
        _8 = Arg::<'_, '_>::takes_value(move _9, const true) -> [return: bb3, unwind: bb11];
    }

    bb3: {
        _7 = Arg::<'_, '_>::multiple(move _8, const false) -> [return: bb4, unwind: bb11];
    }

    bb4: {
        _6 = Arg::<'_, '_>::required(move _7, const true) -> [return: bb5, unwind: bb11];
    }

    bb5: {
        _5 = Arg::<'_, '_>::validator::<{closure@src/subcommand/remove.rs:11:5: 11:9}>(move _6, const ZeroSized: {closure@src/subcommand/remove.rs:11:5: 11:9}) -> [return: bb6, unwind: bb11];
    }

    bb6: {
        _11 = const false;
        _3 = App::<'_, '_>::arg::<Arg<'_, '_>>(move _4, move _5) -> [return: bb7, unwind: bb11];
    }

    bb7: {
        _11 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _3, const "0.3.0") -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        resume;
    }

    bb10 (cleanup): {
        drop(_4) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        switchInt(_11) -> [0: bb9, otherwise: bb10];
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::augment_clap::{closure#0}(_1: &{closure@src/subcommand/remove.rs:11:5: 11:9}, _2: std::string::String) -> Result<(), std::string::String> {
    debug s => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::convert::Infallible>;
    let mut _4: std::result::Result<std::path::PathBuf, std::convert::Infallible>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = std::string::String::as_str(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = <PathBuf as FromStr>::from_str(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = Result::<PathBuf, Infallible>::map::<(), {closure@src/subcommand/remove.rs:11:5: 11:9}>(move _4, const ZeroSized: {closure@src/subcommand/remove.rs:11:5: 11:9}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = Result::<(), Infallible>::map_err::<std::string::String, {closure@src/subcommand/remove.rs:11:5: 11:9}>(const Result::<(), Infallible>::Ok(()), const ZeroSized: {closure@src/subcommand/remove.rs:11:5: 11:9}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::augment_clap::{closure#0}::{closure#0}(_1: {closure@src/subcommand/remove.rs:11:5: 11:9}, _2: PathBuf) -> () {
    let mut _0: ();

    bb0: {
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::augment_clap::{closure#0}::{closure#1}(_1: {closure@src/subcommand/remove.rs:11:5: 11:9}, _2: Infallible) -> std::string::String {
    debug e => const ZeroSized: Infallible;
    let mut _0: std::string::String;
    let mut _3: &std::convert::Infallible;

    bb0: {
        _3 = &_2;
        _0 = <Infallible as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:8:17: 8:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const false;
        return;
    }
}

fn remove::<impl at src/subcommand/remove.rs:14:1: 14:12>::run(_1: &Remove) -> Result<(), anyhow::Error> {
    debug self => _1;
    let mut _0: std::result::Result<(), anyhow::Error>;
    let mut _2: &mut db::DB;
    let mut _3: db::DB;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, db::DB>;
    let mut _5: std::result::Result<db::DB, anyhow::Error>;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _8: db::DB;
    let mut _9: &std::path::PathBuf;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _5 = get_db() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <Result<DB, anyhow::Error> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Continue).0: db::DB);
        _3 = move _8;
        _2 = &mut _3;
        _9 = &((*_1).0: std::path::PathBuf);
        _0 = DB::remove::<&PathBuf>(move _2, move _9) -> [return: bb6, unwind: bb8];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }
}

fn path_to_bytes(_1: &P) -> std::option::Option<&[u8]> {
    debug path => _1;
    let mut _0: std::option::Option<&[u8]>;
    let _2: &[u8];
    let _3: &std::ffi::OsStr;
    let _4: &std::path::Path;

    bb0: {
        _4 = <P as AsRef<Path>>::as_ref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Path::as_os_str(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <OsStr as OsStrExt>::as_bytes(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::option::Option::<&[u8]>::Some(_2);
        return;
    }
}

fn get_db() -> Result<DB, anyhow::Error> {
    let mut _0: std::result::Result<db::DB, anyhow::Error>;
    let mut _1: std::path::PathBuf;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::path::PathBuf>;
    let mut _3: std::result::Result<std::path::PathBuf, anyhow::Error>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _6: std::path::PathBuf;
    let _7: ();
    let mut _8: &mut std::path::PathBuf;
    let mut _9: bool;
    let _10: &std::path::Path;
    let mut _11: &std::path::PathBuf;
    let mut _12: std::option::Option<std::path::PathBuf>;
    let mut _13: isize;
    let _15: ();
    let mut _16: &mut std::path::PathBuf;
    let mut _17: bool;
    let _18: &std::path::Path;
    let mut _19: &std::path::PathBuf;
    let mut _20: std::path::PathBuf;
    let mut _21: std::path::PathBuf;
    let mut _22: std::path::PathBuf;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: isize;
    scope 1 {
        debug db_path => _1;
        scope 6 {
            debug old_db_path => _14;
            let mut _14: std::path::PathBuf;
        }
    }
    scope 2 {
        debug residual => _5;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _6;
        scope 5 {
        }
    }

    bb0: {
        _25 = const false;
        _24 = const false;
        _23 = const false;
        _3 = zo_data_dir() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Result<PathBuf, anyhow::Error> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = move ((_2 as Continue).0: std::path::PathBuf);
        _25 = const true;
        _1 = move _6;
        _8 = &mut _1;
        _7 = PathBuf::push::<&str>(move _8, const "db.zo") -> [return: bb6, unwind: bb31];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<DB, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _5) -> [return: bb21, unwind continue];
    }

    bb6: {
        _11 = &_1;
        _10 = <PathBuf as Deref>::deref(move _11) -> [return: bb7, unwind: bb31];
    }

    bb7: {
        _9 = Path::is_file(_10) -> [return: bb8, unwind: bb31];
    }

    bb8: {
        switchInt(move _9) -> [0: bb9, otherwise: bb19];
    }

    bb9: {
        _12 = dirs::home_dir() -> [return: bb10, unwind: bb31];
    }

    bb10: {
        _23 = const true;
        _13 = discriminant(_12);
        switchInt(move _13) -> [1: bb11, otherwise: bb27];
    }

    bb11: {
        _23 = const false;
        _24 = const true;
        _14 = move ((_12 as Some).0: std::path::PathBuf);
        _16 = &mut _14;
        _15 = PathBuf::push::<&str>(move _16, const ".zo") -> [return: bb12, unwind: bb29];
    }

    bb12: {
        _19 = &_14;
        _18 = <PathBuf as Deref>::deref(move _19) -> [return: bb13, unwind: bb29];
    }

    bb13: {
        _17 = Path::is_file(_18) -> [return: bb14, unwind: bb29];
    }

    bb14: {
        switchInt(move _17) -> [0: bb17, otherwise: bb15];
    }

    bb15: {
        _24 = const false;
        _20 = move _14;
        _25 = const false;
        _21 = move _1;
        _0 = DB::open_and_migrate::<PathBuf, PathBuf>(move _20, move _21) -> [return: bb16, unwind: bb29];
    }

    bb16: {
        _24 = const false;
        _23 = const false;
        goto -> bb21;
    }

    bb17: {
        drop(_14) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        _24 = const false;
        goto -> bb27;
    }

    bb19: {
        _25 = const false;
        _22 = move _1;
        _0 = DB::open::<PathBuf>(move _22) -> [return: bb20, unwind: bb31];
    }

    bb20: {
        _25 = const false;
        goto -> bb22;
    }

    bb21: {
        _25 = const false;
        goto -> bb22;
    }

    bb22: {
        return;
    }

    bb23 (cleanup): {
        resume;
    }

    bb24: {
        _23 = const false;
        goto -> bb19;
    }

    bb25: {
        switchInt(_23) -> [0: bb24, otherwise: bb26];
    }

    bb26: {
        drop(((_12 as Some).0: std::path::PathBuf)) -> [return: bb24, unwind: bb31];
    }

    bb27: {
        _26 = discriminant(_12);
        switchInt(move _26) -> [1: bb25, otherwise: bb24];
    }

    bb28 (cleanup): {
        drop(_14) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        switchInt(_24) -> [0: bb31, otherwise: bb28];
    }

    bb30 (cleanup): {
        drop(_1) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        switchInt(_25) -> [0: bb23, otherwise: bb30];
    }
}

fn get_current_time() -> Result<i64, anyhow::Error> {
    let mut _0: std::result::Result<i64, anyhow::Error>;
    let _1: u64;
    let mut _2: &std::time::Duration;
    let _3: std::time::Duration;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::time::Duration>;
    let mut _5: std::result::Result<std::time::Duration, anyhow::Error>;
    let mut _6: std::result::Result<std::time::Duration, std::time::SystemTimeError>;
    let mut _7: &std::time::SystemTime;
    let _8: std::time::SystemTime;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _11: std::time::Duration;
    let mut _12: i64;
    scope 1 {
        debug current_time => _1;
    }
    scope 2 {
        debug residual => _10;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _11;
        scope 5 {
        }
    }

    bb0: {
        _8 = SystemTime::now() -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &_8;
        _6 = SystemTime::duration_since(move _7, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = <Result<Duration, SystemTimeError> as anyhow::Context<Duration, SystemTimeError>>::context::<&str>(move _6, const "system clock set to invalid time") -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = <Result<Duration, anyhow::Error> as Try>::branch(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_4);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = ((_4 as Continue).0: std::time::Duration);
        _3 = _11;
        _2 = &_3;
        _1 = Duration::as_secs(move _2) -> [return: bb8, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<i64, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb8: {
        _12 = _1 as i64 (IntToInt);
        _0 = Result::<i64, anyhow::Error>::Ok(move _12);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn fzf_helper(_1: i64, _2: Vec<Dir>) -> Result<std::option::Option<Vec<u8>>, anyhow::Error> {
    debug now => _1;
    debug dirs => _2;
    let mut _0: std::result::Result<std::option::Option<std::vec::Vec<u8>>, anyhow::Error>;
    let mut _3: std::process::Child;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::process::Child>;
    let mut _5: std::result::Result<std::process::Child, anyhow::Error>;
    let mut _6: std::result::Result<std::process::Child, std::io::Error>;
    let mut _7: &mut std::process::Command;
    let mut _8: &mut std::process::Command;
    let mut _9: &mut std::process::Command;
    let mut _10: &mut std::process::Command;
    let mut _11: std::process::Command;
    let mut _12: std::process::Stdio;
    let mut _13: std::process::Stdio;
    let mut _14: isize;
    let _15: std::result::Result<std::convert::Infallible, anyhow::Error>;
    let _16: std::process::Child;
    let mut _18: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, &mut std::process::ChildStdin>;
    let mut _19: std::result::Result<&mut std::process::ChildStdin, anyhow::Error>;
    let mut _20: std::option::Option<&mut std::process::ChildStdin>;
    let mut _21: &mut std::option::Option<std::process::ChildStdin>;
    let mut _22: isize;
    let mut _25: std::slice::IterMut<'_, dir::Dir>;
    let mut _26: std::slice::IterMut<'_, dir::Dir>;
    let mut _27: &mut [dir::Dir];
    let mut _28: &mut std::vec::Vec<dir::Dir>;
    let mut _30: std::option::Option<&mut dir::Dir>;
    let mut _31: &mut std::slice::IterMut<'_, dir::Dir>;
    let mut _32: isize;
    let mut _34: f64;
    let mut _35: &dir::Dir;
    let _36: ();
    let mut _37: &mut [dir::Dir];
    let mut _38: &mut std::vec::Vec<dir::Dir>;
    let mut _39: std::slice::Iter<'_, dir::Dir>;
    let mut _40: std::slice::Iter<'_, dir::Dir>;
    let _41: &[dir::Dir];
    let mut _42: &std::vec::Vec<dir::Dir>;
    let mut _44: std::option::Option<&dir::Dir>;
    let mut _45: &mut std::slice::Iter<'_, dir::Dir>;
    let mut _46: isize;
    let mut _49: f64;
    let mut _50: std::option::Option<&[u8]>;
    let _51: &std::path::PathBuf;
    let mut _52: isize;
    let mut _54: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _55: std::result::Result<(), anyhow::Error>;
    let mut _56: std::result::Result<(), std::io::Error>;
    let mut _57: &mut {closure@src/util.rs:81:14: 81:16};
    let mut _58: {closure@src/util.rs:81:14: 81:16};
    let mut _59: &mut &mut std::process::ChildStdin;
    let mut _60: &f64;
    let mut _61: &&[u8];
    let mut _62: isize;
    let mut _64: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, &mut std::process::ChildStdout>;
    let mut _65: std::result::Result<&mut std::process::ChildStdout, anyhow::Error>;
    let mut _66: std::option::Option<&mut std::process::ChildStdout>;
    let mut _67: &mut std::option::Option<std::process::ChildStdout>;
    let mut _68: isize;
    let mut _72: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, usize>;
    let mut _73: std::result::Result<usize, anyhow::Error>;
    let mut _74: std::result::Result<usize, std::io::Error>;
    let mut _75: &mut std::vec::Vec<u8>;
    let mut _76: isize;
    let mut _80: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>, std::process::ExitStatus>;
    let mut _81: std::result::Result<std::process::ExitStatus, anyhow::Error>;
    let mut _82: std::result::Result<std::process::ExitStatus, std::io::Error>;
    let mut _83: &mut std::process::Child;
    let mut _84: isize;
    let mut _87: std::option::Option<i32>;
    let mut _88: &std::process::ExitStatus;
    let mut _89: bool;
    let mut _90: bool;
    let mut _91: isize;
    let mut _92: std::option::Option<&[u8]>;
    let _93: &[u8];
    let mut _94: &std::vec::Vec<u8>;
    let mut _95: std::ops::Range<usize>;
    let mut _96: usize;
    let mut _97: usize;
    let mut _98: &std::vec::Vec<u8>;
    let mut _99: (usize, bool);
    let mut _100: isize;
    let mut _102: std::option::Option<std::vec::Vec<u8>>;
    let mut _103: std::vec::Vec<u8>;
    let mut _104: anyhow::Error;
    let mut _105: std::option::Option<std::vec::Vec<u8>>;
    let mut _106: anyhow::Error;
    let mut _107: anyhow::Error;
    let mut _108: anyhow::Error;
    scope 1 {
        debug fzf => _3;
        let _17: &mut std::process::ChildStdin;
        let _23: std::result::Result<std::convert::Infallible, anyhow::Error>;
        let _24: &mut std::process::ChildStdin;
        scope 6 {
            debug fzf_stdin => _17;
            let mut _29: std::slice::IterMut<'_, dir::Dir>;
            let mut _43: std::slice::Iter<'_, dir::Dir>;
            let _69: std::result::Result<std::convert::Infallible, anyhow::Error>;
            let _70: &mut std::process::ChildStdout;
            scope 11 {
                debug iter => _29;
                let _33: &mut dir::Dir;
                scope 12 {
                    debug dir => _33;
                }
            }
            scope 13 {
                debug iter => _43;
                let _47: &dir::Dir;
                scope 14 {
                    debug dir => _47;
                    let _48: f64;
                    scope 15 {
                        debug frecency => _48;
                        scope 16 {
                            debug path_bytes => _53;
                            let _53: &[u8];
                            let _63: std::result::Result<std::convert::Infallible, anyhow::Error>;
                            scope 17 {
                                debug residual => _63;
                                scope 18 {
                                }
                            }
                            scope 19 {
                                debug val => const ();
                                scope 20 {
                                }
                            }
                        }
                    }
                }
            }
            scope 21 {
                debug fzf_stdout => _70;
                let mut _71: std::vec::Vec<u8>;
                scope 26 {
                    debug buffer => _71;
                    let _77: std::result::Result<std::convert::Infallible, anyhow::Error>;
                    let _78: usize;
                    let _79: std::process::ExitStatus;
                    let _85: std::result::Result<std::convert::Infallible, anyhow::Error>;
                    let _86: std::process::ExitStatus;
                    scope 27 {
                        debug residual => _77;
                        scope 28 {
                        }
                    }
                    scope 29 {
                        debug val => _78;
                        scope 30 {
                        }
                    }
                    scope 31 {
                        debug status => _79;
                        let _101: &[u8];
                        scope 36 {
                            debug path => _101;
                        }
                    }
                    scope 32 {
                        debug residual => _85;
                        scope 33 {
                        }
                    }
                    scope 34 {
                        debug val => _86;
                        scope 35 {
                        }
                    }
                }
            }
            scope 22 {
                debug residual => _69;
                scope 23 {
                }
            }
            scope 24 {
                debug val => _70;
                scope 25 {
                }
            }
        }
        scope 7 {
            debug residual => _23;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _24;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _15;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _16;
        scope 5 {
        }
    }

    bb0: {
        _11 = Command::new::<&str>(const "fzf") -> [return: bb1, unwind: bb92];
    }

    bb1: {
        _10 = &mut _11;
        _9 = Command::arg::<&str>(move _10, const "-n2..") -> [return: bb2, unwind: bb91];
    }

    bb2: {
        _12 = Stdio::piped() -> [return: bb3, unwind: bb91];
    }

    bb3: {
        _8 = Command::stdin::<Stdio>(_9, move _12) -> [return: bb4, unwind: bb91];
    }

    bb4: {
        _13 = Stdio::piped() -> [return: bb5, unwind: bb91];
    }

    bb5: {
        _7 = Command::stdout::<Stdio>(_8, move _13) -> [return: bb6, unwind: bb91];
    }

    bb6: {
        _6 = Command::spawn(_7) -> [return: bb7, unwind: bb91];
    }

    bb7: {
        _5 = <Result<Child, std::io::Error> as anyhow::Context<Child, std::io::Error>>::context::<&str>(move _6, const "could not launch fzf") -> [return: bb8, unwind: bb91];
    }

    bb8: {
        _4 = <Result<Child, anyhow::Error> as Try>::branch(move _5) -> [return: bb9, unwind: bb91];
    }

    bb9: {
        _14 = discriminant(_4);
        switchInt(move _14) -> [0: bb10, 1: bb12, otherwise: bb11];
    }

    bb10: {
        _16 = move ((_4 as Continue).0: std::process::Child);
        _3 = move _16;
        drop(_11) -> [return: bb14, unwind: bb90];
    }

    bb11: {
        unreachable;
    }

    bb12: {
        _15 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _15) -> [return: bb13, unwind: bb91];
    }

    bb13: {
        drop(_11) -> [return: bb87, unwind: bb92];
    }

    bb14: {
        _21 = &mut (_3.1: std::option::Option<std::process::ChildStdin>);
        _20 = std::option::Option::<ChildStdin>::as_mut(move _21) -> [return: bb15, unwind: bb90];
    }

    bb15: {
        _19 = std::option::Option::<&mut ChildStdin>::ok_or_else::<anyhow::Error, {closure@src/util.rs:63:21: 63:23}>(move _20, const ZeroSized: {closure@src/util.rs:63:21: 63:23}) -> [return: bb16, unwind: bb90];
    }

    bb16: {
        _18 = <Result<&mut ChildStdin, anyhow::Error> as Try>::branch(move _19) -> [return: bb17, unwind: bb90];
    }

    bb17: {
        _22 = discriminant(_18);
        switchInt(move _22) -> [0: bb18, 1: bb19, otherwise: bb11];
    }

    bb18: {
        _24 = move ((_18 as Continue).0: &mut std::process::ChildStdin);
        _17 = move _24;
        _28 = &mut _2;
        _27 = <Vec<Dir> as DerefMut>::deref_mut(move _28) -> [return: bb20, unwind: bb90];
    }

    bb19: {
        _23 = move ((_18 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _23) -> [return: bb94, unwind: bb90];
    }

    bb20: {
        _26 = core::slice::<impl [Dir]>::iter_mut(_27) -> [return: bb21, unwind: bb90];
    }

    bb21: {
        _25 = <std::slice::IterMut<'_, Dir> as IntoIterator>::into_iter(move _26) -> [return: bb22, unwind: bb90];
    }

    bb22: {
        _29 = move _25;
        goto -> bb23;
    }

    bb23: {
        _31 = &mut _29;
        _30 = <std::slice::IterMut<'_, Dir> as Iterator>::next(_31) -> [return: bb24, unwind: bb90];
    }

    bb24: {
        _32 = discriminant(_30);
        switchInt(move _32) -> [0: bb26, 1: bb25, otherwise: bb11];
    }

    bb25: {
        _33 = move ((_30 as Some).0: &mut dir::Dir);
        _35 = &(*_33);
        _34 = Dir::get_frecency(move _35, _1) -> [return: bb27, unwind: bb90];
    }

    bb26: {
        _38 = &mut _2;
        _37 = <Vec<Dir> as DerefMut>::deref_mut(move _38) -> [return: bb28, unwind: bb90];
    }

    bb27: {
        ((*_33).1: f64) = move _34;
        goto -> bb23;
    }

    bb28: {
        _36 = core::slice::<impl [Dir]>::sort_unstable_by::<{closure@src/util.rs:69:27: 69:39}>(_37, const ZeroSized: {closure@src/util.rs:69:27: 69:39}) -> [return: bb29, unwind: bb90];
    }

    bb29: {
        _42 = &_2;
        _41 = <Vec<Dir> as Deref>::deref(move _42) -> [return: bb30, unwind: bb90];
    }

    bb30: {
        _40 = core::slice::<impl [Dir]>::iter(_41) -> [return: bb31, unwind: bb90];
    }

    bb31: {
        _39 = <std::slice::Iter<'_, Dir> as IntoIterator>::into_iter(move _40) -> [return: bb32, unwind: bb90];
    }

    bb32: {
        _43 = move _39;
        goto -> bb33;
    }

    bb33: {
        _45 = &mut _43;
        _44 = <std::slice::Iter<'_, Dir> as Iterator>::next(_45) -> [return: bb34, unwind: bb90];
    }

    bb34: {
        _46 = discriminant(_44);
        switchInt(move _46) -> [0: bb36, 1: bb35, otherwise: bb11];
    }

    bb35: {
        _47 = ((_44 as Some).0: &dir::Dir);
        _49 = ((*_47).1: f64);
        _48 = util::clamp(move _49, const 0f64, const 9999f64) -> [return: bb37, unwind: bb90];
    }

    bb36: {
        _67 = &mut (_3.2: std::option::Option<std::process::ChildStdout>);
        _66 = std::option::Option::<ChildStdout>::as_mut(move _67) -> [return: bb44, unwind: bb90];
    }

    bb37: {
        _51 = &((*_47).0: std::path::PathBuf);
        _50 = path_to_bytes::<PathBuf>(_51) -> [return: bb38, unwind: bb90];
    }

    bb38: {
        _52 = discriminant(_50);
        switchInt(move _52) -> [1: bb39, otherwise: bb33];
    }

    bb39: {
        _53 = ((_50 as Some).0: &[u8]);
        _59 = &mut _17;
        _60 = &_48;
        _61 = &_53;
        _58 = {closure@src/util.rs:81:14: 81:16} { fzf_stdin: move _59, frecency: move _60, path_bytes: move _61 };
        _57 = &mut _58;
        _56 = <{closure@src/util.rs:81:14: 81:16} as FnMut<()>>::call_mut(move _57, const ()) -> [return: bb40, unwind: bb90];
    }

    bb40: {
        _55 = <Result<(), std::io::Error> as anyhow::Context<(), std::io::Error>>::context::<&str>(move _56, const "could not write into fzf stdin") -> [return: bb41, unwind: bb90];
    }

    bb41: {
        _54 = <Result<(), anyhow::Error> as Try>::branch(move _55) -> [return: bb42, unwind: bb90];
    }

    bb42: {
        _62 = discriminant(_54);
        switchInt(move _62) -> [0: bb33, 1: bb43, otherwise: bb11];
    }

    bb43: {
        _63 = move ((_54 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _63) -> [return: bb95, unwind: bb90];
    }

    bb44: {
        _65 = std::option::Option::<&mut ChildStdout>::ok_or_else::<anyhow::Error, {closure@src/util.rs:93:21: 93:23}>(move _66, const ZeroSized: {closure@src/util.rs:93:21: 93:23}) -> [return: bb45, unwind: bb90];
    }

    bb45: {
        _64 = <Result<&mut ChildStdout, anyhow::Error> as Try>::branch(move _65) -> [return: bb46, unwind: bb90];
    }

    bb46: {
        _68 = discriminant(_64);
        switchInt(move _68) -> [0: bb47, 1: bb48, otherwise: bb11];
    }

    bb47: {
        _70 = move ((_64 as Continue).0: &mut std::process::ChildStdout);
        _71 = Vec::<u8>::new() -> [return: bb49, unwind: bb90];
    }

    bb48: {
        _69 = move ((_64 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _69) -> [return: bb96, unwind: bb90];
    }

    bb49: {
        _75 = &mut _71;
        _74 = <ChildStdout as std::io::Read>::read_to_end(_70, _75) -> [return: bb50, unwind: bb89];
    }

    bb50: {
        _73 = <Result<usize, std::io::Error> as anyhow::Context<usize, std::io::Error>>::context::<&str>(move _74, const "could not read from fzf stdout") -> [return: bb51, unwind: bb89];
    }

    bb51: {
        _72 = <Result<usize, anyhow::Error> as Try>::branch(move _73) -> [return: bb52, unwind: bb89];
    }

    bb52: {
        _76 = discriminant(_72);
        switchInt(move _76) -> [0: bb53, 1: bb54, otherwise: bb11];
    }

    bb53: {
        _78 = ((_72 as Continue).0: usize);
        _83 = &mut _3;
        _82 = Child::wait(move _83) -> [return: bb55, unwind: bb89];
    }

    bb54: {
        _77 = move ((_72 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _77) -> [return: bb97, unwind: bb89];
    }

    bb55: {
        _81 = <Result<ExitStatus, std::io::Error> as anyhow::Context<ExitStatus, std::io::Error>>::context::<&str>(move _82, const "wait failed on fzf") -> [return: bb56, unwind: bb89];
    }

    bb56: {
        _80 = <Result<ExitStatus, anyhow::Error> as Try>::branch(move _81) -> [return: bb57, unwind: bb89];
    }

    bb57: {
        _84 = discriminant(_80);
        switchInt(move _84) -> [0: bb58, 1: bb59, otherwise: bb11];
    }

    bb58: {
        _86 = ((_80 as Continue).0: std::process::ExitStatus);
        _79 = _86;
        _88 = &_79;
        _87 = ExitStatus::code(move _88) -> [return: bb60, unwind: bb89];
    }

    bb59: {
        _85 = move ((_80 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<std::option::Option<Vec<u8>>, anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _85) -> [return: bb98, unwind: bb89];
    }

    bb60: {
        _91 = discriminant(_87);
        switchInt(move _91) -> [0: bb77, 1: bb61, otherwise: bb11];
    }

    bb61: {
        switchInt(((_87 as Some).0: i32)) -> [0: bb65, 1: bb74, 2: bb75, otherwise: bb62];
    }

    bb62: {
        _89 = Le(const 128_i32, ((_87 as Some).0: i32));
        switchInt(move _89) -> [0: bb63, otherwise: bb64];
    }

    bb63: {
        _108 = new_adhoc::<&str>(const "fzf returned an unknown error") -> [return: bb79, unwind: bb89];
    }

    bb64: {
        _90 = Le(((_87 as Some).0: i32), const 254_i32);
        switchInt(move _90) -> [0: bb63, otherwise: bb77];
    }

    bb65: {
        _94 = &_71;
        _93 = <Vec<u8> as Deref>::deref(move _94) -> [return: bb66, unwind: bb89];
    }

    bb66: {
        _98 = &_71;
        _97 = Vec::<u8>::len(move _98) -> [return: bb67, unwind: bb89];
    }

    bb67: {
        _99 = CheckedSub(_97, const 1_usize);
        assert(!move (_99.1: bool), "attempt to compute `{} - {}`, which would overflow", move _97, const 1_usize) -> [success: bb68, unwind: bb89];
    }

    bb68: {
        _96 = move (_99.0: usize);
        _95 = std::ops::Range::<usize> { start: const 12_usize, end: move _96 };
        _92 = core::slice::<impl [u8]>::get::<std::ops::Range<usize>>(_93, move _95) -> [return: bb69, unwind: bb89];
    }

    bb69: {
        _100 = discriminant(_92);
        switchInt(move _100) -> [0: bb70, 1: bb71, otherwise: bb11];
    }

    bb70: {
        _104 = new_adhoc::<&str>(const "fzf returned invalid output") -> [return: bb73, unwind: bb89];
    }

    bb71: {
        _101 = ((_92 as Some).0: &[u8]);
        _103 = slice::<impl [u8]>::to_vec(_101) -> [return: bb72, unwind: bb89];
    }

    bb72: {
        _102 = std::option::Option::<Vec<u8>>::Some(move _103);
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Ok(move _102);
        goto -> bb80;
    }

    bb73: {
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Err(move _104);
        goto -> bb83;
    }

    bb74: {
        _105 = std::option::Option::<Vec<u8>>::None;
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Ok(move _105);
        goto -> bb80;
    }

    bb75: {
        _106 = new_adhoc::<&str>(const "fzf returned an error") -> [return: bb76, unwind: bb89];
    }

    bb76: {
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Err(move _106);
        goto -> bb83;
    }

    bb77: {
        _107 = new_adhoc::<&str>(const "fzf was terminated") -> [return: bb78, unwind: bb89];
    }

    bb78: {
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Err(move _107);
        goto -> bb83;
    }

    bb79: {
        _0 = Result::<std::option::Option<Vec<u8>>, anyhow::Error>::Err(move _108);
        goto -> bb83;
    }

    bb80: {
        drop(_71) -> [return: bb81, unwind: bb90];
    }

    bb81: {
        drop(_3) -> [return: bb82, unwind: bb92];
    }

    bb82: {
        drop(_2) -> [return: bb88, unwind continue];
    }

    bb83: {
        drop(_71) -> [return: bb84, unwind: bb90];
    }

    bb84: {
        drop(_3) -> [return: bb87, unwind: bb92];
    }

    bb85: {
        drop(_71) -> [return: bb86, unwind: bb90];
    }

    bb86: {
        drop(_3) -> [return: bb87, unwind: bb92];
    }

    bb87: {
        drop(_2) -> [return: bb88, unwind continue];
    }

    bb88: {
        return;
    }

    bb89 (cleanup): {
        drop(_71) -> [return: bb90, unwind terminate(cleanup)];
    }

    bb90 (cleanup): {
        drop(_3) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb91 (cleanup): {
        drop(_11) -> [return: bb92, unwind terminate(cleanup)];
    }

    bb92 (cleanup): {
        drop(_2) -> [return: bb93, unwind terminate(cleanup)];
    }

    bb93 (cleanup): {
        resume;
    }

    bb94: {
        goto -> bb86;
    }

    bb95: {
        goto -> bb86;
    }

    bb96: {
        goto -> bb86;
    }

    bb97: {
        goto -> bb85;
    }

    bb98: {
        goto -> bb85;
    }
}

fn fzf_helper::{closure#0}(_1: {closure@src/util.rs:63:21: 63:23}) -> anyhow::Error {
    let mut _0: anyhow::Error;

    bb0: {
        _0 = new_adhoc::<&str>(const "could not connect to fzf stdin") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fzf_helper::{closure#1}(_1: &mut {closure@src/util.rs:69:27: 69:39}, _2: &Dir, _3: &Dir) -> std::cmp::Ordering {
    debug dir1 => _2;
    debug dir2 => _3;
    let mut _0: std::cmp::Ordering;
    let mut _4: std::cmp::Ordering;
    let mut _5: std::option::Option<std::cmp::Ordering>;
    let mut _6: &f64;
    let _7: &f64;
    let mut _8: std::cmp::Ordering;

    bb0: {
        _6 = &((*_2).1: f64);
        _7 = &((*_3).1: f64);
        _5 = <f64 as PartialOrd>::partial_cmp(move _6, _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = Equal;
        _4 = std::option::Option::<std::cmp::Ordering>::unwrap_or(move _5, move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = std::cmp::Ordering::reverse(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn fzf_helper::{closure#2}(_1: &mut {closure@src/util.rs:81:14: 81:16}) -> Result<(), std::io::Error> {
    debug fzf_stdin => (*((*_1).0: &mut &mut std::process::ChildStdin));
    debug frecency => (*((*_1).1: &f64));
    debug path_bytes => (*((*_1).2: &&[u8]));
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _3: std::result::Result<(), std::io::Error>;
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[core::fmt::rt::Argument<'_>];
    let _7: &[core::fmt::rt::Argument<'_>; 1];
    let _8: [core::fmt::rt::Argument<'_>; 1];
    let mut _9: core::fmt::rt::Argument<'_>;
    let mut _10: &[core::fmt::rt::Placeholder];
    let _11: &[core::fmt::rt::Placeholder; 1];
    let _12: [core::fmt::rt::Placeholder; 1];
    let mut _13: core::fmt::rt::Placeholder;
    let mut _14: core::fmt::rt::Alignment;
    let mut _15: core::fmt::rt::Count;
    let mut _16: core::fmt::rt::Count;
    let mut _17: core::fmt::rt::UnsafeArg;
    let mut _18: isize;
    let _19: std::result::Result<std::convert::Infallible, std::io::Error>;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _21: std::result::Result<(), std::io::Error>;
    let mut _22: isize;
    let _23: std::result::Result<std::convert::Infallible, std::io::Error>;
    let mut _24: &[u8];
    let _25: &[u8; 1];
    let mut _26: &[&str; 2];
    let mut _27: &mut &mut std::process::ChildStdin;
    let mut _28: &mut std::process::ChildStdin;
    let mut _29: &f64;
    let mut _30: &mut &mut std::process::ChildStdin;
    let mut _31: &mut std::process::ChildStdin;
    let mut _32: &&[u8];
    let mut _33: &[u8];
    let mut _34: &mut &mut std::process::ChildStdin;
    let mut _35: &mut std::process::ChildStdin;
    scope 1 {
    }
    scope 2 {
        debug residual => _19;
        scope 3 {
        }
    }
    scope 4 {
        debug val => const ();
        scope 5 {
        }
    }
    scope 6 {
        debug residual => _23;
        scope 7 {
        }
    }
    scope 8 {
        debug val => const ();
        scope 9 {
        }
    }

    bb0: {
        _27 = deref_copy ((*_1).0: &mut &mut std::process::ChildStdin);
        _28 = deref_copy (*_27);
        _26 = const _;
        _5 = _26 as &[&str] (PointerCoercion(Unsize));
        _29 = deref_copy ((*_1).1: &f64);
        _9 = core::fmt::rt::Argument::<'_>::new_display::<f64>(_29) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = [move _9];
        _7 = &_8;
        _6 = _7 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _14 = core::fmt::rt::Alignment::Right;
        _15 = core::fmt::rt::Count::Is(const 0_usize);
        _16 = core::fmt::rt::Count::Is(const 4_usize);
        _13 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _14, const 0_u32, move _15, move _16) -> [return: bb2, unwind continue];
    }

    bb2: {
        _12 = [move _13];
        _11 = &_12;
        _10 = _11 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _17 = core::fmt::rt::UnsafeArg::new() -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = Arguments::<'_>::new_v1_formatted(move _5, move _6, move _10, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = <ChildStdin as std::io::Write>::write_fmt(_28, move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = <Result<(), std::io::Error> as Try>::branch(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _18 = discriminant(_2);
        switchInt(move _18) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _30 = deref_copy ((*_1).0: &mut &mut std::process::ChildStdin);
        _31 = deref_copy (*_30);
        _32 = deref_copy ((*_1).2: &&[u8]);
        _33 = deref_copy (*_32);
        _21 = <ChildStdin as std::io::Write>::write_all(_31, _33) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _19 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _19) -> [return: bb14, unwind continue];
    }

    bb10: {
        _20 = <Result<(), std::io::Error> as Try>::branch(move _21) -> [return: bb11, unwind continue];
    }

    bb11: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb12, 1: bb13, otherwise: bb8];
    }

    bb12: {
        _34 = deref_copy ((*_1).0: &mut &mut std::process::ChildStdin);
        _35 = deref_copy (*_34);
        _25 = const b"\n";
        _24 = _25 as &[u8] (PointerCoercion(Unsize));
        _0 = <ChildStdin as std::io::Write>::write_all(_35, move _24) -> [return: bb14, unwind continue];
    }

    bb13: {
        _23 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <Result<(), std::io::Error> as FromResidual<Result<Infallible, std::io::Error>>>::from_residual(move _23) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

alloc5 (size: 1, align: 1) {
    0a                                              │ .
}

promoted[0] in fzf_helper::{closure#2}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "        "];
        _0 = &_1;
        return;
    }
}

fn fzf_helper::{closure#3}(_1: {closure@src/util.rs:93:21: 93:23}) -> anyhow::Error {
    let mut _0: anyhow::Error;

    bb0: {
        _0 = new_adhoc::<&str>(const "could not connect to fzf stdout") -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn util::clamp(_1: f64, _2: f64, _3: f64) -> f64 {
    debug val => _1;
    debug min => _2;
    debug max => _3;
    let mut _0: f64;
    let mut _4: bool;
    let mut _5: !;
    let mut _6: bool;
    let mut _7: bool;

    bb0: {
        _4 = Le(_2, _3);
        switchInt(move _4) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = Lt(_1, _2);
        switchInt(move _6) -> [0: bb4, otherwise: bb3];
    }

    bb2: {
        _5 = core::panicking::panic(const "assertion failed: min <= max") -> unwind continue;
    }

    bb3: {
        _0 = _2;
        goto -> bb7;
    }

    bb4: {
        _7 = Gt(_1, _3);
        switchInt(move _7) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = _3;
        goto -> bb7;
    }

    bb6: {
        _0 = _1;
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn <impl at src/main.rs:10:10: 10:15>::fmt(_1: &Zoxide, _2: &mut Formatter<'_>) -> Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &subcommand::add::Add;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&subcommand::add::Add;
    let _8: &subcommand::import::Import;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&subcommand::import::Import;
    let _12: &subcommand::init::Init;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&subcommand::init::Init;
    let _16: &subcommand::query::Query;
    let _17: &str;
    let mut _18: &dyn std::fmt::Debug;
    let _19: &&subcommand::query::Query;
    let _20: &subcommand::remove::Remove;
    let _21: &str;
    let mut _22: &dyn std::fmt::Debug;
    let _23: &&subcommand::remove::Remove;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }
    scope 4 {
        debug __self_0 => _16;
    }
    scope 5 {
        debug __self_0 => _20;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _20 = &(((*_1) as Remove).0: subcommand::remove::Remove);
        _21 = const "Remove";
        _23 = &_20;
        _22 = _23 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _21, move _22) -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Add).0: subcommand::add::Add);
        _5 = const "Add";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb7, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as Import).0: subcommand::import::Import);
        _9 = const "Import";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb7, unwind continue];
    }

    bb5: {
        _12 = &(((*_1) as Init).0: subcommand::init::Init);
        _13 = const "Init";
        _15 = &_12;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb7, unwind continue];
    }

    bb6: {
        _16 = &(((*_1) as Query).0: subcommand::query::Query);
        _17 = const "Query";
        _19 = &_16;
        _18 = _19 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = Formatter::<'_>::debug_tuple_field1_finish(_2, _17, move _18) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn <impl at src/main.rs:10:17: 10:26>::clap() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let _1: clap::App<'_, '_>;
    let mut _2: clap::App<'_, '_>;
    let mut _3: clap::AppSettings;
    scope 1 {
        debug app => _1;
    }

    bb0: {
        _2 = App::<'_, '_>::new::<&str>(const "zoxide") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = SubcommandRequiredElseHelp;
        _1 = App::<'_, '_>::setting(move _2, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = <Zoxide as StructOptInternal>::augment_clap(move _1) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn <impl at src/main.rs:10:17: 10:26>::from_clap(_1: &ArgMatches<'_>) -> Zoxide {
    debug matches => _1;
    let mut _0: Zoxide;
    let mut _2: std::option::Option<Zoxide>;
    let mut _3: (&str, std::option::Option<&clap::ArgMatches<'_>>);

    bb0: {
        _3 = ArgMatches::<'_>::subcommand(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Zoxide as StructOptInternal>::from_subcommand(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = std::option::Option::<Zoxide>::unwrap(move _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        return;
    }
}

fn <impl at src/main.rs:10:17: 10:26>::augment_clap(_1: App<'_, '_>) -> App<'_, '_> {
    debug app => _1;
    let mut _0: clap::App<'_, '_>;
    let _2: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::App<'_, '_>;
    let _7: &str;
    let mut _10: bool;
    let mut _11: clap::App<'_, '_>;
    let mut _12: clap::AppSettings;
    let mut _13: clap::App<'_, '_>;
    let mut _15: clap::App<'_, '_>;
    let mut _16: clap::App<'_, '_>;
    let _18: &str;
    let mut _21: bool;
    let mut _22: clap::App<'_, '_>;
    let mut _23: clap::AppSettings;
    let mut _24: clap::App<'_, '_>;
    let mut _26: clap::App<'_, '_>;
    let mut _27: clap::App<'_, '_>;
    let _29: &str;
    let mut _32: bool;
    let mut _33: clap::App<'_, '_>;
    let mut _34: clap::AppSettings;
    let mut _35: clap::App<'_, '_>;
    let mut _37: clap::App<'_, '_>;
    let mut _38: clap::App<'_, '_>;
    let _40: &str;
    let mut _43: bool;
    let mut _44: clap::App<'_, '_>;
    let mut _45: clap::AppSettings;
    let mut _46: clap::App<'_, '_>;
    let mut _48: clap::App<'_, '_>;
    let mut _49: clap::App<'_, '_>;
    let _51: &str;
    let mut _54: bool;
    let mut _55: clap::App<'_, '_>;
    let mut _56: clap::AppSettings;
    let mut _57: clap::App<'_, '_>;
    let mut _58: bool;
    let mut _59: bool;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: bool;
    let mut _65: bool;
    let mut _66: bool;
    let mut _67: bool;
    scope 1 {
        debug app => _2;
        let _3: clap::App<'_, '_>;
        let _6: clap::App<'_, '_>;
        scope 2 {
            debug app => _3;
            let _14: clap::App<'_, '_>;
            let _17: clap::App<'_, '_>;
            scope 6 {
                debug app => _14;
                let _25: clap::App<'_, '_>;
                let _28: clap::App<'_, '_>;
                scope 10 {
                    debug app => _25;
                    let _36: clap::App<'_, '_>;
                    let _39: clap::App<'_, '_>;
                    scope 14 {
                        debug app => _36;
                        let _47: clap::App<'_, '_>;
                        let _50: clap::App<'_, '_>;
                        scope 18 {
                            debug app => _47;
                        }
                        scope 19 {
                            debug subcommand => _50;
                            let _52: clap::App<'_, '_>;
                            let _53: clap::App<'_, '_>;
                            scope 20 {
                                debug subcommand => _52;
                            }
                            scope 21 {
                                debug subcommand => _53;
                            }
                        }
                    }
                    scope 15 {
                        debug subcommand => _39;
                        let _41: clap::App<'_, '_>;
                        let _42: clap::App<'_, '_>;
                        scope 16 {
                            debug subcommand => _41;
                        }
                        scope 17 {
                            debug subcommand => _42;
                        }
                    }
                }
                scope 11 {
                    debug subcommand => _28;
                    let _30: clap::App<'_, '_>;
                    let _31: clap::App<'_, '_>;
                    scope 12 {
                        debug subcommand => _30;
                    }
                    scope 13 {
                        debug subcommand => _31;
                    }
                }
            }
            scope 7 {
                debug subcommand => _17;
                let _19: clap::App<'_, '_>;
                let _20: clap::App<'_, '_>;
                scope 8 {
                    debug subcommand => _19;
                }
                scope 9 {
                    debug subcommand => _20;
                }
            }
        }
        scope 3 {
            debug subcommand => _6;
            let _8: clap::App<'_, '_>;
            let _9: clap::App<'_, '_>;
            scope 4 {
                debug subcommand => _8;
            }
            scope 5 {
                debug subcommand => _9;
            }
        }
    }

    bb0: {
        _67 = const false;
        _66 = const false;
        _65 = const false;
        _64 = const false;
        _63 = const false;
        _62 = const false;
        _61 = const false;
        _60 = const false;
        _59 = const false;
        _58 = const false;
        _2 = App::<'_, '_>::about::<&str>(move _1, const "A cd command that learns your habits") -> [return: bb1, unwind continue];
    }

    bb1: {
        _67 = const true;
        _4 = move _2;
        _7 = const "add";
        _6 = SubCommand::<'_>::with_name::<'_>(_7) -> [return: bb2, unwind: bb63];
    }

    bb2: {
        _9 = <add::Add as StructOptInternal>::augment_clap(move _6) -> [return: bb3, unwind: bb63];
    }

    bb3: {
        _66 = const true;
        _10 = <add::Add as StructOptInternal>::is_subcommand() -> [return: bb4, unwind: bb61];
    }

    bb4: {
        switchInt(move _10) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _66 = const false;
        _11 = move _9;
        _12 = SubcommandRequiredElseHelp;
        _8 = App::<'_, '_>::setting(move _11, move _12) -> [return: bb64, unwind: bb61];
    }

    bb6: {
        _66 = const false;
        _8 = move _9;
        goto -> bb7;
    }

    bb7: {
        _66 = const false;
        _13 = move _8;
        _5 = App::<'_, '_>::version::<&str>(move _13, const "0.3.0") -> [return: bb8, unwind: bb63];
    }

    bb8: {
        _67 = const false;
        _3 = App::<'_, '_>::subcommand(move _4, move _5) -> [return: bb9, unwind: bb63];
    }

    bb9: {
        _67 = const false;
        _65 = const true;
        _15 = move _3;
        _18 = const "import";
        _17 = SubCommand::<'_>::with_name::<'_>(_18) -> [return: bb10, unwind: bb59];
    }

    bb10: {
        _20 = <Import as StructOptInternal>::augment_clap(move _17) -> [return: bb11, unwind: bb59];
    }

    bb11: {
        _64 = const true;
        _21 = <Import as StructOptInternal>::is_subcommand() -> [return: bb12, unwind: bb57];
    }

    bb12: {
        switchInt(move _21) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _64 = const false;
        _22 = move _20;
        _23 = SubcommandRequiredElseHelp;
        _19 = App::<'_, '_>::setting(move _22, move _23) -> [return: bb65, unwind: bb57];
    }

    bb14: {
        _64 = const false;
        _19 = move _20;
        goto -> bb15;
    }

    bb15: {
        _64 = const false;
        _24 = move _19;
        _16 = App::<'_, '_>::version::<&str>(move _24, const "0.3.0") -> [return: bb16, unwind: bb59];
    }

    bb16: {
        _65 = const false;
        _14 = App::<'_, '_>::subcommand(move _15, move _16) -> [return: bb17, unwind: bb59];
    }

    bb17: {
        _65 = const false;
        _63 = const true;
        _26 = move _14;
        _29 = const "init";
        _28 = SubCommand::<'_>::with_name::<'_>(_29) -> [return: bb18, unwind: bb55];
    }

    bb18: {
        _31 = <Init as StructOptInternal>::augment_clap(move _28) -> [return: bb19, unwind: bb55];
    }

    bb19: {
        _62 = const true;
        _32 = <Init as StructOptInternal>::is_subcommand() -> [return: bb20, unwind: bb53];
    }

    bb20: {
        switchInt(move _32) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _62 = const false;
        _33 = move _31;
        _34 = SubcommandRequiredElseHelp;
        _30 = App::<'_, '_>::setting(move _33, move _34) -> [return: bb66, unwind: bb53];
    }

    bb22: {
        _62 = const false;
        _30 = move _31;
        goto -> bb23;
    }

    bb23: {
        _62 = const false;
        _35 = move _30;
        _27 = App::<'_, '_>::version::<&str>(move _35, const "0.3.0") -> [return: bb24, unwind: bb55];
    }

    bb24: {
        _63 = const false;
        _25 = App::<'_, '_>::subcommand(move _26, move _27) -> [return: bb25, unwind: bb55];
    }

    bb25: {
        _63 = const false;
        _61 = const true;
        _37 = move _25;
        _40 = const "query";
        _39 = SubCommand::<'_>::with_name::<'_>(_40) -> [return: bb26, unwind: bb51];
    }

    bb26: {
        _42 = <Query as StructOptInternal>::augment_clap(move _39) -> [return: bb27, unwind: bb51];
    }

    bb27: {
        _60 = const true;
        _43 = <Query as StructOptInternal>::is_subcommand() -> [return: bb28, unwind: bb49];
    }

    bb28: {
        switchInt(move _43) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        _60 = const false;
        _44 = move _42;
        _45 = SubcommandRequiredElseHelp;
        _41 = App::<'_, '_>::setting(move _44, move _45) -> [return: bb67, unwind: bb49];
    }

    bb30: {
        _60 = const false;
        _41 = move _42;
        goto -> bb31;
    }

    bb31: {
        _60 = const false;
        _46 = move _41;
        _38 = App::<'_, '_>::version::<&str>(move _46, const "0.3.0") -> [return: bb32, unwind: bb51];
    }

    bb32: {
        _61 = const false;
        _36 = App::<'_, '_>::subcommand(move _37, move _38) -> [return: bb33, unwind: bb51];
    }

    bb33: {
        _61 = const false;
        _59 = const true;
        _48 = move _36;
        _51 = const "remove";
        _50 = SubCommand::<'_>::with_name::<'_>(_51) -> [return: bb34, unwind: bb47];
    }

    bb34: {
        _53 = <Remove as StructOptInternal>::augment_clap(move _50) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _58 = const true;
        _54 = <Remove as StructOptInternal>::is_subcommand() -> [return: bb36, unwind: bb45];
    }

    bb36: {
        switchInt(move _54) -> [0: bb38, otherwise: bb37];
    }

    bb37: {
        _58 = const false;
        _55 = move _53;
        _56 = SubcommandRequiredElseHelp;
        _52 = App::<'_, '_>::setting(move _55, move _56) -> [return: bb68, unwind: bb45];
    }

    bb38: {
        _58 = const false;
        _52 = move _53;
        goto -> bb39;
    }

    bb39: {
        _58 = const false;
        _57 = move _52;
        _49 = App::<'_, '_>::version::<&str>(move _57, const "0.3.0") -> [return: bb40, unwind: bb47];
    }

    bb40: {
        _59 = const false;
        _47 = App::<'_, '_>::subcommand(move _48, move _49) -> [return: bb41, unwind: bb47];
    }

    bb41: {
        _59 = const false;
        _0 = App::<'_, '_>::version::<&str>(move _47, const "0.3.0") -> [return: bb42, unwind continue];
    }

    bb42: {
        return;
    }

    bb43 (cleanup): {
        resume;
    }

    bb44 (cleanup): {
        drop(_53) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_58) -> [0: bb47, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_48) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_59) -> [0: bb43, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop(_42) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        switchInt(_60) -> [0: bb51, otherwise: bb48];
    }

    bb50 (cleanup): {
        drop(_37) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        switchInt(_61) -> [0: bb43, otherwise: bb50];
    }

    bb52 (cleanup): {
        drop(_31) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        switchInt(_62) -> [0: bb55, otherwise: bb52];
    }

    bb54 (cleanup): {
        drop(_26) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        switchInt(_63) -> [0: bb43, otherwise: bb54];
    }

    bb56 (cleanup): {
        drop(_20) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        switchInt(_64) -> [0: bb59, otherwise: bb56];
    }

    bb58 (cleanup): {
        drop(_15) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        switchInt(_65) -> [0: bb43, otherwise: bb58];
    }

    bb60 (cleanup): {
        drop(_9) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        switchInt(_66) -> [0: bb63, otherwise: bb60];
    }

    bb62 (cleanup): {
        drop(_4) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        switchInt(_67) -> [0: bb43, otherwise: bb62];
    }

    bb64: {
        goto -> bb7;
    }

    bb65: {
        goto -> bb15;
    }

    bb66: {
        goto -> bb23;
    }

    bb67: {
        goto -> bb31;
    }

    bb68: {
        goto -> bb39;
    }
}

fn <impl at src/main.rs:10:17: 10:26>::from_subcommand(_1: (&str, std::option::Option<&ArgMatches<'_>>)) -> std::option::Option<Zoxide> {
    debug sub => _1;
    let mut _0: std::option::Option<Zoxide>;
    let mut _2: isize;
    let mut _3: isize;
    let mut _4: isize;
    let mut _5: isize;
    let mut _6: isize;
    let mut _7: bool;
    let mut _8: bool;
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: bool;
    let _12: &clap::ArgMatches<'_>;
    let mut _13: Zoxide;
    let mut _14: subcommand::add::Add;
    let _15: &clap::ArgMatches<'_>;
    let mut _16: Zoxide;
    let mut _17: subcommand::import::Import;
    let _18: &clap::ArgMatches<'_>;
    let mut _19: Zoxide;
    let mut _20: subcommand::init::Init;
    let _21: &clap::ArgMatches<'_>;
    let mut _22: Zoxide;
    let mut _23: subcommand::query::Query;
    let _24: &clap::ArgMatches<'_>;
    let mut _25: Zoxide;
    let mut _26: subcommand::remove::Remove;
    scope 1 {
        debug matches => _12;
    }
    scope 2 {
        debug matches => _15;
    }
    scope 3 {
        debug matches => _18;
    }
    scope 4 {
        debug matches => _21;
    }
    scope 5 {
        debug matches => _24;
    }
    scope 6 {
        debug other => _1;
    }

    bb0: {
        _11 = <str as PartialEq>::eq((_1.0: &str), const "add") -> [return: bb15, unwind continue];
    }

    bb1: {
        _2 = discriminant((_1.1: std::option::Option<&clap::ArgMatches<'_>>));
        switchInt(move _2) -> [1: bb16, otherwise: bb2];
    }

    bb2: {
        _10 = <str as PartialEq>::eq((_1.0: &str), const "import") -> [return: bb14, unwind continue];
    }

    bb3: {
        _3 = discriminant((_1.1: std::option::Option<&clap::ArgMatches<'_>>));
        switchInt(move _3) -> [1: bb18, otherwise: bb4];
    }

    bb4: {
        _9 = <str as PartialEq>::eq((_1.0: &str), const "init") -> [return: bb13, unwind continue];
    }

    bb5: {
        _4 = discriminant((_1.1: std::option::Option<&clap::ArgMatches<'_>>));
        switchInt(move _4) -> [1: bb20, otherwise: bb6];
    }

    bb6: {
        _8 = <str as PartialEq>::eq((_1.0: &str), const "query") -> [return: bb12, unwind continue];
    }

    bb7: {
        _5 = discriminant((_1.1: std::option::Option<&clap::ArgMatches<'_>>));
        switchInt(move _5) -> [1: bb22, otherwise: bb8];
    }

    bb8: {
        _7 = <str as PartialEq>::eq((_1.0: &str), const "remove") -> [return: bb11, unwind continue];
    }

    bb9: {
        _6 = discriminant((_1.1: std::option::Option<&clap::ArgMatches<'_>>));
        switchInt(move _6) -> [1: bb24, otherwise: bb10];
    }

    bb10: {
        _0 = std::option::Option::<Zoxide>::None;
        goto -> bb26;
    }

    bb11: {
        switchInt(move _7) -> [0: bb10, otherwise: bb9];
    }

    bb12: {
        switchInt(move _8) -> [0: bb8, otherwise: bb7];
    }

    bb13: {
        switchInt(move _9) -> [0: bb6, otherwise: bb5];
    }

    bb14: {
        switchInt(move _10) -> [0: bb4, otherwise: bb3];
    }

    bb15: {
        switchInt(move _11) -> [0: bb2, otherwise: bb1];
    }

    bb16: {
        _12 = (((_1.1: std::option::Option<&clap::ArgMatches<'_>>) as Some).0: &clap::ArgMatches<'_>);
        _14 = <add::Add as StructOpt>::from_clap(_12) -> [return: bb17, unwind continue];
    }

    bb17: {
        _13 = Zoxide::Add(move _14);
        _0 = std::option::Option::<Zoxide>::Some(move _13);
        goto -> bb26;
    }

    bb18: {
        _15 = (((_1.1: std::option::Option<&clap::ArgMatches<'_>>) as Some).0: &clap::ArgMatches<'_>);
        _17 = <Import as StructOpt>::from_clap(_15) -> [return: bb19, unwind continue];
    }

    bb19: {
        _16 = Zoxide::Import(move _17);
        _0 = std::option::Option::<Zoxide>::Some(move _16);
        goto -> bb26;
    }

    bb20: {
        _18 = (((_1.1: std::option::Option<&clap::ArgMatches<'_>>) as Some).0: &clap::ArgMatches<'_>);
        _20 = <Init as StructOpt>::from_clap(_18) -> [return: bb21, unwind continue];
    }

    bb21: {
        _19 = Zoxide::Init(move _20);
        _0 = std::option::Option::<Zoxide>::Some(move _19);
        goto -> bb26;
    }

    bb22: {
        _21 = (((_1.1: std::option::Option<&clap::ArgMatches<'_>>) as Some).0: &clap::ArgMatches<'_>);
        _23 = <Query as StructOpt>::from_clap(_21) -> [return: bb23, unwind continue];
    }

    bb23: {
        _22 = Zoxide::Query(move _23);
        _0 = std::option::Option::<Zoxide>::Some(move _22);
        goto -> bb26;
    }

    bb24: {
        _24 = (((_1.1: std::option::Option<&clap::ArgMatches<'_>>) as Some).0: &clap::ArgMatches<'_>);
        _26 = <Remove as StructOpt>::from_clap(_24) -> [return: bb25, unwind continue];
    }

    bb25: {
        _25 = Zoxide::Remove(move _26);
        _0 = std::option::Option::<Zoxide>::Some(move _25);
        goto -> bb26;
    }

    bb26: {
        return;
    }
}

fn <impl at src/main.rs:10:17: 10:26>::is_subcommand() -> bool {
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn main() -> Result<(), anyhow::Error> {
    let mut _0: std::result::Result<(), anyhow::Error>;
    let _1: Zoxide;
    let mut _2: isize;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _5: std::result::Result<(), anyhow::Error>;
    let mut _6: &subcommand::add::Add;
    let mut _7: isize;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _11: std::result::Result<(), anyhow::Error>;
    let mut _12: &subcommand::import::Import;
    let mut _13: isize;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _17: std::result::Result<(), anyhow::Error>;
    let mut _18: &subcommand::init::Init;
    let mut _19: isize;
    let mut _22: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _23: std::result::Result<(), anyhow::Error>;
    let mut _24: isize;
    let mut _27: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, anyhow::Error>>;
    let mut _28: std::result::Result<(), anyhow::Error>;
    let mut _29: &subcommand::remove::Remove;
    let mut _30: isize;
    scope 1 {
        debug opt => _1;
        let _3: subcommand::add::Add;
        let _9: subcommand::import::Import;
        let _15: subcommand::init::Init;
        let _21: subcommand::query::Query;
        let _26: subcommand::remove::Remove;
        scope 2 {
            debug add => _3;
            let _8: std::result::Result<std::convert::Infallible, anyhow::Error>;
            scope 3 {
                debug residual => _8;
                scope 4 {
                }
            }
            scope 5 {
                debug val => const ();
                scope 6 {
                }
            }
        }
        scope 7 {
            debug import => _9;
            let _14: std::result::Result<std::convert::Infallible, anyhow::Error>;
            scope 8 {
                debug residual => _14;
                scope 9 {
                }
            }
            scope 10 {
                debug val => const ();
                scope 11 {
                }
            }
        }
        scope 12 {
            debug init => _15;
            let _20: std::result::Result<std::convert::Infallible, anyhow::Error>;
            scope 13 {
                debug residual => _20;
                scope 14 {
                }
            }
            scope 15 {
                debug val => const ();
                scope 16 {
                }
            }
        }
        scope 17 {
            debug query => _21;
            let _25: std::result::Result<std::convert::Infallible, anyhow::Error>;
            scope 18 {
                debug residual => _25;
                scope 19 {
                }
            }
            scope 20 {
                debug val => const ();
                scope 21 {
                }
            }
        }
        scope 22 {
            debug remove => _26;
            let _31: std::result::Result<std::convert::Infallible, anyhow::Error>;
            scope 23 {
                debug residual => _31;
                scope 24 {
                }
            }
            scope 25 {
                debug val => const ();
                scope 26 {
                }
            }
        }
    }

    bb0: {
        _1 = <Zoxide as StructOpt>::from_args() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = discriminant(_1);
        switchInt(move _2) -> [0: bb4, 1: bb10, 2: bb16, 3: bb20, 4: bb2, otherwise: bb3];
    }

    bb2: {
        _26 = move ((_1 as Remove).0: subcommand::remove::Remove);
        _29 = &_26;
        _28 = Remove::run(move _29) -> [return: bb24, unwind: bb31];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _3 = move ((_1 as Add).0: subcommand::add::Add);
        _6 = &_3;
        _5 = add::Add::run(move _6) -> [return: bb5, unwind: bb33];
    }

    bb5: {
        _4 = <Result<(), anyhow::Error> as Try>::branch(move _5) -> [return: bb6, unwind: bb33];
    }

    bb6: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb7, 1: bb8, otherwise: bb3];
    }

    bb7: {
        drop(_3) -> [return: bb29, unwind continue];
    }

    bb8: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _8) -> [return: bb9, unwind: bb33];
    }

    bb9: {
        drop(_3) -> [return: bb30, unwind continue];
    }

    bb10: {
        _9 = move ((_1 as Import).0: subcommand::import::Import);
        _12 = &_9;
        _11 = Import::run(move _12) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _10 = <Result<(), anyhow::Error> as Try>::branch(move _11) -> [return: bb12, unwind: bb32];
    }

    bb12: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb13, 1: bb14, otherwise: bb3];
    }

    bb13: {
        drop(_9) -> [return: bb29, unwind continue];
    }

    bb14: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _14) -> [return: bb15, unwind: bb32];
    }

    bb15: {
        drop(_9) -> [return: bb30, unwind continue];
    }

    bb16: {
        _15 = move ((_1 as Init).0: subcommand::init::Init);
        _18 = &_15;
        _17 = Init::run(move _18) -> [return: bb17, unwind continue];
    }

    bb17: {
        _16 = <Result<(), anyhow::Error> as Try>::branch(move _17) -> [return: bb18, unwind continue];
    }

    bb18: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb29, 1: bb19, otherwise: bb3];
    }

    bb19: {
        _20 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _20) -> [return: bb30, unwind continue];
    }

    bb20: {
        _21 = move ((_1 as Query).0: subcommand::query::Query);
        _23 = Query::run(move _21) -> [return: bb21, unwind continue];
    }

    bb21: {
        _22 = <Result<(), anyhow::Error> as Try>::branch(move _23) -> [return: bb22, unwind continue];
    }

    bb22: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [0: bb29, 1: bb23, otherwise: bb3];
    }

    bb23: {
        _25 = move ((_22 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _25) -> [return: bb30, unwind continue];
    }

    bb24: {
        _27 = <Result<(), anyhow::Error> as Try>::branch(move _28) -> [return: bb25, unwind: bb31];
    }

    bb25: {
        _30 = discriminant(_27);
        switchInt(move _30) -> [0: bb26, 1: bb27, otherwise: bb3];
    }

    bb26: {
        drop(_26) -> [return: bb29, unwind continue];
    }

    bb27: {
        _31 = move ((_27 as Break).0: std::result::Result<std::convert::Infallible, anyhow::Error>);
        _0 = <Result<(), anyhow::Error> as FromResidual<Result<Infallible, anyhow::Error>>>::from_residual(move _31) -> [return: bb28, unwind: bb31];
    }

    bb28: {
        drop(_26) -> [return: bb30, unwind continue];
    }

    bb29: {
        _0 = Result::<(), anyhow::Error>::Ok(const ());
        goto -> bb30;
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_26) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_9) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        drop(_3) -> [return: bb34, unwind terminate(cleanup)];
    }

    bb34 (cleanup): {
        resume;
    }
}

fn Zoxide::Add(_1: add::Add) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Add(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Zoxide::Add(_1: add::Add) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Add(move _1);
        return;
    }
}

fn Zoxide::Import(_1: Import) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Import(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Zoxide::Import(_1: Import) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Import(move _1);
        return;
    }
}

fn Zoxide::Init(_1: Init) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Init(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Zoxide::Init(_1: Init) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Init(move _1);
        return;
    }
}

fn Zoxide::Query(_1: Query) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Query(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Zoxide::Query(_1: Query) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Query(move _1);
        return;
    }
}

fn Zoxide::Remove(_1: Remove) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Remove(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Zoxide::Remove(_1: Remove) -> Zoxide {
    let mut _0: Zoxide;

    bb0: {
        _0 = Zoxide::Remove(move _1);
        return;
    }
}
