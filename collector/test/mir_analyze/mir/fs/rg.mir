// WARNING: This output format is intended for human consumers only
// and is subject to change without notice. Knock yourself out.
static MESSAGES: AtomicBool = {
    let mut _0: std::sync::atomic::AtomicBool;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicBool::new(const false) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static IGNORE_MESSAGES: AtomicBool = {
    let mut _0: std::sync::atomic::AtomicBool;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicBool::new(const false) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

static ERRORED: AtomicBool = {
    let mut _0: std::sync::atomic::AtomicBool;

    bb0: {
        ConstEvalCounter;
        _0 = AtomicBool::new(const false) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn messages() -> bool {
    let mut _0: bool;
    let _1: &std::sync::atomic::AtomicBool;
    let mut _2: std::sync::atomic::Ordering;

    bb0: {
        _1 = const {alloc4: &AtomicBool};
        _2 = SeqCst;
        _0 = AtomicBool::load(_1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc4 (static: MESSAGES, size: 1, align: 1) {
    00                                              │ .
}

fn set_messages(_1: bool) -> () {
    debug yes => _1;
    let mut _0: ();
    let _2: &std::sync::atomic::AtomicBool;
    let mut _3: std::sync::atomic::Ordering;

    bb0: {
        _2 = const {alloc4: &AtomicBool};
        _3 = SeqCst;
        _0 = AtomicBool::store(_2, _1, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc4 (static: MESSAGES, size: 1, align: 1) {
    00                                              │ .
}

fn ignore_messages() -> bool {
    let mut _0: bool;
    let _1: &std::sync::atomic::AtomicBool;
    let mut _2: std::sync::atomic::Ordering;

    bb0: {
        _1 = const {alloc5: &AtomicBool};
        _2 = SeqCst;
        _0 = AtomicBool::load(_1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc5 (static: IGNORE_MESSAGES, size: 1, align: 1) {
    00                                              │ .
}

fn set_ignore_messages(_1: bool) -> () {
    debug yes => _1;
    let mut _0: ();
    let _2: &std::sync::atomic::AtomicBool;
    let mut _3: std::sync::atomic::Ordering;

    bb0: {
        _2 = const {alloc5: &AtomicBool};
        _3 = SeqCst;
        _0 = AtomicBool::store(_2, _1, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc5 (static: IGNORE_MESSAGES, size: 1, align: 1) {
    00                                              │ .
}

fn errored() -> bool {
    let mut _0: bool;
    let _1: &std::sync::atomic::AtomicBool;
    let mut _2: std::sync::atomic::Ordering;

    bb0: {
        _1 = const {alloc6: &AtomicBool};
        _2 = SeqCst;
        _0 = AtomicBool::load(_1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc6 (static: ERRORED, size: 1, align: 1) {
    00                                              │ .
}

fn set_errored() -> () {
    let mut _0: ();
    let _1: ();
    let _2: &std::sync::atomic::AtomicBool;
    let mut _3: std::sync::atomic::Ordering;

    bb0: {
        _2 = const {alloc6: &AtomicBool};
        _3 = SeqCst;
        _1 = AtomicBool::store(_2, const true, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc6 (static: ERRORED, size: 1, align: 1) {
    00                                              │ .
}

const ABOUT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\nripgrep (rg) recursively searches the current directory for a regex pattern.\nBy default, ripgrep will respect gitignore rules and automatically skip hidden\nfiles/directories and binary files.\n\nUse -h for short descriptions and --help for more details.\n\nProject home page: https://github.com/BurntSushi/ripgrep\n";
        return;
    }
}

const USAGE: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "\n    rg [OPTIONS] PATTERN [PATH ...]\n    rg [OPTIONS] -e PATTERN ... [PATH ...]\n    rg [OPTIONS] -f PATTERNFILE ... [PATH ...]\n    rg [OPTIONS] --files [PATH ...]\n    rg [OPTIONS] --type-list\n    command | rg [OPTIONS] PATTERN\n    rg [OPTIONS] --help\n    rg [OPTIONS] --version";
        return;
    }
}

const TEMPLATE: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "{bin} {version}\n{author}\n{about}\n\nUSAGE:{usage}\n\nARGS:\n{positionals}\n\nOPTIONS:\n{unified}";
        return;
    }
}

fn app() -> App<'_, '_> {
    let mut _0: clap::App<'_, '_>;
    let mut _1: clap::App<'_, '_>;
    let mut _2: clap::App<'_, '_>;
    let mut _3: clap::App<'_, '_>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: clap::App<'_, '_>;
    let mut _6: clap::App<'_, '_>;
    let mut _7: clap::App<'_, '_>;
    let mut _8: clap::App<'_, '_>;
    let mut _9: clap::App<'_, '_>;
    let mut _10: clap::App<'_, '_>;
    let mut _11: clap::App<'_, '_>;
    let mut _12: &str;
    let _13: &std::string::String;
    let _14: &app::app::LONG_VERSION;
    let mut _15: clap::AppSettings;
    let mut _16: clap::AppSettings;
    let mut _17: std::vec::IntoIter<app::RGArg>;
    let mut _18: std::vec::Vec<app::RGArg>;
    let mut _20: std::option::Option<app::RGArg>;
    let mut _21: &mut std::vec::IntoIter<app::RGArg>;
    let mut _22: isize;
    let mut _24: clap::App<'_, '_>;
    let mut _25: clap::App<'_, '_>;
    let mut _26: clap::Arg<'_, '_>;
    let mut _27: bool;
    let mut _28: bool;
    scope 1 {
        debug app => _1;
        let mut _19: std::vec::IntoIter<app::RGArg>;
        scope 2 {
            debug iter => _19;
            let _23: app::RGArg;
            scope 3 {
                debug arg => _23;
            }
        }
    }

    bb0: {
        _27 = const false;
        _28 = const false;
        _11 = App::<'_, '_>::new::<&str>(const "ripgrep") -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = App::<'_, '_>::author::<&str>(move _11, const "Andrew Gallant <jamslam@gmail.com>") -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = App::<'_, '_>::version::<&str>(move _10, const "13.0.0") -> [return: bb3, unwind continue];
    }

    bb3: {
        _28 = const true;
        _14 = const {alloc7: &LONG_VERSION};
        _13 = <LONG_VERSION as Deref>::deref(_14) -> [return: bb4, unwind: bb29];
    }

    bb4: {
        _12 = std::string::String::as_str(_13) -> [return: bb5, unwind: bb29];
    }

    bb5: {
        _28 = const false;
        _8 = App::<'_, '_>::long_version::<&str>(move _9, move _12) -> [return: bb6, unwind: bb29];
    }

    bb6: {
        _28 = const false;
        _7 = App::<'_, '_>::about::<&str>(move _8, const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = App::<'_, '_>::max_term_width(move _7, const 100_usize) -> [return: bb8, unwind continue];
    }

    bb8: {
        _15 = UnifiedHelpMessage;
        _5 = App::<'_, '_>::setting(move _6, move _15) -> [return: bb9, unwind continue];
    }

    bb9: {
        _16 = AllArgsOverrideSelf;
        _4 = App::<'_, '_>::setting(move _5, move _16) -> [return: bb10, unwind continue];
    }

    bb10: {
        _3 = App::<'_, '_>::usage::<&str>(move _4, const _) -> [return: bb11, unwind continue];
    }

    bb11: {
        _2 = App::<'_, '_>::template::<&str>(move _3, const _) -> [return: bb12, unwind continue];
    }

    bb12: {
        _1 = App::<'_, '_>::help_message::<&str>(move _2, const "Prints help information. Use --help for more details.") -> [return: bb13, unwind continue];
    }

    bb13: {
        _27 = const true;
        _18 = all_args_and_flags() -> [return: bb14, unwind: bb27];
    }

    bb14: {
        _17 = <Vec<RGArg> as IntoIterator>::into_iter(move _18) -> [return: bb15, unwind: bb27];
    }

    bb15: {
        _19 = move _17;
        goto -> bb16;
    }

    bb16: {
        _21 = &mut _19;
        _20 = <std::vec::IntoIter<RGArg> as Iterator>::next(_21) -> [return: bb17, unwind: bb23];
    }

    bb17: {
        _22 = discriminant(_20);
        switchInt(move _22) -> [0: bb20, 1: bb18, otherwise: bb19];
    }

    bb18: {
        _23 = move ((_20 as Some).0: app::RGArg);
        _27 = const false;
        _25 = move _1;
        _26 = move (_23.0: clap::Arg<'_, '_>);
        _24 = App::<'_, '_>::arg::<clap::Arg<'_, '_>>(move _25, move _26) -> [return: bb21, unwind: bb25];
    }

    bb19: {
        unreachable;
    }

    bb20: {
        drop(_19) -> [return: bb22, unwind: bb27];
    }

    bb21: {
        _27 = const true;
        _1 = move _24;
        drop((_23.5: app::RGArgKind)) -> [return: bb16, unwind: bb23];
    }

    bb22: {
        _27 = const false;
        _0 = move _1;
        _27 = const false;
        return;
    }

    bb23 (cleanup): {
        drop(_19) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        resume;
    }

    bb25 (cleanup): {
        drop((_23.5: app::RGArgKind)) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_1) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        switchInt(_27) -> [0: bb24, otherwise: bb26];
    }

    bb28 (cleanup): {
        drop(_9) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        switchInt(_28) -> [0: bb24, otherwise: bb28];
    }
}

alloc7 (static: LONG_VERSION, size: 0, align: 1) {}

static LONG_VERSION: LONG_VERSION = {
    let mut _0: app::app::LONG_VERSION;
    let mut _1: ();

    bb0: {
        StorageLive(_1);
        _1 = ();
        _0 = LONG_VERSION { __private_field: move _1 };
        StorageDead(_1);
        return;
    }
}

fn app::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:133:9: 133:36>::deref(_1: &LONG_VERSION) -> &std::string::String {
    debug self => _1;
    let mut _0: &std::string::String;

    bb0: {
        _0 = __stability() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn __static_ref_initialize() -> std::string::String {
    let mut _0: std::string::String;
    let mut _1: std::option::Option<&str>;

    bb0: {
        _1 = Option::<&str>::None;
        _0 = long_version(move _1, const true) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn __stability() -> &std::string::String {
    let mut _0: &std::string::String;
    let _1: &lazy_static::lazy::Lazy<std::string::String>;

    bb0: {
        _1 = const {alloc8: &Lazy<std::string::String>};
        _0 = Lazy::<std::string::String>::get::<fn() -> std::string::String {__static_ref_initialize}>(_1, __static_ref_initialize) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

alloc8 (static: LAZY, size: 32, align: 8) {
    0x00 │ 00 00 00 00 00 00 00 80 __ __ __ __ __ __ __ __ │ ........░░░░░░░░
    0x10 │ __ __ __ __ __ __ __ __ 00 00 00 00 __ __ __ __ │ ░░░░░░░░....░░░░
}

static LAZY: Lazy<std::string::String> = {
    let mut _0: lazy_static::lazy::Lazy<std::string::String>;

    bb0: {
        _0 = const _;
        return;
    }
}

fn app::<impl at /home/workstation/.cargo/registry/src/github.com-1ecc6299db9ec823/lazy_static-1.4.0/src/lib.rs:147:9: 147:39>::initialize(_1: &LONG_VERSION) -> () {
    debug lazy => _1;
    let mut _0: ();
    let _2: &std::string::String;
    scope 1 {
    }

    bb0: {
        _2 = <LONG_VERSION as Deref>::deref(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn long_version(_1: Option<&str>, _2: bool) -> std::string::String {
    debug revision_hash => _1;
    debug cpu => _2;
    let mut _0: std::string::String;
    let _3: std::string::String;
    let mut _4: std::option::Option<&str>;
    let mut _5: std::option::Option<&str>;
    let mut _6: isize;
    let _7: &str;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &&str;
    let mut _17: std::fmt::Arguments<'_>;
    let mut _18: &[&str];
    let mut _19: &[core::fmt::rt::Argument<'_>];
    let _20: &[core::fmt::rt::Argument<'_>; 1];
    let _21: [core::fmt::rt::Argument<'_>; 1];
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &std::string::String;
    let mut _25: bool;
    let mut _26: &std::vec::Vec<&str>;
    let mut _28: std::fmt::Arguments<'_>;
    let mut _29: &[&str];
    let mut _30: &[core::fmt::rt::Argument<'_>];
    let _31: &[core::fmt::rt::Argument<'_>; 2];
    let _32: [core::fmt::rt::Argument<'_>; 2];
    let mut _33: core::fmt::rt::Argument<'_>;
    let _34: &std::string::String;
    let mut _35: core::fmt::rt::Argument<'_>;
    let _36: &std::string::String;
    let _37: std::string::String;
    let _38: &[&str];
    let mut _39: &std::vec::Vec<&str>;
    let _40: std::vec::Vec<&str>;
    let _41: &str;
    let mut _43: std::fmt::Arguments<'_>;
    let mut _44: &[&str];
    let mut _45: &[core::fmt::rt::Argument<'_>];
    let _46: &[core::fmt::rt::Argument<'_>; 3];
    let _47: [core::fmt::rt::Argument<'_>; 3];
    let mut _48: core::fmt::rt::Argument<'_>;
    let _49: &std::string::String;
    let mut _50: core::fmt::rt::Argument<'_>;
    let _51: &std::string::String;
    let _52: std::string::String;
    let _53: &[&str];
    let mut _54: &std::vec::Vec<&str>;
    let _55: std::vec::Vec<&str>;
    let _56: &str;
    let mut _57: core::fmt::rt::Argument<'_>;
    let _58: &std::string::String;
    let _59: std::string::String;
    let _60: &[&str];
    let mut _61: &std::vec::Vec<&str>;
    let _62: &str;
    scope 1 {
        debug hash => _3;
        let _16: std::string::String;
        let _24: std::vec::Vec<&str>;
        let mut _65: &[&str; 1];
        scope 4 {
            debug res => _16;
        }
        scope 5 {
            debug runtime => _24;
            let _27: std::string::String;
            let _42: std::string::String;
            let mut _63: &[&str; 3];
            let mut _64: &[&str; 4];
            scope 6 {
                debug res => _27;
            }
            scope 7 {
                debug res => _42;
            }
        }
    }
    scope 2 {
        debug githash => _7;
        let _8: std::string::String;
        let mut _66: &[&str; 2];
        scope 3 {
            debug res => _8;
        }
    }

    bb0: {
        _5 = Option::<&str>::None;
        _4 = Option::<&str>::or(_1, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = ((_4 as Some).0: &str);
        _66 = const _;
        _10 = _66 as &[&str] (PointerCoercion(Unsize));
        _15 = &_7;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_15) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _3 = std::string::String::new() -> [return: bb8, unwind continue];
    }

    bb5: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = format(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _3 = move _8;
        goto -> bb8;
    }

    bb8: {
        switchInt(_2) -> [0: bb9, otherwise: bb13];
    }

    bb9: {
        _65 = const _;
        _18 = _65 as &[&str] (PointerCoercion(Unsize));
        _23 = &_3;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_23) -> [return: bb10, unwind: bb54];
    }

    bb10: {
        _21 = [move _22];
        _20 = &_21;
        _19 = _20 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _17 = Arguments::<'_>::new_v1(move _18, move _19) -> [return: bb11, unwind: bb54];
    }

    bb11: {
        _16 = format(move _17) -> [return: bb12, unwind: bb54];
    }

    bb12: {
        _0 = move _16;
        goto -> bb41;
    }

    bb13: {
        _24 = runtime_cpu_features() -> [return: bb14, unwind: bb54];
    }

    bb14: {
        _26 = &_24;
        _25 = Vec::<&str>::is_empty(move _26) -> [return: bb15, unwind: bb53];
    }

    bb15: {
        switchInt(move _25) -> [0: bb26, otherwise: bb16];
    }

    bb16: {
        _63 = const _;
        _29 = _63 as &[&str] (PointerCoercion(Unsize));
        _34 = &_3;
        _33 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_34) -> [return: bb17, unwind: bb53];
    }

    bb17: {
        _40 = compile_cpu_features() -> [return: bb18, unwind: bb53];
    }

    bb18: {
        _39 = &_40;
        _38 = <Vec<&str> as Deref>::deref(move _39) -> [return: bb19, unwind: bb52];
    }

    bb19: {
        _41 = const " ";
        _37 = slice::<impl [&str]>::join::<&str>(_38, _41) -> [return: bb20, unwind: bb52];
    }

    bb20: {
        _36 = &_37;
        _35 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_36) -> [return: bb21, unwind: bb51];
    }

    bb21: {
        _32 = [move _33, move _35];
        _31 = &_32;
        _30 = _31 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _28 = Arguments::<'_>::new_v1(move _29, move _30) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        _27 = format(move _28) -> [return: bb23, unwind: bb51];
    }

    bb23: {
        drop(_37) -> [return: bb24, unwind: bb49];
    }

    bb24: {
        drop(_40) -> [return: bb25, unwind: bb50];
    }

    bb25: {
        _0 = move _27;
        goto -> bb40;
    }

    bb26: {
        _64 = const _;
        _44 = _64 as &[&str] (PointerCoercion(Unsize));
        _49 = &_3;
        _48 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_49) -> [return: bb27, unwind: bb53];
    }

    bb27: {
        _55 = compile_cpu_features() -> [return: bb28, unwind: bb53];
    }

    bb28: {
        _54 = &_55;
        _53 = <Vec<&str> as Deref>::deref(move _54) -> [return: bb29, unwind: bb48];
    }

    bb29: {
        _56 = const " ";
        _52 = slice::<impl [&str]>::join::<&str>(_53, _56) -> [return: bb30, unwind: bb48];
    }

    bb30: {
        _51 = &_52;
        _50 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_51) -> [return: bb31, unwind: bb47];
    }

    bb31: {
        _61 = &_24;
        _60 = <Vec<&str> as Deref>::deref(move _61) -> [return: bb32, unwind: bb47];
    }

    bb32: {
        _62 = const " ";
        _59 = slice::<impl [&str]>::join::<&str>(_60, _62) -> [return: bb33, unwind: bb47];
    }

    bb33: {
        _58 = &_59;
        _57 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_58) -> [return: bb34, unwind: bb46];
    }

    bb34: {
        _47 = [move _48, move _50, move _57];
        _46 = &_47;
        _45 = _46 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _43 = Arguments::<'_>::new_v1(move _44, move _45) -> [return: bb35, unwind: bb46];
    }

    bb35: {
        _42 = format(move _43) -> [return: bb36, unwind: bb46];
    }

    bb36: {
        drop(_59) -> [return: bb37, unwind: bb43];
    }

    bb37: {
        drop(_52) -> [return: bb38, unwind: bb44];
    }

    bb38: {
        drop(_55) -> [return: bb39, unwind: bb45];
    }

    bb39: {
        _0 = move _42;
        goto -> bb40;
    }

    bb40: {
        drop(_24) -> [return: bb41, unwind: bb54];
    }

    bb41: {
        drop(_3) -> [return: bb42, unwind continue];
    }

    bb42: {
        return;
    }

    bb43 (cleanup): {
        drop(_52) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        drop(_55) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        drop(_42) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        drop(_59) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        drop(_52) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        drop(_55) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_40) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_27) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_37) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_40) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_24) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_3) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        resume;
    }
}

promoted[0] in long_version: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "13.0.0", const "\n", const " (compiled)"];
        _0 = &_1;
        return;
    }
}

promoted[1] in long_version: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "13.0.0", const "\n", const " (compiled)\n", const " (runtime)"];
        _0 = &_1;
        return;
    }
}

promoted[2] in long_version: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "13.0.0"];
        _0 = &_1;
        return;
    }
}

promoted[3] in long_version: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const " (rev ", const ")"];
        _0 = &_1;
        return;
    }
}

fn compile_cpu_features() -> Vec<&str> {
    let mut _0: std::vec::Vec<&str>;
    let mut _1: std::vec::Vec<&str>;
    let mut _2: bool;
    let _3: ();
    let mut _4: &mut std::vec::Vec<&str>;
    let _5: ();
    let mut _6: &mut std::vec::Vec<&str>;
    let _7: &str;
    let mut _8: bool;
    let _9: ();
    let mut _10: &mut std::vec::Vec<&str>;
    let _11: &str;
    let _12: ();
    let mut _13: &mut std::vec::Vec<&str>;
    let _14: &str;
    scope 1 {
        debug features => _1;
    }

    bb0: {
        _1 = Vec::<&str>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = const false;
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _4 = &mut _1;
        _3 = Vec::<&str>::push(move _4, const "+SIMD") -> [return: bb10, unwind: bb8];
    }

    bb3: {
        _6 = &mut _1;
        _7 = const "-SIMD";
        _5 = Vec::<&str>::push(move _6, _7) -> [return: bb11, unwind: bb8];
    }

    bb4: {
        _8 = const false;
        switchInt(move _8) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _10 = &mut _1;
        _11 = const "+AVX";
        _9 = Vec::<&str>::push(move _10, _11) -> [return: bb12, unwind: bb8];
    }

    bb6: {
        _13 = &mut _1;
        _14 = const "-AVX";
        _12 = Vec::<&str>::push(move _13, _14) -> [return: bb13, unwind: bb8];
    }

    bb7: {
        _0 = move _1;
        return;
    }

    bb8 (cleanup): {
        drop(_1) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        goto -> bb4;
    }

    bb11: {
        goto -> bb4;
    }

    bb12: {
        goto -> bb7;
    }

    bb13: {
        goto -> bb7;
    }
}

fn runtime_cpu_features() -> Vec<&str> {
    let mut _0: std::vec::Vec<&str>;
    let mut _1: std::vec::Vec<&str>;
    let mut _2: bool;
    let mut _3: bool;
    let _4: ();
    let mut _5: &mut std::vec::Vec<&str>;
    let _6: ();
    let mut _7: &mut std::vec::Vec<&str>;
    let _8: &str;
    let mut _9: bool;
    let mut _10: bool;
    let _11: ();
    let mut _12: &mut std::vec::Vec<&str>;
    let _13: &str;
    let _14: ();
    let mut _15: &mut std::vec::Vec<&str>;
    let _16: &str;
    scope 1 {
        debug features => _1;
    }

    bb0: {
        _1 = Vec::<&str>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = const false;
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _3 = std_detect::detect::arch::x86::__is_feature_detected::ssse3() -> [return: bb3, unwind: bb12];
    }

    bb3: {
        switchInt(move _3) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = &mut _1;
        _4 = Vec::<&str>::push(move _5, const "+SIMD") -> [return: bb14, unwind: bb12];
    }

    bb5: {
        _7 = &mut _1;
        _8 = const "-SIMD";
        _6 = Vec::<&str>::push(move _7, _8) -> [return: bb15, unwind: bb12];
    }

    bb6: {
        _9 = const false;
        switchInt(move _9) -> [0: bb7, otherwise: bb9];
    }

    bb7: {
        _10 = std_detect::detect::arch::x86::__is_feature_detected::avx2() -> [return: bb8, unwind: bb12];
    }

    bb8: {
        switchInt(move _10) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _12 = &mut _1;
        _13 = const "+AVX";
        _11 = Vec::<&str>::push(move _12, _13) -> [return: bb16, unwind: bb12];
    }

    bb10: {
        _15 = &mut _1;
        _16 = const "-AVX";
        _14 = Vec::<&str>::push(move _15, _16) -> [return: bb17, unwind: bb12];
    }

    bb11: {
        _0 = move _1;
        return;
    }

    bb12 (cleanup): {
        drop(_1) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }

    bb14: {
        goto -> bb6;
    }

    bb15: {
        goto -> bb6;
    }

    bb16: {
        goto -> bb11;
    }

    bb17: {
        goto -> bb11;
    }
}

fn app::<impl at crates/core/app.rs:166:10: 166:15>::clone(_1: &RGArg) -> RGArg {
    debug self => _1;
    let mut _0: app::RGArg;
    let mut _2: clap::Arg<'_, '_>;
    let _3: &clap::Arg<'_, '_>;
    let _4: &str;
    let _5: &&str;
    let _6: &str;
    let _7: &&str;
    let _8: &str;
    let _9: &&str;
    let mut _10: bool;
    let _11: &bool;
    let mut _12: app::RGArgKind;
    let _13: &app::RGArgKind;

    bb0: {
        _3 = &((*_1).0: clap::Arg<'_, '_>);
        _2 = <clap::Arg<'_, '_> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: &str);
        _4 = <&str as Clone>::clone(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _7 = &((*_1).2: &str);
        _6 = <&str as Clone>::clone(_7) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _9 = &((*_1).3: &str);
        _8 = <&str as Clone>::clone(_9) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _11 = &((*_1).4: bool);
        _10 = (*_11);
        _13 = &((*_1).5: app::RGArgKind);
        _12 = <RGArgKind as Clone>::clone(_13) -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _0 = RGArg { claparg: move _2, name: _4, doc_short: _6, doc_long: _8, hidden: move _10, kind: move _12 };
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn app::<impl at crates/core/app.rs:214:10: 214:15>::clone(_1: &RGArgKind) -> RGArgKind {
    debug self => _1;
    let mut _0: app::RGArgKind;
    let mut _2: isize;
    let _3: &&str;
    let _4: &bool;
    let _5: &str;
    let mut _6: bool;
    let _7: &&str;
    let _8: &std::option::Option<&str>;
    let _9: &bool;
    let _10: &str;
    let mut _11: std::option::Option<&str>;
    let mut _12: bool;
    let _13: &&str;
    let _14: &std::option::Option<&str>;
    let _15: &&str;
    let _16: &bool;
    let _17: &std::vec::Vec<&str>;
    let _18: &str;
    let mut _19: std::option::Option<&str>;
    let _20: &str;
    let mut _21: bool;
    let mut _22: std::vec::Vec<&str>;
    scope 1 {
        debug __self_0 => _3;
        debug __self_1 => _4;
    }
    scope 2 {
        debug __self_0 => _7;
        debug __self_1 => _8;
        debug __self_2 => _9;
    }
    scope 3 {
        debug __self_0 => _13;
        debug __self_1 => _14;
        debug __self_2 => _15;
        debug __self_3 => _16;
        debug __self_4 => _17;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb5, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _13 = &(((*_1) as Flag).0: &str);
        _14 = &(((*_1) as Flag).1: std::option::Option<&str>);
        _15 = &(((*_1) as Flag).2: &str);
        _16 = &(((*_1) as Flag).3: bool);
        _17 = &(((*_1) as Flag).4: std::vec::Vec<&str>);
        _18 = <&str as Clone>::clone(_13) -> [return: bb8, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as Positional).0: &str);
        _4 = &(((*_1) as Positional).1: bool);
        _5 = <&str as Clone>::clone(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = (*_4);
        _0 = RGArgKind::Positional { value_name: _5, multiple: move _6 };
        goto -> bb12;
    }

    bb5: {
        _7 = &(((*_1) as Switch).0: &str);
        _8 = &(((*_1) as Switch).1: std::option::Option<&str>);
        _9 = &(((*_1) as Switch).2: bool);
        _10 = <&str as Clone>::clone(_7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = <Option<&str> as Clone>::clone(_8) -> [return: bb7, unwind continue];
    }

    bb7: {
        _12 = (*_9);
        _0 = RGArgKind::Switch { long: _10, short: move _11, multiple: move _12 };
        goto -> bb12;
    }

    bb8: {
        _19 = <Option<&str> as Clone>::clone(_14) -> [return: bb9, unwind continue];
    }

    bb9: {
        _20 = <&str as Clone>::clone(_15) -> [return: bb10, unwind continue];
    }

    bb10: {
        _21 = (*_16);
        _22 = <Vec<&str> as Clone>::clone(_17) -> [return: bb11, unwind continue];
    }

    bb11: {
        _0 = RGArgKind::Flag { long: _18, short: move _19, value_name: _20, multiple: move _21, possible_values: move _22 };
        goto -> bb12;
    }

    bb12: {
        return;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::positional(_1: &str, _2: &str) -> RGArg {
    debug name => _1;
    debug value_name => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;
    let mut _5: app::RGArgKind;

    bb0: {
        _4 = clap::Arg::<'_, '_>::with_name(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = clap::Arg::<'_, '_>::value_name(move _4, _2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArgKind::Positional { value_name: _2, multiple: const false };
        _0 = RGArg { claparg: move _3, name: _1, doc_short: const "", doc_long: const "", hidden: const false, kind: move _5 };
        return;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::switch(_1: &str) -> RGArg {
    debug long_name => _1;
    let mut _0: app::RGArg;
    let _2: clap::Arg<'_, '_>;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: app::RGArgKind;
    let mut _5: std::option::Option<&str>;
    scope 1 {
        debug claparg => _2;
    }

    bb0: {
        _3 = clap::Arg::<'_, '_>::with_name(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = clap::Arg::<'_, '_>::long(move _3, _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = Option::<&str>::None;
        _4 = RGArgKind::Switch { long: _1, short: move _5, multiple: const false };
        _0 = RGArg { claparg: move _2, name: _1, doc_short: const "", doc_long: const "", hidden: const false, kind: move _4 };
        return;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::flag(_1: &str, _2: &str) -> RGArg {
    debug long_name => _1;
    debug value_name => _2;
    let mut _0: app::RGArg;
    let _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    let mut _8: clap::Arg<'_, '_>;
    let mut _9: app::RGArgKind;
    let mut _10: std::option::Option<&str>;
    let mut _11: std::vec::Vec<&str>;
    scope 1 {
        debug claparg => _3;
    }

    bb0: {
        _7 = clap::Arg::<'_, '_>::with_name(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = clap::Arg::<'_, '_>::long(move _7, _1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = clap::Arg::<'_, '_>::value_name(move _6, _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = clap::Arg::<'_, '_>::takes_value(move _5, const true) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = clap::Arg::<'_, '_>::number_of_values(move _4, const 1_u64) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = move _3;
        _10 = Option::<&str>::None;
        _11 = Vec::<&str>::new() -> [return: bb6, unwind: bb7];
    }

    bb6: {
        _9 = RGArgKind::Flag { long: _1, short: move _10, value_name: _2, multiple: const false, possible_values: move _11 };
        _0 = RGArg { claparg: move _8, name: _1, doc_short: const "", doc_long: const "", hidden: const false, kind: move _9 };
        return;
    }

    bb7 (cleanup): {
        drop(_8) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::short(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug name => _2;
    let mut _0: app::RGArg;
    let mut _3: isize;
    let _4: !;
    let _5: &mut std::option::Option<&str>;
    let mut _6: std::option::Option<&str>;
    let _7: &mut std::option::Option<&str>;
    let mut _8: std::option::Option<&str>;
    let mut _9: clap::Arg<'_, '_>;
    let mut _10: clap::Arg<'_, '_>;
    let mut _11: bool;
    scope 1 {
        debug short => _5;
    }
    scope 2 {
        debug short => _7;
    }

    bb0: {
        _11 = const false;
        _11 = const true;
        _3 = discriminant((_1.5: app::RGArgKind));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = &mut (((_1.5: app::RGArgKind) as Flag).1: std::option::Option<&str>);
        _8 = Option::<&str>::Some(_2);
        (*_7) = move _8;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = begin_panic::<&str>(const "expected switch or flag") -> bb10;
    }

    bb4: {
        _5 = &mut (((_1.5: app::RGArgKind) as Switch).1: std::option::Option<&str>);
        _6 = Option::<&str>::Some(_2);
        (*_5) = move _6;
        goto -> bb5;
    }

    bb5: {
        _11 = const false;
        _10 = move (_1.0: clap::Arg<'_, '_>);
        _9 = clap::Arg::<'_, '_>::short::<&str>(move _10, _2) -> [return: bb6, unwind: bb10];
    }

    bb6: {
        _11 = const true;
        (_1.0: clap::Arg<'_, '_>) = move _9;
        _11 = const false;
        _0 = move _1;
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        drop((_1.0: clap::Arg<'_, '_>)) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        switchInt(_11) -> [0: bb8, otherwise: bb9];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::help(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug text => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        (_1.2: &str) = _2;
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::help(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::long_help(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug text => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        (_1.3: &str) = _2;
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::long_help(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::multiple(_1: RGArg) -> RGArg {
    debug self => _1;
    let mut _0: app::RGArg;
    let mut _2: isize;
    let _3: &mut bool;
    let _4: &mut bool;
    let _5: &mut bool;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: clap::Arg<'_, '_>;
    scope 1 {
        debug multiple => _3;
    }
    scope 2 {
        debug multiple => _4;
    }
    scope 3 {
        debug multiple => _5;
    }

    bb0: {
        _2 = discriminant((_1.5: app::RGArgKind));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = &mut (((_1.5: app::RGArgKind) as Flag).3: bool);
        (*_5) = const true;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &mut (((_1.5: app::RGArgKind) as Positional).1: bool);
        (*_3) = const true;
        goto -> bb5;
    }

    bb4: {
        _4 = &mut (((_1.5: app::RGArgKind) as Switch).2: bool);
        (*_4) = const true;
        goto -> bb5;
    }

    bb5: {
        _7 = move (_1.0: clap::Arg<'_, '_>);
        _6 = clap::Arg::<'_, '_>::multiple(move _7, const true) -> [return: bb6, unwind: bb8];
    }

    bb6: {
        (_1.0: clap::Arg<'_, '_>) = move _6;
        _0 = move _1;
        return;
    }

    bb7 (cleanup): {
        resume;
    }

    bb8 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb7, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::hidden(_1: RGArg) -> RGArg {
    debug self => _1;
    let mut _0: app::RGArg;
    let mut _2: clap::Arg<'_, '_>;
    let mut _3: clap::Arg<'_, '_>;

    bb0: {
        (_1.4: bool) = const true;
        _3 = move (_1.0: clap::Arg<'_, '_>);
        _2 = clap::Arg::<'_, '_>::hidden(move _3, const true) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _2;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::possible_values(_1: RGArg, _2: &[&str]) -> RGArg {
    debug self => _1;
    debug values => _2;
    let mut _0: app::RGArg;
    let mut _3: isize;
    let _4: !;
    let _5: !;
    let _6: &mut std::vec::Vec<&str>;
    let mut _7: std::vec::Vec<&str>;
    let mut _8: clap::Arg<'_, '_>;
    let mut _9: clap::Arg<'_, '_>;
    let mut _10: clap::Arg<'_, '_>;
    let mut _11: bool;
    scope 1 {
        debug possible_values => _6;
    }

    bb0: {
        _11 = const false;
        _11 = const true;
        _3 = discriminant((_1.5: app::RGArgKind));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _6 = &mut (((_1.5: app::RGArgKind) as Flag).4: std::vec::Vec<&str>);
        _7 = slice::<impl [&str]>::to_vec(_2) -> [return: bb5, unwind: bb13];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = begin_panic::<&str>(const "expected flag") -> bb13;
    }

    bb4: {
        _5 = begin_panic::<&str>(const "expected flag") -> bb13;
    }

    bb5: {
        drop((*_6)) -> [return: bb6, unwind: bb7];
    }

    bb6: {
        (*_6) = move _7;
        _11 = const false;
        _10 = move (_1.0: clap::Arg<'_, '_>);
        _9 = clap::Arg::<'_, '_>::possible_values(move _10, _2) -> [return: bb8, unwind: bb13];
    }

    bb7 (cleanup): {
        (*_6) = move _7;
        goto -> bb13;
    }

    bb8: {
        _8 = clap::Arg::<'_, '_>::hide_possible_values(move _9, const true) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _11 = const true;
        (_1.0: clap::Arg<'_, '_>) = move _8;
        _11 = const false;
        _0 = move _1;
        return;
    }

    bb10 (cleanup): {
        resume;
    }

    bb11 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb12 (cleanup): {
        drop((_1.0: clap::Arg<'_, '_>)) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_11) -> [0: bb11, otherwise: bb12];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::alias(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug name => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::alias::<&str>(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::allow_leading_hyphen(_1: RGArg) -> RGArg {
    debug self => _1;
    let mut _0: app::RGArg;
    let mut _2: isize;
    let _3: !;
    let _4: !;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: clap::Arg<'_, '_>;
    let mut _7: bool;

    bb0: {
        _7 = const false;
        _7 = const true;
        _2 = discriminant((_1.5: app::RGArgKind));
        switchInt(move _2) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const false;
        _6 = move (_1.0: clap::Arg<'_, '_>);
        _5 = clap::Arg::<'_, '_>::allow_hyphen_values(move _6, const true) -> [return: bb5, unwind: bb9];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = begin_panic::<&str>(const "expected flag") -> bb9;
    }

    bb4: {
        _4 = begin_panic::<&str>(const "expected flag") -> bb9;
    }

    bb5: {
        _7 = const true;
        (_1.0: clap::Arg<'_, '_>) = move _5;
        _7 = const false;
        _0 = move _1;
        return;
    }

    bb6 (cleanup): {
        resume;
    }

    bb7 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        drop((_1.0: clap::Arg<'_, '_>)) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        switchInt(_7) -> [0: bb7, otherwise: bb8];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::required_unless(_1: RGArg, _2: &[&str]) -> RGArg {
    debug self => _1;
    debug names => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::required_unless_one(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::conflicts(_1: RGArg, _2: &[&str]) -> RGArg {
    debug self => _1;
    debug names => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::conflicts_with_all(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::overrides(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug name => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::overrides_with(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::default_value(_1: RGArg, _2: &str) -> RGArg {
    debug self => _1;
    debug value => _2;
    let mut _0: app::RGArg;
    let mut _3: clap::Arg<'_, '_>;
    let mut _4: clap::Arg<'_, '_>;

    bb0: {
        _4 = move (_1.0: clap::Arg<'_, '_>);
        _3 = clap::Arg::<'_, '_>::default_value(move _4, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _3;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::default_value_if(_1: RGArg, _2: &str, _3: &str) -> RGArg {
    debug self => _1;
    debug value => _2;
    debug arg_name => _3;
    let mut _0: app::RGArg;
    let mut _4: clap::Arg<'_, '_>;
    let mut _5: clap::Arg<'_, '_>;
    let mut _6: std::option::Option<&str>;

    bb0: {
        _5 = move (_1.0: clap::Arg<'_, '_>);
        _6 = Option::<&str>::None;
        _4 = clap::Arg::<'_, '_>::default_value_if(move _5, _3, move _6, _2) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _4;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::number(_1: RGArg) -> RGArg {
    debug self => _1;
    let mut _0: app::RGArg;
    let mut _2: clap::Arg<'_, '_>;
    let mut _3: clap::Arg<'_, '_>;

    bb0: {
        _3 = move (_1.0: clap::Arg<'_, '_>);
        _2 = clap::Arg::<'_, '_>::validator::<{closure@crates/core/app.rs:526:47: 526:52}>(move _3, const ZeroSized: {closure@crates/core/app.rs:526:47: 526:52}) -> [return: bb1, unwind: bb3];
    }

    bb1: {
        (_1.0: clap::Arg<'_, '_>) = move _2;
        _0 = move _1;
        return;
    }

    bb2 (cleanup): {
        resume;
    }

    bb3 (cleanup): {
        drop((_1.5: app::RGArgKind)) -> [return: bb2, unwind terminate(cleanup)];
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::number::{closure#0}(_1: &{closure@crates/core/app.rs:526:47: 526:52}, _2: std::string::String) -> std::result::Result<(), std::string::String> {
    debug val => _2;
    let mut _0: std::result::Result<(), std::string::String>;
    let mut _3: std::result::Result<(), std::num::ParseIntError>;
    let mut _4: std::result::Result<usize, std::num::ParseIntError>;
    let _5: &str;
    let mut _6: &std::string::String;

    bb0: {
        _6 = &_2;
        _5 = <std::string::String as Deref>::deref(move _6) -> [return: bb1, unwind: bb6];
    }

    bb1: {
        _4 = core::str::<impl str>::parse::<usize>(_5) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _3 = std::result::Result::<usize, ParseIntError>::map::<(), {closure@crates/core/app.rs:527:38: 527:41}>(move _4, const ZeroSized: {closure@crates/core/app.rs:527:38: 527:41}) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _0 = std::result::Result::<(), ParseIntError>::map_err::<std::string::String, {closure@crates/core/app.rs:527:54: 527:59}>(move _3, const ZeroSized: {closure@crates/core/app.rs:527:54: 527:59}) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }

    bb6 (cleanup): {
        drop(_2) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::number::{closure#0}::{closure#0}(_1: {closure@crates/core/app.rs:527:38: 527:41}, _2: usize) -> () {
    let mut _0: ();

    bb0: {
        return;
    }
}

fn app::<impl at crates/core/app.rs:287:1: 287:11>::number::{closure#0}::{closure#1}(_1: {closure@crates/core/app.rs:527:54: 527:59}, _2: ParseIntError) -> std::string::String {
    debug err => _2;
    let mut _0: std::string::String;
    let mut _3: &std::num::ParseIntError;

    bb0: {
        _3 = &_2;
        _0 = <ParseIntError as ToString>::to_string(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn all_args_and_flags() -> Vec<RGArg> {
    let mut _0: std::vec::Vec<app::RGArg>;
    let mut _1: std::vec::Vec<app::RGArg>;
    let _2: ();
    let mut _3: &mut std::vec::Vec<app::RGArg>;
    let _4: ();
    let mut _5: &mut std::vec::Vec<app::RGArg>;
    let _6: ();
    let mut _7: &mut std::vec::Vec<app::RGArg>;
    let _8: ();
    let mut _9: &mut std::vec::Vec<app::RGArg>;
    let _10: ();
    let mut _11: &mut std::vec::Vec<app::RGArg>;
    let _12: ();
    let mut _13: &mut std::vec::Vec<app::RGArg>;
    let _14: ();
    let mut _15: &mut std::vec::Vec<app::RGArg>;
    let _16: ();
    let mut _17: &mut std::vec::Vec<app::RGArg>;
    let _18: ();
    let mut _19: &mut std::vec::Vec<app::RGArg>;
    let _20: ();
    let mut _21: &mut std::vec::Vec<app::RGArg>;
    let _22: ();
    let mut _23: &mut std::vec::Vec<app::RGArg>;
    let _24: ();
    let mut _25: &mut std::vec::Vec<app::RGArg>;
    let _26: ();
    let mut _27: &mut std::vec::Vec<app::RGArg>;
    let _28: ();
    let mut _29: &mut std::vec::Vec<app::RGArg>;
    let _30: ();
    let mut _31: &mut std::vec::Vec<app::RGArg>;
    let _32: ();
    let mut _33: &mut std::vec::Vec<app::RGArg>;
    let _34: ();
    let mut _35: &mut std::vec::Vec<app::RGArg>;
    let _36: ();
    let mut _37: &mut std::vec::Vec<app::RGArg>;
    let _38: ();
    let mut _39: &mut std::vec::Vec<app::RGArg>;
    let _40: ();
    let mut _41: &mut std::vec::Vec<app::RGArg>;
    let _42: ();
    let mut _43: &mut std::vec::Vec<app::RGArg>;
    let _44: ();
    let mut _45: &mut std::vec::Vec<app::RGArg>;
    let _46: ();
    let mut _47: &mut std::vec::Vec<app::RGArg>;
    let _48: ();
    let mut _49: &mut std::vec::Vec<app::RGArg>;
    let _50: ();
    let mut _51: &mut std::vec::Vec<app::RGArg>;
    let _52: ();
    let mut _53: &mut std::vec::Vec<app::RGArg>;
    let _54: ();
    let mut _55: &mut std::vec::Vec<app::RGArg>;
    let _56: ();
    let mut _57: &mut std::vec::Vec<app::RGArg>;
    let _58: ();
    let mut _59: &mut std::vec::Vec<app::RGArg>;
    let _60: ();
    let mut _61: &mut std::vec::Vec<app::RGArg>;
    let _62: ();
    let mut _63: &mut std::vec::Vec<app::RGArg>;
    let _64: ();
    let mut _65: &mut std::vec::Vec<app::RGArg>;
    let _66: ();
    let mut _67: &mut std::vec::Vec<app::RGArg>;
    let _68: ();
    let mut _69: &mut std::vec::Vec<app::RGArg>;
    let _70: ();
    let mut _71: &mut std::vec::Vec<app::RGArg>;
    let _72: ();
    let mut _73: &mut std::vec::Vec<app::RGArg>;
    let _74: ();
    let mut _75: &mut std::vec::Vec<app::RGArg>;
    let _76: ();
    let mut _77: &mut std::vec::Vec<app::RGArg>;
    let _78: ();
    let mut _79: &mut std::vec::Vec<app::RGArg>;
    let _80: ();
    let mut _81: &mut std::vec::Vec<app::RGArg>;
    let _82: ();
    let mut _83: &mut std::vec::Vec<app::RGArg>;
    let _84: ();
    let mut _85: &mut std::vec::Vec<app::RGArg>;
    let _86: ();
    let mut _87: &mut std::vec::Vec<app::RGArg>;
    let _88: ();
    let mut _89: &mut std::vec::Vec<app::RGArg>;
    let _90: ();
    let mut _91: &mut std::vec::Vec<app::RGArg>;
    let _92: ();
    let mut _93: &mut std::vec::Vec<app::RGArg>;
    let _94: ();
    let mut _95: &mut std::vec::Vec<app::RGArg>;
    let _96: ();
    let mut _97: &mut std::vec::Vec<app::RGArg>;
    let _98: ();
    let mut _99: &mut std::vec::Vec<app::RGArg>;
    let _100: ();
    let mut _101: &mut std::vec::Vec<app::RGArg>;
    let _102: ();
    let mut _103: &mut std::vec::Vec<app::RGArg>;
    let _104: ();
    let mut _105: &mut std::vec::Vec<app::RGArg>;
    let _106: ();
    let mut _107: &mut std::vec::Vec<app::RGArg>;
    let _108: ();
    let mut _109: &mut std::vec::Vec<app::RGArg>;
    let _110: ();
    let mut _111: &mut std::vec::Vec<app::RGArg>;
    let _112: ();
    let mut _113: &mut std::vec::Vec<app::RGArg>;
    let _114: ();
    let mut _115: &mut std::vec::Vec<app::RGArg>;
    let _116: ();
    let mut _117: &mut std::vec::Vec<app::RGArg>;
    let _118: ();
    let mut _119: &mut std::vec::Vec<app::RGArg>;
    let _120: ();
    let mut _121: &mut std::vec::Vec<app::RGArg>;
    let _122: ();
    let mut _123: &mut std::vec::Vec<app::RGArg>;
    let _124: ();
    let mut _125: &mut std::vec::Vec<app::RGArg>;
    let _126: ();
    let mut _127: &mut std::vec::Vec<app::RGArg>;
    let _128: ();
    let mut _129: &mut std::vec::Vec<app::RGArg>;
    let _130: ();
    let mut _131: &mut std::vec::Vec<app::RGArg>;
    let _132: ();
    let mut _133: &mut std::vec::Vec<app::RGArg>;
    let _134: ();
    let mut _135: &mut std::vec::Vec<app::RGArg>;
    let _136: ();
    let mut _137: &mut std::vec::Vec<app::RGArg>;
    let _138: ();
    let mut _139: &mut std::vec::Vec<app::RGArg>;
    let _140: ();
    let mut _141: &mut std::vec::Vec<app::RGArg>;
    let _142: ();
    let mut _143: &mut std::vec::Vec<app::RGArg>;
    let _144: ();
    let mut _145: &mut std::vec::Vec<app::RGArg>;
    let _146: ();
    let mut _147: &mut std::vec::Vec<app::RGArg>;
    let _148: ();
    let mut _149: &mut std::vec::Vec<app::RGArg>;
    let _150: ();
    let mut _151: &mut std::vec::Vec<app::RGArg>;
    let _152: ();
    let mut _153: &mut std::vec::Vec<app::RGArg>;
    let _154: ();
    let mut _155: &mut std::vec::Vec<app::RGArg>;
    let _156: ();
    let mut _157: &mut std::vec::Vec<app::RGArg>;
    let _158: ();
    let mut _159: &mut std::vec::Vec<app::RGArg>;
    let _160: ();
    let mut _161: &mut std::vec::Vec<app::RGArg>;
    let _162: ();
    let mut _163: &mut std::vec::Vec<app::RGArg>;
    let _164: ();
    let mut _165: &mut std::vec::Vec<app::RGArg>;
    let _166: ();
    let mut _167: &mut std::vec::Vec<app::RGArg>;
    let _168: ();
    let mut _169: &mut std::vec::Vec<app::RGArg>;
    let _170: ();
    let mut _171: &mut std::vec::Vec<app::RGArg>;
    let _172: ();
    let mut _173: &mut std::vec::Vec<app::RGArg>;
    let _174: ();
    let mut _175: &mut std::vec::Vec<app::RGArg>;
    let _176: ();
    let mut _177: &mut std::vec::Vec<app::RGArg>;
    let _178: ();
    let mut _179: &mut std::vec::Vec<app::RGArg>;
    let _180: ();
    let mut _181: &mut std::vec::Vec<app::RGArg>;
    let _182: ();
    let mut _183: &mut std::vec::Vec<app::RGArg>;
    let _184: ();
    let mut _185: &mut std::vec::Vec<app::RGArg>;
    let _186: ();
    let mut _187: &mut std::vec::Vec<app::RGArg>;
    let _188: ();
    let mut _189: &mut std::vec::Vec<app::RGArg>;
    let _190: ();
    let mut _191: &mut std::vec::Vec<app::RGArg>;
    let _192: ();
    let mut _193: &mut std::vec::Vec<app::RGArg>;
    let _194: ();
    let mut _195: &mut std::vec::Vec<app::RGArg>;
    scope 1 {
        debug args => _1;
    }

    bb0: {
        _1 = Vec::<RGArg>::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &mut _1;
        _2 = arg_pattern(_3) -> [return: bb2, unwind: bb99];
    }

    bb2: {
        _5 = &mut _1;
        _4 = arg_path(_5) -> [return: bb3, unwind: bb99];
    }

    bb3: {
        _7 = &mut _1;
        _6 = flag_after_context(_7) -> [return: bb4, unwind: bb99];
    }

    bb4: {
        _9 = &mut _1;
        _8 = flag_auto_hybrid_regex(_9) -> [return: bb5, unwind: bb99];
    }

    bb5: {
        _11 = &mut _1;
        _10 = flag_before_context(_11) -> [return: bb6, unwind: bb99];
    }

    bb6: {
        _13 = &mut _1;
        _12 = flag_binary(_13) -> [return: bb7, unwind: bb99];
    }

    bb7: {
        _15 = &mut _1;
        _14 = flag_block_buffered(_15) -> [return: bb8, unwind: bb99];
    }

    bb8: {
        _17 = &mut _1;
        _16 = flag_byte_offset(_17) -> [return: bb9, unwind: bb99];
    }

    bb9: {
        _19 = &mut _1;
        _18 = flag_case_sensitive(_19) -> [return: bb10, unwind: bb99];
    }

    bb10: {
        _21 = &mut _1;
        _20 = flag_color(_21) -> [return: bb11, unwind: bb99];
    }

    bb11: {
        _23 = &mut _1;
        _22 = flag_colors(_23) -> [return: bb12, unwind: bb99];
    }

    bb12: {
        _25 = &mut _1;
        _24 = flag_column(_25) -> [return: bb13, unwind: bb99];
    }

    bb13: {
        _27 = &mut _1;
        _26 = flag_context(_27) -> [return: bb14, unwind: bb99];
    }

    bb14: {
        _29 = &mut _1;
        _28 = flag_context_separator(_29) -> [return: bb15, unwind: bb99];
    }

    bb15: {
        _31 = &mut _1;
        _30 = flag_count(_31) -> [return: bb16, unwind: bb99];
    }

    bb16: {
        _33 = &mut _1;
        _32 = flag_count_matches(_33) -> [return: bb17, unwind: bb99];
    }

    bb17: {
        _35 = &mut _1;
        _34 = flag_crlf(_35) -> [return: bb18, unwind: bb99];
    }

    bb18: {
        _37 = &mut _1;
        _36 = flag_debug(_37) -> [return: bb19, unwind: bb99];
    }

    bb19: {
        _39 = &mut _1;
        _38 = flag_dfa_size_limit(_39) -> [return: bb20, unwind: bb99];
    }

    bb20: {
        _41 = &mut _1;
        _40 = flag_encoding(_41) -> [return: bb21, unwind: bb99];
    }

    bb21: {
        _43 = &mut _1;
        _42 = flag_engine(_43) -> [return: bb22, unwind: bb99];
    }

    bb22: {
        _45 = &mut _1;
        _44 = flag_field_context_separator(_45) -> [return: bb23, unwind: bb99];
    }

    bb23: {
        _47 = &mut _1;
        _46 = flag_field_match_separator(_47) -> [return: bb24, unwind: bb99];
    }

    bb24: {
        _49 = &mut _1;
        _48 = flag_file(_49) -> [return: bb25, unwind: bb99];
    }

    bb25: {
        _51 = &mut _1;
        _50 = flag_files(_51) -> [return: bb26, unwind: bb99];
    }

    bb26: {
        _53 = &mut _1;
        _52 = flag_files_with_matches(_53) -> [return: bb27, unwind: bb99];
    }

    bb27: {
        _55 = &mut _1;
        _54 = flag_files_without_match(_55) -> [return: bb28, unwind: bb99];
    }

    bb28: {
        _57 = &mut _1;
        _56 = flag_fixed_strings(_57) -> [return: bb29, unwind: bb99];
    }

    bb29: {
        _59 = &mut _1;
        _58 = flag_follow(_59) -> [return: bb30, unwind: bb99];
    }

    bb30: {
        _61 = &mut _1;
        _60 = flag_glob(_61) -> [return: bb31, unwind: bb99];
    }

    bb31: {
        _63 = &mut _1;
        _62 = flag_glob_case_insensitive(_63) -> [return: bb32, unwind: bb99];
    }

    bb32: {
        _65 = &mut _1;
        _64 = flag_heading(_65) -> [return: bb33, unwind: bb99];
    }

    bb33: {
        _67 = &mut _1;
        _66 = flag_hidden(_67) -> [return: bb34, unwind: bb99];
    }

    bb34: {
        _69 = &mut _1;
        _68 = flag_iglob(_69) -> [return: bb35, unwind: bb99];
    }

    bb35: {
        _71 = &mut _1;
        _70 = flag_ignore_case(_71) -> [return: bb36, unwind: bb99];
    }

    bb36: {
        _73 = &mut _1;
        _72 = flag_ignore_file(_73) -> [return: bb37, unwind: bb99];
    }

    bb37: {
        _75 = &mut _1;
        _74 = flag_ignore_file_case_insensitive(_75) -> [return: bb38, unwind: bb99];
    }

    bb38: {
        _77 = &mut _1;
        _76 = flag_include_zero(_77) -> [return: bb39, unwind: bb99];
    }

    bb39: {
        _79 = &mut _1;
        _78 = flag_invert_match(_79) -> [return: bb40, unwind: bb99];
    }

    bb40: {
        _81 = &mut _1;
        _80 = flag_json(_81) -> [return: bb41, unwind: bb99];
    }

    bb41: {
        _83 = &mut _1;
        _82 = flag_line_buffered(_83) -> [return: bb42, unwind: bb99];
    }

    bb42: {
        _85 = &mut _1;
        _84 = flag_line_number(_85) -> [return: bb43, unwind: bb99];
    }

    bb43: {
        _87 = &mut _1;
        _86 = flag_line_regexp(_87) -> [return: bb44, unwind: bb99];
    }

    bb44: {
        _89 = &mut _1;
        _88 = flag_max_columns(_89) -> [return: bb45, unwind: bb99];
    }

    bb45: {
        _91 = &mut _1;
        _90 = flag_max_columns_preview(_91) -> [return: bb46, unwind: bb99];
    }

    bb46: {
        _93 = &mut _1;
        _92 = flag_max_count(_93) -> [return: bb47, unwind: bb99];
    }

    bb47: {
        _95 = &mut _1;
        _94 = flag_max_depth(_95) -> [return: bb48, unwind: bb99];
    }

    bb48: {
        _97 = &mut _1;
        _96 = flag_max_filesize(_97) -> [return: bb49, unwind: bb99];
    }

    bb49: {
        _99 = &mut _1;
        _98 = flag_mmap(_99) -> [return: bb50, unwind: bb99];
    }

    bb50: {
        _101 = &mut _1;
        _100 = flag_multiline(_101) -> [return: bb51, unwind: bb99];
    }

    bb51: {
        _103 = &mut _1;
        _102 = flag_multiline_dotall(_103) -> [return: bb52, unwind: bb99];
    }

    bb52: {
        _105 = &mut _1;
        _104 = flag_no_config(_105) -> [return: bb53, unwind: bb99];
    }

    bb53: {
        _107 = &mut _1;
        _106 = flag_no_ignore(_107) -> [return: bb54, unwind: bb99];
    }

    bb54: {
        _109 = &mut _1;
        _108 = flag_no_ignore_dot(_109) -> [return: bb55, unwind: bb99];
    }

    bb55: {
        _111 = &mut _1;
        _110 = flag_no_ignore_exclude(_111) -> [return: bb56, unwind: bb99];
    }

    bb56: {
        _113 = &mut _1;
        _112 = flag_no_ignore_files(_113) -> [return: bb57, unwind: bb99];
    }

    bb57: {
        _115 = &mut _1;
        _114 = flag_no_ignore_global(_115) -> [return: bb58, unwind: bb99];
    }

    bb58: {
        _117 = &mut _1;
        _116 = flag_no_ignore_messages(_117) -> [return: bb59, unwind: bb99];
    }

    bb59: {
        _119 = &mut _1;
        _118 = flag_no_ignore_parent(_119) -> [return: bb60, unwind: bb99];
    }

    bb60: {
        _121 = &mut _1;
        _120 = flag_no_ignore_vcs(_121) -> [return: bb61, unwind: bb99];
    }

    bb61: {
        _123 = &mut _1;
        _122 = flag_no_messages(_123) -> [return: bb62, unwind: bb99];
    }

    bb62: {
        _125 = &mut _1;
        _124 = flag_no_pcre2_unicode(_125) -> [return: bb63, unwind: bb99];
    }

    bb63: {
        _127 = &mut _1;
        _126 = flag_no_require_git(_127) -> [return: bb64, unwind: bb99];
    }

    bb64: {
        _129 = &mut _1;
        _128 = flag_no_unicode(_129) -> [return: bb65, unwind: bb99];
    }

    bb65: {
        _131 = &mut _1;
        _130 = flag_null(_131) -> [return: bb66, unwind: bb99];
    }

    bb66: {
        _133 = &mut _1;
        _132 = flag_null_data(_133) -> [return: bb67, unwind: bb99];
    }

    bb67: {
        _135 = &mut _1;
        _134 = flag_one_file_system(_135) -> [return: bb68, unwind: bb99];
    }

    bb68: {
        _137 = &mut _1;
        _136 = flag_only_matching(_137) -> [return: bb69, unwind: bb99];
    }

    bb69: {
        _139 = &mut _1;
        _138 = flag_path_separator(_139) -> [return: bb70, unwind: bb99];
    }

    bb70: {
        _141 = &mut _1;
        _140 = flag_passthru(_141) -> [return: bb71, unwind: bb99];
    }

    bb71: {
        _143 = &mut _1;
        _142 = flag_pcre2(_143) -> [return: bb72, unwind: bb99];
    }

    bb72: {
        _145 = &mut _1;
        _144 = flag_pcre2_version(_145) -> [return: bb73, unwind: bb99];
    }

    bb73: {
        _147 = &mut _1;
        _146 = flag_pre(_147) -> [return: bb74, unwind: bb99];
    }

    bb74: {
        _149 = &mut _1;
        _148 = flag_pre_glob(_149) -> [return: bb75, unwind: bb99];
    }

    bb75: {
        _151 = &mut _1;
        _150 = flag_pretty(_151) -> [return: bb76, unwind: bb99];
    }

    bb76: {
        _153 = &mut _1;
        _152 = flag_quiet(_153) -> [return: bb77, unwind: bb99];
    }

    bb77: {
        _155 = &mut _1;
        _154 = flag_regex_size_limit(_155) -> [return: bb78, unwind: bb99];
    }

    bb78: {
        _157 = &mut _1;
        _156 = flag_regexp(_157) -> [return: bb79, unwind: bb99];
    }

    bb79: {
        _159 = &mut _1;
        _158 = flag_replace(_159) -> [return: bb80, unwind: bb99];
    }

    bb80: {
        _161 = &mut _1;
        _160 = flag_search_zip(_161) -> [return: bb81, unwind: bb99];
    }

    bb81: {
        _163 = &mut _1;
        _162 = flag_smart_case(_163) -> [return: bb82, unwind: bb99];
    }

    bb82: {
        _165 = &mut _1;
        _164 = flag_sort_files(_165) -> [return: bb83, unwind: bb99];
    }

    bb83: {
        _167 = &mut _1;
        _166 = flag_sort(_167) -> [return: bb84, unwind: bb99];
    }

    bb84: {
        _169 = &mut _1;
        _168 = flag_sortr(_169) -> [return: bb85, unwind: bb99];
    }

    bb85: {
        _171 = &mut _1;
        _170 = flag_stats(_171) -> [return: bb86, unwind: bb99];
    }

    bb86: {
        _173 = &mut _1;
        _172 = flag_text(_173) -> [return: bb87, unwind: bb99];
    }

    bb87: {
        _175 = &mut _1;
        _174 = flag_threads(_175) -> [return: bb88, unwind: bb99];
    }

    bb88: {
        _177 = &mut _1;
        _176 = flag_trim(_177) -> [return: bb89, unwind: bb99];
    }

    bb89: {
        _179 = &mut _1;
        _178 = flag_type(_179) -> [return: bb90, unwind: bb99];
    }

    bb90: {
        _181 = &mut _1;
        _180 = flag_type_add(_181) -> [return: bb91, unwind: bb99];
    }

    bb91: {
        _183 = &mut _1;
        _182 = flag_type_clear(_183) -> [return: bb92, unwind: bb99];
    }

    bb92: {
        _185 = &mut _1;
        _184 = flag_type_list(_185) -> [return: bb93, unwind: bb99];
    }

    bb93: {
        _187 = &mut _1;
        _186 = flag_type_not(_187) -> [return: bb94, unwind: bb99];
    }

    bb94: {
        _189 = &mut _1;
        _188 = flag_unrestricted(_189) -> [return: bb95, unwind: bb99];
    }

    bb95: {
        _191 = &mut _1;
        _190 = flag_vimgrep(_191) -> [return: bb96, unwind: bb99];
    }

    bb96: {
        _193 = &mut _1;
        _192 = flag_with_filename(_193) -> [return: bb97, unwind: bb99];
    }

    bb97: {
        _195 = &mut _1;
        _194 = flag_word_regexp(_195) -> [return: bb98, unwind: bb99];
    }

    bb98: {
        _0 = move _1;
        return;
    }

    bb99 (cleanup): {
        drop(_1) -> [return: bb100, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        resume;
    }
}

fn arg_pattern(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: &[&str];
    let _7: ();
    let mut _8: &[&str; 5];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::positional(const "pattern", const "PATTERN") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = const _;
        _6 = _8 as &[&str] (PointerCoercion(Unsize));
        _2 = RGArg::required_unless(move _3, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in arg_pattern: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "file", const "files", const "regexp", const "type-list", const "pcre2-version"];
        _0 = &_1;
        return;
    }
}

const arg_pattern::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A regular expression used for searching.";
        return;
    }
}

const arg_pattern::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A regular expression used for searching. To match a pattern beginning with a\ndash, use the -e/--regexp flag.\n\nFor example, to search for the literal '-foo', you can use this flag:\n\n    rg -e -foo\n\nYou can also use the special '--' delimiter to indicate that no more flags\nwill be provided. Namely, the following is equivalent to the above:\n\n    rg -- -foo\n ";
        return;
    }
}

fn arg_path(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::positional(const "path", const "PATH") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::multiple(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const arg_path::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A file or directory to search.";
        return;
    }
}

const arg_path::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A file or directory to search. Directories are searched recursively. File paths specified on the command line override glob and ignore rules.  ";
        return;
    }
}

fn flag_after_context(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _8 = RGArg::flag(const "after-context", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::short(move _8, const "A") -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::number(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "passthru") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "context") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

const flag_after_context::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines after each match.";
        return;
    }
}

const flag_after_context::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines after each match.\n\nThis overrides the --context and --passthru flags.\n ";
        return;
    }
}

fn flag_auto_hybrid_regex(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let mut _14: app::RGArg;
    let mut _15: app::RGArg;
    let _16: ();
    scope 1 {
        debug arg => _2;
        let _10: app::RGArg;
        scope 2 {
            debug arg => _10;
        }
    }

    bb0: {
        _8 = RGArg::switch(const "auto-hybrid-regex") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::help(move _8, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::overrides(move _6, const "no-auto-hybrid-regex") -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "pcre2") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "no-pcre2") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "engine") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _15 = RGArg::switch(const "no-auto-hybrid-regex") -> [return: bb9, unwind continue];
    }

    bb9: {
        _14 = RGArg::hidden(move _15) -> [return: bb10, unwind continue];
    }

    bb10: {
        _13 = RGArg::overrides(move _14, const "auto-hybrid-regex") -> [return: bb11, unwind continue];
    }

    bb11: {
        _12 = RGArg::overrides(move _13, const "pcre2") -> [return: bb12, unwind continue];
    }

    bb12: {
        _11 = RGArg::overrides(move _12, const "no-pcre2") -> [return: bb13, unwind continue];
    }

    bb13: {
        _10 = RGArg::overrides(move _11, const "engine") -> [return: bb14, unwind continue];
    }

    bb14: {
        _16 = Vec::<RGArg>::push(_1, move _10) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }
}

const flag_auto_hybrid_regex::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Dynamically use PCRE2 if necessary.";
        return;
    }
}

const flag_auto_hybrid_regex::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "DEPRECATED. Use --engine instead.\n\nWhen this flag is used, ripgrep will dynamically choose between supported regex\nengines depending on the features used in a pattern. When ripgrep chooses a\nregex engine, it applies that choice for every regex provided to ripgrep (e.g.,\nvia multiple -e/--regexp or -f/--file flags).\n\nAs an example of how this flag might behave, ripgrep will attempt to use\nits default finite automata based regex engine whenever the pattern can be\nsuccessfully compiled with that regex engine. If PCRE2 is enabled and if the\npattern given could not be compiled with the default regex engine, then PCRE2\nwill be automatically used for searching. If PCRE2 isn't available, then this\nflag has no effect because there is only one regex engine to choose from.\n\nIn the future, ripgrep may adjust its heuristics for how it decides which\nregex engine to use. In general, the heuristics will be limited to a static\nanalysis of the patterns, and not to any specific runtime behavior observed\nwhile searching files.\n\nThe primary downside of using this flag is that it may not always be obvious\nwhich regex engine ripgrep uses, and thus, the match semantics or performance\nprofile of ripgrep may subtly and unexpectedly change. However, in many cases,\nall regex engines will agree on what constitutes a match and it can be nice\nto transparently support more advanced regex features like look-around and\nbackreferences without explicitly needing to enable them.\n\nThis flag can be disabled with --no-auto-hybrid-regex.\n ";
        return;
    }
}

fn flag_before_context(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _8 = RGArg::flag(const "before-context", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::short(move _8, const "B") -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::number(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "passthru") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "context") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

const flag_before_context::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines before each match.";
        return;
    }
}

const flag_before_context::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines before each match.\n\nThis overrides the --context and --passthru flags.\n ";
        return;
    }
}

fn flag_binary(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let _14: ();
    scope 1 {
        debug arg => _2;
        let _9: app::RGArg;
        scope 2 {
            debug arg => _9;
        }
    }

    bb0: {
        _7 = RGArg::switch(const "binary") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::help(move _7, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::overrides(move _5, const "no-binary") -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "text") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "no-text") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _13 = RGArg::switch(const "no-binary") -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = RGArg::hidden(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = RGArg::overrides(move _12, const "binary") -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = RGArg::overrides(move _11, const "text") -> [return: bb11, unwind continue];
    }

    bb11: {
        _9 = RGArg::overrides(move _10, const "no-text") -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Vec::<RGArg>::push(_1, move _9) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

const flag_binary::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search binary files.";
        return;
    }
}

const flag_binary::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enabling this flag will cause ripgrep to search binary files. By default,\nripgrep attempts to automatically skip binary files in order to improve the\nrelevance of results and make the search faster.\n\nBinary files are heuristically detected based on whether they contain a NUL\nbyte or not. By default (without this flag set), once a NUL byte is seen,\nripgrep will stop searching the file. Usually, NUL bytes occur in the beginning\nof most binary files. If a NUL byte occurs after a match, then ripgrep will\nstill stop searching the rest of the file, but a warning will be printed.\n\nIn contrast, when this flag is provided, ripgrep will continue searching a file\neven if a NUL byte is found. In particular, if a NUL byte is found then ripgrep\nwill continue searching until either a match is found or the end of the file is\nreached, whichever comes sooner. If a match is found, then ripgrep will stop\nand print a warning saying that the search stopped prematurely.\n\nIf you want ripgrep to search a file without any special NUL byte handling at\nall (and potentially print binary data to stdout), then you should use the\n'-a/--text' flag.\n\nThe '--binary' flag is a flag for controlling ripgrep's automatic filtering\nmechanism. As such, it does not need to be used when searching a file\nexplicitly or when searching stdin. That is, it is only applicable when\nrecursively searching a directory.\n\nNote that when the '-u/--unrestricted' flag is provided for a third time, then\nthis flag is automatically enabled.\n\nThis flag can be disabled with '--no-binary'. It overrides the '-a/--text'\nflag.\n ";
        return;
    }
}

fn flag_block_buffered(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let _14: ();
    scope 1 {
        debug arg => _2;
        let _9: app::RGArg;
        scope 2 {
            debug arg => _9;
        }
    }

    bb0: {
        _7 = RGArg::switch(const "block-buffered") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::help(move _7, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::overrides(move _5, const "no-block-buffered") -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "line-buffered") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "no-line-buffered") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _13 = RGArg::switch(const "no-block-buffered") -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = RGArg::hidden(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = RGArg::overrides(move _12, const "block-buffered") -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = RGArg::overrides(move _11, const "line-buffered") -> [return: bb11, unwind continue];
    }

    bb11: {
        _9 = RGArg::overrides(move _10, const "no-line-buffered") -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Vec::<RGArg>::push(_1, move _9) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

const flag_block_buffered::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Force block buffering.";
        return;
    }
}

const flag_block_buffered::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When enabled, ripgrep will use block buffering. That is, whenever a matching\nline is found, it will be written to an in-memory buffer and will not be\nwritten to stdout until the buffer reaches a certain size. This is the default\nwhen ripgrep's stdout is redirected to a pipeline or a file. When ripgrep's\nstdout is connected to a terminal, line buffering will be used. Forcing block\nbuffering can be useful when dumping a large amount of contents to a terminal.\n\nForceful block buffering can be disabled with --no-block-buffered. Note that\nusing --no-block-buffered causes ripgrep to revert to its default behavior of\nautomatically detecting the buffering strategy. To force line buffering, use\nthe --line-buffered flag.\n ";
        return;
    }
}

fn flag_byte_offset(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "byte-offset") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "b") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_byte_offset::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the 0-based byte offset for each matching line.";
        return;
    }
}

const flag_byte_offset::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the 0-based byte offset within the input file before each line of output.\nIf -o (--only-matching) is specified, print the offset of the matching part\nitself.\n\nIf ripgrep does transcoding, then the byte offset is in terms of the the result\nof transcoding and not the original data. This applies similarly to another\ntransformation on the source, such as decompression or a --pre filter. Note\nthat when the PCRE2 regex engine is used, then UTF-8 transcoding is done by\ndefault.\n ";
        return;
    }
}

fn flag_case_sensitive(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::switch(const "case-sensitive") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "s") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "ignore-case") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "smart-case") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_case_sensitive::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search case sensitively (default).";
        return;
    }
}

const flag_case_sensitive::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search case sensitively.\n\nThis overrides the -i/--ignore-case and -S/--smart-case flags.\n ";
        return;
    }
}

fn flag_color(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: &[&str];
    let _8: ();
    let mut _9: &[&str; 4];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "color", const "WHEN") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = const _;
        _7 = _9 as &[&str] (PointerCoercion(Unsize));
        _3 = RGArg::possible_values(move _4, move _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::default_value_if(move _3, const "never", const "vimgrep") -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in flag_color: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "never", const "auto", const "always", const "ansi"];
        _0 = &_1;
        return;
    }
}

const flag_color::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Controls when to use color.";
        return;
    }
}

const flag_color::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag controls when to use colors. The default setting is 'auto', which\nmeans ripgrep will try to guess when to use colors. For example, if ripgrep is\nprinting to a terminal, then it will use colors, but if it is redirected to a\nfile or a pipe, then it will suppress color output. ripgrep will suppress color\noutput in some other circumstances as well. For example, if the TERM\nenvironment variable is not set or set to 'dumb', then ripgrep will not use\ncolors.\n\nThe possible values for this flag are:\n\n    never    Colors will never be used.\n    auto     The default. ripgrep tries to be smart.\n    always   Colors will always be used regardless of where output is sent.\n    ansi     Like 'always', but emits ANSI escapes (even in a Windows console).\n\nWhen the --vimgrep flag is given to ripgrep, then the default value for the\n--color flag changes to 'never'.\n ";
        return;
    }
}

fn flag_colors(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::flag(const "colors", const "COLOR_SPEC") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::multiple(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_colors::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Configure color settings and styles.";
        return;
    }
}

const flag_colors::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag specifies color settings for use in the output. This flag may be\nprovided multiple times. Settings are applied iteratively. Colors are limited\nto one of eight choices: red, blue, green, cyan, magenta, yellow, white and\nblack. Styles are limited to nobold, bold, nointense, intense, nounderline\nor underline.\n\nThe format of the flag is '{type}:{attribute}:{value}'. '{type}' should be\none of path, line, column or match. '{attribute}' can be fg, bg or style.\n'{value}' is either a color (for fg and bg) or a text style. A special format,\n'{type}:none', will clear all color settings for '{type}'.\n\nFor example, the following command will change the match color to magenta and\nthe background color for line numbers to yellow:\n\n    rg --colors 'match:fg:magenta' --colors 'line:bg:yellow' foo.\n\nExtended colors can be used for '{value}' when the terminal supports ANSI color\nsequences. These are specified as either 'x' (256-color) or 'x,x,x' (24-bit\ntruecolor) where x is a number between 0 and 255 inclusive. x may be given as\na normal decimal number or a hexadecimal number, which is prefixed by `0x`.\n\nFor example, the following command will change the match background color to\nthat represented by the rgb value (0,128,255):\n\n    rg --colors 'match:bg:0,128,255'\n\nor, equivalently,\n\n    rg --colors 'match:bg:0x0,0x80,0xFF'\n\nNote that the the intense and nointense style flags will have no effect when\nused alongside these extended color codes.\n ";
        return;
    }
}

fn flag_column(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "column") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-column") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-column") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "column") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_column::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show column numbers.";
        return;
    }
}

const flag_column::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show column numbers (1-based). This only shows the column numbers for the first\nmatch on each line. This does not try to account for Unicode. One byte is equal\nto one column. This implies --line-number.\n\nThis flag can be disabled with --no-column.\n ";
        return;
    }
}

fn flag_context(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _9 = RGArg::flag(const "context", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = RGArg::short(move _9, const "C") -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = RGArg::help(move _8, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = RGArg::number(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = RGArg::overrides(move _5, const "passthru") -> [return: bb6, unwind continue];
    }

    bb6: {
        _3 = RGArg::overrides(move _4, const "before-context") -> [return: bb7, unwind continue];
    }

    bb7: {
        _2 = RGArg::overrides(move _3, const "after-context") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_context::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines before and after each match.";
        return;
    }
}

const flag_context::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show NUM lines before and after each match. This is equivalent to providing\nboth the -B/--before-context and -A/--after-context flags with the same value.\n\nThis overrides both the -B/--before-context and -A/--after-context flags,\nin addition to the --passthru flag.\n ";
        return;
    }
}

fn flag_context_separator(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::flag(const "context-separator", const "SEPARATOR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-context-separator") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-context-separator") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "context-separator") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_context_separator::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the context separator string.";
        return;
    }
}

const flag_context_separator::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The string used to separate non-contiguous context lines in the output. This\nis only used when one of the context flags is used (-A, -B or -C). Escape\nsequences like \\x7F or \\t may be used. The default value is --.\n\nWhen the context separator is set to an empty string, then a line break\nis still inserted. To completely disable context separators, use the\n--no-context-separator flag.\n ";
        return;
    }
}

fn flag_count(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::switch(const "count") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "c") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "count-matches") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_count::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show the count of matching lines for each file.";
        return;
    }
}

const flag_count::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag suppresses normal output and shows the number of lines that match\nthe given patterns for each file searched. Each file containing a match has its\npath and count printed on each line. Note that this reports the number of lines\nthat match and not the total number of matches, unless -U/--multiline is\nenabled. In multiline mode, --count is equivalent to --count-matches.\n\nIf only one file is given to ripgrep, then only the count is printed if there\nis a match. The --with-filename flag can be used to force printing the file\npath in this case. If you need a count to be printed regardless of whether\nthere is a match, then use --include-zero.\n\nThis overrides the --count-matches flag. Note that when --count is combined\nwith --only-matching, then ripgrep behaves as if --count-matches was given.\n ";
        return;
    }
}

fn flag_count_matches(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "count-matches") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "count") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_count_matches::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show the count of individual matches for each file.";
        return;
    }
}

const flag_count_matches::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag suppresses normal output and shows the number of individual\nmatches of the given patterns for each file searched. Each file\ncontaining matches has its path and match count printed on each line.\nNote that this reports the total number of individual matches and not\nthe number of lines that match.\n\nIf only one file is given to ripgrep, then only the count is printed if there\nis a match. The --with-filename flag can be used to force printing the file\npath in this case.\n\nThis overrides the --count flag. Note that when --count is combined with\n--only-matching, then ripgrep behaves as if --count-matches was given.\n ";
        return;
    }
}

fn flag_crlf(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "crlf") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::overrides(move _4, const "no-crlf") -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "null-data") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-crlf") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "crlf") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_crlf::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Support CRLF line terminators (useful on Windows).";
        return;
    }
}

const flag_crlf::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When enabled, ripgrep will treat CRLF ('\\r\\n') as a line terminator instead\nof just '\\n'.\n\nPrincipally, this permits '$' in regex patterns to match just before CRLF\ninstead of just before LF. The underlying regex engine may not support this\nnatively, so ripgrep will translate all instances of '$' to '(?:\\r??$)'. This\nmay produce slightly different than desired match offsets. It is intended as a\nwork-around until the regex engine supports this natively.\n\nCRLF support can be disabled with --no-crlf.\n ";
        return;
    }
}

fn flag_debug(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    scope 1 {
        debug arg => _2;
        let _6: app::RGArg;
        scope 2 {
            debug arg => _6;
        }
    }

    bb0: {
        _4 = RGArg::switch(const "debug") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = RGArg::switch(const "trace") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = RGArg::hidden(move _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = RGArg::overrides(move _7, const "debug") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _6) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

const flag_debug::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show debug messages.";
        return;
    }
}

const flag_debug::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show debug messages. Please use this when filing a bug report.\n\nThe --debug flag is generally useful for figuring out why ripgrep skipped\nsearching a particular file. The debug messages should mention all files\nskipped and why they were skipped.\n\nTo get even more debug output, use the --trace flag, which implies --debug\nalong with additional trace data. With --trace, the output could be quite\nlarge and is generally more useful for development.\n ";
        return;
    }
}

fn flag_dfa_size_limit(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "dfa-size-limit", const "NUM+SUFFIX?") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_dfa_size_limit::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The upper size limit of the regex DFA.";
        return;
    }
}

const flag_dfa_size_limit::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The upper size limit of the regex DFA. The default limit is 10M. This should\nonly be changed on very large regex inputs where the (slower) fallback regex\nengine may otherwise be used if the limit is reached.\n\nThe argument accepts the same size suffixes as allowed in with the\n--max-filesize flag.\n ";
        return;
    }
}

fn flag_encoding(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::flag(const "encoding", const "ENCODING") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "E") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-encoding") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "encoding") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_encoding::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specify the text encoding of files to search.";
        return;
    }
}

const flag_encoding::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specify the text encoding that ripgrep will use on all files searched. The\ndefault value is 'auto', which will cause ripgrep to do a best effort automatic\ndetection of encoding on a per-file basis. Automatic detection in this case\nonly applies to files that begin with a UTF-8 or UTF-16 byte-order mark (BOM).\nNo other automatic detection is performed. One can also specify 'none' which\nwill then completely disable BOM sniffing and always result in searching the\nraw bytes, including a BOM if it's present, regardless of its encoding.\n\nOther supported values can be found in the list of labels here:\nhttps://encoding.spec.whatwg.org/#concept-encoding-get\n\nFor more details on encoding and how ripgrep deals with it, see GUIDE.md.\n\nThis flag can be disabled with --no-encoding.\n ";
        return;
    }
}

fn flag_engine(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let mut _11: &[&str];
    let _12: ();
    let mut _13: &[&str; 3];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _10 = RGArg::flag(const "engine", const "ENGINE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _9 = RGArg::help(move _10, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = RGArg::long_help(move _9, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _13 = const _;
        _11 = _13 as &[&str] (PointerCoercion(Unsize));
        _7 = RGArg::possible_values(move _8, move _11) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = RGArg::default_value(move _7, const "default") -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = RGArg::overrides(move _6, const "pcre2") -> [return: bb6, unwind continue];
    }

    bb6: {
        _4 = RGArg::overrides(move _5, const "no-pcre2") -> [return: bb7, unwind continue];
    }

    bb7: {
        _3 = RGArg::overrides(move _4, const "auto-hybrid-regex") -> [return: bb8, unwind continue];
    }

    bb8: {
        _2 = RGArg::overrides(move _3, const "no-auto-hybrid-regex") -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = Vec::<RGArg>::push(_1, move _2) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

promoted[0] in flag_engine: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "default", const "pcre2", const "auto"];
        _0 = &_1;
        return;
    }
}

const flag_engine::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specify which regexp engine to use.";
        return;
    }
}

const flag_engine::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specify which regular expression engine to use. When you choose a regex engine,\nit applies that choice for every regex provided to ripgrep (e.g., via multiple\n-e/--regexp or -f/--file flags).\n\nAccepted values are 'default', 'pcre2', or 'auto'.\n\nThe default value is 'default', which is the fastest and should be good for\nmost use cases. The 'pcre2' engine is generally useful when you want to use\nfeatures such as look-around or backreferences. 'auto' will dynamically choose\nbetween supported regex engines depending on the features used in a pattern on\na best effort basis.\n\nNote that the 'pcre2' engine is an optional ripgrep feature. If PCRE2 wasn't\nincluded in your build of ripgrep, then using this flag will result in ripgrep\nprinting an error message and exiting.\n\nThis overrides previous uses of --pcre2 and --auto-hybrid-regex flags.\n ";
        return;
    }
}

fn flag_field_context_separator(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "field-context-separator", const "SEPARATOR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_field_context_separator::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the field context separator.";
        return;
    }
}

const flag_field_context_separator::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the field context separator, which is used to delimit file paths, line\nnumbers, columns and the context itself, when printing contextual lines. The\nseparator may be any number of bytes, including zero. Escape sequences like\n\\x7F or \\t may be used. The default value is -.\n ";
        return;
    }
}

fn flag_field_match_separator(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "field-match-separator", const "SEPARATOR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_field_match_separator::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the match separator.";
        return;
    }
}

const flag_field_match_separator::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the field match separator, which is used to delimit file paths, line\nnumbers, columns and the match itself. The separator may be any number of\nbytes, including zero. Escape sequences like \\x7F or \\t may be used. The\ndefault value is -.\n ";
        return;
    }
}

fn flag_file(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::flag(const "file", const "PATTERNFILE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "f") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::multiple(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_file::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search for patterns from the given file.";
        return;
    }
}

const flag_file::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search for patterns from the given file, with one pattern per line. When this\nflag is used multiple times or in combination with the -e/--regexp flag,\nthen all patterns provided are searched. Empty pattern lines will match all\ninput lines, and the newline is not counted as part of the pattern.\n\nA line is printed if and only if it matches at least one of the patterns.\n ";
        return;
    }
}

fn flag_files(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: &[&str];
    let _7: ();
    let mut _8: &[&str; 3];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "files") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = const _;
        _6 = _8 as &[&str] (PointerCoercion(Unsize));
        _2 = RGArg::conflicts(move _3, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in flag_files: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "file", const "regexp", const "type-list"];
        _0 = &_1;
        return;
    }
}

const flag_files::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print each file that would be searched.";
        return;
    }
}

const flag_files::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print each file that would be searched without actually performing the search.\nThis is useful to determine whether a particular file is being searched or not.\n ";
        return;
    }
}

fn flag_files_with_matches(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::switch(const "files-with-matches") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "l") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "files-without-match") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_files_with_matches::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the paths with at least one match.";
        return;
    }
}

const flag_files_with_matches::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the paths with at least one match and suppress match contents.\n\nThis overrides --files-without-match.\n ";
        return;
    }
}

fn flag_files_without_match(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "files-without-match") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "files-with-matches") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_files_without_match::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the paths that contain zero matches.";
        return;
    }
}

const flag_files_without_match::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the paths that contain zero matches and suppress match contents. This\ninverts/negates the --files-with-matches flag.\n\nThis overrides --files-with-matches.\n ";
        return;
    }
}

fn flag_fixed_strings(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "fixed-strings") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "F") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-fixed-strings") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-fixed-strings") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "fixed-strings") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_fixed_strings::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Treat the pattern as a literal string.";
        return;
    }
}

const flag_fixed_strings::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Treat the pattern as a literal string instead of a regular expression. When\nthis flag is used, special regular expression meta characters such as .(){}*+\ndo not need to be escaped.\n\nThis flag can be disabled with --no-fixed-strings.\n ";
        return;
    }
}

fn flag_follow(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "follow") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "L") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-follow") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-follow") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "follow") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_follow::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Follow symbolic links.";
        return;
    }
}

const flag_follow::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When this flag is enabled, ripgrep will follow symbolic links while traversing\ndirectories. This is disabled by default. Note that ripgrep will check for\nsymbolic link loops and report errors if it finds one.\n\nThis flag can be disabled with --no-follow.\n ";
        return;
    }
}

fn flag_glob(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::flag(const "glob", const "GLOB") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "g") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::multiple(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_glob::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include or exclude files.";
        return;
    }
}

const flag_glob::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include or exclude files and directories for searching that match the given\nglob. This always overrides any other ignore logic. Multiple glob flags may be\nused. Globbing rules match .gitignore globs. Precede a glob with a ! to exclude\nit. If multiple globs match a file or directory, the glob given later in the\ncommand line takes precedence.\n\nAs an extension, globs support specifying alternatives: *-g ab{c,d}* is\nequivalet to *-g abc -g abd*. Empty alternatives like *-g ab{,c}* are not\ncurrently supported. Note that this syntax extension is also currently enabled\nin gitignore files, even though this syntax isn't supported by git itself.\nripgrep may disable this syntax extension in gitignore files, but it will\nalways remain available via the -g/--glob flag.\n\nWhen this flag is set, every file and directory is applied to it to test for\na match. So for example, if you only want to search in a particular directory\n'foo', then *-g foo* is incorrect because 'foo/bar' does not match the glob\n'foo'. Instead, you should use *-g 'foo/**'*.\n ";
        return;
    }
}

fn flag_glob_case_insensitive(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "glob-case-insensitive") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-glob-case-insensitive") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-glob-case-insensitive") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "glob-case-insensitive") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_glob_case_insensitive::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Process all glob patterns case insensitively.";
        return;
    }
}

const flag_glob_case_insensitive::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Process glob patterns given with the -g/--glob flag case insensitively. This\neffectively treats --glob as --iglob.\n\nThis flag can be disabled with the --no-glob-case-insensitive flag.\n ";
        return;
    }
}

fn flag_heading(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "heading") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-heading") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = RGArg::switch(const "no-heading") -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = RGArg::help(move _10, const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = RGArg::long_help(move _9, const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _7 = RGArg::overrides(move _8, const "heading") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _7) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_heading::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print matches grouped by each file.";
        return;
    }
}

const flag_heading::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag prints the file path above clusters of matches from each file instead\nof printing the file path as a prefix for each matched line. This is the\ndefault mode when printing to a terminal.\n\nThis overrides the --no-heading flag.\n ";
        return;
    }
}

const flag_heading::NO_SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't group matches by each file.";
        return;
    }
}

const flag_heading::NO_LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't group matches by each file. If --no-heading is provided in addition to\nthe -H/--with-filename flag, then file paths will be printed as a prefix for\nevery matched line. This is the default mode when not printing to a terminal.\n\nThis overrides the --heading flag.\n ";
        return;
    }
}

fn flag_hidden(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "hidden") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const ".") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-hidden") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-hidden") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "hidden") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_hidden::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search hidden files and directories.";
        return;
    }
}

const flag_hidden::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search hidden files and directories. By default, hidden files and directories\nare skipped. Note that if a hidden file or a directory is whitelisted in an\nignore file, then it will be searched even if this flag isn't provided.\n\nA file or directory is considered hidden if its base name starts with a dot\ncharacter ('.'). On operating systems which support a `hidden` file attribute,\nlike Windows, files with this attribute are also considered hidden.\n\nThis flag can be disabled with --no-hidden.\n ";
        return;
    }
}

fn flag_iglob(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "iglob", const "GLOB") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::multiple(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_iglob::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include or exclude files case insensitively.";
        return;
    }
}

const flag_iglob::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include or exclude files and directories for searching that match the given\nglob. This always overrides any other ignore logic. Multiple glob flags may be\nused. Globbing rules match .gitignore globs. Precede a glob with a ! to exclude\nit. Globs are matched case insensitively.\n ";
        return;
    }
}

fn flag_ignore_case(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::switch(const "ignore-case") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "i") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "case-sensitive") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "smart-case") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_ignore_case::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Case insensitive search.";
        return;
    }
}

const flag_ignore_case::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When this flag is provided, the given patterns will be searched case\ninsensitively. The case insensitivity rules used by ripgrep conform to\nUnicode's \"simple\" case folding rules.\n\nThis flag overrides -s/--case-sensitive and -S/--smart-case.\n ";
        return;
    }
}

fn flag_ignore_file(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "ignore-file", const "PATH") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::multiple(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_ignore_file::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specify additional ignore files.";
        return;
    }
}

const flag_ignore_file::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Specifies a path to one or more .gitignore format rules files. These patterns\nare applied after the patterns found in .gitignore and .ignore are applied\nand are matched relative to the current working directory. Multiple additional\nignore files can be specified by using the --ignore-file flag several times.\nWhen specifying multiple ignore files, earlier files have lower precedence\nthan later files.\n\nIf you are looking for a way to include or exclude files and directories\ndirectly on the command line, then used -g instead.\n ";
        return;
    }
}

fn flag_ignore_file_case_insensitive(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "ignore-file-case-insensitive") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-ignore-file-case-insensitive") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-ignore-file-case-insensitive") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "ignore-file-case-insensitive") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_ignore_file_case_insensitive::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Process ignore files case insensitively.";
        return;
    }
}

const flag_ignore_file_case_insensitive::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Process ignore files (.gitignore, .ignore, etc.) case insensitively. Note that\nthis comes with a performance penalty and is most useful on case insensitive\nfile systems (such as Windows).\n\nThis flag can be disabled with the --no-ignore-file-case-insensitive flag.\n ";
        return;
    }
}

fn flag_include_zero(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::switch(const "include-zero") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_include_zero::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include files with zero matches in summary";
        return;
    }
}

const flag_include_zero::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When used with --count or --count-matches, print the number of matches for\neach file even if there were zero matches. This is disabled by default but can\nbe enabled to make ripgrep behave more like grep.\n ";
        return;
    }
}

fn flag_invert_match(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "invert-match") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "v") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_invert_match::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Invert matching.";
        return;
    }
}

const flag_invert_match::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Invert matching. Show lines that do not match the given patterns.\n ";
        return;
    }
}

fn flag_json(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: &[&str];
    let _8: ();
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let _12: ();
    let mut _13: &[&str; 5];
    scope 1 {
        debug arg => _2;
        let _9: app::RGArg;
        scope 2 {
            debug arg => _9;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "json") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::overrides(move _4, const "no-json") -> [return: bb4, unwind continue];
    }

    bb4: {
        _13 = const _;
        _7 = _13 as &[&str] (PointerCoercion(Unsize));
        _2 = RGArg::conflicts(move _3, move _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = RGArg::switch(const "no-json") -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = RGArg::hidden(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = RGArg::overrides(move _10, const "json") -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = Vec::<RGArg>::push(_1, move _9) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

promoted[0] in flag_json: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "count", const "count-matches", const "files", const "files-with-matches", const "files-without-match"];
        _0 = &_1;
        return;
    }
}

const flag_json::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show search results in a JSON Lines format.";
        return;
    }
}

const flag_json::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enable printing results in a JSON Lines format.\n\nWhen this flag is provided, ripgrep will emit a sequence of messages, each\nencoded as a JSON object, where there are five different message types:\n\n**begin** - A message that indicates a file is being searched and contains at\nleast one match.\n\n**end** - A message the indicates a file is done being searched. This message\nalso include summary statistics about the search for a particular file.\n\n**match** - A message that indicates a match was found. This includes the text\nand offsets of the match.\n\n**context** - A message that indicates a contextual line was found. This\nincludes the text of the line, along with any match information if the search\nwas inverted.\n\n**summary** - The final message emitted by ripgrep that contains summary\nstatistics about the search across all files.\n\nSince file paths or the contents of files are not guaranteed to be valid UTF-8\nand JSON itself must be representable by a Unicode encoding, ripgrep will emit\nall data elements as objects with one of two keys: 'text' or 'bytes'. 'text' is\na normal JSON string when the data is valid UTF-8 while 'bytes' is the base64\nencoded contents of the data.\n\nThe JSON Lines format is only supported for showing search results. It cannot\nbe used with other flags that emit other types of output, such as --files,\n--files-with-matches, --files-without-match, --count or --count-matches.\nripgrep will report an error if any of the aforementioned flags are used in\nconcert with --json.\n\nOther flags that control aspects of the standard output such as\n--only-matching, --heading, --replace, --max-columns, etc., have no effect\nwhen --json is set.\n\nA more complete description of the JSON format used can be found here:\nhttps://docs.rs/grep-printer/*/grep_printer/struct.JSON.html\n\nThe JSON Lines format can be disabled with --no-json.\n ";
        return;
    }
}

fn flag_line_buffered(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let _14: ();
    scope 1 {
        debug arg => _2;
        let _9: app::RGArg;
        scope 2 {
            debug arg => _9;
        }
    }

    bb0: {
        _7 = RGArg::switch(const "line-buffered") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::help(move _7, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::overrides(move _5, const "no-line-buffered") -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "block-buffered") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "no-block-buffered") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _13 = RGArg::switch(const "no-line-buffered") -> [return: bb8, unwind continue];
    }

    bb8: {
        _12 = RGArg::hidden(move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = RGArg::overrides(move _12, const "line-buffered") -> [return: bb10, unwind continue];
    }

    bb10: {
        _10 = RGArg::overrides(move _11, const "block-buffered") -> [return: bb11, unwind continue];
    }

    bb11: {
        _9 = RGArg::overrides(move _10, const "no-block-buffered") -> [return: bb12, unwind continue];
    }

    bb12: {
        _14 = Vec::<RGArg>::push(_1, move _9) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }
}

const flag_line_buffered::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Force line buffering.";
        return;
    }
}

const flag_line_buffered::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When enabled, ripgrep will use line buffering. That is, whenever a matching\nline is found, it will be flushed to stdout immediately. This is the default\nwhen ripgrep's stdout is connected to a terminal, but otherwise, ripgrep will\nuse block buffering, which is typically faster. This flag forces ripgrep to\nuse line buffering even if it would otherwise use block buffering. This is\ntypically useful in shell pipelines, e.g.,\n'tail -f something.log | rg foo --line-buffered | rg bar'.\n\nForceful line buffering can be disabled with --no-line-buffered. Note that\nusing --no-line-buffered causes ripgrep to revert to its default behavior of\nautomatically detecting the buffering strategy. To force block buffering, use\nthe --block-buffered flag.\n ";
        return;
    }
}

fn flag_line_number(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let _13: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "line-number") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "n") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-line-number") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = RGArg::switch(const "no-line-number") -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = RGArg::short(move _12, const "N") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = RGArg::help(move _11, const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _9 = RGArg::long_help(move _10, const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _8 = RGArg::overrides(move _9, const "line-number") -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Vec::<RGArg>::push(_1, move _8) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

const flag_line_number::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show line numbers.";
        return;
    }
}

const flag_line_number::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show line numbers (1-based). This is enabled by default when searching in a\nterminal.\n ";
        return;
    }
}

const flag_line_number::NO_SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppress line numbers.";
        return;
    }
}

const flag_line_number::NO_LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppress line numbers. This is enabled by default when not searching in a\nterminal.\n ";
        return;
    }
}

fn flag_line_regexp(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::switch(const "line-regexp") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "x") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "word-regexp") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_line_regexp::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show matches surrounded by line boundaries.";
        return;
    }
}

const flag_line_regexp::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show matches surrounded by line boundaries. This is equivalent to putting\n^...$ around all of the search patterns. In other words, this only prints lines\nwhere the entire line participates in a match.\n\nThis overrides the --word-regexp flag.\n ";
        return;
    }
}

fn flag_max_columns(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "max-columns", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "M") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::number(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_max_columns::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't print lines longer than this limit.";
        return;
    }
}

const flag_max_columns::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't print lines longer than this limit in bytes. Longer lines are omitted,\nand only the number of matches in that line is printed.\n\nWhen this flag is omitted or is set to 0, then it has no effect.\n ";
        return;
    }
}

fn flag_max_columns_preview(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "max-columns-preview") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-max-columns-preview") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-max-columns-preview") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "max-columns-preview") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_max_columns_preview::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print a preview for lines exceeding the limit.";
        return;
    }
}

const flag_max_columns_preview::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When the '--max-columns' flag is used, ripgrep will by default completely\nreplace any line that is too long with a message indicating that a matching\nline was removed. When this flag is combined with '--max-columns', a preview\nof the line (corresponding to the limit size) is shown instead, where the part\nof the line exceeding the limit is not shown.\n\nIf the '--max-columns' flag is not set, then this has no effect.\n\nThis flag can be disabled with '--no-max-columns-preview'.\n ";
        return;
    }
}

fn flag_max_count(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "max-count", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "m") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::number(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_max_count::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Limit the number of matches.";
        return;
    }
}

const flag_max_count::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Limit the number of matching lines per file searched to NUM.\n ";
        return;
    }
}

fn flag_max_depth(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "max-depth", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::alias(move _4, const "maxdepth") -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::number(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_max_depth::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Descend at most NUM directories.";
        return;
    }
}

const flag_max_depth::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Limit the depth of directory traversal to NUM levels beyond the paths given. A\nvalue of zero only searches the explicitly given paths themselves.\n\nFor example, 'rg --max-depth 0 dir/' is a no-op because dir/ will not be\ndescended into. 'rg --max-depth 1 dir/' will search only the direct children of\n'dir'.\n ";
        return;
    }
}

fn flag_max_filesize(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "max-filesize", const "NUM+SUFFIX?") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_max_filesize::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Ignore files larger than NUM in size.";
        return;
    }
}

const flag_max_filesize::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Ignore files larger than NUM in size. This does not apply to directories.\n\nThe input format accepts suffixes of K, M or G which correspond to kilobytes,\nmegabytes and gigabytes, respectively. If no suffix is provided the input is\ntreated as bytes.\n\nExamples: --max-filesize 50K or --max-filesize 80M\n ";
        return;
    }
}

fn flag_mmap(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "mmap") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-mmap") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _10 = RGArg::switch(const "no-mmap") -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = RGArg::help(move _10, const _) -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = RGArg::long_help(move _9, const _) -> [return: bb8, unwind continue];
    }

    bb8: {
        _7 = RGArg::overrides(move _8, const "mmap") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _7) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_mmap::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search using memory maps when possible.";
        return;
    }
}

const flag_mmap::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search using memory maps when possible. This is enabled by default when ripgrep\nthinks it will be faster.\n\nMemory map searching doesn't currently support all options, so if an\nincompatible option (e.g., --context) is given with --mmap, then memory maps\nwill not be used.\n\nNote that ripgrep may abort unexpectedly when --mmap if it searches a file that\nis simultaneously truncated.\n\nThis flag overrides --no-mmap.\n ";
        return;
    }
}

const flag_mmap::NO_SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never use memory maps.";
        return;
    }
}

const flag_mmap::NO_LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never use memory maps, even when they might be faster.\n\nThis flag overrides --mmap.\n ";
        return;
    }
}

fn flag_multiline(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "multiline") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "U") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-multiline") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-multiline") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "multiline") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_multiline::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enable matching across multiple lines.";
        return;
    }
}

const flag_multiline::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enable matching across multiple lines.\n\nWhen multiline mode is enabled, ripgrep will lift the restriction that a match\ncannot include a line terminator. For example, when multiline mode is not\nenabled (the default), then the regex '\\p{any}' will match any Unicode\ncodepoint other than '\\n'. Similarly, the regex '\\n' is explicitly forbidden,\nand if you try to use it, ripgrep will return an error. However, when multiline\nmode is enabled, '\\p{any}' will match any Unicode codepoint, including '\\n',\nand regexes like '\\n' are permitted.\n\nAn important caveat is that multiline mode does not change the match semantics\nof '.'. Namely, in most regex matchers, a '.' will by default match any\ncharacter other than '\\n', and this is true in ripgrep as well. In order to\nmake '.' match '\\n', you must enable the \"dot all\" flag inside the regex.\nFor example, both '(?s).' and '(?s:.)' have the same semantics, where '.' will\nmatch any character, including '\\n'. Alternatively, the '--multiline-dotall'\nflag may be passed to make the \"dot all\" behavior the default. This flag only\napplies when multiline search is enabled.\n\nThere is no limit on the number of the lines that a single match can span.\n\n**WARNING**: Because of how the underlying regex engine works, multiline\nsearches may be slower than normal line-oriented searches, and they may also\nuse more memory. In particular, when multiline mode is enabled, ripgrep\nrequires that each file it searches is laid out contiguously in memory\n(either by reading it onto the heap or by memory-mapping it). Things that\ncannot be memory-mapped (such as stdin) will be consumed until EOF before\nsearching can begin. In general, ripgrep will only do these things when\nnecessary. Specifically, if the --multiline flag is provided but the regex\ndoes not contain patterns that would match '\\n' characters, then ripgrep\nwill automatically avoid reading each file into memory before searching it.\nNevertheless, if you only care about matches spanning at most one line, then it\nis always better to disable multiline mode.\n\nThis flag can be disabled with --no-multiline.\n ";
        return;
    }
}

fn flag_multiline_dotall(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "multiline-dotall") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-multiline-dotall") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-multiline-dotall") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "multiline-dotall") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_multiline_dotall::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Make '.' match new lines when multiline is enabled.";
        return;
    }
}

const flag_multiline_dotall::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag enables \"dot all\" in your regex pattern, which causes '.' to match\nnewlines when multiline searching is enabled. This flag has no effect if\nmultiline searching isn't enabled with the --multiline flag.\n\nNormally, a '.' will match any character except newlines. While this behavior\ntypically isn't relevant for line-oriented matching (since matches can span at\nmost one line), this can be useful when searching with the -U/--multiline flag.\nBy default, the multiline mode runs without this flag.\n\nThis flag is generally intended to be used in an alias or your ripgrep config\nfile if you prefer \"dot all\" semantics by default. Note that regardless of\nwhether this flag is used, \"dot all\" semantics can still be controlled via\ninline flags in the regex pattern itself, e.g., '(?s:.)' always enables \"dot\nall\" whereas '(?-s:.)' always disables \"dot all\".\n\nThis flag can be disabled with --no-multiline-dotall.\n ";
        return;
    }
}

fn flag_no_config(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::switch(const "no-config") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_no_config::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never read configuration files.";
        return;
    }
}

const flag_no_config::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never read configuration files. When this flag is present, ripgrep will not\nrespect the RIPGREP_CONFIG_PATH environment variable.\n\nIf ripgrep ever grows a feature to automatically read configuration files in\npre-defined locations, then this flag will also disable that behavior as well.\n ";
        return;
    }
}

fn flag_no_ignore(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files.";
        return;
    }
}

const flag_no_ignore::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files (.gitignore, .ignore, etc.). This implies\n--no-ignore-dot, --no-ignore-exclude, --no-ignore-global, no-ignore-parent and\n--no-ignore-vcs.\n\nThis does *not* imply --no-ignore-files, since --ignore-file is specified\nexplicitly as a command line argument.\n\nWhen given only once, the -u flag is identical in behavior to --no-ignore and\ncan be considered an alias. However, subsequent -u flags have additional\neffects; see --unrestricted.\n\nThis flag can be disabled with the --ignore flag.\n ";
        return;
    }
}

fn flag_no_ignore_dot(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-dot") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-dot") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-dot") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-dot") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_dot::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect .ignore files.";
        return;
    }
}

const flag_no_ignore_dot::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect .ignore files.\n\nThis does *not* affect whether ripgrep will ignore files and directories\nwhose names begin with a dot. For that, see the -./--hidden flag.\n\nThis flag can be disabled with the --ignore-dot flag.\n ";
        return;
    }
}

fn flag_no_ignore_exclude(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-exclude") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-exclude") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-exclude") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-exclude") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_exclude::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect local exclusion files.";
        return;
    }
}

const flag_no_ignore_exclude::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files that are manually configured for the repository\nsuch as git's '.git/info/exclude'.\n\nThis flag can be disabled with the --ignore-exclude flag.\n ";
        return;
    }
}

fn flag_no_ignore_files(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-files") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-files") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-files") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-files") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_files::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect --ignore-file arguments.";
        return;
    }
}

const flag_no_ignore_files::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When set, any --ignore-file flags, even ones that come after this flag, are\nignored.\n\nThis flag can be disabled with the --ignore-files flag.\n ";
        return;
    }
}

fn flag_no_ignore_global(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-global") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-global") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-global") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-global") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_global::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect global ignore files.";
        return;
    }
}

const flag_no_ignore_global::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files that come from \"global\" sources such as git's\n`core.excludesFile` configuration option (which defaults to\n`$HOME/.config/git/ignore`).\n\nThis flag can be disabled with the --ignore-global flag.\n ";
        return;
    }
}

fn flag_no_ignore_messages(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-messages") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-messages") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-messages") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-messages") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_messages::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppress gitignore parse error messages.";
        return;
    }
}

const flag_no_ignore_messages::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppresses all error messages related to parsing ignore files such as .ignore\nor .gitignore.\n\nThis flag can be disabled with the --ignore-messages flag.\n ";
        return;
    }
}

fn flag_no_ignore_parent(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-parent") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-parent") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-parent") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-parent") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_parent::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files in parent directories.";
        return;
    }
}

const flag_no_ignore_parent::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect ignore files (.gitignore, .ignore, etc.) in parent directories.\n\nThis flag can be disabled with the --ignore-parent flag.\n ";
        return;
    }
}

fn flag_no_ignore_vcs(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-ignore-vcs") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "ignore-vcs") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "ignore-vcs") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-ignore-vcs") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_ignore_vcs::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect VCS ignore files.";
        return;
    }
}

const flag_no_ignore_vcs::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Don't respect version control ignore files (.gitignore, etc.). This implies\n--no-ignore-parent for VCS files. Note that .ignore files will continue to be\nrespected.\n\nThis flag can be disabled with the --ignore-vcs flag.\n ";
        return;
    }
}

fn flag_no_messages(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-messages") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "messages") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "messages") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-messages") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_messages::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppress some error messages.";
        return;
    }
}

const flag_no_messages::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Suppress all error messages related to opening and reading files. Error\nmessages related to the syntax of the pattern given are still shown.\n\nThis flag can be disabled with the --messages flag.\n ";
        return;
    }
}

fn flag_no_pcre2_unicode(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let _12: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "no-pcre2-unicode") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::overrides(move _4, const "pcre2-unicode") -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "unicode") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = RGArg::switch(const "pcre2-unicode") -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = RGArg::hidden(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = RGArg::overrides(move _10, const "no-pcre2-unicode") -> [return: bb9, unwind continue];
    }

    bb9: {
        _8 = RGArg::overrides(move _9, const "no-unicode") -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Vec::<RGArg>::push(_1, move _8) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

const flag_no_pcre2_unicode::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Disable Unicode mode for PCRE2 matching.";
        return;
    }
}

const flag_no_pcre2_unicode::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "DEPRECATED. Use --no-unicode instead.\n\nThis flag is now an alias for --no-unicode. And --pcre2-unicode is an alias\nfor --unicode.\n ";
        return;
    }
}

fn flag_no_require_git(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "no-require-git") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "require-git") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "require-git") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "no-require-git") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_no_require_git::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not require a git repository to use gitignores.";
        return;
    }
}

const flag_no_require_git::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "By default, ripgrep will only respect global gitignore rules, .gitignore rules\nand local exclude rules if ripgrep detects that you are searching inside a\ngit repository. This flag allows you to relax this restriction such that\nripgrep will respect all git related ignore rules regardless of whether you're\nsearching in a git repository or not.\n\nThis flag can be disabled with --require-git.\n ";
        return;
    }
}

fn flag_no_unicode(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let _12: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "no-unicode") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::overrides(move _4, const "unicode") -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "pcre2-unicode") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _11 = RGArg::switch(const "unicode") -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = RGArg::hidden(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = RGArg::overrides(move _10, const "no-unicode") -> [return: bb9, unwind continue];
    }

    bb9: {
        _8 = RGArg::overrides(move _9, const "no-pcre2-unicode") -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Vec::<RGArg>::push(_1, move _8) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

const flag_no_unicode::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Disable Unicode mode.";
        return;
    }
}

const flag_no_unicode::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "By default, ripgrep will enable \"Unicode mode\" in all of its regexes. This\nhas a number of consequences:\n\n* '.' will only match valid UTF-8 encoded scalar values.\n* Classes like '\\w', '\\s', '\\d' are all Unicode aware and much bigger\n  than their ASCII only versions.\n* Case insensitive matching will use Unicode case folding.\n* A large array of classes like '\\p{Emoji}' are available.\n* Word boundaries ('\\b' and '\\B') use the Unicode definition of a word\n  character.\n\nIn some cases it can be desirable to turn these things off. The --no-unicode\nflag will do exactly that.\n\nFor PCRE2 specifically, Unicode mode represents a critical trade off in the\nuser experience of ripgrep. In particular, unlike the default regex engine,\nPCRE2 does not support the ability to search possibly invalid UTF-8 with\nUnicode features enabled. Instead, PCRE2 *requires* that everything it searches\nwhen Unicode mode is enabled is valid UTF-8. (Or valid UTF-16/UTF-32, but for\nthe purposes of ripgrep, we only discuss UTF-8.) This means that if you have\nPCRE2's Unicode mode enabled and you attempt to search invalid UTF-8, then\nthe search for that file will halt and print an error. For this reason, when\nPCRE2's Unicode mode is enabled, ripgrep will automatically \"fix\" invalid\nUTF-8 sequences by replacing them with the Unicode replacement codepoint. This\npenalty does not occur when using the default regex engine.\n\nIf you would rather see the encoding errors surfaced by PCRE2 when Unicode mode\nis enabled, then pass the --no-encoding flag to disable all transcoding.\n\nThe --no-unicode flag can be disabled with --unicode. Note that\n--no-pcre2-unicode and --pcre2-unicode are aliases for --no-unicode and\n--unicode, respectively.\n ";
        return;
    }
}

fn flag_null(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "null") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "0") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_null::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print a NUL byte after file paths.";
        return;
    }
}

const flag_null::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Whenever a file path is printed, follow it with a NUL byte. This includes\nprinting file paths before matches, and when printing a list of matching files\nsuch as with --count, --files-with-matches and --files. This option is useful\nfor use with xargs.\n ";
        return;
    }
}

fn flag_null_data(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "null-data") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "crlf") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_null_data::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Use NUL as a line terminator instead of \\n.";
        return;
    }
}

const flag_null_data::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enabling this option causes ripgrep to use NUL as a line terminator instead of\nthe default of '\\n'.\n\nThis is useful when searching large binary files that would otherwise have very\nlong lines if '\\n' were used as the line terminator. In particular, ripgrep\nrequires that, at a minimum, each line must fit into memory. Using NUL instead\ncan be a useful stopgap to keep memory requirements low and avoid OOM (out of\nmemory) conditions.\n\nThis is also useful for processing NUL delimited data, such as that emitted\nwhen using ripgrep's -0/--null flag or find's --print0 flag.\n\nUsing this flag implies -a/--text.\n ";
        return;
    }
}

fn flag_one_file_system(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "one-file-system") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-one-file-system") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-one-file-system") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "one-file-system") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_one_file_system::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not descend into directories on other file systems.";
        return;
    }
}

const flag_one_file_system::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When enabled, ripgrep will not cross file system boundaries relative to where\nthe search started from.\n\nNote that this applies to each path argument given to ripgrep. For example, in\nthe command 'rg --one-file-system /foo/bar /quux/baz', ripgrep will search both\n'/foo/bar' and '/quux/baz' even if they are on different file systems, but will\nnot cross a file system boundary when traversing each path's directory tree.\n\nThis is similar to find's '-xdev' or '-mount' flag.\n\nThis flag can be disabled with --no-one-file-system.\n ";
        return;
    }
}

fn flag_only_matching(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "only-matching") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "o") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_only_matching::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print only matched parts of a line.";
        return;
    }
}

const flag_only_matching::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print only the matched (non-empty) parts of a matching line, with each such\npart on a separate output line.\n ";
        return;
    }
}

fn flag_path_separator(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "path-separator", const "SEPARATOR") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_path_separator::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the path separator.";
        return;
    }
}

const flag_path_separator::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Set the path separator to use when printing file paths. This defaults to your\nplatform's path separator, which is / on Unix and \\ on Windows. This flag is\nintended for overriding the default when the environment demands it (e.g.,\ncygwin). A path separator is limited to a single byte.\n ";
        return;
    }
}

fn flag_passthru(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _8 = RGArg::switch(const "passthru") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::help(move _8, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::alias(move _6, const "passthrough") -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "after-context") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "before-context") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "context") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

const flag_passthru::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print both matching and non-matching lines.";
        return;
    }
}

const flag_passthru::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print both matching and non-matching lines.\n\nAnother way to achieve a similar effect is by modifying your pattern to match\nthe empty string. For example, if you are searching using 'rg foo' then using\n'rg \"^|foo\"' instead will emit every line in every file searched, but only\noccurrences of 'foo' will be highlighted. This flag enables the same behavior\nwithout needing to modify the pattern.\n\nThis overrides the --context, --after-context and --before-context flags.\n ";
        return;
    }
}

fn flag_pcre2(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let mut _14: app::RGArg;
    let mut _15: app::RGArg;
    let mut _16: app::RGArg;
    let _17: ();
    scope 1 {
        debug arg => _2;
        let _11: app::RGArg;
        scope 2 {
            debug arg => _11;
        }
    }

    bb0: {
        _9 = RGArg::switch(const "pcre2") -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = RGArg::short(move _9, const "P") -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = RGArg::help(move _8, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = RGArg::overrides(move _6, const "no-pcre2") -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = RGArg::overrides(move _5, const "auto-hybrid-regex") -> [return: bb6, unwind continue];
    }

    bb6: {
        _3 = RGArg::overrides(move _4, const "no-auto-hybrid-regex") -> [return: bb7, unwind continue];
    }

    bb7: {
        _2 = RGArg::overrides(move _3, const "engine") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _2) -> [return: bb9, unwind continue];
    }

    bb9: {
        _16 = RGArg::switch(const "no-pcre2") -> [return: bb10, unwind continue];
    }

    bb10: {
        _15 = RGArg::hidden(move _16) -> [return: bb11, unwind continue];
    }

    bb11: {
        _14 = RGArg::overrides(move _15, const "pcre2") -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = RGArg::overrides(move _14, const "auto-hybrid-regex") -> [return: bb13, unwind continue];
    }

    bb13: {
        _12 = RGArg::overrides(move _13, const "no-auto-hybrid-regex") -> [return: bb14, unwind continue];
    }

    bb14: {
        _11 = RGArg::overrides(move _12, const "engine") -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = Vec::<RGArg>::push(_1, move _11) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }
}

const flag_pcre2::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Enable PCRE2 matching.";
        return;
    }
}

const flag_pcre2::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When this flag is present, ripgrep will use the PCRE2 regex engine instead of\nits default regex engine.\n\nThis is generally useful when you want to use features such as look-around\nor backreferences.\n\nNote that PCRE2 is an optional ripgrep feature. If PCRE2 wasn't included in\nyour build of ripgrep, then using this flag will result in ripgrep printing\nan error message and exiting. PCRE2 may also have worse user experience in\nsome cases, since it has fewer introspection APIs than ripgrep's default regex\nengine. For example, if you use a '\\n' in a PCRE2 regex without the\n'-U/--multiline' flag, then ripgrep will silently fail to match anything\ninstead of reporting an error immediately (like it does with the default\nregex engine).\n\nRelated flags: --no-pcre2-unicode\n\nThis flag can be disabled with --no-pcre2.\n ";
        return;
    }
}

fn flag_pcre2_version(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::switch(const "pcre2-version") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_pcre2_version::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the version of PCRE2 that ripgrep uses.";
        return;
    }
}

const flag_pcre2_version::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When this flag is present, ripgrep will print the version of PCRE2 in use,\nalong with other information, and then exit. If PCRE2 is not available, then\nripgrep will print an error message and exit with an error code.\n ";
        return;
    }
}

fn flag_pre(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let _11: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::flag(const "pre", const "COMMAND") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::overrides(move _4, const "no-pre") -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "search-zip") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = RGArg::switch(const "no-pre") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = RGArg::hidden(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _8 = RGArg::overrides(move _9, const "pre") -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = Vec::<RGArg>::push(_1, move _8) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

const flag_pre::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "search outputs of COMMAND FILE for each FILE";
        return;
    }
}

const flag_pre::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "For each input FILE, search the standard output of COMMAND FILE rather than the\ncontents of FILE. This option expects the COMMAND program to either be an\nabsolute path or to be available in your PATH. Either an empty string COMMAND\nor the '--no-pre' flag will disable this behavior.\n\n    WARNING: When this flag is set, ripgrep will unconditionally spawn a\n    process for every file that is searched. Therefore, this can incur an\n    unnecessarily large performance penalty if you don't otherwise need the\n    flexibility offered by this flag. One possible mitigation to this is to use\n    the '--pre-glob' flag to limit which files a preprocessor is run with.\n\nA preprocessor is not run when ripgrep is searching stdin.\n\nWhen searching over sets of files that may require one of several decoders\nas preprocessors, COMMAND should be a wrapper program or script which first\nclassifies FILE based on magic numbers/content or based on the FILE name and\nthen dispatches to an appropriate preprocessor. Each COMMAND also has its\nstandard input connected to FILE for convenience.\n\nFor example, a shell script for COMMAND might look like:\n\n    case \"$1\" in\n    *.pdf)\n        exec pdftotext \"$1\" -\n        ;;\n    *)\n        case $(file \"$1\") in\n        *Zstandard*)\n            exec pzstd -cdq\n            ;;\n        *)\n            exec cat\n            ;;\n        esac\n        ;;\n    esac\n\nThe above script uses `pdftotext` to convert a PDF file to plain text. For\nall other files, the script uses the `file` utility to sniff the type of the\nfile based on its contents. If it is a compressed file in the Zstandard format,\nthen `pzstd` is used to decompress the contents to stdout.\n\nThis overrides the -z/--search-zip flag.\n ";
        return;
    }
}

fn flag_pre_glob(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "pre-glob", const "GLOB") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::help(move _6, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::multiple(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_pre_glob::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Include or exclude files from a preprocessing command.";
        return;
    }
}

const flag_pre_glob::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag works in conjunction with the --pre flag. Namely, when one or more\n--pre-glob flags are given, then only files that match the given set of globs\nwill be handed to the command specified by the --pre flag. Any non-matching\nfiles will be searched without using the preprocessor command.\n\nThis flag is useful when searching many files with the --pre flag. Namely,\nit permits the ability to avoid process overhead for files that don't need\npreprocessing. For example, given the following shell script, 'pre-pdftotext':\n\n    #!/bin/sh\n\n    pdftotext \"$1\" -\n\nthen it is possible to use '--pre pre-pdftotext --pre-glob '*.pdf'' to make\nit so ripgrep only executes the 'pre-pdftotext' command on files with a '.pdf'\nextension.\n\nMultiple --pre-glob flags may be used. Globbing rules match .gitignore globs.\nPrecede a glob with a ! to exclude it.\n\nThis flag has no effect if the --pre flag is not used.\n ";
        return;
    }
}

fn flag_pretty(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "pretty") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "p") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_pretty::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Alias for --color always --heading --line-number.";
        return;
    }
}

const flag_pretty::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This is a convenience alias for '--color always --heading --line-number'. This\nflag is useful when you still want pretty output even if you're piping ripgrep\nto another program or file. For example: 'rg -p foo | less -R'.\n ";
        return;
    }
}

fn flag_quiet(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "quiet") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "q") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_quiet::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not print anything to stdout.";
        return;
    }
}

const flag_quiet::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not print anything to stdout. If a match is found in a file, then ripgrep\nwill stop searching. This is useful when ripgrep is used only for its exit\ncode (which will be an error if no matches are found).\n\nWhen --files is used, then ripgrep will stop finding files after finding the\nfirst file that matches all ignore rules.\n ";
        return;
    }
}

fn flag_regex_size_limit(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::flag(const "regex-size-limit", const "NUM+SUFFIX?") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_regex_size_limit::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The upper size limit of the compiled regex.";
        return;
    }
}

const flag_regex_size_limit::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The upper size limit of the compiled regex. The default limit is 10M.\n\nThe argument accepts the same size suffixes as allowed in the --max-filesize\nflag.\n ";
        return;
    }
}

fn flag_regexp(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::flag(const "regexp", const "PATTERN") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "e") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::multiple(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_regexp::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A pattern to search for.";
        return;
    }
}

const flag_regexp::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "A pattern to search for. This option can be provided multiple times, where\nall patterns given are searched. Lines matching at least one of the provided\npatterns are printed. This flag can also be used when searching for patterns\nthat start with a dash.\n\nFor example, to search for the literal '-foo', you can use this flag:\n\n    rg -e -foo\n\nYou can also use the special '--' delimiter to indicate that no more flags\nwill be provided. Namely, the following is equivalent to the above:\n\n    rg -- -foo\n ";
        return;
    }
}

fn flag_replace(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "replace", const "REPLACEMENT_TEXT") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "r") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::allow_leading_hyphen(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_replace::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Replace matches with the given text.";
        return;
    }
}

const flag_replace::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Replace every match with the text given when printing results. Neither this\nflag nor any other ripgrep flag will modify your files.\n\nCapture group indices (e.g., $5) and names (e.g., $foo) are supported in the\nreplacement string. Capture group indices are numbered based on the position of\nthe opening parenthesis of the group, where the leftmost such group is $1. The\nspecial $0 group corresponds to the entire match.\n\nIn shells such as Bash and zsh, you should wrap the pattern in single quotes\ninstead of double quotes. Otherwise, capture group indices will be replaced by\nexpanded shell variables which will most likely be empty.\n\nTo write a literal '$', use '$$'.\n\nNote that the replacement by default replaces each match, and NOT the entire\nline. To replace the entire line, you should match the entire line.\n\nThis flag can be used with the -o/--only-matching flag.\n ";
        return;
    }
}

fn flag_search_zip(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let _12: ();
    scope 1 {
        debug arg => _2;
        let _9: app::RGArg;
        scope 2 {
            debug arg => _9;
        }
    }

    bb0: {
        _7 = RGArg::switch(const "search-zip") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "z") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "no-search-zip") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "pre") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = RGArg::switch(const "no-search-zip") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = RGArg::hidden(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _9 = RGArg::overrides(move _10, const "search-zip") -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = Vec::<RGArg>::push(_1, move _9) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

const flag_search_zip::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search in compressed files.";
        return;
    }
}

const flag_search_zip::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search in compressed files. Currently gzip, bzip2, xz, LZ4, LZMA, Brotli and\nZstd files are supported. This option expects the decompression binaries to be\navailable in your PATH.\n\nThis flag can be disabled with --no-search-zip.\n ";
        return;
    }
}

fn flag_smart_case(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let _8: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _7 = RGArg::switch(const "smart-case") -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = RGArg::short(move _7, const "S") -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = RGArg::help(move _6, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _4 = RGArg::long_help(move _5, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = RGArg::overrides(move _4, const "case-sensitive") -> [return: bb5, unwind continue];
    }

    bb5: {
        _2 = RGArg::overrides(move _3, const "ignore-case") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = Vec::<RGArg>::push(_1, move _2) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

const flag_smart_case::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Smart case search.";
        return;
    }
}

const flag_smart_case::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Searches case insensitively if the pattern is all lowercase. Search case\nsensitively otherwise.\n\nA pattern is considered all lowercase if both of the following rules hold:\n\nFirst, the pattern contains at least one literal character. For example, 'a\\w'\ncontains a literal ('a') but just '\\w' does not.\n\nSecond, of the literals in the pattern, none of them are considered to be\nuppercase according to Unicode. For example, 'foo\\pL' has no uppercase\nliterals but 'Foo\\pL' does.\n\nThis overrides the -s/--case-sensitive and -i/--ignore-case flags.\n ";
        return;
    }
}

fn flag_sort_files(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let mut _14: app::RGArg;
    let _15: ();
    scope 1 {
        debug arg => _2;
        let _10: app::RGArg;
        scope 2 {
            debug arg => _10;
        }
    }

    bb0: {
        _8 = RGArg::switch(const "sort-files") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::help(move _8, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::hidden(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "no-sort-files") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "sort") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "sortr") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _14 = RGArg::switch(const "no-sort-files") -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = RGArg::hidden(move _14) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = RGArg::overrides(move _13, const "sort-files") -> [return: bb11, unwind continue];
    }

    bb11: {
        _11 = RGArg::overrides(move _12, const "sort") -> [return: bb12, unwind continue];
    }

    bb12: {
        _10 = RGArg::overrides(move _11, const "sortr") -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Vec::<RGArg>::push(_1, move _10) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

const flag_sort_files::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "DEPRECATED";
        return;
    }
}

const flag_sort_files::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "DEPRECATED: Use --sort or --sortr instead.\n\nSort results by file path. Note that this currently disables all parallelism\nand runs search in a single thread.\n\nThis flag can be disabled with --no-sort-files.\n ";
        return;
    }
}

fn flag_sort(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let mut _9: &[&str];
    let _10: ();
    let mut _11: &[&str; 5];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _8 = RGArg::flag(const "sort", const "SORTBY") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::help(move _8, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = const _;
        _9 = _11 as &[&str] (PointerCoercion(Unsize));
        _5 = RGArg::possible_values(move _6, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "sortr") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "sort-files") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "no-sort-files") -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

promoted[0] in flag_sort: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "path", const "modified", const "accessed", const "created", const "none"];
        _0 = &_1;
        return;
    }
}

const flag_sort::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Sort results in ascending order. Implies --threads=1.";
        return;
    }
}

const flag_sort::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag enables sorting of results in ascending order. The possible values\nfor this flag are:\n\n    none      (Default) Do not sort results. Fastest. Can be multi-threaded.\n    path      Sort by file path. Always single-threaded.\n    modified  Sort by the last modified time on a file. Always single-threaded.\n    accessed  Sort by the last accessed time on a file. Always single-threaded.\n    created   Sort by the creation time on a file. Always single-threaded.\n\nIf the chosen (manually or by-default) sorting criteria isn't available on your\nsystem (for example, creation time is not available on ext4 file systems), then\nripgrep will attempt to detect this, print an error and exit without searching.\n\nTo sort results in reverse or descending order, use the --sortr flag. Also,\nthis flag overrides --sortr.\n\nNote that sorting results currently always forces ripgrep to abandon\nparallelism and run in a single thread.\n ";
        return;
    }
}

fn flag_sortr(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let mut _9: &[&str];
    let _10: ();
    let mut _11: &[&str; 5];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _8 = RGArg::flag(const "sortr", const "SORTBY") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::help(move _8, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::long_help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _11 = const _;
        _9 = _11 as &[&str] (PointerCoercion(Unsize));
        _5 = RGArg::possible_values(move _6, move _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "sort") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "sort-files") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "no-sort-files") -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

promoted[0] in flag_sortr: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "path", const "modified", const "accessed", const "created", const "none"];
        _0 = &_1;
        return;
    }
}

const flag_sortr::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Sort results in descending order. Implies --threads=1.";
        return;
    }
}

const flag_sortr::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "This flag enables sorting of results in descending order. The possible values\nfor this flag are:\n\n    none      (Default) Do not sort results. Fastest. Can be multi-threaded.\n    path      Sort by file path. Always single-threaded.\n    modified  Sort by the last modified time on a file. Always single-threaded.\n    accessed  Sort by the last accessed time on a file. Always single-threaded.\n    created   Sort by the creation time on a file. Always single-threaded.\n\nIf the chosen (manually or by-default) sorting criteria isn't available on your\nsystem (for example, creation time is not available on ext4 file systems), then\nripgrep will attempt to detect this, print an error and exit without searching.\n\nTo sort results in ascending order, use the --sort flag. Also, this flag\noverrides --sort.\n\nNote that sorting results currently always forces ripgrep to abandon\nparallelism and run in a single thread.\n ";
        return;
    }
}

fn flag_stats(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "stats") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-stats") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-stats") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "stats") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_stats::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print statistics about this ripgrep search.";
        return;
    }
}

const flag_stats::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print aggregate statistics about this ripgrep search. When this flag is\npresent, ripgrep will print the following stats to stdout at the end of the\nsearch: number of matched lines, number of files with matches, number of files\nsearched, and the time taken for the entire search to complete.\n\nThis set of aggregate statistics may expand over time.\n\nNote that this flag has no effect if --files, --files-with-matches or\n--files-without-match is passed.\n\nThis flag can be disabled with --no-stats.\n ";
        return;
    }
}

fn flag_text(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let mut _7: app::RGArg;
    let mut _8: app::RGArg;
    let _9: ();
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let mut _13: app::RGArg;
    let mut _14: app::RGArg;
    let _15: ();
    scope 1 {
        debug arg => _2;
        let _10: app::RGArg;
        scope 2 {
            debug arg => _10;
        }
    }

    bb0: {
        _8 = RGArg::switch(const "text") -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = RGArg::short(move _8, const "a") -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = RGArg::help(move _7, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = RGArg::long_help(move _6, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _4 = RGArg::overrides(move _5, const "no-text") -> [return: bb5, unwind continue];
    }

    bb5: {
        _3 = RGArg::overrides(move _4, const "binary") -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = RGArg::overrides(move _3, const "no-binary") -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Vec::<RGArg>::push(_1, move _2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _14 = RGArg::switch(const "no-text") -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = RGArg::hidden(move _14) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = RGArg::overrides(move _13, const "text") -> [return: bb11, unwind continue];
    }

    bb11: {
        _11 = RGArg::overrides(move _12, const "binary") -> [return: bb12, unwind continue];
    }

    bb12: {
        _10 = RGArg::overrides(move _11, const "no-binary") -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = Vec::<RGArg>::push(_1, move _10) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

const flag_text::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search binary files as if they were text.";
        return;
    }
}

const flag_text::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Search binary files as if they were text. When this flag is present, ripgrep's\nbinary file detection is disabled. This means that when a binary file is\nsearched, its contents may be printed if there is a match. This may cause\nescape codes to be printed that alter the behavior of your terminal.\n\nWhen binary file detection is enabled it is imperfect. In general, it uses\na simple heuristic. If a NUL byte is seen during search, then the file is\nconsidered binary and search stops (unless this flag is present).\nAlternatively, if the '--binary' flag is used, then ripgrep will only quit\nwhen it sees a NUL byte after it sees a match (or searches the entire file).\n\nThis flag can be disabled with '--no-text'. It overrides the '--binary' flag.\n ";
        return;
    }
}

fn flag_threads(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::flag(const "threads", const "NUM") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::short(move _5, const "j") -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_threads::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The approximate number of threads to use.";
        return;
    }
}

const flag_threads::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "The approximate number of threads to use. A value of 0 (which is the default)\ncauses ripgrep to choose the thread count using heuristics.\n ";
        return;
    }
}

fn flag_trim(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    let mut _8: app::RGArg;
    let mut _9: app::RGArg;
    let _10: ();
    scope 1 {
        debug arg => _2;
        let _7: app::RGArg;
        scope 2 {
            debug arg => _7;
        }
    }

    bb0: {
        _5 = RGArg::switch(const "trim") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::overrides(move _3, const "no-trim") -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = RGArg::switch(const "no-trim") -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = RGArg::hidden(move _9) -> [return: bb7, unwind continue];
    }

    bb7: {
        _7 = RGArg::overrides(move _8, const "trim") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = Vec::<RGArg>::push(_1, move _7) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }
}

const flag_trim::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Trim prefixed whitespace from matches.";
        return;
    }
}

const flag_trim::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "When set, all ASCII whitespace at the beginning of each line printed will be\ntrimmed.\n\nThis flag can be disabled with --no-trim.\n ";
        return;
    }
}

fn flag_type(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "type", const "TYPE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "t") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::multiple(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_type::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only search files matching TYPE.";
        return;
    }
}

const flag_type::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only search files matching TYPE. Multiple type flags may be provided. Use the\n--type-list flag to list all available types.\n\nThis flag supports the special value 'all', which will behave as if --type\nwas provided for every file type supported by ripgrep (including any custom\nfile types). The end result is that '--type all' causes ripgrep to search in\n\"whitelist\" mode, where it will only search files it recognizes via its type\ndefinitions.\n ";
        return;
    }
}

fn flag_type_add(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::flag(const "type-add", const "TYPE_SPEC") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::multiple(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_type_add::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Add a new glob for a file type.";
        return;
    }
}

const flag_type_add::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Add a new glob for a particular file type. Only one glob can be added at a\ntime. Multiple --type-add flags can be provided. Unless --type-clear is used,\nglobs are added to any existing globs defined inside of ripgrep.\n\nNote that this MUST be passed to every invocation of ripgrep. Type settings are\nNOT persisted. See CONFIGURATION FILES for a workaround.\n\nExample:\n\n    rg --type-add 'foo:*.foo' -tfoo PATTERN.\n\n--type-add can also be used to include rules from other types with the special\ninclude directive. The include directive permits specifying one or more other\ntype names (separated by a comma) that have been defined and its rules will\nautomatically be imported into the type specified. For example, to create a\ntype called src that matches C++, Python and Markdown files, one can use:\n\n    --type-add 'src:include:cpp,py,md'\n\nAdditional glob rules can still be added to the src type by using the\n--type-add flag again:\n\n    --type-add 'src:include:cpp,py,md' --type-add 'src:*.foo'\n\nNote that type names must consist only of Unicode letters or numbers.\nPunctuation characters are not allowed.\n ";
        return;
    }
}

fn flag_type_clear(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let _6: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::flag(const "type-clear", const "TYPE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _2 = RGArg::multiple(move _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

const flag_type_clear::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Clear globs for a file type.";
        return;
    }
}

const flag_type_clear::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Clear the file type globs previously defined for TYPE. This only clears the\ndefault type definitions that are found inside of ripgrep.\n\nNote that this MUST be passed to every invocation of ripgrep. Type settings are\nNOT persisted. See CONFIGURATION FILES for a workaround.\n ";
        return;
    }
}

fn flag_type_not(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::flag(const "type-not", const "TYPE") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "T") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::multiple(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_type_not::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not search files matching TYPE.";
        return;
    }
}

const flag_type_not::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Do not search files matching TYPE. Multiple type-not flags may be provided. Use\nthe --type-list flag to list all available types.\n ";
        return;
    }
}

fn flag_type_list(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: &[&str];
    let _7: ();
    let mut _8: &[&str; 4];
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _5 = RGArg::switch(const "type-list") -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = RGArg::help(move _5, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _8 = const _;
        _6 = _8 as &[&str] (PointerCoercion(Unsize));
        _2 = RGArg::conflicts(move _3, move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in flag_type_list: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "file", const "files", const "pattern", const "regexp"];
        _0 = &_1;
        return;
    }
}

const flag_type_list::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show all supported file types.";
        return;
    }
}

const flag_type_list::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show all supported file types and their corresponding globs.\n ";
        return;
    }
}

fn flag_unrestricted(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::switch(const "unrestricted") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "u") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::multiple(move _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_unrestricted::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Reduce the level of \"smart\" searching.";
        return;
    }
}

const flag_unrestricted::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Reduce the level of \"smart\" searching. A single -u won't respect .gitignore\n(etc.) files (--no-ignore). Two -u flags will additionally search hidden files\nand directories (-./--hidden). Three -u flags will additionally search binary\nfiles (--binary).\n\n'rg -uuu' is roughly equivalent to 'grep -r'.\n ";
        return;
    }
}

fn flag_vimgrep(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let _5: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _4 = RGArg::switch(const "vimgrep") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = RGArg::help(move _4, const _) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = RGArg::long_help(move _3, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = Vec::<RGArg>::push(_1, move _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

const flag_vimgrep::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show results in vim compatible format.";
        return;
    }
}

const flag_vimgrep::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Show results with every match on its own line, including line numbers and\ncolumn numbers. With this option, a line with more than one match will be\nprinted more than once.\n ";
        return;
    }
}

fn flag_with_filename(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    let mut _9: app::RGArg;
    let mut _10: app::RGArg;
    let mut _11: app::RGArg;
    let mut _12: app::RGArg;
    let _13: ();
    scope 1 {
        debug arg => _2;
        let _8: app::RGArg;
        scope 2 {
            debug arg => _8;
        }
    }

    bb0: {
        _6 = RGArg::switch(const "with-filename") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "H") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "no-filename") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _12 = RGArg::switch(const "no-filename") -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = RGArg::short(move _12, const "I") -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = RGArg::help(move _11, const _) -> [return: bb9, unwind continue];
    }

    bb9: {
        _9 = RGArg::long_help(move _10, const _) -> [return: bb10, unwind continue];
    }

    bb10: {
        _8 = RGArg::overrides(move _9, const "with-filename") -> [return: bb11, unwind continue];
    }

    bb11: {
        _13 = Vec::<RGArg>::push(_1, move _8) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

const flag_with_filename::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Print the file path with the matched lines.";
        return;
    }
}

const flag_with_filename::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Display the file path for matches. This is the default when more than one\nfile is searched. If --heading is enabled (the default when printing to a\nterminal), the file path will be shown above clusters of matches from each\nfile; otherwise, the file name will be shown as a prefix for each matched line.\n\nThis flag overrides --no-filename.\n ";
        return;
    }
}

const flag_with_filename::NO_SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never print the file path with the matched lines.";
        return;
    }
}

const flag_with_filename::NO_LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Never print the file path with the matched lines. This is the default when\nripgrep is explicitly instructed to search one file or stdin.\n\nThis flag overrides --with-filename.\n ";
        return;
    }
}

fn flag_word_regexp(_1: &mut Vec<RGArg>) -> () {
    debug args => _1;
    let mut _0: ();
    let _2: app::RGArg;
    let mut _3: app::RGArg;
    let mut _4: app::RGArg;
    let mut _5: app::RGArg;
    let mut _6: app::RGArg;
    let _7: ();
    scope 1 {
        debug arg => _2;
    }

    bb0: {
        _6 = RGArg::switch(const "word-regexp") -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = RGArg::short(move _6, const "w") -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = RGArg::help(move _5, const _) -> [return: bb3, unwind continue];
    }

    bb3: {
        _3 = RGArg::long_help(move _4, const _) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = RGArg::overrides(move _3, const "line-regexp") -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Vec::<RGArg>::push(_1, move _2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

const flag_word_regexp::SHORT: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show matches surrounded by word boundaries.";
        return;
    }
}

const flag_word_regexp::LONG: &str = {
    let mut _0: &str;

    bb0: {
        _0 = const "Only show matches surrounded by word boundaries. This is roughly equivalent to\nputting \\b before and after all of the search patterns.\n\nThis overrides the --line-regexp flag.\n ";
        return;
    }
}

fn args::<impl at crates/core/args.rs:51:10: 51:15>::clone(_1: &args::Command) -> args::Command {
    debug self => _1;
    let mut _0: args::Command;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn args::<impl at crates/core/args.rs:51:23: 51:28>::fmt(_1: &args::Command, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;
    let _10: &str;
    let _11: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb7, 5: bb8, 6: bb1, otherwise: bb2];
    }

    bb1: {
        _11 = const "PCRE2Version";
        _3 = _11;
        goto -> bb9;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Search";
        _3 = _5;
        goto -> bb9;
    }

    bb4: {
        _6 = const "SearchParallel";
        _3 = _6;
        goto -> bb9;
    }

    bb5: {
        _7 = const "SearchNever";
        _3 = _7;
        goto -> bb9;
    }

    bb6: {
        _8 = const "Files";
        _3 = _8;
        goto -> bb9;
    }

    bb7: {
        _9 = const "FilesParallel";
        _3 = _9;
        goto -> bb9;
    }

    bb8: {
        _10 = const "Types";
        _3 = _10;
        goto -> bb9;
    }

    bb9: {
        _0 = std::fmt::Formatter::<'_>::write_str(_2, move _3) -> [return: bb10, unwind continue];
    }

    bb10: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:51:30: 51:32>::assert_receiver_is_total_eq(_1: &args::Command) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:51:34: 51:43>::eq(_1: &args::Command, _2: &args::Command) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn args::<impl at crates/core/args.rs:74:1: 74:13>::is_search(_1: &args::Command) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: isize;

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb2, 1: bb2, 2: bb3, 3: bb3, 4: bb3, 5: bb3, 6: bb3, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:93:10: 93:15>::clone(_1: &args::Args) -> args::Args {
    debug self => _1;
    let mut _0: args::Args;
    let mut _2: std::sync::Arc<args::ArgsImp>;
    let _3: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _2 = <Arc<ArgsImp> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = args::Args(move _2);
        return;
    }
}

fn args::<impl at crates/core/args.rs:93:17: 93:22>::fmt(_1: &args::Args, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&std::sync::Arc<args::ArgsImp>;
    let _6: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _3 = const "Args";
        _6 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:96:10: 96:15>::clone(_1: &ArgsImp) -> ArgsImp {
    debug self => _1;
    let mut _0: args::ArgsImp;
    let mut _2: args::ArgMatches;
    let _3: &args::ArgMatches;
    let mut _4: std::vec::Vec<std::string::String>;
    let _5: &std::vec::Vec<std::string::String>;
    let mut _6: search::PatternMatcher;
    let _7: &search::PatternMatcher;
    let mut _8: std::vec::Vec<std::path::PathBuf>;
    let _9: &std::vec::Vec<std::path::PathBuf>;
    let mut _10: bool;
    let _11: &bool;

    bb0: {
        _3 = &((*_1).0: args::ArgMatches);
        _2 = <args::ArgMatches as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: std::vec::Vec<std::string::String>);
        _4 = <Vec<std::string::String> as Clone>::clone(_5) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _7 = &((*_1).2: search::PatternMatcher);
        _6 = <PatternMatcher as Clone>::clone(_7) -> [return: bb3, unwind: bb6];
    }

    bb3: {
        _9 = &((*_1).3: std::vec::Vec<std::path::PathBuf>);
        _8 = <Vec<PathBuf> as Clone>::clone(_9) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _11 = &((*_1).4: bool);
        _10 = (*_11);
        _0 = ArgsImp { matches: move _2, patterns: move _4, matcher: move _6, paths: move _8, using_default_path: move _10 };
        return;
    }

    bb5 (cleanup): {
        drop(_6) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:96:17: 96:22>::fmt(_1: &ArgsImp, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &args::ArgMatches;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::vec::Vec<std::string::String>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &search::PatternMatcher;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &std::vec::Vec<std::path::PathBuf>;
    let _16: &str;
    let mut _17: &dyn std::fmt::Debug;
    let _18: &&bool;
    let _19: &bool;

    bb0: {
        _3 = const "ArgsImp";
        _4 = const "matches";
        _6 = &((*_1).0: args::ArgMatches);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "patterns";
        _9 = &((*_1).1: std::vec::Vec<std::string::String>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "matcher";
        _12 = &((*_1).2: search::PatternMatcher);
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = const "paths";
        _15 = &((*_1).3: std::vec::Vec<std::path::PathBuf>);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _16 = const "using_default_path";
        _19 = &((*_1).4: bool);
        _18 = &_19;
        _17 = _18 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field5_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11, _13, move _14, _16, move _17) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::parse() -> std::result::Result<args::Args, Box<dyn std::error::Error>> {
    let mut _0: std::result::Result<args::Args, std::boxed::Box<dyn std::error::Error>>;
    let _1: args::ArgMatches;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, clap::ArgMatches<'_>>;
    let mut _3: std::result::Result<clap::ArgMatches<'_>, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: std::env::ArgsOs;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _7: clap::ArgMatches<'_>;
    let _8: ();
    let mut _9: bool;
    let mut _10: bool;
    let mut _11: &args::ArgMatches;
    let _12: &str;
    let _13: ();
    let mut _14: bool;
    let mut _15: bool;
    let mut _16: &args::ArgMatches;
    let _17: &str;
    let mut _18: std::result::Result<(), log::SetLoggerError>;
    let mut _19: isize;
    let mut _21: std::boxed::Box<dyn std::error::Error>;
    let mut _23: std::fmt::Arguments<'_>;
    let mut _24: &[&str];
    let mut _25: &[core::fmt::rt::Argument<'_>];
    let _26: &[core::fmt::rt::Argument<'_>; 1];
    let _27: [core::fmt::rt::Argument<'_>; 1];
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &log::SetLoggerError;
    let mut _30: bool;
    let mut _31: &args::ArgMatches;
    let _32: &str;
    let _33: ();
    let mut _34: log::LevelFilter;
    let mut _35: bool;
    let mut _36: &args::ArgMatches;
    let _37: &str;
    let _38: ();
    let mut _39: log::LevelFilter;
    let _40: ();
    let mut _41: log::LevelFilter;
    let mut _43: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::ArgMatches>;
    let mut _44: std::result::Result<args::ArgMatches, std::boxed::Box<dyn std::error::Error>>;
    let mut _45: args::ArgMatches;
    let mut _46: isize;
    let mut _49: bool;
    let mut _50: &args::ArgMatches;
    let _51: &str;
    let _52: ();
    let mut _53: log::LevelFilter;
    let mut _54: bool;
    let mut _55: &args::ArgMatches;
    let _56: &str;
    let _57: ();
    let mut _58: log::LevelFilter;
    let _59: ();
    let mut _60: log::LevelFilter;
    let _61: ();
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: &args::ArgMatches;
    let _65: &str;
    let _66: ();
    let mut _67: bool;
    let mut _68: bool;
    let mut _69: &args::ArgMatches;
    let _70: &str;
    let mut _71: args::ArgMatches;
    let mut _73: bool;
    let mut _74: bool;
    scope 1 {
        debug early_matches => _1;
        let _42: args::ArgMatches;
        let _47: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _48: args::ArgMatches;
        scope 6 {
            debug err => const SetLoggerError(());
            let _20: log::SetLoggerError;
            let _22: std::string::String;
            let mut _72: &[&str; 1];
            scope 7 {
                debug res => _22;
            }
        }
        scope 8 {
            debug matches => _42;
        }
        scope 9 {
            debug residual => _47;
            scope 10 {
            }
        }
        scope 11 {
            debug val => _48;
            scope 12 {
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _73 = const false;
        _74 = const false;
        _4 = args_os() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = clap_matches::<ArgsOs, OsString>(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = <std::result::Result<clap::ArgMatches<'_>, Box<dyn std::error::Error>> as Try>::branch(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = move ((_2 as Continue).0: clap::ArgMatches<'_>);
        _1 = args::ArgMatches::new(move _7) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::Args, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb43, unwind continue];
    }

    bb7: {
        _73 = const true;
        _11 = &_1;
        _12 = const "no-messages";
        _10 = args::ArgMatches::is_present(move _11, _12) -> [return: bb8, unwind: bb51];
    }

    bb8: {
        _9 = Not(move _10);
        _8 = set_messages(move _9) -> [return: bb9, unwind: bb51];
    }

    bb9: {
        _16 = &_1;
        _17 = const "no-ignore-messages";
        _15 = args::ArgMatches::is_present(move _16, _17) -> [return: bb10, unwind: bb51];
    }

    bb10: {
        _14 = Not(move _15);
        _13 = set_ignore_messages(move _14) -> [return: bb11, unwind: bb51];
    }

    bb11: {
        _18 = Logger::init() -> [return: bb12, unwind: bb51];
    }

    bb12: {
        _19 = discriminant(_18);
        switchInt(move _19) -> [1: bb13, otherwise: bb18];
    }

    bb13: {
        _72 = const _;
        _24 = _72 as &[&str] (PointerCoercion(Unsize));
        _29 = &_20;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<SetLoggerError>(_29) -> [return: bb14, unwind: bb51];
    }

    bb14: {
        _27 = [move _28];
        _26 = &_27;
        _25 = _26 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _23 = Arguments::<'_>::new_v1(move _24, move _25) -> [return: bb15, unwind: bb51];
    }

    bb15: {
        _22 = format(move _23) -> [return: bb16, unwind: bb51];
    }

    bb16: {
        _21 = <std::string::String as Into<Box<dyn std::error::Error>>>::into(move _22) -> [return: bb17, unwind: bb51];
    }

    bb17: {
        _0 = std::result::Result::<args::Args, Box<dyn std::error::Error>>::Err(move _21);
        goto -> bb47;
    }

    bb18: {
        _31 = &_1;
        _32 = const "trace";
        _30 = args::ArgMatches::is_present(move _31, _32) -> [return: bb19, unwind: bb51];
    }

    bb19: {
        switchInt(move _30) -> [0: bb21, otherwise: bb20];
    }

    bb20: {
        _34 = log::LevelFilter::Trace;
        _33 = set_max_level(move _34) -> [return: bb52, unwind: bb51];
    }

    bb21: {
        _36 = &_1;
        _37 = const "debug";
        _35 = args::ArgMatches::is_present(move _36, _37) -> [return: bb22, unwind: bb51];
    }

    bb22: {
        switchInt(move _35) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _39 = log::LevelFilter::Debug;
        _38 = set_max_level(move _39) -> [return: bb53, unwind: bb51];
    }

    bb24: {
        _41 = log::LevelFilter::Warn;
        _40 = set_max_level(move _41) -> [return: bb54, unwind: bb51];
    }

    bb25: {
        _73 = const false;
        _45 = move _1;
        _44 = args::ArgMatches::reconfigure(move _45) -> [return: bb26, unwind: bb51];
    }

    bb26: {
        _43 = <std::result::Result<args::ArgMatches, Box<dyn std::error::Error>> as Try>::branch(move _44) -> [return: bb27, unwind: bb51];
    }

    bb27: {
        _46 = discriminant(_43);
        switchInt(move _46) -> [0: bb28, 1: bb29, otherwise: bb5];
    }

    bb28: {
        _48 = move ((_43 as Continue).0: args::ArgMatches);
        _74 = const true;
        _42 = move _48;
        _50 = &_42;
        _51 = const "trace";
        _49 = args::ArgMatches::is_present(move _50, _51) -> [return: bb31, unwind: bb49];
    }

    bb29: {
        _47 = move ((_43 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::Args, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _47) -> [return: bb30, unwind: bb51];
    }

    bb30: {
        _74 = const false;
        goto -> bb47;
    }

    bb31: {
        switchInt(move _49) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _53 = log::LevelFilter::Trace;
        _52 = set_max_level(move _53) -> [return: bb55, unwind: bb49];
    }

    bb33: {
        _55 = &_42;
        _56 = const "debug";
        _54 = args::ArgMatches::is_present(move _55, _56) -> [return: bb34, unwind: bb49];
    }

    bb34: {
        switchInt(move _54) -> [0: bb36, otherwise: bb35];
    }

    bb35: {
        _58 = log::LevelFilter::Debug;
        _57 = set_max_level(move _58) -> [return: bb56, unwind: bb49];
    }

    bb36: {
        _60 = log::LevelFilter::Warn;
        _59 = set_max_level(move _60) -> [return: bb57, unwind: bb49];
    }

    bb37: {
        _64 = &_42;
        _65 = const "no-messages";
        _63 = args::ArgMatches::is_present(move _64, _65) -> [return: bb38, unwind: bb49];
    }

    bb38: {
        _62 = Not(move _63);
        _61 = set_messages(move _62) -> [return: bb39, unwind: bb49];
    }

    bb39: {
        _69 = &_42;
        _70 = const "no-ignore-messages";
        _68 = args::ArgMatches::is_present(move _69, _70) -> [return: bb40, unwind: bb49];
    }

    bb40: {
        _67 = Not(move _68);
        _66 = set_ignore_messages(move _67) -> [return: bb41, unwind: bb49];
    }

    bb41: {
        _74 = const false;
        _71 = move _42;
        _0 = args::ArgMatches::to_args(move _71) -> [return: bb42, unwind: bb49];
    }

    bb42: {
        _74 = const false;
        _73 = const false;
        goto -> bb44;
    }

    bb43: {
        _73 = const false;
        goto -> bb44;
    }

    bb44: {
        return;
    }

    bb45 (cleanup): {
        resume;
    }

    bb46: {
        drop(_1) -> [return: bb43, unwind continue];
    }

    bb47: {
        switchInt(_73) -> [0: bb43, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop(_42) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        switchInt(_74) -> [0: bb51, otherwise: bb48];
    }

    bb50 (cleanup): {
        drop(_1) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        switchInt(_73) -> [0: bb45, otherwise: bb50];
    }

    bb52: {
        goto -> bb25;
    }

    bb53: {
        goto -> bb25;
    }

    bb54: {
        goto -> bb25;
    }

    bb55: {
        goto -> bb37;
    }

    bb56: {
        goto -> bb37;
    }

    bb57: {
        goto -> bb37;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:118:1: 118:10>::parse: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "failed to initialize logger: "];
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::matches(_1: &args::Args) -> &args::ArgMatches {
    debug self => _1;
    let mut _0: &args::ArgMatches;
    let _2: &args::ArgsImp;
    let mut _3: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _2 = <Arc<ArgsImp> as Deref>::deref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &((*_2).0: args::ArgMatches);
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::patterns(_1: &args::Args) -> &[std::string::String] {
    debug self => _1;
    let mut _0: &[std::string::String];
    let _2: &std::vec::Vec<std::string::String>;
    let _3: &args::ArgsImp;
    let mut _4: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _4 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _3 = <Arc<ArgsImp> as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &((*_3).1: std::vec::Vec<std::string::String>);
        _0 = <Vec<std::string::String> as Deref>::deref(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::matcher(_1: &args::Args) -> &PatternMatcher {
    debug self => _1;
    let mut _0: &search::PatternMatcher;
    let _2: &args::ArgsImp;
    let mut _3: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _2 = <Arc<ArgsImp> as Deref>::deref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = &((*_2).2: search::PatternMatcher);
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::paths(_1: &args::Args) -> &[PathBuf] {
    debug self => _1;
    let mut _0: &[std::path::PathBuf];
    let _2: &std::vec::Vec<std::path::PathBuf>;
    let _3: &args::ArgsImp;
    let mut _4: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _4 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _3 = <Arc<ArgsImp> as Deref>::deref(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = &((*_3).3: std::vec::Vec<std::path::PathBuf>);
        _0 = <Vec<PathBuf> as Deref>::deref(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::using_default_path(_1: &args::Args) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &args::ArgsImp;
    let mut _3: &std::sync::Arc<args::ArgsImp>;

    bb0: {
        _3 = &((*_1).0: std::sync::Arc<args::ArgsImp>);
        _2 = <Arc<ArgsImp> as Deref>::deref(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = ((*_2).4: bool);
        return;
    }
}

fn args::<impl at crates/core/args.rs:118:1: 118:10>::printer(_1: &args::Args, _2: W) -> std::result::Result<Printer<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug wtr => _2;
    let mut _0: std::result::Result<search::Printer<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: args::OutputKind;
    let _4: &args::ArgMatches;
    let mut _5: isize;
    let _6: bool;
    let mut _7: &args::Command;
    let _8: args::Command;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::Command>;
    let mut _10: std::result::Result<args::Command, std::boxed::Box<dyn std::error::Error>>;
    let mut _11: isize;
    let _12: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _13: args::Command;
    let mut _14: std::result::Result<grep::grep_printer::Standard<W>, std::boxed::Box<dyn std::error::Error>>;
    let _15: &args::ArgMatches;
    let _16: &[std::path::PathBuf];
    let mut _17: W;
    let mut _18: std::result::Result<grep::grep_printer::Summary<W>, std::boxed::Box<dyn std::error::Error>>;
    let _19: &args::ArgMatches;
    let _20: &[std::path::PathBuf];
    let mut _21: W;
    let mut _22: std::result::Result<grep::grep_printer::JSON<W>, std::boxed::Box<dyn std::error::Error>>;
    let _23: &args::ArgMatches;
    let mut _24: W;
    let mut _25: &args::Command;
    let mut _26: bool;
    scope 1 {
        debug separator_search => _6;
    }
    scope 2 {
        debug residual => _12;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _13;
        scope 5 {
        }
    }

    bb0: {
        _26 = const false;
        _26 = const true;
        _4 = args::Args::matches(_1) -> [return: bb1, unwind: bb24];
    }

    bb1: {
        _3 = args::ArgMatches::output_kind(_4) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb5, 1: bb15, 2: bb3, otherwise: bb4];
    }

    bb3: {
        _23 = args::Args::matches(_1) -> [return: bb19, unwind: bb24];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _10 = args::Args::command(_1) -> [return: bb6, unwind: bb24];
    }

    bb6: {
        _9 = <std::result::Result<args::Command, Box<dyn std::error::Error>> as Try>::branch(move _10) -> [return: bb7, unwind: bb24];
    }

    bb7: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb8, 1: bb9, otherwise: bb4];
    }

    bb8: {
        _13 = ((_9 as Continue).0: args::Command);
        _8 = _13;
        _7 = &_8;
        _25 = const _;
        _6 = <args::Command as PartialEq>::eq(move _7, _25) -> [return: bb11, unwind: bb24];
    }

    bb9: {
        _12 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Printer<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _12) -> [return: bb10, unwind: bb24];
    }

    bb10: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb11: {
        _15 = args::Args::matches(_1) -> [return: bb12, unwind: bb24];
    }

    bb12: {
        _16 = args::Args::paths(_1) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        _26 = const false;
        _17 = move _2;
        _14 = args::ArgMatches::printer_standard::<W>(_15, _16, move _17, _6) -> [return: bb14, unwind: bb24];
    }

    bb14: {
        _0 = std::result::Result::<Standard<W>, Box<dyn std::error::Error>>::map::<Printer<W>, fn(Standard<W>) -> Printer<W> {Printer::<W>::Standard}>(move _14, Printer::<W>::Standard) -> [return: bb25, unwind: bb24];
    }

    bb15: {
        _19 = args::Args::matches(_1) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _20 = args::Args::paths(_1) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _26 = const false;
        _21 = move _2;
        _18 = args::ArgMatches::printer_summary::<W>(_19, _20, move _21) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _0 = std::result::Result::<Summary<W>, Box<dyn std::error::Error>>::map::<Printer<W>, fn(Summary<W>) -> Printer<W> {Printer::<W>::Summary}>(move _18, Printer::<W>::Summary) -> [return: bb26, unwind: bb24];
    }

    bb19: {
        _26 = const false;
        _24 = move _2;
        _22 = args::ArgMatches::printer_json::<W>(_23, move _24) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        _0 = std::result::Result::<JSON<W>, Box<dyn std::error::Error>>::map::<Printer<W>, fn(JSON<W>) -> Printer<W> {Printer::<W>::JSON}>(move _22, Printer::<W>::JSON) -> [return: bb27, unwind: bb24];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        drop(_2) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_26) -> [0: bb22, otherwise: bb23];
    }

    bb25: {
        goto -> bb21;
    }

    bb26: {
        goto -> bb21;
    }

    bb27: {
        goto -> bb21;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:118:1: 118:10>::printer: &args::Command = {
    let mut _0: &args::Command;
    let mut _1: args::Command;

    bb0: {
        _1 = args::Command::Search;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::buffer_writer(_1: &args::Args) -> std::result::Result<BufferWriter, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<termcolor::BufferWriter, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: termcolor::BufferWriter;
    let mut _3: termcolor::ColorChoice;
    let _4: &args::ArgMatches;
    let _5: ();
    let mut _6: &mut termcolor::BufferWriter;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<std::vec::Vec<u8>>>;
    let mut _8: std::result::Result<std::option::Option<std::vec::Vec<u8>>, std::boxed::Box<dyn std::error::Error>>;
    let _9: &args::ArgMatches;
    let mut _10: isize;
    let mut _13: termcolor::BufferWriter;
    scope 1 {
        debug wtr => _2;
        let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _12: std::option::Option<std::vec::Vec<u8>>;
        scope 2 {
            debug residual => _11;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _12;
            scope 5 {
            }
        }
    }

    bb0: {
        _4 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = args::ArgMatches::color_choice(_4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = BufferWriter::stdout(move _3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &mut _2;
        _9 = args::Args::matches(_1) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _8 = args::ArgMatches::file_separator(_9) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _7 = <std::result::Result<Option<Vec<u8>>, Box<dyn std::error::Error>> as Try>::branch(move _8) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = move ((_7 as Continue).0: std::option::Option<std::vec::Vec<u8>>);
        _5 = BufferWriter::separator(move _6, move _12) -> [return: bb11, unwind: bb13];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<BufferWriter, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb10, unwind: bb13];
    }

    bb10: {
        drop(_2) -> [return: bb12, unwind continue];
    }

    bb11: {
        _13 = move _2;
        _0 = std::result::Result::<BufferWriter, Box<dyn std::error::Error>>::Ok(move _13);
        goto -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_2) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::command(_1: &args::Args) -> std::result::Result<args::Command, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<args::Command, std::boxed::Box<dyn std::error::Error>>;
    let _2: bool;
    let _3: &args::ArgMatches;
    let _4: &[std::path::PathBuf];
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, usize>;
    let mut _6: std::result::Result<usize, std::boxed::Box<dyn std::error::Error>>;
    let _7: &args::ArgMatches;
    let mut _8: isize;
    let mut _12: args::Command;
    let mut _13: bool;
    let _14: &args::ArgMatches;
    let _15: &str;
    let mut _16: bool;
    let _17: &args::ArgMatches;
    let _18: &str;
    let mut _19: bool;
    let _20: &args::ArgMatches;
    let _21: &str;
    let mut _22: bool;
    let mut _23: bool;
    let _24: &args::ArgMatches;
    let _25: &[std::string::String];
    let mut _26: bool;
    scope 1 {
        debug is_one_search => _2;
        let _9: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _10: usize;
        scope 2 {
            debug threads => _10;
            let _11: bool;
            scope 7 {
                debug one_thread => _11;
            }
        }
        scope 3 {
            debug residual => _9;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _10;
            scope 6 {
            }
        }
    }

    bb0: {
        _3 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = args::Args::paths(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _2 = args::ArgMatches::is_one_search(_3, _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _7 = args::Args::matches(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = args::ArgMatches::threads(_7) -> [return: bb5, unwind continue];
    }

    bb5: {
        _5 = <std::result::Result<usize, Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _8 = discriminant(_5);
        switchInt(move _8) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _10 = ((_5 as Continue).0: usize);
        switchInt(_2) -> [0: bb11, otherwise: bb10];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _9 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::Command, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _9) -> [return: bb35, unwind continue];
    }

    bb10: {
        _11 = const true;
        goto -> bb12;
    }

    bb11: {
        _11 = Eq(_10, const 1_usize);
        goto -> bb12;
    }

    bb12: {
        _14 = args::Args::matches(_1) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = const "pcre2-version";
        _13 = args::ArgMatches::is_present(_14, _15) -> [return: bb14, unwind continue];
    }

    bb14: {
        switchInt(move _13) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _12 = args::Command::PCRE2Version;
        goto -> bb34;
    }

    bb16: {
        _17 = args::Args::matches(_1) -> [return: bb17, unwind continue];
    }

    bb17: {
        _18 = const "type-list";
        _16 = args::ArgMatches::is_present(_17, _18) -> [return: bb18, unwind continue];
    }

    bb18: {
        switchInt(move _16) -> [0: bb20, otherwise: bb19];
    }

    bb19: {
        _12 = args::Command::Types;
        goto -> bb34;
    }

    bb20: {
        _20 = args::Args::matches(_1) -> [return: bb21, unwind continue];
    }

    bb21: {
        _21 = const "files";
        _19 = args::ArgMatches::is_present(_20, _21) -> [return: bb22, unwind continue];
    }

    bb22: {
        switchInt(move _19) -> [0: bb26, otherwise: bb23];
    }

    bb23: {
        _22 = _11;
        switchInt(move _22) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _12 = args::Command::Files;
        goto -> bb34;
    }

    bb25: {
        _12 = args::Command::FilesParallel;
        goto -> bb34;
    }

    bb26: {
        _24 = args::Args::matches(_1) -> [return: bb27, unwind continue];
    }

    bb27: {
        _25 = args::Args::patterns(_1) -> [return: bb28, unwind continue];
    }

    bb28: {
        _23 = args::ArgMatches::can_never_match(_24, _25) -> [return: bb29, unwind continue];
    }

    bb29: {
        switchInt(move _23) -> [0: bb31, otherwise: bb30];
    }

    bb30: {
        _12 = args::Command::SearchNever;
        goto -> bb34;
    }

    bb31: {
        _26 = _11;
        switchInt(move _26) -> [0: bb33, otherwise: bb32];
    }

    bb32: {
        _12 = args::Command::Search;
        goto -> bb34;
    }

    bb33: {
        _12 = args::Command::SearchParallel;
        goto -> bb34;
    }

    bb34: {
        _0 = std::result::Result::<args::Command, Box<dyn std::error::Error>>::Ok(move _12);
        goto -> bb35;
    }

    bb35: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::path_printer(_1: &args::Args, _2: W) -> std::result::Result<PathPrinter<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug wtr => _2;
    let mut _0: std::result::Result<path_printer::PathPrinter<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: path_printer::PathPrinterBuilder;
    let _4: &mut path_printer::PathPrinterBuilder;
    let mut _5: &mut path_printer::PathPrinterBuilder;
    let mut _6: &mut path_printer::PathPrinterBuilder;
    let mut _7: &mut path_printer::PathPrinterBuilder;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, grep::grep_printer::ColorSpecs>;
    let mut _9: std::result::Result<grep::grep_printer::ColorSpecs, std::boxed::Box<dyn std::error::Error>>;
    let _10: &args::ArgMatches;
    let mut _11: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u8>>;
    let mut _15: std::result::Result<std::option::Option<u8>, std::boxed::Box<dyn std::error::Error>>;
    let _16: &args::ArgMatches;
    let mut _17: isize;
    let mut _20: u8;
    let mut _21: std::option::Option<u8>;
    let _22: &args::ArgMatches;
    let mut _23: path_printer::PathPrinter<W>;
    let mut _24: &path_printer::PathPrinterBuilder;
    let mut _25: W;
    let mut _26: bool;
    scope 1 {
        debug builder => _3;
        let _12: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _13: grep::grep_printer::ColorSpecs;
        let _18: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _19: std::option::Option<u8>;
        scope 2 {
            debug residual => _12;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _13;
            scope 5 {
            }
        }
        scope 6 {
            debug residual => _18;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _19;
            scope 9 {
            }
        }
    }

    bb0: {
        _26 = const false;
        _26 = const true;
        _3 = PathPrinterBuilder::new() -> [return: bb1, unwind: bb24];
    }

    bb1: {
        _7 = &mut _3;
        _10 = args::Args::matches(_1) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _9 = args::ArgMatches::color_specs(_10) -> [return: bb3, unwind: bb24];
    }

    bb3: {
        _8 = <std::result::Result<ColorSpecs, Box<dyn std::error::Error>> as Try>::branch(move _9) -> [return: bb4, unwind: bb24];
    }

    bb4: {
        _11 = discriminant(_8);
        switchInt(move _11) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _13 = move ((_8 as Continue).0: grep::grep_printer::ColorSpecs);
        _6 = PathPrinterBuilder::color_specs(move _7, move _13) -> [return: bb8, unwind: bb24];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _12 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<PathPrinter<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _12) -> [return: bb25, unwind: bb24];
    }

    bb8: {
        _16 = args::Args::matches(_1) -> [return: bb9, unwind: bb24];
    }

    bb9: {
        _15 = args::ArgMatches::path_separator(_16) -> [return: bb10, unwind: bb24];
    }

    bb10: {
        _14 = <std::result::Result<Option<u8>, Box<dyn std::error::Error>> as Try>::branch(move _15) -> [return: bb11, unwind: bb24];
    }

    bb11: {
        _17 = discriminant(_14);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb6];
    }

    bb12: {
        _19 = ((_14 as Continue).0: std::option::Option<u8>);
        _5 = PathPrinterBuilder::separator(_6, _19) -> [return: bb14, unwind: bb24];
    }

    bb13: {
        _18 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<PathPrinter<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _18) -> [return: bb26, unwind: bb24];
    }

    bb14: {
        _22 = args::Args::matches(_1) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _21 = args::ArgMatches::path_terminator(_22) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _20 = Option::<u8>::unwrap_or(move _21, const 10_u8) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _4 = PathPrinterBuilder::terminator(_5, move _20) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _24 = &_3;
        _26 = const false;
        _25 = move _2;
        _23 = PathPrinterBuilder::build::<W>(move _24, move _25) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        _0 = std::result::Result::<PathPrinter<W>, Box<dyn std::error::Error>>::Ok(move _23);
        goto -> bb20;
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        resume;
    }

    bb22: {
        drop(_2) -> [return: bb20, unwind continue];
    }

    bb23 (cleanup): {
        drop(_2) -> [return: bb21, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_26) -> [0: bb21, otherwise: bb23];
    }

    bb25: {
        goto -> bb22;
    }

    bb26: {
        goto -> bb22;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::quiet(_1: &args::Args) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &args::ArgMatches;
    let _3: &str;

    bb0: {
        _2 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = const "quiet";
        _0 = args::ArgMatches::is_present(_2, _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::quit_after_match(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let mut _3: bool;
    let _4: &args::ArgMatches;
    let _5: &str;
    let mut _6: &std::option::Option<grep::grep_printer::Stats>;
    let _7: std::option::Option<grep::grep_printer::Stats>;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<grep::grep_printer::Stats>>;
    let mut _9: std::result::Result<std::option::Option<grep::grep_printer::Stats>, std::boxed::Box<dyn std::error::Error>>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _12: std::option::Option<grep::grep_printer::Stats>;
    scope 1 {
        debug residual => _11;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _12;
        scope 4 {
        }
    }

    bb0: {
        _4 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "quiet";
        _3 = args::ArgMatches::is_present(_4, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _9 = args::Args::stats(_1) -> [return: bb5, unwind continue];
    }

    bb4: {
        _2 = const false;
        goto -> bb10;
    }

    bb5: {
        _8 = <std::result::Result<Option<Stats>, Box<dyn std::error::Error>> as Try>::branch(move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = move ((_8 as Continue).0: std::option::Option<grep::grep_printer::Stats>);
        _7 = move _12;
        _6 = &_7;
        _2 = Option::<Stats>::is_none(move _6) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _2);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::search_worker(_1: &args::Args, _2: W) -> std::result::Result<SearchWorker<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug wtr => _2;
    let mut _0: std::result::Result<search::SearchWorker<W>, std::boxed::Box<dyn std::error::Error>>;
    let _3: &args::ArgMatches;
    let _5: &search::PatternMatcher;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, search::Printer<W>>;
    let mut _8: std::result::Result<search::Printer<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _9: W;
    let mut _10: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, grep::grep_searcher::Searcher>;
    let mut _15: std::result::Result<grep::grep_searcher::Searcher, std::boxed::Box<dyn std::error::Error>>;
    let _16: &[std::path::PathBuf];
    let mut _17: isize;
    let _21: &mut search::SearchWorkerBuilder;
    let mut _22: &mut search::SearchWorkerBuilder;
    let mut _23: &mut search::SearchWorkerBuilder;
    let mut _24: &mut search::SearchWorkerBuilder;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, &mut search::SearchWorkerBuilder>;
    let mut _26: std::result::Result<&mut search::SearchWorkerBuilder, std::boxed::Box<dyn std::error::Error>>;
    let mut _27: &mut search::SearchWorkerBuilder;
    let mut _28: &mut search::SearchWorkerBuilder;
    let mut _29: bool;
    let _30: &str;
    let mut _31: std::option::Option<std::path::PathBuf>;
    let mut _32: isize;
    let mut _35: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::overrides::Override>;
    let mut _36: std::result::Result<ignore::overrides::Override, std::boxed::Box<dyn std::error::Error>>;
    let mut _37: isize;
    let mut _40: bool;
    let _41: &str;
    let mut _42: grep::grep_searcher::BinaryDetection;
    let mut _43: grep::grep_searcher::BinaryDetection;
    let mut _44: search::SearchWorker<W>;
    let mut _45: &search::SearchWorkerBuilder;
    let mut _46: search::PatternMatcher;
    let mut _47: grep::grep_searcher::Searcher;
    let mut _48: search::Printer<W>;
    let mut _49: bool;
    let mut _50: bool;
    let mut _51: bool;
    let mut _52: bool;
    scope 1 {
        debug matches => _3;
        let _4: search::PatternMatcher;
        scope 2 {
            debug matcher => _4;
            let _6: search::Printer<W>;
            let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _12: search::Printer<W>;
            scope 3 {
                debug printer => _6;
                let _13: grep::grep_searcher::Searcher;
                let _18: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                let _19: grep::grep_searcher::Searcher;
                scope 8 {
                    debug searcher => _13;
                    let mut _20: search::SearchWorkerBuilder;
                    scope 13 {
                        debug builder => _20;
                        let _33: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                        let _34: &mut search::SearchWorkerBuilder;
                        let _38: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                        let _39: ignore::overrides::Override;
                        scope 14 {
                            debug residual => _33;
                            scope 15 {
                            }
                        }
                        scope 16 {
                            debug val => _34;
                            scope 17 {
                            }
                        }
                        scope 18 {
                            debug residual => _38;
                            scope 19 {
                            }
                        }
                        scope 20 {
                            debug val => _39;
                            scope 21 {
                            }
                        }
                    }
                }
                scope 9 {
                    debug residual => _18;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _19;
                    scope 12 {
                    }
                }
            }
            scope 4 {
                debug residual => _11;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _12;
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _52 = const false;
        _51 = const false;
        _50 = const false;
        _49 = const false;
        _52 = const true;
        _3 = args::Args::matches(_1) -> [return: bb1, unwind: bb50];
    }

    bb1: {
        _5 = args::Args::matcher(_1) -> [return: bb2, unwind: bb50];
    }

    bb2: {
        _4 = <PatternMatcher as Clone>::clone(_5) -> [return: bb3, unwind: bb50];
    }

    bb3: {
        _51 = const true;
        _52 = const false;
        _9 = move _2;
        _8 = args::Args::printer::<W>(_1, move _9) -> [return: bb4, unwind: bb48];
    }

    bb4: {
        _7 = <std::result::Result<Printer<W>, Box<dyn std::error::Error>> as Try>::branch(move _8) -> [return: bb5, unwind: bb48];
    }

    bb5: {
        _10 = discriminant(_7);
        switchInt(move _10) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _12 = move ((_7 as Continue).0: search::Printer<W>);
        _50 = const true;
        _6 = move _12;
        _16 = args::Args::paths(_1) -> [return: bb9, unwind: bb46];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<SearchWorker<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb51, unwind: bb48];
    }

    bb9: {
        _15 = args::ArgMatches::searcher(_3, _16) -> [return: bb10, unwind: bb46];
    }

    bb10: {
        _14 = <std::result::Result<grep::grep_searcher::Searcher, Box<dyn std::error::Error>> as Try>::branch(move _15) -> [return: bb11, unwind: bb46];
    }

    bb11: {
        _17 = discriminant(_14);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb7];
    }

    bb12: {
        _19 = move ((_14 as Continue).0: grep::grep_searcher::Searcher);
        _49 = const true;
        _13 = move _19;
        _20 = SearchWorkerBuilder::new() -> [return: bb14, unwind: bb44];
    }

    bb13: {
        _18 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<SearchWorker<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _18) -> [return: bb52, unwind: bb46];
    }

    bb14: {
        _28 = &mut _20;
        _30 = const "json";
        _29 = args::ArgMatches::is_present(_3, _30) -> [return: bb15, unwind: bb40];
    }

    bb15: {
        _27 = SearchWorkerBuilder::json_stats(move _28, move _29) -> [return: bb16, unwind: bb40];
    }

    bb16: {
        _31 = args::ArgMatches::preprocessor(_3) -> [return: bb17, unwind: bb40];
    }

    bb17: {
        _26 = SearchWorkerBuilder::preprocessor(_27, move _31) -> [return: bb18, unwind: bb40];
    }

    bb18: {
        _25 = <std::result::Result<&mut SearchWorkerBuilder, Box<dyn std::error::Error>> as Try>::branch(move _26) -> [return: bb19, unwind: bb40];
    }

    bb19: {
        _32 = discriminant(_25);
        switchInt(move _32) -> [0: bb20, 1: bb21, otherwise: bb7];
    }

    bb20: {
        _34 = move ((_25 as Continue).0: &mut search::SearchWorkerBuilder);
        _36 = args::ArgMatches::preprocessor_globs(_3) -> [return: bb22, unwind: bb40];
    }

    bb21: {
        _33 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<SearchWorker<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _33) -> [return: bb53, unwind: bb40];
    }

    bb22: {
        _35 = <std::result::Result<Override, Box<dyn std::error::Error>> as Try>::branch(move _36) -> [return: bb23, unwind: bb40];
    }

    bb23: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb24, 1: bb25, otherwise: bb7];
    }

    bb24: {
        _39 = move ((_35 as Continue).0: ignore::overrides::Override);
        _24 = SearchWorkerBuilder::preprocessor_globs(_34, move _39) -> [return: bb26, unwind: bb40];
    }

    bb25: {
        _38 = move ((_35 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<SearchWorker<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _38) -> [return: bb54, unwind: bb40];
    }

    bb26: {
        _41 = const "search-zip";
        _40 = args::ArgMatches::is_present(_3, _41) -> [return: bb27, unwind: bb40];
    }

    bb27: {
        _23 = SearchWorkerBuilder::search_zip(_24, move _40) -> [return: bb28, unwind: bb40];
    }

    bb28: {
        _42 = args::ArgMatches::binary_detection_implicit(_3) -> [return: bb29, unwind: bb40];
    }

    bb29: {
        _22 = SearchWorkerBuilder::binary_detection_implicit(_23, move _42) -> [return: bb30, unwind: bb40];
    }

    bb30: {
        _43 = args::ArgMatches::binary_detection_explicit(_3) -> [return: bb31, unwind: bb40];
    }

    bb31: {
        _21 = SearchWorkerBuilder::binary_detection_explicit(_22, move _43) -> [return: bb32, unwind: bb40];
    }

    bb32: {
        _45 = &_20;
        _51 = const false;
        _46 = move _4;
        _49 = const false;
        _47 = move _13;
        _50 = const false;
        _48 = move _6;
        _44 = SearchWorkerBuilder::build::<W>(move _45, move _46, move _47, move _48) -> [return: bb33, unwind: bb40];
    }

    bb33: {
        _0 = std::result::Result::<SearchWorker<W>, Box<dyn std::error::Error>>::Ok(move _44);
        drop(_20) -> [return: bb34, unwind: bb44];
    }

    bb34: {
        _49 = const false;
        _50 = const false;
        _51 = const false;
        goto -> bb39;
    }

    bb35: {
        drop(_13) -> [return: bb36, unwind: bb46];
    }

    bb36: {
        _49 = const false;
        drop(_6) -> [return: bb37, unwind: bb48];
    }

    bb37: {
        _50 = const false;
        drop(_4) -> [return: bb38, unwind: bb50];
    }

    bb38: {
        _51 = const false;
        goto -> bb39;
    }

    bb39: {
        return;
    }

    bb40 (cleanup): {
        drop(_20) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        resume;
    }

    bb42: {
        drop(_20) -> [return: bb35, unwind: bb44];
    }

    bb43 (cleanup): {
        drop(_13) -> [return: bb46, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        switchInt(_49) -> [0: bb46, otherwise: bb43];
    }

    bb45 (cleanup): {
        drop(_6) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb46 (cleanup): {
        switchInt(_50) -> [0: bb48, otherwise: bb45];
    }

    bb47 (cleanup): {
        drop(_4) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_51) -> [0: bb50, otherwise: bb47];
    }

    bb49 (cleanup): {
        drop(_2) -> [return: bb41, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        switchInt(_52) -> [0: bb41, otherwise: bb49];
    }

    bb51: {
        goto -> bb37;
    }

    bb52: {
        goto -> bb36;
    }

    bb53: {
        goto -> bb42;
    }

    bb54: {
        goto -> bb42;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::stats(_1: &args::Args) -> std::result::Result<Option<Stats>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<grep::grep_printer::Stats>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::option::Option<grep::grep_printer::Stats>;
    let mut _3: bool;
    let mut _4: &args::Command;
    let _5: args::Command;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::Command>;
    let mut _7: std::result::Result<args::Command, std::boxed::Box<dyn std::error::Error>>;
    let mut _8: isize;
    let _9: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _10: args::Command;
    let mut _11: bool;
    let _12: &args::ArgMatches;
    let mut _13: grep::grep_printer::Stats;
    scope 1 {
        debug residual => _9;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _10;
        scope 4 {
        }
    }

    bb0: {
        _7 = args::Args::command(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = <std::result::Result<args::Command, Box<dyn std::error::Error>> as Try>::branch(move _7) -> [return: bb2, unwind continue];
    }

    bb2: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _10 = ((_6 as Continue).0: args::Command);
        _5 = _10;
        _4 = &_5;
        _3 = args::Command::is_search(move _4) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _9 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<Stats>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _9) -> [return: bb13, unwind continue];
    }

    bb6: {
        switchInt(move _3) -> [0: bb11, otherwise: bb14];
    }

    bb7: {
        _11 = args::ArgMatches::stats(_12) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _11) -> [0: bb11, otherwise: bb9];
    }

    bb9: {
        _13 = Stats::new() -> [return: bb10, unwind continue];
    }

    bb10: {
        _2 = Option::<Stats>::Some(move _13);
        goto -> bb12;
    }

    bb11: {
        _2 = Option::<Stats>::None;
        goto -> bb12;
    }

    bb12: {
        _0 = std::result::Result::<Option<Stats>, Box<dyn std::error::Error>>::Ok(move _2);
        goto -> bb13;
    }

    bb13: {
        return;
    }

    bb14: {
        _12 = args::Args::matches(_1) -> [return: bb7, unwind continue];
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::subject_builder(_1: &args::Args) -> SubjectBuilder {
    debug self => _1;
    let mut _0: subject::SubjectBuilder;
    let mut _2: subject::SubjectBuilder;
    let _3: &mut subject::SubjectBuilder;
    let mut _4: &mut subject::SubjectBuilder;
    let mut _5: bool;
    scope 1 {
        debug builder => _2;
    }

    bb0: {
        _2 = SubjectBuilder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _2;
        _5 = args::Args::using_default_path(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = SubjectBuilder::strip_dot_prefix(move _4, move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = move _2;
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::stdout(_1: &args::Args) -> grep::grep_cli::StandardStream {
    debug self => _1;
    let mut _0: grep::grep_cli::StandardStream;
    let _2: termcolor::ColorChoice;
    let _3: &args::ArgMatches;
    let mut _4: bool;
    let _5: &args::ArgMatches;
    let _6: &str;
    let mut _7: bool;
    let _8: &args::ArgMatches;
    let _9: &str;
    scope 1 {
        debug color => _2;
    }

    bb0: {
        _3 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = args::ArgMatches::color_choice(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = args::Args::matches(_1) -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = const "line-buffered";
        _4 = args::ArgMatches::is_present(_5, _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = stdout_buffered_line(_2) -> [return: bb11, unwind continue];
    }

    bb6: {
        _8 = args::Args::matches(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = const "block-buffered";
        _7 = args::ArgMatches::is_present(_8, _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _7) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = stdout_buffered_block(_2) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = grep::grep_cli::stdout(_2) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::type_defs(_1: &args::Args) -> std::result::Result<Vec<FileTypeDef>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<ignore::types::FileTypeDef>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::vec::Vec<ignore::types::FileTypeDef>;
    let _3: &[ignore::types::FileTypeDef];
    let mut _4: &ignore::types::Types;
    let _5: ignore::types::Types;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::types::Types>;
    let mut _7: std::result::Result<ignore::types::Types, std::boxed::Box<dyn std::error::Error>>;
    let _8: &args::ArgMatches;
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _11: ignore::types::Types;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }

    bb0: {
        _8 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = args::ArgMatches::types(_8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = <std::result::Result<ignore::types::Types, Box<dyn std::error::Error>> as Try>::branch(move _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = discriminant(_6);
        switchInt(move _9) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _11 = move ((_6 as Continue).0: ignore::types::Types);
        _5 = move _11;
        _4 = &_5;
        _3 = ignore::types::Types::definitions(move _4) -> [return: bb7, unwind: bb10];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _10 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Vec<FileTypeDef>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb7: {
        _2 = slice::<impl [FileTypeDef]>::to_vec(_3) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _0 = std::result::Result::<Vec<FileTypeDef>, Box<dyn std::error::Error>>::Ok(move _2);
        drop(_5) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_5) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::walker(_1: &args::Args) -> std::result::Result<Walk, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<ignore::Walk, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: ignore::Walk;
    let mut _3: &ignore::WalkBuilder;
    let _4: ignore::WalkBuilder;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::WalkBuilder>;
    let mut _6: std::result::Result<ignore::WalkBuilder, std::boxed::Box<dyn std::error::Error>>;
    let _7: &args::ArgMatches;
    let _8: &[std::path::PathBuf];
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _11: ignore::WalkBuilder;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }

    bb0: {
        _7 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = args::Args::paths(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = args::ArgMatches::walker_builder(_7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_5);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_5 as Continue).0: ignore::WalkBuilder);
        _4 = move _11;
        _3 = &_4;
        _2 = WalkBuilder::build(move _3) -> [return: bb8, unwind: bb10];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Walk, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = std::result::Result::<Walk, Box<dyn std::error::Error>>::Ok(move _2);
        drop(_4) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_4) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:218:1: 218:10>::walker_parallel(_1: &args::Args) -> std::result::Result<WalkParallel, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<ignore::WalkParallel, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: ignore::WalkParallel;
    let mut _3: &ignore::WalkBuilder;
    let _4: ignore::WalkBuilder;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::WalkBuilder>;
    let mut _6: std::result::Result<ignore::WalkBuilder, std::boxed::Box<dyn std::error::Error>>;
    let _7: &args::ArgMatches;
    let _8: &[std::path::PathBuf];
    let mut _9: isize;
    let _10: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _11: ignore::WalkBuilder;
    scope 1 {
        debug residual => _10;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _11;
        scope 4 {
        }
    }

    bb0: {
        _7 = args::Args::matches(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = args::Args::paths(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = args::ArgMatches::walker_builder(_7, _8) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _9 = discriminant(_5);
        switchInt(move _9) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _11 = move ((_5 as Continue).0: ignore::WalkBuilder);
        _4 = move _11;
        _3 = &_4;
        _2 = WalkBuilder::build_parallel(move _3) -> [return: bb8, unwind: bb10];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _10 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkParallel, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _10) -> [return: bb9, unwind continue];
    }

    bb8: {
        _0 = std::result::Result::<WalkParallel, Box<dyn std::error::Error>>::Ok(move _2);
        drop(_4) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_4) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:357:10: 357:15>::clone(_1: &args::ArgMatches) -> args::ArgMatches {
    debug self => _1;
    let mut _0: args::ArgMatches;
    let mut _2: clap::ArgMatches<'_>;
    let _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _2 = <clap::ArgMatches<'_> as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = args::ArgMatches(move _2);
        return;
    }
}

fn args::<impl at crates/core/args.rs:357:17: 357:22>::fmt(_1: &args::ArgMatches, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&clap::ArgMatches<'_>;
    let _6: &clap::ArgMatches<'_>;

    bb0: {
        _3 = const "ArgMatches";
        _6 = &((*_1).0: clap::ArgMatches<'_>);
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:362:10: 362:15>::clone(_1: &OutputKind) -> OutputKind {
    debug self => _1;
    let mut _0: args::OutputKind;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn args::<impl at crates/core/args.rs:362:23: 362:28>::fmt(_1: &OutputKind, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _7 = const "JSON";
        _3 = _7;
        goto -> bb5;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "Standard";
        _3 = _5;
        goto -> bb5;
    }

    bb4: {
        _6 = const "Summary";
        _3 = _6;
        goto -> bb5;
    }

    bb5: {
        _0 = std::fmt::Formatter::<'_>::write_str(_2, move _3) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:362:30: 362:32>::assert_receiver_is_total_eq(_1: &OutputKind) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:362:34: 362:43>::eq(_1: &OutputKind, _2: &OutputKind) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn args::<impl at crates/core/args.rs:373:10: 373:15>::clone(_1: &SortBy) -> SortBy {
    debug self => _1;
    let mut _0: args::SortBy;
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn args::<impl at crates/core/args.rs:373:23: 373:28>::fmt(_1: &SortBy, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &bool;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&args::SortByKind;
    let _10: &args::SortByKind;

    bb0: {
        _3 = const "SortBy";
        _4 = const "reverse";
        _6 = &((*_1).0: bool);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "kind";
        _10 = &((*_1).1: args::SortByKind);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:373:30: 373:32>::assert_receiver_is_total_eq(_1: &SortBy) -> () {
    debug self => _1;
    let mut _0: ();
    scope 1 {
        scope 2 {
        }
    }

    bb0: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:373:34: 373:43>::eq(_1: &SortBy, _2: &SortBy) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: &args::SortByKind;
    let mut _7: &args::SortByKind;

    bb0: {
        _4 = ((*_1).0: bool);
        _5 = ((*_2).0: bool);
        _3 = Eq(move _4, move _5);
        switchInt(move _3) -> [0: bb2, otherwise: bb1];
    }

    bb1: {
        _6 = &((*_1).1: args::SortByKind);
        _7 = &((*_2).1: args::SortByKind);
        _0 = <SortByKind as PartialEq>::eq(move _6, move _7) -> [return: bb3, unwind continue];
    }

    bb2: {
        _0 = const false;
        goto -> bb3;
    }

    bb3: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:381:10: 381:15>::clone(_1: &SortByKind) -> SortByKind {
    debug self => _1;
    let mut _0: args::SortByKind;

    bb0: {
        _0 = (*_1);
        return;
    }
}

fn args::<impl at crates/core/args.rs:381:23: 381:28>::fmt(_1: &SortByKind, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: &str;
    let mut _4: isize;
    let _5: &str;
    let _6: &str;
    let _7: &str;
    let _8: &str;
    let _9: &str;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb4, 2: bb5, 3: bb6, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = const "Created";
        _3 = _9;
        goto -> bb7;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _5 = const "None";
        _3 = _5;
        goto -> bb7;
    }

    bb4: {
        _6 = const "Path";
        _3 = _6;
        goto -> bb7;
    }

    bb5: {
        _7 = const "LastModified";
        _3 = _7;
        goto -> bb7;
    }

    bb6: {
        _8 = const "LastAccessed";
        _3 = _8;
        goto -> bb7;
    }

    bb7: {
        _0 = std::fmt::Formatter::<'_>::write_str(_2, move _3) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:381:30: 381:32>::assert_receiver_is_total_eq(_1: &SortByKind) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:381:34: 381:43>::eq(_1: &SortByKind, _2: &SortByKind) -> bool {
    debug self => _1;
    debug other => _2;
    let mut _0: bool;
    let _3: isize;
    scope 1 {
        debug __self_tag => _3;
        let _4: isize;
        scope 2 {
            debug __arg1_tag => _4;
        }
    }

    bb0: {
        _3 = discriminant((*_1));
        _4 = discriminant((*_2));
        _0 = Eq(_3, _4);
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::asc(_1: SortByKind) -> SortBy {
    debug kind => _1;
    let mut _0: args::SortBy;

    bb0: {
        _0 = SortBy { reverse: const false, kind: _1 };
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::desc(_1: SortByKind) -> SortBy {
    debug kind => _1;
    let mut _0: args::SortBy;

    bb0: {
        _0 = SortBy { reverse: const true, kind: _1 };
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::none() -> SortBy {
    let mut _0: args::SortBy;
    let mut _1: args::SortByKind;

    bb0: {
        _1 = SortByKind::None;
        _0 = SortBy::asc(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::check(_1: &SortBy) -> std::result::Result<(), Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<(), std::boxed::Box<dyn std::error::Error>>;
    let mut _2: isize;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::time::SystemTime>;
    let mut _4: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _5: &std::fs::Metadata;
    let _6: std::fs::Metadata;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _8: std::result::Result<std::fs::Metadata, std::io::Error>;
    let _9: &std::path::Path;
    let mut _10: &std::path::PathBuf;
    let _11: std::path::PathBuf;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::path::PathBuf>;
    let mut _13: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _14: isize;
    let _15: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _16: std::path::PathBuf;
    let mut _17: isize;
    let _18: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _19: std::fs::Metadata;
    let mut _20: isize;
    let _21: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _22: std::time::SystemTime;
    let mut _23: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::time::SystemTime>;
    let mut _24: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _25: &std::fs::Metadata;
    let _26: std::fs::Metadata;
    let mut _27: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _28: std::result::Result<std::fs::Metadata, std::io::Error>;
    let _29: &std::path::Path;
    let mut _30: &std::path::PathBuf;
    let _31: std::path::PathBuf;
    let mut _32: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::path::PathBuf>;
    let mut _33: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _34: isize;
    let _35: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _36: std::path::PathBuf;
    let mut _37: isize;
    let _38: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _39: std::fs::Metadata;
    let mut _40: isize;
    let _41: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _42: std::time::SystemTime;
    let mut _43: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::time::SystemTime>;
    let mut _44: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _45: &std::fs::Metadata;
    let _46: std::fs::Metadata;
    let mut _47: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::Metadata>;
    let mut _48: std::result::Result<std::fs::Metadata, std::io::Error>;
    let _49: &std::path::Path;
    let mut _50: &std::path::PathBuf;
    let _51: std::path::PathBuf;
    let mut _52: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::path::PathBuf>;
    let mut _53: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _54: isize;
    let _55: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _56: std::path::PathBuf;
    let mut _57: isize;
    let _58: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _59: std::fs::Metadata;
    let mut _60: isize;
    let _61: std::result::Result<std::convert::Infallible, std::io::Error>;
    let _62: std::time::SystemTime;
    scope 1 {
        debug residual => _15;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _16;
        scope 4 {
        }
    }
    scope 5 {
        debug residual => _18;
        scope 6 {
        }
    }
    scope 7 {
        debug val => _19;
        scope 8 {
        }
    }
    scope 9 {
        debug residual => _21;
        scope 10 {
        }
    }
    scope 11 {
        debug val => _22;
        scope 12 {
        }
    }
    scope 13 {
        debug residual => _35;
        scope 14 {
        }
    }
    scope 15 {
        debug val => _36;
        scope 16 {
        }
    }
    scope 17 {
        debug residual => _38;
        scope 18 {
        }
    }
    scope 19 {
        debug val => _39;
        scope 20 {
        }
    }
    scope 21 {
        debug residual => _41;
        scope 22 {
        }
    }
    scope 23 {
        debug val => _42;
        scope 24 {
        }
    }
    scope 25 {
        debug residual => _55;
        scope 26 {
        }
    }
    scope 27 {
        debug val => _56;
        scope 28 {
        }
    }
    scope 29 {
        debug residual => _58;
        scope 30 {
        }
    }
    scope 31 {
        debug val => _59;
        scope 32 {
        }
    }
    scope 33 {
        debug residual => _61;
        scope 34 {
        }
    }
    scope 35 {
        debug val => _62;
        scope 36 {
        }
    }

    bb0: {
        _2 = discriminant(((*_1).1: args::SortByKind));
        switchInt(move _2) -> [0: bb44, 1: bb44, 2: bb3, 3: bb17, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _53 = current_exe() -> [return: bb31, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _13 = current_exe() -> [return: bb4, unwind continue];
    }

    bb4: {
        _12 = <std::result::Result<PathBuf, std::io::Error> as Try>::branch(move _13) -> [return: bb5, unwind continue];
    }

    bb5: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb6, 1: bb7, otherwise: bb2];
    }

    bb6: {
        _16 = move ((_12 as Continue).0: std::path::PathBuf);
        _11 = move _16;
        _10 = &_11;
        _9 = <PathBuf as Deref>::deref(move _10) -> [return: bb8, unwind: bb51];
    }

    bb7: {
        _15 = move ((_12 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _15) -> [return: bb48, unwind continue];
    }

    bb8: {
        _8 = Path::metadata(_9) -> [return: bb9, unwind: bb51];
    }

    bb9: {
        _7 = <std::result::Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _8) -> [return: bb10, unwind: bb51];
    }

    bb10: {
        _17 = discriminant(_7);
        switchInt(move _17) -> [0: bb11, 1: bb12, otherwise: bb2];
    }

    bb11: {
        _19 = move ((_7 as Continue).0: std::fs::Metadata);
        _6 = move _19;
        _5 = &_6;
        _4 = std::fs::Metadata::modified(move _5) -> [return: bb13, unwind: bb51];
    }

    bb12: {
        _18 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _18) -> [return: bb53, unwind: bb51];
    }

    bb13: {
        _3 = <std::result::Result<SystemTime, std::io::Error> as Try>::branch(move _4) -> [return: bb14, unwind: bb51];
    }

    bb14: {
        _20 = discriminant(_3);
        switchInt(move _20) -> [0: bb15, 1: bb16, otherwise: bb2];
    }

    bb15: {
        _22 = ((_3 as Continue).0: std::time::SystemTime);
        drop(_11) -> [return: bb44, unwind continue];
    }

    bb16: {
        _21 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _21) -> [return: bb54, unwind: bb51];
    }

    bb17: {
        _33 = current_exe() -> [return: bb18, unwind continue];
    }

    bb18: {
        _32 = <std::result::Result<PathBuf, std::io::Error> as Try>::branch(move _33) -> [return: bb19, unwind continue];
    }

    bb19: {
        _34 = discriminant(_32);
        switchInt(move _34) -> [0: bb20, 1: bb21, otherwise: bb2];
    }

    bb20: {
        _36 = move ((_32 as Continue).0: std::path::PathBuf);
        _31 = move _36;
        _30 = &_31;
        _29 = <PathBuf as Deref>::deref(move _30) -> [return: bb22, unwind: bb50];
    }

    bb21: {
        _35 = move ((_32 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _35) -> [return: bb48, unwind continue];
    }

    bb22: {
        _28 = Path::metadata(_29) -> [return: bb23, unwind: bb50];
    }

    bb23: {
        _27 = <std::result::Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _28) -> [return: bb24, unwind: bb50];
    }

    bb24: {
        _37 = discriminant(_27);
        switchInt(move _37) -> [0: bb25, 1: bb26, otherwise: bb2];
    }

    bb25: {
        _39 = move ((_27 as Continue).0: std::fs::Metadata);
        _26 = move _39;
        _25 = &_26;
        _24 = std::fs::Metadata::accessed(move _25) -> [return: bb27, unwind: bb50];
    }

    bb26: {
        _38 = move ((_27 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _38) -> [return: bb55, unwind: bb50];
    }

    bb27: {
        _23 = <std::result::Result<SystemTime, std::io::Error> as Try>::branch(move _24) -> [return: bb28, unwind: bb50];
    }

    bb28: {
        _40 = discriminant(_23);
        switchInt(move _40) -> [0: bb29, 1: bb30, otherwise: bb2];
    }

    bb29: {
        _42 = ((_23 as Continue).0: std::time::SystemTime);
        drop(_31) -> [return: bb44, unwind continue];
    }

    bb30: {
        _41 = move ((_23 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _41) -> [return: bb56, unwind: bb50];
    }

    bb31: {
        _52 = <std::result::Result<PathBuf, std::io::Error> as Try>::branch(move _53) -> [return: bb32, unwind continue];
    }

    bb32: {
        _54 = discriminant(_52);
        switchInt(move _54) -> [0: bb33, 1: bb34, otherwise: bb2];
    }

    bb33: {
        _56 = move ((_52 as Continue).0: std::path::PathBuf);
        _51 = move _56;
        _50 = &_51;
        _49 = <PathBuf as Deref>::deref(move _50) -> [return: bb35, unwind: bb49];
    }

    bb34: {
        _55 = move ((_52 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _55) -> [return: bb48, unwind continue];
    }

    bb35: {
        _48 = Path::metadata(_49) -> [return: bb36, unwind: bb49];
    }

    bb36: {
        _47 = <std::result::Result<std::fs::Metadata, std::io::Error> as Try>::branch(move _48) -> [return: bb37, unwind: bb49];
    }

    bb37: {
        _57 = discriminant(_47);
        switchInt(move _57) -> [0: bb38, 1: bb39, otherwise: bb2];
    }

    bb38: {
        _59 = move ((_47 as Continue).0: std::fs::Metadata);
        _46 = move _59;
        _45 = &_46;
        _44 = std::fs::Metadata::created(move _45) -> [return: bb40, unwind: bb49];
    }

    bb39: {
        _58 = move ((_47 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _58) -> [return: bb57, unwind: bb49];
    }

    bb40: {
        _43 = <std::result::Result<SystemTime, std::io::Error> as Try>::branch(move _44) -> [return: bb41, unwind: bb49];
    }

    bb41: {
        _60 = discriminant(_43);
        switchInt(move _60) -> [0: bb42, 1: bb43, otherwise: bb2];
    }

    bb42: {
        _62 = ((_43 as Continue).0: std::time::SystemTime);
        drop(_51) -> [return: bb44, unwind continue];
    }

    bb43: {
        _61 = move ((_43 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _61) -> [return: bb58, unwind: bb49];
    }

    bb44: {
        _0 = std::result::Result::<(), Box<dyn std::error::Error>>::Ok(const ());
        goto -> bb48;
    }

    bb45: {
        drop(_51) -> [return: bb48, unwind continue];
    }

    bb46: {
        drop(_31) -> [return: bb48, unwind continue];
    }

    bb47: {
        drop(_11) -> [return: bb48, unwind continue];
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_51) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_31) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_11) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        resume;
    }

    bb53: {
        goto -> bb47;
    }

    bb54: {
        goto -> bb47;
    }

    bb55: {
        goto -> bb46;
    }

    bb56: {
        goto -> bb46;
    }

    bb57: {
        goto -> bb45;
    }

    bb58: {
        goto -> bb45;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder(_1: SortBy, _2: &mut WalkBuilder) -> () {
    debug self => _1;
    debug builder => _2;
    let mut _0: ();
    let mut _3: isize;
    let mut _4: bool;
    let _5: &mut ignore::WalkBuilder;
    let _6: &mut ignore::WalkBuilder;
    let _7: &mut ignore::WalkBuilder;
    let mut _8: {closure@crates/core/args.rs:443:43: 443:54};
    let _9: &mut ignore::WalkBuilder;
    let mut _10: {closure@crates/core/args.rs:450:43: 450:54};
    let _11: &mut ignore::WalkBuilder;
    let mut _12: {closure@crates/core/args.rs:457:43: 457:54};

    bb0: {
        _3 = discriminant((_1.1: args::SortByKind));
        switchInt(move _3) -> [0: bb8, 1: bb3, 2: bb6, 3: bb7, 4: bb1, otherwise: bb2];
    }

    bb1: {
        _12 = {closure@crates/core/args.rs:457:43: 457:54} { self: _1 };
        _11 = WalkBuilder::sort_by_file_path::<{closure@crates/core/args.rs:457:43: 457:54}>(_2, move _12) -> [return: bb8, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = (_1.0: bool);
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _5 = WalkBuilder::sort_by_file_name::<{closure@crates/core/args.rs:437:47: 437:53}>(_2, const ZeroSized: {closure@crates/core/args.rs:437:47: 437:53}) -> [return: bb8, unwind continue];
    }

    bb5: {
        _6 = WalkBuilder::sort_by_file_name::<{closure@crates/core/args.rs:439:47: 439:53}>(_2, const ZeroSized: {closure@crates/core/args.rs:439:47: 439:53}) -> [return: bb8, unwind continue];
    }

    bb6: {
        _8 = {closure@crates/core/args.rs:443:43: 443:54} { self: _1 };
        _7 = WalkBuilder::sort_by_file_path::<{closure@crates/core/args.rs:443:43: 443:54}>(_2, move _8) -> [return: bb8, unwind continue];
    }

    bb7: {
        _10 = {closure@crates/core/args.rs:450:43: 450:54} { self: _1 };
        _9 = WalkBuilder::sort_by_file_path::<{closure@crates/core/args.rs:450:43: 450:54}>(_2, move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#0}(_1: &{closure@crates/core/args.rs:437:47: 437:53}, _2: &OsStr, _3: &OsStr) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    let mut _0: std::cmp::Ordering;
    let mut _4: std::cmp::Ordering;

    bb0: {
        _4 = <OsStr as Ord>::cmp(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = std::cmp::Ordering::reverse(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#1}(_1: &{closure@crates/core/args.rs:439:47: 439:53}, _2: &OsStr, _3: &OsStr) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    let mut _0: std::cmp::Ordering;

    bb0: {
        _0 = <OsStr as Ord>::cmp(_2, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#2}(_1: &{closure@crates/core/args.rs:443:43: 443:54}, _2: &Path, _3: &Path) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    debug self => ((*_1).0: args::SortBy);
    let mut _0: std::cmp::Ordering;
    let mut _4: bool;

    bb0: {
        _4 = (((*_1).0: args::SortBy).0: bool);
        _0 = sort_by_metadata_time::<{closure@crates/core/args.rs:444:63: 444:67}>(_2, _3, move _4, const ZeroSized: {closure@crates/core/args.rs:444:63: 444:67}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#2}::{closure#0}(_1: &{closure@crates/core/args.rs:444:63: 444:67}, _2: &std::fs::Metadata) -> std::result::Result<SystemTime, std::io::Error> {
    debug md => _2;
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;

    bb0: {
        _0 = std::fs::Metadata::modified(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#3}(_1: &{closure@crates/core/args.rs:450:43: 450:54}, _2: &Path, _3: &Path) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    debug self => ((*_1).0: args::SortBy);
    let mut _0: std::cmp::Ordering;
    let mut _4: bool;

    bb0: {
        _4 = (((*_1).0: args::SortBy).0: bool);
        _0 = sort_by_metadata_time::<{closure@crates/core/args.rs:451:63: 451:67}>(_2, _3, move _4, const ZeroSized: {closure@crates/core/args.rs:451:63: 451:67}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#3}::{closure#0}(_1: &{closure@crates/core/args.rs:451:63: 451:67}, _2: &std::fs::Metadata) -> std::result::Result<SystemTime, std::io::Error> {
    debug md => _2;
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;

    bb0: {
        _0 = std::fs::Metadata::accessed(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#4}(_1: &{closure@crates/core/args.rs:457:43: 457:54}, _2: &Path, _3: &Path) -> std::cmp::Ordering {
    debug a => _2;
    debug b => _3;
    debug self => ((*_1).0: args::SortBy);
    let mut _0: std::cmp::Ordering;
    let mut _4: bool;

    bb0: {
        _4 = (((*_1).0: args::SortBy).0: bool);
        _0 = sort_by_metadata_time::<{closure@crates/core/args.rs:458:63: 458:67}>(_2, _3, move _4, const ZeroSized: {closure@crates/core/args.rs:458:63: 458:67}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:395:1: 395:12>::configure_walk_builder::{closure#4}::{closure#0}(_1: &{closure@crates/core/args.rs:458:63: 458:67}, _2: &std::fs::Metadata) -> std::result::Result<SystemTime, std::io::Error> {
    debug md => _2;
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;

    bb0: {
        _0 = std::fs::Metadata::created(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:467:1: 467:16>::new(_1: &str) -> SortByKind {
    debug kind => _1;
    let mut _0: args::SortByKind;
    let mut _2: bool;
    let mut _3: bool;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;

    bb0: {
        _6 = <str as PartialEq>::eq(_1, const "none") -> [return: bb15, unwind continue];
    }

    bb1: {
        _0 = SortByKind::None;
        goto -> bb16;
    }

    bb2: {
        _5 = <str as PartialEq>::eq(_1, const "path") -> [return: bb14, unwind continue];
    }

    bb3: {
        _0 = SortByKind::Path;
        goto -> bb16;
    }

    bb4: {
        _4 = <str as PartialEq>::eq(_1, const "modified") -> [return: bb13, unwind continue];
    }

    bb5: {
        _0 = SortByKind::LastModified;
        goto -> bb16;
    }

    bb6: {
        _3 = <str as PartialEq>::eq(_1, const "accessed") -> [return: bb12, unwind continue];
    }

    bb7: {
        _0 = SortByKind::LastAccessed;
        goto -> bb16;
    }

    bb8: {
        _2 = <str as PartialEq>::eq(_1, const "created") -> [return: bb11, unwind continue];
    }

    bb9: {
        _0 = SortByKind::Created;
        goto -> bb16;
    }

    bb10: {
        _0 = SortByKind::None;
        goto -> bb16;
    }

    bb11: {
        switchInt(move _2) -> [0: bb10, otherwise: bb9];
    }

    bb12: {
        switchInt(move _3) -> [0: bb8, otherwise: bb7];
    }

    bb13: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb14: {
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb15: {
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb16: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:481:10: 481:15>::clone(_1: &EncodingMode) -> EncodingMode {
    debug self => _1;
    let mut _0: args::EncodingMode;
    let mut _2: isize;
    let _3: &grep::grep_searcher::Encoding;
    let mut _4: grep::grep_searcher::Encoding;
    scope 1 {
        debug __self_0 => _3;
    }

    bb0: {
        _2 = discriminant((*_1));
        switchInt(move _2) -> [0: bb3, 1: bb5, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = EncodingMode::Disabled;
        goto -> bb6;
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _3 = &(((*_1) as Some).0: grep::grep_searcher::Encoding);
        _4 = <Encoding as Clone>::clone(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = EncodingMode::Some(move _4);
        goto -> bb6;
    }

    bb5: {
        _0 = EncodingMode::Auto;
        goto -> bb6;
    }

    bb6: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:481:17: 481:22>::fmt(_1: &EncodingMode, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &grep::grep_searcher::Encoding;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&grep::grep_searcher::Encoding;
    let _8: &str;
    let _9: &str;
    scope 1 {
        debug __self_0 => _4;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _9 = const "Disabled";
        _0 = std::fmt::Formatter::<'_>::write_str(_2, _9) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Some).0: grep::grep_searcher::Encoding);
        _5 = const "Some";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _8 = const "Auto";
        _0 = std::fmt::Formatter::<'_>::write_str(_2, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:511:1: 511:16>::new(_1: clap::ArgMatches<'_>) -> args::ArgMatches {
    debug clap_matches => _1;
    let mut _0: args::ArgMatches;

    bb0: {
        _0 = args::ArgMatches(move _1);
        return;
    }
}

fn args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure(_1: args::ArgMatches) -> std::result::Result<args::ArgMatches, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<args::ArgMatches, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let mut _3: &args::ArgMatches;
    let _4: &str;
    let _5: log::Level;
    let mut _6: bool;
    let mut _7: &log::Level;
    let mut _8: bool;
    let mut _9: &log::Level;
    let mut _10: &log::LevelFilter;
    let _11: log::LevelFilter;
    let _12: ();
    let mut _13: std::fmt::Arguments<'_>;
    let mut _14: &[&str];
    let mut _15: log::Level;
    let mut _16: args::ArgMatches;
    let mut _17: std::vec::Vec<std::ffi::OsString>;
    let mut _18: bool;
    let mut _19: &std::vec::Vec<std::ffi::OsString>;
    let mut _20: args::ArgMatches;
    let mut _22: std::option::Option<std::ffi::OsString>;
    let mut _23: &mut std::env::ArgsOs;
    let mut _24: isize;
    let _26: ();
    let mut _27: &mut std::vec::Vec<std::ffi::OsString>;
    let _28: ();
    let mut _29: &mut std::vec::Vec<std::ffi::OsString>;
    let mut _30: std::env::ArgsOs;
    let mut _32: bool;
    let mut _33: &log::Level;
    let mut _34: bool;
    let mut _35: &log::Level;
    let mut _36: &log::LevelFilter;
    let _37: log::LevelFilter;
    let _38: ();
    let mut _39: std::fmt::Arguments<'_>;
    let mut _40: &[&str];
    let mut _41: &[core::fmt::rt::Argument<'_>];
    let _42: &[core::fmt::rt::Argument<'_>; 1];
    let _43: [core::fmt::rt::Argument<'_>; 1];
    let mut _44: core::fmt::rt::Argument<'_>;
    let _45: &std::vec::Vec<std::ffi::OsString>;
    let mut _46: log::Level;
    let mut _47: args::ArgMatches;
    let mut _48: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, clap::ArgMatches<'_>>;
    let mut _49: std::result::Result<clap::ArgMatches<'_>, std::boxed::Box<dyn std::error::Error>>;
    let mut _50: std::vec::Vec<std::ffi::OsString>;
    let mut _51: isize;
    let mut _60: bool;
    let mut _61: bool;
    let mut _62: bool;
    let mut _63: bool;
    let mut _64: isize;
    scope 1 {
        debug lvl => _5;
        let mut _54: &(&str, &str, &str, u32);
        let mut _55: &[&str; 1];
        let mut _56: &log::LevelFilter;
    }
    scope 2 {
        debug args => _17;
        let mut _21: std::env::ArgsOs;
        scope 3 {
            debug cliargs => _21;
            let _31: log::Level;
            let _52: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _53: clap::ArgMatches<'_>;
            scope 4 {
                debug bin => _25;
                let _25: std::ffi::OsString;
            }
            scope 5 {
                debug lvl => _31;
                let mut _57: &(&str, &str, &str, u32);
                let mut _58: &[&str; 1];
                let mut _59: &log::LevelFilter;
            }
            scope 6 {
                debug residual => _52;
                scope 7 {
                }
            }
            scope 8 {
                debug val => _53;
                scope 9 {
                }
            }
        }
    }

    bb0: {
        _61 = const false;
        _63 = const false;
        _62 = const false;
        _60 = const false;
        _61 = const true;
        _3 = &_1;
        _4 = const "no-config";
        _2 = args::ArgMatches::is_present(move _3, _4) -> [return: bb1, unwind: bb47];
    }

    bb1: {
        switchInt(move _2) -> [0: bb10, otherwise: bb2];
    }

    bb2: {
        _5 = log::Level::Debug;
        _7 = &_5;
        _56 = const _;
        _6 = <Level as PartialOrd<LevelFilter>>::le(move _7, _56) -> [return: bb3, unwind: bb47];
    }

    bb3: {
        switchInt(move _6) -> [0: bb9, otherwise: bb4];
    }

    bb4: {
        _9 = &_5;
        _11 = max_level() -> [return: bb5, unwind: bb47];
    }

    bb5: {
        _10 = &_11;
        _8 = <Level as PartialOrd<LevelFilter>>::le(move _9, move _10) -> [return: bb6, unwind: bb47];
    }

    bb6: {
        switchInt(move _8) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _55 = const _;
        _14 = _55 as &[&str] (PointerCoercion(Unsize));
        _13 = Arguments::<'_>::new_const(move _14) -> [return: bb8, unwind: bb47];
    }

    bb8: {
        _15 = _5;
        _54 = const _;
        _12 = __private_api_log(move _13, move _15, _54) -> [return: bb48, unwind: bb47];
    }

    bb9: {
        _61 = const false;
        _16 = move _1;
        _0 = std::result::Result::<args::ArgMatches, Box<dyn std::error::Error>>::Ok(move _16);
        goto -> bb41;
    }

    bb10: {
        _17 = config::args() -> [return: bb11, unwind: bb47];
    }

    bb11: {
        _63 = const true;
        _19 = &_17;
        _18 = Vec::<OsString>::is_empty(move _19) -> [return: bb12, unwind: bb45];
    }

    bb12: {
        switchInt(move _18) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _61 = const false;
        _20 = move _1;
        _0 = std::result::Result::<args::ArgMatches, Box<dyn std::error::Error>>::Ok(move _20);
        drop(_17) -> [return: bb33, unwind: bb47];
    }

    bb14: {
        _21 = args_os() -> [return: bb15, unwind: bb45];
    }

    bb15: {
        _62 = const true;
        _23 = &mut _21;
        _22 = <ArgsOs as Iterator>::next(move _23) -> [return: bb16, unwind: bb43];
    }

    bb16: {
        _60 = const true;
        _24 = discriminant(_22);
        switchInt(move _24) -> [1: bb17, otherwise: bb39];
    }

    bb17: {
        _60 = const false;
        _25 = move ((_22 as Some).0: std::ffi::OsString);
        _27 = &mut _17;
        _26 = Vec::<OsString>::insert(move _27, const 0_usize, move _25) -> [return: bb49, unwind: bb43];
    }

    bb18: {
        _31 = log::Level::Debug;
        _33 = &_31;
        _59 = const _;
        _32 = <Level as PartialOrd<LevelFilter>>::le(move _33, _59) -> [return: bb19, unwind: bb43];
    }

    bb19: {
        switchInt(move _32) -> [0: bb26, otherwise: bb20];
    }

    bb20: {
        _35 = &_31;
        _37 = max_level() -> [return: bb21, unwind: bb43];
    }

    bb21: {
        _36 = &_37;
        _34 = <Level as PartialOrd<LevelFilter>>::le(move _35, move _36) -> [return: bb22, unwind: bb43];
    }

    bb22: {
        switchInt(move _34) -> [0: bb26, otherwise: bb23];
    }

    bb23: {
        _58 = const _;
        _40 = _58 as &[&str] (PointerCoercion(Unsize));
        _45 = &_17;
        _44 = core::fmt::rt::Argument::<'_>::new_debug::<Vec<OsString>>(_45) -> [return: bb24, unwind: bb43];
    }

    bb24: {
        _43 = [move _44];
        _42 = &_43;
        _41 = _42 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = Arguments::<'_>::new_v1(move _40, move _41) -> [return: bb25, unwind: bb43];
    }

    bb25: {
        _46 = _31;
        _57 = const _;
        _38 = __private_api_log(move _39, move _46, _57) -> [return: bb50, unwind: bb43];
    }

    bb26: {
        _63 = const false;
        _50 = move _17;
        _49 = clap_matches::<Vec<OsString>, OsString>(move _50) -> [return: bb27, unwind: bb43];
    }

    bb27: {
        _48 = <std::result::Result<clap::ArgMatches<'_>, Box<dyn std::error::Error>> as Try>::branch(move _49) -> [return: bb28, unwind: bb43];
    }

    bb28: {
        _51 = discriminant(_48);
        switchInt(move _51) -> [0: bb29, 1: bb31, otherwise: bb30];
    }

    bb29: {
        _53 = move ((_48 as Continue).0: clap::ArgMatches<'_>);
        _47 = args::ArgMatches(move _53);
        _0 = std::result::Result::<args::ArgMatches, Box<dyn std::error::Error>>::Ok(move _47);
        _62 = const false;
        _63 = const false;
        drop(_1) -> [return: bb34, unwind continue];
    }

    bb30: {
        unreachable;
    }

    bb31: {
        _52 = move ((_48 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::ArgMatches, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _52) -> [return: bb32, unwind: bb47];
    }

    bb32: {
        _62 = const false;
        _63 = const false;
        goto -> bb41;
    }

    bb33: {
        _63 = const false;
        goto -> bb41;
    }

    bb34: {
        return;
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        _60 = const false;
        _29 = &mut _17;
        _62 = const false;
        _30 = move _21;
        _28 = <Vec<OsString> as Extend<OsString>>::extend::<ArgsOs>(move _29, move _30) -> [return: bb18, unwind: bb43];
    }

    bb37: {
        switchInt(_60) -> [0: bb36, otherwise: bb38];
    }

    bb38: {
        drop(((_22 as Some).0: std::ffi::OsString)) -> [return: bb36, unwind: bb43];
    }

    bb39: {
        _64 = discriminant(_22);
        switchInt(move _64) -> [1: bb37, otherwise: bb36];
    }

    bb40: {
        drop(_1) -> [return: bb34, unwind continue];
    }

    bb41: {
        switchInt(_61) -> [0: bb34, otherwise: bb40];
    }

    bb42 (cleanup): {
        drop(_21) -> [return: bb45, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        switchInt(_62) -> [0: bb45, otherwise: bb42];
    }

    bb44 (cleanup): {
        drop(_17) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_63) -> [0: bb47, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_1) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_61) -> [0: bb35, otherwise: bb46];
    }

    bb48: {
        goto -> bb9;
    }

    bb49: {
        goto -> bb39;
    }

    bb50: {
        goto -> bb26;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::args";
        _2 = &(*_3);
        _1 = (move _2, const "rg::args", const "crates/core/args.rs", const 527_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "not reading config files because --no-config is present"];
        _0 = &_1;
        return;
    }
}

promoted[2] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::args";
        _2 = &(*_3);
        _1 = (move _2, const "rg::args", const "crates/core/args.rs", const 543_u32);
        _0 = &_1;
        return;
    }
}

promoted[4] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "final argv: "];
        _0 = &_1;
        return;
    }
}

promoted[5] in args::<impl at crates/core/args.rs:511:1: 511:16>::reconfigure: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:511:1: 511:16>::to_args(_1: args::ArgMatches) -> std::result::Result<args::Args, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<args::Args, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::vec::Vec<std::string::String>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::vec::Vec<std::string::String>>;
    let mut _4: std::result::Result<std::vec::Vec<std::string::String>, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: &args::ArgMatches;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _8: std::vec::Vec<std::string::String>;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, search::PatternMatcher>;
    let mut _11: std::result::Result<search::PatternMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _12: &args::ArgMatches;
    let _13: &[std::string::String];
    let _14: &std::vec::Vec<std::string::String>;
    let mut _15: isize;
    let mut _19: &args::ArgMatches;
    let mut _21: bool;
    let mut _22: &std::vec::Vec<std::path::PathBuf>;
    let _23: ();
    let mut _24: &mut std::vec::Vec<std::path::PathBuf>;
    let mut _25: std::path::PathBuf;
    let mut _26: &args::ArgMatches;
    let mut _27: args::Args;
    let mut _28: std::sync::Arc<args::ArgsImp>;
    let mut _29: args::ArgsImp;
    let mut _30: args::ArgMatches;
    let mut _31: std::vec::Vec<std::string::String>;
    let mut _32: search::PatternMatcher;
    let mut _33: std::vec::Vec<std::path::PathBuf>;
    let mut _34: bool;
    let mut _35: bool;
    let mut _36: bool;
    let mut _37: bool;
    let mut _38: bool;
    scope 1 {
        debug patterns => _2;
        let _9: search::PatternMatcher;
        let _16: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _17: search::PatternMatcher;
        scope 6 {
            debug matcher => _9;
            let mut _18: std::vec::Vec<std::path::PathBuf>;
            scope 11 {
                debug paths => _18;
                let _20: bool;
                scope 12 {
                    debug using_default_path => _20;
                }
            }
        }
        scope 7 {
            debug residual => _16;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _17;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _38 = const false;
        _37 = const false;
        _36 = const false;
        _35 = const false;
        _38 = const true;
        _5 = &_1;
        _4 = args::ArgMatches::patterns(move _5) -> [return: bb1, unwind: bb30];
    }

    bb1: {
        _3 = <std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind: bb30];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_3 as Continue).0: std::vec::Vec<std::string::String>);
        _37 = const true;
        _2 = move _8;
        _12 = &_1;
        _14 = &_2;
        _13 = <Vec<std::string::String> as Deref>::deref(_14) -> [return: bb6, unwind: bb28];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::Args, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _7) -> [return: bb31, unwind: bb30];
    }

    bb6: {
        _11 = args::ArgMatches::matcher(move _12, _13) -> [return: bb7, unwind: bb28];
    }

    bb7: {
        _10 = <std::result::Result<PatternMatcher, Box<dyn std::error::Error>> as Try>::branch(move _11) -> [return: bb8, unwind: bb28];
    }

    bb8: {
        _15 = discriminant(_10);
        switchInt(move _15) -> [0: bb9, 1: bb10, otherwise: bb4];
    }

    bb9: {
        _17 = move ((_10 as Continue).0: search::PatternMatcher);
        _36 = const true;
        _9 = move _17;
        _19 = &_1;
        _18 = args::ArgMatches::paths(move _19) -> [return: bb12, unwind: bb26];
    }

    bb10: {
        _16 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<args::Args, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _16) -> [return: bb11, unwind: bb28];
    }

    bb11: {
        _36 = const false;
        drop(_2) -> [return: bb20, unwind: bb30];
    }

    bb12: {
        _35 = const true;
        _22 = &_18;
        _21 = Vec::<PathBuf>::is_empty(move _22) -> [return: bb13, unwind: bb24];
    }

    bb13: {
        switchInt(move _21) -> [0: bb17, otherwise: bb14];
    }

    bb14: {
        _24 = &mut _18;
        _26 = &_1;
        _25 = args::ArgMatches::path_default(move _26) -> [return: bb15, unwind: bb24];
    }

    bb15: {
        _23 = Vec::<PathBuf>::push(move _24, move _25) -> [return: bb16, unwind: bb24];
    }

    bb16: {
        _20 = const true;
        goto -> bb18;
    }

    bb17: {
        _20 = const false;
        goto -> bb18;
    }

    bb18: {
        _38 = const false;
        _30 = move _1;
        _37 = const false;
        _31 = move _2;
        _36 = const false;
        _32 = move _9;
        _35 = const false;
        _33 = move _18;
        _34 = _20;
        _29 = ArgsImp { matches: move _30, patterns: move _31, matcher: move _32, paths: move _33, using_default_path: move _34 };
        _28 = Arc::<ArgsImp>::new(move _29) -> [return: bb19, unwind: bb24];
    }

    bb19: {
        _27 = args::Args(move _28);
        _0 = std::result::Result::<args::Args, Box<dyn std::error::Error>>::Ok(move _27);
        _35 = const false;
        _36 = const false;
        _37 = const false;
        goto -> bb21;
    }

    bb20: {
        _37 = const false;
        drop(_1) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        resume;
    }

    bb23 (cleanup): {
        drop(_18) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        switchInt(_35) -> [0: bb26, otherwise: bb23];
    }

    bb25 (cleanup): {
        drop(_9) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        switchInt(_36) -> [0: bb28, otherwise: bb25];
    }

    bb27 (cleanup): {
        drop(_2) -> [return: bb30, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        switchInt(_37) -> [0: bb30, otherwise: bb27];
    }

    bb29 (cleanup): {
        drop(_1) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb30 (cleanup): {
        switchInt(_38) -> [0: bb22, otherwise: bb29];
    }

    bb31: {
        goto -> bb20;
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::matcher(_1: &args::ArgMatches, _2: &[std::string::String]) -> std::result::Result<PatternMatcher, Box<dyn std::error::Error>> {
    debug self => _1;
    debug patterns => _2;
    let mut _0: std::result::Result<search::PatternMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: bool;
    let _4: &str;
    let _5: &str;
    let mut _6: bool;
    let _7: &str;
    let _8: &str;
    let _9: std::string::String;
    let mut _10: std::option::Option<std::string::String>;
    let _11: &str;
    let _12: &str;
    let _13: &std::string::String;
    scope 1 {
        debug engine => _9;
    }

    bb0: {
        _4 = const "pcre2";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = const "pcre2";
        _0 = args::ArgMatches::matcher_engine(_1, _5, _2) -> [return: bb11, unwind continue];
    }

    bb3: {
        _7 = const "auto-hybrid-regex";
        _6 = args::ArgMatches::is_present(_1, _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _6) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _8 = const "auto";
        _0 = args::ArgMatches::matcher_engine(_1, _8, _2) -> [return: bb11, unwind continue];
    }

    bb6: {
        _11 = const "engine";
        _10 = args::ArgMatches::value_of_lossy(_1, _11) -> [return: bb7, unwind continue];
    }

    bb7: {
        _9 = Option::<std::string::String>::unwrap(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        _13 = &_9;
        _12 = <std::string::String as Deref>::deref(_13) -> [return: bb9, unwind: bb12];
    }

    bb9: {
        _0 = args::ArgMatches::matcher_engine(_1, _12, _2) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_9) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_9) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine(_1: &args::ArgMatches, _2: &str, _3: &[std::string::String]) -> std::result::Result<PatternMatcher, Box<dyn std::error::Error>> {
    debug self => _1;
    debug engine => _2;
    debug patterns => _3;
    let mut _0: std::result::Result<search::PatternMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: bool;
    let mut _5: bool;
    let mut _6: bool;
    let mut _7: std::result::Result<grep::grep_regex::RegexMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _8: isize;
    let _9: grep::grep_regex::RegexMatcher;
    let _10: std::boxed::Box<dyn std::error::Error>;
    let mut _11: std::boxed::Box<dyn std::error::Error>;
    let mut _12: std::string::String;
    let mut _13: std::string::String;
    let mut _14: &std::boxed::Box<dyn std::error::Error>;
    let mut _15: search::PatternMatcher;
    let mut _16: std::boxed::Box<dyn std::error::Error>;
    let _17: std::boxed::Box<dyn std::error::Error>;
    let mut _18: std::result::Result<grep::grep_regex::RegexMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _19: isize;
    let _20: grep::grep_regex::RegexMatcher;
    let mut _21: search::PatternMatcher;
    let _22: std::boxed::Box<dyn std::error::Error>;
    let mut _24: bool;
    let mut _25: &log::Level;
    let mut _26: bool;
    let mut _27: &log::Level;
    let mut _28: &log::LevelFilter;
    let _29: log::LevelFilter;
    let _30: ();
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 1];
    let _35: [core::fmt::rt::Argument<'_>; 1];
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &std::boxed::Box<dyn std::error::Error>;
    let mut _38: log::Level;
    let mut _40: std::result::Result<search::PatternMatcher, std::boxed::Box<dyn std::error::Error>>;
    let _41: &str;
    let mut _42: isize;
    let mut _45: std::boxed::Box<dyn std::error::Error>;
    let mut _46: std::string::String;
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 4];
    let _52: [core::fmt::rt::Argument<'_>; 4];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &std::string::String;
    let _55: std::string::String;
    let _56: &str;
    let mut _57: core::fmt::rt::Argument<'_>;
    let _58: &std::boxed::Box<dyn std::error::Error>;
    let mut _59: core::fmt::rt::Argument<'_>;
    let _60: &std::string::String;
    let _61: std::string::String;
    let _62: &str;
    let mut _63: core::fmt::rt::Argument<'_>;
    let _64: &std::boxed::Box<dyn std::error::Error>;
    let mut _65: std::boxed::Box<dyn std::error::Error>;
    let _66: std::string::String;
    let mut _67: std::fmt::Arguments<'_>;
    let mut _68: &[&str];
    let mut _69: &[core::fmt::rt::Argument<'_>];
    let _70: &[core::fmt::rt::Argument<'_>; 1];
    let _71: [core::fmt::rt::Argument<'_>; 1];
    let mut _72: core::fmt::rt::Argument<'_>;
    let _73: &&str;
    let mut _74: &[&str; 2];
    scope 1 {
        debug matcher => _9;
    }
    scope 2 {
        debug matcher => _9;
    }
    scope 3 {
        debug err => _10;
    }
    scope 4 {
        debug rust_err => _17;
        let _23: log::Level;
        let _39: std::boxed::Box<dyn std::error::Error>;
        let _43: search::PatternMatcher;
        let _44: std::boxed::Box<dyn std::error::Error>;
        scope 7 {
            debug lvl => _23;
            let mut _76: &(&str, &str, &str, u32);
            let mut _77: &[&str; 1];
            let mut _78: &log::LevelFilter;
        }
        scope 8 {
            debug pcre_err => _39;
            let _47: std::string::String;
            let mut _75: &[&str; 4];
            scope 11 {
                debug res => _47;
            }
        }
        scope 9 {
            debug matcher => _43;
        }
        scope 10 {
            debug err => _44;
        }
    }
    scope 5 {
        debug matcher => _20;
    }
    scope 6 {
        debug err => _22;
    }
    scope 12 {
        debug res => _66;
    }

    bb0: {
        _6 = <str as PartialEq>::eq(_2, const "default") -> [return: bb9, unwind continue];
    }

    bb1: {
        _7 = args::ArgMatches::matcher_rust(_1, _3) -> [return: bb10, unwind continue];
    }

    bb2: {
        _5 = <str as PartialEq>::eq(_2, const "pcre2") -> [return: bb8, unwind continue];
    }

    bb3: {
        _16 = <Box<dyn std::error::Error> as From<&str>>::from(const "PCRE2 is not available in this build of ripgrep") -> [return: bb17, unwind continue];
    }

    bb4: {
        _4 = <str as PartialEq>::eq(_2, const "auto") -> [return: bb7, unwind continue];
    }

    bb5: {
        _18 = args::ArgMatches::matcher_rust(_1, _3) -> [return: bb18, unwind continue];
    }

    bb6: {
        _74 = const _;
        _68 = _74 as &[&str] (PointerCoercion(Unsize));
        _73 = &_2;
        _72 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_73) -> [return: bb44, unwind continue];
    }

    bb7: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb8: {
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb9: {
        switchInt(move _6) -> [0: bb2, otherwise: bb1];
    }

    bb10: {
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb13, 1: bb11, otherwise: bb12];
    }

    bb11: {
        _10 = move ((_7 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _14 = &_10;
        _13 = <Box<dyn std::error::Error> as ToString>::to_string(move _14) -> [return: bb14, unwind: bb55];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _9 = move ((_7 as Ok).0: grep::grep_regex::RegexMatcher);
        _15 = PatternMatcher::RustRegex(move _9);
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Ok(move _15);
        goto -> bb48;
    }

    bb14: {
        _12 = args::suggest(move _13) -> [return: bb15, unwind: bb55];
    }

    bb15: {
        _11 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _12) -> [return: bb16, unwind: bb55];
    }

    bb16: {
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Err(move _11);
        drop(_10) -> [return: bb48, unwind continue];
    }

    bb17: {
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Err(move _16);
        goto -> bb48;
    }

    bb18: {
        _19 = discriminant(_18);
        switchInt(move _19) -> [0: bb20, 1: bb19, otherwise: bb12];
    }

    bb19: {
        _22 = move ((_18 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _17 = move _22;
        _23 = log::Level::Debug;
        _25 = &_23;
        _78 = const _;
        _24 = <Level as PartialOrd<LevelFilter>>::le(move _25, _78) -> [return: bb21, unwind: bb54];
    }

    bb20: {
        _20 = move ((_18 as Ok).0: grep::grep_regex::RegexMatcher);
        _21 = PatternMatcher::RustRegex(move _20);
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Ok(move _21);
        goto -> bb48;
    }

    bb21: {
        switchInt(move _24) -> [0: bb28, otherwise: bb22];
    }

    bb22: {
        _27 = &_23;
        _29 = max_level() -> [return: bb23, unwind: bb54];
    }

    bb23: {
        _28 = &_29;
        _26 = <Level as PartialOrd<LevelFilter>>::le(move _27, move _28) -> [return: bb24, unwind: bb54];
    }

    bb24: {
        switchInt(move _26) -> [0: bb28, otherwise: bb25];
    }

    bb25: {
        _77 = const _;
        _32 = _77 as &[&str] (PointerCoercion(Unsize));
        _37 = &_17;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_37) -> [return: bb26, unwind: bb54];
    }

    bb26: {
        _35 = [move _36];
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb27, unwind: bb54];
    }

    bb27: {
        _38 = _23;
        _76 = const _;
        _30 = __private_api_log(move _31, move _38, _76) -> [return: bb57, unwind: bb54];
    }

    bb28: {
        _41 = const "pcre2";
        _40 = args::ArgMatches::matcher_engine(_1, _41, _3) -> [return: bb29, unwind: bb54];
    }

    bb29: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb31, 1: bb30, otherwise: bb12];
    }

    bb30: {
        _44 = move ((_40 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _39 = move _44;
        _75 = const _;
        _49 = _75 as &[&str] (PointerCoercion(Unsize));
        _56 = const "~";
        _55 = str::<impl str>::repeat(_56, const 79_usize) -> [return: bb32, unwind: bb53];
    }

    bb31: {
        _43 = move ((_40 as Ok).0: search::PatternMatcher);
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Ok(move _43);
        drop(_17) -> [return: bb48, unwind continue];
    }

    bb32: {
        _54 = &_55;
        _53 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_54) -> [return: bb33, unwind: bb52];
    }

    bb33: {
        _58 = &_17;
        _57 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_58) -> [return: bb34, unwind: bb52];
    }

    bb34: {
        _62 = const "~";
        _61 = str::<impl str>::repeat(_62, const 79_usize) -> [return: bb35, unwind: bb52];
    }

    bb35: {
        _60 = &_61;
        _59 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_60) -> [return: bb36, unwind: bb51];
    }

    bb36: {
        _64 = &_39;
        _63 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_64) -> [return: bb37, unwind: bb51];
    }

    bb37: {
        _52 = [move _53, move _57, move _59, move _63];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb38, unwind: bb51];
    }

    bb38: {
        _47 = format(move _48) -> [return: bb39, unwind: bb51];
    }

    bb39: {
        drop(_61) -> [return: bb40, unwind: bb49];
    }

    bb40: {
        drop(_55) -> [return: bb41, unwind: bb50];
    }

    bb41: {
        _46 = move _47;
        _45 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _46) -> [return: bb42, unwind: bb53];
    }

    bb42: {
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Err(move _45);
        drop(_39) -> [return: bb43, unwind: bb54];
    }

    bb43: {
        drop(_17) -> [return: bb48, unwind continue];
    }

    bb44: {
        _71 = [move _72];
        _70 = &_71;
        _69 = _70 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _67 = Arguments::<'_>::new_v1(move _68, move _69) -> [return: bb45, unwind continue];
    }

    bb45: {
        _66 = format(move _67) -> [return: bb46, unwind continue];
    }

    bb46: {
        _65 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _66) -> [return: bb47, unwind continue];
    }

    bb47: {
        _0 = std::result::Result::<PatternMatcher, Box<dyn std::error::Error>>::Err(move _65);
        goto -> bb48;
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_55) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_47) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_61) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_55) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_39) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_17) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_10) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        resume;
    }

    bb57: {
        goto -> bb28;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "unrecognized regex engine '", const "'"];
        _0 = &_1;
        return;
    }
}

promoted[1] in args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "regex could not be compiled with either the default regex engine or with PCRE2.\n\ndefault regex engine error:\n", const "\n", const "\n", const "\n\nPCRE2 regex engine error:\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::args";
        _2 = &(*_3);
        _1 = (move _2, const "rg::args", const "crates/core/args.rs", const 626_u32);
        _0 = &_1;
        return;
    }
}

promoted[3] in args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "error building Rust regex in hybrid mode:\n"];
        _0 = &_1;
        return;
    }
}

promoted[4] in args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_engine: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::matcher_rust(_1: &args::ArgMatches, _2: &[std::string::String]) -> std::result::Result<RegexMatcher, Box<dyn std::error::Error>> {
    debug self => _1;
    debug patterns => _2;
    let mut _0: std::result::Result<grep::grep_regex::RegexMatcher, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: grep::grep_regex::RegexMatcherBuilder;
    let _4: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _5: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _6: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _7: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _8: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _9: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _10: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let mut _14: bool;
    let _15: &str;
    let mut _16: bool;
    let _17: &str;
    let _18: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _19: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _20: bool;
    let _21: &str;
    let mut _22: bool;
    let _23: &str;
    let _24: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _25: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _26: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _27: std::option::Option<u8>;
    let _28: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _29: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _30: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _31: std::option::Option<u8>;
    let mut _32: bool;
    let _33: &str;
    let _34: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _35: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _36: bool;
    let _37: &str;
    let _38: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _39: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _40: std::option::Option<u8>;
    let mut _41: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _42: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _43: isize;
    let mut _46: isize;
    let _48: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _49: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _50: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _51: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _52: isize;
    let mut _55: isize;
    let _57: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _58: &mut grep::grep_regex::RegexMatcherBuilder;
    let mut _60: bool;
    let _61: &str;
    let mut _62: &grep::grep_regex::RegexMatcherBuilder;
    let mut _63: &grep::grep_regex::RegexMatcherBuilder;
    let _64: &str;
    let _65: &std::string::String;
    let _66: std::string::String;
    let _67: &str;
    let mut _68: isize;
    let mut _71: std::boxed::Box<dyn std::error::Error>;
    let mut _72: std::string::String;
    let mut _73: std::string::String;
    let mut _74: &grep::grep_regex::Error;
    scope 1 {
        debug builder => _3;
        let _59: std::result::Result<grep::grep_regex::RegexMatcher, grep::grep_regex::Error>;
        scope 2 {
            debug limit => _47;
            let _44: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _45: std::option::Option<usize>;
            let _47: usize;
            scope 3 {
                debug residual => _44;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _45;
                scope 6 {
                }
            }
        }
        scope 7 {
            debug limit => _56;
            let _53: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _54: std::option::Option<usize>;
            let _56: usize;
            scope 8 {
                debug residual => _53;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _54;
                scope 11 {
                }
            }
        }
        scope 12 {
            debug res => _59;
            let _69: grep::grep_regex::RegexMatcher;
            let _70: grep::grep_regex::Error;
            scope 13 {
                debug m => _69;
            }
            scope 14 {
                debug err => _70;
            }
        }
    }

    bb0: {
        _3 = RegexMatcherBuilder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _10 = &mut _3;
        _11 = args::ArgMatches::case_smart(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _9 = RegexMatcherBuilder::case_smart(move _10, move _11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _12 = args::ArgMatches::case_insensitive(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = RegexMatcherBuilder::case_insensitive(_9, move _12) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = RegexMatcherBuilder::multi_line(_8, const true) -> [return: bb6, unwind continue];
    }

    bb6: {
        _13 = args::ArgMatches::unicode(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = RegexMatcherBuilder::unicode(_7, move _13) -> [return: bb8, unwind continue];
    }

    bb8: {
        _5 = RegexMatcherBuilder::octal(_6, const false) -> [return: bb9, unwind continue];
    }

    bb9: {
        _15 = const "word-regexp";
        _14 = args::ArgMatches::is_present(_1, _15) -> [return: bb10, unwind continue];
    }

    bb10: {
        _4 = RegexMatcherBuilder::word(_5, move _14) -> [return: bb11, unwind continue];
    }

    bb11: {
        _17 = const "multiline";
        _16 = args::ArgMatches::is_present(_1, _17) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _16) -> [0: bb19, otherwise: bb13];
    }

    bb13: {
        _19 = &mut _3;
        _21 = const "multiline-dotall";
        _20 = args::ArgMatches::is_present(_1, _21) -> [return: bb14, unwind continue];
    }

    bb14: {
        _18 = RegexMatcherBuilder::dot_matches_new_line(move _19, move _20) -> [return: bb15, unwind continue];
    }

    bb15: {
        _23 = const "crlf";
        _22 = args::ArgMatches::is_present(_1, _23) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _22) -> [0: bb27, otherwise: bb17];
    }

    bb17: {
        _26 = &mut _3;
        _25 = RegexMatcherBuilder::crlf(move _26, const true) -> [return: bb18, unwind continue];
    }

    bb18: {
        _27 = Option::<u8>::None;
        _24 = RegexMatcherBuilder::line_terminator(_25, move _27) -> [return: bb27, unwind continue];
    }

    bb19: {
        _30 = &mut _3;
        _31 = Option::<u8>::Some(const 10_u8);
        _29 = RegexMatcherBuilder::line_terminator(move _30, move _31) -> [return: bb20, unwind continue];
    }

    bb20: {
        _28 = RegexMatcherBuilder::dot_matches_new_line(_29, const false) -> [return: bb21, unwind continue];
    }

    bb21: {
        _33 = const "crlf";
        _32 = args::ArgMatches::is_present(_1, _33) -> [return: bb22, unwind continue];
    }

    bb22: {
        switchInt(move _32) -> [0: bb24, otherwise: bb23];
    }

    bb23: {
        _35 = &mut _3;
        _34 = RegexMatcherBuilder::crlf(move _35, const true) -> [return: bb24, unwind continue];
    }

    bb24: {
        _37 = const "null-data";
        _36 = args::ArgMatches::is_present(_1, _37) -> [return: bb25, unwind continue];
    }

    bb25: {
        switchInt(move _36) -> [0: bb27, otherwise: bb26];
    }

    bb26: {
        _39 = &mut _3;
        _40 = Option::<u8>::Some(const 0_u8);
        _38 = RegexMatcherBuilder::line_terminator(move _39, move _40) -> [return: bb27, unwind continue];
    }

    bb27: {
        _42 = args::ArgMatches::regex_size_limit(_1) -> [return: bb28, unwind continue];
    }

    bb28: {
        _41 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _42) -> [return: bb29, unwind continue];
    }

    bb29: {
        _43 = discriminant(_41);
        switchInt(move _43) -> [0: bb30, 1: bb32, otherwise: bb31];
    }

    bb30: {
        _45 = ((_41 as Continue).0: std::option::Option<usize>);
        _46 = discriminant(_45);
        switchInt(move _46) -> [1: bb33, otherwise: bb55];
    }

    bb31: {
        unreachable;
    }

    bb32: {
        _44 = move ((_41 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<RegexMatcher, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _44) -> [return: bb51, unwind continue];
    }

    bb33: {
        _47 = ((_45 as Some).0: usize);
        _49 = &mut _3;
        _48 = RegexMatcherBuilder::size_limit(move _49, _47) -> [return: bb55, unwind continue];
    }

    bb34: {
        _50 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _51) -> [return: bb35, unwind continue];
    }

    bb35: {
        _52 = discriminant(_50);
        switchInt(move _52) -> [0: bb36, 1: bb37, otherwise: bb31];
    }

    bb36: {
        _54 = ((_50 as Continue).0: std::option::Option<usize>);
        _55 = discriminant(_54);
        switchInt(move _55) -> [1: bb38, otherwise: bb56];
    }

    bb37: {
        _53 = move ((_50 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<RegexMatcher, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _53) -> [return: bb51, unwind continue];
    }

    bb38: {
        _56 = ((_54 as Some).0: usize);
        _58 = &mut _3;
        _57 = RegexMatcherBuilder::dfa_size_limit(move _58, _56) -> [return: bb56, unwind continue];
    }

    bb39: {
        switchInt(move _60) -> [0: bb41, otherwise: bb40];
    }

    bb40: {
        _62 = &_3;
        _59 = RegexMatcherBuilder::build_literals::<std::string::String>(move _62, _2) -> [return: bb45, unwind continue];
    }

    bb41: {
        _63 = &_3;
        _67 = const "|";
        _66 = slice::<impl [std::string::String]>::join::<&str>(_2, _67) -> [return: bb42, unwind continue];
    }

    bb42: {
        _65 = &_66;
        _64 = <std::string::String as Deref>::deref(_65) -> [return: bb43, unwind: bb53];
    }

    bb43: {
        _59 = RegexMatcherBuilder::build(move _63, _64) -> [return: bb44, unwind: bb53];
    }

    bb44: {
        drop(_66) -> [return: bb45, unwind continue];
    }

    bb45: {
        _68 = discriminant(_59);
        switchInt(move _68) -> [0: bb47, 1: bb46, otherwise: bb31];
    }

    bb46: {
        _70 = move ((_59 as Err).0: grep::grep_regex::Error);
        _74 = &_70;
        _73 = <grep::grep_regex::Error as ToString>::to_string(move _74) -> [return: bb48, unwind: bb52];
    }

    bb47: {
        _69 = move ((_59 as Ok).0: grep::grep_regex::RegexMatcher);
        _0 = std::result::Result::<RegexMatcher, Box<dyn std::error::Error>>::Ok(move _69);
        goto -> bb51;
    }

    bb48: {
        _72 = suggest_multiline(move _73) -> [return: bb49, unwind: bb52];
    }

    bb49: {
        _71 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _72) -> [return: bb50, unwind: bb52];
    }

    bb50: {
        _0 = std::result::Result::<RegexMatcher, Box<dyn std::error::Error>>::Err(move _71);
        drop(_70) -> [return: bb51, unwind continue];
    }

    bb51: {
        return;
    }

    bb52 (cleanup): {
        drop(_70) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_66) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        resume;
    }

    bb55: {
        _51 = args::ArgMatches::dfa_size_limit(_1) -> [return: bb34, unwind continue];
    }

    bb56: {
        _61 = const "fixed-strings";
        _60 = args::ArgMatches::is_present(_1, _61) -> [return: bb39, unwind continue];
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::printer_json(_1: &args::ArgMatches, _2: W) -> std::result::Result<JSON<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug wtr => _2;
    let mut _0: std::result::Result<grep::grep_printer::JSON<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: grep::grep_printer::JSONBuilder;
    let _4: &mut grep::grep_printer::JSONBuilder;
    let mut _5: &mut grep::grep_printer::JSONBuilder;
    let mut _6: &mut grep::grep_printer::JSONBuilder;
    let mut _7: &mut grep::grep_printer::JSONBuilder;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _9: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _10: isize;
    let mut _13: grep::grep_printer::JSON<W>;
    let mut _14: &grep::grep_printer::JSONBuilder;
    let mut _15: W;
    let mut _16: bool;
    scope 1 {
        debug builder => _3;
        let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _12: std::option::Option<u64>;
        scope 2 {
            debug residual => _11;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _12;
            scope 5 {
            }
        }
    }

    bb0: {
        _16 = const false;
        _16 = const true;
        _3 = JSONBuilder::new() -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _7 = &mut _3;
        _6 = JSONBuilder::pretty(move _7, const false) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _9 = args::ArgMatches::max_count(_1) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _8 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _9) -> [return: bb4, unwind: bb15];
    }

    bb4: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _12 = ((_8 as Continue).0: std::option::Option<u64>);
        _5 = JSONBuilder::max_matches(_6, _12) -> [return: bb9, unwind: bb15];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<JSON<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb8, unwind: bb15];
    }

    bb8: {
        drop(_2) -> [return: bb12, unwind continue];
    }

    bb9: {
        _4 = JSONBuilder::always_begin_end(_5, const false) -> [return: bb10, unwind: bb15];
    }

    bb10: {
        _14 = &_3;
        _16 = const false;
        _15 = move _2;
        _13 = JSONBuilder::build::<W>(move _14, move _15) -> [return: bb11, unwind: bb15];
    }

    bb11: {
        _0 = std::result::Result::<JSON<W>, Box<dyn std::error::Error>>::Ok(move _13);
        goto -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        resume;
    }

    bb14 (cleanup): {
        drop(_2) -> [return: bb13, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        switchInt(_16) -> [0: bb13, otherwise: bb14];
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::printer_standard(_1: &args::ArgMatches, _2: &[PathBuf], _3: W, _4: bool) -> std::result::Result<Standard<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug paths => _2;
    debug wtr => _3;
    debug separator_search => _4;
    let mut _0: std::result::Result<grep::grep_printer::Standard<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: grep::grep_printer::StandardBuilder;
    let _6: &mut grep::grep_printer::StandardBuilder;
    let mut _7: &mut grep::grep_printer::StandardBuilder;
    let mut _8: &mut grep::grep_printer::StandardBuilder;
    let mut _9: &mut grep::grep_printer::StandardBuilder;
    let mut _10: &mut grep::grep_printer::StandardBuilder;
    let mut _11: &mut grep::grep_printer::StandardBuilder;
    let mut _12: &mut grep::grep_printer::StandardBuilder;
    let mut _13: &mut grep::grep_printer::StandardBuilder;
    let mut _14: &mut grep::grep_printer::StandardBuilder;
    let mut _15: &mut grep::grep_printer::StandardBuilder;
    let mut _16: &mut grep::grep_printer::StandardBuilder;
    let mut _17: &mut grep::grep_printer::StandardBuilder;
    let mut _18: &mut grep::grep_printer::StandardBuilder;
    let mut _19: &mut grep::grep_printer::StandardBuilder;
    let mut _20: &mut grep::grep_printer::StandardBuilder;
    let mut _21: &mut grep::grep_printer::StandardBuilder;
    let mut _22: &mut grep::grep_printer::StandardBuilder;
    let mut _23: &mut grep::grep_printer::StandardBuilder;
    let mut _24: &mut grep::grep_printer::StandardBuilder;
    let mut _25: &mut grep::grep_printer::StandardBuilder;
    let mut _26: &mut grep::grep_printer::StandardBuilder;
    let mut _27: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, grep::grep_printer::ColorSpecs>;
    let mut _28: std::result::Result<grep::grep_printer::ColorSpecs, std::boxed::Box<dyn std::error::Error>>;
    let mut _29: isize;
    let mut _32: bool;
    let mut _33: bool;
    let mut _34: bool;
    let mut _35: bool;
    let _36: &str;
    let mut _37: bool;
    let _38: &str;
    let mut _39: std::option::Option<std::vec::Vec<u8>>;
    let mut _40: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _41: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _42: isize;
    let mut _45: bool;
    let mut _46: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _47: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _48: isize;
    let mut _51: bool;
    let mut _52: bool;
    let _53: &str;
    let mut _54: bool;
    let _55: &str;
    let mut _56: std::option::Option<std::vec::Vec<u8>>;
    let mut _57: std::option::Option<std::vec::Vec<u8>>;
    let mut _58: std::vec::Vec<u8>;
    let mut _59: std::vec::Vec<u8>;
    let mut _60: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u8>>;
    let mut _61: std::result::Result<std::option::Option<u8>, std::boxed::Box<dyn std::error::Error>>;
    let mut _62: isize;
    let mut _65: std::option::Option<u8>;
    let _66: &mut grep::grep_printer::StandardBuilder;
    let mut _67: &mut grep::grep_printer::StandardBuilder;
    let mut _68: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<std::vec::Vec<u8>>>;
    let mut _69: std::result::Result<std::option::Option<std::vec::Vec<u8>>, std::boxed::Box<dyn std::error::Error>>;
    let mut _70: isize;
    let mut _73: grep::grep_printer::Standard<W>;
    let mut _74: &grep::grep_printer::StandardBuilder;
    let mut _75: W;
    let mut _76: bool;
    scope 1 {
        debug builder => _5;
        let _30: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _31: grep::grep_printer::ColorSpecs;
        let _43: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _44: std::option::Option<u64>;
        let _49: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _50: std::option::Option<u64>;
        let _63: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _64: std::option::Option<u8>;
        let _71: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _72: std::option::Option<std::vec::Vec<u8>>;
        scope 2 {
            debug residual => _30;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _31;
            scope 5 {
            }
        }
        scope 6 {
            debug residual => _43;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _44;
            scope 9 {
            }
        }
        scope 10 {
            debug residual => _49;
            scope 11 {
            }
        }
        scope 12 {
            debug val => _50;
            scope 13 {
            }
        }
        scope 14 {
            debug residual => _63;
            scope 15 {
            }
        }
        scope 16 {
            debug val => _64;
            scope 17 {
            }
        }
        scope 18 {
            debug residual => _71;
            scope 19 {
            }
        }
        scope 20 {
            debug val => _72;
            scope 21 {
            }
        }
    }

    bb0: {
        _76 = const false;
        _76 = const true;
        _5 = StandardBuilder::new() -> [return: bb1, unwind: bb66];
    }

    bb1: {
        _26 = &mut _5;
        _28 = args::ArgMatches::color_specs(_1) -> [return: bb2, unwind: bb63];
    }

    bb2: {
        _27 = <std::result::Result<ColorSpecs, Box<dyn std::error::Error>> as Try>::branch(move _28) -> [return: bb3, unwind: bb63];
    }

    bb3: {
        _29 = discriminant(_27);
        switchInt(move _29) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _31 = move ((_27 as Continue).0: grep::grep_printer::ColorSpecs);
        _25 = StandardBuilder::color_specs(move _26, move _31) -> [return: bb7, unwind: bb63];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _30 = move ((_27 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Standard<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _30) -> [return: bb67, unwind: bb63];
    }

    bb7: {
        _32 = args::ArgMatches::stats(_1) -> [return: bb8, unwind: bb63];
    }

    bb8: {
        _24 = StandardBuilder::stats(_25, move _32) -> [return: bb9, unwind: bb63];
    }

    bb9: {
        _33 = args::ArgMatches::heading(_1) -> [return: bb10, unwind: bb63];
    }

    bb10: {
        _23 = StandardBuilder::heading(_24, move _33) -> [return: bb11, unwind: bb63];
    }

    bb11: {
        _34 = args::ArgMatches::with_filename(_1, _2) -> [return: bb12, unwind: bb63];
    }

    bb12: {
        _22 = StandardBuilder::path(_23, move _34) -> [return: bb13, unwind: bb63];
    }

    bb13: {
        _36 = const "only-matching";
        _35 = args::ArgMatches::is_present(_1, _36) -> [return: bb14, unwind: bb63];
    }

    bb14: {
        _21 = StandardBuilder::only_matching(_22, move _35) -> [return: bb15, unwind: bb63];
    }

    bb15: {
        _38 = const "vimgrep";
        _37 = args::ArgMatches::is_present(_1, _38) -> [return: bb16, unwind: bb63];
    }

    bb16: {
        _20 = StandardBuilder::per_match(_21, move _37) -> [return: bb17, unwind: bb63];
    }

    bb17: {
        _19 = StandardBuilder::per_match_one_line(_20, const true) -> [return: bb18, unwind: bb63];
    }

    bb18: {
        _39 = args::ArgMatches::replacement(_1) -> [return: bb19, unwind: bb63];
    }

    bb19: {
        _18 = StandardBuilder::replacement(_19, move _39) -> [return: bb20, unwind: bb63];
    }

    bb20: {
        _41 = args::ArgMatches::max_columns(_1) -> [return: bb21, unwind: bb63];
    }

    bb21: {
        _40 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _41) -> [return: bb22, unwind: bb63];
    }

    bb22: {
        _42 = discriminant(_40);
        switchInt(move _42) -> [0: bb23, 1: bb24, otherwise: bb5];
    }

    bb23: {
        _44 = ((_40 as Continue).0: std::option::Option<u64>);
        _17 = StandardBuilder::max_columns(_18, _44) -> [return: bb25, unwind: bb63];
    }

    bb24: {
        _43 = move ((_40 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Standard<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _43) -> [return: bb68, unwind: bb63];
    }

    bb25: {
        _45 = args::ArgMatches::max_columns_preview(_1) -> [return: bb26, unwind: bb63];
    }

    bb26: {
        _16 = StandardBuilder::max_columns_preview(_17, move _45) -> [return: bb27, unwind: bb63];
    }

    bb27: {
        _47 = args::ArgMatches::max_count(_1) -> [return: bb28, unwind: bb63];
    }

    bb28: {
        _46 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _47) -> [return: bb29, unwind: bb63];
    }

    bb29: {
        _48 = discriminant(_46);
        switchInt(move _48) -> [0: bb30, 1: bb31, otherwise: bb5];
    }

    bb30: {
        _50 = ((_46 as Continue).0: std::option::Option<u64>);
        _15 = StandardBuilder::max_matches(_16, _50) -> [return: bb32, unwind: bb63];
    }

    bb31: {
        _49 = move ((_46 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Standard<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _49) -> [return: bb69, unwind: bb63];
    }

    bb32: {
        _51 = args::ArgMatches::column(_1) -> [return: bb33, unwind: bb63];
    }

    bb33: {
        _14 = StandardBuilder::column(_15, move _51) -> [return: bb34, unwind: bb63];
    }

    bb34: {
        _53 = const "byte-offset";
        _52 = args::ArgMatches::is_present(_1, _53) -> [return: bb35, unwind: bb63];
    }

    bb35: {
        _13 = StandardBuilder::byte_offset(_14, move _52) -> [return: bb36, unwind: bb63];
    }

    bb36: {
        _55 = const "trim";
        _54 = args::ArgMatches::is_present(_1, _55) -> [return: bb37, unwind: bb63];
    }

    bb37: {
        _12 = StandardBuilder::trim_ascii(_13, move _54) -> [return: bb38, unwind: bb63];
    }

    bb38: {
        _56 = Option::<Vec<u8>>::None;
        _11 = StandardBuilder::separator_search(_12, move _56) -> [return: bb39, unwind: bb63];
    }

    bb39: {
        _57 = args::ArgMatches::context_separator(_1) -> [return: bb40, unwind: bb63];
    }

    bb40: {
        _10 = StandardBuilder::separator_context(_11, move _57) -> [return: bb41, unwind: bb63];
    }

    bb41: {
        _58 = args::ArgMatches::field_match_separator(_1) -> [return: bb42, unwind: bb63];
    }

    bb42: {
        _9 = StandardBuilder::separator_field_match(_10, move _58) -> [return: bb43, unwind: bb63];
    }

    bb43: {
        _59 = args::ArgMatches::field_context_separator(_1) -> [return: bb44, unwind: bb63];
    }

    bb44: {
        _8 = StandardBuilder::separator_field_context(_9, move _59) -> [return: bb45, unwind: bb63];
    }

    bb45: {
        _61 = args::ArgMatches::path_separator(_1) -> [return: bb46, unwind: bb63];
    }

    bb46: {
        _60 = <std::result::Result<Option<u8>, Box<dyn std::error::Error>> as Try>::branch(move _61) -> [return: bb47, unwind: bb63];
    }

    bb47: {
        _62 = discriminant(_60);
        switchInt(move _62) -> [0: bb48, 1: bb49, otherwise: bb5];
    }

    bb48: {
        _64 = ((_60 as Continue).0: std::option::Option<u8>);
        _7 = StandardBuilder::separator_path(_8, _64) -> [return: bb50, unwind: bb63];
    }

    bb49: {
        _63 = move ((_60 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Standard<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _63) -> [return: bb70, unwind: bb63];
    }

    bb50: {
        _65 = args::ArgMatches::path_terminator(_1) -> [return: bb51, unwind: bb63];
    }

    bb51: {
        _6 = StandardBuilder::path_terminator(_7, move _65) -> [return: bb52, unwind: bb63];
    }

    bb52: {
        switchInt(_4) -> [0: bb58, otherwise: bb53];
    }

    bb53: {
        _67 = &mut _5;
        _69 = args::ArgMatches::file_separator(_1) -> [return: bb54, unwind: bb63];
    }

    bb54: {
        _68 = <std::result::Result<Option<Vec<u8>>, Box<dyn std::error::Error>> as Try>::branch(move _69) -> [return: bb55, unwind: bb63];
    }

    bb55: {
        _70 = discriminant(_68);
        switchInt(move _70) -> [0: bb56, 1: bb57, otherwise: bb5];
    }

    bb56: {
        _72 = move ((_68 as Continue).0: std::option::Option<std::vec::Vec<u8>>);
        _66 = StandardBuilder::separator_search(move _67, move _72) -> [return: bb71, unwind: bb63];
    }

    bb57: {
        _71 = move ((_68 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Standard<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _71) -> [return: bb72, unwind: bb63];
    }

    bb58: {
        _74 = &_5;
        _76 = const false;
        _75 = move _3;
        _73 = StandardBuilder::build::<W>(move _74, move _75) -> [return: bb59, unwind: bb63];
    }

    bb59: {
        _0 = std::result::Result::<Standard<W>, Box<dyn std::error::Error>>::Ok(move _73);
        drop(_5) -> [return: bb62, unwind: bb66];
    }

    bb60: {
        drop(_5) -> [return: bb61, unwind: bb66];
    }

    bb61: {
        drop(_3) -> [return: bb62, unwind continue];
    }

    bb62: {
        return;
    }

    bb63 (cleanup): {
        drop(_5) -> [return: bb66, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        resume;
    }

    bb65 (cleanup): {
        drop(_3) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb66 (cleanup): {
        switchInt(_76) -> [0: bb64, otherwise: bb65];
    }

    bb67: {
        goto -> bb60;
    }

    bb68: {
        goto -> bb60;
    }

    bb69: {
        goto -> bb60;
    }

    bb70: {
        goto -> bb60;
    }

    bb71: {
        goto -> bb58;
    }

    bb72: {
        goto -> bb60;
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::printer_summary(_1: &args::ArgMatches, _2: &[PathBuf], _3: W) -> std::result::Result<Summary<W>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug paths => _2;
    debug wtr => _3;
    let mut _0: std::result::Result<grep::grep_printer::Summary<W>, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: grep::grep_printer::SummaryBuilder;
    let _5: &mut grep::grep_printer::SummaryBuilder;
    let mut _6: &mut grep::grep_printer::SummaryBuilder;
    let mut _7: &mut grep::grep_printer::SummaryBuilder;
    let mut _8: &mut grep::grep_printer::SummaryBuilder;
    let mut _9: &mut grep::grep_printer::SummaryBuilder;
    let mut _10: &mut grep::grep_printer::SummaryBuilder;
    let mut _11: &mut grep::grep_printer::SummaryBuilder;
    let mut _12: &mut grep::grep_printer::SummaryBuilder;
    let mut _13: &mut grep::grep_printer::SummaryBuilder;
    let mut _14: &mut grep::grep_printer::SummaryBuilder;
    let mut _15: grep::grep_printer::SummaryKind;
    let mut _16: std::option::Option<grep::grep_printer::SummaryKind>;
    let _17: &str;
    let mut _18: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, grep::grep_printer::ColorSpecs>;
    let mut _19: std::result::Result<grep::grep_printer::ColorSpecs, std::boxed::Box<dyn std::error::Error>>;
    let mut _20: isize;
    let mut _23: bool;
    let mut _24: bool;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _26: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _27: isize;
    let mut _30: bool;
    let mut _31: bool;
    let _32: &str;
    let mut _33: std::vec::Vec<u8>;
    let mut _34: &[u8];
    let _35: &[u8; 1];
    let mut _36: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u8>>;
    let mut _37: std::result::Result<std::option::Option<u8>, std::boxed::Box<dyn std::error::Error>>;
    let mut _38: isize;
    let mut _41: std::option::Option<u8>;
    let mut _42: grep::grep_printer::Summary<W>;
    let mut _43: &grep::grep_printer::SummaryBuilder;
    let mut _44: W;
    let mut _45: bool;
    scope 1 {
        debug builder => _4;
        let _21: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _22: grep::grep_printer::ColorSpecs;
        let _28: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _29: std::option::Option<u64>;
        let _39: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _40: std::option::Option<u8>;
        scope 2 {
            debug residual => _21;
            scope 3 {
            }
        }
        scope 4 {
            debug val => _22;
            scope 5 {
            }
        }
        scope 6 {
            debug residual => _28;
            scope 7 {
            }
        }
        scope 8 {
            debug val => _29;
            scope 9 {
            }
        }
        scope 10 {
            debug residual => _39;
            scope 11 {
            }
        }
        scope 12 {
            debug val => _40;
            scope 13 {
            }
        }
    }

    bb0: {
        _45 = const false;
        _45 = const true;
        _4 = SummaryBuilder::new() -> [return: bb1, unwind: bb38];
    }

    bb1: {
        _14 = &mut _4;
        _16 = args::ArgMatches::summary_kind(_1) -> [return: bb2, unwind: bb34];
    }

    bb2: {
        _17 = const "summary format";
        _15 = Option::<SummaryKind>::expect(move _16, _17) -> [return: bb3, unwind: bb34];
    }

    bb3: {
        _13 = SummaryBuilder::kind(move _14, move _15) -> [return: bb4, unwind: bb34];
    }

    bb4: {
        _19 = args::ArgMatches::color_specs(_1) -> [return: bb5, unwind: bb34];
    }

    bb5: {
        _18 = <std::result::Result<ColorSpecs, Box<dyn std::error::Error>> as Try>::branch(move _19) -> [return: bb6, unwind: bb34];
    }

    bb6: {
        _20 = discriminant(_18);
        switchInt(move _20) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _22 = move ((_18 as Continue).0: grep::grep_printer::ColorSpecs);
        _12 = SummaryBuilder::color_specs(_13, move _22) -> [return: bb10, unwind: bb34];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _21 = move ((_18 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Summary<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _21) -> [return: bb39, unwind: bb34];
    }

    bb10: {
        _23 = args::ArgMatches::stats(_1) -> [return: bb11, unwind: bb34];
    }

    bb11: {
        _11 = SummaryBuilder::stats(_12, move _23) -> [return: bb12, unwind: bb34];
    }

    bb12: {
        _24 = args::ArgMatches::with_filename(_1, _2) -> [return: bb13, unwind: bb34];
    }

    bb13: {
        _10 = SummaryBuilder::path(_11, move _24) -> [return: bb14, unwind: bb34];
    }

    bb14: {
        _26 = args::ArgMatches::max_count(_1) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _25 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _26) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb17, 1: bb18, otherwise: bb8];
    }

    bb17: {
        _29 = ((_25 as Continue).0: std::option::Option<u64>);
        _9 = SummaryBuilder::max_matches(_10, _29) -> [return: bb19, unwind: bb34];
    }

    bb18: {
        _28 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Summary<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _28) -> [return: bb40, unwind: bb34];
    }

    bb19: {
        _32 = const "include-zero";
        _31 = args::ArgMatches::is_present(_1, _32) -> [return: bb20, unwind: bb34];
    }

    bb20: {
        _30 = Not(move _31);
        _8 = SummaryBuilder::exclude_zero(_9, move _30) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _35 = const b":";
        _34 = _35 as &[u8] (PointerCoercion(Unsize));
        _33 = slice::<impl [u8]>::to_vec(move _34) -> [return: bb22, unwind: bb34];
    }

    bb22: {
        _7 = SummaryBuilder::separator_field(_8, move _33) -> [return: bb23, unwind: bb34];
    }

    bb23: {
        _37 = args::ArgMatches::path_separator(_1) -> [return: bb24, unwind: bb34];
    }

    bb24: {
        _36 = <std::result::Result<Option<u8>, Box<dyn std::error::Error>> as Try>::branch(move _37) -> [return: bb25, unwind: bb34];
    }

    bb25: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb26, 1: bb27, otherwise: bb8];
    }

    bb26: {
        _40 = ((_36 as Continue).0: std::option::Option<u8>);
        _6 = SummaryBuilder::separator_path(_7, _40) -> [return: bb28, unwind: bb34];
    }

    bb27: {
        _39 = move ((_36 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Summary<W>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _39) -> [return: bb41, unwind: bb34];
    }

    bb28: {
        _41 = args::ArgMatches::path_terminator(_1) -> [return: bb29, unwind: bb34];
    }

    bb29: {
        _5 = SummaryBuilder::path_terminator(_6, move _41) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        _43 = &_4;
        _45 = const false;
        _44 = move _3;
        _42 = SummaryBuilder::build::<W>(move _43, move _44) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        _0 = std::result::Result::<Summary<W>, Box<dyn std::error::Error>>::Ok(move _42);
        drop(_4) -> [return: bb33, unwind: bb38];
    }

    bb32: {
        drop(_3) -> [return: bb33, unwind continue];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_4) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        resume;
    }

    bb36: {
        drop(_4) -> [return: bb32, unwind: bb38];
    }

    bb37 (cleanup): {
        drop(_3) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_45) -> [0: bb35, otherwise: bb37];
    }

    bb39: {
        goto -> bb36;
    }

    bb40: {
        goto -> bb36;
    }

    bb41: {
        goto -> bb36;
    }
}

alloc9 (size: 1, align: 1) {
    3a                                              │ :
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::searcher(_1: &args::ArgMatches, _2: &[PathBuf]) -> std::result::Result<grep::grep_searcher::Searcher, Box<dyn std::error::Error>> {
    debug self => _1;
    debug paths => _2;
    let mut _0: std::result::Result<grep::grep_searcher::Searcher, std::boxed::Box<dyn std::error::Error>>;
    let _3: usize;
    let _4: usize;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, (usize, usize)>;
    let mut _6: std::result::Result<(usize, usize), std::boxed::Box<dyn std::error::Error>>;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _9: (usize, usize);
    let mut _11: bool;
    let _12: &str;
    let mut _13: bool;
    let _14: &str;
    let _16: &mut grep::grep_searcher::SearcherBuilder;
    let mut _17: &mut grep::grep_searcher::SearcherBuilder;
    let mut _18: &mut grep::grep_searcher::SearcherBuilder;
    let mut _19: &mut grep::grep_searcher::SearcherBuilder;
    let mut _20: &mut grep::grep_searcher::SearcherBuilder;
    let mut _21: &mut grep::grep_searcher::SearcherBuilder;
    let mut _22: &mut grep::grep_searcher::SearcherBuilder;
    let mut _23: &mut grep::grep_searcher::SearcherBuilder;
    let mut _24: &mut grep::grep_searcher::SearcherBuilder;
    let mut _25: grep::grep_matcher::LineTerminator;
    let mut _26: bool;
    let _27: &str;
    let mut _28: bool;
    let mut _29: bool;
    let _30: &str;
    let mut _31: bool;
    let _32: &str;
    let mut _33: grep::grep_searcher::MmapChoice;
    let mut _34: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::EncodingMode>;
    let mut _35: std::result::Result<args::EncodingMode, std::boxed::Box<dyn std::error::Error>>;
    let mut _36: isize;
    let mut _39: isize;
    let _41: &mut grep::grep_searcher::SearcherBuilder;
    let mut _42: &mut grep::grep_searcher::SearcherBuilder;
    let mut _43: std::option::Option<grep::grep_searcher::Encoding>;
    let _44: &mut grep::grep_searcher::SearcherBuilder;
    let mut _45: &mut grep::grep_searcher::SearcherBuilder;
    let mut _46: grep::grep_searcher::Searcher;
    let mut _47: &grep::grep_searcher::SearcherBuilder;
    scope 1 {
        debug ctx_before => _3;
        debug ctx_after => _4;
        let _10: grep::grep_matcher::LineTerminator;
        scope 6 {
            debug line_term => _10;
            let mut _15: grep::grep_searcher::SearcherBuilder;
            scope 7 {
                debug builder => _15;
                let _37: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                let _38: args::EncodingMode;
                let _40: grep::grep_searcher::Encoding;
                scope 8 {
                    debug residual => _37;
                    scope 9 {
                    }
                }
                scope 10 {
                    debug val => _38;
                    scope 11 {
                    }
                }
                scope 12 {
                    debug enc => _40;
                }
            }
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _6 = args::ArgMatches::contexts(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = <std::result::Result<(usize, usize), Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_5 as Continue).0: (usize, usize));
        _3 = (_9.0: usize);
        _4 = (_9.1: usize);
        _12 = const "crlf";
        _11 = args::ArgMatches::is_present(_1, _12) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<grep::grep_searcher::Searcher, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _8) -> [return: bb34, unwind continue];
    }

    bb6: {
        switchInt(move _11) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _10 = LineTerminator::crlf() -> [return: bb12, unwind continue];
    }

    bb8: {
        _14 = const "null-data";
        _13 = args::ArgMatches::is_present(_1, _14) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _13) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _10 = LineTerminator::byte(const 0_u8) -> [return: bb12, unwind continue];
    }

    bb11: {
        _10 = LineTerminator::byte(const 10_u8) -> [return: bb12, unwind continue];
    }

    bb12: {
        _15 = SearcherBuilder::new() -> [return: bb13, unwind continue];
    }

    bb13: {
        _24 = &mut _15;
        _25 = _10;
        _23 = SearcherBuilder::line_terminator(move _24, move _25) -> [return: bb14, unwind continue];
    }

    bb14: {
        _27 = const "invert-match";
        _26 = args::ArgMatches::is_present(_1, _27) -> [return: bb15, unwind continue];
    }

    bb15: {
        _22 = SearcherBuilder::invert_match(_23, move _26) -> [return: bb16, unwind continue];
    }

    bb16: {
        _28 = args::ArgMatches::line_number(_1, _2) -> [return: bb17, unwind continue];
    }

    bb17: {
        _21 = SearcherBuilder::line_number(_22, move _28) -> [return: bb18, unwind continue];
    }

    bb18: {
        _30 = const "multiline";
        _29 = args::ArgMatches::is_present(_1, _30) -> [return: bb19, unwind continue];
    }

    bb19: {
        _20 = SearcherBuilder::multi_line(_21, move _29) -> [return: bb20, unwind continue];
    }

    bb20: {
        _19 = SearcherBuilder::before_context(_20, _3) -> [return: bb21, unwind continue];
    }

    bb21: {
        _18 = SearcherBuilder::after_context(_19, _4) -> [return: bb22, unwind continue];
    }

    bb22: {
        _32 = const "passthru";
        _31 = args::ArgMatches::is_present(_1, _32) -> [return: bb23, unwind continue];
    }

    bb23: {
        _17 = SearcherBuilder::passthru(_18, move _31) -> [return: bb24, unwind continue];
    }

    bb24: {
        _33 = args::ArgMatches::mmap_choice(_1, _2) -> [return: bb25, unwind continue];
    }

    bb25: {
        _16 = SearcherBuilder::memory_map(_17, move _33) -> [return: bb26, unwind continue];
    }

    bb26: {
        _35 = args::ArgMatches::encoding(_1) -> [return: bb27, unwind continue];
    }

    bb27: {
        _34 = <std::result::Result<EncodingMode, Box<dyn std::error::Error>> as Try>::branch(move _35) -> [return: bb28, unwind continue];
    }

    bb28: {
        _36 = discriminant(_34);
        switchInt(move _36) -> [0: bb29, 1: bb30, otherwise: bb4];
    }

    bb29: {
        _38 = move ((_34 as Continue).0: args::EncodingMode);
        _39 = discriminant(_38);
        switchInt(move _39) -> [0: bb32, 1: bb35, 2: bb31, otherwise: bb4];
    }

    bb30: {
        _37 = move ((_34 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<grep::grep_searcher::Searcher, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _37) -> [return: bb34, unwind continue];
    }

    bb31: {
        _45 = &mut _15;
        _44 = SearcherBuilder::bom_sniffing(move _45, const false) -> [return: bb35, unwind continue];
    }

    bb32: {
        _40 = move ((_38 as Some).0: grep::grep_searcher::Encoding);
        _42 = &mut _15;
        _43 = Option::<Encoding>::Some(move _40);
        _41 = SearcherBuilder::encoding(move _42, move _43) -> [return: bb35, unwind continue];
    }

    bb33: {
        _0 = std::result::Result::<grep::grep_searcher::Searcher, Box<dyn std::error::Error>>::Ok(move _46);
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35: {
        _47 = &_15;
        _46 = SearcherBuilder::build(move _47) -> [return: bb33, unwind continue];
    }
}

fn args::<impl at crates/core/args.rs:574:1: 574:16>::walker_builder(_1: &args::ArgMatches, _2: &[PathBuf]) -> std::result::Result<WalkBuilder, Box<dyn std::error::Error>> {
    debug self => _1;
    debug paths => _2;
    let mut _0: std::result::Result<ignore::WalkBuilder, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: ignore::WalkBuilder;
    let mut _4: &std::path::PathBuf;
    let _5: usize;
    let mut _6: usize;
    let mut _7: bool;
    let mut _8: std::slice::Iter<'_, std::path::PathBuf>;
    let _9: &[std::path::PathBuf];
    let mut _10: std::ops::RangeFrom<usize>;
    let mut _12: std::option::Option<&std::path::PathBuf>;
    let mut _13: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _14: isize;
    let _16: &mut ignore::WalkBuilder;
    let mut _17: &mut ignore::WalkBuilder;
    let mut _18: bool;
    let mut _19: std::vec::IntoIter<std::path::PathBuf>;
    let mut _20: std::vec::Vec<std::path::PathBuf>;
    let mut _22: std::option::Option<std::path::PathBuf>;
    let mut _23: &mut std::vec::IntoIter<std::path::PathBuf>;
    let mut _24: isize;
    let mut _26: std::option::Option<ignore::Error>;
    let mut _27: &mut ignore::WalkBuilder;
    let mut _28: isize;
    let mut _30: bool;
    let mut _31: bool;
    let _32: ();
    let mut _33: std::fmt::Arguments<'_>;
    let mut _34: &[&str];
    let mut _35: &[core::fmt::rt::Argument<'_>];
    let _36: &[core::fmt::rt::Argument<'_>; 1];
    let _37: [core::fmt::rt::Argument<'_>; 1];
    let mut _38: core::fmt::rt::Argument<'_>;
    let _39: &ignore::Error;
    let _40: &mut ignore::WalkBuilder;
    let mut _41: &mut ignore::WalkBuilder;
    let mut _42: &mut ignore::WalkBuilder;
    let mut _43: &mut ignore::WalkBuilder;
    let mut _44: &mut ignore::WalkBuilder;
    let mut _45: &mut ignore::WalkBuilder;
    let mut _46: &mut ignore::WalkBuilder;
    let mut _47: &mut ignore::WalkBuilder;
    let mut _48: &mut ignore::WalkBuilder;
    let mut _49: &mut ignore::WalkBuilder;
    let mut _50: &mut ignore::WalkBuilder;
    let mut _51: &mut ignore::WalkBuilder;
    let mut _52: &mut ignore::WalkBuilder;
    let mut _53: &mut ignore::WalkBuilder;
    let mut _54: &mut ignore::WalkBuilder;
    let mut _55: &mut ignore::WalkBuilder;
    let mut _56: &mut ignore::WalkBuilder;
    let mut _57: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _58: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _59: &str;
    let mut _60: isize;
    let mut _63: bool;
    let _64: &str;
    let mut _65: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _66: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _67: isize;
    let mut _70: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, usize>;
    let mut _71: std::result::Result<usize, std::boxed::Box<dyn std::error::Error>>;
    let mut _72: isize;
    let mut _75: bool;
    let _76: &str;
    let mut _77: bool;
    let mut _78: bool;
    let _79: &str;
    let mut _80: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::overrides::Override>;
    let mut _81: std::result::Result<ignore::overrides::Override, std::boxed::Box<dyn std::error::Error>>;
    let mut _82: isize;
    let mut _85: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::types::Types>;
    let mut _86: std::result::Result<ignore::types::Types, std::boxed::Box<dyn std::error::Error>>;
    let mut _87: isize;
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    let mut _97: bool;
    let mut _98: bool;
    let mut _99: bool;
    let mut _100: bool;
    let mut _101: bool;
    let mut _102: bool;
    let mut _103: bool;
    let mut _104: bool;
    let mut _105: bool;
    let _106: &str;
    let mut _107: bool;
    let mut _108: bool;
    let _109: &mut ignore::WalkBuilder;
    let mut _110: &mut ignore::WalkBuilder;
    let mut _112: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::SortBy>;
    let mut _113: std::result::Result<args::SortBy, std::boxed::Box<dyn std::error::Error>>;
    let mut _114: isize;
    let mut _117: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>>;
    let mut _118: std::result::Result<(), std::boxed::Box<dyn std::error::Error>>;
    let mut _119: &args::SortBy;
    let mut _120: isize;
    let _122: ();
    let mut _123: args::SortBy;
    let mut _124: &mut ignore::WalkBuilder;
    let mut _125: ignore::WalkBuilder;
    let mut _127: bool;
    let mut _128: isize;
    scope 1 {
        debug builder => _3;
        let mut _11: std::slice::Iter<'_, std::path::PathBuf>;
        let mut _21: std::vec::IntoIter<std::path::PathBuf>;
        let _61: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _62: std::option::Option<usize>;
        let _68: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _69: std::option::Option<u64>;
        let _73: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _74: usize;
        let _83: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _84: ignore::overrides::Override;
        let _88: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _89: ignore::types::Types;
        let _111: args::SortBy;
        let _115: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _116: args::SortBy;
        scope 2 {
            debug iter => _11;
            let _15: &std::path::PathBuf;
            scope 3 {
                debug path => _15;
            }
        }
        scope 4 {
            debug iter => _21;
            let _25: std::path::PathBuf;
            scope 5 {
                debug path => _25;
                scope 6 {
                    debug err => _29;
                    let _29: ignore::Error;
                    let mut _126: &[&str; 2];
                }
            }
        }
        scope 7 {
            debug residual => _61;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _62;
            scope 10 {
            }
        }
        scope 11 {
            debug residual => _68;
            scope 12 {
            }
        }
        scope 13 {
            debug val => _69;
            scope 14 {
            }
        }
        scope 15 {
            debug residual => _73;
            scope 16 {
            }
        }
        scope 17 {
            debug val => _74;
            scope 18 {
            }
        }
        scope 19 {
            debug residual => _83;
            scope 20 {
            }
        }
        scope 21 {
            debug val => _84;
            scope 22 {
            }
        }
        scope 23 {
            debug residual => _88;
            scope 24 {
            }
        }
        scope 25 {
            debug val => _89;
            scope 26 {
            }
        }
        scope 27 {
            debug sortby => _111;
            let _121: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            scope 32 {
                debug residual => _121;
                scope 33 {
                }
            }
            scope 34 {
                debug val => const ();
                scope 35 {
                }
            }
        }
        scope 28 {
            debug residual => _115;
            scope 29 {
            }
        }
        scope 30 {
            debug val => _116;
            scope 31 {
            }
        }
    }

    bb0: {
        _127 = const false;
        _5 = const 0_usize;
        _6 = Len((*_2));
        _7 = Lt(_5, _6);
        assert(move _7, "index out of bounds: the length is {} but the index is {}", move _6, _5) -> [success: bb1, unwind continue];
    }

    bb1: {
        _4 = &(*_2)[_5];
        _3 = WalkBuilder::new::<&PathBuf>(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _10 = RangeFrom::<usize> { start: const 1_usize };
        _9 = <[PathBuf] as std::ops::Index<RangeFrom<usize>>>::index(_2, move _10) -> [return: bb3, unwind: bb99];
    }

    bb3: {
        _8 = <&[PathBuf] as IntoIterator>::into_iter(_9) -> [return: bb4, unwind: bb99];
    }

    bb4: {
        _11 = move _8;
        goto -> bb5;
    }

    bb5: {
        _13 = &mut _11;
        _12 = <std::slice::Iter<'_, PathBuf> as Iterator>::next(_13) -> [return: bb6, unwind: bb99];
    }

    bb6: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb9, 1: bb7, otherwise: bb8];
    }

    bb7: {
        _15 = ((_12 as Some).0: &std::path::PathBuf);
        _17 = &mut _3;
        _16 = WalkBuilder::add::<&PathBuf>(move _17, _15) -> [return: bb105, unwind: bb99];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _18 = args::ArgMatches::no_ignore_files(_1) -> [return: bb10, unwind: bb99];
    }

    bb10: {
        switchInt(move _18) -> [0: bb11, otherwise: bb27];
    }

    bb11: {
        _20 = args::ArgMatches::ignore_paths(_1) -> [return: bb12, unwind: bb99];
    }

    bb12: {
        _19 = <Vec<PathBuf> as IntoIterator>::into_iter(move _20) -> [return: bb13, unwind: bb99];
    }

    bb13: {
        _21 = move _19;
        goto -> bb14;
    }

    bb14: {
        _23 = &mut _21;
        _22 = <std::vec::IntoIter<PathBuf> as Iterator>::next(_23) -> [return: bb15, unwind: bb98];
    }

    bb15: {
        _24 = discriminant(_22);
        switchInt(move _24) -> [0: bb17, 1: bb16, otherwise: bb8];
    }

    bb16: {
        _25 = move ((_22 as Some).0: std::path::PathBuf);
        _27 = &mut _3;
        _26 = WalkBuilder::add_ignore::<PathBuf>(move _27, move _25) -> [return: bb18, unwind: bb98];
    }

    bb17: {
        drop(_21) -> [return: bb27, unwind: bb99];
    }

    bb18: {
        _127 = const true;
        _28 = discriminant(_26);
        switchInt(move _28) -> [1: bb19, otherwise: bb104];
    }

    bb19: {
        _127 = const false;
        _29 = move ((_26 as Some).0: ignore::Error);
        _30 = messages() -> [return: bb20, unwind: bb97];
    }

    bb20: {
        switchInt(move _30) -> [0: bb26, otherwise: bb21];
    }

    bb21: {
        _31 = ignore_messages() -> [return: bb22, unwind: bb97];
    }

    bb22: {
        switchInt(move _31) -> [0: bb26, otherwise: bb23];
    }

    bb23: {
        _126 = const _;
        _34 = _126 as &[&str] (PointerCoercion(Unsize));
        _39 = &_29;
        _38 = core::fmt::rt::Argument::<'_>::new_display::<ignore::Error>(_39) -> [return: bb24, unwind: bb97];
    }

    bb24: {
        _37 = [move _38];
        _36 = &_37;
        _35 = _36 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _33 = Arguments::<'_>::new_v1(move _34, move _35) -> [return: bb25, unwind: bb97];
    }

    bb25: {
        _32 = _eprint(move _33) -> [return: bb106, unwind: bb97];
    }

    bb26: {
        drop(_29) -> [return: bb104, unwind: bb98];
    }

    bb27: {
        _56 = &mut _3;
        _59 = const "max-depth";
        _58 = args::ArgMatches::usize_of(_1, _59) -> [return: bb28, unwind: bb99];
    }

    bb28: {
        _57 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _58) -> [return: bb29, unwind: bb99];
    }

    bb29: {
        _60 = discriminant(_57);
        switchInt(move _60) -> [0: bb30, 1: bb31, otherwise: bb8];
    }

    bb30: {
        _62 = ((_57 as Continue).0: std::option::Option<usize>);
        _55 = WalkBuilder::max_depth(move _56, _62) -> [return: bb32, unwind: bb99];
    }

    bb31: {
        _61 = move ((_57 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _61) -> [return: bb107, unwind: bb99];
    }

    bb32: {
        _64 = const "follow";
        _63 = args::ArgMatches::is_present(_1, _64) -> [return: bb33, unwind: bb99];
    }

    bb33: {
        _54 = WalkBuilder::follow_links(_55, move _63) -> [return: bb34, unwind: bb99];
    }

    bb34: {
        _66 = args::ArgMatches::max_file_size(_1) -> [return: bb35, unwind: bb99];
    }

    bb35: {
        _65 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _66) -> [return: bb36, unwind: bb99];
    }

    bb36: {
        _67 = discriminant(_65);
        switchInt(move _67) -> [0: bb37, 1: bb38, otherwise: bb8];
    }

    bb37: {
        _69 = ((_65 as Continue).0: std::option::Option<u64>);
        _53 = WalkBuilder::max_filesize(_54, _69) -> [return: bb39, unwind: bb99];
    }

    bb38: {
        _68 = move ((_65 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _68) -> [return: bb108, unwind: bb99];
    }

    bb39: {
        _71 = args::ArgMatches::threads(_1) -> [return: bb40, unwind: bb99];
    }

    bb40: {
        _70 = <std::result::Result<usize, Box<dyn std::error::Error>> as Try>::branch(move _71) -> [return: bb41, unwind: bb99];
    }

    bb41: {
        _72 = discriminant(_70);
        switchInt(move _72) -> [0: bb42, 1: bb43, otherwise: bb8];
    }

    bb42: {
        _74 = ((_70 as Continue).0: usize);
        _52 = WalkBuilder::threads(_53, _74) -> [return: bb44, unwind: bb99];
    }

    bb43: {
        _73 = move ((_70 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _73) -> [return: bb109, unwind: bb99];
    }

    bb44: {
        _76 = const "one-file-system";
        _75 = args::ArgMatches::is_present(_1, _76) -> [return: bb45, unwind: bb99];
    }

    bb45: {
        _51 = WalkBuilder::same_file_system(_52, move _75) -> [return: bb46, unwind: bb99];
    }

    bb46: {
        _79 = const "files";
        _78 = args::ArgMatches::is_present(_1, _79) -> [return: bb47, unwind: bb99];
    }

    bb47: {
        _77 = Not(move _78);
        _50 = WalkBuilder::skip_stdout(_51, move _77) -> [return: bb48, unwind: bb99];
    }

    bb48: {
        _81 = args::ArgMatches::overrides(_1) -> [return: bb49, unwind: bb99];
    }

    bb49: {
        _80 = <std::result::Result<Override, Box<dyn std::error::Error>> as Try>::branch(move _81) -> [return: bb50, unwind: bb99];
    }

    bb50: {
        _82 = discriminant(_80);
        switchInt(move _82) -> [0: bb51, 1: bb52, otherwise: bb8];
    }

    bb51: {
        _84 = move ((_80 as Continue).0: ignore::overrides::Override);
        _49 = WalkBuilder::overrides(_50, move _84) -> [return: bb53, unwind: bb99];
    }

    bb52: {
        _83 = move ((_80 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _83) -> [return: bb110, unwind: bb99];
    }

    bb53: {
        _86 = args::ArgMatches::types(_1) -> [return: bb54, unwind: bb99];
    }

    bb54: {
        _85 = <std::result::Result<ignore::types::Types, Box<dyn std::error::Error>> as Try>::branch(move _86) -> [return: bb55, unwind: bb99];
    }

    bb55: {
        _87 = discriminant(_85);
        switchInt(move _87) -> [0: bb56, 1: bb57, otherwise: bb8];
    }

    bb56: {
        _89 = move ((_85 as Continue).0: ignore::types::Types);
        _48 = WalkBuilder::types(_49, move _89) -> [return: bb58, unwind: bb99];
    }

    bb57: {
        _88 = move ((_85 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _88) -> [return: bb111, unwind: bb99];
    }

    bb58: {
        _91 = args::ArgMatches::hidden(_1) -> [return: bb59, unwind: bb99];
    }

    bb59: {
        _90 = Not(move _91);
        _47 = WalkBuilder::hidden(_48, move _90) -> [return: bb60, unwind: bb99];
    }

    bb60: {
        _93 = args::ArgMatches::no_ignore_parent(_1) -> [return: bb61, unwind: bb99];
    }

    bb61: {
        _92 = Not(move _93);
        _46 = WalkBuilder::parents(_47, move _92) -> [return: bb62, unwind: bb99];
    }

    bb62: {
        _95 = args::ArgMatches::no_ignore_dot(_1) -> [return: bb63, unwind: bb99];
    }

    bb63: {
        _94 = Not(move _95);
        _45 = WalkBuilder::ignore(_46, move _94) -> [return: bb64, unwind: bb99];
    }

    bb64: {
        _97 = args::ArgMatches::no_ignore_vcs(_1) -> [return: bb65, unwind: bb99];
    }

    bb65: {
        switchInt(move _97) -> [0: bb67, otherwise: bb66];
    }

    bb66: {
        _96 = const false;
        goto -> bb69;
    }

    bb67: {
        _98 = args::ArgMatches::no_ignore_global(_1) -> [return: bb68, unwind: bb99];
    }

    bb68: {
        _96 = Not(move _98);
        goto -> bb69;
    }

    bb69: {
        _44 = WalkBuilder::git_global(_45, move _96) -> [return: bb70, unwind: bb99];
    }

    bb70: {
        _100 = args::ArgMatches::no_ignore_vcs(_1) -> [return: bb71, unwind: bb99];
    }

    bb71: {
        _99 = Not(move _100);
        _43 = WalkBuilder::git_ignore(_44, move _99) -> [return: bb72, unwind: bb99];
    }

    bb72: {
        _102 = args::ArgMatches::no_ignore_vcs(_1) -> [return: bb73, unwind: bb99];
    }

    bb73: {
        switchInt(move _102) -> [0: bb75, otherwise: bb74];
    }

    bb74: {
        _101 = const false;
        goto -> bb77;
    }

    bb75: {
        _103 = args::ArgMatches::no_ignore_exclude(_1) -> [return: bb76, unwind: bb99];
    }

    bb76: {
        _101 = Not(move _103);
        goto -> bb77;
    }

    bb77: {
        _42 = WalkBuilder::git_exclude(_43, move _101) -> [return: bb78, unwind: bb99];
    }

    bb78: {
        _106 = const "no-require-git";
        _105 = args::ArgMatches::is_present(_1, _106) -> [return: bb79, unwind: bb99];
    }

    bb79: {
        _104 = Not(move _105);
        _41 = WalkBuilder::require_git(_42, move _104) -> [return: bb80, unwind: bb99];
    }

    bb80: {
        _107 = args::ArgMatches::ignore_file_case_insensitive(_1) -> [return: bb81, unwind: bb99];
    }

    bb81: {
        _40 = WalkBuilder::ignore_case_insensitive(_41, move _107) -> [return: bb82, unwind: bb99];
    }

    bb82: {
        _108 = args::ArgMatches::no_ignore(_1) -> [return: bb83, unwind: bb99];
    }

    bb83: {
        switchInt(move _108) -> [0: bb84, otherwise: bb85];
    }

    bb84: {
        _110 = &mut _3;
        _109 = WalkBuilder::add_custom_ignore_filename::<&str>(move _110, const ".rgignore") -> [return: bb112, unwind: bb99];
    }

    bb85: {
        _113 = args::ArgMatches::sort_by(_1) -> [return: bb86, unwind: bb99];
    }

    bb86: {
        _112 = <std::result::Result<SortBy, Box<dyn std::error::Error>> as Try>::branch(move _113) -> [return: bb87, unwind: bb99];
    }

    bb87: {
        _114 = discriminant(_112);
        switchInt(move _114) -> [0: bb88, 1: bb89, otherwise: bb8];
    }

    bb88: {
        _116 = ((_112 as Continue).0: args::SortBy);
        _111 = _116;
        _119 = &_111;
        _118 = SortBy::check(move _119) -> [return: bb90, unwind: bb99];
    }

    bb89: {
        _115 = move ((_112 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _115) -> [return: bb113, unwind: bb99];
    }

    bb90: {
        _117 = <std::result::Result<(), Box<dyn std::error::Error>> as Try>::branch(move _118) -> [return: bb91, unwind: bb99];
    }

    bb91: {
        _120 = discriminant(_117);
        switchInt(move _120) -> [0: bb92, 1: bb93, otherwise: bb8];
    }

    bb92: {
        _123 = _111;
        _124 = &mut _3;
        _122 = SortBy::configure_walk_builder(move _123, _124) -> [return: bb94, unwind: bb99];
    }

    bb93: {
        _121 = move ((_117 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<WalkBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _121) -> [return: bb114, unwind: bb99];
    }

    bb94: {
        _125 = move _3;
        _0 = std::result::Result::<WalkBuilder, Box<dyn std::error::Error>>::Ok(move _125);
        goto -> bb96;
    }

    bb95: {
        drop(_3) -> [return: bb96, unwind continue];
    }

    bb96: {
        return;
    }

    bb97 (cleanup): {
        drop(_29) -> [return: bb98, unwind terminate(cleanup)];
    }

    bb98 (cleanup): {
        drop(_21) -> [return: bb99, unwind terminate(cleanup)];
    }

    bb99 (cleanup): {
        drop(_3) -> [return: bb100, unwind terminate(cleanup)];
    }

    bb100 (cleanup): {
        resume;
    }

    bb101: {
        _127 = const false;
        goto -> bb14;
    }

    bb102: {
        switchInt(_127) -> [0: bb101, otherwise: bb103];
    }

    bb103: {
        drop(((_26 as Some).0: ignore::Error)) -> [return: bb101, unwind: bb98];
    }

    bb104: {
        _128 = discriminant(_26);
        switchInt(move _128) -> [1: bb102, otherwise: bb101];
    }

    bb105: {
        goto -> bb5;
    }

    bb106: {
        goto -> bb26;
    }

    bb107: {
        goto -> bb95;
    }

    bb108: {
        goto -> bb95;
    }

    bb109: {
        goto -> bb95;
    }

    bb110: {
        goto -> bb95;
    }

    bb111: {
        goto -> bb95;
    }

    bb112: {
        goto -> bb85;
    }

    bb113: {
        goto -> bb95;
    }

    bb114: {
        goto -> bb95;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:574:1: 574:16>::walker_builder: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::binary_detection_implicit(_1: &args::ArgMatches) -> BinaryDetection {
    debug self => _1;
    let mut _0: grep::grep_searcher::BinaryDetection;
    let _2: bool;
    let mut _3: bool;
    let _4: &str;
    let _5: &str;
    let mut _7: bool;
    let _8: &str;
    let mut _9: u64;
    let mut _10: bool;
    let mut _11: bool;
    scope 1 {
        debug none => _2;
        let _6: bool;
        scope 2 {
            debug convert => _6;
        }
    }

    bb0: {
        _4 = const "text";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _2 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const "null-data";
        _2 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = const "binary";
        _7 = args::ArgMatches::is_present(_1, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _6 = const true;
        goto -> bb9;
    }

    bb7: {
        _9 = args::ArgMatches::unrestricted_count(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _6 = Ge(move _9, const 3_u64);
        goto -> bb9;
    }

    bb9: {
        _10 = _2;
        switchInt(move _10) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = BinaryDetection::none() -> [return: bb14, unwind continue];
    }

    bb11: {
        _11 = _6;
        switchInt(move _11) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = BinaryDetection::convert(const 0_u8) -> [return: bb14, unwind continue];
    }

    bb13: {
        _0 = BinaryDetection::quit(const 0_u8) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::binary_detection_explicit(_1: &args::ArgMatches) -> BinaryDetection {
    debug self => _1;
    let mut _0: grep::grep_searcher::BinaryDetection;
    let _2: bool;
    let mut _3: bool;
    let _4: &str;
    let _5: &str;
    let mut _6: bool;
    scope 1 {
        debug none => _2;
    }

    bb0: {
        _4 = const "text";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _2 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const "null-data";
        _2 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _6 = _2;
        switchInt(move _6) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = BinaryDetection::none() -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = BinaryDetection::convert(const 0_u8) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::can_never_match(_1: &args::ArgMatches, _2: &[std::string::String]) -> bool {
    debug self => _1;
    debug patterns => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::option::Option<u64>>;
    let _5: std::option::Option<std::option::Option<u64>>;
    let mut _6: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _7: &std::option::Option<std::option::Option<u64>>;

    bb0: {
        _3 = core::slice::<impl [std::string::String]>::is_empty(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb6;
    }

    bb3: {
        _6 = args::ArgMatches::max_count(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _5 = std::result::Result::<Option<u64>, Box<dyn std::error::Error>>::ok(move _6) -> [return: bb5, unwind continue];
    }

    bb5: {
        _4 = &_5;
        _7 = const _;
        _0 = <Option<Option<u64>> as PartialEq>::eq(move _4, _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::can_never_match: &Option<Option<u64>> = {
    let mut _0: &std::option::Option<std::option::Option<u64>>;
    let mut _1: std::option::Option<std::option::Option<u64>>;
    let mut _2: std::option::Option<u64>;

    bb0: {
        _2 = Option::<u64>::Some(const 0_u64);
        _1 = Option::<Option<u64>>::Some(move _2);
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::case_insensitive(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let _5: &str;

    bb0: {
        _3 = const "ignore-case";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = const "case-sensitive";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb5;
    }

    bb4: {
        _0 = Not(move _4);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::case_smart(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let _5: &str;
    let mut _6: bool;
    let _7: &str;

    bb0: {
        _3 = const "smart-case";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb5, otherwise: bb2];
    }

    bb2: {
        _5 = const "ignore-case";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb4, otherwise: bb5];
    }

    bb4: {
        _7 = const "case-sensitive";
        _6 = args::ArgMatches::is_present(_1, _7) -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = const false;
        goto -> bb7;
    }

    bb6: {
        _0 = Not(move _6);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::color_choice(_1: &args::ArgMatches) -> ColorChoice {
    debug self => _1;
    let mut _0: termcolor::ColorChoice;
    let _2: std::string::String;
    let mut _3: std::option::Option<std::string::String>;
    let _4: &str;
    let mut _5: isize;
    let _6: &str;
    let _7: std::string::String;
    let mut _8: bool;
    let mut _9: &std::string::String;
    let mut _10: bool;
    let mut _11: &std::string::String;
    let mut _12: bool;
    let mut _13: &std::string::String;
    let mut _14: bool;
    let mut _15: bool;
    let _16: &str;
    scope 1 {
        debug preference => _2;
        let mut _17: &&str;
        let mut _18: &&str;
        let mut _19: &&str;
    }
    scope 2 {
        debug v => _7;
    }

    bb0: {
        _4 = const "color";
        _3 = args::ArgMatches::value_of_lossy(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = move ((_3 as Some).0: std::string::String);
        _2 = move _7;
        goto -> bb23;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = const "auto";
        _2 = <str as ToString>::to_string(_6) -> [return: bb23, unwind continue];
    }

    bb5: {
        switchInt(move _8) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Always;
        goto -> bb19;
    }

    bb7: {
        _11 = &_2;
        _18 = const _;
        _10 = <std::string::String as PartialEq<&str>>::eq(move _11, _18) -> [return: bb8, unwind: bb21];
    }

    bb8: {
        switchInt(move _10) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = AlwaysAnsi;
        goto -> bb19;
    }

    bb10: {
        _13 = &_2;
        _17 = const _;
        _12 = <std::string::String as PartialEq<&str>>::eq(move _13, _17) -> [return: bb11, unwind: bb21];
    }

    bb11: {
        switchInt(move _12) -> [0: bb18, otherwise: bb12];
    }

    bb12: {
        _14 = is_tty_stdout() -> [return: bb13, unwind: bb21];
    }

    bb13: {
        switchInt(move _14) -> [0: bb14, otherwise: bb16];
    }

    bb14: {
        _16 = const "pretty";
        _15 = args::ArgMatches::is_present(_1, _16) -> [return: bb15, unwind: bb21];
    }

    bb15: {
        switchInt(move _15) -> [0: bb17, otherwise: bb16];
    }

    bb16: {
        _0 = Auto;
        goto -> bb19;
    }

    bb17: {
        _0 = Never;
        goto -> bb19;
    }

    bb18: {
        _0 = Never;
        goto -> bb19;
    }

    bb19: {
        drop(_2) -> [return: bb20, unwind continue];
    }

    bb20: {
        return;
    }

    bb21 (cleanup): {
        drop(_2) -> [return: bb22, unwind terminate(cleanup)];
    }

    bb22 (cleanup): {
        resume;
    }

    bb23: {
        _9 = &_2;
        _19 = const _;
        _8 = <std::string::String as PartialEq<&str>>::eq(move _9, _19) -> [return: bb5, unwind: bb21];
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::color_choice: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "auto";
        _0 = &_1;
        return;
    }
}

promoted[1] in args::<impl at crates/core/args.rs:904:1: 904:16>::color_choice: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "ansi";
        _0 = &_1;
        return;
    }
}

promoted[2] in args::<impl at crates/core/args.rs:904:1: 904:16>::color_choice: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "always";
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::color_specs(_1: &args::ArgMatches) -> std::result::Result<ColorSpecs, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<grep::grep_printer::ColorSpecs, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::vec::Vec<grep::grep_printer::UserColorSpec>;
    let mut _3: std::vec::IntoIter<std::string::String>;
    let mut _4: std::vec::Vec<std::string::String>;
    let _5: &str;
    let mut _7: std::option::Option<std::string::String>;
    let mut _8: &mut std::vec::IntoIter<std::string::String>;
    let mut _9: isize;
    let _11: ();
    let mut _12: &mut std::vec::Vec<grep::grep_printer::UserColorSpec>;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_printer::ColorError>, grep::grep_printer::UserColorSpec>;
    let mut _14: std::result::Result<grep::grep_printer::UserColorSpec, grep::grep_printer::ColorError>;
    let _15: &str;
    let mut _16: &std::string::String;
    let mut _17: isize;
    let mut _20: grep::grep_printer::ColorSpecs;
    let _21: &[grep::grep_printer::UserColorSpec];
    let _22: &std::vec::Vec<grep::grep_printer::UserColorSpec>;
    scope 1 {
        debug specs => _2;
        let mut _6: std::vec::IntoIter<std::string::String>;
        scope 2 {
            debug iter => _6;
            let _10: std::string::String;
            scope 3 {
                debug spec_str => _10;
                let _18: std::result::Result<std::convert::Infallible, grep::grep_printer::ColorError>;
                let _19: grep::grep_printer::UserColorSpec;
                scope 4 {
                    debug residual => _18;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => _19;
                    scope 7 {
                    }
                }
            }
        }
    }

    bb0: {
        _2 = default_color_specs() -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "colors";
        _4 = args::ArgMatches::values_of_lossy_vec(_1, _5) -> [return: bb2, unwind: bb24];
    }

    bb2: {
        _3 = <Vec<std::string::String> as IntoIterator>::into_iter(move _4) -> [return: bb3, unwind: bb24];
    }

    bb3: {
        _6 = move _3;
        goto -> bb4;
    }

    bb4: {
        _8 = &mut _6;
        _7 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_8) -> [return: bb5, unwind: bb23];
    }

    bb5: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _10 = move ((_7 as Some).0: std::string::String);
        _12 = &mut _2;
        _16 = &_10;
        _15 = <std::string::String as Deref>::deref(move _16) -> [return: bb9, unwind: bb22];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        drop(_6) -> [return: bb16, unwind: bb24];
    }

    bb9: {
        _14 = core::str::<impl str>::parse::<UserColorSpec>(_15) -> [return: bb10, unwind: bb22];
    }

    bb10: {
        _13 = <std::result::Result<UserColorSpec, ColorError> as Try>::branch(move _14) -> [return: bb11, unwind: bb22];
    }

    bb11: {
        _17 = discriminant(_13);
        switchInt(move _17) -> [0: bb12, 1: bb13, otherwise: bb7];
    }

    bb12: {
        _19 = move ((_13 as Continue).0: grep::grep_printer::UserColorSpec);
        _11 = Vec::<UserColorSpec>::push(move _12, move _19) -> [return: bb15, unwind: bb22];
    }

    bb13: {
        _18 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_printer::ColorError>);
        _0 = <std::result::Result<ColorSpecs, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ColorError>>>::from_residual(move _18) -> [return: bb14, unwind: bb22];
    }

    bb14: {
        drop(_10) -> [return: bb19, unwind: bb23];
    }

    bb15: {
        drop(_10) -> [return: bb4, unwind: bb23];
    }

    bb16: {
        _22 = &_2;
        _21 = <Vec<UserColorSpec> as Deref>::deref(_22) -> [return: bb17, unwind: bb24];
    }

    bb17: {
        _20 = ColorSpecs::new(_21) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _0 = std::result::Result::<ColorSpecs, Box<dyn std::error::Error>>::Ok(move _20);
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb19: {
        drop(_6) -> [return: bb20, unwind: bb24];
    }

    bb20: {
        drop(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        return;
    }

    bb22 (cleanup): {
        drop(_10) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        drop(_6) -> [return: bb24, unwind terminate(cleanup)];
    }

    bb24 (cleanup): {
        drop(_2) -> [return: bb25, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::column(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let _5: &str;
    let _6: &str;

    bb0: {
        _3 = const "no-column";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb7;
    }

    bb3: {
        _5 = const "column";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = const true;
        goto -> bb7;
    }

    bb6: {
        _6 = const "vimgrep";
        _0 = args::ArgMatches::is_present(_1, _6) -> [return: bb7, unwind continue];
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::contexts(_1: &args::ArgMatches) -> std::result::Result<(usize, usize), Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<(usize, usize), std::boxed::Box<dyn std::error::Error>>;
    let _2: usize;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _4: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _5: &str;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _8: std::option::Option<usize>;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _11: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _12: &str;
    let mut _13: isize;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _18: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _19: &str;
    let mut _20: isize;
    let mut _23: (usize, usize);
    let mut _24: bool;
    scope 1 {
        debug after => _2;
        let _9: usize;
        let _14: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _15: std::option::Option<usize>;
        scope 6 {
            debug before => _9;
            let _16: usize;
            let _21: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _22: std::option::Option<usize>;
            scope 11 {
                debug both => _16;
            }
            scope 12 {
                debug residual => _21;
                scope 13 {
                }
            }
            scope 14 {
                debug val => _22;
                scope 15 {
                }
            }
        }
        scope 7 {
            debug residual => _14;
            scope 8 {
            }
        }
        scope 9 {
            debug val => _15;
            scope 10 {
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = const "after-context";
        _4 = args::ArgMatches::usize_of(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: std::option::Option<usize>);
        _2 = Option::<usize>::unwrap_or(_8, const 0_usize) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<(usize, usize), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _7) -> [return: bb20, unwind continue];
    }

    bb6: {
        _12 = const "before-context";
        _11 = args::ArgMatches::usize_of(_1, _12) -> [return: bb7, unwind continue];
    }

    bb7: {
        _10 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _11) -> [return: bb8, unwind continue];
    }

    bb8: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb9, 1: bb10, otherwise: bb4];
    }

    bb9: {
        _15 = ((_10 as Continue).0: std::option::Option<usize>);
        _9 = Option::<usize>::unwrap_or(_15, const 0_usize) -> [return: bb11, unwind continue];
    }

    bb10: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<(usize, usize), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _14) -> [return: bb20, unwind continue];
    }

    bb11: {
        _19 = const "context";
        _18 = args::ArgMatches::usize_of(_1, _19) -> [return: bb12, unwind continue];
    }

    bb12: {
        _17 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _18) -> [return: bb13, unwind continue];
    }

    bb13: {
        _20 = discriminant(_17);
        switchInt(move _20) -> [0: bb14, 1: bb15, otherwise: bb4];
    }

    bb14: {
        _22 = ((_17 as Continue).0: std::option::Option<usize>);
        _16 = Option::<usize>::unwrap_or(_22, const 0_usize) -> [return: bb16, unwind continue];
    }

    bb15: {
        _21 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<(usize, usize), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _21) -> [return: bb20, unwind continue];
    }

    bb16: {
        _24 = Gt(_16, const 0_usize);
        switchInt(move _24) -> [0: bb18, otherwise: bb17];
    }

    bb17: {
        _23 = (_16, _16);
        goto -> bb19;
    }

    bb18: {
        _23 = (_9, _2);
        goto -> bb19;
    }

    bb19: {
        _0 = std::result::Result::<(usize, usize), Box<dyn std::error::Error>>::Ok(move _23);
        goto -> bb20;
    }

    bb20: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::context_separator(_1: &args::ArgMatches) -> Option<Vec<u8>> {
    debug self => _1;
    let mut _0: std::option::Option<std::vec::Vec<u8>>;
    let _2: bool;
    let _3: &str;
    let _5: &str;
    let mut _6: (bool, std::option::Option<&std::ffi::OsStr>);
    let mut _7: isize;
    let mut _8: std::vec::Vec<u8>;
    let mut _9: &[u8];
    let _10: &[u8; 2];
    let mut _12: std::vec::Vec<u8>;
    let _13: &&std::ffi::OsStr;
    let mut _14: &std::ffi::OsStr;
    scope 1 {
        debug nosep => _2;
        let _4: std::option::Option<&std::ffi::OsStr>;
        scope 2 {
            debug sep => _4;
            let _11: &std::ffi::OsStr;
            scope 3 {
                debug sep => _11;
            }
        }
    }

    bb0: {
        _3 = const "no-context-separator";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "context-separator";
        _4 = args::ArgMatches::value_of_os(_1, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = (_2, _4);
        switchInt((_6.0: bool)) -> [0: bb3, otherwise: bb6];
    }

    bb3: {
        _7 = discriminant((_6.1: std::option::Option<&std::ffi::OsStr>));
        switchInt(move _7) -> [0: bb7, 1: bb4, otherwise: bb5];
    }

    bb4: {
        _11 = (((_6.1: std::option::Option<&std::ffi::OsStr>) as Some).0: &std::ffi::OsStr);
        _13 = &_11;
        _14 = deref_copy (*_13);
        _12 = unescape_os(_14) -> [return: bb9, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _0 = Option::<Vec<u8>>::None;
        goto -> bb10;
    }

    bb7: {
        _10 = const b"--";
        _9 = _10 as &[u8] (PointerCoercion(Unsize));
        _8 = slice::<impl [u8]>::to_vec(move _9) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = Option::<Vec<u8>>::Some(move _8);
        goto -> bb10;
    }

    bb9: {
        _0 = Option::<Vec<u8>>::Some(move _12);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

alloc10 (size: 2, align: 1) {
    2d 2d                                           │ --
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::counts(_1: &args::ArgMatches) -> (bool, bool) {
    debug self => _1;
    let mut _0: (bool, bool);
    let _2: bool;
    let _3: &str;
    let _5: &str;
    let _7: &str;
    let _9: &str;
    scope 1 {
        debug count => _2;
        let _4: bool;
        scope 2 {
            debug count_matches => _4;
            let _6: bool;
            scope 3 {
                debug invert_matches => _6;
                let _8: bool;
                scope 4 {
                    debug only_matching => _8;
                }
            }
        }
    }

    bb0: {
        _3 = const "count";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "count-matches";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = const "invert-match";
        _6 = args::ArgMatches::is_present(_1, _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = const "only-matching";
        _8 = args::ArgMatches::is_present(_1, _9) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(_4) -> [0: bb7, otherwise: bb5];
    }

    bb5: {
        switchInt(_6) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = (const true, const false);
        goto -> bb11;
    }

    bb7: {
        switchInt(_2) -> [0: bb10, otherwise: bb8];
    }

    bb8: {
        switchInt(_8) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = (const false, const true);
        goto -> bb11;
    }

    bb10: {
        _0 = (_2, _4);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::dfa_size_limit(_1: &args::ArgMatches) -> std::result::Result<Option<usize>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _3: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let _4: &str;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _7: std::option::Option<u64>;
    let _8: &str;
    scope 1 {
        debug r => _7;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = const "dfa-size-limit";
        _3 = args::ArgMatches::parse_human_readable_size(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: std::option::Option<u64>);
        _8 = const "dfa-size-limit";
        _0 = u64_to_usize(_8, _7) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::encoding(_1: &args::ArgMatches) -> std::result::Result<EncodingMode, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<args::EncodingMode, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: args::EncodingMode;
    let _5: std::string::String;
    let mut _6: std::option::Option<std::string::String>;
    let _7: &str;
    let mut _8: isize;
    let mut _9: bool;
    let _10: &str;
    let mut _11: args::EncodingMode;
    let _12: std::string::String;
    let mut _13: bool;
    let mut _14: &std::string::String;
    let mut _15: args::EncodingMode;
    let mut _16: bool;
    let mut _17: &std::string::String;
    let mut _18: args::EncodingMode;
    let mut _19: args::EncodingMode;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_searcher::ConfigError>, grep::grep_searcher::Encoding>;
    let mut _21: std::result::Result<grep::grep_searcher::Encoding, grep::grep_searcher::ConfigError>;
    let _22: &str;
    let _23: &std::string::String;
    let mut _24: isize;
    scope 1 {
        debug label => _5;
        let _25: std::result::Result<std::convert::Infallible, grep::grep_searcher::ConfigError>;
        let _26: grep::grep_searcher::Encoding;
        let mut _27: &&str;
        let mut _28: &&str;
        scope 3 {
            debug residual => _25;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _26;
            scope 6 {
            }
        }
    }
    scope 2 {
        debug label => _12;
    }

    bb0: {
        _3 = const "no-encoding";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _4 = EncodingMode::Auto;
        _0 = std::result::Result::<EncodingMode, Box<dyn std::error::Error>>::Ok(move _4);
        goto -> bb24;
    }

    bb3: {
        _7 = const "encoding";
        _6 = args::ArgMatches::value_of_lossy(_1, _7) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _12 = move ((_6 as Some).0: std::string::String);
        _5 = move _12;
        goto -> bb28;
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = args::ArgMatches::pcre2_unicode(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _10 = const "utf-8";
        _5 = <str as ToString>::to_string(_10) -> [return: bb28, unwind continue];
    }

    bb10: {
        _11 = EncodingMode::Auto;
        _0 = std::result::Result::<EncodingMode, Box<dyn std::error::Error>>::Ok(move _11);
        goto -> bb24;
    }

    bb11: {
        switchInt(move _13) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _15 = EncodingMode::Auto;
        _0 = std::result::Result::<EncodingMode, Box<dyn std::error::Error>>::Ok(move _15);
        goto -> bb23;
    }

    bb13: {
        _17 = &_5;
        _27 = const _;
        _16 = <std::string::String as PartialEq<&str>>::eq(move _17, _27) -> [return: bb14, unwind: bb26];
    }

    bb14: {
        switchInt(move _16) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _18 = EncodingMode::Disabled;
        _0 = std::result::Result::<EncodingMode, Box<dyn std::error::Error>>::Ok(move _18);
        goto -> bb23;
    }

    bb16: {
        _23 = &_5;
        _22 = <std::string::String as Deref>::deref(_23) -> [return: bb17, unwind: bb26];
    }

    bb17: {
        _21 = Encoding::new(_22) -> [return: bb18, unwind: bb26];
    }

    bb18: {
        _20 = <std::result::Result<Encoding, ConfigError> as Try>::branch(move _21) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _24 = discriminant(_20);
        switchInt(move _24) -> [0: bb20, 1: bb21, otherwise: bb6];
    }

    bb20: {
        _26 = move ((_20 as Continue).0: grep::grep_searcher::Encoding);
        _19 = EncodingMode::Some(move _26);
        _0 = std::result::Result::<EncodingMode, Box<dyn std::error::Error>>::Ok(move _19);
        drop(_5) -> [return: bb24, unwind continue];
    }

    bb21: {
        _25 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_searcher::ConfigError>);
        _0 = <std::result::Result<EncodingMode, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ConfigError>>>::from_residual(move _25) -> [return: bb22, unwind: bb25];
    }

    bb22: {
        drop(_5) -> [return: bb24, unwind continue];
    }

    bb23: {
        drop(_5) -> [return: bb24, unwind continue];
    }

    bb24: {
        return;
    }

    bb25 (cleanup): {
        drop(_5) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_5) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }

    bb28: {
        _14 = &_5;
        _28 = const _;
        _13 = <std::string::String as PartialEq<&str>>::eq(move _14, _28) -> [return: bb11, unwind: bb26];
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::encoding: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "none";
        _0 = &_1;
        return;
    }
}

promoted[1] in args::<impl at crates/core/args.rs:904:1: 904:16>::encoding: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "auto";
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::file_separator(_1: &args::ArgMatches) -> std::result::Result<Option<Vec<u8>>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<std::vec::Vec<u8>>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let mut _3: &args::OutputKind;
    let _4: args::OutputKind;
    let mut _5: std::option::Option<std::vec::Vec<u8>>;
    let _6: usize;
    let _7: usize;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, (usize, usize)>;
    let mut _9: std::result::Result<(usize, usize), std::boxed::Box<dyn std::error::Error>>;
    let mut _10: isize;
    let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _12: (usize, usize);
    let mut _13: std::option::Option<std::vec::Vec<u8>>;
    let mut _14: bool;
    let mut _15: std::vec::Vec<u8>;
    let mut _16: &[u8];
    let _17: &[u8; 0];
    let mut _18: bool;
    let mut _19: bool;
    let mut _20: &args::OutputKind;
    scope 1 {
        debug ctx_before => _6;
        debug ctx_after => _7;
    }
    scope 2 {
        debug residual => _11;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _12;
        scope 5 {
        }
    }

    bb0: {
        _4 = args::ArgMatches::output_kind(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _20 = const _;
        _2 = <OutputKind as PartialEq>::ne(move _3, _20) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _5 = Option::<Vec<u8>>::None;
        _0 = std::result::Result::<Option<Vec<u8>>, Box<dyn std::error::Error>>::Ok(move _5);
        goto -> bb18;
    }

    bb4: {
        _9 = args::ArgMatches::contexts(_1) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = <std::result::Result<(usize, usize), Box<dyn std::error::Error>> as Try>::branch(move _9) -> [return: bb6, unwind continue];
    }

    bb6: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _12 = ((_8 as Continue).0: (usize, usize));
        _6 = (_12.0: usize);
        _7 = (_12.1: usize);
        _14 = args::ArgMatches::heading(_1) -> [return: bb10, unwind continue];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<Vec<u8>>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb18, unwind continue];
    }

    bb10: {
        switchInt(move _14) -> [0: bb13, otherwise: bb11];
    }

    bb11: {
        _17 = const b"";
        _16 = _17 as &[u8] (PointerCoercion(Unsize));
        _15 = slice::<impl [u8]>::to_vec(move _16) -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = Option::<Vec<u8>>::Some(move _15);
        goto -> bb17;
    }

    bb13: {
        _18 = Gt(_6, const 0_usize);
        switchInt(move _18) -> [0: bb14, otherwise: bb15];
    }

    bb14: {
        _19 = Gt(_7, const 0_usize);
        switchInt(move _19) -> [0: bb16, otherwise: bb15];
    }

    bb15: {
        _13 = args::ArgMatches::context_separator(_1) -> [return: bb17, unwind continue];
    }

    bb16: {
        _13 = Option::<Vec<u8>>::None;
        goto -> bb17;
    }

    bb17: {
        _0 = std::result::Result::<Option<Vec<u8>>, Box<dyn std::error::Error>>::Ok(move _13);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

alloc11 (size: 0, align: 1) {}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::file_separator: &OutputKind = {
    let mut _0: &args::OutputKind;
    let mut _1: args::OutputKind;

    bb0: {
        _1 = OutputKind::Standard;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::heading(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let _5: &str;
    let mut _6: bool;
    let mut _7: bool;
    let _8: &str;
    let _9: &str;

    bb0: {
        _3 = const "no-heading";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _5 = const "vimgrep";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const false;
        goto -> bb11;
    }

    bb5: {
        _6 = is_tty_stdout() -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _6) -> [0: bb7, otherwise: bb9];
    }

    bb7: {
        _8 = const "heading";
        _7 = args::ArgMatches::is_present(_1, _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _7) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = const true;
        goto -> bb11;
    }

    bb10: {
        _9 = const "pretty";
        _0 = args::ArgMatches::is_present(_1, _9) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::hidden(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: u64;

    bb0: {
        _3 = const "hidden";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb5;
    }

    bb3: {
        _4 = args::ArgMatches::unrestricted_count(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Ge(move _4, const 2_u64);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::ignore_file_case_insensitive(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &str;

    bb0: {
        _2 = const "ignore-file-case-insensitive";
        _0 = args::ArgMatches::is_present(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::ignore_paths(_1: &args::ArgMatches) -> Vec<PathBuf> {
    debug self => _1;
    let mut _0: std::vec::Vec<std::path::PathBuf>;
    let mut _2: std::option::Option<clap::OsValues<'_>>;
    let _3: &str;
    let mut _4: isize;
    let _5: clap::OsValues<'_>;
    let mut _6: std::iter::Map<clap::OsValues<'_>, {closure@crates/core/args.rs:1130:19: 1130:22}>;
    scope 1 {
        debug paths => _5;
    }
    scope 2 {
        debug paths => _5;
    }

    bb0: {
        _3 = const "ignore-file";
        _2 = args::ArgMatches::values_of_os(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = move ((_2 as Some).0: clap::OsValues<'_>);
        _6 = <OsValues<'_> as Iterator>::map::<PathBuf, {closure@crates/core/args.rs:1130:19: 1130:22}>(move _5, const ZeroSized: {closure@crates/core/args.rs:1130:19: 1130:22}) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = Vec::<PathBuf>::new() -> [return: bb6, unwind continue];
    }

    bb5: {
        _0 = <std::iter::Map<OsValues<'_>, {closure@crates/core/args.rs:1130:19: 1130:22}> as Iterator>::collect::<Vec<PathBuf>>(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::ignore_paths::{closure#0}(_1: &mut {closure@crates/core/args.rs:1130:19: 1130:22}, _2: &OsStr) -> PathBuf {
    debug p => _2;
    let mut _0: std::path::PathBuf;
    let _3: &std::path::Path;

    bb0: {
        _3 = Path::new::<OsStr>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::to_path_buf(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::is_one_search(_1: &args::ArgMatches, _2: &[PathBuf]) -> bool {
    debug self => _1;
    debug paths => _2;
    let mut _0: bool;
    let mut _3: usize;
    let mut _4: bool;
    let _5: &std::path::Path;
    let mut _6: &std::path::PathBuf;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;

    bb0: {
        _3 = Len((*_2));
        switchInt(move _3) -> [1: bb2, otherwise: bb1];
    }

    bb1: {
        _0 = const false;
        goto -> bb8;
    }

    bb2: {
        _4 = args::ArgMatches::is_only_stdin(_1, _2) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _4) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = const true;
        goto -> bb8;
    }

    bb5: {
        _7 = const 0_usize;
        _8 = Len((*_2));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb6, unwind continue];
    }

    bb6: {
        _6 = &(*_2)[_7];
        _5 = <PathBuf as Deref>::deref(move _6) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = Path::is_file(_5) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::is_only_stdin(_1: &args::ArgMatches, _2: &[PathBuf]) -> bool {
    debug self => _1;
    debug paths => _2;
    let mut _0: bool;
    let mut _3: &&[std::path::PathBuf];
    let mut _4: &[&std::path::Path; 1];
    let _5: [&std::path::Path; 1];
    let mut _6: &std::path::Path;
    let _7: &str;

    bb0: {
        _3 = &_2;
        _7 = const "-";
        _6 = Path::new::<str>(_7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = [move _6];
        _4 = &_5;
        _0 = <&[PathBuf] as PartialEq<[&Path; 1]>>::eq(move _3, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::line_number(_1: &args::ArgMatches, _2: &[PathBuf]) -> bool {
    debug self => _1;
    debug paths => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &args::OutputKind;
    let _5: args::OutputKind;
    let mut _6: bool;
    let _7: &str;
    let mut _8: bool;
    let mut _9: &args::OutputKind;
    let _10: args::OutputKind;
    let mut _11: bool;
    let mut _12: bool;
    let mut _13: bool;
    let _14: &str;
    let mut _15: bool;
    let _16: &str;
    let mut _17: bool;
    let _18: &str;
    let _19: &str;
    let mut _20: &args::OutputKind;
    let mut _21: &args::OutputKind;

    bb0: {
        _5 = args::ArgMatches::output_kind(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &_5;
        _21 = const _;
        _3 = <OutputKind as PartialEq>::eq(move _4, _21) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _3) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const false;
        goto -> bb23;
    }

    bb4: {
        _7 = const "no-line-number";
        _6 = args::ArgMatches::is_present(_1, _7) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _6) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = const false;
        goto -> bb23;
    }

    bb7: {
        _10 = args::ArgMatches::output_kind(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _9 = &_10;
        _20 = const _;
        _8 = <OutputKind as PartialEq>::eq(move _9, _20) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _8) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _0 = const true;
        goto -> bb23;
    }

    bb11: {
        _11 = is_tty_stdout() -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _11) -> [0: bb15, otherwise: bb13];
    }

    bb13: {
        _12 = args::ArgMatches::is_only_stdin(_1, _2) -> [return: bb14, unwind continue];
    }

    bb14: {
        switchInt(move _12) -> [0: bb21, otherwise: bb15];
    }

    bb15: {
        _14 = const "line-number";
        _13 = args::ArgMatches::is_present(_1, _14) -> [return: bb16, unwind continue];
    }

    bb16: {
        switchInt(move _13) -> [0: bb17, otherwise: bb21];
    }

    bb17: {
        _16 = const "column";
        _15 = args::ArgMatches::is_present(_1, _16) -> [return: bb18, unwind continue];
    }

    bb18: {
        switchInt(move _15) -> [0: bb19, otherwise: bb21];
    }

    bb19: {
        _18 = const "pretty";
        _17 = args::ArgMatches::is_present(_1, _18) -> [return: bb20, unwind continue];
    }

    bb20: {
        switchInt(move _17) -> [0: bb22, otherwise: bb21];
    }

    bb21: {
        _0 = const true;
        goto -> bb23;
    }

    bb22: {
        _19 = const "vimgrep";
        _0 = args::ArgMatches::is_present(_1, _19) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::line_number: &OutputKind = {
    let mut _0: &args::OutputKind;
    let mut _1: args::OutputKind;

    bb0: {
        _1 = OutputKind::JSON;
        _0 = &_1;
        return;
    }
}

promoted[1] in args::<impl at crates/core/args.rs:904:1: 904:16>::line_number: &OutputKind = {
    let mut _0: &args::OutputKind;
    let mut _1: args::OutputKind;

    bb0: {
        _1 = OutputKind::Summary;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_columns(_1: &args::ArgMatches) -> std::result::Result<Option<u64>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::option::Option<u64>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _4: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _5: &str;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _8: std::option::Option<usize>;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _5 = const "max-columns";
        _4 = args::ArgMatches::usize_of_nonzero(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: std::option::Option<usize>);
        _2 = Option::<usize>::map::<u64, {closure@crates/core/args.rs:1175:54: 1175:57}>(_8, const ZeroSized: {closure@crates/core/args.rs:1175:54: 1175:57}) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<Option<u64>, Box<dyn std::error::Error>>::Ok(move _2);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_columns::{closure#0}(_1: {closure@crates/core/args.rs:1175:54: 1175:57}, _2: usize) -> u64 {
    debug n => _2;
    let mut _0: u64;

    bb0: {
        _0 = _2 as u64 (IntToInt);
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_columns_preview(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &str;

    bb0: {
        _2 = const "max-columns-preview";
        _0 = args::ArgMatches::is_present(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_count(_1: &args::ArgMatches) -> std::result::Result<Option<u64>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::option::Option<u64>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _4: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _5: &str;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _8: std::option::Option<usize>;
    scope 1 {
        debug residual => _7;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _8;
        scope 4 {
        }
    }

    bb0: {
        _5 = const "max-count";
        _4 = args::ArgMatches::usize_of(_1, _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: std::option::Option<usize>);
        _2 = Option::<usize>::map::<u64, {closure@crates/core/args.rs:1186:44: 1186:47}>(_8, const ZeroSized: {closure@crates/core/args.rs:1186:44: 1186:47}) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _7) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<Option<u64>, Box<dyn std::error::Error>>::Ok(move _2);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_count::{closure#0}(_1: {closure@crates/core/args.rs:1186:44: 1186:47}, _2: usize) -> u64 {
    debug n => _2;
    let mut _0: u64;

    bb0: {
        _0 = _2 as u64 (IntToInt);
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::max_file_size(_1: &args::ArgMatches) -> std::result::Result<Option<u64>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let _2: &str;

    bb0: {
        _2 = const "max-filesize";
        _0 = args::ArgMatches::parse_human_readable_size(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::mmap_choice(_1: &args::ArgMatches, _2: &[PathBuf]) -> MmapChoice {
    debug self => _1;
    debug paths => _2;
    let mut _0: grep::grep_searcher::MmapChoice;
    let _3: grep::grep_searcher::MmapChoice;
    let mut _5: bool;
    let _6: &str;
    let mut _7: bool;
    let _8: &str;
    let mut _9: bool;
    let mut _10: usize;
    let mut _11: bool;
    let mut _12: &mut std::slice::Iter<'_, std::path::PathBuf>;
    let mut _13: std::slice::Iter<'_, std::path::PathBuf>;
    scope 1 {
        debug maybe => _3;
        let _4: grep::grep_searcher::MmapChoice;
        scope 3 {
            debug never => _4;
        }
    }
    scope 2 {
    }

    bb0: {
        _3 = MmapChoice::auto() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = MmapChoice::never() -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = const "no-mmap";
        _5 = args::ArgMatches::is_present(_1, _6) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = move _4;
        goto -> bb14;
    }

    bb5: {
        _8 = const "mmap";
        _7 = args::ArgMatches::is_present(_1, _8) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _7) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = move _3;
        goto -> bb14;
    }

    bb8: {
        _10 = Len((*_2));
        _9 = Le(move _10, const 10_usize);
        switchInt(move _9) -> [0: bb13, otherwise: bb9];
    }

    bb9: {
        _13 = core::slice::<impl [PathBuf]>::iter(_2) -> [return: bb10, unwind continue];
    }

    bb10: {
        _12 = &mut _13;
        _11 = <std::slice::Iter<'_, PathBuf> as Iterator>::all::<{closure@crates/core/args.rs:1210:57: 1210:60}>(move _12, const ZeroSized: {closure@crates/core/args.rs:1210:57: 1210:60}) -> [return: bb11, unwind continue];
    }

    bb11: {
        switchInt(move _11) -> [0: bb13, otherwise: bb12];
    }

    bb12: {
        _0 = move _3;
        goto -> bb14;
    }

    bb13: {
        _0 = move _4;
        goto -> bb14;
    }

    bb14: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::mmap_choice::{closure#0}(_1: &mut {closure@crates/core/args.rs:1210:57: 1210:60}, _2: &PathBuf) -> bool {
    debug p => _2;
    let mut _0: bool;
    let _3: &std::path::Path;

    bb0: {
        _3 = <PathBuf as Deref>::deref(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::is_file(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;
    let mut _4: u64;

    bb0: {
        _3 = const "no-ignore";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb5;
    }

    bb3: {
        _4 = args::ArgMatches::unrestricted_count(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Ge(move _4, const 1_u64);
        goto -> bb5;
    }

    bb5: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_dot(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "no-ignore-dot";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = args::ArgMatches::no_ignore(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_exclude(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "no-ignore-exclude";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = args::ArgMatches::no_ignore(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_files(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: &str;

    bb0: {
        _2 = const "no-ignore-files";
        _0 = args::ArgMatches::is_present(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_global(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "no-ignore-global";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = args::ArgMatches::no_ignore(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_parent(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "no-ignore-parent";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = args::ArgMatches::no_ignore(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::no_ignore_vcs(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "no-ignore-vcs";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb4;
    }

    bb3: {
        _0 = args::ArgMatches::no_ignore(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::output_kind(_1: &args::ArgMatches) -> OutputKind {
    debug self => _1;
    let mut _0: args::OutputKind;
    let mut _2: bool;
    let _3: &str;
    let mut _4: bool;
    let _5: &str;
    let _6: bool;
    let _7: bool;
    let mut _8: (bool, bool);
    let mut _10: bool;
    let _11: &str;
    let _12: &str;
    let mut _13: bool;
    scope 1 {
        debug count => _6;
        debug count_matches => _7;
        let _9: bool;
        scope 2 {
            debug summary => _9;
        }
    }

    bb0: {
        _3 = const "quiet";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = OutputKind::Summary;
        goto -> bb16;
    }

    bb3: {
        _5 = const "json";
        _4 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _4) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = OutputKind::JSON;
        goto -> bb16;
    }

    bb6: {
        _8 = args::ArgMatches::counts(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _6 = (_8.0: bool);
        _7 = (_8.1: bool);
        switchInt(_6) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        switchInt(_7) -> [0: bb9, otherwise: bb11];
    }

    bb9: {
        _11 = const "files-with-matches";
        _10 = args::ArgMatches::is_present(_1, _11) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _10) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _9 = const true;
        goto -> bb13;
    }

    bb12: {
        _12 = const "files-without-match";
        _9 = args::ArgMatches::is_present(_1, _12) -> [return: bb13, unwind continue];
    }

    bb13: {
        _13 = _9;
        switchInt(move _13) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _0 = OutputKind::Summary;
        goto -> bb16;
    }

    bb15: {
        _0 = OutputKind::Standard;
        goto -> bb16;
    }

    bb16: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::overrides(_1: &args::ArgMatches) -> std::result::Result<Override, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<ignore::overrides::Override, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::vec::Vec<std::string::String>;
    let _3: &str;
    let _5: &str;
    let mut _6: bool;
    let mut _7: &std::vec::Vec<std::string::String>;
    let mut _8: bool;
    let mut _9: &std::vec::Vec<std::string::String>;
    let mut _10: ignore::overrides::Override;
    let mut _12: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::path::PathBuf>;
    let mut _13: std::result::Result<std::path::PathBuf, std::boxed::Box<dyn std::error::Error>>;
    let mut _14: isize;
    let mut _17: bool;
    let _18: &str;
    let _19: &mut ignore::overrides::OverrideBuilder;
    let mut _20: std::result::Result<&mut ignore::overrides::OverrideBuilder, ignore::Error>;
    let mut _21: &mut ignore::overrides::OverrideBuilder;
    let mut _22: std::vec::IntoIter<std::string::String>;
    let mut _23: std::vec::Vec<std::string::String>;
    let mut _25: std::option::Option<std::string::String>;
    let mut _26: &mut std::vec::IntoIter<std::string::String>;
    let mut _27: isize;
    let mut _29: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>, &mut ignore::overrides::OverrideBuilder>;
    let mut _30: std::result::Result<&mut ignore::overrides::OverrideBuilder, ignore::Error>;
    let mut _31: &mut ignore::overrides::OverrideBuilder;
    let _32: &str;
    let _33: &std::string::String;
    let mut _34: isize;
    let _37: &mut ignore::overrides::OverrideBuilder;
    let mut _38: std::result::Result<&mut ignore::overrides::OverrideBuilder, ignore::Error>;
    let mut _39: &mut ignore::overrides::OverrideBuilder;
    let mut _40: std::vec::IntoIter<std::string::String>;
    let mut _41: std::vec::Vec<std::string::String>;
    let mut _43: std::option::Option<std::string::String>;
    let mut _44: &mut std::vec::IntoIter<std::string::String>;
    let mut _45: isize;
    let mut _47: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>, &mut ignore::overrides::OverrideBuilder>;
    let mut _48: std::result::Result<&mut ignore::overrides::OverrideBuilder, ignore::Error>;
    let mut _49: &mut ignore::overrides::OverrideBuilder;
    let _50: &str;
    let _51: &std::string::String;
    let mut _52: isize;
    let mut _55: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>, ignore::overrides::Override>;
    let mut _56: std::result::Result<ignore::overrides::Override, ignore::Error>;
    let mut _57: &ignore::overrides::OverrideBuilder;
    let mut _58: isize;
    let mut _61: bool;
    let mut _62: bool;
    scope 1 {
        debug globs => _2;
        let _4: std::vec::Vec<std::string::String>;
        scope 2 {
            debug iglobs => _4;
            let mut _11: ignore::overrides::OverrideBuilder;
            let _15: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _16: std::path::PathBuf;
            scope 3 {
                debug builder => _11;
                let mut _24: std::vec::IntoIter<std::string::String>;
                let mut _42: std::vec::IntoIter<std::string::String>;
                let _59: std::result::Result<std::convert::Infallible, ignore::Error>;
                let _60: ignore::overrides::Override;
                scope 8 {
                    debug iter => _24;
                    let _28: std::string::String;
                    scope 9 {
                        debug glob => _28;
                        let _35: std::result::Result<std::convert::Infallible, ignore::Error>;
                        let _36: &mut ignore::overrides::OverrideBuilder;
                        scope 10 {
                            debug residual => _35;
                            scope 11 {
                            }
                        }
                        scope 12 {
                            debug val => _36;
                            scope 13 {
                            }
                        }
                    }
                }
                scope 14 {
                    debug iter => _42;
                    let _46: std::string::String;
                    scope 15 {
                        debug glob => _46;
                        let _53: std::result::Result<std::convert::Infallible, ignore::Error>;
                        let _54: &mut ignore::overrides::OverrideBuilder;
                        scope 16 {
                            debug residual => _53;
                            scope 17 {
                            }
                        }
                        scope 18 {
                            debug val => _54;
                            scope 19 {
                            }
                        }
                    }
                }
                scope 20 {
                    debug residual => _59;
                    scope 21 {
                    }
                }
                scope 22 {
                    debug val => _60;
                    scope 23 {
                    }
                }
            }
            scope 4 {
                debug residual => _15;
                scope 5 {
                }
            }
            scope 6 {
                debug val => _16;
                scope 7 {
                }
            }
        }
    }

    bb0: {
        _62 = const false;
        _61 = const false;
        _3 = const "glob";
        _62 = const true;
        _2 = args::ArgMatches::values_of_lossy_vec(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = const "iglob";
        _4 = args::ArgMatches::values_of_lossy_vec(_1, _5) -> [return: bb2, unwind: bb71];
    }

    bb2: {
        _61 = const true;
        _7 = &_2;
        _6 = Vec::<std::string::String>::is_empty(move _7) -> [return: bb3, unwind: bb69];
    }

    bb3: {
        switchInt(move _6) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _9 = &_4;
        _8 = Vec::<std::string::String>::is_empty(move _9) -> [return: bb5, unwind: bb69];
    }

    bb5: {
        switchInt(move _8) -> [0: bb8, otherwise: bb6];
    }

    bb6: {
        _10 = Override::empty() -> [return: bb7, unwind: bb69];
    }

    bb7: {
        _0 = std::result::Result::<Override, Box<dyn std::error::Error>>::Ok(move _10);
        goto -> bb66;
    }

    bb8: {
        _13 = args::current_dir() -> [return: bb9, unwind: bb69];
    }

    bb9: {
        _12 = <std::result::Result<PathBuf, Box<dyn std::error::Error>> as Try>::branch(move _13) -> [return: bb10, unwind: bb69];
    }

    bb10: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb11, 1: bb13, otherwise: bb12];
    }

    bb11: {
        _16 = move ((_12 as Continue).0: std::path::PathBuf);
        _11 = OverrideBuilder::new::<PathBuf>(move _16) -> [return: bb14, unwind: bb69];
    }

    bb12: {
        unreachable;
    }

    bb13: {
        _15 = move ((_12 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _15) -> [return: bb72, unwind: bb69];
    }

    bb14: {
        _18 = const "glob-case-insensitive";
        _17 = args::ArgMatches::is_present(_1, _18) -> [return: bb15, unwind: bb63];
    }

    bb15: {
        switchInt(move _17) -> [0: bb18, otherwise: bb16];
    }

    bb16: {
        _21 = &mut _11;
        _20 = OverrideBuilder::case_insensitive(move _21, const true) -> [return: bb17, unwind: bb63];
    }

    bb17: {
        _19 = std::result::Result::<&mut OverrideBuilder, ignore::Error>::unwrap(move _20) -> [return: bb73, unwind: bb63];
    }

    bb18: {
        _62 = const false;
        _23 = move _2;
        _22 = <Vec<std::string::String> as IntoIterator>::into_iter(move _23) -> [return: bb19, unwind: bb63];
    }

    bb19: {
        _24 = move _22;
        goto -> bb20;
    }

    bb20: {
        _26 = &mut _24;
        _25 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_26) -> [return: bb21, unwind: bb62];
    }

    bb21: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb23, 1: bb22, otherwise: bb12];
    }

    bb22: {
        _28 = move ((_25 as Some).0: std::string::String);
        _31 = &mut _11;
        _33 = &_28;
        _32 = <std::string::String as Deref>::deref(_33) -> [return: bb24, unwind: bb61];
    }

    bb23: {
        drop(_24) -> [return: bb30, unwind: bb63];
    }

    bb24: {
        _30 = OverrideBuilder::add(move _31, _32) -> [return: bb25, unwind: bb61];
    }

    bb25: {
        _29 = <std::result::Result<&mut OverrideBuilder, ignore::Error> as Try>::branch(move _30) -> [return: bb26, unwind: bb61];
    }

    bb26: {
        _34 = discriminant(_29);
        switchInt(move _34) -> [0: bb27, 1: bb28, otherwise: bb12];
    }

    bb27: {
        _36 = move ((_29 as Continue).0: &mut ignore::overrides::OverrideBuilder);
        drop(_28) -> [return: bb20, unwind: bb62];
    }

    bb28: {
        _35 = move ((_29 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _35) -> [return: bb29, unwind: bb61];
    }

    bb29: {
        drop(_28) -> [return: bb53, unwind: bb62];
    }

    bb30: {
        _39 = &mut _11;
        _38 = OverrideBuilder::case_insensitive(move _39, const true) -> [return: bb31, unwind: bb63];
    }

    bb31: {
        _37 = std::result::Result::<&mut OverrideBuilder, ignore::Error>::unwrap(move _38) -> [return: bb32, unwind: bb63];
    }

    bb32: {
        _61 = const false;
        _41 = move _4;
        _40 = <Vec<std::string::String> as IntoIterator>::into_iter(move _41) -> [return: bb33, unwind: bb63];
    }

    bb33: {
        _42 = move _40;
        goto -> bb34;
    }

    bb34: {
        _44 = &mut _42;
        _43 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_44) -> [return: bb35, unwind: bb60];
    }

    bb35: {
        _45 = discriminant(_43);
        switchInt(move _45) -> [0: bb37, 1: bb36, otherwise: bb12];
    }

    bb36: {
        _46 = move ((_43 as Some).0: std::string::String);
        _49 = &mut _11;
        _51 = &_46;
        _50 = <std::string::String as Deref>::deref(_51) -> [return: bb38, unwind: bb59];
    }

    bb37: {
        drop(_42) -> [return: bb44, unwind: bb63];
    }

    bb38: {
        _48 = OverrideBuilder::add(move _49, _50) -> [return: bb39, unwind: bb59];
    }

    bb39: {
        _47 = <std::result::Result<&mut OverrideBuilder, ignore::Error> as Try>::branch(move _48) -> [return: bb40, unwind: bb59];
    }

    bb40: {
        _52 = discriminant(_47);
        switchInt(move _52) -> [0: bb41, 1: bb42, otherwise: bb12];
    }

    bb41: {
        _54 = move ((_47 as Continue).0: &mut ignore::overrides::OverrideBuilder);
        drop(_46) -> [return: bb34, unwind: bb60];
    }

    bb42: {
        _53 = move ((_47 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _53) -> [return: bb43, unwind: bb59];
    }

    bb43: {
        drop(_46) -> [return: bb52, unwind: bb60];
    }

    bb44: {
        _57 = &_11;
        _56 = OverrideBuilder::build(move _57) -> [return: bb45, unwind: bb63];
    }

    bb45: {
        _55 = <std::result::Result<Override, ignore::Error> as Try>::branch(move _56) -> [return: bb46, unwind: bb63];
    }

    bb46: {
        _58 = discriminant(_55);
        switchInt(move _58) -> [0: bb47, 1: bb48, otherwise: bb12];
    }

    bb47: {
        _60 = move ((_55 as Continue).0: ignore::overrides::Override);
        _0 = std::result::Result::<Override, Box<dyn std::error::Error>>::Ok(move _60);
        drop(_11) -> [return: bb50, unwind continue];
    }

    bb48: {
        _59 = move ((_55 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _59) -> [return: bb49, unwind: bb58];
    }

    bb49: {
        drop(_11) -> [return: bb51, unwind continue];
    }

    bb50: {
        _61 = const false;
        _62 = const false;
        goto -> bb57;
    }

    bb51: {
        _61 = const false;
        _62 = const false;
        goto -> bb57;
    }

    bb52: {
        drop(_42) -> [return: bb54, unwind: bb63];
    }

    bb53: {
        drop(_24) -> [return: bb54, unwind: bb63];
    }

    bb54: {
        drop(_11) -> [return: bb66, unwind: bb69];
    }

    bb55: {
        _61 = const false;
        switchInt(_62) -> [0: bb56, otherwise: bb67];
    }

    bb56: {
        _62 = const false;
        goto -> bb57;
    }

    bb57: {
        return;
    }

    bb58 (cleanup): {
        drop(_11) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_46) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_42) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_28) -> [return: bb62, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        drop(_24) -> [return: bb63, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        drop(_11) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb64 (cleanup): {
        resume;
    }

    bb65: {
        drop(_4) -> [return: bb55, unwind: bb71];
    }

    bb66: {
        switchInt(_61) -> [0: bb55, otherwise: bb65];
    }

    bb67: {
        drop(_2) -> [return: bb56, unwind continue];
    }

    bb68 (cleanup): {
        drop(_4) -> [return: bb71, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        switchInt(_61) -> [0: bb71, otherwise: bb68];
    }

    bb70 (cleanup): {
        drop(_2) -> [return: bb64, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        switchInt(_62) -> [0: bb64, otherwise: bb70];
    }

    bb72: {
        goto -> bb66;
    }

    bb73: {
        goto -> bb18;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::paths(_1: &args::ArgMatches) -> Vec<PathBuf> {
    debug self => _1;
    let mut _0: std::vec::Vec<std::path::PathBuf>;
    let mut _2: std::vec::Vec<std::path::PathBuf>;
    let mut _3: std::option::Option<clap::OsValues<'_>>;
    let _4: &str;
    let mut _5: isize;
    let _6: clap::OsValues<'_>;
    let mut _7: std::iter::Map<clap::OsValues<'_>, {closure@crates/core/args.rs:1310:38: 1310:41}>;
    let mut _8: bool;
    let _9: &str;
    let mut _10: bool;
    let _11: &str;
    let mut _12: bool;
    let _13: &str;
    let mut _14: std::option::Option<&std::ffi::OsStr>;
    let _15: &str;
    let mut _16: isize;
    let _18: ();
    let mut _19: &mut std::vec::Vec<std::path::PathBuf>;
    let mut _20: std::path::PathBuf;
    let _21: &std::path::Path;
    scope 1 {
        debug paths => _2;
        scope 3 {
            debug path => _17;
            let _17: &std::ffi::OsStr;
        }
    }
    scope 2 {
        debug paths => _6;
    }

    bb0: {
        _4 = const "path";
        _3 = args::ArgMatches::values_of_os(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Some).0: clap::OsValues<'_>);
        _7 = <OsValues<'_> as Iterator>::map::<PathBuf, {closure@crates/core/args.rs:1310:38: 1310:41}>(move _6, const ZeroSized: {closure@crates/core/args.rs:1310:38: 1310:41}) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _2 = Vec::<PathBuf>::new() -> [return: bb6, unwind continue];
    }

    bb5: {
        _2 = <std::iter::Map<OsValues<'_>, {closure@crates/core/args.rs:1310:38: 1310:41}> as Iterator>::collect::<Vec<PathBuf>>(move _7) -> [return: bb6, unwind continue];
    }

    bb6: {
        _9 = const "file";
        _8 = args::ArgMatches::is_present(_1, _9) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        switchInt(move _8) -> [0: bb8, otherwise: bb12];
    }

    bb8: {
        _11 = const "files";
        _10 = args::ArgMatches::is_present(_1, _11) -> [return: bb9, unwind: bb18];
    }

    bb9: {
        switchInt(move _10) -> [0: bb10, otherwise: bb12];
    }

    bb10: {
        _13 = const "regexp";
        _12 = args::ArgMatches::is_present(_1, _13) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        switchInt(move _12) -> [0: bb17, otherwise: bb12];
    }

    bb12: {
        _15 = const "pattern";
        _14 = args::ArgMatches::value_of_os(_1, _15) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [1: bb14, otherwise: bb17];
    }

    bb14: {
        _17 = ((_14 as Some).0: &std::ffi::OsStr);
        _19 = &mut _2;
        _21 = Path::new::<OsStr>(_17) -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _20 = Path::to_path_buf(_21) -> [return: bb16, unwind: bb18];
    }

    bb16: {
        _18 = Vec::<PathBuf>::insert(move _19, const 0_usize, move _20) -> [return: bb20, unwind: bb18];
    }

    bb17: {
        _0 = move _2;
        return;
    }

    bb18 (cleanup): {
        drop(_2) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20: {
        goto -> bb17;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::paths::{closure#0}(_1: &mut {closure@crates/core/args.rs:1310:38: 1310:41}, _2: &OsStr) -> PathBuf {
    debug p => _2;
    let mut _0: std::path::PathBuf;
    let _3: &std::path::Path;

    bb0: {
        _3 = Path::new::<OsStr>(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Path::to_path_buf(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::path_default(_1: &args::ArgMatches) -> PathBuf {
    debug self => _1;
    let mut _0: std::path::PathBuf;
    let _2: bool;
    let mut _3: std::option::Option<clap::OsValues<'_>>;
    let _4: &str;
    let mut _6: bool;
    let mut _7: bool;
    let _8: &str;
    let mut _9: bool;
    let _10: &str;
    let mut _11: bool;
    let _12: &str;
    let _13: &str;
    let mut _14: bool;
    let _15: &std::path::Path;
    let _16: &str;
    let _17: &std::path::Path;
    let _18: &str;
    scope 1 {
        debug file_is_stdin => _2;
        let _5: bool;
        scope 2 {
            debug search_cwd => _5;
        }
    }

    bb0: {
        _4 = const "file";
        _3 = args::ArgMatches::values_of_os(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<OsValues<'_>>::map_or::<bool, {closure@crates/core/args.rs:1331:28: 1331:39}>(move _3, const false, const ZeroSized: {closure@crates/core/args.rs:1331:28: 1331:39}) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = is_readable_stdin() -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _6) -> [0: bb11, otherwise: bb4];
    }

    bb4: {
        _8 = const "file";
        _7 = args::ArgMatches::is_present(_1, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        switchInt(_2) -> [0: bb7, otherwise: bb11];
    }

    bb7: {
        _10 = const "files";
        _9 = args::ArgMatches::is_present(_1, _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _9) -> [0: bb9, otherwise: bb11];
    }

    bb9: {
        _12 = const "type-list";
        _11 = args::ArgMatches::is_present(_1, _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        switchInt(move _11) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _5 = const true;
        goto -> bb13;
    }

    bb12: {
        _13 = const "pcre2-version";
        _5 = args::ArgMatches::is_present(_1, _13) -> [return: bb13, unwind continue];
    }

    bb13: {
        _14 = _5;
        switchInt(move _14) -> [0: bb16, otherwise: bb14];
    }

    bb14: {
        _16 = const "./";
        _15 = Path::new::<str>(_16) -> [return: bb15, unwind continue];
    }

    bb15: {
        _0 = Path::to_path_buf(_15) -> [return: bb18, unwind continue];
    }

    bb16: {
        _18 = const "-";
        _17 = Path::new::<str>(_18) -> [return: bb17, unwind continue];
    }

    bb17: {
        _0 = Path::to_path_buf(_17) -> [return: bb18, unwind continue];
    }

    bb18: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::path_default::{closure#0}(_1: {closure@crates/core/args.rs:1331:28: 1331:39}, _2: OsValues<'_>) -> bool {
    debug files => _2;
    let mut _0: bool;
    let mut _3: &mut clap::OsValues<'_>;

    bb0: {
        _3 = &mut _2;
        _0 = <OsValues<'_> as Iterator>::any::<{closure@crates/core/args.rs:1331:50: 1331:53}>(move _3, const ZeroSized: {closure@crates/core/args.rs:1331:50: 1331:53}) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::path_default::{closure#0}::{closure#0}(_1: &mut {closure@crates/core/args.rs:1331:50: 1331:53}, _2: &OsStr) -> bool {
    debug f => _2;
    let mut _0: bool;
    let mut _3: &&std::ffi::OsStr;
    let mut _4: &&str;

    bb0: {
        _3 = &_2;
        _4 = const _;
        _0 = <&OsStr as PartialEq<&str>>::eq(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::path_default::{closure#0}::{closure#0}: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "-";
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::path_separator(_1: &args::ArgMatches) -> std::result::Result<Option<u8>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<u8>, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::vec::Vec<u8>;
    let mut _3: std::option::Option<&std::ffi::OsStr>;
    let _4: &str;
    let mut _5: isize;
    let mut _6: std::option::Option<u8>;
    let _7: &std::ffi::OsStr;
    let _8: &&std::ffi::OsStr;
    let mut _9: bool;
    let mut _10: &std::vec::Vec<u8>;
    let mut _11: std::option::Option<u8>;
    let mut _12: bool;
    let mut _13: usize;
    let mut _14: &std::vec::Vec<u8>;
    let mut _15: std::boxed::Box<dyn std::error::Error>;
    let mut _16: std::string::String;
    let mut _18: std::fmt::Arguments<'_>;
    let mut _19: &[&str];
    let mut _20: &[core::fmt::rt::Argument<'_>];
    let _21: &[core::fmt::rt::Argument<'_>; 2];
    let _22: [core::fmt::rt::Argument<'_>; 2];
    let mut _23: core::fmt::rt::Argument<'_>;
    let _24: &usize;
    let _25: usize;
    let mut _26: &std::vec::Vec<u8>;
    let mut _27: core::fmt::rt::Argument<'_>;
    let _28: &std::string::String;
    let _29: std::string::String;
    let _30: &[u8];
    let _31: &std::vec::Vec<u8>;
    let mut _32: std::option::Option<u8>;
    let mut _33: u8;
    let mut _34: &u8;
    let mut _35: &std::vec::Vec<u8>;
    let mut _37: &std::ffi::OsStr;
    scope 1 {
        debug sep => _2;
        let _17: std::string::String;
        let mut _36: &[&str; 3];
        scope 3 {
            debug res => _17;
        }
    }
    scope 2 {
        debug sep => _7;
    }

    bb0: {
        _4 = const "path-separator";
        _3 = args::ArgMatches::value_of_os(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = ((_3 as Some).0: &std::ffi::OsStr);
        _8 = &_7;
        _37 = deref_copy (*_8);
        _2 = unescape_os(_37) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = Option::<u8>::None;
        _0 = std::result::Result::<Option<u8>, Box<dyn std::error::Error>>::Ok(move _6);
        goto -> bb23;
    }

    bb5: {
        _10 = &_2;
        _9 = Vec::<u8>::is_empty(move _10) -> [return: bb6, unwind: bb26];
    }

    bb6: {
        switchInt(move _9) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _11 = Option::<u8>::None;
        _0 = std::result::Result::<Option<u8>, Box<dyn std::error::Error>>::Ok(move _11);
        goto -> bb22;
    }

    bb8: {
        _14 = &_2;
        _13 = Vec::<u8>::len(move _14) -> [return: bb9, unwind: bb26];
    }

    bb9: {
        _12 = Gt(move _13, const 1_usize);
        switchInt(move _12) -> [0: bb20, otherwise: bb10];
    }

    bb10: {
        _36 = const _;
        _19 = _36 as &[&str] (PointerCoercion(Unsize));
        _26 = &_2;
        _25 = Vec::<u8>::len(move _26) -> [return: bb11, unwind: bb26];
    }

    bb11: {
        _24 = &_25;
        _23 = core::fmt::rt::Argument::<'_>::new_display::<usize>(_24) -> [return: bb12, unwind: bb26];
    }

    bb12: {
        _31 = &_2;
        _30 = <Vec<u8> as Deref>::deref(_31) -> [return: bb13, unwind: bb26];
    }

    bb13: {
        _29 = grep::grep_cli::escape(_30) -> [return: bb14, unwind: bb26];
    }

    bb14: {
        _28 = &_29;
        _27 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_28) -> [return: bb15, unwind: bb25];
    }

    bb15: {
        _22 = [move _23, move _27];
        _21 = &_22;
        _20 = _21 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _18 = Arguments::<'_>::new_v1(move _19, move _20) -> [return: bb16, unwind: bb25];
    }

    bb16: {
        _17 = format(move _18) -> [return: bb17, unwind: bb25];
    }

    bb17: {
        drop(_29) -> [return: bb18, unwind: bb24];
    }

    bb18: {
        _16 = move _17;
        _15 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _16) -> [return: bb19, unwind: bb26];
    }

    bb19: {
        _0 = std::result::Result::<Option<u8>, Box<dyn std::error::Error>>::Err(move _15);
        goto -> bb22;
    }

    bb20: {
        _35 = &_2;
        _34 = <Vec<u8> as std::ops::Index<usize>>::index(move _35, const 0_usize) -> [return: bb21, unwind: bb26];
    }

    bb21: {
        _33 = (*_34);
        _32 = Option::<u8>::Some(move _33);
        _0 = std::result::Result::<Option<u8>, Box<dyn std::error::Error>>::Ok(move _32);
        goto -> bb22;
    }

    bb22: {
        drop(_2) -> [return: bb23, unwind continue];
    }

    bb23: {
        return;
    }

    bb24 (cleanup): {
        drop(_17) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        drop(_29) -> [return: bb26, unwind terminate(cleanup)];
    }

    bb26 (cleanup): {
        drop(_2) -> [return: bb27, unwind terminate(cleanup)];
    }

    bb27 (cleanup): {
        resume;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::path_separator: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "A path separator must be exactly one byte, but the given separator is ", const " bytes: ", const "\nIn some shells on Windows '/' is automatically expanded. Use '//' instead."];
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::path_terminator(_1: &args::ArgMatches) -> Option<u8> {
    debug self => _1;
    let mut _0: std::option::Option<u8>;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "null";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = Option::<u8>::Some(const 0_u8);
        goto -> bb4;
    }

    bb3: {
        _0 = Option::<u8>::None;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::field_context_separator(_1: &args::ArgMatches) -> Vec<u8> {
    debug self => _1;
    let mut _0: std::vec::Vec<u8>;
    let mut _2: std::option::Option<&std::ffi::OsStr>;
    let _3: &str;
    let mut _4: isize;
    let mut _5: &[u8];
    let _6: &[u8; 1];
    let _7: &std::ffi::OsStr;
    let _8: &&std::ffi::OsStr;
    let mut _9: &std::ffi::OsStr;
    scope 1 {
        debug sep => _7;
    }

    bb0: {
        _3 = const "field-context-separator";
        _2 = args::ArgMatches::value_of_os(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = ((_2 as Some).0: &std::ffi::OsStr);
        _8 = &_7;
        _9 = deref_copy (*_8);
        _0 = unescape_os(_9) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = const b"-";
        _5 = _6 as &[u8] (PointerCoercion(Unsize));
        _0 = slice::<impl [u8]>::to_vec(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

alloc12 (size: 1, align: 1) {
    2d                                              │ -
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::field_match_separator(_1: &args::ArgMatches) -> Vec<u8> {
    debug self => _1;
    let mut _0: std::vec::Vec<u8>;
    let mut _2: std::option::Option<&std::ffi::OsStr>;
    let _3: &str;
    let mut _4: isize;
    let mut _5: &[u8];
    let _6: &[u8; 1];
    let _7: &std::ffi::OsStr;
    let _8: &&std::ffi::OsStr;
    let mut _9: &std::ffi::OsStr;
    scope 1 {
        debug sep => _7;
    }

    bb0: {
        _3 = const "field-match-separator";
        _2 = args::ArgMatches::value_of_os(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = ((_2 as Some).0: &std::ffi::OsStr);
        _8 = &_7;
        _9 = deref_copy (*_8);
        _0 = unescape_os(_9) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = const b":";
        _5 = _6 as &[u8] (PointerCoercion(Unsize));
        _0 = slice::<impl [u8]>::to_vec(move _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

alloc13 (size: 1, align: 1) {
    3a                                              │ :
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::patterns(_1: &args::ArgMatches) -> std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::vec::Vec<std::string::String>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let mut _3: &args::ArgMatches;
    let _4: &str;
    let mut _5: bool;
    let mut _6: &args::ArgMatches;
    let _7: &str;
    let mut _8: std::vec::Vec<std::string::String>;
    let mut _9: std::vec::Vec<std::string::String>;
    let mut _10: std::option::Option<clap::OsValues<'_>>;
    let mut _11: &args::ArgMatches;
    let _12: &str;
    let mut _13: isize;
    let mut _14: bool;
    let mut _15: &std::option::Option<clap::OsValues<'_>>;
    let _16: std::option::Option<clap::OsValues<'_>>;
    let mut _17: &args::ArgMatches;
    let _18: &str;
    let mut _19: std::option::Option<&std::ffi::OsStr>;
    let mut _20: &args::ArgMatches;
    let _21: &str;
    let mut _22: isize;
    let _24: ();
    let mut _25: &mut std::vec::Vec<std::string::String>;
    let mut _26: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::string::String>;
    let mut _27: std::result::Result<std::string::String, std::boxed::Box<dyn std::error::Error>>;
    let mut _28: &args::ArgMatches;
    let mut _29: isize;
    let mut _33: clap::OsValues<'_>;
    let mut _35: std::option::Option<&std::ffi::OsStr>;
    let mut _36: &mut clap::OsValues<'_>;
    let mut _37: isize;
    let _39: ();
    let mut _40: &mut std::vec::Vec<std::string::String>;
    let mut _41: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::string::String>;
    let mut _42: std::result::Result<std::string::String, std::boxed::Box<dyn std::error::Error>>;
    let mut _43: &args::ArgMatches;
    let mut _44: isize;
    let mut _47: std::option::Option<clap::OsValues<'_>>;
    let mut _48: &args::ArgMatches;
    let _49: &str;
    let mut _50: isize;
    let mut _52: clap::OsValues<'_>;
    let mut _54: std::option::Option<&std::ffi::OsStr>;
    let mut _55: &mut clap::OsValues<'_>;
    let mut _56: isize;
    let mut _58: bool;
    let mut _59: &&std::ffi::OsStr;
    let _60: ();
    let mut _61: &mut std::vec::Vec<std::string::String>;
    let mut _62: std::iter::Map<std::vec::IntoIter<std::string::String>, {closure@crates/core/args.rs:1433:34: 1433:37}>;
    let mut _63: std::vec::IntoIter<std::string::String>;
    let mut _64: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::vec::Vec<std::string::String>>;
    let mut _65: std::result::Result<std::vec::Vec<std::string::String>, std::io::Error>;
    let mut _66: isize;
    let mut _69: {closure@crates/core/args.rs:1433:34: 1433:37};
    let mut _70: &&args::ArgMatches;
    let _71: ();
    let mut _72: &mut std::vec::Vec<std::string::String>;
    let mut _73: std::iter::Map<std::vec::IntoIter<std::string::String>, {closure@crates/core/args.rs:1439:34: 1439:37}>;
    let mut _74: std::vec::IntoIter<std::string::String>;
    let mut _75: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::vec::Vec<std::string::String>>;
    let mut _76: std::result::Result<std::vec::Vec<std::string::String>, std::io::Error>;
    let mut _77: &std::ffi::OsStr;
    let mut _78: isize;
    let mut _81: {closure@crates/core/args.rs:1439:34: 1439:37};
    let mut _82: &&args::ArgMatches;
    let mut _83: std::vec::Vec<std::string::String>;
    scope 1 {
        debug pats => _9;
        let _32: clap::OsValues<'_>;
        scope 2 {
            debug os_pat => _23;
            let _23: &std::ffi::OsStr;
            let _30: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _31: std::string::String;
            scope 3 {
                debug residual => _30;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _31;
                scope 6 {
                }
            }
        }
        scope 7 {
            debug os_pats => _32;
            let mut _34: clap::OsValues<'_>;
            scope 8 {
                debug iter => _34;
                let _38: &std::ffi::OsStr;
                scope 9 {
                    debug os_pat => _38;
                    let _45: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                    let _46: std::string::String;
                    scope 10 {
                        debug residual => _45;
                        scope 11 {
                        }
                    }
                    scope 12 {
                        debug val => _46;
                        scope 13 {
                        }
                    }
                }
            }
        }
        scope 14 {
            debug paths => _51;
            let _51: clap::OsValues<'_>;
            let mut _53: clap::OsValues<'_>;
            scope 15 {
                debug iter => _53;
                let _57: &std::ffi::OsStr;
                scope 16 {
                    debug path => _57;
                    let _67: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let _68: std::vec::Vec<std::string::String>;
                    let _79: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let _80: std::vec::Vec<std::string::String>;
                    let mut _84: &&str;
                    scope 17 {
                        debug residual => _67;
                        scope 18 {
                        }
                    }
                    scope 19 {
                        debug val => _68;
                        scope 20 {
                        }
                    }
                    scope 21 {
                        debug residual => _79;
                        scope 22 {
                        }
                    }
                    scope 23 {
                        debug val => _80;
                        scope 24 {
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _3 = _1;
        _4 = const "files";
        _2 = args::ArgMatches::is_present(move _3, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb2, otherwise: bb4];
    }

    bb2: {
        _6 = _1;
        _7 = const "type-list";
        _5 = args::ArgMatches::is_present(move _6, _7) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb6, otherwise: bb4];
    }

    bb4: {
        _8 = Vec::<std::string::String>::new() -> [return: bb5, unwind continue];
    }

    bb5: {
        _0 = std::result::Result::<Vec<std::string::String>, Box<dyn std::error::Error>>::Ok(move _8);
        goto -> bb53;
    }

    bb6: {
        _9 = Vec::<std::string::String>::new() -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = _1;
        _12 = const "regexp";
        _10 = args::ArgMatches::values_of_os(move _11, _12) -> [return: bb8, unwind: bb54];
    }

    bb8: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _32 = move ((_10 as Some).0: clap::OsValues<'_>);
        _33 = <OsValues<'_> as IntoIterator>::into_iter(move _32) -> [return: bb21, unwind: bb54];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _17 = _1;
        _18 = const "file";
        _16 = args::ArgMatches::values_of_os(move _17, _18) -> [return: bb12, unwind: bb54];
    }

    bb12: {
        _15 = &_16;
        _14 = Option::<OsValues<'_>>::is_none(move _15) -> [return: bb13, unwind: bb54];
    }

    bb13: {
        switchInt(move _14) -> [0: bb29, otherwise: bb14];
    }

    bb14: {
        _20 = _1;
        _21 = const "pattern";
        _19 = args::ArgMatches::value_of_os(move _20, _21) -> [return: bb15, unwind: bb54];
    }

    bb15: {
        _22 = discriminant(_19);
        switchInt(move _22) -> [1: bb16, otherwise: bb29];
    }

    bb16: {
        _23 = ((_19 as Some).0: &std::ffi::OsStr);
        _25 = &mut _9;
        _28 = _1;
        _27 = args::ArgMatches::pattern_from_os_str(move _28, _23) -> [return: bb17, unwind: bb54];
    }

    bb17: {
        _26 = <std::result::Result<std::string::String, Box<dyn std::error::Error>> as Try>::branch(move _27) -> [return: bb18, unwind: bb54];
    }

    bb18: {
        _29 = discriminant(_26);
        switchInt(move _29) -> [0: bb19, 1: bb20, otherwise: bb10];
    }

    bb19: {
        _31 = move ((_26 as Continue).0: std::string::String);
        _24 = Vec::<std::string::String>::push(move _25, move _31) -> [return: bb56, unwind: bb54];
    }

    bb20: {
        _30 = move ((_26 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _30) -> [return: bb57, unwind: bb54];
    }

    bb21: {
        _34 = move _33;
        goto -> bb22;
    }

    bb22: {
        _36 = &mut _34;
        _35 = <OsValues<'_> as Iterator>::next(_36) -> [return: bb23, unwind: bb54];
    }

    bb23: {
        _37 = discriminant(_35);
        switchInt(move _37) -> [0: bb29, 1: bb24, otherwise: bb10];
    }

    bb24: {
        _38 = ((_35 as Some).0: &std::ffi::OsStr);
        _40 = &mut _9;
        _43 = _1;
        _42 = args::ArgMatches::pattern_from_os_str(move _43, _38) -> [return: bb25, unwind: bb54];
    }

    bb25: {
        _41 = <std::result::Result<std::string::String, Box<dyn std::error::Error>> as Try>::branch(move _42) -> [return: bb26, unwind: bb54];
    }

    bb26: {
        _44 = discriminant(_41);
        switchInt(move _44) -> [0: bb27, 1: bb28, otherwise: bb10];
    }

    bb27: {
        _46 = move ((_41 as Continue).0: std::string::String);
        _39 = Vec::<std::string::String>::push(move _40, move _46) -> [return: bb58, unwind: bb54];
    }

    bb28: {
        _45 = move ((_41 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _45) -> [return: bb59, unwind: bb54];
    }

    bb29: {
        _48 = _1;
        _49 = const "file";
        _47 = args::ArgMatches::values_of_os(move _48, _49) -> [return: bb30, unwind: bb54];
    }

    bb30: {
        _50 = discriminant(_47);
        switchInt(move _50) -> [1: bb31, otherwise: bb51];
    }

    bb31: {
        _51 = move ((_47 as Some).0: clap::OsValues<'_>);
        _52 = <OsValues<'_> as IntoIterator>::into_iter(move _51) -> [return: bb32, unwind: bb54];
    }

    bb32: {
        _53 = move _52;
        goto -> bb33;
    }

    bb33: {
        _55 = &mut _53;
        _54 = <OsValues<'_> as Iterator>::next(_55) -> [return: bb34, unwind: bb54];
    }

    bb34: {
        _56 = discriminant(_54);
        switchInt(move _56) -> [0: bb51, 1: bb35, otherwise: bb10];
    }

    bb35: {
        _57 = ((_54 as Some).0: &std::ffi::OsStr);
        _59 = &_57;
        _84 = const _;
        _58 = <&OsStr as PartialEq<&str>>::eq(move _59, _84) -> [return: bb36, unwind: bb54];
    }

    bb36: {
        switchInt(move _58) -> [0: bb44, otherwise: bb37];
    }

    bb37: {
        _61 = &mut _9;
        _65 = patterns_from_stdin() -> [return: bb38, unwind: bb54];
    }

    bb38: {
        _64 = <std::result::Result<Vec<std::string::String>, std::io::Error> as Try>::branch(move _65) -> [return: bb39, unwind: bb54];
    }

    bb39: {
        _66 = discriminant(_64);
        switchInt(move _66) -> [0: bb40, 1: bb41, otherwise: bb10];
    }

    bb40: {
        _68 = move ((_64 as Continue).0: std::vec::Vec<std::string::String>);
        _63 = <Vec<std::string::String> as IntoIterator>::into_iter(move _68) -> [return: bb42, unwind: bb54];
    }

    bb41: {
        _67 = move ((_64 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _67) -> [return: bb60, unwind: bb54];
    }

    bb42: {
        _70 = &_1;
        _69 = {closure@crates/core/args.rs:1433:34: 1433:37} { self: move _70 };
        _62 = <std::vec::IntoIter<std::string::String> as Iterator>::map::<std::string::String, {closure@crates/core/args.rs:1433:34: 1433:37}>(move _63, move _69) -> [return: bb43, unwind: bb54];
    }

    bb43: {
        _60 = <Vec<std::string::String> as Extend<std::string::String>>::extend::<std::iter::Map<std::vec::IntoIter<std::string::String>, {closure@crates/core/args.rs:1433:34: 1433:37}>>(move _61, move _62) -> [return: bb61, unwind: bb54];
    }

    bb44: {
        _72 = &mut _9;
        _77 = _57;
        _76 = patterns_from_path::<&OsStr>(move _77) -> [return: bb45, unwind: bb54];
    }

    bb45: {
        _75 = <std::result::Result<Vec<std::string::String>, std::io::Error> as Try>::branch(move _76) -> [return: bb46, unwind: bb54];
    }

    bb46: {
        _78 = discriminant(_75);
        switchInt(move _78) -> [0: bb47, 1: bb48, otherwise: bb10];
    }

    bb47: {
        _80 = move ((_75 as Continue).0: std::vec::Vec<std::string::String>);
        _74 = <Vec<std::string::String> as IntoIterator>::into_iter(move _80) -> [return: bb49, unwind: bb54];
    }

    bb48: {
        _79 = move ((_75 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<Vec<std::string::String>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _79) -> [return: bb62, unwind: bb54];
    }

    bb49: {
        _82 = &_1;
        _81 = {closure@crates/core/args.rs:1439:34: 1439:37} { self: move _82 };
        _73 = <std::vec::IntoIter<std::string::String> as Iterator>::map::<std::string::String, {closure@crates/core/args.rs:1439:34: 1439:37}>(move _74, move _81) -> [return: bb50, unwind: bb54];
    }

    bb50: {
        _71 = <Vec<std::string::String> as Extend<std::string::String>>::extend::<std::iter::Map<std::vec::IntoIter<std::string::String>, {closure@crates/core/args.rs:1439:34: 1439:37}>>(move _72, move _73) -> [return: bb63, unwind: bb54];
    }

    bb51: {
        _83 = move _9;
        _0 = std::result::Result::<Vec<std::string::String>, Box<dyn std::error::Error>>::Ok(move _83);
        goto -> bb53;
    }

    bb52: {
        drop(_9) -> [return: bb53, unwind continue];
    }

    bb53: {
        return;
    }

    bb54 (cleanup): {
        drop(_9) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        resume;
    }

    bb56: {
        goto -> bb29;
    }

    bb57: {
        goto -> bb52;
    }

    bb58: {
        goto -> bb22;
    }

    bb59: {
        goto -> bb52;
    }

    bb60: {
        goto -> bb52;
    }

    bb61: {
        goto -> bb33;
    }

    bb62: {
        goto -> bb52;
    }

    bb63: {
        goto -> bb33;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::patterns: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "-";
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::patterns::{closure#0}(_1: &mut {closure@crates/core/args.rs:1433:34: 1433:37}, _2: std::string::String) -> std::string::String {
    debug p => _2;
    debug self => (*((*_1).0: &&args::ArgMatches));
    let mut _0: std::string::String;
    let mut _3: &&args::ArgMatches;
    let mut _4: &args::ArgMatches;

    bb0: {
        _3 = deref_copy ((*_1).0: &&args::ArgMatches);
        _4 = deref_copy (*_3);
        _0 = args::ArgMatches::pattern_from_string(_4, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::patterns::{closure#1}(_1: &mut {closure@crates/core/args.rs:1439:34: 1439:37}, _2: std::string::String) -> std::string::String {
    debug p => _2;
    debug self => (*((*_1).0: &&args::ArgMatches));
    let mut _0: std::string::String;
    let mut _3: &&args::ArgMatches;
    let mut _4: &args::ArgMatches;

    bb0: {
        _3 = deref_copy ((*_1).0: &&args::ArgMatches);
        _4 = deref_copy (*_3);
        _0 = args::ArgMatches::pattern_from_string(_4, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_empty(_1: &args::ArgMatches) -> std::string::String {
    debug self => _1;
    let mut _0: std::string::String;
    let _2: &str;

    bb0: {
        _2 = const "(?:z{0})*";
        _0 = <str as ToString>::to_string(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_from_os_str(_1: &args::ArgMatches, _2: &OsStr) -> std::result::Result<std::string::String, Box<dyn std::error::Error>> {
    debug self => _1;
    debug pat => _2;
    let mut _0: std::result::Result<std::string::String, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_cli::InvalidPatternError>, &str>;
    let mut _4: std::result::Result<&str, grep::grep_cli::InvalidPatternError>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, grep::grep_cli::InvalidPatternError>;
    let _7: &str;
    let mut _8: std::string::String;
    scope 1 {
        debug s => _7;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = pattern_from_os(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<&str, InvalidPatternError> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: &str);
        _8 = args::ArgMatches::pattern_from_str(_1, _7) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_cli::InvalidPatternError>);
        _0 = <std::result::Result<std::string::String, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, InvalidPatternError>>>::from_residual(move _6) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = std::result::Result::<std::string::String, Box<dyn std::error::Error>>::Ok(move _8);
        goto -> bb7;
    }

    bb7: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_from_str(_1: &args::ArgMatches, _2: &str) -> std::string::String {
    debug self => _1;
    debug pat => _2;
    let mut _0: std::string::String;
    let mut _3: std::string::String;

    bb0: {
        _3 = <str as ToString>::to_string(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = args::ArgMatches::pattern_from_string(_1, move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_from_string(_1: &args::ArgMatches, _2: std::string::String) -> std::string::String {
    debug self => _1;
    debug pat => _2;
    let mut _0: std::string::String;
    let _3: std::string::String;
    let mut _4: std::string::String;
    let mut _5: bool;
    let mut _6: &std::string::String;
    let mut _7: bool;
    scope 1 {
        debug pat => _3;
    }

    bb0: {
        _7 = const false;
        _4 = args::ArgMatches::pattern_literal(_1, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = args::ArgMatches::pattern_line(_1, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = const true;
        _6 = &_3;
        _5 = std::string::String::is_empty(move _6) -> [return: bb3, unwind: bb8];
    }

    bb3: {
        switchInt(move _5) -> [0: bb5, otherwise: bb4];
    }

    bb4: {
        _0 = args::ArgMatches::pattern_empty(_1) -> [return: bb11, unwind: bb8];
    }

    bb5: {
        _7 = const false;
        _0 = move _3;
        goto -> bb6;
    }

    bb6: {
        switchInt(_7) -> [0: bb7, otherwise: bb10];
    }

    bb7: {
        _7 = const false;
        return;
    }

    bb8 (cleanup): {
        drop(_3) -> [return: bb9, unwind terminate(cleanup)];
    }

    bb9 (cleanup): {
        resume;
    }

    bb10: {
        drop(_3) -> [return: bb7, unwind continue];
    }

    bb11: {
        goto -> bb6;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_line(_1: &args::ArgMatches, _2: std::string::String) -> std::string::String {
    debug self => _1;
    debug pat => _2;
    let mut _0: std::string::String;
    let mut _3: bool;
    let _4: &str;
    let _5: std::string::String;
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 1];
    let _10: [core::fmt::rt::Argument<'_>; 1];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &std::string::String;
    let mut _13: &[&str; 2];
    let mut _14: bool;
    scope 1 {
        debug res => _5;
    }

    bb0: {
        _14 = const false;
        _14 = const true;
        _4 = const "line-regexp";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind: bb9];
    }

    bb1: {
        switchInt(move _3) -> [0: bb6, otherwise: bb2];
    }

    bb2: {
        _13 = const _;
        _7 = _13 as &[&str] (PointerCoercion(Unsize));
        _12 = &_2;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_12) -> [return: bb3, unwind: bb9];
    }

    bb3: {
        _10 = [move _11];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_v1(move _7, move _8) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _5 = format(move _6) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _0 = move _5;
        goto -> bb7;
    }

    bb6: {
        _14 = const false;
        _0 = move _2;
        goto -> bb7;
    }

    bb7: {
        switchInt(_14) -> [0: bb8, otherwise: bb11];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_2) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }

    bb11: {
        drop(_2) -> [return: bb8, unwind continue];
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_line: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "^(?:", const ")$"];
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pattern_literal(_1: &args::ArgMatches, _2: std::string::String) -> std::string::String {
    debug self => _1;
    debug pat => _2;
    let mut _0: std::string::String;
    let mut _3: bool;
    let _4: &str;
    let _5: &str;
    let _6: &std::string::String;
    let mut _7: bool;

    bb0: {
        _7 = const false;
        _7 = const true;
        _4 = const "fixed-strings";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        switchInt(move _3) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _6 = &_2;
        _5 = <std::string::String as Deref>::deref(_6) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _0 = regex::escape(_5) -> [return: bb10, unwind: bb7];
    }

    bb4: {
        _7 = const false;
        _0 = move _2;
        goto -> bb5;
    }

    bb5: {
        switchInt(_7) -> [0: bb6, otherwise: bb9];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }

    bb9: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb10: {
        goto -> bb5;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::preprocessor(_1: &args::ArgMatches) -> Option<PathBuf> {
    debug self => _1;
    let mut _0: std::option::Option<std::path::PathBuf>;
    let mut _2: std::option::Option<&std::ffi::OsStr>;
    let _3: &str;
    let mut _4: isize;
    let _5: &std::ffi::OsStr;
    let mut _6: bool;
    let mut _7: std::path::PathBuf;
    let _8: &std::path::Path;
    scope 1 {
        debug path => _5;
    }
    scope 2 {
        debug path => _5;
    }

    bb0: {
        _3 = const "pre";
        _2 = args::ArgMatches::value_of_os(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _5 = ((_2 as Some).0: &std::ffi::OsStr);
        _6 = OsStr::is_empty(_5) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = Option::<PathBuf>::None;
        goto -> bb10;
    }

    bb5: {
        switchInt(move _6) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Option::<PathBuf>::None;
        goto -> bb10;
    }

    bb7: {
        _8 = Path::new::<OsStr>(_5) -> [return: bb8, unwind continue];
    }

    bb8: {
        _7 = Path::to_path_buf(_8) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = Option::<PathBuf>::Some(move _7);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::preprocessor_globs(_1: &args::ArgMatches) -> std::result::Result<Override, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<ignore::overrides::Override, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::vec::Vec<std::string::String>;
    let _3: &str;
    let mut _4: bool;
    let mut _5: &std::vec::Vec<std::string::String>;
    let mut _6: ignore::overrides::Override;
    let mut _8: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::path::PathBuf>;
    let mut _9: std::result::Result<std::path::PathBuf, std::boxed::Box<dyn std::error::Error>>;
    let mut _10: isize;
    let mut _13: std::vec::IntoIter<std::string::String>;
    let mut _14: std::vec::Vec<std::string::String>;
    let mut _16: std::option::Option<std::string::String>;
    let mut _17: &mut std::vec::IntoIter<std::string::String>;
    let mut _18: isize;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>, &mut ignore::overrides::OverrideBuilder>;
    let mut _21: std::result::Result<&mut ignore::overrides::OverrideBuilder, ignore::Error>;
    let mut _22: &mut ignore::overrides::OverrideBuilder;
    let _23: &str;
    let _24: &std::string::String;
    let mut _25: isize;
    let mut _28: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>, ignore::overrides::Override>;
    let mut _29: std::result::Result<ignore::overrides::Override, ignore::Error>;
    let mut _30: &ignore::overrides::OverrideBuilder;
    let mut _31: isize;
    let mut _34: bool;
    scope 1 {
        debug globs => _2;
        let mut _7: ignore::overrides::OverrideBuilder;
        let _11: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _12: std::path::PathBuf;
        scope 2 {
            debug builder => _7;
            let mut _15: std::vec::IntoIter<std::string::String>;
            let _32: std::result::Result<std::convert::Infallible, ignore::Error>;
            let _33: ignore::overrides::Override;
            scope 7 {
                debug iter => _15;
                let _19: std::string::String;
                scope 8 {
                    debug glob => _19;
                    let _26: std::result::Result<std::convert::Infallible, ignore::Error>;
                    let _27: &mut ignore::overrides::OverrideBuilder;
                    scope 9 {
                        debug residual => _26;
                        scope 10 {
                        }
                    }
                    scope 11 {
                        debug val => _27;
                        scope 12 {
                        }
                    }
                }
            }
            scope 13 {
                debug residual => _32;
                scope 14 {
                }
            }
            scope 15 {
                debug val => _33;
                scope 16 {
                }
            }
        }
        scope 3 {
            debug residual => _11;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _12;
            scope 6 {
            }
        }
    }

    bb0: {
        _34 = const false;
        _3 = const "pre-glob";
        _34 = const true;
        _2 = args::ArgMatches::values_of_lossy_vec(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &_2;
        _4 = Vec::<std::string::String>::is_empty(move _5) -> [return: bb2, unwind: bb43];
    }

    bb2: {
        switchInt(move _4) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _6 = Override::empty() -> [return: bb4, unwind: bb43];
    }

    bb4: {
        _0 = std::result::Result::<Override, Box<dyn std::error::Error>>::Ok(move _6);
        goto -> bb41;
    }

    bb5: {
        _9 = args::current_dir() -> [return: bb6, unwind: bb43];
    }

    bb6: {
        _8 = <std::result::Result<PathBuf, Box<dyn std::error::Error>> as Try>::branch(move _9) -> [return: bb7, unwind: bb43];
    }

    bb7: {
        _10 = discriminant(_8);
        switchInt(move _10) -> [0: bb8, 1: bb10, otherwise: bb9];
    }

    bb8: {
        _12 = move ((_8 as Continue).0: std::path::PathBuf);
        _7 = OverrideBuilder::new::<PathBuf>(move _12) -> [return: bb11, unwind: bb43];
    }

    bb9: {
        unreachable;
    }

    bb10: {
        _11 = move ((_8 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _11) -> [return: bb44, unwind: bb43];
    }

    bb11: {
        _34 = const false;
        _14 = move _2;
        _13 = <Vec<std::string::String> as IntoIterator>::into_iter(move _14) -> [return: bb12, unwind: bb38];
    }

    bb12: {
        _15 = move _13;
        goto -> bb13;
    }

    bb13: {
        _17 = &mut _15;
        _16 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_17) -> [return: bb14, unwind: bb37];
    }

    bb14: {
        _18 = discriminant(_16);
        switchInt(move _18) -> [0: bb16, 1: bb15, otherwise: bb9];
    }

    bb15: {
        _19 = move ((_16 as Some).0: std::string::String);
        _22 = &mut _7;
        _24 = &_19;
        _23 = <std::string::String as Deref>::deref(_24) -> [return: bb17, unwind: bb36];
    }

    bb16: {
        drop(_15) -> [return: bb23, unwind: bb38];
    }

    bb17: {
        _21 = OverrideBuilder::add(move _22, _23) -> [return: bb18, unwind: bb36];
    }

    bb18: {
        _20 = <std::result::Result<&mut OverrideBuilder, ignore::Error> as Try>::branch(move _21) -> [return: bb19, unwind: bb36];
    }

    bb19: {
        _25 = discriminant(_20);
        switchInt(move _25) -> [0: bb20, 1: bb21, otherwise: bb9];
    }

    bb20: {
        _27 = move ((_20 as Continue).0: &mut ignore::overrides::OverrideBuilder);
        drop(_19) -> [return: bb13, unwind: bb37];
    }

    bb21: {
        _26 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _26) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        drop(_19) -> [return: bb31, unwind: bb37];
    }

    bb23: {
        _30 = &_7;
        _29 = OverrideBuilder::build(move _30) -> [return: bb24, unwind: bb38];
    }

    bb24: {
        _28 = <std::result::Result<Override, ignore::Error> as Try>::branch(move _29) -> [return: bb25, unwind: bb38];
    }

    bb25: {
        _31 = discriminant(_28);
        switchInt(move _31) -> [0: bb26, 1: bb27, otherwise: bb9];
    }

    bb26: {
        _33 = move ((_28 as Continue).0: ignore::overrides::Override);
        _0 = std::result::Result::<Override, Box<dyn std::error::Error>>::Ok(move _33);
        drop(_7) -> [return: bb29, unwind continue];
    }

    bb27: {
        _32 = move ((_28 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<Override, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _32) -> [return: bb28, unwind: bb35];
    }

    bb28: {
        drop(_7) -> [return: bb30, unwind continue];
    }

    bb29: {
        _34 = const false;
        goto -> bb34;
    }

    bb30: {
        _34 = const false;
        goto -> bb34;
    }

    bb31: {
        drop(_15) -> [return: bb32, unwind: bb38];
    }

    bb32: {
        drop(_7) -> [return: bb41, unwind: bb43];
    }

    bb33: {
        _34 = const false;
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35 (cleanup): {
        drop(_7) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_19) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_15) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_7) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        resume;
    }

    bb40: {
        drop(_2) -> [return: bb33, unwind continue];
    }

    bb41: {
        switchInt(_34) -> [0: bb33, otherwise: bb40];
    }

    bb42 (cleanup): {
        drop(_2) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        switchInt(_34) -> [0: bb39, otherwise: bb42];
    }

    bb44: {
        goto -> bb41;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::regex_size_limit(_1: &args::ArgMatches) -> std::result::Result<Option<usize>, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<u64>>;
    let mut _3: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let _4: &str;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _7: std::option::Option<u64>;
    let _8: &str;
    scope 1 {
        debug r => _7;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _4 = const "regex-size-limit";
        _3 = args::ArgMatches::parse_human_readable_size(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_2 as Continue).0: std::option::Option<u64>);
        _8 = const "regex-size-limit";
        _0 = u64_to_usize(_8, _7) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::replacement(_1: &args::ArgMatches) -> Option<Vec<u8>> {
    debug self => _1;
    let mut _0: std::option::Option<std::vec::Vec<u8>>;
    let mut _2: std::option::Option<std::string::String>;
    let _3: &str;

    bb0: {
        _3 = const "replace";
        _2 = args::ArgMatches::value_of_lossy(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<std::string::String>::map::<Vec<u8>, {closure@crates/core/args.rs:1539:44: 1539:47}>(move _2, const ZeroSized: {closure@crates/core/args.rs:1539:44: 1539:47}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::replacement::{closure#0}(_1: {closure@crates/core/args.rs:1539:44: 1539:47}, _2: std::string::String) -> Vec<u8> {
    debug s => _2;
    let mut _0: std::vec::Vec<u8>;

    bb0: {
        _0 = std::string::String::into_bytes(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::sort_by(_1: &args::ArgMatches) -> std::result::Result<SortBy, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<args::SortBy, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let _3: &str;
    let mut _4: args::SortBy;
    let mut _5: args::SortByKind;
    let _6: args::SortBy;
    let mut _7: std::option::Option<std::string::String>;
    let _8: &str;
    let mut _9: isize;
    let mut _10: std::option::Option<std::string::String>;
    let _11: &str;
    let mut _12: isize;
    let mut _13: args::SortBy;
    let _14: std::string::String;
    let mut _15: args::SortByKind;
    let _16: &str;
    let _17: &std::string::String;
    let _18: std::string::String;
    let mut _19: args::SortByKind;
    let _20: &str;
    let _21: &std::string::String;
    let mut _22: args::SortBy;
    scope 1 {
        debug sortby => _6;
    }
    scope 2 {
        debug choice => _14;
    }
    scope 3 {
        debug choice => _18;
    }

    bb0: {
        _3 = const "sort-files";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb4, otherwise: bb2];
    }

    bb2: {
        _5 = SortByKind::Path;
        _4 = SortBy::asc(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = std::result::Result::<SortBy, Box<dyn std::error::Error>>::Ok(move _4);
        goto -> bb19;
    }

    bb4: {
        _8 = const "sort";
        _7 = args::ArgMatches::value_of_lossy(_1, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        _9 = discriminant(_7);
        switchInt(move _9) -> [0: bb8, 1: bb6, otherwise: bb7];
    }

    bb6: {
        _18 = move ((_7 as Some).0: std::string::String);
        _21 = &_18;
        _20 = <std::string::String as Deref>::deref(_21) -> [return: bb16, unwind: bb20];
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _11 = const "sortr";
        _10 = args::ArgMatches::value_of_lossy(_1, _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb11, 1: bb10, otherwise: bb7];
    }

    bb10: {
        _14 = move ((_10 as Some).0: std::string::String);
        _17 = &_14;
        _16 = <std::string::String as Deref>::deref(_17) -> [return: bb13, unwind: bb21];
    }

    bb11: {
        _13 = SortBy::none() -> [return: bb12, unwind continue];
    }

    bb12: {
        _0 = std::result::Result::<SortBy, Box<dyn std::error::Error>>::Ok(move _13);
        goto -> bb19;
    }

    bb13: {
        _15 = SortByKind::new(_16) -> [return: bb14, unwind: bb21];
    }

    bb14: {
        _6 = SortBy::desc(move _15) -> [return: bb15, unwind: bb21];
    }

    bb15: {
        drop(_14) -> [return: bb22, unwind continue];
    }

    bb16: {
        _19 = SortByKind::new(_20) -> [return: bb17, unwind: bb20];
    }

    bb17: {
        _6 = SortBy::asc(move _19) -> [return: bb18, unwind: bb20];
    }

    bb18: {
        drop(_18) -> [return: bb22, unwind continue];
    }

    bb19: {
        return;
    }

    bb20 (cleanup): {
        drop(_18) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        drop(_14) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb22: {
        _22 = _6;
        _0 = std::result::Result::<SortBy, Box<dyn std::error::Error>>::Ok(move _22);
        goto -> bb19;
    }

    bb23 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::stats(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: &args::OutputKind;
    let _4: args::OutputKind;
    let _5: &str;
    let mut _6: &args::OutputKind;

    bb0: {
        _4 = args::ArgMatches::output_kind(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &_4;
        _6 = const _;
        _2 = <OutputKind as PartialEq>::eq(move _3, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _0 = const true;
        goto -> bb5;
    }

    bb4: {
        _5 = const "stats";
        _0 = args::ArgMatches::is_present(_1, _5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::stats: &OutputKind = {
    let mut _0: &args::OutputKind;
    let mut _1: args::OutputKind;

    bb0: {
        _1 = OutputKind::JSON;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::summary_kind(_1: &args::ArgMatches) -> Option<SummaryKind> {
    debug self => _1;
    let mut _0: std::option::Option<grep::grep_printer::SummaryKind>;
    let _2: bool;
    let _3: bool;
    let mut _4: (bool, bool);
    let mut _5: bool;
    let _6: &str;
    let mut _7: grep::grep_printer::SummaryKind;
    let mut _8: grep::grep_printer::SummaryKind;
    let mut _9: grep::grep_printer::SummaryKind;
    let mut _10: bool;
    let _11: &str;
    let mut _12: grep::grep_printer::SummaryKind;
    let mut _13: bool;
    let _14: &str;
    let mut _15: grep::grep_printer::SummaryKind;
    scope 1 {
        debug count => _2;
        debug count_matches => _3;
    }

    bb0: {
        _4 = args::ArgMatches::counts(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = (_4.0: bool);
        _3 = (_4.1: bool);
        _6 = const "quiet";
        _5 = args::ArgMatches::is_present(_1, _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _7 = Quiet;
        _0 = Option::<SummaryKind>::Some(move _7);
        goto -> bb15;
    }

    bb4: {
        switchInt(_3) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _8 = CountMatches;
        _0 = Option::<SummaryKind>::Some(move _8);
        goto -> bb15;
    }

    bb6: {
        switchInt(_2) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _9 = Count;
        _0 = Option::<SummaryKind>::Some(move _9);
        goto -> bb15;
    }

    bb8: {
        _11 = const "files-with-matches";
        _10 = args::ArgMatches::is_present(_1, _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _10) -> [0: bb11, otherwise: bb10];
    }

    bb10: {
        _12 = PathWithMatch;
        _0 = Option::<SummaryKind>::Some(move _12);
        goto -> bb15;
    }

    bb11: {
        _14 = const "files-without-match";
        _13 = args::ArgMatches::is_present(_1, _14) -> [return: bb12, unwind continue];
    }

    bb12: {
        switchInt(move _13) -> [0: bb14, otherwise: bb13];
    }

    bb13: {
        _15 = PathWithoutMatch;
        _0 = Option::<SummaryKind>::Some(move _15);
        goto -> bb15;
    }

    bb14: {
        _0 = Option::<SummaryKind>::None;
        goto -> bb15;
    }

    bb15: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::threads(_1: &args::ArgMatches) -> std::result::Result<usize, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<usize, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: bool;
    let mut _3: &args::SortByKind;
    let _4: args::SortBy;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::SortBy>;
    let mut _6: std::result::Result<args::SortBy, std::boxed::Box<dyn std::error::Error>>;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _9: args::SortBy;
    let _10: usize;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _12: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let _13: &str;
    let mut _14: isize;
    let _15: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _16: std::option::Option<usize>;
    let mut _17: usize;
    let mut _18: usize;
    let mut _19: &args::SortByKind;
    scope 1 {
        debug residual => _8;
        scope 2 {
        }
    }
    scope 3 {
        debug val => _9;
        scope 4 {
        }
    }
    scope 5 {
        debug threads => _10;
    }
    scope 6 {
        debug residual => _15;
        scope 7 {
        }
    }
    scope 8 {
        debug val => _16;
        scope 9 {
        }
    }

    bb0: {
        _6 = args::ArgMatches::sort_by(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = <std::result::Result<SortBy, Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_5 as Continue).0: args::SortBy);
        _4 = _9;
        _3 = &(_4.1: args::SortByKind);
        _19 = const _;
        _2 = <SortByKind as PartialEq>::ne(move _3, _19) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<usize, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _8) -> [return: bb18, unwind continue];
    }

    bb6: {
        switchInt(move _2) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = std::result::Result::<usize, Box<dyn std::error::Error>>::Ok(const 1_usize);
        goto -> bb18;
    }

    bb8: {
        _13 = const "threads";
        _12 = args::ArgMatches::usize_of(_1, _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        _11 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _12) -> [return: bb10, unwind continue];
    }

    bb10: {
        _14 = discriminant(_11);
        switchInt(move _14) -> [0: bb11, 1: bb12, otherwise: bb4];
    }

    bb11: {
        _16 = ((_11 as Continue).0: std::option::Option<usize>);
        _10 = Option::<usize>::unwrap_or(_16, const 0_usize) -> [return: bb13, unwind continue];
    }

    bb12: {
        _15 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<usize, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _15) -> [return: bb18, unwind continue];
    }

    bb13: {
        switchInt(move _10) -> [0: bb14, otherwise: bb16];
    }

    bb14: {
        _18 = num_cpus::get() -> [return: bb15, unwind continue];
    }

    bb15: {
        _17 = std::cmp::min::<usize>(const 12_usize, move _18) -> [return: bb17, unwind continue];
    }

    bb16: {
        _17 = _10;
        goto -> bb17;
    }

    bb17: {
        _0 = std::result::Result::<usize, Box<dyn std::error::Error>>::Ok(move _17);
        goto -> bb18;
    }

    bb18: {
        return;
    }
}

promoted[0] in args::<impl at crates/core/args.rs:904:1: 904:16>::threads: &SortByKind = {
    let mut _0: &args::SortByKind;
    let mut _1: args::SortByKind;

    bb0: {
        _1 = SortByKind::None;
        _0 = &_1;
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::types(_1: &args::ArgMatches) -> std::result::Result<ignore::types::Types, Box<dyn std::error::Error>> {
    debug self => _1;
    let mut _0: std::result::Result<ignore::types::Types, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: ignore::types::TypesBuilder;
    let _3: &mut ignore::types::TypesBuilder;
    let mut _4: &mut ignore::types::TypesBuilder;
    let mut _5: std::vec::IntoIter<std::string::String>;
    let mut _6: std::vec::Vec<std::string::String>;
    let _7: &str;
    let mut _9: std::option::Option<std::string::String>;
    let mut _10: &mut std::vec::IntoIter<std::string::String>;
    let mut _11: isize;
    let _13: &mut ignore::types::TypesBuilder;
    let mut _14: &mut ignore::types::TypesBuilder;
    let _15: &str;
    let _16: &std::string::String;
    let mut _17: std::vec::IntoIter<std::string::String>;
    let mut _18: std::vec::Vec<std::string::String>;
    let _19: &str;
    let mut _21: std::option::Option<std::string::String>;
    let mut _22: &mut std::vec::IntoIter<std::string::String>;
    let mut _23: isize;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, ignore::Error>>;
    let mut _26: std::result::Result<(), ignore::Error>;
    let mut _27: &mut ignore::types::TypesBuilder;
    let _28: &str;
    let _29: &std::string::String;
    let mut _30: isize;
    let mut _32: std::vec::IntoIter<std::string::String>;
    let mut _33: std::vec::Vec<std::string::String>;
    let _34: &str;
    let mut _36: std::option::Option<std::string::String>;
    let mut _37: &mut std::vec::IntoIter<std::string::String>;
    let mut _38: isize;
    let _40: &mut ignore::types::TypesBuilder;
    let mut _41: &mut ignore::types::TypesBuilder;
    let _42: &str;
    let _43: &std::string::String;
    let mut _44: std::vec::IntoIter<std::string::String>;
    let mut _45: std::vec::Vec<std::string::String>;
    let _46: &str;
    let mut _48: std::option::Option<std::string::String>;
    let mut _49: &mut std::vec::IntoIter<std::string::String>;
    let mut _50: isize;
    let _52: &mut ignore::types::TypesBuilder;
    let mut _53: &mut ignore::types::TypesBuilder;
    let _54: &str;
    let _55: &std::string::String;
    let mut _56: std::result::Result<ignore::types::Types, ignore::Error>;
    let mut _57: &ignore::types::TypesBuilder;
    scope 1 {
        debug builder => _2;
        let mut _8: std::vec::IntoIter<std::string::String>;
        let mut _20: std::vec::IntoIter<std::string::String>;
        let mut _35: std::vec::IntoIter<std::string::String>;
        let mut _47: std::vec::IntoIter<std::string::String>;
        scope 2 {
            debug iter => _8;
            let _12: std::string::String;
            scope 3 {
                debug ty => _12;
            }
        }
        scope 4 {
            debug iter => _20;
            let _24: std::string::String;
            scope 5 {
                debug def => _24;
                let _31: std::result::Result<std::convert::Infallible, ignore::Error>;
                scope 6 {
                    debug residual => _31;
                    scope 7 {
                    }
                }
                scope 8 {
                    debug val => const ();
                    scope 9 {
                    }
                }
            }
        }
        scope 10 {
            debug iter => _35;
            let _39: std::string::String;
            scope 11 {
                debug ty => _39;
            }
        }
        scope 12 {
            debug iter => _47;
            let _51: std::string::String;
            scope 13 {
                debug ty => _51;
            }
        }
    }

    bb0: {
        _2 = TypesBuilder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = &mut _2;
        _3 = TypesBuilder::add_defaults(move _4) -> [return: bb2, unwind: bb57];
    }

    bb2: {
        _7 = const "type-clear";
        _6 = args::ArgMatches::values_of_lossy_vec(_1, _7) -> [return: bb3, unwind: bb57];
    }

    bb3: {
        _5 = <Vec<std::string::String> as IntoIterator>::into_iter(move _6) -> [return: bb4, unwind: bb57];
    }

    bb4: {
        _8 = move _5;
        goto -> bb5;
    }

    bb5: {
        _10 = &mut _8;
        _9 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_10) -> [return: bb6, unwind: bb56];
    }

    bb6: {
        _11 = discriminant(_9);
        switchInt(move _11) -> [0: bb9, 1: bb7, otherwise: bb8];
    }

    bb7: {
        _12 = move ((_9 as Some).0: std::string::String);
        _14 = &mut _2;
        _16 = &_12;
        _15 = <std::string::String as Deref>::deref(_16) -> [return: bb10, unwind: bb55];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        drop(_8) -> [return: bb12, unwind: bb57];
    }

    bb10: {
        _13 = TypesBuilder::clear(move _14, _15) -> [return: bb11, unwind: bb55];
    }

    bb11: {
        drop(_12) -> [return: bb5, unwind: bb56];
    }

    bb12: {
        _19 = const "type-add";
        _18 = args::ArgMatches::values_of_lossy_vec(_1, _19) -> [return: bb13, unwind: bb57];
    }

    bb13: {
        _17 = <Vec<std::string::String> as IntoIterator>::into_iter(move _18) -> [return: bb14, unwind: bb57];
    }

    bb14: {
        _20 = move _17;
        goto -> bb15;
    }

    bb15: {
        _22 = &mut _20;
        _21 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_22) -> [return: bb16, unwind: bb54];
    }

    bb16: {
        _23 = discriminant(_21);
        switchInt(move _23) -> [0: bb18, 1: bb17, otherwise: bb8];
    }

    bb17: {
        _24 = move ((_21 as Some).0: std::string::String);
        _27 = &mut _2;
        _29 = &_24;
        _28 = <std::string::String as Deref>::deref(_29) -> [return: bb19, unwind: bb53];
    }

    bb18: {
        drop(_20) -> [return: bb25, unwind: bb57];
    }

    bb19: {
        _26 = TypesBuilder::add_def(move _27, _28) -> [return: bb20, unwind: bb53];
    }

    bb20: {
        _25 = <std::result::Result<(), ignore::Error> as Try>::branch(move _26) -> [return: bb21, unwind: bb53];
    }

    bb21: {
        _30 = discriminant(_25);
        switchInt(move _30) -> [0: bb22, 1: bb23, otherwise: bb8];
    }

    bb22: {
        drop(_24) -> [return: bb15, unwind: bb54];
    }

    bb23: {
        _31 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, ignore::Error>);
        _0 = <std::result::Result<ignore::types::Types, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ignore::Error>>>::from_residual(move _31) -> [return: bb24, unwind: bb53];
    }

    bb24: {
        drop(_24) -> [return: bb46, unwind: bb54];
    }

    bb25: {
        _34 = const "type";
        _33 = args::ArgMatches::values_of_lossy_vec(_1, _34) -> [return: bb26, unwind: bb57];
    }

    bb26: {
        _32 = <Vec<std::string::String> as IntoIterator>::into_iter(move _33) -> [return: bb27, unwind: bb57];
    }

    bb27: {
        _35 = move _32;
        goto -> bb28;
    }

    bb28: {
        _37 = &mut _35;
        _36 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_37) -> [return: bb29, unwind: bb52];
    }

    bb29: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb31, 1: bb30, otherwise: bb8];
    }

    bb30: {
        _39 = move ((_36 as Some).0: std::string::String);
        _41 = &mut _2;
        _43 = &_39;
        _42 = <std::string::String as Deref>::deref(_43) -> [return: bb32, unwind: bb51];
    }

    bb31: {
        drop(_35) -> [return: bb34, unwind: bb57];
    }

    bb32: {
        _40 = TypesBuilder::select(move _41, _42) -> [return: bb33, unwind: bb51];
    }

    bb33: {
        drop(_39) -> [return: bb28, unwind: bb52];
    }

    bb34: {
        _46 = const "type-not";
        _45 = args::ArgMatches::values_of_lossy_vec(_1, _46) -> [return: bb35, unwind: bb57];
    }

    bb35: {
        _44 = <Vec<std::string::String> as IntoIterator>::into_iter(move _45) -> [return: bb36, unwind: bb57];
    }

    bb36: {
        _47 = move _44;
        goto -> bb37;
    }

    bb37: {
        _49 = &mut _47;
        _48 = <std::vec::IntoIter<std::string::String> as Iterator>::next(_49) -> [return: bb38, unwind: bb50];
    }

    bb38: {
        _50 = discriminant(_48);
        switchInt(move _50) -> [0: bb40, 1: bb39, otherwise: bb8];
    }

    bb39: {
        _51 = move ((_48 as Some).0: std::string::String);
        _53 = &mut _2;
        _55 = &_51;
        _54 = <std::string::String as Deref>::deref(_55) -> [return: bb41, unwind: bb49];
    }

    bb40: {
        drop(_47) -> [return: bb43, unwind: bb57];
    }

    bb41: {
        _52 = TypesBuilder::negate(move _53, _54) -> [return: bb42, unwind: bb49];
    }

    bb42: {
        drop(_51) -> [return: bb37, unwind: bb50];
    }

    bb43: {
        _57 = &_2;
        _56 = TypesBuilder::build(move _57) -> [return: bb44, unwind: bb57];
    }

    bb44: {
        _0 = std::result::Result::<ignore::types::Types, ignore::Error>::map_err::<Box<dyn std::error::Error>, fn(ignore::Error) -> Box<dyn std::error::Error> {<Box<dyn std::error::Error> as From<ignore::Error>>::from}>(move _56, <Box<dyn std::error::Error> as From<ignore::Error>>::from) -> [return: bb45, unwind: bb57];
    }

    bb45: {
        drop(_2) -> [return: bb48, unwind continue];
    }

    bb46: {
        drop(_20) -> [return: bb47, unwind: bb57];
    }

    bb47: {
        drop(_2) -> [return: bb48, unwind continue];
    }

    bb48: {
        return;
    }

    bb49 (cleanup): {
        drop(_51) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        drop(_47) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_39) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_35) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        drop(_24) -> [return: bb54, unwind terminate(cleanup)];
    }

    bb54 (cleanup): {
        drop(_20) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_12) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_8) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_2) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::unrestricted_count(_1: &args::ArgMatches) -> u64 {
    debug self => _1;
    let mut _0: u64;
    let _2: &str;

    bb0: {
        _2 = const "unrestricted";
        _0 = args::ArgMatches::occurrences_of(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::unicode(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: bool;
    let _4: &str;
    let _5: &str;

    bb0: {
        _4 = const "no-unicode";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _2 = const true;
        goto -> bb4;
    }

    bb3: {
        _5 = const "no-pcre2-unicode";
        _2 = args::ArgMatches::is_present(_1, _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Not(move _2);
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::pcre2_unicode(_1: &args::ArgMatches) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let _3: &str;

    bb0: {
        _3 = const "pcre2";
        _2 = args::ArgMatches::is_present(_1, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = args::ArgMatches::unicode(_1) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb4;
    }

    bb4: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::with_filename(_1: &args::ArgMatches, _2: &[PathBuf]) -> bool {
    debug self => _1;
    debug paths => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &str;
    let _5: &std::path::Path;
    let _6: &str;
    let mut _7: bool;
    let _8: &str;
    let mut _9: bool;
    let _10: &str;
    let mut _11: bool;
    let mut _12: usize;
    let mut _13: std::option::Option<&std::path::PathBuf>;
    let mut _14: {closure@crates/core/args.rs:1647:36: 1647:39};
    let mut _15: &&std::path::Path;
    scope 1 {
        debug path_stdin => _5;
    }

    bb0: {
        _4 = const "no-filename";
        _3 = args::ArgMatches::is_present(_1, _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const false;
        goto -> bb12;
    }

    bb3: {
        _6 = const "-";
        _5 = Path::new::<str>(_6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _8 = const "with-filename";
        _7 = args::ArgMatches::is_present(_1, _8) -> [return: bb5, unwind continue];
    }

    bb5: {
        switchInt(move _7) -> [0: bb6, otherwise: bb9];
    }

    bb6: {
        _10 = const "vimgrep";
        _9 = args::ArgMatches::is_present(_1, _10) -> [return: bb7, unwind continue];
    }

    bb7: {
        switchInt(move _9) -> [0: bb8, otherwise: bb9];
    }

    bb8: {
        _12 = Len((*_2));
        _11 = Gt(move _12, const 1_usize);
        switchInt(move _11) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _0 = const true;
        goto -> bb12;
    }

    bb10: {
        _13 = core::slice::<impl [PathBuf]>::get::<usize>(_2, const 0_usize) -> [return: bb11, unwind continue];
    }

    bb11: {
        _15 = &_5;
        _14 = {closure@crates/core/args.rs:1647:36: 1647:39} { path_stdin: move _15 };
        _0 = Option::<&PathBuf>::map_or::<bool, {closure@crates/core/args.rs:1647:36: 1647:39}>(move _13, const false, move _14) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:904:1: 904:16>::with_filename::{closure#0}(_1: {closure@crates/core/args.rs:1647:36: 1647:39}, _2: &PathBuf) -> bool {
    debug p => _2;
    debug path_stdin => (*(_1.0: &&std::path::Path));
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &&std::path::PathBuf;
    let _5: &std::path::Path;
    let mut _6: &std::path::PathBuf;
    let mut _7: &&std::path::Path;

    bb0: {
        _4 = &_2;
        _7 = deref_copy (_1.0: &&std::path::Path);
        _3 = <&PathBuf as PartialEq<&Path>>::ne(move _4, _7) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = _2;
        _5 = <PathBuf as Deref>::deref(move _6) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb5;
    }

    bb4: {
        _0 = Path::is_dir(_5) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1653:1: 1653:16>::values_of_lossy_vec(_1: &args::ArgMatches, _2: &str) -> Vec<std::string::String> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::vec::Vec<std::string::String>;
    let mut _3: std::option::Option<std::vec::Vec<std::string::String>>;

    bb0: {
        _3 = args::ArgMatches::values_of_lossy(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<Vec<std::string::String>>::unwrap_or_else::<fn() -> Vec<std::string::String> {Vec::<std::string::String>::new}>(move _3, Vec::<std::string::String>::new) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1653:1: 1653:16>::usize_of_nonzero(_1: &args::ArgMatches, _2: &str) -> std::result::Result<Option<usize>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<usize>>;
    let mut _4: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _7: std::option::Option<usize>;
    let mut _8: isize;
    let mut _9: std::option::Option<usize>;
    let _10: usize;
    let mut _11: std::option::Option<usize>;
    scope 1 {
        debug n => _10;
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }
    scope 6 {
        debug n => _10;
    }

    bb0: {
        _4 = args::ArgMatches::usize_of(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: std::option::Option<usize>);
        _8 = discriminant(_7);
        switchInt(move _8) -> [0: bb7, 1: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<Option<usize>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb11, unwind continue];
    }

    bb6: {
        _10 = ((_7 as Some).0: usize);
        switchInt(move _10) -> [0: bb8, otherwise: bb9];
    }

    bb7: {
        _9 = Option::<usize>::None;
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Ok(move _9);
        goto -> bb11;
    }

    bb8: {
        _11 = Option::<usize>::None;
        goto -> bb10;
    }

    bb9: {
        _11 = Option::<usize>::Some(_10);
        goto -> bb10;
    }

    bb10: {
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Ok(move _11);
        goto -> bb11;
    }

    bb11: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1653:1: 1653:16>::usize_of(_1: &args::ArgMatches, _2: &str) -> std::result::Result<Option<usize>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: std::option::Option<std::string::String>;
    let mut _4: isize;
    let mut _5: std::option::Option<usize>;
    let _6: std::string::String;
    let mut _7: std::result::Result<std::option::Option<usize>, std::num::ParseIntError>;
    let mut _8: std::result::Result<usize, std::num::ParseIntError>;
    let _9: &str;
    let mut _10: &std::string::String;
    scope 1 {
        debug v => _6;
    }

    bb0: {
        _3 = args::ArgMatches::value_of_lossy(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = discriminant(_3);
        switchInt(move _4) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = move ((_3 as Some).0: std::string::String);
        _10 = &_6;
        _9 = <std::string::String as Deref>::deref(move _10) -> [return: bb5, unwind: bb9];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _5 = Option::<usize>::None;
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Ok(move _5);
        goto -> bb10;
    }

    bb5: {
        _8 = core::str::<impl str>::parse::<usize>(_9) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _7 = std::result::Result::<usize, ParseIntError>::map::<Option<usize>, fn(usize) -> Option<usize> {Option::<usize>::Some}>(move _8, Option::<usize>::Some) -> [return: bb7, unwind: bb9];
    }

    bb7: {
        _0 = std::result::Result::<Option<usize>, ParseIntError>::map_err::<Box<dyn std::error::Error>, fn(ParseIntError) -> Box<dyn std::error::Error> {<Box<dyn std::error::Error> as From<ParseIntError>>::from}>(move _7, <Box<dyn std::error::Error> as From<ParseIntError>>::from) -> [return: bb8, unwind: bb9];
    }

    bb8: {
        drop(_6) -> [return: bb10, unwind continue];
    }

    bb9 (cleanup): {
        drop(_6) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:1653:1: 1653:16>::parse_human_readable_size(_1: &args::ArgMatches, _2: &str) -> std::result::Result<Option<u64>, Box<dyn std::error::Error>> {
    debug self => _1;
    debug arg_name => _2;
    let mut _0: std::result::Result<std::option::Option<u64>, std::boxed::Box<dyn std::error::Error>>;
    let _3: std::string::String;
    let mut _4: std::option::Option<std::string::String>;
    let mut _5: isize;
    let mut _6: std::option::Option<u64>;
    let _7: std::string::String;
    let mut _8: std::option::Option<u64>;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_cli::ParseSizeError>, u64>;
    let mut _10: std::result::Result<u64, grep::grep_cli::ParseSizeError>;
    let _11: &str;
    let _12: &std::string::String;
    let mut _13: isize;
    scope 1 {
        debug size => _3;
        let _14: std::result::Result<std::convert::Infallible, grep::grep_cli::ParseSizeError>;
        let _15: u64;
        scope 3 {
            debug residual => _14;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _15;
            scope 6 {
            }
        }
    }
    scope 2 {
        debug size => _7;
    }

    bb0: {
        _4 = args::ArgMatches::value_of_lossy(_1, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _7 = move ((_4 as Some).0: std::string::String);
        _3 = move _7;
        _12 = &_3;
        _11 = <std::string::String as Deref>::deref(_12) -> [return: bb5, unwind: bb13];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = Option::<u64>::None;
        _0 = std::result::Result::<Option<u64>, Box<dyn std::error::Error>>::Ok(move _6);
        goto -> bb11;
    }

    bb5: {
        _10 = parse_human_readable_size(_11) -> [return: bb6, unwind: bb13];
    }

    bb6: {
        _9 = <std::result::Result<u64, ParseSizeError> as Try>::branch(move _10) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _13 = discriminant(_9);
        switchInt(move _13) -> [0: bb8, 1: bb9, otherwise: bb3];
    }

    bb8: {
        _15 = ((_9 as Continue).0: u64);
        _8 = Option::<u64>::Some(_15);
        _0 = std::result::Result::<Option<u64>, Box<dyn std::error::Error>>::Ok(move _8);
        drop(_3) -> [return: bb11, unwind continue];
    }

    bb9: {
        _14 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_cli::ParseSizeError>);
        _0 = <std::result::Result<Option<u64>, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, ParseSizeError>>>::from_residual(move _14) -> [return: bb10, unwind: bb12];
    }

    bb10: {
        drop(_3) -> [return: bb11, unwind continue];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        drop(_3) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        drop(_3) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::is_present(_1: &args::ArgMatches, _2: &str) -> bool {
    debug self => _1;
    debug name => _2;
    let mut _0: bool;
    let mut _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _0 = clap::ArgMatches::<'_>::is_present::<&str>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::occurrences_of(_1: &args::ArgMatches, _2: &str) -> u64 {
    debug self => _1;
    debug name => _2;
    let mut _0: u64;
    let mut _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _0 = clap::ArgMatches::<'_>::occurrences_of::<&str>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::value_of_lossy(_1: &args::ArgMatches, _2: &str) -> Option<std::string::String> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<std::string::String>;
    let mut _3: std::option::Option<std::borrow::Cow<'_, str>>;
    let mut _4: &clap::ArgMatches<'_>;

    bb0: {
        _4 = &((*_1).0: clap::ArgMatches<'_>);
        _3 = clap::ArgMatches::<'_>::value_of_lossy::<&str>(move _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<Cow<'_, str>>::map::<std::string::String, {closure@crates/core/args.rs:1712:41: 1712:44}>(move _3, const ZeroSized: {closure@crates/core/args.rs:1712:41: 1712:44}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::value_of_lossy::{closure#0}(_1: {closure@crates/core/args.rs:1712:41: 1712:44}, _2: Cow<'_, str>) -> std::string::String {
    debug s => _2;
    let mut _0: std::string::String;

    bb0: {
        _0 = Cow::<'_, str>::into_owned(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::values_of_lossy(_1: &args::ArgMatches, _2: &str) -> Option<Vec<std::string::String>> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<std::vec::Vec<std::string::String>>;
    let mut _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _0 = clap::ArgMatches::<'_>::values_of_lossy::<&str>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::value_of_os(_1: &args::ArgMatches, _2: &str) -> Option<&OsStr> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<&std::ffi::OsStr>;
    let mut _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _0 = clap::ArgMatches::<'_>::value_of_os::<&str>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::<impl at crates/core/args.rs:1702:1: 1702:16>::values_of_os(_1: &args::ArgMatches, _2: &str) -> Option<OsValues<'_>> {
    debug self => _1;
    debug name => _2;
    let mut _0: std::option::Option<clap::OsValues<'_>>;
    let mut _3: &clap::ArgMatches<'_>;

    bb0: {
        _3 = &((*_1).0: clap::ArgMatches<'_>);
        _0 = clap::ArgMatches::<'_>::values_of_os::<&str>(move _3, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn args::suggest(_1: std::string::String) -> std::string::String {
    debug msg => _1;
    let mut _0: std::string::String;
    let mut _2: std::option::Option<std::string::String>;
    let _3: &str;
    let _4: &std::string::String;
    let mut _5: isize;
    scope 1 {
        debug pcre_msg => _6;
        let _6: std::string::String;
    }

    bb0: {
        _4 = &_1;
        _3 = <std::string::String as Deref>::deref(_4) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _2 = suggest_pcre2(_3) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _5 = discriminant(_2);
        switchInt(move _5) -> [1: bb3, otherwise: bb4];
    }

    bb3: {
        _6 = move ((_2 as Some).0: std::string::String);
        _0 = move _6;
        drop(_1) -> [return: bb6, unwind continue];
    }

    bb4: {
        drop(_2) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        _0 = move _1;
        goto -> bb6;
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_1) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn suggest_pcre2(_1: &str) -> Option<std::string::String> {
    debug msg => _1;
    let mut _0: std::option::Option<std::string::String>;

    bb0: {
        _0 = suggest_pcre2::suggest(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn suggest_pcre2::suggest(_1: &str) -> Option<std::string::String> {
    let mut _0: std::option::Option<std::string::String>;

    bb0: {
        _0 = Option::<std::string::String>::None;
        return;
    }
}

fn suggest_multiline(_1: std::string::String) -> std::string::String {
    debug msg => _1;
    let mut _0: std::string::String;
    let mut _2: bool;
    let _3: &str;
    let mut _4: &std::string::String;
    let mut _5: bool;
    let _6: &str;
    let mut _7: &std::string::String;
    let _8: std::string::String;
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &std::string::String;
    let mut _16: &[&str; 2];
    let mut _17: bool;
    scope 1 {
        debug res => _8;
    }

    bb0: {
        _17 = const false;
        _17 = const true;
        _4 = &_1;
        _3 = <std::string::String as Deref>::deref(move _4) -> [return: bb1, unwind: bb13];
    }

    bb1: {
        _2 = core::str::<impl str>::contains::<'_, &str>(_3, const "the literal") -> [return: bb2, unwind: bb13];
    }

    bb2: {
        switchInt(move _2) -> [0: bb10, otherwise: bb3];
    }

    bb3: {
        _7 = &_1;
        _6 = <std::string::String as Deref>::deref(move _7) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _5 = core::str::<impl str>::contains::<'_, &str>(_6, const "not allowed") -> [return: bb5, unwind: bb13];
    }

    bb5: {
        switchInt(move _5) -> [0: bb10, otherwise: bb6];
    }

    bb6: {
        _16 = const _;
        _10 = _16 as &[&str] (PointerCoercion(Unsize));
        _15 = &_1;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<std::string::String>(_15) -> [return: bb7, unwind: bb13];
    }

    bb7: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb8, unwind: bb13];
    }

    bb8: {
        _8 = format(move _9) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        _0 = move _8;
        goto -> bb11;
    }

    bb10: {
        _17 = const false;
        _0 = move _1;
        goto -> bb11;
    }

    bb11: {
        switchInt(_17) -> [0: bb12, otherwise: bb15];
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_1) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        resume;
    }

    bb15: {
        drop(_1) -> [return: bb12, unwind continue];
    }
}

promoted[0] in suggest_multiline: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n\nConsider enabling multiline mode with the --multiline flag (or -U for short).\nWhen multiline mode is enabled, new line characters can be matched."];
        _0 = &_1;
        return;
    }
}

fn u64_to_usize(_1: &str, _2: Option<u64>) -> std::result::Result<Option<usize>, Box<dyn std::error::Error>> {
    debug arg_name => _1;
    debug value => _2;
    let mut _0: std::result::Result<std::option::Option<usize>, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: isize;
    let mut _4: std::option::Option<usize>;
    let _5: u64;
    let mut _6: bool;
    let mut _7: u64;
    let mut _8: std::option::Option<usize>;
    let mut _9: usize;
    let mut _10: std::boxed::Box<dyn std::error::Error>;
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &&str;
    scope 1 {
        debug value => _5;
        let _11: std::string::String;
        let mut _19: &[&str; 1];
        scope 3 {
            debug res => _11;
        }
    }
    scope 2 {
        debug value => _5;
    }

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = ((_2 as Some).0: u64);
        _7 = const _ as u64 (IntToInt);
        _6 = Le(_5, move _7);
        switchInt(move _6) -> [0: bb5, otherwise: bb4];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = Option::<usize>::None;
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Ok(move _4);
        goto -> bb10;
    }

    bb4: {
        _9 = _5 as usize (IntToInt);
        _8 = Option::<usize>::Some(move _9);
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Ok(move _8);
        goto -> bb10;
    }

    bb5: {
        _19 = const _;
        _13 = _19 as &[&str] (PointerCoercion(Unsize));
        _18 = &_1;
        _17 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_18) -> [return: bb6, unwind continue];
    }

    bb6: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _12 = Arguments::<'_>::new_v1(move _13, move _14) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = format(move _12) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = std::result::Result::<Option<usize>, Box<dyn std::error::Error>>::Err(move _10);
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

promoted[0] in u64_to_usize: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "number too large for "];
        _0 = &_1;
        return;
    }
}

fn sort_by_metadata_time(_1: &Path, _2: &Path, _3: bool, _4: G) -> std::cmp::Ordering {
    debug p1 => _1;
    debug p2 => _2;
    debug reverse => _3;
    debug get_time => _4;
    let mut _0: std::cmp::Ordering;
    let _5: std::time::SystemTime;
    let mut _6: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _7: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _8: {closure@crates/core/args.rs:1809:43: 1809:47};
    let mut _9: &G;
    let mut _10: isize;
    let _11: std::time::SystemTime;
    let mut _13: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _14: std::result::Result<std::fs::Metadata, std::io::Error>;
    let mut _15: {closure@crates/core/args.rs:1813:43: 1813:47};
    let mut _16: &G;
    let mut _17: isize;
    let mut _19: std::cmp::Ordering;
    let mut _20: &std::time::SystemTime;
    let _21: &std::time::SystemTime;
    let mut _22: &std::time::SystemTime;
    let _23: &std::time::SystemTime;
    scope 1 {
        debug t1 => _5;
        let _12: std::time::SystemTime;
        let _18: std::time::SystemTime;
        scope 3 {
            debug t2 => _12;
        }
        scope 4 {
            debug t => _18;
        }
    }
    scope 2 {
        debug t => _11;
    }

    bb0: {
        _7 = Path::metadata(_1) -> [return: bb1, unwind: bb18];
    }

    bb1: {
        _9 = &_4;
        _8 = {closure@crates/core/args.rs:1809:43: 1809:47} { get_time: move _9 };
        _6 = std::result::Result::<std::fs::Metadata, std::io::Error>::and_then::<SystemTime, {closure@crates/core/args.rs:1809:43: 1809:47}>(move _7, move _8) -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _10 = discriminant(_6);
        switchInt(move _10) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _0 = Equal;
        drop(_6) -> [return: bb16, unwind: bb18];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _11 = ((_6 as Ok).0: std::time::SystemTime);
        _5 = _11;
        drop(_6) -> [return: bb6, unwind: bb18];
    }

    bb6: {
        _14 = Path::metadata(_2) -> [return: bb7, unwind: bb18];
    }

    bb7: {
        _16 = &_4;
        _15 = {closure@crates/core/args.rs:1813:43: 1813:47} { get_time: move _16 };
        _13 = std::result::Result::<std::fs::Metadata, std::io::Error>::and_then::<SystemTime, {closure@crates/core/args.rs:1813:43: 1813:47}>(move _14, move _15) -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _17 = discriminant(_13);
        switchInt(move _17) -> [0: bb10, 1: bb9, otherwise: bb4];
    }

    bb9: {
        _0 = Equal;
        drop(_13) -> [return: bb16, unwind: bb18];
    }

    bb10: {
        _18 = ((_13 as Ok).0: std::time::SystemTime);
        _12 = _18;
        drop(_13) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        switchInt(_3) -> [0: bb14, otherwise: bb12];
    }

    bb12: {
        _20 = &_5;
        _21 = &_12;
        _19 = <SystemTime as Ord>::cmp(move _20, _21) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        _0 = std::cmp::Ordering::reverse(move _19) -> [return: bb20, unwind: bb18];
    }

    bb14: {
        _22 = &_5;
        _23 = &_12;
        _0 = <SystemTime as Ord>::cmp(move _22, _23) -> [return: bb21, unwind: bb18];
    }

    bb15: {
        drop(_4) -> [return: bb17, unwind continue];
    }

    bb16: {
        drop(_4) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_4) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20: {
        goto -> bb15;
    }

    bb21: {
        goto -> bb15;
    }
}

fn sort_by_metadata_time::{closure#0}(_1: {closure@crates/core/args.rs:1809:43: 1809:47}, _2: std::fs::Metadata) -> std::result::Result<SystemTime, std::io::Error> {
    debug md => _2;
    debug get_time => (*(_1.0: &G));
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _3: (&std::fs::Metadata,);
    let _4: &std::fs::Metadata;
    let mut _5: &G;

    bb0: {
        _5 = deref_copy (_1.0: &G);
        _4 = &_2;
        _3 = (_4,);
        _0 = <G as Fn<(&std::fs::Metadata,)>>::call(_5, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn sort_by_metadata_time::{closure#1}(_1: {closure@crates/core/args.rs:1813:43: 1813:47}, _2: std::fs::Metadata) -> std::result::Result<SystemTime, std::io::Error> {
    debug md => _2;
    debug get_time => (*(_1.0: &G));
    let mut _0: std::result::Result<std::time::SystemTime, std::io::Error>;
    let mut _3: (&std::fs::Metadata,);
    let _4: &std::fs::Metadata;
    let mut _5: &G;

    bb0: {
        _5 = deref_copy (_1.0: &G);
        _4 = &_2;
        _3 = (_4,);
        _0 = <G as Fn<(&std::fs::Metadata,)>>::call(_5, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn clap_matches(_1: I) -> std::result::Result<clap::ArgMatches<'_>, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<clap::ArgMatches<'_>, std::boxed::Box<dyn std::error::Error>>;
    let _2: clap::Error;
    let mut _3: std::result::Result<clap::ArgMatches<'_>, clap::Error>;
    let mut _4: clap::App<'_, '_>;
    let mut _5: I;
    let mut _6: isize;
    let _7: clap::ArgMatches<'_>;
    let _8: clap::Error;
    let mut _9: bool;
    let mut _10: &clap::Error;
    let mut _11: std::boxed::Box<dyn std::error::Error>;
    let mut _12: clap::Error;
    let mut _13: std::result::Result<(), std::io::Error>;
    let mut _14: &mut std::io::Stdout;
    let mut _15: std::io::Stdout;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &clap::Error;
    let _23: !;
    let mut _25: bool;
    let mut _26: bool;
    scope 1 {
        debug err => _2;
        let mut _24: &[&str; 1];
        scope 4 {
        }
    }
    scope 2 {
        debug matches => _7;
    }
    scope 3 {
        debug err => _8;
    }

    bb0: {
        _26 = const false;
        _25 = const false;
        _26 = const true;
        _4 = app() -> [return: bb1, unwind: bb20];
    }

    bb1: {
        _26 = const false;
        _5 = move _1;
        _3 = App::<'_, '_>::get_matches_from_safe::<I, T>(move _4, move _5) -> [return: bb2, unwind: bb20];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_3 as Err).0: clap::Error);
        _25 = const true;
        _2 = move _8;
        _10 = &_2;
        _9 = clap::Error::use_stderr(move _10) -> [return: bb6, unwind: bb18];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Ok).0: clap::ArgMatches<'_>);
        _0 = std::result::Result::<clap::ArgMatches<'_>, Box<dyn std::error::Error>>::Ok(move _7);
        goto -> bb15;
    }

    bb6: {
        switchInt(move _9) -> [0: bb9, otherwise: bb7];
    }

    bb7: {
        _25 = const false;
        _12 = move _2;
        _11 = <clap::Error as Into<Box<dyn std::error::Error>>>::into(move _12) -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _0 = std::result::Result::<clap::ArgMatches<'_>, Box<dyn std::error::Error>>::Err(move _11);
        goto -> bb15;
    }

    bb9: {
        _15 = std::io::stdout() -> [return: bb10, unwind: bb18];
    }

    bb10: {
        _14 = &mut _15;
        _24 = const _;
        _17 = _24 as &[&str] (PointerCoercion(Unsize));
        _22 = &_2;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<clap::Error>(_22) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb12, unwind: bb18];
    }

    bb12: {
        _13 = <Stdout as std::io::Write>::write_fmt(move _14, move _16) -> [return: bb13, unwind: bb18];
    }

    bb13: {
        drop(_13) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _23 = exit(const 0_i32) -> bb18;
    }

    bb15: {
        _25 = const false;
        return;
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb20, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_25) -> [0: bb20, otherwise: bb17];
    }

    bb19 (cleanup): {
        drop(_1) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb20 (cleanup): {
        switchInt(_26) -> [0: bb16, otherwise: bb19];
    }
}

promoted[0] in clap_matches: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const ""];
        _0 = &_1;
        return;
    }
}

fn args::current_dir() -> std::result::Result<PathBuf, Box<dyn std::error::Error>> {
    let mut _0: std::result::Result<std::path::PathBuf, std::boxed::Box<dyn std::error::Error>>;
    let _1: std::io::Error;
    let mut _2: std::result::Result<std::path::PathBuf, std::io::Error>;
    let mut _3: isize;
    let _4: std::io::Error;
    let _5: std::path::PathBuf;
    let mut _6: std::option::Option<std::ffi::OsString>;
    let mut _7: isize;
    let mut _9: bool;
    let _10: &std::ffi::OsStr;
    let mut _11: &std::ffi::OsString;
    let mut _12: std::path::PathBuf;
    let mut _13: std::ffi::OsString;
    let mut _14: std::boxed::Box<dyn std::error::Error>;
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 1];
    let _20: [core::fmt::rt::Argument<'_>; 1];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &std::io::Error;
    let mut _24: bool;
    let mut _25: bool;
    let mut _26: isize;
    scope 1 {
        debug err => _1;
        let _15: std::string::String;
        let mut _23: &[&str; 2];
        scope 4 {
            debug cwd => _8;
            let _8: std::ffi::OsString;
        }
        scope 5 {
            debug res => _15;
        }
    }
    scope 2 {
        debug err => _4;
    }
    scope 3 {
        debug cwd => _5;
    }

    bb0: {
        _25 = const false;
        _24 = const false;
        _2 = std::env::current_dir() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _5 = move ((_2 as Ok).0: std::path::PathBuf);
        _0 = std::result::Result::<PathBuf, Box<dyn std::error::Error>>::Ok(move _5);
        goto -> bb17;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _4 = move ((_2 as Err).0: std::io::Error);
        _1 = move _4;
        _6 = var_os::<&str>(const "PWD") -> [return: bb5, unwind: bb18];
    }

    bb5: {
        _24 = const true;
        _7 = discriminant(_6);
        switchInt(move _7) -> [1: bb6, otherwise: bb23];
    }

    bb6: {
        _24 = const false;
        _25 = const true;
        _8 = move ((_6 as Some).0: std::ffi::OsString);
        _11 = &_8;
        _10 = <OsString as Deref>::deref(move _11) -> [return: bb7, unwind: bb25];
    }

    bb7: {
        _9 = OsStr::is_empty(_10) -> [return: bb8, unwind: bb25];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        drop(_8) -> [return: bb12, unwind: bb18];
    }

    bb10: {
        _25 = const false;
        _13 = move _8;
        _12 = <PathBuf as From<OsString>>::from(move _13) -> [return: bb11, unwind: bb25];
    }

    bb11: {
        _0 = std::result::Result::<PathBuf, Box<dyn std::error::Error>>::Ok(move _12);
        _25 = const false;
        _24 = const false;
        drop(_1) -> [return: bb17, unwind continue];
    }

    bb12: {
        _25 = const false;
        goto -> bb23;
    }

    bb13: {
        _20 = [move _21];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb14, unwind: bb18];
    }

    bb14: {
        _15 = format(move _16) -> [return: bb15, unwind: bb18];
    }

    bb15: {
        _14 = <std::string::String as Into<Box<dyn std::error::Error>>>::into(move _15) -> [return: bb16, unwind: bb18];
    }

    bb16: {
        _0 = std::result::Result::<PathBuf, Box<dyn std::error::Error>>::Err(move _14);
        drop(_1) -> [return: bb17, unwind continue];
    }

    bb17: {
        return;
    }

    bb18 (cleanup): {
        drop(_1) -> [return: bb19, unwind terminate(cleanup)];
    }

    bb19 (cleanup): {
        resume;
    }

    bb20: {
        _24 = const false;
        _23 = const _;
        _17 = _23 as &[&str] (PointerCoercion(Unsize));
        _22 = &_1;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_22) -> [return: bb13, unwind: bb18];
    }

    bb21: {
        switchInt(_24) -> [0: bb20, otherwise: bb22];
    }

    bb22: {
        drop(((_6 as Some).0: std::ffi::OsString)) -> [return: bb20, unwind: bb18];
    }

    bb23: {
        _26 = discriminant(_6);
        switchInt(move _26) -> [1: bb21, otherwise: bb20];
    }

    bb24 (cleanup): {
        drop(_8) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb25 (cleanup): {
        switchInt(_25) -> [0: bb18, otherwise: bb24];
    }
}

promoted[0] in args::current_dir: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "failed to get current working directory: ", const " --- did your CWD get deleted?"];
        _0 = &_1;
        return;
    }
}

fn config::args() -> Vec<OsString> {
    let mut _0: std::vec::Vec<std::ffi::OsString>;
    let _1: std::path::PathBuf;
    let mut _2: std::option::Option<std::ffi::OsString>;
    let mut _3: isize;
    let _4: std::ffi::OsString;
    let mut _5: bool;
    let _6: &std::ffi::OsStr;
    let mut _7: &std::ffi::OsString;
    let mut _8: std::ffi::OsString;
    let mut _11: (std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
    let mut _12: std::result::Result<(std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>), std::boxed::Box<dyn std::error::Error>>;
    let mut _13: &std::path::PathBuf;
    let mut _14: isize;
    let mut _18: bool;
    let _19: ();
    let mut _20: std::fmt::Arguments<'_>;
    let mut _21: &[&str];
    let mut _22: &[core::fmt::rt::Argument<'_>];
    let _23: &[core::fmt::rt::Argument<'_>; 1];
    let _24: [core::fmt::rt::Argument<'_>; 1];
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &std::boxed::Box<dyn std::error::Error>;
    let mut _27: bool;
    let mut _28: &std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _29: std::vec::IntoIter<std::boxed::Box<dyn std::error::Error>>;
    let mut _30: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _32: std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _33: &mut std::vec::IntoIter<std::boxed::Box<dyn std::error::Error>>;
    let mut _34: isize;
    let mut _36: bool;
    let _37: ();
    let mut _38: std::fmt::Arguments<'_>;
    let mut _39: &[&str];
    let mut _40: &[core::fmt::rt::Argument<'_>];
    let _41: &[core::fmt::rt::Argument<'_>; 2];
    let _42: [core::fmt::rt::Argument<'_>; 2];
    let mut _43: core::fmt::rt::Argument<'_>;
    let _44: &std::path::Display<'_>;
    let _45: std::path::Display<'_>;
    let _46: &std::path::Path;
    let mut _47: &std::path::PathBuf;
    let mut _48: core::fmt::rt::Argument<'_>;
    let _49: &std::boxed::Box<dyn std::error::Error>;
    let mut _51: bool;
    let mut _52: &log::Level;
    let mut _53: bool;
    let mut _54: &log::Level;
    let mut _55: &log::LevelFilter;
    let _56: log::LevelFilter;
    let _57: ();
    let mut _58: std::fmt::Arguments<'_>;
    let mut _59: &[&str];
    let mut _60: &[core::fmt::rt::Argument<'_>];
    let _61: &[core::fmt::rt::Argument<'_>; 2];
    let _62: [core::fmt::rt::Argument<'_>; 2];
    let mut _63: core::fmt::rt::Argument<'_>;
    let _64: &std::path::Display<'_>;
    let _65: std::path::Display<'_>;
    let _66: &std::path::Path;
    let mut _67: &std::path::PathBuf;
    let mut _68: core::fmt::rt::Argument<'_>;
    let _69: &std::vec::Vec<std::ffi::OsString>;
    let mut _70: log::Level;
    let mut _76: bool;
    let mut _77: bool;
    let mut _78: bool;
    scope 1 {
        debug config_path => _1;
        let _9: std::vec::Vec<std::ffi::OsString>;
        let _10: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
        let _15: std::vec::Vec<std::ffi::OsString>;
        let _16: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
        let _17: std::boxed::Box<dyn std::error::Error>;
        scope 3 {
            debug args => _9;
            debug errs => _10;
            let mut _31: std::vec::IntoIter<std::boxed::Box<dyn std::error::Error>>;
            let _50: log::Level;
            scope 6 {
                debug iter => _31;
                let _35: std::boxed::Box<dyn std::error::Error>;
                scope 7 {
                    debug err => _35;
                    let mut _75: &[&str; 3];
                }
            }
            scope 8 {
                debug lvl => _50;
                let mut _72: &(&str, &str, &str, u32);
                let mut _73: &[&str; 2];
                let mut _74: &log::LevelFilter;
            }
        }
        scope 4 {
            debug args => _15;
            debug errs => _16;
        }
        scope 5 {
            debug err => _17;
            let mut _71: &[&str; 2];
        }
    }
    scope 2 {
        debug config_path => _4;
    }

    bb0: {
        _78 = const false;
        _77 = const false;
        _76 = const false;
        _2 = var_os::<&str>(const "RIPGREP_CONFIG_PATH") -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _78 = const true;
        _4 = move ((_2 as Some).0: std::ffi::OsString);
        _7 = &_4;
        _6 = <OsString as Deref>::deref(move _7) -> [return: bb5, unwind: bb62];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = Vec::<OsString>::new() -> [return: bb50, unwind continue];
    }

    bb5: {
        _5 = OsStr::is_empty(_6) -> [return: bb6, unwind: bb62];
    }

    bb6: {
        switchInt(move _5) -> [0: bb8, otherwise: bb7];
    }

    bb7: {
        _0 = Vec::<OsString>::new() -> [return: bb48, unwind: bb62];
    }

    bb8: {
        _78 = const false;
        _8 = move _4;
        _1 = <PathBuf as From<OsString>>::from(move _8) -> [return: bb9, unwind: bb62];
    }

    bb9: {
        _78 = const false;
        _13 = &_1;
        _12 = parse::<&PathBuf>(move _13) -> [return: bb10, unwind: bb55];
    }

    bb10: {
        _14 = discriminant(_12);
        switchInt(move _14) -> [0: bb12, 1: bb11, otherwise: bb3];
    }

    bb11: {
        _17 = move ((_12 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _18 = messages() -> [return: bb13, unwind: bb54];
    }

    bb12: {
        _15 = move (((_12 as Ok).0: (std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>)).0: std::vec::Vec<std::ffi::OsString>);
        _16 = move (((_12 as Ok).0: (std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>)).1: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
        _11 = (move _15, move _16);
        _77 = const true;
        _9 = move (_11.0: std::vec::Vec<std::ffi::OsString>);
        _76 = const true;
        _10 = move (_11.1: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
        _28 = &_10;
        _27 = Vec::<Box<dyn std::error::Error>>::is_empty(move _28) -> [return: bb18, unwind: bb59];
    }

    bb13: {
        switchInt(move _18) -> [0: bb17, otherwise: bb14];
    }

    bb14: {
        _71 = const _;
        _21 = _71 as &[&str] (PointerCoercion(Unsize));
        _26 = &_17;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_26) -> [return: bb15, unwind: bb54];
    }

    bb15: {
        _24 = [move _25];
        _23 = &_24;
        _22 = _23 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _20 = Arguments::<'_>::new_v1(move _21, move _22) -> [return: bb16, unwind: bb54];
    }

    bb16: {
        _19 = _eprint(move _20) -> [return: bb63, unwind: bb54];
    }

    bb17: {
        _0 = Vec::<OsString>::new() -> [return: bb46, unwind: bb54];
    }

    bb18: {
        switchInt(move _27) -> [0: bb19, otherwise: bb33];
    }

    bb19: {
        _76 = const false;
        _30 = move _10;
        _29 = <Vec<Box<dyn std::error::Error>> as IntoIterator>::into_iter(move _30) -> [return: bb20, unwind: bb59];
    }

    bb20: {
        _31 = move _29;
        goto -> bb21;
    }

    bb21: {
        _33 = &mut _31;
        _32 = <std::vec::IntoIter<Box<dyn std::error::Error>> as Iterator>::next(_33) -> [return: bb22, unwind: bb52];
    }

    bb22: {
        _34 = discriminant(_32);
        switchInt(move _34) -> [0: bb24, 1: bb23, otherwise: bb3];
    }

    bb23: {
        _35 = move ((_32 as Some).0: std::boxed::Box<dyn std::error::Error>);
        _36 = messages() -> [return: bb25, unwind: bb51];
    }

    bb24: {
        drop(_31) -> [return: bb33, unwind: bb59];
    }

    bb25: {
        switchInt(move _36) -> [0: bb32, otherwise: bb26];
    }

    bb26: {
        _75 = const _;
        _39 = _75 as &[&str] (PointerCoercion(Unsize));
        _47 = &_1;
        _46 = <PathBuf as Deref>::deref(move _47) -> [return: bb27, unwind: bb51];
    }

    bb27: {
        _45 = Path::display(_46) -> [return: bb28, unwind: bb51];
    }

    bb28: {
        _44 = &_45;
        _43 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_44) -> [return: bb29, unwind: bb51];
    }

    bb29: {
        _49 = &_35;
        _48 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_49) -> [return: bb30, unwind: bb51];
    }

    bb30: {
        _42 = [move _43, move _48];
        _41 = &_42;
        _40 = _41 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _38 = Arguments::<'_>::new_v1(move _39, move _40) -> [return: bb31, unwind: bb51];
    }

    bb31: {
        _37 = _eprint(move _38) -> [return: bb64, unwind: bb51];
    }

    bb32: {
        drop(_35) -> [return: bb21, unwind: bb52];
    }

    bb33: {
        _50 = log::Level::Debug;
        _52 = &_50;
        _74 = const _;
        _51 = <Level as PartialOrd<LevelFilter>>::le(move _52, _74) -> [return: bb34, unwind: bb59];
    }

    bb34: {
        switchInt(move _51) -> [0: bb44, otherwise: bb35];
    }

    bb35: {
        _54 = &_50;
        _56 = max_level() -> [return: bb36, unwind: bb59];
    }

    bb36: {
        _55 = &_56;
        _53 = <Level as PartialOrd<LevelFilter>>::le(move _54, move _55) -> [return: bb37, unwind: bb59];
    }

    bb37: {
        switchInt(move _53) -> [0: bb44, otherwise: bb38];
    }

    bb38: {
        _73 = const _;
        _59 = _73 as &[&str] (PointerCoercion(Unsize));
        _67 = &_1;
        _66 = <PathBuf as Deref>::deref(move _67) -> [return: bb39, unwind: bb59];
    }

    bb39: {
        _65 = Path::display(_66) -> [return: bb40, unwind: bb59];
    }

    bb40: {
        _64 = &_65;
        _63 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_64) -> [return: bb41, unwind: bb59];
    }

    bb41: {
        _69 = &_9;
        _68 = core::fmt::rt::Argument::<'_>::new_debug::<Vec<OsString>>(_69) -> [return: bb42, unwind: bb59];
    }

    bb42: {
        _62 = [move _63, move _68];
        _61 = &_62;
        _60 = _61 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _58 = Arguments::<'_>::new_v1(move _59, move _60) -> [return: bb43, unwind: bb59];
    }

    bb43: {
        _70 = _50;
        _72 = const _;
        _57 = __private_api_log(move _58, move _70, _72) -> [return: bb65, unwind: bb59];
    }

    bb44: {
        _77 = const false;
        _0 = move _9;
        switchInt(_76) -> [0: bb45, otherwise: bb57];
    }

    bb45: {
        _76 = const false;
        _77 = const false;
        drop(_1) -> [return: bb50, unwind continue];
    }

    bb46: {
        drop(_17) -> [return: bb47, unwind: bb55];
    }

    bb47: {
        drop(_1) -> [return: bb50, unwind continue];
    }

    bb48: {
        drop(_4) -> [return: bb49, unwind continue];
    }

    bb49: {
        _78 = const false;
        goto -> bb50;
    }

    bb50: {
        return;
    }

    bb51 (cleanup): {
        drop(_35) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        drop(_31) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb53 (cleanup): {
        switchInt(_77) -> [0: bb55, otherwise: bb60];
    }

    bb54 (cleanup): {
        drop(_17) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_1) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        resume;
    }

    bb57: {
        drop(_10) -> [return: bb45, unwind: bb53];
    }

    bb58 (cleanup): {
        drop(_10) -> [return: bb53, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        switchInt(_76) -> [0: bb53, otherwise: bb58];
    }

    bb60 (cleanup): {
        drop(_9) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        drop(_4) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb62 (cleanup): {
        switchInt(_78) -> [0: bb56, otherwise: bb61];
    }

    bb63: {
        goto -> bb17;
    }

    bb64: {
        goto -> bb32;
    }

    bb65: {
        goto -> bb44;
    }
}

promoted[0] in config::args: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in config::args: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::config";
        _2 = &(*_3);
        _1 = (move _2, const "rg::config", const "crates/core/config.rs", const 40_u32);
        _0 = &_1;
        return;
    }
}

promoted[2] in config::args: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ": arguments loaded from config file: "];
        _0 = &_1;
        return;
    }
}

promoted[3] in config::args: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[4] in config::args: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ":", const "\n"];
        _0 = &_1;
        return;
    }
}

fn parse(_1: P) -> std::result::Result<(Vec<OsString>, Vec<Box<dyn std::error::Error>>), Box<dyn std::error::Error>> {
    debug path => _1;
    let mut _0: std::result::Result<(std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>), std::boxed::Box<dyn std::error::Error>>;
    let _2: &std::path::Path;
    let mut _3: &P;
    let mut _4: std::result::Result<std::fs::File, std::io::Error>;
    let mut _5: &&std::path::Path;
    let mut _6: isize;
    let mut _9: std::boxed::Box<dyn std::error::Error>;
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 2];
    let _15: [core::fmt::rt::Argument<'_>; 2];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &std::path::Display<'_>;
    let _18: std::path::Display<'_>;
    let mut _19: &std::path::Path;
    let mut _20: core::fmt::rt::Argument<'_>;
    let _21: &std::io::Error;
    scope 1 {
        debug path => _2;
        let _7: std::fs::File;
        let _8: std::io::Error;
        scope 2 {
            debug file => _7;
        }
        scope 3 {
            debug err => _8;
            let _10: std::string::String;
            let mut _22: &[&str; 2];
            scope 4 {
                debug res => _10;
            }
        }
    }

    bb0: {
        _3 = &_1;
        _2 = <P as AsRef<Path>>::as_ref(move _3) -> [return: bb1, unwind: bb15];
    }

    bb1: {
        _5 = &_2;
        _4 = File::open::<&&Path>(move _5) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _6 = discriminant(_4);
        switchInt(move _6) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _8 = move ((_4 as Err).0: std::io::Error);
        _22 = const _;
        _12 = _22 as &[&str] (PointerCoercion(Unsize));
        _19 = _2;
        _18 = Path::display(move _19) -> [return: bb6, unwind: bb14];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_4 as Ok).0: std::fs::File);
        _0 = parse_reader::<File>(move _7) -> [return: bb17, unwind: bb15];
    }

    bb6: {
        _17 = &_18;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_17) -> [return: bb7, unwind: bb14];
    }

    bb7: {
        _21 = &_8;
        _20 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_21) -> [return: bb8, unwind: bb14];
    }

    bb8: {
        _15 = [move _16, move _20];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _11 = Arguments::<'_>::new_v1(move _12, move _13) -> [return: bb9, unwind: bb14];
    }

    bb9: {
        _10 = format(move _11) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        _9 = <Box<dyn std::error::Error> as From<std::string::String>>::from(move _10) -> [return: bb11, unwind: bb14];
    }

    bb11: {
        _0 = std::result::Result::<(Vec<OsString>, Vec<Box<dyn std::error::Error>>), Box<dyn std::error::Error>>::Err(move _9);
        drop(_8) -> [return: bb12, unwind: bb15];
    }

    bb12: {
        drop(_1) -> [return: bb13, unwind continue];
    }

    bb13: {
        return;
    }

    bb14 (cleanup): {
        drop(_8) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_1) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17: {
        goto -> bb12;
    }
}

promoted[0] in parse: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ": "];
        _0 = &_1;
        return;
    }
}

fn parse_reader(_1: R) -> std::result::Result<(Vec<OsString>, Vec<Box<dyn std::error::Error>>), Box<dyn std::error::Error>> {
    debug rdr => _1;
    let mut _0: std::result::Result<(std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>), std::boxed::Box<dyn std::error::Error>>;
    let _2: std::io::BufReader<R>;
    let mut _5: (std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
    let mut _6: std::vec::Vec<std::ffi::OsString>;
    let mut _7: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _10: std::result::Result<(), std::io::Error>;
    let mut _11: std::io::BufReader<R>;
    let mut _12: {closure@crates/core/config.rs:83:42: 83:48};
    let mut _13: &mut i32;
    let mut _14: &mut std::vec::Vec<std::ffi::OsString>;
    let mut _15: &mut std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _16: isize;
    let mut _18: (std::vec::Vec<std::ffi::OsString>, std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
    let mut _19: std::vec::Vec<std::ffi::OsString>;
    let mut _20: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _21: bool;
    scope 1 {
        debug bufrdr => _2;
        let mut _3: std::vec::Vec<std::ffi::OsString>;
        let mut _4: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
        scope 2 {
            debug args => _3;
            debug errs => _4;
            let mut _8: i32;
            scope 3 {
                debug line_number => _8;
                let _17: std::result::Result<std::convert::Infallible, std::io::Error>;
                scope 4 {
                    debug residual => _17;
                    scope 5 {
                    }
                }
                scope 6 {
                    debug val => const ();
                    scope 7 {
                    }
                }
            }
        }
    }

    bb0: {
        _21 = const false;
        _2 = BufReader::<R>::new(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _21 = const true;
        _6 = Vec::<OsString>::new() -> [return: bb2, unwind: bb18];
    }

    bb2: {
        _7 = Vec::<Box<dyn std::error::Error>>::new() -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _5 = (move _6, move _7);
        _3 = move (_5.0: std::vec::Vec<std::ffi::OsString>);
        _4 = move (_5.1: std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
        _8 = const 0_i32;
        _21 = const false;
        _11 = move _2;
        _13 = &mut _8;
        _14 = &mut _3;
        _15 = &mut _4;
        _12 = {closure@crates/core/config.rs:83:42: 83:48} { line_number: move _13, args: move _14, errs: move _15 };
        _10 = <BufReader<R> as BufReadExt>::for_byte_line_with_terminator::<{closure@crates/core/config.rs:83:42: 83:48}>(move _11, move _12) -> [return: bb4, unwind: bb13];
    }

    bb4: {
        _9 = <std::result::Result<(), std::io::Error> as Try>::branch(move _10) -> [return: bb5, unwind: bb13];
    }

    bb5: {
        _16 = discriminant(_9);
        switchInt(move _16) -> [0: bb6, 1: bb8, otherwise: bb7];
    }

    bb6: {
        _19 = move _3;
        _20 = move _4;
        _18 = (move _19, move _20);
        _0 = std::result::Result::<(Vec<OsString>, Vec<Box<dyn std::error::Error>>), Box<dyn std::error::Error>>::Ok(move _18);
        _21 = const false;
        goto -> bb12;
    }

    bb7: {
        unreachable;
    }

    bb8: {
        _17 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(Vec<OsString>, Vec<Box<dyn std::error::Error>>), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _17) -> [return: bb9, unwind: bb13];
    }

    bb9: {
        drop(_4) -> [return: bb10, unwind: bb14];
    }

    bb10: {
        drop(_3) -> [return: bb11, unwind: bb18];
    }

    bb11: {
        _21 = const false;
        goto -> bb12;
    }

    bb12: {
        return;
    }

    bb13 (cleanup): {
        drop(_4) -> [return: bb14, unwind terminate(cleanup)];
    }

    bb14 (cleanup): {
        drop(_3) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb15 (cleanup): {
        drop(_6) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_21) -> [0: bb16, otherwise: bb17];
    }
}

fn parse_reader::{closure#0}(_1: &mut {closure@crates/core/config.rs:83:42: 83:48}, _2: &[u8]) -> std::result::Result<bool, std::io::Error> {
    debug line => _2;
    debug line_number => (*((*_1).0: &mut i32));
    debug args => (*((*_1).1: &mut std::vec::Vec<std::ffi::OsString>));
    debug errs => (*((*_1).2: &mut std::vec::Vec<std::boxed::Box<dyn std::error::Error>>));
    let mut _0: std::result::Result<bool, std::io::Error>;
    let mut _3: (i32, bool);
    let _4: &[u8];
    let mut _5: bool;
    let mut _6: u8;
    let _7: usize;
    let mut _8: usize;
    let mut _9: bool;
    let mut _10: std::result::Result<&std::ffi::OsStr, bstr::Utf8Error>;
    let mut _11: isize;
    let _13: ();
    let mut _14: std::ffi::OsString;
    let _16: ();
    let mut _17: std::boxed::Box<dyn std::error::Error>;
    let mut _19: std::fmt::Arguments<'_>;
    let mut _20: &[&str];
    let mut _21: &[core::fmt::rt::Argument<'_>];
    let _22: &[core::fmt::rt::Argument<'_>; 2];
    let _23: [core::fmt::rt::Argument<'_>; 2];
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &i32;
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &bstr::Utf8Error;
    let mut _29: &mut i32;
    let mut _30: &mut i32;
    let mut _31: &mut i32;
    let mut _32: &mut std::vec::Vec<std::boxed::Box<dyn std::error::Error>>;
    let mut _33: &mut i32;
    let mut _34: &mut std::vec::Vec<std::ffi::OsString>;
    scope 1 {
        debug line => _4;
        let _12: &std::ffi::OsStr;
        let _15: bstr::Utf8Error;
        scope 2 {
            debug osstr => _12;
        }
        scope 3 {
            debug err => _15;
            let _18: std::string::String;
            let mut _28: &[&str; 2];
            scope 4 {
                debug res => _18;
            }
        }
    }

    bb0: {
        _29 = deref_copy ((*_1).0: &mut i32);
        _3 = CheckedAdd((*_29), const 1_i32);
        _30 = deref_copy ((*_1).0: &mut i32);
        assert(!move (_3.1: bool), "attempt to compute `{} + {}`, which would overflow", (*_30), const 1_i32) -> [success: bb1, unwind continue];
    }

    bb1: {
        _31 = deref_copy ((*_1).0: &mut i32);
        (*_31) = move (_3.0: i32);
        _4 = <[u8] as ByteSlice>::trim(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = core::slice::<impl [u8]>::is_empty(_4) -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _5) -> [0: bb4, otherwise: bb6];
    }

    bb4: {
        _7 = const 0_usize;
        _8 = Len((*_4));
        _9 = Lt(_7, _8);
        assert(move _9, "index out of bounds: the length is {} but the index is {}", move _8, _7) -> [success: bb5, unwind continue];
    }

    bb5: {
        _6 = (*_4)[_7];
        switchInt(move _6) -> [35: bb6, otherwise: bb7];
    }

    bb6: {
        _0 = std::result::Result::<bool, std::io::Error>::Ok(const true);
        goto -> bb19;
    }

    bb7: {
        _10 = <[u8] as ByteSlice>::to_os_str(_4) -> [return: bb8, unwind continue];
    }

    bb8: {
        _11 = discriminant(_10);
        switchInt(move _11) -> [0: bb11, 1: bb9, otherwise: bb10];
    }

    bb9: {
        _15 = move ((_10 as Err).0: bstr::Utf8Error);
        _32 = deref_copy ((*_1).2: &mut std::vec::Vec<std::boxed::Box<dyn std::error::Error>>);
        _28 = const _;
        _20 = _28 as &[&str] (PointerCoercion(Unsize));
        _33 = deref_copy ((*_1).0: &mut i32);
        _25 = &(*_33);
        _24 = core::fmt::rt::Argument::<'_>::new_display::<i32>(_25) -> [return: bb13, unwind continue];
    }

    bb10: {
        unreachable;
    }

    bb11: {
        _12 = ((_10 as Ok).0: &std::ffi::OsStr);
        _34 = deref_copy ((*_1).1: &mut std::vec::Vec<std::ffi::OsString>);
        _14 = OsStr::to_os_string(_12) -> [return: bb12, unwind continue];
    }

    bb12: {
        _13 = Vec::<OsString>::push(_34, move _14) -> [return: bb18, unwind continue];
    }

    bb13: {
        _27 = &_15;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<bstr::Utf8Error>(_27) -> [return: bb14, unwind continue];
    }

    bb14: {
        _23 = [move _24, move _26];
        _22 = &_23;
        _21 = _22 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _19 = Arguments::<'_>::new_v1(move _20, move _21) -> [return: bb15, unwind continue];
    }

    bb15: {
        _18 = format(move _19) -> [return: bb16, unwind continue];
    }

    bb16: {
        _17 = <std::string::String as Into<Box<dyn std::error::Error>>>::into(move _18) -> [return: bb17, unwind continue];
    }

    bb17: {
        _16 = Vec::<Box<dyn std::error::Error>>::push(_32, move _17) -> [return: bb18, unwind continue];
    }

    bb18: {
        _0 = std::result::Result::<bool, std::io::Error>::Ok(const true);
        goto -> bb19;
    }

    bb19: {
        return;
    }
}

promoted[0] in parse_reader::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ": "];
        _0 = &_1;
        return;
    }
}

fn logger::<impl at crates/core/logger.rs:12:10: 12:15>::fmt(_1: &Logger, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let mut _4: &dyn std::fmt::Debug;
    let _5: &&();
    let _6: &();

    bb0: {
        _3 = const "Logger";
        _6 = &((*_1).0: ());
        _5 = &_6;
        _4 = _5 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _3, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

const LOGGER: &Logger = {
    let mut _0: &logger::Logger;
    let _1: &logger::Logger;
    let _2: logger::Logger;
    let mut _3: ();
    let mut _4: &logger::Logger;

    bb0: {
        StorageLive(_1);
        _4 = const _;
        _1 = &(*_4);
        _0 = &(*_1);
        StorageDead(_1);
        return;
    }
}

promoted[0] in LOGGER: &Logger = {
    let mut _0: &logger::Logger;
    let mut _1: logger::Logger;
    let mut _2: ();

    bb0: {
        _2 = ();
        _1 = Logger(move _2);
        _0 = &_1;
        return;
    }
}

fn logger::<impl at crates/core/logger.rs:17:1: 17:12>::init() -> std::result::Result<(), SetLoggerError> {
    let mut _0: std::result::Result<(), log::SetLoggerError>;
    let mut _1: &dyn log::Log;
    let _2: &logger::Logger;

    bb0: {
        _2 = const _;
        _1 = _2 as &dyn log::Log (PointerCoercion(Unsize));
        _0 = set_logger(move _1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn logger::<impl at crates/core/logger.rs:26:1: 26:20>::enabled(_1: &Logger, _2: &log::Metadata<'_>) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = const true;
        return;
    }
}

fn logger::<impl at crates/core/logger.rs:26:1: 26:20>::log(_1: &Logger, _2: &Record<'_>) -> () {
    debug self => _1;
    debug record => _2;
    let mut _0: ();
    let mut _3: (std::option::Option<&str>, std::option::Option<u32>);
    let mut _4: std::option::Option<&str>;
    let mut _5: std::option::Option<u32>;
    let mut _6: isize;
    let mut _7: isize;
    let _8: &str;
    let _9: u32;
    let _10: ();
    let mut _11: std::fmt::Arguments<'_>;
    let mut _12: &[&str];
    let mut _13: &[core::fmt::rt::Argument<'_>];
    let _14: &[core::fmt::rt::Argument<'_>; 5];
    let _15: [core::fmt::rt::Argument<'_>; 5];
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &log::Level;
    let _18: log::Level;
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &&str;
    let _21: &str;
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &&str;
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &u32;
    let mut _26: core::fmt::rt::Argument<'_>;
    let _27: &&std::fmt::Arguments<'_>;
    let _28: &std::fmt::Arguments<'_>;
    let _29: &str;
    let _30: ();
    let mut _31: std::fmt::Arguments<'_>;
    let mut _32: &[&str];
    let mut _33: &[core::fmt::rt::Argument<'_>];
    let _34: &[core::fmt::rt::Argument<'_>; 4];
    let _35: [core::fmt::rt::Argument<'_>; 4];
    let mut _36: core::fmt::rt::Argument<'_>;
    let _37: &log::Level;
    let _38: log::Level;
    let mut _39: core::fmt::rt::Argument<'_>;
    let _40: &&str;
    let _41: &str;
    let mut _42: core::fmt::rt::Argument<'_>;
    let _43: &&str;
    let mut _44: core::fmt::rt::Argument<'_>;
    let _45: &&std::fmt::Arguments<'_>;
    let _46: &std::fmt::Arguments<'_>;
    let _47: ();
    let mut _48: std::fmt::Arguments<'_>;
    let mut _49: &[&str];
    let mut _50: &[core::fmt::rt::Argument<'_>];
    let _51: &[core::fmt::rt::Argument<'_>; 3];
    let _52: [core::fmt::rt::Argument<'_>; 3];
    let mut _53: core::fmt::rt::Argument<'_>;
    let _54: &log::Level;
    let _55: log::Level;
    let mut _56: core::fmt::rt::Argument<'_>;
    let _57: &&str;
    let _58: &str;
    let mut _59: core::fmt::rt::Argument<'_>;
    let _60: &&std::fmt::Arguments<'_>;
    let _61: &std::fmt::Arguments<'_>;
    let mut _62: &[&str; 4];
    scope 1 {
        debug file => _8;
        debug line => _9;
        let mut _64: &[&str; 6];
    }
    scope 2 {
        debug file => _29;
        let mut _63: &[&str; 5];
    }

    bb0: {
        _4 = Record::<'_>::file(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = Record::<'_>::line(_2) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = (move _4, move _5);
        _7 = discriminant((_3.0: std::option::Option<&str>));
        switchInt(move _7) -> [1: bb4, otherwise: bb3];
    }

    bb3: {
        _62 = const _;
        _49 = _62 as &[&str] (PointerCoercion(Unsize));
        _55 = Record::<'_>::level(_2) -> [return: bb24, unwind continue];
    }

    bb4: {
        _6 = discriminant((_3.1: std::option::Option<u32>));
        switchInt(move _6) -> [0: bb15, 1: bb5, otherwise: bb32];
    }

    bb5: {
        _8 = (((_3.0: std::option::Option<&str>) as Some).0: &str);
        _9 = (((_3.1: std::option::Option<u32>) as Some).0: u32);
        _64 = const _;
        _12 = _64 as &[&str] (PointerCoercion(Unsize));
        _18 = Record::<'_>::level(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        _17 = &_18;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<Level>(_17) -> [return: bb7, unwind continue];
    }

    bb7: {
        _21 = Record::<'_>::target(_2) -> [return: bb8, unwind continue];
    }

    bb8: {
        _20 = &_21;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_20) -> [return: bb9, unwind continue];
    }

    bb9: {
        _23 = &_8;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_23) -> [return: bb10, unwind continue];
    }

    bb10: {
        _25 = &_9;
        _24 = core::fmt::rt::Argument::<'_>::new_display::<u32>(_25) -> [return: bb11, unwind continue];
    }

    bb11: {
        _28 = Record::<'_>::args(_2) -> [return: bb12, unwind continue];
    }

    bb12: {
        _27 = &_28;
        _26 = core::fmt::rt::Argument::<'_>::new_display::<&Arguments<'_>>(_27) -> [return: bb13, unwind continue];
    }

    bb13: {
        _15 = [move _16, move _19, move _22, move _24, move _26];
        _14 = &_15;
        _13 = _14 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _11 = Arguments::<'_>::new_v1(move _12, move _13) -> [return: bb14, unwind continue];
    }

    bb14: {
        _10 = _eprint(move _11) -> [return: bb31, unwind continue];
    }

    bb15: {
        _29 = (((_3.0: std::option::Option<&str>) as Some).0: &str);
        _63 = const _;
        _32 = _63 as &[&str] (PointerCoercion(Unsize));
        _38 = Record::<'_>::level(_2) -> [return: bb16, unwind continue];
    }

    bb16: {
        _37 = &_38;
        _36 = core::fmt::rt::Argument::<'_>::new_display::<Level>(_37) -> [return: bb17, unwind continue];
    }

    bb17: {
        _41 = Record::<'_>::target(_2) -> [return: bb18, unwind continue];
    }

    bb18: {
        _40 = &_41;
        _39 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_40) -> [return: bb19, unwind continue];
    }

    bb19: {
        _43 = &_29;
        _42 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_43) -> [return: bb20, unwind continue];
    }

    bb20: {
        _46 = Record::<'_>::args(_2) -> [return: bb21, unwind continue];
    }

    bb21: {
        _45 = &_46;
        _44 = core::fmt::rt::Argument::<'_>::new_display::<&Arguments<'_>>(_45) -> [return: bb22, unwind continue];
    }

    bb22: {
        _35 = [move _36, move _39, move _42, move _44];
        _34 = &_35;
        _33 = _34 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _31 = Arguments::<'_>::new_v1(move _32, move _33) -> [return: bb23, unwind continue];
    }

    bb23: {
        _30 = _eprint(move _31) -> [return: bb31, unwind continue];
    }

    bb24: {
        _54 = &_55;
        _53 = core::fmt::rt::Argument::<'_>::new_display::<Level>(_54) -> [return: bb25, unwind continue];
    }

    bb25: {
        _58 = Record::<'_>::target(_2) -> [return: bb26, unwind continue];
    }

    bb26: {
        _57 = &_58;
        _56 = core::fmt::rt::Argument::<'_>::new_display::<&str>(_57) -> [return: bb27, unwind continue];
    }

    bb27: {
        _61 = Record::<'_>::args(_2) -> [return: bb28, unwind continue];
    }

    bb28: {
        _60 = &_61;
        _59 = core::fmt::rt::Argument::<'_>::new_display::<&Arguments<'_>>(_60) -> [return: bb29, unwind continue];
    }

    bb29: {
        _52 = [move _53, move _56, move _59];
        _51 = &_52;
        _50 = _51 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _48 = Arguments::<'_>::new_v1(move _49, move _50) -> [return: bb30, unwind continue];
    }

    bb30: {
        _47 = _eprint(move _48) -> [return: bb31, unwind continue];
    }

    bb31: {
        return;
    }

    bb32: {
        unreachable;
    }
}

promoted[0] in logger::<impl at crates/core/logger.rs:26:1: 26:20>::log: &[&str; 4] = {
    let mut _0: &[&str; 4];
    let mut _1: [&str; 4];

    bb0: {
        _1 = [const "", const "|", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in logger::<impl at crates/core/logger.rs:26:1: 26:20>::log: &[&str; 5] = {
    let mut _0: &[&str; 5];
    let mut _1: [&str; 5];

    bb0: {
        _1 = [const "", const "|", const "|", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in logger::<impl at crates/core/logger.rs:26:1: 26:20>::log: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];

    bb0: {
        _1 = [const "", const "|", const "|", const ":", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

fn logger::<impl at crates/core/logger.rs:26:1: 26:20>::flush(_1: &Logger) -> () {
    debug self => _1;
    let mut _0: ();

    bb0: {
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:8:10: 8:15>::clone(_1: &path_printer::Config) -> path_printer::Config {
    debug self => _1;
    let mut _0: path_printer::Config;
    let mut _2: grep::grep_printer::ColorSpecs;
    let _3: &grep::grep_printer::ColorSpecs;
    let mut _4: std::option::Option<u8>;
    let _5: &std::option::Option<u8>;
    let mut _6: u8;
    let _7: &u8;

    bb0: {
        _3 = &((*_1).0: grep::grep_printer::ColorSpecs);
        _2 = <ColorSpecs as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: std::option::Option<u8>);
        _4 = <Option<u8> as Clone>::clone(_5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = &((*_1).2: u8);
        _6 = (*_7);
        _0 = path_printer::Config { colors: move _2, separator: move _4, terminator: move _6 };
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:8:17: 8:22>::fmt(_1: &path_printer::Config, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &grep::grep_printer::ColorSpecs;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<u8>;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&u8;
    let _13: &u8;

    bb0: {
        _3 = const "Config";
        _4 = const "colors";
        _6 = &((*_1).0: grep::grep_printer::ColorSpecs);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "separator";
        _9 = &((*_1).1: std::option::Option<u8>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "terminator";
        _13 = &((*_1).2: u8);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:15:1: 15:24>::default() -> path_printer::Config {
    let mut _0: path_printer::Config;
    let mut _1: grep::grep_printer::ColorSpecs;
    let mut _2: std::option::Option<u8>;

    bb0: {
        _1 = <ColorSpecs as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = Option::<u8>::None;
        _0 = path_printer::Config { colors: move _1, separator: move _2, terminator: const 10_u8 };
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:26:10: 26:15>::clone(_1: &PathPrinterBuilder) -> PathPrinterBuilder {
    debug self => _1;
    let mut _0: path_printer::PathPrinterBuilder;
    let mut _2: path_printer::Config;
    let _3: &path_printer::Config;

    bb0: {
        _3 = &((*_1).0: path_printer::Config);
        _2 = <path_printer::Config as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = PathPrinterBuilder { config: move _2 };
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:26:17: 26:22>::fmt(_1: &PathPrinterBuilder, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&path_printer::Config;
    let _7: &path_printer::Config;

    bb0: {
        _3 = const "PathPrinterBuilder";
        _4 = const "config";
        _7 = &((*_1).0: path_printer::Config);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:31:1: 31:24>::new() -> PathPrinterBuilder {
    let mut _0: path_printer::PathPrinterBuilder;
    let mut _1: path_printer::Config;

    bb0: {
        _1 = <path_printer::Config as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = PathPrinterBuilder { config: move _1 };
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:31:1: 31:24>::build(_1: &PathPrinterBuilder, _2: W) -> PathPrinter<W> {
    debug self => _1;
    debug wtr => _2;
    let mut _0: path_printer::PathPrinter<W>;
    let mut _3: path_printer::Config;
    let mut _4: &path_printer::Config;
    let mut _5: W;

    bb0: {
        _4 = &((*_1).0: path_printer::Config);
        _3 = <path_printer::Config as Clone>::clone(move _4) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        _5 = move _2;
        _0 = PathPrinter::<W> { config: move _3, wtr: move _5 };
        return;
    }

    bb2 (cleanup): {
        drop(_2) -> [return: bb3, unwind terminate(cleanup)];
    }

    bb3 (cleanup): {
        resume;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:31:1: 31:24>::color_specs(_1: &mut PathPrinterBuilder, _2: ColorSpecs) -> &mut PathPrinterBuilder {
    debug self => _1;
    debug specs => _2;
    let mut _0: &mut path_printer::PathPrinterBuilder;

    bb0: {
        (((*_1).0: path_printer::Config).0: grep::grep_printer::ColorSpecs) = move _2;
        _0 = _1;
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:31:1: 31:24>::separator(_1: &mut PathPrinterBuilder, _2: Option<u8>) -> &mut PathPrinterBuilder {
    debug self => _1;
    debug sep => _2;
    let mut _0: &mut path_printer::PathPrinterBuilder;

    bb0: {
        (((*_1).0: path_printer::Config).1: std::option::Option<u8>) = _2;
        _0 = _1;
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:31:1: 31:24>::terminator(_1: &mut PathPrinterBuilder, _2: u8) -> &mut PathPrinterBuilder {
    debug self => _1;
    debug terminator => _2;
    let mut _0: &mut path_printer::PathPrinterBuilder;

    bb0: {
        (((*_1).0: path_printer::Config).2: u8) = _2;
        _0 = _1;
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:79:10: 79:15>::fmt(_1: &PathPrinter<W>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &path_printer::Config;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&W;
    let _10: &W;

    bb0: {
        _3 = const "PathPrinter";
        _4 = const "config";
        _6 = &((*_1).0: path_printer::Config);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "wtr";
        _10 = &((*_1).1: W);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn path_printer::<impl at crates/core/path_printer.rs:85:1: 85:35>::write_path(_1: &mut PathPrinter<W>, _2: &Path) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _3: grep::grep_printer::PrinterPath<'_>;
    let mut _4: std::option::Option<u8>;
    let mut _5: bool;
    let mut _6: &W;
    let mut _7: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _8: std::result::Result<(), std::io::Error>;
    let mut _9: &mut W;
    let _10: &[u8];
    let mut _11: &grep::grep_printer::PrinterPath<'_>;
    let mut _12: isize;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _15: std::result::Result<(), std::io::Error>;
    let mut _16: &mut W;
    let _17: &termcolor::ColorSpec;
    let mut _18: &grep::grep_printer::ColorSpecs;
    let mut _19: isize;
    let mut _21: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _22: std::result::Result<(), std::io::Error>;
    let mut _23: &mut W;
    let _24: &[u8];
    let mut _25: &grep::grep_printer::PrinterPath<'_>;
    let mut _26: isize;
    let mut _28: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _29: std::result::Result<(), std::io::Error>;
    let mut _30: &mut W;
    let mut _31: isize;
    let mut _33: &mut W;
    let mut _34: &[u8];
    let _35: &[u8; 1];
    let _36: [u8; 1];
    let mut _37: u8;
    scope 1 {
        debug ppath => _3;
        let _13: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _20: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _27: std::result::Result<std::convert::Infallible, std::io::Error>;
        let _32: std::result::Result<std::convert::Infallible, std::io::Error>;
        scope 2 {
            debug residual => _13;
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
        scope 6 {
            debug residual => _20;
            scope 7 {
            }
        }
        scope 8 {
            debug val => const ();
            scope 9 {
            }
        }
        scope 10 {
            debug residual => _27;
            scope 11 {
            }
        }
        scope 12 {
            debug val => const ();
            scope 13 {
            }
        }
        scope 14 {
            debug residual => _32;
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
    }

    bb0: {
        _4 = (((*_1).0: path_printer::Config).1: std::option::Option<u8>);
        _3 = PrinterPath::<'_>::with_separator(_2, move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = &((*_1).1: W);
        _5 = <W as WriteColor>::supports_color(move _6) -> [return: bb2, unwind: bb27];
    }

    bb2: {
        switchInt(move _5) -> [0: bb4, otherwise: bb3];
    }

    bb3: {
        _16 = &mut ((*_1).1: W);
        _18 = &(((*_1).0: path_printer::Config).0: grep::grep_printer::ColorSpecs);
        _17 = ColorSpecs::path(move _18) -> [return: bb10, unwind: bb27];
    }

    bb4: {
        _9 = &mut ((*_1).1: W);
        _11 = &_3;
        _10 = PrinterPath::<'_>::as_bytes(move _11) -> [return: bb5, unwind: bb27];
    }

    bb5: {
        _8 = <W as std::io::Write>::write_all(move _9, _10) -> [return: bb6, unwind: bb27];
    }

    bb6: {
        _7 = <std::result::Result<(), std::io::Error> as Try>::branch(move _8) -> [return: bb7, unwind: bb27];
    }

    bb7: {
        _12 = discriminant(_7);
        switchInt(move _12) -> [0: bb23, 1: bb9, otherwise: bb8];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _13 = move ((_7 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _13) -> [return: bb29, unwind: bb27];
    }

    bb10: {
        _15 = <W as WriteColor>::set_color(move _16, _17) -> [return: bb11, unwind: bb27];
    }

    bb11: {
        _14 = <std::result::Result<(), std::io::Error> as Try>::branch(move _15) -> [return: bb12, unwind: bb27];
    }

    bb12: {
        _19 = discriminant(_14);
        switchInt(move _19) -> [0: bb13, 1: bb14, otherwise: bb8];
    }

    bb13: {
        _23 = &mut ((*_1).1: W);
        _25 = &_3;
        _24 = PrinterPath::<'_>::as_bytes(move _25) -> [return: bb15, unwind: bb27];
    }

    bb14: {
        _20 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _20) -> [return: bb30, unwind: bb27];
    }

    bb15: {
        _22 = <W as std::io::Write>::write_all(move _23, _24) -> [return: bb16, unwind: bb27];
    }

    bb16: {
        _21 = <std::result::Result<(), std::io::Error> as Try>::branch(move _22) -> [return: bb17, unwind: bb27];
    }

    bb17: {
        _26 = discriminant(_21);
        switchInt(move _26) -> [0: bb18, 1: bb19, otherwise: bb8];
    }

    bb18: {
        _30 = &mut ((*_1).1: W);
        _29 = <W as WriteColor>::reset(move _30) -> [return: bb20, unwind: bb27];
    }

    bb19: {
        _27 = move ((_21 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _27) -> [return: bb31, unwind: bb27];
    }

    bb20: {
        _28 = <std::result::Result<(), std::io::Error> as Try>::branch(move _29) -> [return: bb21, unwind: bb27];
    }

    bb21: {
        _31 = discriminant(_28);
        switchInt(move _31) -> [0: bb23, 1: bb22, otherwise: bb8];
    }

    bb22: {
        _32 = move ((_28 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _32) -> [return: bb32, unwind: bb27];
    }

    bb23: {
        _33 = &mut ((*_1).1: W);
        _37 = (((*_1).0: path_printer::Config).2: u8);
        _36 = [move _37];
        _35 = &_36;
        _34 = _35 as &[u8] (PointerCoercion(Unsize));
        _0 = <W as std::io::Write>::write_all(move _33, move _34) -> [return: bb24, unwind: bb27];
    }

    bb24: {
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb25: {
        drop(_3) -> [return: bb26, unwind continue];
    }

    bb26: {
        return;
    }

    bb27 (cleanup): {
        drop(_3) -> [return: bb28, unwind terminate(cleanup)];
    }

    bb28 (cleanup): {
        resume;
    }

    bb29: {
        goto -> bb25;
    }

    bb30: {
        goto -> bb25;
    }

    bb31: {
        goto -> bb25;
    }

    bb32: {
        goto -> bb25;
    }
}

fn search::<impl at crates/core/search.rs:24:10: 24:15>::clone(_1: &search::Config) -> search::Config {
    debug self => _1;
    let mut _0: search::Config;
    let mut _2: bool;
    let _3: &bool;
    let mut _4: std::option::Option<std::path::PathBuf>;
    let _5: &std::option::Option<std::path::PathBuf>;
    let mut _6: ignore::overrides::Override;
    let _7: &ignore::overrides::Override;
    let mut _8: bool;
    let _9: &bool;
    let mut _10: grep::grep_searcher::BinaryDetection;
    let _11: &grep::grep_searcher::BinaryDetection;
    let mut _12: grep::grep_searcher::BinaryDetection;
    let _13: &grep::grep_searcher::BinaryDetection;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _5 = &((*_1).1: std::option::Option<std::path::PathBuf>);
        _4 = <Option<PathBuf> as Clone>::clone(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _7 = &((*_1).2: ignore::overrides::Override);
        _6 = <Override as Clone>::clone(_7) -> [return: bb2, unwind: bb6];
    }

    bb2: {
        _9 = &((*_1).3: bool);
        _8 = (*_9);
        _11 = &((*_1).4: grep::grep_searcher::BinaryDetection);
        _10 = <BinaryDetection as Clone>::clone(_11) -> [return: bb3, unwind: bb5];
    }

    bb3: {
        _13 = &((*_1).5: grep::grep_searcher::BinaryDetection);
        _12 = <BinaryDetection as Clone>::clone(_13) -> [return: bb4, unwind: bb5];
    }

    bb4: {
        _0 = search::Config { json_stats: move _2, preprocessor: move _4, preprocessor_globs: move _6, search_zip: move _8, binary_implicit: move _10, binary_explicit: move _12 };
        return;
    }

    bb5 (cleanup): {
        drop(_6) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn search::<impl at crates/core/search.rs:24:17: 24:22>::fmt(_1: &search::Config, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 6];
    let _5: [&dyn std::fmt::Debug; 6];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &bool;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &std::option::Option<std::path::PathBuf>;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &ignore::overrides::Override;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &bool;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &grep::grep_searcher::BinaryDetection;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&grep::grep_searcher::BinaryDetection;
    let _18: &grep::grep_searcher::BinaryDetection;
    let _19: &str;
    let mut _20: &[&str];
    let mut _21: &[&str; 6];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _21 = const _;
        _7 = &((*_1).0: bool);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: std::option::Option<std::path::PathBuf>);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: ignore::overrides::Override);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: bool);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: grep::grep_searcher::BinaryDetection);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _18 = &((*_1).5: grep::grep_searcher::BinaryDetection);
        _17 = &_18;
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _19 = const "Config";
        _20 = _21 as &[&str] (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_fields_finish(_2, _19, move _20, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:24:17: 24:22>::fmt: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;

    bb0: {
        _3 = const "preprocessor";
        _2 = &(*_3);
        _5 = const "preprocessor_globs";
        _4 = &(*_5);
        _7 = const "search_zip";
        _6 = &(*_7);
        _9 = const "binary_implicit";
        _8 = &(*_9);
        _11 = const "binary_explicit";
        _10 = &(*_11);
        _1 = [const "json_stats", move _2, move _4, move _6, move _8, move _10];
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:34:1: 34:24>::default() -> search::Config {
    let mut _0: search::Config;
    let mut _1: std::option::Option<std::path::PathBuf>;
    let mut _2: ignore::overrides::Override;
    let mut _3: grep::grep_searcher::BinaryDetection;
    let mut _4: grep::grep_searcher::BinaryDetection;

    bb0: {
        _1 = Option::<PathBuf>::None;
        _2 = Override::empty() -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _3 = BinaryDetection::none() -> [return: bb2, unwind: bb4];
    }

    bb2: {
        _4 = BinaryDetection::none() -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = search::Config { json_stats: const false, preprocessor: move _1, preprocessor_globs: move _2, search_zip: const false, binary_implicit: move _3, binary_explicit: move _4 };
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_1) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        resume;
    }
}

fn search::<impl at crates/core/search.rs:48:10: 48:15>::clone(_1: &SearchWorkerBuilder) -> SearchWorkerBuilder {
    debug self => _1;
    let mut _0: search::SearchWorkerBuilder;
    let mut _2: search::Config;
    let _3: &search::Config;
    let mut _4: grep::grep_cli::CommandReaderBuilder;
    let _5: &grep::grep_cli::CommandReaderBuilder;
    let mut _6: grep::grep_cli::DecompressionReaderBuilder;
    let _7: &grep::grep_cli::DecompressionReaderBuilder;

    bb0: {
        _3 = &((*_1).0: search::Config);
        _2 = <search::Config as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: grep::grep_cli::CommandReaderBuilder);
        _4 = <CommandReaderBuilder as Clone>::clone(_5) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        _7 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _6 = <DecompressionReaderBuilder as Clone>::clone(_7) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _0 = SearchWorkerBuilder { config: move _2, command_builder: move _4, decomp_builder: move _6 };
        return;
    }

    bb4 (cleanup): {
        drop(_2) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        resume;
    }
}

fn search::<impl at crates/core/search.rs:48:17: 48:22>::fmt(_1: &SearchWorkerBuilder, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &search::Config;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &grep::grep_cli::CommandReaderBuilder;
    let _10: &str;
    let mut _11: &dyn std::fmt::Debug;
    let _12: &&grep::grep_cli::DecompressionReaderBuilder;
    let _13: &grep::grep_cli::DecompressionReaderBuilder;

    bb0: {
        _3 = const "SearchWorkerBuilder";
        _4 = const "config";
        _6 = &((*_1).0: search::Config);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "command_builder";
        _9 = &((*_1).1: grep::grep_cli::CommandReaderBuilder);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _10 = const "decomp_builder";
        _13 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _12 = &_13;
        _11 = _12 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field3_finish(_2, _3, _4, move _5, _7, move _8, _10, move _11) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:55:1: 55:37>::default() -> SearchWorkerBuilder {
    let mut _0: search::SearchWorkerBuilder;

    bb0: {
        _0 = SearchWorkerBuilder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::new() -> SearchWorkerBuilder {
    let mut _0: search::SearchWorkerBuilder;
    let mut _1: grep::grep_cli::CommandReaderBuilder;
    let _2: &mut grep::grep_cli::CommandReaderBuilder;
    let mut _3: &mut grep::grep_cli::CommandReaderBuilder;
    let _5: &mut grep::grep_cli::DecompressionReaderBuilder;
    let mut _6: &mut grep::grep_cli::DecompressionReaderBuilder;
    let mut _7: search::Config;
    let mut _8: grep::grep_cli::CommandReaderBuilder;
    let mut _9: grep::grep_cli::DecompressionReaderBuilder;
    scope 1 {
        debug cmd_builder => _1;
        let mut _4: grep::grep_cli::DecompressionReaderBuilder;
        scope 2 {
            debug decomp_builder => _4;
        }
    }

    bb0: {
        _1 = CommandReaderBuilder::new() -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = &mut _1;
        _2 = CommandReaderBuilder::async_stderr(move _3, const true) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = DecompressionReaderBuilder::new() -> [return: bb3, unwind continue];
    }

    bb3: {
        _6 = &mut _4;
        _5 = DecompressionReaderBuilder::async_stderr(move _6, const true) -> [return: bb4, unwind: bb6];
    }

    bb4: {
        _7 = <search::Config as Default>::default() -> [return: bb5, unwind: bb6];
    }

    bb5: {
        _8 = move _1;
        _9 = move _4;
        _0 = SearchWorkerBuilder { config: move _7, command_builder: move _8, decomp_builder: move _9 };
        return;
    }

    bb6 (cleanup): {
        drop(_4) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        resume;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::build(_1: &SearchWorkerBuilder, _2: PatternMatcher, _3: grep::grep_searcher::Searcher, _4: Printer<W>) -> SearchWorker<W> {
    debug self => _1;
    debug matcher => _2;
    debug searcher => _3;
    debug printer => _4;
    let mut _0: search::SearchWorker<W>;
    let _5: search::Config;
    let mut _6: &search::Config;
    let mut _8: &grep::grep_cli::CommandReaderBuilder;
    let mut _10: &grep::grep_cli::DecompressionReaderBuilder;
    let mut _11: search::Config;
    let mut _12: search::PatternMatcher;
    let mut _13: grep::grep_searcher::Searcher;
    let mut _14: search::Printer<W>;
    scope 1 {
        debug config => _5;
        let _7: grep::grep_cli::CommandReaderBuilder;
        scope 2 {
            debug command_builder => _7;
            let _9: grep::grep_cli::DecompressionReaderBuilder;
            scope 3 {
                debug decomp_builder => _9;
            }
        }
    }

    bb0: {
        _6 = &((*_1).0: search::Config);
        _5 = <search::Config as Clone>::clone(move _6) -> [return: bb1, unwind: bb5];
    }

    bb1: {
        _8 = &((*_1).1: grep::grep_cli::CommandReaderBuilder);
        _7 = <CommandReaderBuilder as Clone>::clone(move _8) -> [return: bb2, unwind: bb4];
    }

    bb2: {
        _10 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _9 = <DecompressionReaderBuilder as Clone>::clone(move _10) -> [return: bb3, unwind: bb4];
    }

    bb3: {
        _11 = move _5;
        _12 = move _2;
        _13 = move _3;
        _14 = move _4;
        _0 = SearchWorker::<W> { config: move _11, command_builder: move _7, decomp_builder: move _9, matcher: move _12, searcher: move _13, printer: move _14 };
        return;
    }

    bb4 (cleanup): {
        drop(_5) -> [return: bb5, unwind terminate(cleanup)];
    }

    bb5 (cleanup): {
        drop(_4) -> [return: bb6, unwind terminate(cleanup)];
    }

    bb6 (cleanup): {
        drop(_3) -> [return: bb7, unwind terminate(cleanup)];
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::json_stats(_1: &mut SearchWorkerBuilder, _2: bool) -> &mut SearchWorkerBuilder {
    debug self => _1;
    debug yes => _2;
    let mut _0: &mut search::SearchWorkerBuilder;

    bb0: {
        (((*_1).0: search::Config).0: bool) = _2;
        _0 = _1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::preprocessor(_1: &mut SearchWorkerBuilder, _2: Option<PathBuf>) -> std::result::Result<&mut SearchWorkerBuilder, Box<dyn std::error::Error>> {
    debug self => _1;
    debug cmd => _2;
    let mut _0: std::result::Result<&mut search::SearchWorkerBuilder, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: isize;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>, std::path::PathBuf>;
    let mut _7: std::result::Result<std::path::PathBuf, grep::grep_cli::CommandError>;
    let mut _8: isize;
    let mut _11: std::option::Option<std::path::PathBuf>;
    let mut _12: std::path::PathBuf;
    let mut _13: std::option::Option<std::path::PathBuf>;
    let mut _14: bool;
    scope 1 {
        debug prog => _4;
        let _4: &std::path::PathBuf;
        let _5: std::path::PathBuf;
        let _9: std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>;
        let _10: std::path::PathBuf;
        scope 2 {
            debug bin => _5;
        }
        scope 3 {
            debug residual => _9;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _10;
            scope 6 {
            }
        }
    }

    bb0: {
        _14 = const false;
        _3 = discriminant(_2);
        switchInt(move _3) -> [1: bb1, otherwise: bb10];
    }

    bb1: {
        _4 = &((_2 as Some).0: std::path::PathBuf);
        _7 = resolve_binary::<&PathBuf>(_4) -> [return: bb2, unwind: bb15];
    }

    bb2: {
        _6 = <std::result::Result<PathBuf, CommandError> as Try>::branch(move _7) -> [return: bb3, unwind: bb15];
    }

    bb3: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _10 = move ((_6 as Continue).0: std::path::PathBuf);
        _14 = const true;
        _5 = move _10;
        _14 = const false;
        _12 = move _5;
        _11 = Option::<PathBuf>::Some(move _12);
        drop((((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>)) -> [return: bb8, unwind: bb9];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _9 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>);
        _0 = <std::result::Result<&mut SearchWorkerBuilder, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, CommandError>>>::from_residual(move _9) -> [return: bb7, unwind: bb15];
    }

    bb7: {
        _14 = const false;
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb8: {
        (((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>) = move _11;
        _14 = const false;
        goto -> bb13;
    }

    bb9 (cleanup): {
        (((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>) = move _11;
        switchInt(_14) -> [0: bb15, otherwise: bb17];
    }

    bb10: {
        _13 = Option::<PathBuf>::None;
        drop((((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>)) -> [return: bb11, unwind: bb12];
    }

    bb11: {
        (((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>) = move _13;
        goto -> bb13;
    }

    bb12 (cleanup): {
        (((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>) = move _13;
        goto -> bb15;
    }

    bb13: {
        _0 = std::result::Result::<&mut SearchWorkerBuilder, Box<dyn std::error::Error>>::Ok(_1);
        drop(_2) -> [return: bb14, unwind continue];
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        drop(_2) -> [return: bb16, unwind terminate(cleanup)];
    }

    bb16 (cleanup): {
        resume;
    }

    bb17 (cleanup): {
        drop(_5) -> [return: bb15, unwind terminate(cleanup)];
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::preprocessor_globs(_1: &mut SearchWorkerBuilder, _2: Override) -> &mut SearchWorkerBuilder {
    debug self => _1;
    debug globs => _2;
    let mut _0: &mut search::SearchWorkerBuilder;

    bb0: {
        drop((((*_1).0: search::Config).2: ignore::overrides::Override)) -> [return: bb1, unwind: bb2];
    }

    bb1: {
        (((*_1).0: search::Config).2: ignore::overrides::Override) = move _2;
        _0 = _1;
        return;
    }

    bb2 (cleanup): {
        (((*_1).0: search::Config).2: ignore::overrides::Override) = move _2;
        resume;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::search_zip(_1: &mut SearchWorkerBuilder, _2: bool) -> &mut SearchWorkerBuilder {
    debug self => _1;
    debug yes => _2;
    let mut _0: &mut search::SearchWorkerBuilder;

    bb0: {
        (((*_1).0: search::Config).3: bool) = _2;
        _0 = _1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::binary_detection_implicit(_1: &mut SearchWorkerBuilder, _2: BinaryDetection) -> &mut SearchWorkerBuilder {
    debug self => _1;
    debug detection => _2;
    let mut _0: &mut search::SearchWorkerBuilder;

    bb0: {
        (((*_1).0: search::Config).4: grep::grep_searcher::BinaryDetection) = move _2;
        _0 = _1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:61:1: 61:25>::binary_detection_explicit(_1: &mut SearchWorkerBuilder, _2: BinaryDetection) -> &mut SearchWorkerBuilder {
    debug self => _1;
    debug detection => _2;
    let mut _0: &mut search::SearchWorkerBuilder;

    bb0: {
        (((*_1).0: search::Config).5: grep::grep_searcher::BinaryDetection) = move _2;
        _0 = _1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:189:10: 189:15>::clone(_1: &SearchResult) -> SearchResult {
    debug self => _1;
    let mut _0: search::SearchResult;
    let mut _2: bool;
    let _3: &bool;
    let mut _4: std::option::Option<grep::grep_printer::Stats>;
    let _5: &std::option::Option<grep::grep_printer::Stats>;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _5 = &((*_1).1: std::option::Option<grep::grep_printer::Stats>);
        _4 = <Option<Stats> as Clone>::clone(_5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = SearchResult { has_match: move _2, stats: move _4 };
        return;
    }
}

fn search::<impl at crates/core/search.rs:189:17: 189:22>::fmt(_1: &SearchResult, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &bool;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&std::option::Option<grep::grep_printer::Stats>;
    let _10: &std::option::Option<grep::grep_printer::Stats>;

    bb0: {
        _3 = const "SearchResult";
        _4 = const "has_match";
        _6 = &((*_1).0: bool);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "stats";
        _10 = &((*_1).1: std::option::Option<grep::grep_printer::Stats>);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:189:24: 189:31>::default() -> SearchResult {
    let mut _0: search::SearchResult;
    let mut _1: bool;
    let mut _2: std::option::Option<grep::grep_printer::Stats>;

    bb0: {
        _1 = <bool as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <Option<Stats> as Default>::default() -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = SearchResult { has_match: move _1, stats: move _2 };
        return;
    }
}

fn search::<impl at crates/core/search.rs:195:1: 195:18>::has_match(_1: &SearchResult) -> bool {
    debug self => _1;
    let mut _0: bool;

    bb0: {
        _0 = ((*_1).0: bool);
        return;
    }
}

fn search::<impl at crates/core/search.rs:195:1: 195:18>::stats(_1: &SearchResult) -> Option<&Stats> {
    debug self => _1;
    let mut _0: std::option::Option<&grep::grep_printer::Stats>;
    let mut _2: &std::option::Option<grep::grep_printer::Stats>;

    bb0: {
        _2 = &((*_1).1: std::option::Option<grep::grep_printer::Stats>);
        _0 = Option::<Stats>::as_ref(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:211:10: 211:15>::clone(_1: &PatternMatcher) -> PatternMatcher {
    debug self => _1;
    let mut _0: search::PatternMatcher;
    let _2: &grep::grep_regex::RegexMatcher;
    let mut _3: grep::grep_regex::RegexMatcher;
    scope 1 {
        debug __self_0 => _2;
    }

    bb0: {
        _2 = &(((*_1) as RustRegex).0: grep::grep_regex::RegexMatcher);
        _3 = <RegexMatcher as Clone>::clone(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = PatternMatcher::RustRegex(move _3);
        return;
    }
}

fn search::<impl at crates/core/search.rs:211:17: 211:22>::fmt(_1: &PatternMatcher, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &grep::grep_regex::RegexMatcher;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&grep::grep_regex::RegexMatcher;
    scope 1 {
        debug __self_0 => _3;
    }

    bb0: {
        _3 = &(((*_1) as RustRegex).0: grep::grep_regex::RegexMatcher);
        _4 = const "RustRegex";
        _6 = &_3;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:221:10: 221:15>::fmt(_1: &Printer<W>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let mut _3: isize;
    let _4: &grep::grep_printer::Standard<W>;
    let _5: &str;
    let mut _6: &dyn std::fmt::Debug;
    let _7: &&grep::grep_printer::Standard<W>;
    let _8: &grep::grep_printer::Summary<W>;
    let _9: &str;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &&grep::grep_printer::Summary<W>;
    let _12: &grep::grep_printer::JSON<W>;
    let _13: &str;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &&grep::grep_printer::JSON<W>;
    scope 1 {
        debug __self_0 => _4;
    }
    scope 2 {
        debug __self_0 => _8;
    }
    scope 3 {
        debug __self_0 => _12;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb4, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _12 = &(((*_1) as JSON).0: grep::grep_printer::JSON<W>);
        _13 = const "JSON";
        _15 = &_12;
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _13, move _14) -> [return: bb5, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &(((*_1) as Standard).0: grep::grep_printer::Standard<W>);
        _5 = const "Standard";
        _7 = &_4;
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _5, move _6) -> [return: bb5, unwind continue];
    }

    bb4: {
        _8 = &(((*_1) as Summary).0: grep::grep_printer::Summary<W>);
        _9 = const "Summary";
        _11 = &_8;
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_tuple_field1_finish(_2, _9, move _10) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats(_1: &mut Printer<W>, _2: Duration, _3: &Stats) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug total_duration => _2;
    debug stats => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: isize;

    bb0: {
        _4 = discriminant((*_1));
        switchInt(move _4) -> [0: bb3, 1: bb3, 2: bb2, otherwise: bb1];
    }

    bb1: {
        unreachable;
    }

    bb2: {
        _0 = Printer::<W>::print_stats_json(_1, _2, _3) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = Printer::<W>::print_stats_human(_1, _2, _3) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_human(_1: &mut Printer<W>, _2: Duration, _3: &Stats) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug total_duration => _2;
    debug stats => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: &mut W;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 8];
    let _9: [core::fmt::rt::Argument<'_>; 8];
    let mut _10: core::fmt::rt::Argument<'_>;
    let _11: &u64;
    let _12: u64;
    let mut _13: core::fmt::rt::Argument<'_>;
    let _14: &u64;
    let _15: u64;
    let mut _16: core::fmt::rt::Argument<'_>;
    let _17: &u64;
    let _18: u64;
    let mut _19: core::fmt::rt::Argument<'_>;
    let _20: &u64;
    let _21: u64;
    let mut _22: core::fmt::rt::Argument<'_>;
    let _23: &u64;
    let _24: u64;
    let mut _25: core::fmt::rt::Argument<'_>;
    let _26: &u64;
    let _27: u64;
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &f64;
    let _30: f64;
    let mut _31: std::time::Duration;
    let mut _32: core::fmt::rt::Argument<'_>;
    let _33: &f64;
    let _34: f64;
    let mut _35: &[core::fmt::rt::Placeholder];
    let _36: &[core::fmt::rt::Placeholder; 8];
    let _37: [core::fmt::rt::Placeholder; 8];
    let mut _38: core::fmt::rt::Placeholder;
    let mut _39: core::fmt::rt::Alignment;
    let mut _40: core::fmt::rt::Count;
    let mut _41: core::fmt::rt::Count;
    let mut _42: core::fmt::rt::Placeholder;
    let mut _43: core::fmt::rt::Alignment;
    let mut _44: core::fmt::rt::Count;
    let mut _45: core::fmt::rt::Count;
    let mut _46: core::fmt::rt::Placeholder;
    let mut _47: core::fmt::rt::Alignment;
    let mut _48: core::fmt::rt::Count;
    let mut _49: core::fmt::rt::Count;
    let mut _50: core::fmt::rt::Placeholder;
    let mut _51: core::fmt::rt::Alignment;
    let mut _52: core::fmt::rt::Count;
    let mut _53: core::fmt::rt::Count;
    let mut _54: core::fmt::rt::Placeholder;
    let mut _55: core::fmt::rt::Alignment;
    let mut _56: core::fmt::rt::Count;
    let mut _57: core::fmt::rt::Count;
    let mut _58: core::fmt::rt::Placeholder;
    let mut _59: core::fmt::rt::Alignment;
    let mut _60: core::fmt::rt::Count;
    let mut _61: core::fmt::rt::Count;
    let mut _62: core::fmt::rt::Placeholder;
    let mut _63: core::fmt::rt::Alignment;
    let mut _64: core::fmt::rt::Count;
    let mut _65: core::fmt::rt::Count;
    let mut _66: core::fmt::rt::Placeholder;
    let mut _67: core::fmt::rt::Alignment;
    let mut _68: core::fmt::rt::Count;
    let mut _69: core::fmt::rt::Count;
    let mut _70: core::fmt::rt::UnsafeArg;
    let mut _71: &[&str; 9];
    scope 1 {
    }

    bb0: {
        _4 = Printer::<W>::get_mut(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _71 = const _;
        _6 = _71 as &[&str] (PointerCoercion(Unsize));
        _12 = Stats::matches(_3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _11 = &_12;
        _10 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_11) -> [return: bb3, unwind continue];
    }

    bb3: {
        _15 = Stats::matched_lines(_3) -> [return: bb4, unwind continue];
    }

    bb4: {
        _14 = &_15;
        _13 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_14) -> [return: bb5, unwind continue];
    }

    bb5: {
        _18 = Stats::searches_with_match(_3) -> [return: bb6, unwind continue];
    }

    bb6: {
        _17 = &_18;
        _16 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_17) -> [return: bb7, unwind continue];
    }

    bb7: {
        _21 = Stats::searches(_3) -> [return: bb8, unwind continue];
    }

    bb8: {
        _20 = &_21;
        _19 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_20) -> [return: bb9, unwind continue];
    }

    bb9: {
        _24 = Stats::bytes_printed(_3) -> [return: bb10, unwind continue];
    }

    bb10: {
        _23 = &_24;
        _22 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_23) -> [return: bb11, unwind continue];
    }

    bb11: {
        _27 = Stats::bytes_searched(_3) -> [return: bb12, unwind continue];
    }

    bb12: {
        _26 = &_27;
        _25 = core::fmt::rt::Argument::<'_>::new_display::<u64>(_26) -> [return: bb13, unwind continue];
    }

    bb13: {
        _31 = Stats::elapsed(_3) -> [return: bb14, unwind continue];
    }

    bb14: {
        _30 = fractional_seconds(move _31) -> [return: bb15, unwind continue];
    }

    bb15: {
        _29 = &_30;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<f64>(_29) -> [return: bb16, unwind continue];
    }

    bb16: {
        _34 = fractional_seconds(_2) -> [return: bb17, unwind continue];
    }

    bb17: {
        _33 = &_34;
        _32 = core::fmt::rt::Argument::<'_>::new_display::<f64>(_33) -> [return: bb18, unwind continue];
    }

    bb18: {
        _9 = [move _10, move _13, move _16, move _19, move _22, move _25, move _28, move _32];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _39 = core::fmt::rt::Alignment::Unknown;
        _40 = core::fmt::rt::Count::Implied;
        _41 = core::fmt::rt::Count::Implied;
        _38 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _39, const 0_u32, move _40, move _41) -> [return: bb19, unwind continue];
    }

    bb19: {
        _43 = core::fmt::rt::Alignment::Unknown;
        _44 = core::fmt::rt::Count::Implied;
        _45 = core::fmt::rt::Count::Implied;
        _42 = core::fmt::rt::Placeholder::new(const 1_usize, const ' ', move _43, const 0_u32, move _44, move _45) -> [return: bb20, unwind continue];
    }

    bb20: {
        _47 = core::fmt::rt::Alignment::Unknown;
        _48 = core::fmt::rt::Count::Implied;
        _49 = core::fmt::rt::Count::Implied;
        _46 = core::fmt::rt::Placeholder::new(const 2_usize, const ' ', move _47, const 0_u32, move _48, move _49) -> [return: bb21, unwind continue];
    }

    bb21: {
        _51 = core::fmt::rt::Alignment::Unknown;
        _52 = core::fmt::rt::Count::Implied;
        _53 = core::fmt::rt::Count::Implied;
        _50 = core::fmt::rt::Placeholder::new(const 3_usize, const ' ', move _51, const 0_u32, move _52, move _53) -> [return: bb22, unwind continue];
    }

    bb22: {
        _55 = core::fmt::rt::Alignment::Unknown;
        _56 = core::fmt::rt::Count::Implied;
        _57 = core::fmt::rt::Count::Implied;
        _54 = core::fmt::rt::Placeholder::new(const 4_usize, const ' ', move _55, const 0_u32, move _56, move _57) -> [return: bb23, unwind continue];
    }

    bb23: {
        _59 = core::fmt::rt::Alignment::Unknown;
        _60 = core::fmt::rt::Count::Implied;
        _61 = core::fmt::rt::Count::Implied;
        _58 = core::fmt::rt::Placeholder::new(const 5_usize, const ' ', move _59, const 0_u32, move _60, move _61) -> [return: bb24, unwind continue];
    }

    bb24: {
        _63 = core::fmt::rt::Alignment::Unknown;
        _64 = core::fmt::rt::Count::Is(const 6_usize);
        _65 = core::fmt::rt::Count::Implied;
        _62 = core::fmt::rt::Placeholder::new(const 6_usize, const ' ', move _63, const 8_u32, move _64, move _65) -> [return: bb25, unwind continue];
    }

    bb25: {
        _67 = core::fmt::rt::Alignment::Unknown;
        _68 = core::fmt::rt::Count::Is(const 6_usize);
        _69 = core::fmt::rt::Count::Implied;
        _66 = core::fmt::rt::Placeholder::new(const 7_usize, const ' ', move _67, const 8_u32, move _68, move _69) -> [return: bb26, unwind continue];
    }

    bb26: {
        _37 = [move _38, move _42, move _46, move _50, move _54, move _58, move _62, move _66];
        _36 = &_37;
        _35 = _36 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _70 = core::fmt::rt::UnsafeArg::new() -> [return: bb27, unwind continue];
    }

    bb27: {
        _5 = Arguments::<'_>::new_v1_formatted(move _6, move _7, move _35, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb28, unwind continue];
    }

    bb28: {
        _0 = <W as std::io::Write>::write_fmt(_4, move _5) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_human: &[&str; 9] = {
    let mut _0: &[&str; 9];
    let mut _1: [&str; 9];

    bb0: {
        _1 = [const "\n", const " matches\n", const " matched lines\n", const " files contained matches\n", const " files searched\n", const " bytes printed\n", const " bytes searched\n", const " seconds spent searching\n", const " seconds\n"];
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_json(_1: &mut Printer<W>, _2: Duration, _3: &Stats) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug total_duration => _2;
    debug stats => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let _4: f64;
    let mut _5: std::time::Duration;
    let mut _6: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, serde_json::Error>>;
    let mut _7: std::result::Result<(), serde_json::Error>;
    let mut _8: &mut W;
    let _9: &serde_json::Value;
    let _10: serde_json::Value;
    let mut _11: serde_json::Map<std::string::String, serde_json::Value>;
    let mut _13: std::option::Option<serde_json::Value>;
    let mut _14: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _15: std::string::String;
    let _16: &str;
    let mut _17: serde_json::Value;
    let mut _18: std::result::Result<serde_json::Value, serde_json::Error>;
    let mut _19: std::option::Option<serde_json::Value>;
    let mut _20: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _21: std::string::String;
    let _22: &str;
    let mut _23: serde_json::Value;
    let mut _24: serde_json::Map<std::string::String, serde_json::Value>;
    let mut _26: std::option::Option<serde_json::Value>;
    let mut _27: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _28: std::string::String;
    let _29: &str;
    let mut _30: serde_json::Value;
    let mut _31: std::result::Result<serde_json::Value, serde_json::Error>;
    let mut _32: &&grep::grep_printer::Stats;
    let mut _33: std::option::Option<serde_json::Value>;
    let mut _34: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _35: std::string::String;
    let _36: &str;
    let mut _37: serde_json::Value;
    let mut _38: serde_json::Map<std::string::String, serde_json::Value>;
    let mut _40: std::option::Option<serde_json::Value>;
    let mut _41: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _42: std::string::String;
    let _43: &str;
    let mut _44: serde_json::Value;
    let mut _45: std::result::Result<serde_json::Value, serde_json::Error>;
    let mut _46: &u64;
    let _47: u64;
    let mut _48: &std::time::Duration;
    let mut _49: std::option::Option<serde_json::Value>;
    let mut _50: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _51: std::string::String;
    let _52: &str;
    let mut _53: serde_json::Value;
    let mut _54: std::result::Result<serde_json::Value, serde_json::Error>;
    let mut _55: &u32;
    let _56: u32;
    let mut _57: &std::time::Duration;
    let mut _58: std::option::Option<serde_json::Value>;
    let mut _59: &mut serde_json::Map<std::string::String, serde_json::Value>;
    let mut _60: std::string::String;
    let _61: &str;
    let mut _62: serde_json::Value;
    let mut _63: std::result::Result<serde_json::Value, serde_json::Error>;
    let mut _64: &std::string::String;
    let _65: std::string::String;
    let mut _67: std::fmt::Arguments<'_>;
    let mut _68: &[&str];
    let mut _69: &[core::fmt::rt::Argument<'_>];
    let _70: &[core::fmt::rt::Argument<'_>; 1];
    let _71: [core::fmt::rt::Argument<'_>; 1];
    let mut _72: core::fmt::rt::Argument<'_>;
    let _73: &f64;
    let mut _74: &[core::fmt::rt::Placeholder];
    let _75: &[core::fmt::rt::Placeholder; 1];
    let _76: [core::fmt::rt::Placeholder; 1];
    let mut _77: core::fmt::rt::Placeholder;
    let mut _78: core::fmt::rt::Alignment;
    let mut _79: core::fmt::rt::Count;
    let mut _80: core::fmt::rt::Count;
    let mut _81: core::fmt::rt::UnsafeArg;
    let mut _82: isize;
    let mut _84: &mut W;
    let mut _85: std::fmt::Arguments<'_>;
    let mut _86: &[&str];
    let mut _90: bool;
    let mut _91: bool;
    let mut _92: bool;
    let mut _93: bool;
    let mut _94: bool;
    let mut _95: bool;
    let mut _96: bool;
    scope 1 {
        debug fractional => _4;
        let mut _12: serde_json::Map<std::string::String, serde_json::Value>;
        let _83: std::result::Result<std::convert::Infallible, serde_json::Error>;
        let mut _87: &[&str; 1];
        scope 2 {
            debug object => _12;
            let mut _89: &&str;
            scope 3 {
                let mut _25: serde_json::Map<std::string::String, serde_json::Value>;
                scope 4 {
                }
                scope 5 {
                    debug object => _25;
                    scope 6 {
                        let mut _39: serde_json::Map<std::string::String, serde_json::Value>;
                        scope 7 {
                        }
                        scope 8 {
                            debug object => _39;
                            scope 9 {
                                scope 10 {
                                    let _66: std::string::String;
                                    let mut _88: &[&str; 2];
                                    scope 11 {
                                    }
                                    scope 12 {
                                        debug res => _66;
                                    }
                                    scope 13 {
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        scope 14 {
            debug residual => _83;
            scope 15 {
            }
        }
        scope 16 {
            debug val => const ();
            scope 17 {
            }
        }
    }

    bb0: {
        _96 = const false;
        _95 = const false;
        _94 = const false;
        _93 = const false;
        _92 = const false;
        _91 = const false;
        _90 = const false;
        _5 = _2;
        _4 = fractional_seconds(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = Printer::<W>::get_mut(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _12 = serde_json::Map::<std::string::String, Value>::new() -> [return: bb3, unwind continue];
    }

    bb3: {
        _14 = &mut _12;
        _16 = const "type";
        _15 = <&str as Into<std::string::String>>::into(_16) -> [return: bb4, unwind: bb60];
    }

    bb4: {
        _96 = const true;
        _89 = const _;
        _18 = to_value::<&&str>(_89) -> [return: bb5, unwind: bb75];
    }

    bb5: {
        _17 = std::result::Result::<Value, serde_json::Error>::unwrap(move _18) -> [return: bb6, unwind: bb75];
    }

    bb6: {
        _96 = const false;
        _13 = serde_json::Map::<std::string::String, Value>::insert(move _14, move _15, move _17) -> [return: bb7, unwind: bb75];
    }

    bb7: {
        _96 = const false;
        drop(_13) -> [return: bb8, unwind: bb60];
    }

    bb8: {
        _20 = &mut _12;
        _22 = const "data";
        _21 = <&str as Into<std::string::String>>::into(_22) -> [return: bb9, unwind: bb60];
    }

    bb9: {
        _95 = const true;
        _25 = serde_json::Map::<std::string::String, Value>::new() -> [return: bb10, unwind: bb73];
    }

    bb10: {
        _27 = &mut _25;
        _29 = const "stats";
        _28 = <&str as Into<std::string::String>>::into(_29) -> [return: bb11, unwind: bb59];
    }

    bb11: {
        _94 = const true;
        _32 = &_3;
        _31 = to_value::<&&Stats>(move _32) -> [return: bb12, unwind: bb71];
    }

    bb12: {
        _30 = std::result::Result::<Value, serde_json::Error>::unwrap(move _31) -> [return: bb13, unwind: bb71];
    }

    bb13: {
        _94 = const false;
        _26 = serde_json::Map::<std::string::String, Value>::insert(move _27, move _28, move _30) -> [return: bb14, unwind: bb71];
    }

    bb14: {
        _94 = const false;
        drop(_26) -> [return: bb15, unwind: bb59];
    }

    bb15: {
        _34 = &mut _25;
        _36 = const "elapsed_total";
        _35 = <&str as Into<std::string::String>>::into(_36) -> [return: bb16, unwind: bb59];
    }

    bb16: {
        _93 = const true;
        _39 = serde_json::Map::<std::string::String, Value>::new() -> [return: bb17, unwind: bb69];
    }

    bb17: {
        _41 = &mut _39;
        _43 = const "secs";
        _42 = <&str as Into<std::string::String>>::into(_43) -> [return: bb18, unwind: bb58];
    }

    bb18: {
        _92 = const true;
        _48 = &_2;
        _47 = Duration::as_secs(move _48) -> [return: bb19, unwind: bb67];
    }

    bb19: {
        _46 = &_47;
        _45 = to_value::<&u64>(move _46) -> [return: bb20, unwind: bb67];
    }

    bb20: {
        _44 = std::result::Result::<Value, serde_json::Error>::unwrap(move _45) -> [return: bb21, unwind: bb67];
    }

    bb21: {
        _92 = const false;
        _40 = serde_json::Map::<std::string::String, Value>::insert(move _41, move _42, move _44) -> [return: bb22, unwind: bb67];
    }

    bb22: {
        _92 = const false;
        drop(_40) -> [return: bb23, unwind: bb58];
    }

    bb23: {
        _50 = &mut _39;
        _52 = const "nanos";
        _51 = <&str as Into<std::string::String>>::into(_52) -> [return: bb24, unwind: bb58];
    }

    bb24: {
        _91 = const true;
        _57 = &_2;
        _56 = Duration::subsec_nanos(move _57) -> [return: bb25, unwind: bb65];
    }

    bb25: {
        _55 = &_56;
        _54 = to_value::<&u32>(move _55) -> [return: bb26, unwind: bb65];
    }

    bb26: {
        _53 = std::result::Result::<Value, serde_json::Error>::unwrap(move _54) -> [return: bb27, unwind: bb65];
    }

    bb27: {
        _91 = const false;
        _49 = serde_json::Map::<std::string::String, Value>::insert(move _50, move _51, move _53) -> [return: bb28, unwind: bb65];
    }

    bb28: {
        _91 = const false;
        drop(_49) -> [return: bb29, unwind: bb58];
    }

    bb29: {
        _59 = &mut _39;
        _61 = const "human";
        _60 = <&str as Into<std::string::String>>::into(_61) -> [return: bb30, unwind: bb58];
    }

    bb30: {
        _90 = const true;
        _88 = const _;
        _68 = _88 as &[&str] (PointerCoercion(Unsize));
        _73 = &_4;
        _72 = core::fmt::rt::Argument::<'_>::new_display::<f64>(_73) -> [return: bb31, unwind: bb57];
    }

    bb31: {
        _71 = [move _72];
        _70 = &_71;
        _69 = _70 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _78 = core::fmt::rt::Alignment::Unknown;
        _79 = core::fmt::rt::Count::Is(const 6_usize);
        _80 = core::fmt::rt::Count::Implied;
        _77 = core::fmt::rt::Placeholder::new(const 0_usize, const ' ', move _78, const 8_u32, move _79, move _80) -> [return: bb32, unwind: bb57];
    }

    bb32: {
        _76 = [move _77];
        _75 = &_76;
        _74 = _75 as &[core::fmt::rt::Placeholder] (PointerCoercion(Unsize));
        _81 = core::fmt::rt::UnsafeArg::new() -> [return: bb33, unwind: bb57];
    }

    bb33: {
        _67 = Arguments::<'_>::new_v1_formatted(move _68, move _69, move _74, const core::fmt::rt::UnsafeArg {{ _private: () }}) -> [return: bb34, unwind: bb57];
    }

    bb34: {
        _66 = format(move _67) -> [return: bb35, unwind: bb57];
    }

    bb35: {
        _65 = move _66;
        _64 = &_65;
        _63 = to_value::<&std::string::String>(move _64) -> [return: bb36, unwind: bb63];
    }

    bb36: {
        _62 = std::result::Result::<Value, serde_json::Error>::unwrap(move _63) -> [return: bb37, unwind: bb63];
    }

    bb37: {
        _90 = const false;
        _58 = serde_json::Map::<std::string::String, Value>::insert(move _59, move _60, move _62) -> [return: bb38, unwind: bb63];
    }

    bb38: {
        _90 = const false;
        drop(_58) -> [return: bb39, unwind: bb56];
    }

    bb39: {
        drop(_65) -> [return: bb40, unwind: bb58];
    }

    bb40: {
        _38 = move _39;
        _37 = Object(move _38);
        _93 = const false;
        _33 = serde_json::Map::<std::string::String, Value>::insert(move _34, move _35, move _37) -> [return: bb41, unwind: bb69];
    }

    bb41: {
        _93 = const false;
        drop(_33) -> [return: bb42, unwind: bb59];
    }

    bb42: {
        _24 = move _25;
        _23 = Object(move _24);
        _95 = const false;
        _19 = serde_json::Map::<std::string::String, Value>::insert(move _20, move _21, move _23) -> [return: bb43, unwind: bb73];
    }

    bb43: {
        _95 = const false;
        drop(_19) -> [return: bb44, unwind: bb60];
    }

    bb44: {
        _11 = move _12;
        _10 = Object(move _11);
        _9 = &_10;
        _7 = to_writer::<&mut W, Value>(move _8, _9) -> [return: bb45, unwind: bb55];
    }

    bb45: {
        _6 = <std::result::Result<(), serde_json::Error> as Try>::branch(move _7) -> [return: bb46, unwind: bb55];
    }

    bb46: {
        _82 = discriminant(_6);
        switchInt(move _82) -> [0: bb47, 1: bb49, otherwise: bb48];
    }

    bb47: {
        drop(_10) -> [return: bb51, unwind continue];
    }

    bb48: {
        unreachable;
    }

    bb49: {
        _83 = move ((_6 as Break).0: std::result::Result<std::convert::Infallible, serde_json::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, serde_json::Error>>>::from_residual(move _83) -> [return: bb50, unwind: bb55];
    }

    bb50: {
        drop(_10) -> [return: bb54, unwind continue];
    }

    bb51: {
        _84 = Printer::<W>::get_mut(_1) -> [return: bb52, unwind continue];
    }

    bb52: {
        _87 = const _;
        _86 = _87 as &[&str] (PointerCoercion(Unsize));
        _85 = Arguments::<'_>::new_const(move _86) -> [return: bb53, unwind continue];
    }

    bb53: {
        _0 = <W as std::io::Write>::write_fmt(_84, move _85) -> [return: bb54, unwind continue];
    }

    bb54: {
        return;
    }

    bb55 (cleanup): {
        drop(_10) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_65) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_60) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_39) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_25) -> [return: bb73, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_12) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        resume;
    }

    bb62 (cleanup): {
        drop(_60) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb63 (cleanup): {
        switchInt(_90) -> [0: bb56, otherwise: bb62];
    }

    bb64 (cleanup): {
        drop(_51) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb65 (cleanup): {
        switchInt(_91) -> [0: bb58, otherwise: bb64];
    }

    bb66 (cleanup): {
        drop(_42) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        switchInt(_92) -> [0: bb58, otherwise: bb66];
    }

    bb68 (cleanup): {
        drop(_35) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        switchInt(_93) -> [0: bb59, otherwise: bb68];
    }

    bb70 (cleanup): {
        drop(_28) -> [return: bb59, unwind terminate(cleanup)];
    }

    bb71 (cleanup): {
        switchInt(_94) -> [0: bb59, otherwise: bb70];
    }

    bb72 (cleanup): {
        drop(_21) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb73 (cleanup): {
        switchInt(_95) -> [0: bb60, otherwise: bb72];
    }

    bb74 (cleanup): {
        drop(_15) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb75 (cleanup): {
        switchInt(_96) -> [0: bb60, otherwise: bb74];
    }
}

promoted[0] in search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_json: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_json: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "s"];
        _0 = &_1;
        return;
    }
}

promoted[2] in search::<impl at crates/core/search.rs:232:1: 232:31>::print_stats_json: &&str = {
    let mut _0: &&str;
    let mut _1: &str;

    bb0: {
        _1 = const "summary";
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:232:1: 232:31>::get_mut(_1: &mut Printer<W>) -> &mut W {
    debug self => _1;
    let mut _0: &mut W;
    let mut _2: &mut W;
    let mut _3: isize;
    let _4: &mut grep::grep_printer::Standard<W>;
    let mut _5: &mut W;
    let _6: &mut grep::grep_printer::Summary<W>;
    let mut _7: &mut W;
    let _8: &mut grep::grep_printer::JSON<W>;
    let mut _9: &mut W;
    scope 1 {
        debug p => _4;
    }
    scope 2 {
        debug p => _6;
    }
    scope 3 {
        debug p => _8;
    }

    bb0: {
        _3 = discriminant((*_1));
        switchInt(move _3) -> [0: bb3, 1: bb5, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _8 = &mut (((*_1) as JSON).0: grep::grep_printer::JSON<W>);
        _9 = JSON::<W>::get_mut(_8) -> [return: bb7, unwind continue];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = &mut (((*_1) as Standard).0: grep::grep_printer::Standard<W>);
        _5 = Standard::<W>::get_mut(_4) -> [return: bb4, unwind continue];
    }

    bb4: {
        _2 = _5;
        goto -> bb8;
    }

    bb5: {
        _6 = &mut (((*_1) as Summary).0: grep::grep_printer::Summary<W>);
        _7 = Summary::<W>::get_mut(_6) -> [return: bb6, unwind continue];
    }

    bb6: {
        _2 = _7;
        goto -> bb8;
    }

    bb7: {
        _2 = _9;
        goto -> bb8;
    }

    bb8: {
        _0 = _2;
        return;
    }
}

fn search::<impl at crates/core/search.rs:315:10: 315:15>::fmt(_1: &SearchWorker<W>, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _4: &[&dyn std::fmt::Debug; 6];
    let _5: [&dyn std::fmt::Debug; 6];
    let mut _6: &dyn std::fmt::Debug;
    let _7: &search::Config;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &grep::grep_cli::CommandReaderBuilder;
    let mut _10: &dyn std::fmt::Debug;
    let _11: &grep::grep_cli::DecompressionReaderBuilder;
    let mut _12: &dyn std::fmt::Debug;
    let _13: &search::PatternMatcher;
    let mut _14: &dyn std::fmt::Debug;
    let _15: &grep::grep_searcher::Searcher;
    let mut _16: &dyn std::fmt::Debug;
    let _17: &&search::Printer<W>;
    let _18: &search::Printer<W>;
    let _19: &str;
    let mut _20: &[&str];
    let mut _21: &[&str; 6];
    scope 1 {
        debug names => const _;
        let _3: &[&dyn std::fmt::Debug];
        scope 2 {
            debug values => _3;
        }
    }

    bb0: {
        _21 = const _;
        _7 = &((*_1).0: search::Config);
        _6 = _7 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _9 = &((*_1).1: grep::grep_cli::CommandReaderBuilder);
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _11 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _10 = _11 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _13 = &((*_1).3: search::PatternMatcher);
        _12 = _13 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _15 = &((*_1).4: grep::grep_searcher::Searcher);
        _14 = _15 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _18 = &((*_1).5: search::Printer<W>);
        _17 = &_18;
        _16 = _17 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _5 = [move _6, move _8, move _10, move _12, move _14, move _16];
        _4 = &_5;
        _3 = _4 as &[&dyn std::fmt::Debug] (PointerCoercion(Unsize));
        _19 = const "SearchWorker";
        _20 = _21 as &[&str] (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_fields_finish(_2, _19, move _20, _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:315:10: 315:15>::fmt: &[&str; 6] = {
    let mut _0: &[&str; 6];
    let mut _1: [&str; 6];
    let mut _2: &str;
    let mut _3: &str;
    let mut _4: &str;
    let mut _5: &str;
    let mut _6: &str;
    let mut _7: &str;
    let mut _8: &str;
    let mut _9: &str;
    let mut _10: &str;
    let mut _11: &str;

    bb0: {
        _3 = const "command_builder";
        _2 = &(*_3);
        _5 = const "decomp_builder";
        _4 = &(*_5);
        _7 = const "matcher";
        _6 = &(*_7);
        _9 = const "searcher";
        _8 = &(*_9);
        _11 = const "printer";
        _10 = &(*_11);
        _1 = [const "config", move _2, move _4, move _6, move _8, move _10];
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search(_1: &mut SearchWorker<W>, _2: &Subject) -> std::result::Result<SearchResult, std::io::Error> {
    debug self => _1;
    debug subject => _2;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let _3: grep::grep_searcher::BinaryDetection;
    let mut _4: bool;
    let mut _5: &grep::grep_searcher::BinaryDetection;
    let mut _6: &grep::grep_searcher::BinaryDetection;
    let mut _9: bool;
    let mut _10: &log::Level;
    let mut _11: bool;
    let mut _12: &log::Level;
    let mut _13: &log::LevelFilter;
    let _14: log::LevelFilter;
    let _15: ();
    let mut _16: std::fmt::Arguments<'_>;
    let mut _17: &[&str];
    let mut _18: &[core::fmt::rt::Argument<'_>];
    let _19: &[core::fmt::rt::Argument<'_>; 2];
    let _20: [core::fmt::rt::Argument<'_>; 2];
    let mut _21: core::fmt::rt::Argument<'_>;
    let _22: &std::path::Display<'_>;
    let _23: std::path::Display<'_>;
    let mut _24: core::fmt::rt::Argument<'_>;
    let _25: &grep::grep_searcher::BinaryDetection;
    let mut _26: log::Level;
    let _27: ();
    let mut _28: &mut grep::grep_searcher::Searcher;
    let mut _29: grep::grep_searcher::BinaryDetection;
    let mut _30: bool;
    let mut _31: &mut std::io::StdinLock<'_>;
    let mut _32: std::io::StdinLock<'_>;
    let mut _33: &std::io::Stdin;
    let _34: std::io::Stdin;
    let mut _35: bool;
    let mut _36: &search::SearchWorker<W>;
    let mut _37: bool;
    let mut _38: &search::SearchWorker<W>;
    scope 1 {
        debug bin => _3;
        let _7: &std::path::Path;
        scope 2 {
            debug path => _7;
            let _8: log::Level;
            scope 3 {
                debug lvl => _8;
                let mut _39: &(&str, &str, &str, u32);
                let mut _40: &[&str; 2];
                let mut _41: &log::LevelFilter;
            }
        }
    }

    bb0: {
        _4 = Subject::is_explicit(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _4) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _5 = &(((*_1).0: search::Config).5: grep::grep_searcher::BinaryDetection);
        _3 = <BinaryDetection as Clone>::clone(move _5) -> [return: bb4, unwind continue];
    }

    bb3: {
        _6 = &(((*_1).0: search::Config).4: grep::grep_searcher::BinaryDetection);
        _3 = <BinaryDetection as Clone>::clone(move _6) -> [return: bb4, unwind continue];
    }

    bb4: {
        _7 = Subject::path(_2) -> [return: bb5, unwind continue];
    }

    bb5: {
        _8 = log::Level::Trace;
        _10 = &_8;
        _41 = const _;
        _9 = <Level as PartialOrd<LevelFilter>>::le(move _10, _41) -> [return: bb6, unwind continue];
    }

    bb6: {
        switchInt(move _9) -> [0: bb15, otherwise: bb7];
    }

    bb7: {
        _12 = &_8;
        _14 = max_level() -> [return: bb8, unwind continue];
    }

    bb8: {
        _13 = &_14;
        _11 = <Level as PartialOrd<LevelFilter>>::le(move _12, move _13) -> [return: bb9, unwind continue];
    }

    bb9: {
        switchInt(move _11) -> [0: bb15, otherwise: bb10];
    }

    bb10: {
        _40 = const _;
        _17 = _40 as &[&str] (PointerCoercion(Unsize));
        _23 = Path::display(_7) -> [return: bb11, unwind continue];
    }

    bb11: {
        _22 = &_23;
        _21 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_22) -> [return: bb12, unwind continue];
    }

    bb12: {
        _25 = &_3;
        _24 = core::fmt::rt::Argument::<'_>::new_debug::<BinaryDetection>(_25) -> [return: bb13, unwind continue];
    }

    bb13: {
        _20 = [move _21, move _24];
        _19 = &_20;
        _18 = _19 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _16 = Arguments::<'_>::new_v1(move _17, move _18) -> [return: bb14, unwind continue];
    }

    bb14: {
        _26 = _8;
        _39 = const _;
        _15 = __private_api_log(move _16, move _26, _39) -> [return: bb15, unwind continue];
    }

    bb15: {
        _28 = &mut ((*_1).4: grep::grep_searcher::Searcher);
        _29 = move _3;
        _27 = grep::grep_searcher::Searcher::set_binary_detection(move _28, move _29) -> [return: bb16, unwind continue];
    }

    bb16: {
        _30 = Subject::is_stdin(_2) -> [return: bb17, unwind continue];
    }

    bb17: {
        switchInt(move _30) -> [0: bb22, otherwise: bb18];
    }

    bb18: {
        _34 = stdin() -> [return: bb19, unwind continue];
    }

    bb19: {
        _33 = &_34;
        _32 = Stdin::lock(move _33) -> [return: bb20, unwind continue];
    }

    bb20: {
        _31 = &mut _32;
        _0 = SearchWorker::<W>::search_reader::<StdinLock<'_>>(_1, _7, _31) -> [return: bb21, unwind: bb30];
    }

    bb21: {
        drop(_32) -> [return: bb29, unwind continue];
    }

    bb22: {
        _36 = &(*_1);
        _35 = SearchWorker::<W>::should_preprocess(move _36, _7) -> [return: bb23, unwind continue];
    }

    bb23: {
        switchInt(move _35) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _0 = SearchWorker::<W>::search_preprocessor(_1, _7) -> [return: bb29, unwind continue];
    }

    bb25: {
        _38 = &(*_1);
        _37 = SearchWorker::<W>::should_decompress(move _38, _7) -> [return: bb26, unwind continue];
    }

    bb26: {
        switchInt(move _37) -> [0: bb28, otherwise: bb27];
    }

    bb27: {
        _0 = SearchWorker::<W>::search_decompress(_1, _7) -> [return: bb29, unwind continue];
    }

    bb28: {
        _0 = SearchWorker::<W>::search_path(_1, _7) -> [return: bb29, unwind continue];
    }

    bb29: {
        return;
    }

    bb30 (cleanup): {
        drop(_32) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb31 (cleanup): {
        resume;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:325:1: 325:36>::search: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::search";
        _2 = &(*_3);
        _1 = (move _2, const "rg::search", const "crates/core/search.rs", const 334_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in search::<impl at crates/core/search.rs:325:1: 325:36>::search: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const ": binary detection: "];
        _0 = &_1;
        return;
    }
}

promoted[2] in search::<impl at crates/core/search.rs:325:1: 325:36>::search: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::printer(_1: &mut SearchWorker<W>) -> &mut Printer<W> {
    debug self => _1;
    let mut _0: &mut search::Printer<W>;

    bb0: {
        _0 = &mut ((*_1).5: search::Printer<W>);
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::print_stats(_1: &mut SearchWorker<W>, _2: Duration, _3: &Stats) -> std::result::Result<(), std::io::Error> {
    debug self => _1;
    debug total_duration => _2;
    debug stats => _3;
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _4: bool;
    let mut _5: &mut search::Printer<W>;
    let mut _6: &mut search::Printer<W>;

    bb0: {
        _4 = (((*_1).0: search::Config).0: bool);
        switchInt(move _4) -> [0: bb3, otherwise: bb1];
    }

    bb1: {
        _5 = SearchWorker::<W>::printer(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = Printer::<W>::print_stats_json(_5, _2, _3) -> [return: bb5, unwind continue];
    }

    bb3: {
        _6 = SearchWorker::<W>::printer(_1) -> [return: bb4, unwind continue];
    }

    bb4: {
        _0 = Printer::<W>::print_stats(_6, _2, _3) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::should_decompress(_1: &SearchWorker<W>, _2: &Path) -> bool {
    debug self => _1;
    debug path => _2;
    let mut _0: bool;
    let mut _3: bool;
    let _4: &grep::grep_cli::DecompressionMatcher;
    let mut _5: &grep::grep_cli::DecompressionReaderBuilder;

    bb0: {
        _3 = (((*_1).0: search::Config).3: bool);
        switchInt(move _3) -> [0: bb1, otherwise: bb2];
    }

    bb1: {
        _0 = const false;
        goto -> bb4;
    }

    bb2: {
        _5 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _4 = DecompressionReaderBuilder::get_matcher(move _5) -> [return: bb3, unwind continue];
    }

    bb3: {
        _0 = DecompressionMatcher::has_command::<&Path>(_4, _2) -> [return: bb4, unwind continue];
    }

    bb4: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::should_preprocess(_1: &SearchWorker<W>, _2: &Path) -> bool {
    debug self => _1;
    debug path => _2;
    let mut _0: bool;
    let mut _3: bool;
    let mut _4: &std::option::Option<std::path::PathBuf>;
    let mut _5: bool;
    let mut _6: &ignore::overrides::Override;
    let mut _7: bool;
    let mut _8: &ignore::Match<ignore::overrides::Glob<'_>>;
    let _9: ignore::Match<ignore::overrides::Glob<'_>>;
    let mut _10: &ignore::overrides::Override;

    bb0: {
        _4 = &(((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>);
        _3 = Option::<PathBuf>::is_some(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _3) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _6 = &(((*_1).0: search::Config).2: ignore::overrides::Override);
        _5 = Override::is_empty(move _6) -> [return: bb4, unwind continue];
    }

    bb3: {
        _0 = const false;
        goto -> bb9;
    }

    bb4: {
        switchInt(move _5) -> [0: bb6, otherwise: bb5];
    }

    bb5: {
        _0 = const true;
        goto -> bb9;
    }

    bb6: {
        _10 = &(((*_1).0: search::Config).2: ignore::overrides::Override);
        _9 = Override::matched::<&Path>(move _10, _2, const false) -> [return: bb7, unwind continue];
    }

    bb7: {
        _8 = &_9;
        _7 = ignore::Match::<ignore::overrides::Glob<'_>>::is_ignore(move _8) -> [return: bb8, unwind continue];
    }

    bb8: {
        _0 = Not(move _7);
        goto -> bb9;
    }

    bb9: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_preprocessor(_1: &mut SearchWorker<W>, _2: &Path) -> std::result::Result<SearchResult, std::io::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let _3: &std::path::PathBuf;
    let mut _4: std::option::Option<&std::path::PathBuf>;
    let mut _5: &std::option::Option<std::path::PathBuf>;
    let _7: &mut std::process::Command;
    let mut _8: &mut std::process::Command;
    let mut _9: &mut std::process::Command;
    let mut _10: std::process::Stdio;
    let mut _11: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, std::fs::File>;
    let mut _12: std::result::Result<std::fs::File, std::io::Error>;
    let mut _13: isize;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, grep::grep_cli::CommandReader>;
    let mut _18: std::result::Result<grep::grep_cli::CommandReader, std::io::Error>;
    let mut _19: std::result::Result<grep::grep_cli::CommandReader, grep::grep_cli::CommandError>;
    let mut _20: &grep::grep_cli::CommandReaderBuilder;
    let mut _21: &mut std::process::Command;
    let mut _22: {closure@crates/core/search.rs:402:68: 402:73};
    let mut _23: &std::process::Command;
    let mut _24: isize;
    let mut _28: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _29: &mut grep::grep_cli::CommandReader;
    let mut _30: {closure@crates/core/search.rs:411:65: 411:70};
    let mut _31: &std::process::Command;
    let mut _33: &mut grep::grep_cli::CommandReader;
    let mut _34: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, search::SearchResult>;
    let mut _35: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _36: isize;
    let mut _39: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _40: std::result::Result<(), std::io::Error>;
    let mut _41: isize;
    let mut _43: bool;
    let mut _44: bool;
    scope 1 {
        debug bin => _3;
        let mut _6: std::process::Command;
        scope 2 {
            debug cmd => _6;
            let _14: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _15: std::fs::File;
            let mut _16: grep::grep_cli::CommandReader;
            let _25: std::result::Result<std::convert::Infallible, std::io::Error>;
            let _26: grep::grep_cli::CommandReader;
            scope 3 {
                debug residual => _14;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _15;
                scope 6 {
                }
            }
            scope 7 {
                debug rdr => _16;
                let _27: std::result::Result<search::SearchResult, std::io::Error>;
                scope 12 {
                    debug result => _27;
                    let _32: std::result::Result<(), std::io::Error>;
                    scope 13 {
                        debug close_result => _32;
                        let _37: std::result::Result<std::convert::Infallible, std::io::Error>;
                        let _38: search::SearchResult;
                        scope 14 {
                            debug search_result => _38;
                            let _42: std::result::Result<std::convert::Infallible, std::io::Error>;
                            scope 19 {
                                debug residual => _42;
                                scope 20 {
                                }
                            }
                            scope 21 {
                                debug val => const ();
                                scope 22 {
                                }
                            }
                        }
                        scope 15 {
                            debug residual => _37;
                            scope 16 {
                            }
                        }
                        scope 17 {
                            debug val => _38;
                            scope 18 {
                            }
                        }
                    }
                }
            }
            scope 8 {
                debug residual => _25;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _26;
                scope 11 {
                }
            }
        }
    }

    bb0: {
        _44 = const false;
        _43 = const false;
        _5 = &(((*_1).0: search::Config).1: std::option::Option<std::path::PathBuf>);
        _4 = Option::<PathBuf>::as_ref(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = Option::<&PathBuf>::unwrap(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = std::process::Command::new::<&PathBuf>(_3) -> [return: bb3, unwind continue];
    }

    bb3: {
        _9 = &mut _6;
        _8 = std::process::Command::arg::<&Path>(move _9, _2) -> [return: bb4, unwind: bb32];
    }

    bb4: {
        _12 = File::open::<&Path>(_2) -> [return: bb5, unwind: bb32];
    }

    bb5: {
        _11 = <std::result::Result<File, std::io::Error> as Try>::branch(move _12) -> [return: bb6, unwind: bb32];
    }

    bb6: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb7, 1: bb9, otherwise: bb8];
    }

    bb7: {
        _15 = move ((_11 as Continue).0: std::fs::File);
        _10 = <Stdio as From<File>>::from(move _15) -> [return: bb10, unwind: bb32];
    }

    bb8: {
        unreachable;
    }

    bb9: {
        _14 = move ((_11 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _14) -> [return: bb39, unwind: bb32];
    }

    bb10: {
        _7 = std::process::Command::stdin::<Stdio>(_8, move _10) -> [return: bb11, unwind: bb32];
    }

    bb11: {
        _20 = &((*_1).1: grep::grep_cli::CommandReaderBuilder);
        _21 = &mut _6;
        _19 = CommandReaderBuilder::build(move _20, _21) -> [return: bb12, unwind: bb32];
    }

    bb12: {
        _23 = &_6;
        _22 = {closure@crates/core/search.rs:402:68: 402:73} { cmd: move _23 };
        _18 = std::result::Result::<CommandReader, CommandError>::map_err::<std::io::Error, {closure@crates/core/search.rs:402:68: 402:73}>(move _19, move _22) -> [return: bb13, unwind: bb32];
    }

    bb13: {
        _17 = <std::result::Result<CommandReader, std::io::Error> as Try>::branch(move _18) -> [return: bb14, unwind: bb32];
    }

    bb14: {
        _24 = discriminant(_17);
        switchInt(move _24) -> [0: bb15, 1: bb16, otherwise: bb8];
    }

    bb15: {
        _26 = move ((_17 as Continue).0: grep::grep_cli::CommandReader);
        _16 = move _26;
        _29 = &mut _16;
        _28 = SearchWorker::<W>::search_reader::<CommandReader>(_1, _2, _29) -> [return: bb17, unwind: bb31];
    }

    bb16: {
        _25 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _25) -> [return: bb40, unwind: bb32];
    }

    bb17: {
        _31 = &_6;
        _30 = {closure@crates/core/search.rs:411:65: 411:70} { cmd: move _31 };
        _27 = std::result::Result::<SearchResult, std::io::Error>::map_err::<std::io::Error, {closure@crates/core/search.rs:411:65: 411:70}>(move _28, move _30) -> [return: bb18, unwind: bb31];
    }

    bb18: {
        _44 = const true;
        _33 = &mut _16;
        _32 = CommandReader::close(move _33) -> [return: bb19, unwind: bb38];
    }

    bb19: {
        _43 = const true;
        _44 = const false;
        _35 = move _27;
        _34 = <std::result::Result<SearchResult, std::io::Error> as Try>::branch(move _35) -> [return: bb20, unwind: bb36];
    }

    bb20: {
        _36 = discriminant(_34);
        switchInt(move _36) -> [0: bb21, 1: bb22, otherwise: bb8];
    }

    bb21: {
        _38 = move ((_34 as Continue).0: search::SearchResult);
        _43 = const false;
        _40 = move _32;
        _39 = <std::result::Result<(), std::io::Error> as Try>::branch(move _40) -> [return: bb23, unwind: bb36];
    }

    bb22: {
        _37 = move ((_34 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _37) -> [return: bb41, unwind: bb36];
    }

    bb23: {
        _41 = discriminant(_39);
        switchInt(move _41) -> [0: bb24, 1: bb25, otherwise: bb8];
    }

    bb24: {
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _38);
        _43 = const false;
        _44 = const false;
        drop(_16) -> [return: bb26, unwind: bb32];
    }

    bb25: {
        _42 = move ((_39 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _42) -> [return: bb42, unwind: bb36];
    }

    bb26: {
        drop(_6) -> [return: bb30, unwind continue];
    }

    bb27: {
        switchInt(_43) -> [0: bb28, otherwise: bb34];
    }

    bb28: {
        _43 = const false;
        _44 = const false;
        drop(_16) -> [return: bb29, unwind: bb32];
    }

    bb29: {
        drop(_6) -> [return: bb30, unwind continue];
    }

    bb30: {
        return;
    }

    bb31 (cleanup): {
        drop(_16) -> [return: bb32, unwind terminate(cleanup)];
    }

    bb32 (cleanup): {
        drop(_6) -> [return: bb33, unwind terminate(cleanup)];
    }

    bb33 (cleanup): {
        resume;
    }

    bb34: {
        drop(_32) -> [return: bb28, unwind: bb38];
    }

    bb35 (cleanup): {
        drop(_32) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        switchInt(_43) -> [0: bb38, otherwise: bb35];
    }

    bb37 (cleanup): {
        drop(_27) -> [return: bb31, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        switchInt(_44) -> [0: bb31, otherwise: bb37];
    }

    bb39: {
        goto -> bb29;
    }

    bb40: {
        goto -> bb29;
    }

    bb41: {
        goto -> bb27;
    }

    bb42: {
        goto -> bb27;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_preprocessor::{closure#0}(_1: {closure@crates/core/search.rs:402:68: 402:73}, _2: CommandError) -> std::io::Error {
    debug err => _2;
    debug cmd => (*(_1.0: &std::process::Command));
    let mut _0: std::io::Error;
    let mut _3: std::io::ErrorKind;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 2];
    let _9: [core::fmt::rt::Argument<'_>; 2];
    let mut _10: core::fmt::rt::Argument<'_>;
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &grep::grep_cli::CommandError;
    let mut _13: &[&str; 2];
    let mut _14: &std::process::Command;
    scope 1 {
        debug res => _4;
    }

    bb0: {
        _3 = std::io::ErrorKind::Other;
        _13 = const _;
        _6 = _13 as &[&str] (PointerCoercion(Unsize));
        _14 = deref_copy (_1.0: &std::process::Command);
        _10 = core::fmt::rt::Argument::<'_>::new_debug::<std::process::Command>(_14) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _12 = &_2;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<CommandError>(_12) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _9 = [move _10, move _11];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _4 = format(move _5) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _0 = std::io::Error::new::<std::string::String>(move _3, move _4) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:325:1: 325:36>::search_preprocessor::{closure#0}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "preprocessor command could not start: '", const "': "];
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_preprocessor::{closure#1}(_1: {closure@crates/core/search.rs:411:65: 411:70}, _2: std::io::Error) -> std::io::Error {
    debug err => _2;
    debug cmd => (*(_1.0: &std::process::Command));
    let mut _0: std::io::Error;
    let mut _3: std::io::ErrorKind;
    let _4: std::string::String;
    let mut _5: std::fmt::Arguments<'_>;
    let mut _6: &[&str];
    let mut _7: &[core::fmt::rt::Argument<'_>];
    let _8: &[core::fmt::rt::Argument<'_>; 2];
    let _9: [core::fmt::rt::Argument<'_>; 2];
    let mut _10: core::fmt::rt::Argument<'_>;
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &std::io::Error;
    let mut _13: &[&str; 2];
    let mut _14: &std::process::Command;
    scope 1 {
        debug res => _4;
    }

    bb0: {
        _3 = std::io::ErrorKind::Other;
        _13 = const _;
        _6 = _13 as &[&str] (PointerCoercion(Unsize));
        _14 = deref_copy (_1.0: &std::process::Command);
        _10 = core::fmt::rt::Argument::<'_>::new_debug::<std::process::Command>(_14) -> [return: bb1, unwind: bb7];
    }

    bb1: {
        _12 = &_2;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_12) -> [return: bb2, unwind: bb7];
    }

    bb2: {
        _9 = [move _10, move _11];
        _8 = &_9;
        _7 = _8 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _5 = Arguments::<'_>::new_v1(move _6, move _7) -> [return: bb3, unwind: bb7];
    }

    bb3: {
        _4 = format(move _5) -> [return: bb4, unwind: bb7];
    }

    bb4: {
        _0 = std::io::Error::new::<std::string::String>(move _3, move _4) -> [return: bb5, unwind: bb7];
    }

    bb5: {
        drop(_2) -> [return: bb6, unwind continue];
    }

    bb6: {
        return;
    }

    bb7 (cleanup): {
        drop(_2) -> [return: bb8, unwind terminate(cleanup)];
    }

    bb8 (cleanup): {
        resume;
    }
}

promoted[0] in search::<impl at crates/core/search.rs:325:1: 325:36>::search_preprocessor::{closure#1}: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "preprocessor command failed: '", const "': "];
        _0 = &_1;
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_decompress(_1: &mut SearchWorker<W>, _2: &Path) -> std::result::Result<SearchResult, std::io::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _3: grep::grep_cli::DecompressionReader;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>, grep::grep_cli::DecompressionReader>;
    let mut _5: std::result::Result<grep::grep_cli::DecompressionReader, grep::grep_cli::CommandError>;
    let mut _6: &grep::grep_cli::DecompressionReaderBuilder;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>;
    let _9: grep::grep_cli::DecompressionReader;
    let mut _11: &mut grep::grep_cli::DecompressionReader;
    let mut _13: &mut grep::grep_cli::DecompressionReader;
    let mut _14: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>, search::SearchResult>;
    let mut _15: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _16: isize;
    let mut _19: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _20: std::result::Result<(), std::io::Error>;
    let mut _21: isize;
    let mut _23: bool;
    let mut _24: bool;
    scope 1 {
        debug rdr => _3;
        let _10: std::result::Result<search::SearchResult, std::io::Error>;
        scope 6 {
            debug result => _10;
            let _12: std::result::Result<(), std::io::Error>;
            scope 7 {
                debug close_result => _12;
                let _17: std::result::Result<std::convert::Infallible, std::io::Error>;
                let _18: search::SearchResult;
                scope 8 {
                    debug search_result => _18;
                    let _22: std::result::Result<std::convert::Infallible, std::io::Error>;
                    scope 13 {
                        debug residual => _22;
                        scope 14 {
                        }
                    }
                    scope 15 {
                        debug val => const ();
                        scope 16 {
                        }
                    }
                }
                scope 9 {
                    debug residual => _17;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _18;
                    scope 12 {
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }

    bb0: {
        _24 = const false;
        _23 = const false;
        _6 = &((*_1).2: grep::grep_cli::DecompressionReaderBuilder);
        _5 = DecompressionReaderBuilder::build::<&Path>(move _6, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = <std::result::Result<DecompressionReader, CommandError> as Try>::branch(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = move ((_4 as Continue).0: grep::grep_cli::DecompressionReader);
        _3 = move _9;
        _11 = &mut _3;
        _10 = SearchWorker::<W>::search_reader::<DecompressionReader>(_1, _2, _11) -> [return: bb6, unwind: bb17];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, grep::grep_cli::CommandError>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, CommandError>>>::from_residual(move _8) -> [return: bb16, unwind continue];
    }

    bb6: {
        _24 = const true;
        _13 = &mut _3;
        _12 = DecompressionReader::close(move _13) -> [return: bb7, unwind: bb23];
    }

    bb7: {
        _23 = const true;
        _24 = const false;
        _15 = move _10;
        _14 = <std::result::Result<SearchResult, std::io::Error> as Try>::branch(move _15) -> [return: bb8, unwind: bb21];
    }

    bb8: {
        _16 = discriminant(_14);
        switchInt(move _16) -> [0: bb9, 1: bb10, otherwise: bb4];
    }

    bb9: {
        _18 = move ((_14 as Continue).0: search::SearchResult);
        _23 = const false;
        _20 = move _12;
        _19 = <std::result::Result<(), std::io::Error> as Try>::branch(move _20) -> [return: bb11, unwind: bb21];
    }

    bb10: {
        _17 = move ((_14 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _17) -> [return: bb24, unwind: bb21];
    }

    bb11: {
        _21 = discriminant(_19);
        switchInt(move _21) -> [0: bb12, 1: bb13, otherwise: bb4];
    }

    bb12: {
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _18);
        _23 = const false;
        _24 = const false;
        drop(_3) -> [return: bb16, unwind continue];
    }

    bb13: {
        _22 = move ((_19 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _22) -> [return: bb25, unwind: bb21];
    }

    bb14: {
        switchInt(_23) -> [0: bb15, otherwise: bb19];
    }

    bb15: {
        _23 = const false;
        _24 = const false;
        drop(_3) -> [return: bb16, unwind continue];
    }

    bb16: {
        return;
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }

    bb19: {
        drop(_12) -> [return: bb15, unwind: bb23];
    }

    bb20 (cleanup): {
        drop(_12) -> [return: bb23, unwind terminate(cleanup)];
    }

    bb21 (cleanup): {
        switchInt(_23) -> [0: bb23, otherwise: bb20];
    }

    bb22 (cleanup): {
        drop(_10) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb23 (cleanup): {
        switchInt(_24) -> [0: bb17, otherwise: bb22];
    }

    bb24: {
        goto -> bb14;
    }

    bb25: {
        goto -> bb14;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_path(_1: &mut SearchWorker<W>, _2: &Path) -> std::result::Result<SearchResult, std::io::Error> {
    debug self => _1;
    debug path => _2;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let _3: &mut grep::grep_searcher::Searcher;
    let _4: &mut search::Printer<W>;
    let mut _5: (&mut grep::grep_searcher::Searcher, &mut search::Printer<W>);
    let mut _6: &mut grep::grep_searcher::Searcher;
    let mut _7: &mut search::Printer<W>;
    scope 1 {
        debug searcher => _3;
        debug printer => _4;
        let _8: &grep::grep_regex::RegexMatcher;
        scope 2 {
            debug m => _8;
        }
    }

    bb0: {
        _6 = &mut ((*_1).4: grep::grep_searcher::Searcher);
        _7 = &mut ((*_1).5: search::Printer<W>);
        _5 = (move _6, move _7);
        _3 = move (_5.0: &mut grep::grep_searcher::Searcher);
        _4 = move (_5.1: &mut search::Printer<W>);
        _8 = &((((*_1).3: search::PatternMatcher) as RustRegex).0: grep::grep_regex::RegexMatcher);
        _0 = search_path::<&RegexMatcher, W>(_8, _3, _4, _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search::<impl at crates/core/search.rs:325:1: 325:36>::search_reader(_1: &mut SearchWorker<W>, _2: &Path, _3: &mut R) -> std::result::Result<SearchResult, std::io::Error> {
    debug self => _1;
    debug path => _2;
    debug rdr => _3;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let _4: &mut grep::grep_searcher::Searcher;
    let _5: &mut search::Printer<W>;
    let mut _6: (&mut grep::grep_searcher::Searcher, &mut search::Printer<W>);
    let mut _7: &mut grep::grep_searcher::Searcher;
    let mut _8: &mut search::Printer<W>;
    scope 1 {
        debug searcher => _4;
        debug printer => _5;
        let _9: &grep::grep_regex::RegexMatcher;
        scope 2 {
            debug m => _9;
        }
    }

    bb0: {
        _7 = &mut ((*_1).4: grep::grep_searcher::Searcher);
        _8 = &mut ((*_1).5: search::Printer<W>);
        _6 = (move _7, move _8);
        _4 = move (_6.0: &mut grep::grep_searcher::Searcher);
        _5 = move (_6.1: &mut search::Printer<W>);
        _9 = &((((*_1).3: search::PatternMatcher) as RustRegex).0: grep::grep_regex::RegexMatcher);
        _0 = search_reader::<&RegexMatcher, &mut R, W>(_9, _4, _5, _2, move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search_path(_1: M, _2: &mut grep::grep_searcher::Searcher, _3: &mut Printer<W>, _4: &Path) -> std::result::Result<SearchResult, std::io::Error> {
    debug matcher => _1;
    debug searcher => _2;
    debug printer => _3;
    debug path => _4;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _5: isize;
    let _6: &mut grep::grep_printer::Standard<W>;
    let mut _8: &M;
    let mut _9: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _10: std::result::Result<(), std::io::Error>;
    let mut _11: &M;
    let mut _12: &mut grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let mut _13: isize;
    let mut _15: search::SearchResult;
    let mut _16: bool;
    let mut _17: &grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let mut _18: std::option::Option<grep::grep_printer::Stats>;
    let mut _19: std::option::Option<&grep::grep_printer::Stats>;
    let mut _20: &grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let _21: &mut grep::grep_printer::Summary<W>;
    let mut _23: &M;
    let mut _24: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _25: std::result::Result<(), std::io::Error>;
    let mut _26: &M;
    let mut _27: &mut grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let mut _28: isize;
    let mut _30: search::SearchResult;
    let mut _31: bool;
    let mut _32: &grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let mut _33: std::option::Option<grep::grep_printer::Stats>;
    let mut _34: std::option::Option<&grep::grep_printer::Stats>;
    let mut _35: &grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let _36: &mut grep::grep_printer::JSON<W>;
    let mut _38: &M;
    let mut _39: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _40: std::result::Result<(), std::io::Error>;
    let mut _41: &M;
    let mut _42: &mut grep::grep_printer::JSONSink<'_, '_, &M, W>;
    let mut _43: isize;
    let mut _45: search::SearchResult;
    let mut _46: bool;
    let mut _47: &grep::grep_printer::JSONSink<'_, '_, &M, W>;
    let mut _48: std::option::Option<grep::grep_printer::Stats>;
    let mut _49: grep::grep_printer::Stats;
    let _50: &grep::grep_printer::Stats;
    let mut _51: &grep::grep_printer::JSONSink<'_, '_, &M, W>;
    scope 1 {
        debug p => _6;
        let mut _7: grep::grep_printer::StandardSink<'_, '_, &M, W>;
        scope 2 {
            debug sink => _7;
            let _14: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 3 {
                debug residual => _14;
                scope 4 {
                }
            }
            scope 5 {
                debug val => const ();
                scope 6 {
                }
            }
        }
    }
    scope 7 {
        debug p => _21;
        let mut _22: grep::grep_printer::SummarySink<'_, '_, &M, W>;
        scope 8 {
            debug sink => _22;
            let _29: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 9 {
                debug residual => _29;
                scope 10 {
                }
            }
            scope 11 {
                debug val => const ();
                scope 12 {
                }
            }
        }
    }
    scope 13 {
        debug p => _36;
        let mut _37: grep::grep_printer::JSONSink<'_, '_, &M, W>;
        scope 14 {
            debug sink => _37;
            let _44: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 15 {
                debug residual => _44;
                scope 16 {
                }
            }
            scope 17 {
                debug val => const ();
                scope 18 {
                }
            }
        }
    }

    bb0: {
        _5 = discriminant((*_3));
        switchInt(move _5) -> [0: bb3, 1: bb13, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _36 = &mut (((*_3) as JSON).0: grep::grep_printer::JSON<W>);
        _38 = &_1;
        _37 = JSON::<W>::sink_with_path::<&M, Path>(_36, move _38, _4) -> [return: bb23, unwind: bb36];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _6 = &mut (((*_3) as Standard).0: grep::grep_printer::Standard<W>);
        _8 = &_1;
        _7 = Standard::<W>::sink_with_path::<&M, Path>(_6, move _8, _4) -> [return: bb4, unwind: bb36];
    }

    bb4: {
        _11 = &_1;
        _12 = &mut _7;
        _10 = grep::grep_searcher::Searcher::search_path::<&Path, &M, &mut StandardSink<'_, '_, &M, W>>(_2, move _11, _4, move _12) -> [return: bb5, unwind: bb35];
    }

    bb5: {
        _9 = <std::result::Result<(), std::io::Error> as Try>::branch(move _10) -> [return: bb6, unwind: bb35];
    }

    bb6: {
        _13 = discriminant(_9);
        switchInt(move _13) -> [0: bb7, 1: bb8, otherwise: bb2];
    }

    bb7: {
        _17 = &_7;
        _16 = StandardSink::<'_, '_, &M, W>::has_match(move _17) -> [return: bb10, unwind: bb35];
    }

    bb8: {
        _14 = move ((_9 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _14) -> [return: bb9, unwind: bb35];
    }

    bb9: {
        drop(_7) -> [return: bb32, unwind: bb36];
    }

    bb10: {
        _20 = &_7;
        _19 = StandardSink::<'_, '_, &M, W>::stats(move _20) -> [return: bb11, unwind: bb35];
    }

    bb11: {
        _18 = Option::<&Stats>::map::<Stats, {closure@crates/core/search.rs:486:41: 486:44}>(move _19, const ZeroSized: {closure@crates/core/search.rs:486:41: 486:44}) -> [return: bb12, unwind: bb35];
    }

    bb12: {
        _15 = SearchResult { has_match: move _16, stats: move _18 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _15);
        drop(_7) -> [return: bb31, unwind: bb36];
    }

    bb13: {
        _21 = &mut (((*_3) as Summary).0: grep::grep_printer::Summary<W>);
        _23 = &_1;
        _22 = Summary::<W>::sink_with_path::<&M, Path>(_21, move _23, _4) -> [return: bb14, unwind: bb36];
    }

    bb14: {
        _26 = &_1;
        _27 = &mut _22;
        _25 = grep::grep_searcher::Searcher::search_path::<&Path, &M, &mut SummarySink<'_, '_, &M, W>>(_2, move _26, _4, move _27) -> [return: bb15, unwind: bb34];
    }

    bb15: {
        _24 = <std::result::Result<(), std::io::Error> as Try>::branch(move _25) -> [return: bb16, unwind: bb34];
    }

    bb16: {
        _28 = discriminant(_24);
        switchInt(move _28) -> [0: bb17, 1: bb18, otherwise: bb2];
    }

    bb17: {
        _32 = &_22;
        _31 = SummarySink::<'_, '_, &M, W>::has_match(move _32) -> [return: bb20, unwind: bb34];
    }

    bb18: {
        _29 = move ((_24 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _29) -> [return: bb19, unwind: bb34];
    }

    bb19: {
        drop(_22) -> [return: bb32, unwind: bb36];
    }

    bb20: {
        _35 = &_22;
        _34 = SummarySink::<'_, '_, &M, W>::stats(move _35) -> [return: bb21, unwind: bb34];
    }

    bb21: {
        _33 = Option::<&Stats>::map::<Stats, {closure@crates/core/search.rs:494:41: 494:44}>(move _34, const ZeroSized: {closure@crates/core/search.rs:494:41: 494:44}) -> [return: bb22, unwind: bb34];
    }

    bb22: {
        _30 = SearchResult { has_match: move _31, stats: move _33 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _30);
        drop(_22) -> [return: bb31, unwind: bb36];
    }

    bb23: {
        _41 = &_1;
        _42 = &mut _37;
        _40 = grep::grep_searcher::Searcher::search_path::<&Path, &M, &mut JSONSink<'_, '_, &M, W>>(_2, move _41, _4, move _42) -> [return: bb24, unwind: bb36];
    }

    bb24: {
        _39 = <std::result::Result<(), std::io::Error> as Try>::branch(move _40) -> [return: bb25, unwind: bb36];
    }

    bb25: {
        _43 = discriminant(_39);
        switchInt(move _43) -> [0: bb26, 1: bb27, otherwise: bb2];
    }

    bb26: {
        _47 = &_37;
        _46 = JSONSink::<'_, '_, &M, W>::has_match(move _47) -> [return: bb28, unwind: bb36];
    }

    bb27: {
        _44 = move ((_39 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _44) -> [return: bb38, unwind: bb36];
    }

    bb28: {
        _51 = &_37;
        _50 = JSONSink::<'_, '_, &M, W>::stats(move _51) -> [return: bb29, unwind: bb36];
    }

    bb29: {
        _49 = <Stats as Clone>::clone(_50) -> [return: bb30, unwind: bb36];
    }

    bb30: {
        _48 = Option::<Stats>::Some(move _49);
        _45 = SearchResult { has_match: move _46, stats: move _48 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _45);
        goto -> bb31;
    }

    bb31: {
        drop(_1) -> [return: bb33, unwind continue];
    }

    bb32: {
        drop(_1) -> [return: bb33, unwind continue];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_22) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_7) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        drop(_1) -> [return: bb37, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        resume;
    }

    bb38: {
        goto -> bb32;
    }
}

fn search_path::{closure#0}(_1: {closure@crates/core/search.rs:486:41: 486:44}, _2: &Stats) -> Stats {
    debug s => _2;
    let mut _0: grep::grep_printer::Stats;

    bb0: {
        _0 = <Stats as Clone>::clone(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search_path::{closure#1}(_1: {closure@crates/core/search.rs:494:41: 494:44}, _2: &Stats) -> Stats {
    debug s => _2;
    let mut _0: grep::grep_printer::Stats;

    bb0: {
        _0 = <Stats as Clone>::clone(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search_reader(_1: M, _2: &mut grep::grep_searcher::Searcher, _3: &mut Printer<W>, _4: &Path, _5: R) -> std::result::Result<SearchResult, std::io::Error> {
    debug matcher => _1;
    debug searcher => _2;
    debug printer => _3;
    debug path => _4;
    debug rdr => _5;
    let mut _0: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _6: isize;
    let _7: &mut grep::grep_printer::Standard<W>;
    let mut _9: &M;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _11: std::result::Result<(), std::io::Error>;
    let mut _12: &M;
    let mut _13: &mut R;
    let mut _14: &mut grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let mut _15: isize;
    let mut _17: search::SearchResult;
    let mut _18: bool;
    let mut _19: &grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let mut _20: std::option::Option<grep::grep_printer::Stats>;
    let mut _21: std::option::Option<&grep::grep_printer::Stats>;
    let mut _22: &grep::grep_printer::StandardSink<'_, '_, &M, W>;
    let _23: &mut grep::grep_printer::Summary<W>;
    let mut _25: &M;
    let mut _26: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _27: std::result::Result<(), std::io::Error>;
    let mut _28: &M;
    let mut _29: &mut R;
    let mut _30: &mut grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let mut _31: isize;
    let mut _33: search::SearchResult;
    let mut _34: bool;
    let mut _35: &grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let mut _36: std::option::Option<grep::grep_printer::Stats>;
    let mut _37: std::option::Option<&grep::grep_printer::Stats>;
    let mut _38: &grep::grep_printer::SummarySink<'_, '_, &M, W>;
    let _39: &mut grep::grep_printer::JSON<W>;
    let mut _41: &M;
    let mut _42: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _43: std::result::Result<(), std::io::Error>;
    let mut _44: &M;
    let mut _45: &mut R;
    let mut _46: &mut grep::grep_printer::JSONSink<'_, '_, &M, W>;
    let mut _47: isize;
    let mut _49: search::SearchResult;
    let mut _50: bool;
    let mut _51: &grep::grep_printer::JSONSink<'_, '_, &M, W>;
    let mut _52: std::option::Option<grep::grep_printer::Stats>;
    let mut _53: grep::grep_printer::Stats;
    let _54: &grep::grep_printer::Stats;
    let mut _55: &grep::grep_printer::JSONSink<'_, '_, &M, W>;
    scope 1 {
        debug p => _7;
        let mut _8: grep::grep_printer::StandardSink<'_, '_, &M, W>;
        scope 2 {
            debug sink => _8;
            let _16: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 3 {
                debug residual => _16;
                scope 4 {
                }
            }
            scope 5 {
                debug val => const ();
                scope 6 {
                }
            }
        }
    }
    scope 7 {
        debug p => _23;
        let mut _24: grep::grep_printer::SummarySink<'_, '_, &M, W>;
        scope 8 {
            debug sink => _24;
            let _32: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 9 {
                debug residual => _32;
                scope 10 {
                }
            }
            scope 11 {
                debug val => const ();
                scope 12 {
                }
            }
        }
    }
    scope 13 {
        debug p => _39;
        let mut _40: grep::grep_printer::JSONSink<'_, '_, &M, W>;
        scope 14 {
            debug sink => _40;
            let _48: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 15 {
                debug residual => _48;
                scope 16 {
                }
            }
            scope 17 {
                debug val => const ();
                scope 18 {
                }
            }
        }
    }

    bb0: {
        _6 = discriminant((*_3));
        switchInt(move _6) -> [0: bb3, 1: bb13, 2: bb1, otherwise: bb2];
    }

    bb1: {
        _39 = &mut (((*_3) as JSON).0: grep::grep_printer::JSON<W>);
        _41 = &_1;
        _40 = JSON::<W>::sink_with_path::<&M, Path>(_39, move _41, _4) -> [return: bb23, unwind: bb38];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _7 = &mut (((*_3) as Standard).0: grep::grep_printer::Standard<W>);
        _9 = &_1;
        _8 = Standard::<W>::sink_with_path::<&M, Path>(_7, move _9, _4) -> [return: bb4, unwind: bb38];
    }

    bb4: {
        _12 = &_1;
        _13 = &mut _5;
        _14 = &mut _8;
        _11 = grep::grep_searcher::Searcher::search_reader::<&M, &mut R, &mut StandardSink<'_, '_, &M, W>>(_2, move _12, move _13, move _14) -> [return: bb5, unwind: bb37];
    }

    bb5: {
        _10 = <std::result::Result<(), std::io::Error> as Try>::branch(move _11) -> [return: bb6, unwind: bb37];
    }

    bb6: {
        _15 = discriminant(_10);
        switchInt(move _15) -> [0: bb7, 1: bb8, otherwise: bb2];
    }

    bb7: {
        _19 = &_8;
        _18 = StandardSink::<'_, '_, &M, W>::has_match(move _19) -> [return: bb10, unwind: bb37];
    }

    bb8: {
        _16 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _16) -> [return: bb9, unwind: bb37];
    }

    bb9: {
        drop(_8) -> [return: bb33, unwind: bb38];
    }

    bb10: {
        _22 = &_8;
        _21 = StandardSink::<'_, '_, &M, W>::stats(move _22) -> [return: bb11, unwind: bb37];
    }

    bb11: {
        _20 = Option::<&Stats>::map::<Stats, {closure@crates/core/search.rs:523:41: 523:44}>(move _21, const ZeroSized: {closure@crates/core/search.rs:523:41: 523:44}) -> [return: bb12, unwind: bb37];
    }

    bb12: {
        _17 = SearchResult { has_match: move _18, stats: move _20 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _17);
        drop(_8) -> [return: bb31, unwind: bb38];
    }

    bb13: {
        _23 = &mut (((*_3) as Summary).0: grep::grep_printer::Summary<W>);
        _25 = &_1;
        _24 = Summary::<W>::sink_with_path::<&M, Path>(_23, move _25, _4) -> [return: bb14, unwind: bb38];
    }

    bb14: {
        _28 = &_1;
        _29 = &mut _5;
        _30 = &mut _24;
        _27 = grep::grep_searcher::Searcher::search_reader::<&M, &mut R, &mut SummarySink<'_, '_, &M, W>>(_2, move _28, move _29, move _30) -> [return: bb15, unwind: bb36];
    }

    bb15: {
        _26 = <std::result::Result<(), std::io::Error> as Try>::branch(move _27) -> [return: bb16, unwind: bb36];
    }

    bb16: {
        _31 = discriminant(_26);
        switchInt(move _31) -> [0: bb17, 1: bb18, otherwise: bb2];
    }

    bb17: {
        _35 = &_24;
        _34 = SummarySink::<'_, '_, &M, W>::has_match(move _35) -> [return: bb20, unwind: bb36];
    }

    bb18: {
        _32 = move ((_26 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _32) -> [return: bb19, unwind: bb36];
    }

    bb19: {
        drop(_24) -> [return: bb33, unwind: bb38];
    }

    bb20: {
        _38 = &_24;
        _37 = SummarySink::<'_, '_, &M, W>::stats(move _38) -> [return: bb21, unwind: bb36];
    }

    bb21: {
        _36 = Option::<&Stats>::map::<Stats, {closure@crates/core/search.rs:531:41: 531:44}>(move _37, const ZeroSized: {closure@crates/core/search.rs:531:41: 531:44}) -> [return: bb22, unwind: bb36];
    }

    bb22: {
        _33 = SearchResult { has_match: move _34, stats: move _36 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _33);
        drop(_24) -> [return: bb31, unwind: bb38];
    }

    bb23: {
        _44 = &_1;
        _45 = &mut _5;
        _46 = &mut _40;
        _43 = grep::grep_searcher::Searcher::search_reader::<&M, &mut R, &mut JSONSink<'_, '_, &M, W>>(_2, move _44, move _45, move _46) -> [return: bb24, unwind: bb38];
    }

    bb24: {
        _42 = <std::result::Result<(), std::io::Error> as Try>::branch(move _43) -> [return: bb25, unwind: bb38];
    }

    bb25: {
        _47 = discriminant(_42);
        switchInt(move _47) -> [0: bb26, 1: bb27, otherwise: bb2];
    }

    bb26: {
        _51 = &_40;
        _50 = JSONSink::<'_, '_, &M, W>::has_match(move _51) -> [return: bb28, unwind: bb38];
    }

    bb27: {
        _48 = move ((_42 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<SearchResult, std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _48) -> [return: bb41, unwind: bb38];
    }

    bb28: {
        _55 = &_40;
        _54 = JSONSink::<'_, '_, &M, W>::stats(move _55) -> [return: bb29, unwind: bb38];
    }

    bb29: {
        _53 = <Stats as Clone>::clone(_54) -> [return: bb30, unwind: bb38];
    }

    bb30: {
        _52 = Option::<Stats>::Some(move _53);
        _49 = SearchResult { has_match: move _50, stats: move _52 };
        _0 = std::result::Result::<SearchResult, std::io::Error>::Ok(move _49);
        goto -> bb31;
    }

    bb31: {
        drop(_5) -> [return: bb32, unwind: bb39];
    }

    bb32: {
        drop(_1) -> [return: bb35, unwind continue];
    }

    bb33: {
        drop(_5) -> [return: bb34, unwind: bb39];
    }

    bb34: {
        drop(_1) -> [return: bb35, unwind continue];
    }

    bb35: {
        return;
    }

    bb36 (cleanup): {
        drop(_24) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb37 (cleanup): {
        drop(_8) -> [return: bb38, unwind terminate(cleanup)];
    }

    bb38 (cleanup): {
        drop(_5) -> [return: bb39, unwind terminate(cleanup)];
    }

    bb39 (cleanup): {
        drop(_1) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb40 (cleanup): {
        resume;
    }

    bb41: {
        goto -> bb33;
    }
}

fn search_reader::{closure#0}(_1: {closure@crates/core/search.rs:523:41: 523:44}, _2: &Stats) -> Stats {
    debug s => _2;
    let mut _0: grep::grep_printer::Stats;

    bb0: {
        _0 = <Stats as Clone>::clone(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search_reader::{closure#1}(_1: {closure@crates/core/search.rs:531:41: 531:44}, _2: &Stats) -> Stats {
    debug s => _2;
    let mut _0: grep::grep_printer::Stats;

    bb0: {
        _0 = <Stats as Clone>::clone(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn fractional_seconds(_1: Duration) -> f64 {
    debug duration => _1;
    let mut _0: f64;
    let mut _2: f64;
    let mut _3: u64;
    let mut _4: &std::time::Duration;
    let mut _5: f64;
    let mut _6: f64;
    let mut _7: u32;
    let mut _8: &std::time::Duration;

    bb0: {
        _4 = &_1;
        _3 = Duration::as_secs(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = move _3 as f64 (IntToFloat);
        _8 = &_1;
        _7 = Duration::subsec_nanos(move _8) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = move _7 as f64 (IntToFloat);
        _5 = Mul(move _6, const 1.0000000000000001E-9f64);
        _0 = Add(move _2, move _5);
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:7:10: 7:15>::clone(_1: &subject::Config) -> subject::Config {
    debug self => _1;
    let mut _0: subject::Config;
    let mut _2: bool;
    let _3: &bool;

    bb0: {
        _3 = &((*_1).0: bool);
        _2 = (*_3);
        _0 = subject::Config { strip_dot_prefix: move _2 };
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:7:17: 7:22>::fmt(_1: &subject::Config, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&bool;
    let _7: &bool;

    bb0: {
        _3 = const "Config";
        _4 = const "strip_dot_prefix";
        _7 = &((*_1).0: bool);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:12:1: 12:24>::default() -> subject::Config {
    let mut _0: subject::Config;

    bb0: {
        _0 = subject::Config { strip_dot_prefix: const false };
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:19:10: 19:15>::clone(_1: &SubjectBuilder) -> SubjectBuilder {
    debug self => _1;
    let mut _0: subject::SubjectBuilder;
    let mut _2: subject::Config;
    let _3: &subject::Config;

    bb0: {
        _3 = &((*_1).0: subject::Config);
        _2 = <subject::Config as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = SubjectBuilder { config: move _2 };
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:19:17: 19:22>::fmt(_1: &SubjectBuilder, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &&subject::Config;
    let _7: &subject::Config;

    bb0: {
        _3 = const "SubjectBuilder";
        _4 = const "config";
        _7 = &((*_1).0: subject::Config);
        _6 = &_7;
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field1_finish(_2, _3, _4, move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:24:1: 24:20>::new() -> SubjectBuilder {
    let mut _0: subject::SubjectBuilder;
    let mut _1: subject::Config;

    bb0: {
        _1 = <subject::Config as Default>::default() -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = SubjectBuilder { config: move _1 };
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:24:1: 24:20>::build_from_result(_1: &SubjectBuilder, _2: std::result::Result<ignore::DirEntry, ignore::Error>) -> Option<Subject> {
    debug self => _1;
    debug result => _2;
    let mut _0: std::option::Option<subject::Subject>;
    let mut _3: isize;
    let _4: ignore::DirEntry;
    let _5: ignore::Error;
    let _6: ();
    let mut _7: bool;
    let _8: ();
    let mut _9: std::fmt::Arguments<'_>;
    let mut _10: &[&str];
    let mut _11: &[core::fmt::rt::Argument<'_>];
    let _12: &[core::fmt::rt::Argument<'_>; 1];
    let _13: [core::fmt::rt::Argument<'_>; 1];
    let mut _14: core::fmt::rt::Argument<'_>;
    let _15: &ignore::Error;
    scope 1 {
        debug dent => _4;
    }
    scope 2 {
        debug err => _5;
        let mut _16: &[&str; 2];
    }

    bb0: {
        _3 = discriminant(_2);
        switchInt(move _3) -> [0: bb3, 1: bb1, otherwise: bb2];
    }

    bb1: {
        _5 = move ((_2 as Err).0: ignore::Error);
        _6 = set_errored() -> [return: bb4, unwind: bb10];
    }

    bb2: {
        unreachable;
    }

    bb3: {
        _4 = move ((_2 as Ok).0: ignore::DirEntry);
        _0 = SubjectBuilder::build(_1, move _4) -> [return: bb11, unwind continue];
    }

    bb4: {
        _7 = messages() -> [return: bb5, unwind: bb10];
    }

    bb5: {
        switchInt(move _7) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _16 = const _;
        _10 = _16 as &[&str] (PointerCoercion(Unsize));
        _15 = &_5;
        _14 = core::fmt::rt::Argument::<'_>::new_display::<ignore::Error>(_15) -> [return: bb7, unwind: bb10];
    }

    bb7: {
        _13 = [move _14];
        _12 = &_13;
        _11 = _12 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _9 = Arguments::<'_>::new_v1(move _10, move _11) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        _8 = _eprint(move _9) -> [return: bb13, unwind: bb10];
    }

    bb9: {
        _0 = Option::<Subject>::None;
        drop(_5) -> [return: bb11, unwind continue];
    }

    bb10 (cleanup): {
        drop(_5) -> [return: bb12, unwind terminate(cleanup)];
    }

    bb11: {
        return;
    }

    bb12 (cleanup): {
        resume;
    }

    bb13: {
        goto -> bb9;
    }
}

promoted[0] in subject::<impl at crates/core/subject.rs:24:1: 24:20>::build_from_result: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:24:1: 24:20>::build(_1: &SubjectBuilder, _2: ignore::DirEntry) -> Option<Subject> {
    debug self => _1;
    debug dent => _2;
    let mut _0: std::option::Option<subject::Subject>;
    let _3: subject::Subject;
    let mut _4: bool;
    let mut _5: std::option::Option<&ignore::Error>;
    let mut _6: &ignore::DirEntry;
    let mut _7: isize;
    let mut _9: bool;
    let mut _10: bool;
    let _11: ();
    let mut _12: std::fmt::Arguments<'_>;
    let mut _13: &[&str];
    let mut _14: &[core::fmt::rt::Argument<'_>];
    let _15: &[core::fmt::rt::Argument<'_>; 1];
    let _16: [core::fmt::rt::Argument<'_>; 1];
    let mut _17: core::fmt::rt::Argument<'_>;
    let _18: &&ignore::Error;
    let mut _19: bool;
    let mut _20: &subject::Subject;
    let mut _21: subject::Subject;
    let mut _22: bool;
    let mut _23: &subject::Subject;
    let mut _24: subject::Subject;
    let mut _25: bool;
    let mut _26: &subject::Subject;
    let mut _28: bool;
    let mut _29: &log::Level;
    let mut _30: bool;
    let mut _31: &log::Level;
    let mut _32: &log::LevelFilter;
    let _33: log::LevelFilter;
    let _34: ();
    let mut _35: std::fmt::Arguments<'_>;
    let mut _36: &[&str];
    let mut _37: &[core::fmt::rt::Argument<'_>];
    let _38: &[core::fmt::rt::Argument<'_>; 3];
    let _39: [core::fmt::rt::Argument<'_>; 3];
    let mut _40: core::fmt::rt::Argument<'_>;
    let _41: &std::path::Display<'_>;
    let _42: std::path::Display<'_>;
    let _43: &std::path::Path;
    let mut _44: &ignore::DirEntry;
    let mut _45: core::fmt::rt::Argument<'_>;
    let _46: &std::option::Option<std::fs::FileType>;
    let _47: std::option::Option<std::fs::FileType>;
    let mut _48: &ignore::DirEntry;
    let mut _49: core::fmt::rt::Argument<'_>;
    let _50: &std::result::Result<std::fs::Metadata, ignore::Error>;
    let _51: std::result::Result<std::fs::Metadata, ignore::Error>;
    let mut _52: &ignore::DirEntry;
    let mut _53: log::Level;
    scope 1 {
        debug subj => _3;
        let _27: log::Level;
        scope 2 {
            debug ignore_err => _8;
            let _8: &ignore::Error;
            let mut _57: &[&str; 2];
        }
        scope 3 {
            debug lvl => _27;
            let mut _54: &(&str, &str, &str, u32);
            let mut _55: &[&str; 3];
            let mut _56: &log::LevelFilter;
        }
    }

    bb0: {
        _4 = (((*_1).0: subject::Config).0: bool);
        _3 = Subject { dent: move _2, strip_dot_prefix: move _4 };
        _6 = &(_3.0: ignore::DirEntry);
        _5 = ignore::DirEntry::error(move _6) -> [return: bb1, unwind: bb35];
    }

    bb1: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [1: bb2, otherwise: bb9];
    }

    bb2: {
        _8 = ((_5 as Some).0: &ignore::Error);
        _9 = messages() -> [return: bb3, unwind: bb35];
    }

    bb3: {
        switchInt(move _9) -> [0: bb9, otherwise: bb4];
    }

    bb4: {
        _10 = ignore_messages() -> [return: bb5, unwind: bb35];
    }

    bb5: {
        switchInt(move _10) -> [0: bb9, otherwise: bb6];
    }

    bb6: {
        _57 = const _;
        _13 = _57 as &[&str] (PointerCoercion(Unsize));
        _18 = &_8;
        _17 = core::fmt::rt::Argument::<'_>::new_display::<&ignore::Error>(_18) -> [return: bb7, unwind: bb35];
    }

    bb7: {
        _16 = [move _17];
        _15 = &_16;
        _14 = _15 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _12 = Arguments::<'_>::new_v1(move _13, move _14) -> [return: bb8, unwind: bb35];
    }

    bb8: {
        _11 = _eprint(move _12) -> [return: bb37, unwind: bb35];
    }

    bb9: {
        _20 = &_3;
        _19 = Subject::is_explicit(move _20) -> [return: bb10, unwind: bb35];
    }

    bb10: {
        switchInt(move _19) -> [0: bb12, otherwise: bb11];
    }

    bb11: {
        _21 = move _3;
        _0 = Option::<Subject>::Some(move _21);
        goto -> bb33;
    }

    bb12: {
        _23 = &_3;
        _22 = Subject::is_file(move _23) -> [return: bb13, unwind: bb35];
    }

    bb13: {
        switchInt(move _22) -> [0: bb15, otherwise: bb14];
    }

    bb14: {
        _24 = move _3;
        _0 = Option::<Subject>::Some(move _24);
        goto -> bb33;
    }

    bb15: {
        _26 = &_3;
        _25 = Subject::is_dir(move _26) -> [return: bb16, unwind: bb35];
    }

    bb16: {
        switchInt(move _25) -> [0: bb17, otherwise: bb32];
    }

    bb17: {
        _27 = log::Level::Debug;
        _29 = &_27;
        _56 = const _;
        _28 = <Level as PartialOrd<LevelFilter>>::le(move _29, _56) -> [return: bb18, unwind: bb35];
    }

    bb18: {
        switchInt(move _28) -> [0: bb32, otherwise: bb19];
    }

    bb19: {
        _31 = &_27;
        _33 = max_level() -> [return: bb20, unwind: bb35];
    }

    bb20: {
        _32 = &_33;
        _30 = <Level as PartialOrd<LevelFilter>>::le(move _31, move _32) -> [return: bb21, unwind: bb35];
    }

    bb21: {
        switchInt(move _30) -> [0: bb32, otherwise: bb22];
    }

    bb22: {
        _55 = const _;
        _36 = _55 as &[&str] (PointerCoercion(Unsize));
        _44 = &(_3.0: ignore::DirEntry);
        _43 = ignore::DirEntry::path(move _44) -> [return: bb23, unwind: bb35];
    }

    bb23: {
        _42 = Path::display(_43) -> [return: bb24, unwind: bb35];
    }

    bb24: {
        _41 = &_42;
        _40 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_41) -> [return: bb25, unwind: bb35];
    }

    bb25: {
        _48 = &(_3.0: ignore::DirEntry);
        _47 = ignore::DirEntry::file_type(move _48) -> [return: bb26, unwind: bb35];
    }

    bb26: {
        _46 = &_47;
        _45 = core::fmt::rt::Argument::<'_>::new_debug::<Option<FileType>>(_46) -> [return: bb27, unwind: bb35];
    }

    bb27: {
        _52 = &(_3.0: ignore::DirEntry);
        _51 = ignore::DirEntry::metadata(move _52) -> [return: bb28, unwind: bb35];
    }

    bb28: {
        _50 = &_51;
        _49 = core::fmt::rt::Argument::<'_>::new_debug::<std::result::Result<std::fs::Metadata, ignore::Error>>(_50) -> [return: bb29, unwind: bb34];
    }

    bb29: {
        _39 = [move _40, move _45, move _49];
        _38 = &_39;
        _37 = _38 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _35 = Arguments::<'_>::new_v1(move _36, move _37) -> [return: bb30, unwind: bb34];
    }

    bb30: {
        _53 = _27;
        _54 = const _;
        _34 = __private_api_log(move _35, move _53, _54) -> [return: bb31, unwind: bb34];
    }

    bb31: {
        drop(_51) -> [return: bb32, unwind: bb35];
    }

    bb32: {
        _0 = Option::<Subject>::None;
        drop(_3) -> [return: bb33, unwind continue];
    }

    bb33: {
        return;
    }

    bb34 (cleanup): {
        drop(_51) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb35 (cleanup): {
        drop(_3) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb36 (cleanup): {
        resume;
    }

    bb37: {
        goto -> bb9;
    }
}

promoted[0] in subject::<impl at crates/core/subject.rs:24:1: 24:20>::build: &(&str, &str, &str, u32) = {
    let mut _0: &(&str, &str, &str, u32);
    let mut _1: (&str, &str, &str, u32);
    let mut _2: &str;
    let mut _3: &str;

    bb0: {
        _3 = const "rg::subject";
        _2 = &(*_3);
        _1 = (move _2, const "rg::subject", const "crates/core/subject.rs", const 74_u32);
        _0 = &_1;
        return;
    }
}

promoted[1] in subject::<impl at crates/core/subject.rs:24:1: 24:20>::build: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "ignoring ", const ": failed to pass subject filter: file type: ", const ", metadata: "];
        _0 = &_1;
        return;
    }
}

promoted[2] in subject::<impl at crates/core/subject.rs:24:1: 24:20>::build: &LevelFilter = {
    let mut _0: &log::LevelFilter;
    let mut _1: log::LevelFilter;

    bb0: {
        _1 = const _;
        _0 = &_1;
        return;
    }
}

promoted[3] in subject::<impl at crates/core/subject.rs:24:1: 24:20>::build: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:24:1: 24:20>::strip_dot_prefix(_1: &mut SubjectBuilder, _2: bool) -> &mut SubjectBuilder {
    debug self => _1;
    debug yes => _2;
    let mut _0: &mut subject::SubjectBuilder;

    bb0: {
        (((*_1).0: subject::Config).0: bool) = _2;
        _0 = _1;
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:97:10: 97:15>::clone(_1: &Subject) -> Subject {
    debug self => _1;
    let mut _0: subject::Subject;
    let mut _2: ignore::DirEntry;
    let _3: &ignore::DirEntry;
    let mut _4: bool;
    let _5: &bool;

    bb0: {
        _3 = &((*_1).0: ignore::DirEntry);
        _2 = <ignore::DirEntry as Clone>::clone(_3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &((*_1).1: bool);
        _4 = (*_5);
        _0 = Subject { dent: move _2, strip_dot_prefix: move _4 };
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:97:17: 97:22>::fmt(_1: &Subject, _2: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
    debug self => _1;
    debug f => _2;
    let mut _0: std::result::Result<(), std::fmt::Error>;
    let _3: &str;
    let _4: &str;
    let mut _5: &dyn std::fmt::Debug;
    let _6: &ignore::DirEntry;
    let _7: &str;
    let mut _8: &dyn std::fmt::Debug;
    let _9: &&bool;
    let _10: &bool;

    bb0: {
        _3 = const "Subject";
        _4 = const "dent";
        _6 = &((*_1).0: ignore::DirEntry);
        _5 = _6 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _7 = const "strip_dot_prefix";
        _10 = &((*_1).1: bool);
        _9 = &_10;
        _8 = _9 as &dyn std::fmt::Debug (PointerCoercion(Unsize));
        _0 = std::fmt::Formatter::<'_>::debug_struct_field2_finish(_2, _3, _4, move _5, _7, move _8) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::path(_1: &Subject) -> &Path {
    debug self => _1;
    let mut _0: &std::path::Path;
    let mut _2: bool;
    let mut _3: bool;
    let _4: &std::path::Path;
    let mut _5: &ignore::DirEntry;
    let _6: &std::path::Path;
    let mut _7: std::result::Result<&std::path::Path, std::path::StripPrefixError>;
    let _8: &std::path::Path;
    let mut _9: &ignore::DirEntry;
    let _10: &std::path::Path;
    let mut _11: &ignore::DirEntry;

    bb0: {
        _2 = ((*_1).1: bool);
        switchInt(move _2) -> [0: bb8, otherwise: bb1];
    }

    bb1: {
        _5 = &((*_1).0: ignore::DirEntry);
        _4 = ignore::DirEntry::path(move _5) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = Path::starts_with::<&str>(_4, const "./") -> [return: bb3, unwind continue];
    }

    bb3: {
        switchInt(move _3) -> [0: bb8, otherwise: bb4];
    }

    bb4: {
        _9 = &((*_1).0: ignore::DirEntry);
        _8 = ignore::DirEntry::path(move _9) -> [return: bb5, unwind continue];
    }

    bb5: {
        _7 = Path::strip_prefix::<&str>(_8, const "./") -> [return: bb6, unwind continue];
    }

    bb6: {
        _6 = std::result::Result::<&Path, StripPrefixError>::unwrap(move _7) -> [return: bb7, unwind continue];
    }

    bb7: {
        _0 = _6;
        goto -> bb10;
    }

    bb8: {
        _11 = &((*_1).0: ignore::DirEntry);
        _10 = ignore::DirEntry::path(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _0 = _10;
        goto -> bb10;
    }

    bb10: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::is_stdin(_1: &Subject) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: &ignore::DirEntry;

    bb0: {
        _2 = &((*_1).0: ignore::DirEntry);
        _0 = ignore::DirEntry::is_stdin(move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::is_explicit(_1: &Subject) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: bool;
    let mut _3: usize;
    let mut _4: &ignore::DirEntry;
    let mut _5: bool;

    bb0: {
        _2 = Subject::is_stdin(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        switchInt(move _2) -> [0: bb3, otherwise: bb2];
    }

    bb2: {
        _0 = const true;
        goto -> bb8;
    }

    bb3: {
        _4 = &((*_1).0: ignore::DirEntry);
        _3 = ignore::DirEntry::depth(move _4) -> [return: bb4, unwind continue];
    }

    bb4: {
        switchInt(move _3) -> [0: bb5, otherwise: bb6];
    }

    bb5: {
        _5 = Subject::is_dir(_1) -> [return: bb7, unwind continue];
    }

    bb6: {
        _0 = const false;
        goto -> bb8;
    }

    bb7: {
        _0 = Not(move _5);
        goto -> bb8;
    }

    bb8: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::is_dir(_1: &Subject) -> bool {
    debug self => _1;
    let mut _0: bool;
    let _2: std::fs::FileType;
    let mut _3: std::option::Option<std::fs::FileType>;
    let mut _4: &ignore::DirEntry;
    let mut _5: isize;
    let _6: std::fs::FileType;
    let mut _7: bool;
    let mut _8: &std::fs::FileType;
    let mut _9: bool;
    let mut _10: &ignore::DirEntry;
    let _11: &std::path::Path;
    let mut _12: &ignore::DirEntry;
    scope 1 {
        debug ft => _2;
    }
    scope 2 {
        debug ft => _6;
    }

    bb0: {
        _4 = &((*_1).0: ignore::DirEntry);
        _3 = ignore::DirEntry::file_type(move _4) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb2, otherwise: bb3];
    }

    bb2: {
        _6 = ((_3 as Some).0: std::fs::FileType);
        _2 = _6;
        _8 = &_2;
        _7 = FileType::is_dir(move _8) -> [return: bb5, unwind continue];
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _0 = const false;
        goto -> bb12;
    }

    bb5: {
        switchInt(move _7) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = const true;
        goto -> bb12;
    }

    bb7: {
        _10 = &((*_1).0: ignore::DirEntry);
        _9 = ignore::DirEntry::path_is_symlink(move _10) -> [return: bb8, unwind continue];
    }

    bb8: {
        switchInt(move _9) -> [0: bb10, otherwise: bb9];
    }

    bb9: {
        _12 = &((*_1).0: ignore::DirEntry);
        _11 = ignore::DirEntry::path(move _12) -> [return: bb11, unwind continue];
    }

    bb10: {
        _0 = const false;
        goto -> bb12;
    }

    bb11: {
        _0 = Path::is_dir(_11) -> [return: bb12, unwind continue];
    }

    bb12: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::is_file(_1: &Subject) -> bool {
    debug self => _1;
    let mut _0: bool;
    let mut _2: std::option::Option<std::fs::FileType>;
    let mut _3: &ignore::DirEntry;

    bb0: {
        _3 = &((*_1).0: ignore::DirEntry);
        _2 = ignore::DirEntry::file_type(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        _0 = Option::<FileType>::map_or::<bool, {closure@crates/core/subject.rs:158:45: 158:49}>(move _2, const false, const ZeroSized: {closure@crates/core/subject.rs:158:45: 158:49}) -> [return: bb2, unwind continue];
    }

    bb2: {
        return;
    }
}

fn subject::<impl at crates/core/subject.rs:103:1: 103:13>::is_file::{closure#0}(_1: {closure@crates/core/subject.rs:158:45: 158:49}, _2: FileType) -> bool {
    debug ft => _2;
    let mut _0: bool;
    let mut _3: &std::fs::FileType;

    bb0: {
        _3 = &_2;
        _0 = FileType::is_file(move _3) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn main() -> () {
    let mut _0: ();
    let mut _1: std::result::Result<(), std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::result::Result<args::Args, std::boxed::Box<dyn std::error::Error>>;
    let mut _3: isize;
    let _5: ();
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: &[core::fmt::rt::Argument<'_>];
    let _9: &[core::fmt::rt::Argument<'_>; 1];
    let _10: [core::fmt::rt::Argument<'_>; 1];
    let mut _11: core::fmt::rt::Argument<'_>;
    let _12: &std::boxed::Box<dyn std::error::Error>;
    let _13: !;
    scope 1 {
        debug err => _4;
        let _4: std::boxed::Box<dyn std::error::Error>;
        let mut _14: &[&str; 2];
    }

    bb0: {
        _2 = args::Args::parse() -> [return: bb1, unwind continue];
    }

    bb1: {
        _1 = std::result::Result::<args::Args, Box<dyn std::error::Error>>::and_then::<(), fn(args::Args) -> std::result::Result<(), Box<(dyn std::error::Error + 'static)>> {try_main}>(move _2, try_main) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = discriminant(_1);
        switchInt(move _3) -> [1: bb3, otherwise: bb7];
    }

    bb3: {
        _4 = move ((_1 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _14 = const _;
        _7 = _14 as &[&str] (PointerCoercion(Unsize));
        _12 = &_4;
        _11 = core::fmt::rt::Argument::<'_>::new_display::<Box<dyn std::error::Error>>(_12) -> [return: bb4, unwind: bb9];
    }

    bb4: {
        _10 = [move _11];
        _9 = &_10;
        _8 = _9 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_v1(move _7, move _8) -> [return: bb5, unwind: bb9];
    }

    bb5: {
        _5 = _eprint(move _6) -> [return: bb6, unwind: bb9];
    }

    bb6: {
        _13 = exit(const 2_i32) -> bb9;
    }

    bb7: {
        drop(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        return;
    }

    bb9 (cleanup): {
        drop(_4) -> [return: bb10, unwind terminate(cleanup)];
    }

    bb10 (cleanup): {
        resume;
    }
}

promoted[0] in main: &[&str; 2] = {
    let mut _0: &[&str; 2];
    let mut _1: [&str; 2];

    bb0: {
        _1 = [const "", const "\n"];
        _0 = &_1;
        return;
    }
}

fn try_main(_1: args::Args) -> std::result::Result<(), Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<(), std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, bool>;
    let mut _3: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, args::Command>;
    let mut _5: std::result::Result<args::Command, std::boxed::Box<dyn std::error::Error>>;
    let mut _6: &args::Args;
    let mut _7: isize;
    let _8: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _9: args::Command;
    let mut _10: isize;
    let _11: &args::Args;
    let _12: &args::Args;
    let _13: &args::Args;
    let _14: &args::Args;
    let _15: &args::Args;
    let _16: &args::Args;
    let mut _17: isize;
    let _18: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _19: bool;
    let mut _20: bool;
    let mut _21: &args::Args;
    let mut _22: bool;
    let mut _23: !;
    let mut _24: bool;
    let mut _25: !;
    let mut _26: !;
    scope 1 {
        debug matched => _19;
    }
    scope 2 {
        debug residual => _8;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _9;
        scope 5 {
        }
    }
    scope 6 {
        debug residual => _18;
        scope 7 {
        }
    }
    scope 8 {
        debug val => _19;
        scope 9 {
        }
    }

    bb0: {
        _6 = &_1;
        _5 = args::Args::command(move _6) -> [return: bb1, unwind: bb28];
    }

    bb1: {
        _4 = <std::result::Result<args::Command, Box<dyn std::error::Error>> as Try>::branch(move _5) -> [return: bb2, unwind: bb28];
    }

    bb2: {
        _7 = discriminant(_4);
        switchInt(move _7) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _9 = ((_4 as Continue).0: args::Command);
        _10 = discriminant(_9);
        switchInt(move _10) -> [0: bb7, 1: bb8, 2: bb9, 3: bb10, 4: bb11, 5: bb12, 6: bb6, otherwise: bb4];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _8 = move ((_4 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _8) -> [return: bb30, unwind: bb28];
    }

    bb6: {
        _16 = &_1;
        _3 = pcre2_version(_16) -> [return: bb31, unwind: bb28];
    }

    bb7: {
        _11 = &_1;
        _3 = search(_11) -> [return: bb32, unwind: bb28];
    }

    bb8: {
        _12 = &_1;
        _3 = search_parallel(_12) -> [return: bb33, unwind: bb28];
    }

    bb9: {
        _3 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(const false);
        goto -> bb13;
    }

    bb10: {
        _13 = &_1;
        _3 = files(_13) -> [return: bb34, unwind: bb28];
    }

    bb11: {
        _14 = &_1;
        _3 = files_parallel(_14) -> [return: bb35, unwind: bb28];
    }

    bb12: {
        _15 = &_1;
        _3 = types(_15) -> [return: bb36, unwind: bb28];
    }

    bb13: {
        _2 = <std::result::Result<bool, Box<dyn std::error::Error>> as Try>::branch(move _3) -> [return: bb14, unwind: bb28];
    }

    bb14: {
        _17 = discriminant(_2);
        switchInt(move _17) -> [0: bb15, 1: bb16, otherwise: bb4];
    }

    bb15: {
        _19 = ((_2 as Continue).0: bool);
        switchInt(_19) -> [0: bb22, otherwise: bb17];
    }

    bb16: {
        _18 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<(), Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _18) -> [return: bb37, unwind: bb28];
    }

    bb17: {
        _21 = &_1;
        _20 = args::Args::quiet(move _21) -> [return: bb18, unwind: bb28];
    }

    bb18: {
        switchInt(move _20) -> [0: bb19, otherwise: bb21];
    }

    bb19: {
        _22 = errored() -> [return: bb20, unwind: bb28];
    }

    bb20: {
        switchInt(move _22) -> [0: bb21, otherwise: bb22];
    }

    bb21: {
        _23 = exit(const 0_i32) -> bb28;
    }

    bb22: {
        _24 = errored() -> [return: bb23, unwind: bb28];
    }

    bb23: {
        switchInt(move _24) -> [0: bb25, otherwise: bb24];
    }

    bb24: {
        _25 = exit(const 2_i32) -> bb28;
    }

    bb25: {
        _26 = exit(const 1_i32) -> bb28;
    }

    bb26: {
        drop(_1) -> [return: bb27, unwind continue];
    }

    bb27: {
        return;
    }

    bb28 (cleanup): {
        drop(_1) -> [return: bb29, unwind terminate(cleanup)];
    }

    bb29 (cleanup): {
        resume;
    }

    bb30: {
        goto -> bb26;
    }

    bb31: {
        goto -> bb13;
    }

    bb32: {
        goto -> bb13;
    }

    bb33: {
        goto -> bb13;
    }

    bb34: {
        goto -> bb13;
    }

    bb35: {
        goto -> bb13;
    }

    bb36: {
        goto -> bb13;
    }

    bb37: {
        goto -> bb26;
    }
}

fn search(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let _2: std::time::Instant;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, bool>;
    let mut _4: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: isize;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<grep::grep_printer::Stats>>;
    let mut _11: std::result::Result<std::option::Option<grep::grep_printer::Stats>, std::boxed::Box<dyn std::error::Error>>;
    let mut _12: isize;
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, search::SearchWorker<grep::grep_cli::StandardStream>>;
    let mut _17: std::result::Result<search::SearchWorker<grep::grep_cli::StandardStream>, std::boxed::Box<dyn std::error::Error>>;
    let mut _18: grep::grep_cli::StandardStream;
    let mut _19: isize;
    let mut _24: ignore::Walk;
    let mut _25: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::Walk>;
    let mut _26: std::result::Result<ignore::Walk, std::boxed::Box<dyn std::error::Error>>;
    let mut _27: isize;
    let mut _31: std::option::Option<std::result::Result<ignore::DirEntry, ignore::Error>>;
    let mut _32: &mut ignore::Walk;
    let mut _33: isize;
    let mut _36: std::option::Option<subject::Subject>;
    let mut _37: &subject::SubjectBuilder;
    let mut _38: isize;
    let mut _41: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _42: &mut search::SearchWorker<grep::grep_cli::StandardStream>;
    let _43: &subject::Subject;
    let mut _44: isize;
    let mut _47: bool;
    let mut _48: &std::io::ErrorKind;
    let _49: std::io::ErrorKind;
    let mut _50: &std::io::Error;
    let _51: ();
    let mut _52: bool;
    let _53: ();
    let mut _54: std::fmt::Arguments<'_>;
    let mut _55: &[&str];
    let mut _56: &[core::fmt::rt::Argument<'_>];
    let _57: &[core::fmt::rt::Argument<'_>; 2];
    let _58: [core::fmt::rt::Argument<'_>; 2];
    let mut _59: core::fmt::rt::Argument<'_>;
    let _60: &std::path::Display<'_>;
    let _61: std::path::Display<'_>;
    let _62: &std::path::Path;
    let mut _63: &subject::Subject;
    let mut _64: core::fmt::rt::Argument<'_>;
    let _65: &std::io::Error;
    let mut _66: bool;
    let mut _67: bool;
    let mut _68: &search::SearchResult;
    let mut _69: isize;
    let _71: ();
    let mut _72: &grep::grep_printer::Stats;
    let mut _73: std::option::Option<&grep::grep_printer::Stats>;
    let mut _74: &search::SearchResult;
    let mut _75: bool;
    let mut _76: bool;
    let mut _77: bool;
    let _78: ();
    let mut _79: isize;
    let mut _82: &std::time::Instant;
    let _83: std::time::Instant;
    let mut _84: std::result::Result<(), std::io::Error>;
    let mut _85: &mut search::SearchWorker<grep::grep_cli::StandardStream>;
    let mut _86: bool;
    scope 1 {
        debug started_at => _2;
        let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
        let _7: bool;
        scope 2 {
            debug quit_after_match => _7;
            let _8: subject::SubjectBuilder;
            scope 7 {
                debug subject_builder => _8;
                let mut _9: std::option::Option<grep::grep_printer::Stats>;
                let _13: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                let _14: std::option::Option<grep::grep_printer::Stats>;
                scope 8 {
                    debug stats => _9;
                    let mut _15: search::SearchWorker<grep::grep_cli::StandardStream>;
                    let _20: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                    let _21: search::SearchWorker<grep::grep_cli::StandardStream>;
                    scope 13 {
                        debug searcher => _15;
                        let mut _22: bool;
                        scope 18 {
                            debug matched => _22;
                            let mut _23: bool;
                            scope 19 {
                                debug searched => _23;
                                let _28: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                                let _29: ignore::Walk;
                                let mut _30: ignore::Walk;
                                scope 20 {
                                    debug residual => _28;
                                    scope 21 {
                                    }
                                }
                                scope 22 {
                                    debug val => _29;
                                    scope 23 {
                                    }
                                }
                                scope 24 {
                                    debug iter => _30;
                                    let _34: std::result::Result<ignore::DirEntry, ignore::Error>;
                                    scope 25 {
                                        debug result => _34;
                                        let _35: subject::Subject;
                                        let _39: subject::Subject;
                                        scope 26 {
                                            debug subject => _35;
                                            let _40: search::SearchResult;
                                            let _45: search::SearchResult;
                                            let _46: std::io::Error;
                                            scope 28 {
                                                debug search_result => _40;
                                                scope 31 {
                                                    debug stats => _70;
                                                    let _70: &mut grep::grep_printer::Stats;
                                                }
                                            }
                                            scope 29 {
                                                debug search_result => _45;
                                            }
                                            scope 30 {
                                                debug err => _46;
                                                let mut _87: &[&str; 3];
                                                let mut _88: &std::io::ErrorKind;
                                            }
                                        }
                                        scope 27 {
                                            debug subject => _39;
                                        }
                                    }
                                }
                                scope 32 {
                                    debug stats => _80;
                                    let _80: &grep::grep_printer::Stats;
                                    let _81: std::time::Duration;
                                    scope 33 {
                                        debug elapsed => _81;
                                        scope 34 {
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 14 {
                        debug residual => _20;
                        scope 15 {
                        }
                    }
                    scope 16 {
                        debug val => _21;
                        scope 17 {
                        }
                    }
                }
                scope 9 {
                    debug residual => _13;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _14;
                    scope 12 {
                    }
                }
            }
        }
        scope 3 {
            debug residual => _6;
            scope 4 {
            }
        }
        scope 5 {
            debug val => _7;
            scope 6 {
            }
        }
    }

    bb0: {
        _2 = Instant::now() -> [return: bb1, unwind continue];
    }

    bb1: {
        _4 = args::Args::quit_after_match(_1) -> [return: bb2, unwind continue];
    }

    bb2: {
        _3 = <std::result::Result<bool, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb3, unwind continue];
    }

    bb3: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _7 = ((_3 as Continue).0: bool);
        _8 = args::Args::subject_builder(_1) -> [return: bb7, unwind continue];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb65, unwind continue];
    }

    bb7: {
        _11 = args::Args::stats(_1) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = <std::result::Result<Option<Stats>, Box<dyn std::error::Error>> as Try>::branch(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _12 = discriminant(_10);
        switchInt(move _12) -> [0: bb10, 1: bb11, otherwise: bb5];
    }

    bb10: {
        _14 = move ((_10 as Continue).0: std::option::Option<grep::grep_printer::Stats>);
        _9 = move _14;
        _18 = args::Args::stdout(_1) -> [return: bb12, unwind continue];
    }

    bb11: {
        _13 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _13) -> [return: bb65, unwind continue];
    }

    bb12: {
        _17 = args::Args::search_worker::<grep::grep_cli::StandardStream>(_1, move _18) -> [return: bb13, unwind continue];
    }

    bb13: {
        _16 = <std::result::Result<SearchWorker<grep::grep_cli::StandardStream>, Box<dyn std::error::Error>> as Try>::branch(move _17) -> [return: bb14, unwind continue];
    }

    bb14: {
        _19 = discriminant(_16);
        switchInt(move _19) -> [0: bb15, 1: bb16, otherwise: bb5];
    }

    bb15: {
        _21 = move ((_16 as Continue).0: search::SearchWorker<grep::grep_cli::StandardStream>);
        _15 = move _21;
        _22 = const false;
        _23 = const false;
        _26 = args::Args::walker(_1) -> [return: bb17, unwind: bb69];
    }

    bb16: {
        _20 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _20) -> [return: bb65, unwind continue];
    }

    bb17: {
        _25 = <std::result::Result<Walk, Box<dyn std::error::Error>> as Try>::branch(move _26) -> [return: bb18, unwind: bb69];
    }

    bb18: {
        _27 = discriminant(_25);
        switchInt(move _27) -> [0: bb19, 1: bb20, otherwise: bb5];
    }

    bb19: {
        _29 = move ((_25 as Continue).0: ignore::Walk);
        _24 = <Walk as IntoIterator>::into_iter(move _29) -> [return: bb22, unwind: bb69];
    }

    bb20: {
        _28 = move ((_25 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _28) -> [return: bb21, unwind: bb69];
    }

    bb21: {
        drop(_15) -> [return: bb65, unwind continue];
    }

    bb22: {
        _30 = move _24;
        goto -> bb23;
    }

    bb23: {
        _32 = &mut _30;
        _31 = <Walk as Iterator>::next(_32) -> [return: bb24, unwind: bb68];
    }

    bb24: {
        _33 = discriminant(_31);
        switchInt(move _33) -> [0: bb71, 1: bb25, otherwise: bb5];
    }

    bb25: {
        _34 = move ((_31 as Some).0: std::result::Result<ignore::DirEntry, ignore::Error>);
        _37 = &_8;
        _36 = SubjectBuilder::build_from_result(move _37, move _34) -> [return: bb26, unwind: bb68];
    }

    bb26: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb23, 1: bb27, otherwise: bb5];
    }

    bb27: {
        _39 = move ((_36 as Some).0: subject::Subject);
        _35 = move _39;
        _23 = const true;
        _42 = &mut _15;
        _43 = &_35;
        _41 = SearchWorker::<grep::grep_cli::StandardStream>::search(move _42, _43) -> [return: bb28, unwind: bb67];
    }

    bb28: {
        _44 = discriminant(_41);
        switchInt(move _44) -> [0: bb30, 1: bb29, otherwise: bb5];
    }

    bb29: {
        _46 = move ((_41 as Err).0: std::io::Error);
        _50 = &_46;
        _49 = std::io::Error::kind(move _50) -> [return: bb31, unwind: bb66];
    }

    bb30: {
        _45 = move ((_41 as Ok).0: search::SearchResult);
        _40 = move _45;
        _67 = _22;
        switchInt(move _67) -> [0: bb45, otherwise: bb44];
    }

    bb31: {
        _48 = &_49;
        _88 = const _;
        _47 = <std::io::ErrorKind as PartialEq>::eq(move _48, _88) -> [return: bb32, unwind: bb66];
    }

    bb32: {
        switchInt(move _47) -> [0: bb34, otherwise: bb33];
    }

    bb33: {
        drop(_46) -> [return: bb53, unwind: bb67];
    }

    bb34: {
        _51 = set_errored() -> [return: bb35, unwind: bb66];
    }

    bb35: {
        _52 = messages() -> [return: bb36, unwind: bb66];
    }

    bb36: {
        switchInt(move _52) -> [0: bb43, otherwise: bb37];
    }

    bb37: {
        _87 = const _;
        _55 = _87 as &[&str] (PointerCoercion(Unsize));
        _63 = &_35;
        _62 = Subject::path(move _63) -> [return: bb38, unwind: bb66];
    }

    bb38: {
        _61 = Path::display(_62) -> [return: bb39, unwind: bb66];
    }

    bb39: {
        _60 = &_61;
        _59 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_60) -> [return: bb40, unwind: bb66];
    }

    bb40: {
        _65 = &_46;
        _64 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_65) -> [return: bb41, unwind: bb66];
    }

    bb41: {
        _58 = [move _59, move _64];
        _57 = &_58;
        _56 = _57 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _54 = Arguments::<'_>::new_v1(move _55, move _56) -> [return: bb42, unwind: bb66];
    }

    bb42: {
        _53 = _eprint(move _54) -> [return: bb72, unwind: bb66];
    }

    bb43: {
        drop(_46) -> [return: bb54, unwind: bb67];
    }

    bb44: {
        _66 = const true;
        goto -> bb46;
    }

    bb45: {
        _68 = &_40;
        _66 = SearchResult::has_match(move _68) -> [return: bb73, unwind: bb67];
    }

    bb46: {
        _22 = move _66;
        _69 = discriminant(_9);
        switchInt(move _69) -> [1: bb47, otherwise: bb50];
    }

    bb47: {
        _70 = &mut ((_9 as Some).0: grep::grep_printer::Stats);
        _74 = &_40;
        _73 = SearchResult::stats(move _74) -> [return: bb48, unwind: bb67];
    }

    bb48: {
        _72 = Option::<&Stats>::unwrap(move _73) -> [return: bb49, unwind: bb67];
    }

    bb49: {
        _71 = <Stats as AddAssign<&Stats>>::add_assign(_70, move _72) -> [return: bb74, unwind: bb67];
    }

    bb50: {
        _75 = _22;
        switchInt(move _75) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        switchInt(_7) -> [0: bb52, otherwise: bb53];
    }

    bb52: {
        drop(_35) -> [return: bb23, unwind: bb68];
    }

    bb53: {
        drop(_35) -> [return: bb71, unwind: bb68];
    }

    bb54: {
        drop(_35) -> [return: bb23, unwind: bb68];
    }

    bb55: {
        _76 = args::Args::using_default_path(_1) -> [return: bb56, unwind: bb69];
    }

    bb56: {
        switchInt(move _76) -> [0: bb59, otherwise: bb57];
    }

    bb57: {
        _77 = _23;
        switchInt(move _77) -> [0: bb58, otherwise: bb59];
    }

    bb58: {
        _78 = eprint_nothing_searched() -> [return: bb75, unwind: bb69];
    }

    bb59: {
        _79 = discriminant(_9);
        switchInt(move _79) -> [1: bb60, otherwise: bb64];
    }

    bb60: {
        _80 = &((_9 as Some).0: grep::grep_printer::Stats);
        _83 = Instant::now() -> [return: bb61, unwind: bb69];
    }

    bb61: {
        _82 = &_83;
        _81 = Instant::duration_since(move _82, _2) -> [return: bb62, unwind: bb69];
    }

    bb62: {
        _85 = &mut _15;
        _84 = SearchWorker::<grep::grep_cli::StandardStream>::print_stats(move _85, _81, _80) -> [return: bb63, unwind: bb69];
    }

    bb63: {
        drop(_84) -> [return: bb64, unwind: bb69];
    }

    bb64: {
        _86 = _22;
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _86);
        drop(_15) -> [return: bb65, unwind continue];
    }

    bb65: {
        return;
    }

    bb66 (cleanup): {
        drop(_46) -> [return: bb67, unwind terminate(cleanup)];
    }

    bb67 (cleanup): {
        drop(_35) -> [return: bb68, unwind terminate(cleanup)];
    }

    bb68 (cleanup): {
        drop(_30) -> [return: bb69, unwind terminate(cleanup)];
    }

    bb69 (cleanup): {
        drop(_15) -> [return: bb70, unwind terminate(cleanup)];
    }

    bb70 (cleanup): {
        resume;
    }

    bb71: {
        drop(_30) -> [return: bb55, unwind: bb69];
    }

    bb72: {
        goto -> bb43;
    }

    bb73: {
        goto -> bb46;
    }

    bb74: {
        goto -> bb50;
    }

    bb75: {
        goto -> bb59;
    }
}

promoted[0] in search: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in search: &std::io::ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = BrokenPipe;
        _0 = &_1;
        return;
    }
}

fn search_parallel(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let _2: bool;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, bool>;
    let mut _4: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: &args::Args;
    let mut _6: isize;
    let _7: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _8: bool;
    let mut _11: &args::Args;
    let mut _13: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, termcolor::BufferWriter>;
    let mut _14: std::result::Result<termcolor::BufferWriter, std::boxed::Box<dyn std::error::Error>>;
    let mut _15: &args::Args;
    let mut _16: isize;
    let mut _20: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::option::Option<grep::grep_printer::Stats>>;
    let mut _21: std::result::Result<std::option::Option<grep::grep_printer::Stats>, std::boxed::Box<dyn std::error::Error>>;
    let mut _22: &args::Args;
    let mut _23: isize;
    let _29: ();
    let mut _30: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::WalkParallel>;
    let mut _31: std::result::Result<ignore::WalkParallel, std::boxed::Box<dyn std::error::Error>>;
    let mut _32: &args::Args;
    let mut _33: isize;
    let mut _36: {closure@crates/core/main.rs:139:33: 139:35};
    let mut _37: &termcolor::BufferWriter;
    let mut _38: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>;
    let mut _39: &std::sync::atomic::AtomicBool;
    let mut _40: &std::sync::atomic::AtomicBool;
    let mut _41: &subject::SubjectBuilder;
    let mut _42: &&args::Args;
    let mut _43: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _44: &bool;
    let mut _45: std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _46: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _47: isize;
    let mut _49: bool;
    let mut _50: &args::Args;
    let mut _51: bool;
    let mut _52: &std::sync::atomic::AtomicBool;
    let mut _53: std::sync::atomic::Ordering;
    let _54: ();
    let mut _55: isize;
    let mut _58: &std::time::Instant;
    let _59: std::time::Instant;
    let mut _61: std::result::Result<std::sync::MutexGuard<'_, grep::grep_printer::Stats>, std::sync::PoisonError<std::sync::MutexGuard<'_, grep::grep_printer::Stats>>>;
    let mut _63: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, search::SearchWorker<grep::grep_cli::StandardStream>>;
    let mut _64: std::result::Result<search::SearchWorker<grep::grep_cli::StandardStream>, std::boxed::Box<dyn std::error::Error>>;
    let mut _65: &args::Args;
    let mut _66: grep::grep_cli::StandardStream;
    let mut _67: &args::Args;
    let mut _68: isize;
    let mut _71: std::result::Result<(), std::io::Error>;
    let mut _72: &mut search::SearchWorker<grep::grep_cli::StandardStream>;
    let _73: &grep::grep_printer::Stats;
    let _74: &std::sync::MutexGuard<'_, grep::grep_printer::Stats>;
    let mut _75: bool;
    let mut _76: &std::sync::atomic::AtomicBool;
    let mut _77: std::sync::atomic::Ordering;
    scope 1 {
        debug quit_after_match => _2;
        let _9: std::time::Instant;
        scope 6 {
            debug started_at => _9;
            let _10: subject::SubjectBuilder;
            scope 7 {
                debug subject_builder => _10;
                let _12: termcolor::BufferWriter;
                let _17: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                let _18: termcolor::BufferWriter;
                scope 8 {
                    debug bufwtr => _12;
                    let _19: std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>;
                    let _24: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                    let _25: std::option::Option<grep::grep_printer::Stats>;
                    scope 13 {
                        debug stats => _19;
                        let _26: std::sync::atomic::AtomicBool;
                        scope 18 {
                            debug matched => _26;
                            let _27: std::sync::atomic::AtomicBool;
                            scope 19 {
                                debug searched => _27;
                                let mut _28: std::option::Option<std::boxed::Box<dyn std::error::Error>>;
                                scope 20 {
                                    debug searcher_err => _28;
                                    let _34: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                                    let _35: ignore::WalkParallel;
                                    scope 21 {
                                        debug residual => _34;
                                        scope 22 {
                                        }
                                    }
                                    scope 23 {
                                        debug val => _35;
                                        scope 24 {
                                        }
                                    }
                                    scope 25 {
                                        debug err => _48;
                                        let _48: std::boxed::Box<dyn std::error::Error>;
                                    }
                                    scope 26 {
                                        debug locked_stats => _56;
                                        let _56: &std::sync::Mutex<grep::grep_printer::Stats>;
                                        let _57: std::time::Duration;
                                        scope 27 {
                                            debug elapsed => _57;
                                            let _60: std::sync::MutexGuard<'_, grep::grep_printer::Stats>;
                                            scope 28 {
                                                debug stats => _60;
                                                let mut _62: search::SearchWorker<grep::grep_cli::StandardStream>;
                                                let _69: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                                                let _70: search::SearchWorker<grep::grep_cli::StandardStream>;
                                                scope 29 {
                                                    debug searcher => _62;
                                                    scope 34 {
                                                    }
                                                }
                                                scope 30 {
                                                    debug residual => _69;
                                                    scope 31 {
                                                    }
                                                }
                                                scope 32 {
                                                    debug val => _70;
                                                    scope 33 {
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    scope 14 {
                        debug residual => _24;
                        scope 15 {
                        }
                    }
                    scope 16 {
                        debug val => _25;
                        scope 17 {
                        }
                    }
                }
                scope 9 {
                    debug residual => _17;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _18;
                    scope 12 {
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _7;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _8;
        scope 5 {
        }
    }

    bb0: {
        _5 = _1;
        _4 = args::Args::quit_after_match(move _5) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<bool, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _6 = discriminant(_3);
        switchInt(move _6) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _8 = ((_3 as Continue).0: bool);
        _2 = _8;
        _9 = Instant::now() -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _7 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _7) -> [return: bb53, unwind continue];
    }

    bb6: {
        _11 = _1;
        _10 = args::Args::subject_builder(move _11) -> [return: bb7, unwind continue];
    }

    bb7: {
        _15 = _1;
        _14 = args::Args::buffer_writer(move _15) -> [return: bb8, unwind continue];
    }

    bb8: {
        _13 = <std::result::Result<BufferWriter, Box<dyn std::error::Error>> as Try>::branch(move _14) -> [return: bb9, unwind continue];
    }

    bb9: {
        _16 = discriminant(_13);
        switchInt(move _16) -> [0: bb10, 1: bb11, otherwise: bb4];
    }

    bb10: {
        _18 = move ((_13 as Continue).0: termcolor::BufferWriter);
        _12 = move _18;
        _22 = _1;
        _21 = args::Args::stats(move _22) -> [return: bb12, unwind: bb57];
    }

    bb11: {
        _17 = move ((_13 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _17) -> [return: bb53, unwind continue];
    }

    bb12: {
        _20 = <std::result::Result<Option<Stats>, Box<dyn std::error::Error>> as Try>::branch(move _21) -> [return: bb13, unwind: bb57];
    }

    bb13: {
        _23 = discriminant(_20);
        switchInt(move _23) -> [0: bb14, 1: bb15, otherwise: bb4];
    }

    bb14: {
        _25 = move ((_20 as Continue).0: std::option::Option<grep::grep_printer::Stats>);
        _19 = Option::<Stats>::map::<Mutex<Stats>, fn(Stats) -> Mutex<Stats> {Mutex::<Stats>::new}>(move _25, Mutex::<Stats>::new) -> [return: bb16, unwind: bb57];
    }

    bb15: {
        _24 = move ((_20 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _24) -> [return: bb59, unwind: bb57];
    }

    bb16: {
        _26 = AtomicBool::new(const false) -> [return: bb17, unwind: bb57];
    }

    bb17: {
        _27 = AtomicBool::new(const false) -> [return: bb18, unwind: bb57];
    }

    bb18: {
        _28 = Option::<Box<dyn std::error::Error>>::None;
        _32 = _1;
        _31 = args::Args::walker_parallel(move _32) -> [return: bb19, unwind: bb56];
    }

    bb19: {
        _30 = <std::result::Result<WalkParallel, Box<dyn std::error::Error>> as Try>::branch(move _31) -> [return: bb20, unwind: bb56];
    }

    bb20: {
        _33 = discriminant(_30);
        switchInt(move _33) -> [0: bb21, 1: bb22, otherwise: bb4];
    }

    bb21: {
        _35 = move ((_30 as Continue).0: ignore::WalkParallel);
        _37 = &_12;
        _38 = &_19;
        _39 = &_26;
        _40 = &_27;
        _41 = &_10;
        _42 = &_1;
        _43 = &mut _28;
        _44 = &_2;
        _36 = {closure@crates/core/main.rs:139:33: 139:35} { bufwtr: move _37, stats: move _38, matched: move _39, searched: move _40, subject_builder: move _41, args: move _42, searcher_err: move _43, quit_after_match: move _44 };
        _29 = WalkParallel::run::<'_, {closure@crates/core/main.rs:139:33: 139:35}>(move _35, move _36) -> [return: bb23, unwind: bb56];
    }

    bb22: {
        _34 = move ((_30 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _34) -> [return: bb60, unwind: bb56];
    }

    bb23: {
        _46 = &mut _28;
        _45 = Option::<Box<dyn std::error::Error>>::take(move _46) -> [return: bb24, unwind: bb56];
    }

    bb24: {
        _47 = discriminant(_45);
        switchInt(move _47) -> [1: bb25, otherwise: bb26];
    }

    bb25: {
        _48 = move ((_45 as Some).0: std::boxed::Box<dyn std::error::Error>);
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Err(move _48);
        goto -> bb51;
    }

    bb26: {
        drop(_45) -> [return: bb27, unwind: bb56];
    }

    bb27: {
        _50 = _1;
        _49 = args::Args::using_default_path(move _50) -> [return: bb28, unwind: bb56];
    }

    bb28: {
        switchInt(move _49) -> [0: bb32, otherwise: bb29];
    }

    bb29: {
        _52 = &_27;
        _53 = SeqCst;
        _51 = AtomicBool::load(move _52, move _53) -> [return: bb30, unwind: bb56];
    }

    bb30: {
        switchInt(move _51) -> [0: bb31, otherwise: bb32];
    }

    bb31: {
        _54 = eprint_nothing_searched() -> [return: bb61, unwind: bb56];
    }

    bb32: {
        _55 = discriminant(_19);
        switchInt(move _55) -> [1: bb33, otherwise: bb48];
    }

    bb33: {
        _56 = &((_19 as Some).0: std::sync::Mutex<grep::grep_printer::Stats>);
        _59 = Instant::now() -> [return: bb34, unwind: bb56];
    }

    bb34: {
        _58 = &_59;
        _57 = Instant::duration_since(move _58, _9) -> [return: bb35, unwind: bb56];
    }

    bb35: {
        _61 = Mutex::<Stats>::lock(_56) -> [return: bb36, unwind: bb56];
    }

    bb36: {
        _60 = std::result::Result::<MutexGuard<'_, Stats>, PoisonError<MutexGuard<'_, Stats>>>::unwrap(move _61) -> [return: bb37, unwind: bb56];
    }

    bb37: {
        _65 = _1;
        _67 = _1;
        _66 = args::Args::stdout(move _67) -> [return: bb38, unwind: bb55];
    }

    bb38: {
        _64 = args::Args::search_worker::<grep::grep_cli::StandardStream>(move _65, move _66) -> [return: bb39, unwind: bb55];
    }

    bb39: {
        _63 = <std::result::Result<SearchWorker<grep::grep_cli::StandardStream>, Box<dyn std::error::Error>> as Try>::branch(move _64) -> [return: bb40, unwind: bb55];
    }

    bb40: {
        _68 = discriminant(_63);
        switchInt(move _68) -> [0: bb41, 1: bb42, otherwise: bb4];
    }

    bb41: {
        _70 = move ((_63 as Continue).0: search::SearchWorker<grep::grep_cli::StandardStream>);
        _62 = move _70;
        _72 = &mut _62;
        _74 = &_60;
        _73 = <MutexGuard<'_, Stats> as Deref>::deref(_74) -> [return: bb44, unwind: bb54];
    }

    bb42: {
        _69 = move ((_63 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _69) -> [return: bb43, unwind: bb55];
    }

    bb43: {
        drop(_60) -> [return: bb51, unwind: bb56];
    }

    bb44: {
        _71 = SearchWorker::<grep::grep_cli::StandardStream>::print_stats(move _72, _57, _73) -> [return: bb45, unwind: bb54];
    }

    bb45: {
        drop(_71) -> [return: bb46, unwind: bb54];
    }

    bb46: {
        drop(_62) -> [return: bb47, unwind: bb55];
    }

    bb47: {
        drop(_60) -> [return: bb48, unwind: bb56];
    }

    bb48: {
        _76 = &_26;
        _77 = SeqCst;
        _75 = AtomicBool::load(move _76, move _77) -> [return: bb49, unwind: bb56];
    }

    bb49: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _75);
        drop(_28) -> [return: bb50, unwind: bb57];
    }

    bb50: {
        drop(_12) -> [return: bb53, unwind continue];
    }

    bb51: {
        drop(_28) -> [return: bb52, unwind: bb57];
    }

    bb52: {
        drop(_12) -> [return: bb53, unwind continue];
    }

    bb53: {
        return;
    }

    bb54 (cleanup): {
        drop(_62) -> [return: bb55, unwind terminate(cleanup)];
    }

    bb55 (cleanup): {
        drop(_60) -> [return: bb56, unwind terminate(cleanup)];
    }

    bb56 (cleanup): {
        drop(_28) -> [return: bb57, unwind terminate(cleanup)];
    }

    bb57 (cleanup): {
        drop(_12) -> [return: bb58, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        resume;
    }

    bb59: {
        goto -> bb52;
    }

    bb60: {
        goto -> bb51;
    }

    bb61: {
        goto -> bb32;
    }
}

fn search_parallel::{closure#0}(_1: &mut {closure@crates/core/main.rs:139:33: 139:35}) -> Box<dyn FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> WalkState + Send> {
    debug bufwtr => (*((*_1).0: &termcolor::BufferWriter));
    debug stats => (*((*_1).1: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>));
    debug matched => (*((*_1).2: &std::sync::atomic::AtomicBool));
    debug searched => (*((*_1).3: &std::sync::atomic::AtomicBool));
    debug subject_builder => (*((*_1).4: &subject::SubjectBuilder));
    debug args => (*((*_1).5: &&args::Args));
    debug searcher_err => (*((*_1).6: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>));
    debug quit_after_match => (*((*_1).7: &bool));
    let mut _0: std::boxed::Box<dyn std::ops::FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> ignore::WalkState + std::marker::Send>;
    let mut _3: std::result::Result<search::SearchWorker<termcolor::Buffer>, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: termcolor::Buffer;
    let mut _5: isize;
    let mut _8: std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _9: std::boxed::Box<{closure@crates/core/main.rs:149:33: 149:41}>;
    let mut _10: std::boxed::Box<{closure@crates/core/main.rs:153:18: 153:31}>;
    let mut _11: {closure@crates/core/main.rs:153:18: 153:31};
    let mut _12: &termcolor::BufferWriter;
    let mut _13: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>;
    let mut _14: &std::sync::atomic::AtomicBool;
    let mut _15: &std::sync::atomic::AtomicBool;
    let mut _16: &subject::SubjectBuilder;
    let mut _17: &&args::Args;
    let mut _18: &args::Args;
    let mut _19: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _20: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _21: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>;
    let mut _22: &bool;
    let mut _23: bool;
    scope 1 {
        debug bufwtr => _12;
        scope 2 {
            debug stats => _13;
            scope 3 {
                debug matched => _14;
                scope 4 {
                    debug searched => _15;
                    scope 5 {
                        debug subject_builder => _16;
                        let mut _2: search::SearchWorker<termcolor::Buffer>;
                        let _6: search::SearchWorker<termcolor::Buffer>;
                        let _7: std::boxed::Box<dyn std::error::Error>;
                        scope 6 {
                            debug searcher => _2;
                        }
                        scope 7 {
                            debug searcher => _6;
                        }
                        scope 8 {
                            debug err => _7;
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _23 = const false;
        _12 = deref_copy ((*_1).0: &termcolor::BufferWriter);
        _13 = deref_copy ((*_1).1: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>);
        _14 = deref_copy ((*_1).2: &std::sync::atomic::AtomicBool);
        _15 = deref_copy ((*_1).3: &std::sync::atomic::AtomicBool);
        _16 = deref_copy ((*_1).4: &subject::SubjectBuilder);
        _17 = deref_copy ((*_1).5: &&args::Args);
        _18 = deref_copy (*_17);
        _4 = BufferWriter::buffer(_12) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = args::Args::search_worker::<Buffer>(_18, move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb5, 1: bb3, otherwise: bb4];
    }

    bb3: {
        _7 = move ((_3 as Err).0: std::boxed::Box<dyn std::error::Error>);
        _8 = Option::<Box<dyn std::error::Error>>::Some(move _7);
        _19 = deref_copy ((*_1).6: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>);
        drop((*_19)) -> [return: bb6, unwind: bb7];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Ok).0: search::SearchWorker<termcolor::Buffer>);
        _23 = const true;
        _2 = move _6;
        _22 = deref_copy ((*_1).7: &bool);
        _23 = const false;
        _11 = {closure@crates/core/main.rs:153:18: 153:31} { subject_builder: _16, searched: _15, searcher: move _2, matched: _14, stats: _13, bufwtr: _12, quit_after_match: (*_22) };
        _10 = Box::<{closure@crates/core/main.rs:153:18: 153:31}>::new(move _11) -> [return: bb9, unwind: bb13];
    }

    bb6: {
        _20 = deref_copy ((*_1).6: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>);
        (*_20) = move _8;
        _9 = Box::<{closure@crates/core/main.rs:149:33: 149:41}>::new(const ZeroSized: {closure@crates/core/main.rs:149:33: 149:41}) -> [return: bb8, unwind continue];
    }

    bb7 (cleanup): {
        _21 = deref_copy ((*_1).6: &mut std::option::Option<std::boxed::Box<dyn std::error::Error>>);
        (*_21) = move _8;
        goto -> bb11;
    }

    bb8: {
        _0 = move _9 as std::boxed::Box<dyn std::ops::FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> ignore::WalkState + std::marker::Send> (PointerCoercion(Unsize));
        _23 = const false;
        goto -> bb10;
    }

    bb9: {
        _0 = move _10 as std::boxed::Box<dyn std::ops::FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> ignore::WalkState + std::marker::Send> (PointerCoercion(Unsize));
        _23 = const false;
        goto -> bb10;
    }

    bb10: {
        return;
    }

    bb11 (cleanup): {
        resume;
    }

    bb12 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb13 (cleanup): {
        switchInt(_23) -> [0: bb11, otherwise: bb12];
    }
}

fn search_parallel::{closure#0}::{closure#0}(_1: &mut {closure@crates/core/main.rs:149:33: 149:41}, _2: std::result::Result<ignore::DirEntry, ignore::Error>) -> WalkState {
    let mut _0: ignore::WalkState;

    bb0: {
        _0 = Quit;
        drop(_2) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn search_parallel::{closure#0}::{closure#1}(_1: &mut {closure@crates/core/main.rs:153:18: 153:31}, _2: std::result::Result<ignore::DirEntry, ignore::Error>) -> WalkState {
    debug result => _2;
    debug subject_builder => ((*_1).0: &subject::SubjectBuilder);
    debug searched => ((*_1).1: &std::sync::atomic::AtomicBool);
    debug searcher => ((*_1).2: search::SearchWorker<termcolor::Buffer>);
    debug matched => ((*_1).3: &std::sync::atomic::AtomicBool);
    debug stats => ((*_1).4: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>);
    debug bufwtr => ((*_1).5: &termcolor::BufferWriter);
    debug quit_after_match => ((*_1).6: bool);
    let mut _0: ignore::WalkState;
    let _3: subject::Subject;
    let mut _4: std::option::Option<subject::Subject>;
    let mut _5: isize;
    let _6: subject::Subject;
    let _7: ();
    let mut _8: std::sync::atomic::Ordering;
    let _9: ();
    let mut _10: &mut termcolor::Buffer;
    let mut _11: &mut search::Printer<termcolor::Buffer>;
    let mut _12: &mut search::SearchWorker<termcolor::Buffer>;
    let mut _14: std::result::Result<search::SearchResult, std::io::Error>;
    let mut _15: &mut search::SearchWorker<termcolor::Buffer>;
    let _16: &subject::Subject;
    let mut _17: isize;
    let _20: ();
    let mut _21: bool;
    let _22: ();
    let mut _23: std::fmt::Arguments<'_>;
    let mut _24: &[&str];
    let mut _25: &[core::fmt::rt::Argument<'_>];
    let _26: &[core::fmt::rt::Argument<'_>; 2];
    let _27: [core::fmt::rt::Argument<'_>; 2];
    let mut _28: core::fmt::rt::Argument<'_>;
    let _29: &std::path::Display<'_>;
    let _30: std::path::Display<'_>;
    let _31: &std::path::Path;
    let mut _32: &subject::Subject;
    let mut _33: core::fmt::rt::Argument<'_>;
    let _34: &std::io::Error;
    let mut _35: bool;
    let mut _36: &search::SearchResult;
    let _37: ();
    let mut _38: std::sync::atomic::Ordering;
    let mut _39: isize;
    let mut _42: std::result::Result<std::sync::MutexGuard<'_, grep::grep_printer::Stats>, std::sync::PoisonError<std::sync::MutexGuard<'_, grep::grep_printer::Stats>>>;
    let _43: ();
    let mut _44: &mut grep::grep_printer::Stats;
    let mut _45: &mut std::sync::MutexGuard<'_, grep::grep_printer::Stats>;
    let mut _46: &grep::grep_printer::Stats;
    let mut _47: std::option::Option<&grep::grep_printer::Stats>;
    let mut _48: &search::SearchResult;
    let mut _49: std::result::Result<(), std::io::Error>;
    let mut _50: &termcolor::Buffer;
    let _51: &mut termcolor::Buffer;
    let mut _52: &mut search::Printer<termcolor::Buffer>;
    let mut _53: &mut search::SearchWorker<termcolor::Buffer>;
    let mut _54: isize;
    let mut _56: bool;
    let mut _57: &std::io::ErrorKind;
    let _58: std::io::ErrorKind;
    let mut _59: &std::io::Error;
    let _60: ();
    let mut _61: bool;
    let _62: ();
    let mut _63: std::fmt::Arguments<'_>;
    let mut _64: &[&str];
    let mut _65: &[core::fmt::rt::Argument<'_>];
    let _66: &[core::fmt::rt::Argument<'_>; 2];
    let _67: [core::fmt::rt::Argument<'_>; 2];
    let mut _68: core::fmt::rt::Argument<'_>;
    let _69: &std::path::Display<'_>;
    let _70: std::path::Display<'_>;
    let _71: &std::path::Path;
    let mut _72: &subject::Subject;
    let mut _73: core::fmt::rt::Argument<'_>;
    let _74: &std::io::Error;
    let mut _75: bool;
    let mut _76: std::sync::atomic::Ordering;
    let mut _77: bool;
    let mut _81: &subject::SubjectBuilder;
    let mut _82: &std::sync::atomic::AtomicBool;
    let mut _83: &std::sync::atomic::AtomicBool;
    let mut _84: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>;
    let mut _85: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>;
    let mut _86: &termcolor::BufferWriter;
    let mut _87: &std::sync::atomic::AtomicBool;
    let mut _88: bool;
    let mut _89: isize;
    scope 1 {
        debug subject => _3;
        let _13: search::SearchResult;
        let _18: search::SearchResult;
        let _19: std::io::Error;
        scope 3 {
            debug search_result => _13;
            scope 6 {
                debug locked_stats => _40;
                let _40: &std::sync::Mutex<grep::grep_printer::Stats>;
                let mut _41: std::sync::MutexGuard<'_, grep::grep_printer::Stats>;
                scope 7 {
                    debug stats => _41;
                }
            }
            scope 8 {
                debug err => _55;
                let _55: std::io::Error;
                let mut _79: &[&str; 3];
                let mut _80: &std::io::ErrorKind;
            }
        }
        scope 4 {
            debug search_result => _18;
        }
        scope 5 {
            debug err => _19;
            let mut _78: &[&str; 3];
        }
    }
    scope 2 {
        debug subject => _6;
    }

    bb0: {
        _88 = const false;
        _81 = deref_copy ((*_1).0: &subject::SubjectBuilder);
        _4 = SubjectBuilder::build_from_result(_81, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = ignore::WalkState::Continue;
        goto -> bb56;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = move ((_4 as Some).0: subject::Subject);
        _3 = move _6;
        _82 = deref_copy ((*_1).1: &std::sync::atomic::AtomicBool);
        _8 = SeqCst;
        _7 = AtomicBool::store(_82, const true, move _8) -> [return: bb5, unwind: bb60];
    }

    bb5: {
        _12 = &mut ((*_1).2: search::SearchWorker<termcolor::Buffer>);
        _11 = SearchWorker::<Buffer>::printer(move _12) -> [return: bb6, unwind: bb60];
    }

    bb6: {
        _10 = Printer::<Buffer>::get_mut(_11) -> [return: bb7, unwind: bb60];
    }

    bb7: {
        _9 = Buffer::clear(_10) -> [return: bb8, unwind: bb60];
    }

    bb8: {
        _15 = &mut ((*_1).2: search::SearchWorker<termcolor::Buffer>);
        _16 = &_3;
        _14 = SearchWorker::<Buffer>::search(move _15, _16) -> [return: bb9, unwind: bb60];
    }

    bb9: {
        _17 = discriminant(_14);
        switchInt(move _17) -> [0: bb11, 1: bb10, otherwise: bb3];
    }

    bb10: {
        _19 = move ((_14 as Err).0: std::io::Error);
        _20 = set_errored() -> [return: bb12, unwind: bb59];
    }

    bb11: {
        _18 = move ((_14 as Ok).0: search::SearchResult);
        _13 = move _18;
        _36 = &_13;
        _35 = SearchResult::has_match(move _36) -> [return: bb21, unwind: bb60];
    }

    bb12: {
        _21 = messages() -> [return: bb13, unwind: bb59];
    }

    bb13: {
        switchInt(move _21) -> [0: bb20, otherwise: bb14];
    }

    bb14: {
        _78 = const _;
        _24 = _78 as &[&str] (PointerCoercion(Unsize));
        _32 = &_3;
        _31 = Subject::path(move _32) -> [return: bb15, unwind: bb59];
    }

    bb15: {
        _30 = Path::display(_31) -> [return: bb16, unwind: bb59];
    }

    bb16: {
        _29 = &_30;
        _28 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_29) -> [return: bb17, unwind: bb59];
    }

    bb17: {
        _34 = &_19;
        _33 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_34) -> [return: bb18, unwind: bb59];
    }

    bb18: {
        _27 = [move _28, move _33];
        _26 = &_27;
        _25 = _26 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _23 = Arguments::<'_>::new_v1(move _24, move _25) -> [return: bb19, unwind: bb59];
    }

    bb19: {
        _22 = _eprint(move _23) -> [return: bb66, unwind: bb59];
    }

    bb20: {
        _0 = ignore::WalkState::Continue;
        drop(_19) -> [return: bb55, unwind: bb60];
    }

    bb21: {
        switchInt(move _35) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        _83 = deref_copy ((*_1).3: &std::sync::atomic::AtomicBool);
        _38 = SeqCst;
        _37 = AtomicBool::store(_83, const true, move _38) -> [return: bb67, unwind: bb60];
    }

    bb23: {
        _84 = deref_copy ((*_1).4: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>);
        _39 = discriminant((*_84));
        switchInt(move _39) -> [1: bb24, otherwise: bb31];
    }

    bb24: {
        _85 = deref_copy ((*_1).4: &std::option::Option<std::sync::Mutex<grep::grep_printer::Stats>>);
        _40 = &(((*_85) as Some).0: std::sync::Mutex<grep::grep_printer::Stats>);
        _42 = Mutex::<Stats>::lock(_40) -> [return: bb25, unwind: bb60];
    }

    bb25: {
        _41 = std::result::Result::<MutexGuard<'_, Stats>, PoisonError<MutexGuard<'_, Stats>>>::unwrap(move _42) -> [return: bb26, unwind: bb60];
    }

    bb26: {
        _45 = &mut _41;
        _44 = <MutexGuard<'_, Stats> as DerefMut>::deref_mut(move _45) -> [return: bb27, unwind: bb58];
    }

    bb27: {
        _48 = &_13;
        _47 = SearchResult::stats(move _48) -> [return: bb28, unwind: bb58];
    }

    bb28: {
        _46 = Option::<&Stats>::unwrap(move _47) -> [return: bb29, unwind: bb58];
    }

    bb29: {
        _43 = <Stats as AddAssign<&Stats>>::add_assign(_44, move _46) -> [return: bb30, unwind: bb58];
    }

    bb30: {
        drop(_41) -> [return: bb31, unwind: bb60];
    }

    bb31: {
        _86 = deref_copy ((*_1).5: &termcolor::BufferWriter);
        _53 = &mut ((*_1).2: search::SearchWorker<termcolor::Buffer>);
        _52 = SearchWorker::<Buffer>::printer(move _53) -> [return: bb32, unwind: bb60];
    }

    bb32: {
        _51 = Printer::<Buffer>::get_mut(_52) -> [return: bb33, unwind: bb60];
    }

    bb33: {
        _50 = &(*_51);
        _49 = BufferWriter::print(_86, move _50) -> [return: bb34, unwind: bb60];
    }

    bb34: {
        _88 = const true;
        _54 = discriminant(_49);
        switchInt(move _54) -> [1: bb35, otherwise: bb65];
    }

    bb35: {
        _88 = const false;
        _55 = move ((_49 as Err).0: std::io::Error);
        _59 = &_55;
        _58 = std::io::Error::kind(move _59) -> [return: bb36, unwind: bb57];
    }

    bb36: {
        _57 = &_58;
        _80 = const _;
        _56 = <std::io::ErrorKind as PartialEq>::eq(move _57, _80) -> [return: bb37, unwind: bb57];
    }

    bb37: {
        switchInt(move _56) -> [0: bb39, otherwise: bb38];
    }

    bb38: {
        _0 = Quit;
        drop(_55) -> [return: bb54, unwind: bb60];
    }

    bb39: {
        _60 = set_errored() -> [return: bb40, unwind: bb57];
    }

    bb40: {
        _61 = messages() -> [return: bb41, unwind: bb57];
    }

    bb41: {
        switchInt(move _61) -> [0: bb48, otherwise: bb42];
    }

    bb42: {
        _79 = const _;
        _64 = _79 as &[&str] (PointerCoercion(Unsize));
        _72 = &_3;
        _71 = Subject::path(move _72) -> [return: bb43, unwind: bb57];
    }

    bb43: {
        _70 = Path::display(_71) -> [return: bb44, unwind: bb57];
    }

    bb44: {
        _69 = &_70;
        _68 = core::fmt::rt::Argument::<'_>::new_display::<std::path::Display<'_>>(_69) -> [return: bb45, unwind: bb57];
    }

    bb45: {
        _74 = &_55;
        _73 = core::fmt::rt::Argument::<'_>::new_display::<std::io::Error>(_74) -> [return: bb46, unwind: bb57];
    }

    bb46: {
        _67 = [move _68, move _73];
        _66 = &_67;
        _65 = _66 as &[core::fmt::rt::Argument<'_>] (PointerCoercion(Unsize));
        _63 = Arguments::<'_>::new_v1(move _64, move _65) -> [return: bb47, unwind: bb57];
    }

    bb47: {
        _62 = _eprint(move _63) -> [return: bb68, unwind: bb57];
    }

    bb48: {
        drop(_55) -> [return: bb65, unwind: bb60];
    }

    bb49: {
        switchInt(move _75) -> [0: bb52, otherwise: bb50];
    }

    bb50: {
        _77 = ((*_1).6: bool);
        switchInt(move _77) -> [0: bb52, otherwise: bb51];
    }

    bb51: {
        _0 = Quit;
        goto -> bb53;
    }

    bb52: {
        _0 = ignore::WalkState::Continue;
        goto -> bb53;
    }

    bb53: {
        drop(_3) -> [return: bb56, unwind continue];
    }

    bb54: {
        _88 = const false;
        goto -> bb55;
    }

    bb55: {
        drop(_3) -> [return: bb56, unwind continue];
    }

    bb56: {
        return;
    }

    bb57 (cleanup): {
        drop(_55) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb58 (cleanup): {
        drop(_41) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb59 (cleanup): {
        drop(_19) -> [return: bb60, unwind terminate(cleanup)];
    }

    bb60 (cleanup): {
        drop(_3) -> [return: bb61, unwind terminate(cleanup)];
    }

    bb61 (cleanup): {
        resume;
    }

    bb62: {
        _88 = const false;
        _87 = deref_copy ((*_1).3: &std::sync::atomic::AtomicBool);
        _76 = SeqCst;
        _75 = AtomicBool::load(_87, move _76) -> [return: bb49, unwind: bb60];
    }

    bb63: {
        switchInt(_88) -> [0: bb62, otherwise: bb64];
    }

    bb64: {
        drop(((_49 as Err).0: std::io::Error)) -> [return: bb62, unwind: bb60];
    }

    bb65: {
        _89 = discriminant(_49);
        switchInt(move _89) -> [1: bb63, otherwise: bb62];
    }

    bb66: {
        goto -> bb20;
    }

    bb67: {
        goto -> bb23;
    }

    bb68: {
        goto -> bb48;
    }
}

promoted[0] in search_parallel::{closure#0}::{closure#1}: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[1] in search_parallel::{closure#0}::{closure#1}: &[&str; 3] = {
    let mut _0: &[&str; 3];
    let mut _1: [&str; 3];

    bb0: {
        _1 = [const "", const ": ", const "\n"];
        _0 = &_1;
        return;
    }
}

promoted[2] in search_parallel::{closure#0}::{closure#1}: &std::io::ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = BrokenPipe;
        _0 = &_1;
        return;
    }
}

fn eprint_nothing_searched() -> () {
    let mut _0: ();
    let _1: ();
    let mut _2: bool;
    let _3: ();
    let mut _4: std::fmt::Arguments<'_>;
    let mut _5: &[&str];
    let mut _6: &[&str; 1];

    bb0: {
        _1 = set_errored() -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = messages() -> [return: bb2, unwind continue];
    }

    bb2: {
        switchInt(move _2) -> [0: bb5, otherwise: bb3];
    }

    bb3: {
        _6 = const _;
        _5 = _6 as &[&str] (PointerCoercion(Unsize));
        _4 = Arguments::<'_>::new_const(move _5) -> [return: bb4, unwind continue];
    }

    bb4: {
        _3 = _eprint(move _4) -> [return: bb5, unwind continue];
    }

    bb5: {
        return;
    }
}

promoted[0] in eprint_nothing_searched: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "No files were searched, which means ripgrep probably applied a filter you didn't expect.\nRunning with --debug will show why files are being skipped.\n"];
        _0 = &_1;
        return;
    }
}

fn files(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, bool>;
    let mut _3: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _4: isize;
    let _5: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _6: bool;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, path_printer::PathPrinter<grep::grep_cli::StandardStream>>;
    let mut _11: std::result::Result<path_printer::PathPrinter<grep::grep_cli::StandardStream>, std::boxed::Box<dyn std::error::Error>>;
    let mut _12: grep::grep_cli::StandardStream;
    let mut _13: isize;
    let mut _16: ignore::Walk;
    let mut _17: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::Walk>;
    let mut _18: std::result::Result<ignore::Walk, std::boxed::Box<dyn std::error::Error>>;
    let mut _19: isize;
    let mut _23: std::option::Option<std::result::Result<ignore::DirEntry, ignore::Error>>;
    let mut _24: &mut ignore::Walk;
    let mut _25: isize;
    let mut _28: std::option::Option<subject::Subject>;
    let mut _29: &subject::SubjectBuilder;
    let mut _30: isize;
    let mut _32: std::result::Result<(), std::io::Error>;
    let mut _33: &mut path_printer::PathPrinter<grep::grep_cli::StandardStream>;
    let _34: &std::path::Path;
    let mut _35: &subject::Subject;
    let mut _36: isize;
    let mut _38: bool;
    let mut _39: &std::io::ErrorKind;
    let _40: std::io::ErrorKind;
    let mut _41: &std::io::Error;
    let mut _42: std::boxed::Box<dyn std::error::Error>;
    let mut _43: std::io::Error;
    let mut _44: bool;
    let mut _46: bool;
    let mut _47: bool;
    let mut _48: isize;
    scope 1 {
        debug quit_after_match => _6;
        let _7: subject::SubjectBuilder;
        scope 6 {
            debug subject_builder => _7;
            let mut _8: bool;
            scope 7 {
                debug matched => _8;
                let mut _9: path_printer::PathPrinter<grep::grep_cli::StandardStream>;
                let _14: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                let _15: path_printer::PathPrinter<grep::grep_cli::StandardStream>;
                scope 8 {
                    debug path_printer => _9;
                    let _20: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                    let _21: ignore::Walk;
                    let mut _22: ignore::Walk;
                    scope 13 {
                        debug residual => _20;
                        scope 14 {
                        }
                    }
                    scope 15 {
                        debug val => _21;
                        scope 16 {
                        }
                    }
                    scope 17 {
                        debug iter => _22;
                        let _26: std::result::Result<ignore::DirEntry, ignore::Error>;
                        scope 18 {
                            debug result => _26;
                            let _27: subject::Subject;
                            let _31: subject::Subject;
                            scope 19 {
                                debug subject => _27;
                                scope 21 {
                                    debug err => _37;
                                    let _37: std::io::Error;
                                    let mut _45: &std::io::ErrorKind;
                                }
                            }
                            scope 20 {
                                debug subject => _31;
                            }
                        }
                    }
                }
                scope 9 {
                    debug residual => _14;
                    scope 10 {
                    }
                }
                scope 11 {
                    debug val => _15;
                    scope 12 {
                    }
                }
            }
        }
    }
    scope 2 {
        debug residual => _5;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _6;
        scope 5 {
        }
    }

    bb0: {
        _46 = const false;
        _47 = const false;
        _3 = args::Args::quit_after_match(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _2 = <std::result::Result<bool, Box<dyn std::error::Error>> as Try>::branch(move _3) -> [return: bb2, unwind continue];
    }

    bb2: {
        _4 = discriminant(_2);
        switchInt(move _4) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _6 = ((_2 as Continue).0: bool);
        _7 = args::Args::subject_builder(_1) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _5 = move ((_2 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _5) -> [return: bb39, unwind continue];
    }

    bb6: {
        _8 = const false;
        _12 = args::Args::stdout(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = args::Args::path_printer::<grep::grep_cli::StandardStream>(_1, move _12) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = <std::result::Result<PathPrinter<grep::grep_cli::StandardStream>, Box<dyn std::error::Error>> as Try>::branch(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb4];
    }

    bb10: {
        _15 = move ((_10 as Continue).0: path_printer::PathPrinter<grep::grep_cli::StandardStream>);
        _9 = move _15;
        _18 = args::Args::walker(_1) -> [return: bb12, unwind: bb43];
    }

    bb11: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _14) -> [return: bb39, unwind continue];
    }

    bb12: {
        _17 = <std::result::Result<Walk, Box<dyn std::error::Error>> as Try>::branch(move _18) -> [return: bb13, unwind: bb43];
    }

    bb13: {
        _19 = discriminant(_17);
        switchInt(move _19) -> [0: bb14, 1: bb15, otherwise: bb4];
    }

    bb14: {
        _21 = move ((_17 as Continue).0: ignore::Walk);
        _16 = <Walk as IntoIterator>::into_iter(move _21) -> [return: bb16, unwind: bb43];
    }

    bb15: {
        _20 = move ((_17 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _20) -> [return: bb52, unwind: bb43];
    }

    bb16: {
        _22 = move _16;
        goto -> bb17;
    }

    bb17: {
        _24 = &mut _22;
        _23 = <Walk as Iterator>::next(_24) -> [return: bb18, unwind: bb42];
    }

    bb18: {
        _25 = discriminant(_23);
        switchInt(move _25) -> [0: bb45, 1: bb19, otherwise: bb4];
    }

    bb19: {
        _26 = move ((_23 as Some).0: std::result::Result<ignore::DirEntry, ignore::Error>);
        _29 = &_7;
        _28 = SubjectBuilder::build_from_result(move _29, move _26) -> [return: bb20, unwind: bb42];
    }

    bb20: {
        _30 = discriminant(_28);
        switchInt(move _30) -> [0: bb17, 1: bb21, otherwise: bb4];
    }

    bb21: {
        _31 = move ((_28 as Some).0: subject::Subject);
        _27 = move _31;
        _8 = const true;
        switchInt(_6) -> [0: bb23, otherwise: bb22];
    }

    bb22: {
        drop(_27) -> [return: bb45, unwind: bb42];
    }

    bb23: {
        _33 = &mut _9;
        _35 = &_27;
        _34 = Subject::path(move _35) -> [return: bb24, unwind: bb41];
    }

    bb24: {
        _32 = PathPrinter::<grep::grep_cli::StandardStream>::write_path(move _33, _34) -> [return: bb25, unwind: bb41];
    }

    bb25: {
        _47 = const true;
        _36 = discriminant(_32);
        switchInt(move _36) -> [1: bb26, otherwise: bb32];
    }

    bb26: {
        _47 = const false;
        _46 = const true;
        _37 = move ((_32 as Err).0: std::io::Error);
        _41 = &_37;
        _40 = std::io::Error::kind(move _41) -> [return: bb27, unwind: bb48];
    }

    bb27: {
        _39 = &_40;
        _45 = const _;
        _38 = <std::io::ErrorKind as PartialEq>::eq(move _39, _45) -> [return: bb28, unwind: bb48];
    }

    bb28: {
        switchInt(move _38) -> [0: bb30, otherwise: bb29];
    }

    bb29: {
        drop(_37) -> [return: bb35, unwind: bb40];
    }

    bb30: {
        _46 = const false;
        _43 = move _37;
        _42 = <std::io::Error as Into<Box<dyn std::error::Error>>>::into(move _43) -> [return: bb31, unwind: bb48];
    }

    bb31: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Err(move _42);
        _46 = const false;
        drop(_27) -> [return: bb38, unwind: bb51];
    }

    bb32: {
        drop(_27) -> [return: bb33, unwind: bb51];
    }

    bb33: {
        drop(_32) -> [return: bb34, unwind: bb42];
    }

    bb34: {
        _47 = const false;
        goto -> bb17;
    }

    bb35: {
        _46 = const false;
        drop(_27) -> [return: bb36, unwind: bb51];
    }

    bb36: {
        _47 = const false;
        goto -> bb45;
    }

    bb37: {
        _44 = _8;
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _44);
        drop(_9) -> [return: bb39, unwind continue];
    }

    bb38: {
        _47 = const false;
        drop(_22) -> [return: bb46, unwind: bb43];
    }

    bb39: {
        return;
    }

    bb40 (cleanup): {
        drop(_27) -> [return: bb51, unwind terminate(cleanup)];
    }

    bb41 (cleanup): {
        drop(_27) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb42 (cleanup): {
        drop(_22) -> [return: bb43, unwind terminate(cleanup)];
    }

    bb43 (cleanup): {
        drop(_9) -> [return: bb44, unwind terminate(cleanup)];
    }

    bb44 (cleanup): {
        resume;
    }

    bb45: {
        drop(_22) -> [return: bb37, unwind: bb43];
    }

    bb46: {
        drop(_9) -> [return: bb39, unwind continue];
    }

    bb47 (cleanup): {
        drop(_37) -> [return: bb40, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        switchInt(_46) -> [0: bb40, otherwise: bb47];
    }

    bb49 (cleanup): {
        switchInt(_47) -> [0: bb42, otherwise: bb50];
    }

    bb50 (cleanup): {
        drop(((_32 as Err).0: std::io::Error)) -> [return: bb42, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        _48 = discriminant(_32);
        switchInt(move _48) -> [1: bb49, otherwise: bb42];
    }

    bb52: {
        goto -> bb46;
    }
}

promoted[0] in files: &std::io::ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = BrokenPipe;
        _0 = &_1;
        return;
    }
}

fn files_parallel(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let _2: bool;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, bool>;
    let mut _4: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _5: isize;
    let _6: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
    let _7: bool;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, path_printer::PathPrinter<grep::grep_cli::StandardStream>>;
    let mut _11: std::result::Result<path_printer::PathPrinter<grep::grep_cli::StandardStream>, std::boxed::Box<dyn std::error::Error>>;
    let mut _12: grep::grep_cli::StandardStream;
    let mut _13: isize;
    let mut _19: (std::sync::mpsc::Sender<subject::Subject>, std::sync::mpsc::Receiver<subject::Subject>);
    let mut _21: {closure@crates/core/main.rs:258:38: 258:63};
    let _22: ();
    let mut _23: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, ignore::WalkParallel>;
    let mut _24: std::result::Result<ignore::WalkParallel, std::boxed::Box<dyn std::error::Error>>;
    let mut _25: isize;
    let mut _28: {closure@crates/core/main.rs:264:33: 264:35};
    let mut _29: &subject::SubjectBuilder;
    let mut _30: &std::sync::atomic::AtomicBool;
    let mut _31: &std::sync::mpsc::Sender<subject::Subject>;
    let mut _32: &bool;
    let _33: ();
    let mut _34: std::sync::mpsc::Sender<subject::Subject>;
    let mut _35: std::result::Result<(), std::io::Error>;
    let mut _36: std::result::Result<std::result::Result<(), std::io::Error>, std::boxed::Box<dyn std::any::Any + std::marker::Send>>;
    let mut _37: std::thread::JoinHandle<std::result::Result<(), std::io::Error>>;
    let mut _38: isize;
    let mut _40: bool;
    let mut _41: &std::io::ErrorKind;
    let _42: std::io::ErrorKind;
    let mut _43: &std::io::Error;
    let mut _44: std::boxed::Box<dyn std::error::Error>;
    let mut _45: std::io::Error;
    let mut _46: bool;
    let mut _47: &std::sync::atomic::AtomicBool;
    let mut _48: std::sync::atomic::Ordering;
    let mut _50: bool;
    let mut _51: bool;
    let mut _52: bool;
    let mut _53: bool;
    let mut _54: bool;
    let mut _55: bool;
    let mut _56: isize;
    scope 1 {
        debug quit_after_match => _2;
        let _8: subject::SubjectBuilder;
        scope 6 {
            debug subject_builder => _8;
            let mut _9: path_printer::PathPrinter<grep::grep_cli::StandardStream>;
            let _14: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _15: path_printer::PathPrinter<grep::grep_cli::StandardStream>;
            scope 7 {
                debug path_printer => _9;
                let _16: std::sync::atomic::AtomicBool;
                scope 12 {
                    debug matched => _16;
                    let _17: std::sync::mpsc::Sender<subject::Subject>;
                    let _18: std::sync::mpsc::Receiver<subject::Subject>;
                    scope 13 {
                        debug tx => _17;
                        debug rx => _18;
                        let _20: std::thread::JoinHandle<std::result::Result<(), std::io::Error>>;
                        scope 14 {
                            debug print_thread => _20;
                            let _26: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
                            let _27: ignore::WalkParallel;
                            scope 15 {
                                debug residual => _26;
                                scope 16 {
                                }
                            }
                            scope 17 {
                                debug val => _27;
                                scope 18 {
                                }
                            }
                            scope 19 {
                                debug err => _39;
                                let _39: std::io::Error;
                                let mut _49: &std::io::ErrorKind;
                            }
                        }
                    }
                }
            }
            scope 8 {
                debug residual => _14;
                scope 9 {
                }
            }
            scope 10 {
                debug val => _15;
                scope 11 {
                }
            }
        }
    }
    scope 2 {
        debug residual => _6;
        scope 3 {
        }
    }
    scope 4 {
        debug val => _7;
        scope 5 {
        }
    }

    bb0: {
        _55 = const false;
        _52 = const false;
        _54 = const false;
        _51 = const false;
        _53 = const false;
        _50 = const false;
        _4 = args::Args::quit_after_match(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _3 = <std::result::Result<bool, Box<dyn std::error::Error>> as Try>::branch(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _5 = discriminant(_3);
        switchInt(move _5) -> [0: bb3, 1: bb5, otherwise: bb4];
    }

    bb3: {
        _7 = ((_3 as Continue).0: bool);
        _2 = _7;
        _8 = args::Args::subject_builder(_1) -> [return: bb6, unwind continue];
    }

    bb4: {
        unreachable;
    }

    bb5: {
        _6 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _6) -> [return: bb34, unwind continue];
    }

    bb6: {
        _12 = args::Args::stdout(_1) -> [return: bb7, unwind continue];
    }

    bb7: {
        _11 = args::Args::path_printer::<grep::grep_cli::StandardStream>(_1, move _12) -> [return: bb8, unwind continue];
    }

    bb8: {
        _10 = <std::result::Result<PathPrinter<grep::grep_cli::StandardStream>, Box<dyn std::error::Error>> as Try>::branch(move _11) -> [return: bb9, unwind continue];
    }

    bb9: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb11, otherwise: bb4];
    }

    bb10: {
        _15 = move ((_10 as Continue).0: path_printer::PathPrinter<grep::grep_cli::StandardStream>);
        _55 = const true;
        _9 = move _15;
        _16 = AtomicBool::new(const false) -> [return: bb12, unwind: bb52];
    }

    bb11: {
        _14 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _14) -> [return: bb33, unwind continue];
    }

    bb12: {
        _19 = channel::<Subject>() -> [return: bb13, unwind: bb52];
    }

    bb13: {
        _52 = const true;
        _17 = move (_19.0: std::sync::mpsc::Sender<subject::Subject>);
        _54 = const true;
        _18 = move (_19.1: std::sync::mpsc::Receiver<subject::Subject>);
        _54 = const false;
        _55 = const false;
        _21 = {closure@crates/core/main.rs:258:38: 258:63} { rx: move _18, path_printer: move _9 };
        _20 = spawn::<{closure@crates/core/main.rs:258:38: 258:63}, std::result::Result<(), std::io::Error>>(move _21) -> [return: bb14, unwind: bb49];
    }

    bb14: {
        _51 = const true;
        _24 = args::Args::walker_parallel(_1) -> [return: bb15, unwind: bb47];
    }

    bb15: {
        _23 = <std::result::Result<WalkParallel, Box<dyn std::error::Error>> as Try>::branch(move _24) -> [return: bb16, unwind: bb47];
    }

    bb16: {
        _25 = discriminant(_23);
        switchInt(move _25) -> [0: bb17, 1: bb18, otherwise: bb4];
    }

    bb17: {
        _27 = move ((_23 as Continue).0: ignore::WalkParallel);
        _29 = &_8;
        _30 = &_16;
        _31 = &_17;
        _32 = &_2;
        _28 = {closure@crates/core/main.rs:264:33: 264:35} { subject_builder: move _29, matched: move _30, tx: move _31, quit_after_match: move _32 };
        _22 = WalkParallel::run::<'_, {closure@crates/core/main.rs:264:33: 264:35}>(move _27, move _28) -> [return: bb19, unwind: bb47];
    }

    bb18: {
        _26 = move ((_23 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _26) -> [return: bb53, unwind: bb47];
    }

    bb19: {
        _52 = const false;
        _34 = move _17;
        _33 = std::mem::drop::<Sender<Subject>>(move _34) -> [return: bb20, unwind: bb47];
    }

    bb20: {
        _51 = const false;
        _37 = move _20;
        _36 = JoinHandle::<std::result::Result<(), std::io::Error>>::join(move _37) -> [return: bb21, unwind: bb47];
    }

    bb21: {
        _35 = std::result::Result::<std::result::Result<(), std::io::Error>, Box<dyn Any + Send>>::unwrap(move _36) -> [return: bb22, unwind: bb47];
    }

    bb22: {
        _50 = const true;
        _38 = discriminant(_35);
        switchInt(move _38) -> [1: bb23, otherwise: bb40];
    }

    bb23: {
        _50 = const false;
        _53 = const true;
        _39 = move ((_35 as Err).0: std::io::Error);
        _43 = &_39;
        _42 = std::io::Error::kind(move _43) -> [return: bb24, unwind: bb45];
    }

    bb24: {
        _41 = &_42;
        _49 = const _;
        _40 = <std::io::ErrorKind as PartialEq>::ne(move _41, _49) -> [return: bb25, unwind: bb45];
    }

    bb25: {
        switchInt(move _40) -> [0: bb28, otherwise: bb26];
    }

    bb26: {
        _53 = const false;
        _45 = move _39;
        _44 = <std::io::Error as Into<Box<dyn std::error::Error>>>::into(move _45) -> [return: bb27, unwind: bb45];
    }

    bb27: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Err(move _44);
        _53 = const false;
        _50 = const false;
        goto -> bb42;
    }

    bb28: {
        drop(_39) -> [return: bb29, unwind: bb47];
    }

    bb29: {
        _53 = const false;
        goto -> bb40;
    }

    bb30: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _46);
        _51 = const false;
        _54 = const false;
        _52 = const false;
        _55 = const false;
        goto -> bb34;
    }

    bb31: {
        _51 = const false;
        _54 = const false;
        switchInt(_52) -> [0: bb32, otherwise: bb43];
    }

    bb32: {
        _52 = const false;
        goto -> bb33;
    }

    bb33: {
        _55 = const false;
        goto -> bb34;
    }

    bb34: {
        return;
    }

    bb35 (cleanup): {
        switchInt(_52) -> [0: bb52, otherwise: bb50];
    }

    bb36 (cleanup): {
        resume;
    }

    bb37: {
        _50 = const false;
        _47 = &_16;
        _48 = SeqCst;
        _46 = AtomicBool::load(move _47, move _48) -> [return: bb30, unwind: bb47];
    }

    bb38: {
        switchInt(_50) -> [0: bb37, otherwise: bb39];
    }

    bb39: {
        drop(((_35 as Err).0: std::io::Error)) -> [return: bb37, unwind: bb47];
    }

    bb40: {
        _56 = discriminant(_35);
        switchInt(move _56) -> [1: bb38, otherwise: bb37];
    }

    bb41: {
        drop(_20) -> [return: bb31, unwind: bb49];
    }

    bb42: {
        switchInt(_51) -> [0: bb31, otherwise: bb41];
    }

    bb43: {
        drop(_17) -> [return: bb32, unwind: bb52];
    }

    bb44 (cleanup): {
        drop(_39) -> [return: bb47, unwind terminate(cleanup)];
    }

    bb45 (cleanup): {
        switchInt(_53) -> [0: bb47, otherwise: bb44];
    }

    bb46 (cleanup): {
        drop(_20) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb47 (cleanup): {
        switchInt(_51) -> [0: bb49, otherwise: bb46];
    }

    bb48 (cleanup): {
        drop(_18) -> [return: bb35, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        switchInt(_54) -> [0: bb35, otherwise: bb48];
    }

    bb50 (cleanup): {
        drop(_17) -> [return: bb52, unwind terminate(cleanup)];
    }

    bb51 (cleanup): {
        drop(_9) -> [return: bb36, unwind terminate(cleanup)];
    }

    bb52 (cleanup): {
        switchInt(_55) -> [0: bb36, otherwise: bb51];
    }

    bb53: {
        goto -> bb42;
    }
}

promoted[0] in files_parallel: &std::io::ErrorKind = {
    let mut _0: &std::io::ErrorKind;
    let mut _1: std::io::ErrorKind;

    bb0: {
        _1 = BrokenPipe;
        _0 = &_1;
        return;
    }
}

fn files_parallel::{closure#0}(_1: {closure@crates/core/main.rs:258:38: 258:63}) -> std::result::Result<(), std::io::Error> {
    debug rx => (_1.0: std::sync::mpsc::Receiver<subject::Subject>);
    debug path_printer => (_1.1: path_printer::PathPrinter<grep::grep_cli::StandardStream>);
    let mut _0: std::result::Result<(), std::io::Error>;
    let mut _2: std::sync::mpsc::Iter<'_, subject::Subject>;
    let mut _3: std::sync::mpsc::Iter<'_, subject::Subject>;
    let mut _4: &std::sync::mpsc::Receiver<subject::Subject>;
    let mut _5: std::sync::mpsc::Iter<'_, subject::Subject>;
    let mut _6: std::option::Option<subject::Subject>;
    let mut _7: &mut std::sync::mpsc::Iter<'_, subject::Subject>;
    let mut _8: isize;
    let mut _10: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _11: std::result::Result<(), std::io::Error>;
    let mut _12: &mut path_printer::PathPrinter<grep::grep_cli::StandardStream>;
    let _13: &std::path::Path;
    let mut _14: &subject::Subject;
    let mut _15: isize;
    scope 1 {
        debug iter => _5;
        let _9: subject::Subject;
        scope 2 {
            debug subject => _9;
            let _16: std::result::Result<std::convert::Infallible, std::io::Error>;
            scope 3 {
                debug residual => _16;
                scope 4 {
                }
            }
            scope 5 {
                debug val => const ();
                scope 6 {
                }
            }
        }
    }

    bb0: {
        _4 = &(_1.0: std::sync::mpsc::Receiver<subject::Subject>);
        _3 = std::sync::mpsc::Receiver::<Subject>::iter(move _4) -> [return: bb1, unwind: bb17];
    }

    bb1: {
        _2 = <std::sync::mpsc::Iter<'_, Subject> as IntoIterator>::into_iter(move _3) -> [return: bb2, unwind: bb17];
    }

    bb2: {
        _5 = move _2;
        goto -> bb3;
    }

    bb3: {
        _7 = &mut _5;
        _6 = <std::sync::mpsc::Iter<'_, Subject> as Iterator>::next(_7) -> [return: bb4, unwind: bb17];
    }

    bb4: {
        _8 = discriminant(_6);
        switchInt(move _8) -> [0: bb7, 1: bb5, otherwise: bb6];
    }

    bb5: {
        _9 = move ((_6 as Some).0: subject::Subject);
        _12 = &mut (_1.1: path_printer::PathPrinter<grep::grep_cli::StandardStream>);
        _14 = &_9;
        _13 = Subject::path(move _14) -> [return: bb8, unwind: bb16];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _0 = std::result::Result::<(), std::io::Error>::Ok(const ());
        drop(_1) -> [return: bb15, unwind continue];
    }

    bb8: {
        _11 = PathPrinter::<grep::grep_cli::StandardStream>::write_path(move _12, _13) -> [return: bb9, unwind: bb16];
    }

    bb9: {
        _10 = <std::result::Result<(), std::io::Error> as Try>::branch(move _11) -> [return: bb10, unwind: bb16];
    }

    bb10: {
        _15 = discriminant(_10);
        switchInt(move _15) -> [0: bb11, 1: bb12, otherwise: bb6];
    }

    bb11: {
        drop(_9) -> [return: bb3, unwind: bb17];
    }

    bb12: {
        _16 = move ((_10 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<(), std::io::Error> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _16) -> [return: bb13, unwind: bb16];
    }

    bb13: {
        drop(_9) -> [return: bb14, unwind: bb17];
    }

    bb14: {
        drop(_1) -> [return: bb15, unwind continue];
    }

    bb15: {
        return;
    }

    bb16 (cleanup): {
        drop(_9) -> [return: bb17, unwind terminate(cleanup)];
    }

    bb17 (cleanup): {
        drop(_1) -> [return: bb18, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        resume;
    }
}

fn files_parallel::{closure#1}(_1: &mut {closure@crates/core/main.rs:264:33: 264:35}) -> Box<dyn FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> WalkState + Send> {
    debug subject_builder => (*((*_1).0: &subject::SubjectBuilder));
    debug matched => (*((*_1).1: &std::sync::atomic::AtomicBool));
    debug tx => (*((*_1).2: &std::sync::mpsc::Sender<subject::Subject>));
    debug quit_after_match => (*((*_1).3: &bool));
    let mut _0: std::boxed::Box<dyn std::ops::FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> ignore::WalkState + std::marker::Send>;
    let mut _3: std::boxed::Box<{closure@crates/core/main.rs:269:18: 269:31}>;
    let mut _4: {closure@crates/core/main.rs:269:18: 269:31};
    let mut _5: &subject::SubjectBuilder;
    let mut _6: &std::sync::atomic::AtomicBool;
    let mut _7: &std::sync::mpsc::Sender<subject::Subject>;
    let mut _8: &bool;
    scope 1 {
        debug subject_builder => _5;
        scope 2 {
            debug matched => _6;
            let _2: std::sync::mpsc::Sender<subject::Subject>;
            scope 3 {
                debug tx => _2;
            }
        }
    }

    bb0: {
        _5 = deref_copy ((*_1).0: &subject::SubjectBuilder);
        _6 = deref_copy ((*_1).1: &std::sync::atomic::AtomicBool);
        _7 = deref_copy ((*_1).2: &std::sync::mpsc::Sender<subject::Subject>);
        _2 = <Sender<Subject> as Clone>::clone(_7) -> [return: bb1, unwind continue];
    }

    bb1: {
        _8 = deref_copy ((*_1).3: &bool);
        _4 = {closure@crates/core/main.rs:269:18: 269:31} { subject_builder: _5, matched: _6, quit_after_match: (*_8), tx: move _2 };
        _3 = Box::<{closure@crates/core/main.rs:269:18: 269:31}>::new(move _4) -> [return: bb2, unwind continue];
    }

    bb2: {
        _0 = move _3 as std::boxed::Box<dyn std::ops::FnMut(std::result::Result<ignore::DirEntry, ignore::Error>) -> ignore::WalkState + std::marker::Send> (PointerCoercion(Unsize));
        return;
    }
}

fn files_parallel::{closure#1}::{closure#0}(_1: &mut {closure@crates/core/main.rs:269:18: 269:31}, _2: std::result::Result<ignore::DirEntry, ignore::Error>) -> WalkState {
    debug result => _2;
    debug subject_builder => ((*_1).0: &subject::SubjectBuilder);
    debug matched => ((*_1).1: &std::sync::atomic::AtomicBool);
    debug quit_after_match => ((*_1).2: bool);
    debug tx => ((*_1).3: std::sync::mpsc::Sender<subject::Subject>);
    let mut _0: ignore::WalkState;
    let _3: subject::Subject;
    let mut _4: std::option::Option<subject::Subject>;
    let mut _5: isize;
    let _6: subject::Subject;
    let _7: ();
    let mut _8: std::sync::atomic::Ordering;
    let mut _9: bool;
    let mut _10: std::result::Result<(), std::sync::mpsc::SendError<subject::Subject>>;
    let mut _11: &std::sync::mpsc::Sender<subject::Subject>;
    let mut _12: subject::Subject;
    let mut _13: isize;
    let mut _14: &subject::SubjectBuilder;
    let mut _15: &std::sync::atomic::AtomicBool;
    let mut _16: bool;
    scope 1 {
        debug subject => _3;
    }
    scope 2 {
        debug subject => _6;
    }

    bb0: {
        _16 = const false;
        _14 = deref_copy ((*_1).0: &subject::SubjectBuilder);
        _4 = SubjectBuilder::build_from_result(_14, move _2) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = discriminant(_4);
        switchInt(move _5) -> [0: bb2, 1: bb4, otherwise: bb3];
    }

    bb2: {
        _0 = ignore::WalkState::Continue;
        _16 = const false;
        goto -> bb14;
    }

    bb3: {
        unreachable;
    }

    bb4: {
        _6 = move ((_4 as Some).0: subject::Subject);
        _16 = const true;
        _3 = move _6;
        _15 = deref_copy ((*_1).1: &std::sync::atomic::AtomicBool);
        _8 = SeqCst;
        _7 = AtomicBool::store(_15, const true, move _8) -> [return: bb5, unwind: bb18];
    }

    bb5: {
        _9 = ((*_1).2: bool);
        switchInt(move _9) -> [0: bb7, otherwise: bb6];
    }

    bb6: {
        _0 = Quit;
        goto -> bb12;
    }

    bb7: {
        _11 = &((*_1).3: std::sync::mpsc::Sender<subject::Subject>);
        _16 = const false;
        _12 = move _3;
        _10 = Sender::<Subject>::send(move _11, move _12) -> [return: bb8, unwind: bb18];
    }

    bb8: {
        _13 = discriminant(_10);
        switchInt(move _13) -> [0: bb10, 1: bb9, otherwise: bb3];
    }

    bb9: {
        _0 = Quit;
        goto -> bb11;
    }

    bb10: {
        _0 = ignore::WalkState::Continue;
        goto -> bb11;
    }

    bb11: {
        drop(_10) -> [return: bb12, unwind: bb18];
    }

    bb12: {
        switchInt(_16) -> [0: bb13, otherwise: bb16];
    }

    bb13: {
        _16 = const false;
        goto -> bb14;
    }

    bb14: {
        return;
    }

    bb15 (cleanup): {
        resume;
    }

    bb16: {
        drop(_3) -> [return: bb13, unwind continue];
    }

    bb17 (cleanup): {
        drop(_3) -> [return: bb15, unwind terminate(cleanup)];
    }

    bb18 (cleanup): {
        switchInt(_16) -> [0: bb15, otherwise: bb17];
    }
}

fn types(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: i32;
    let mut _4: std::vec::IntoIter<ignore::types::FileTypeDef>;
    let mut _5: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>, std::vec::Vec<ignore::types::FileTypeDef>>;
    let mut _6: std::result::Result<std::vec::Vec<ignore::types::FileTypeDef>, std::boxed::Box<dyn std::error::Error>>;
    let mut _7: isize;
    let mut _11: std::option::Option<ignore::types::FileTypeDef>;
    let mut _12: &mut std::vec::IntoIter<ignore::types::FileTypeDef>;
    let mut _13: isize;
    let mut _15: (i32, bool);
    let mut _16: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _17: std::result::Result<(), std::io::Error>;
    let mut _18: &mut grep::grep_cli::StandardStream;
    let _19: &[u8];
    let _20: &str;
    let mut _21: &ignore::types::FileTypeDef;
    let mut _22: isize;
    let mut _24: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _25: std::result::Result<(), std::io::Error>;
    let mut _26: &mut grep::grep_cli::StandardStream;
    let mut _27: &[u8];
    let _28: &[u8; 2];
    let mut _29: isize;
    let mut _32: std::slice::Iter<'_, std::string::String>;
    let mut _33: &[std::string::String];
    let mut _34: &ignore::types::FileTypeDef;
    let mut _36: std::option::Option<&std::string::String>;
    let mut _37: &mut std::slice::Iter<'_, std::string::String>;
    let mut _38: isize;
    let mut _40: bool;
    let mut _41: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _42: std::result::Result<(), std::io::Error>;
    let mut _43: &mut grep::grep_cli::StandardStream;
    let mut _44: &[u8];
    let _45: &[u8; 2];
    let mut _46: isize;
    let mut _48: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _49: std::result::Result<(), std::io::Error>;
    let mut _50: &mut grep::grep_cli::StandardStream;
    let _51: &[u8];
    let mut _52: isize;
    let mut _54: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _55: std::result::Result<(), std::io::Error>;
    let mut _56: &mut grep::grep_cli::StandardStream;
    let mut _57: &[u8];
    let _58: &[u8; 1];
    let mut _59: isize;
    let mut _61: bool;
    let mut _62: i32;
    scope 1 {
        debug count => _2;
        let mut _3: grep::grep_cli::StandardStream;
        scope 2 {
            debug stdout => _3;
            let _8: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>;
            let _9: std::vec::Vec<ignore::types::FileTypeDef>;
            let mut _10: std::vec::IntoIter<ignore::types::FileTypeDef>;
            scope 3 {
                debug residual => _8;
                scope 4 {
                }
            }
            scope 5 {
                debug val => _9;
                scope 6 {
                }
            }
            scope 7 {
                debug iter => _10;
                let _14: ignore::types::FileTypeDef;
                scope 8 {
                    debug def => _14;
                    let _23: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let _30: std::result::Result<std::convert::Infallible, std::io::Error>;
                    let mut _31: bool;
                    scope 9 {
                        debug residual => _23;
                        scope 10 {
                        }
                    }
                    scope 11 {
                        debug val => const ();
                        scope 12 {
                        }
                    }
                    scope 13 {
                        debug residual => _30;
                        scope 14 {
                        }
                    }
                    scope 15 {
                        debug val => const ();
                        scope 16 {
                        }
                    }
                    scope 17 {
                        debug first => _31;
                        let mut _35: std::slice::Iter<'_, std::string::String>;
                        let _60: std::result::Result<std::convert::Infallible, std::io::Error>;
                        scope 18 {
                            debug iter => _35;
                            let _39: &std::string::String;
                            scope 19 {
                                debug glob => _39;
                                let _47: std::result::Result<std::convert::Infallible, std::io::Error>;
                                let _53: std::result::Result<std::convert::Infallible, std::io::Error>;
                                scope 20 {
                                    debug residual => _47;
                                    scope 21 {
                                    }
                                }
                                scope 22 {
                                    debug val => const ();
                                    scope 23 {
                                    }
                                }
                                scope 24 {
                                    debug residual => _53;
                                    scope 25 {
                                    }
                                }
                                scope 26 {
                                    debug val => const ();
                                    scope 27 {
                                    }
                                }
                            }
                        }
                        scope 28 {
                            debug residual => _60;
                            scope 29 {
                            }
                        }
                        scope 30 {
                            debug val => const ();
                            scope 31 {
                            }
                        }
                    }
                }
            }
        }
    }

    bb0: {
        _2 = const 0_i32;
        _3 = args::Args::stdout(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _6 = args::Args::type_defs(_1) -> [return: bb2, unwind: bb49];
    }

    bb2: {
        _5 = <std::result::Result<Vec<FileTypeDef>, Box<dyn std::error::Error>> as Try>::branch(move _6) -> [return: bb3, unwind: bb49];
    }

    bb3: {
        _7 = discriminant(_5);
        switchInt(move _7) -> [0: bb4, 1: bb6, otherwise: bb5];
    }

    bb4: {
        _9 = move ((_5 as Continue).0: std::vec::Vec<ignore::types::FileTypeDef>);
        _4 = <Vec<FileTypeDef> as IntoIterator>::into_iter(move _9) -> [return: bb7, unwind: bb49];
    }

    bb5: {
        unreachable;
    }

    bb6: {
        _8 = move ((_5 as Break).0: std::result::Result<std::convert::Infallible, std::boxed::Box<dyn std::error::Error>>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, Box<dyn std::error::Error>>>>::from_residual(move _8) -> [return: bb52, unwind: bb49];
    }

    bb7: {
        _10 = move _4;
        goto -> bb8;
    }

    bb8: {
        _12 = &mut _10;
        _11 = <std::vec::IntoIter<FileTypeDef> as Iterator>::next(_12) -> [return: bb9, unwind: bb48];
    }

    bb9: {
        _13 = discriminant(_11);
        switchInt(move _13) -> [0: bb11, 1: bb10, otherwise: bb5];
    }

    bb10: {
        _14 = move ((_11 as Some).0: ignore::types::FileTypeDef);
        _15 = CheckedAdd(_2, const 1_i32);
        assert(!move (_15.1: bool), "attempt to compute `{} + {}`, which would overflow", _2, const 1_i32) -> [success: bb12, unwind: bb47];
    }

    bb11: {
        drop(_10) -> [return: bb43, unwind: bb49];
    }

    bb12: {
        _2 = move (_15.0: i32);
        _18 = &mut _3;
        _21 = &_14;
        _20 = FileTypeDef::name(move _21) -> [return: bb13, unwind: bb47];
    }

    bb13: {
        _19 = core::str::<impl str>::as_bytes(_20) -> [return: bb14, unwind: bb47];
    }

    bb14: {
        _17 = <grep::grep_cli::StandardStream as std::io::Write>::write_all(move _18, _19) -> [return: bb15, unwind: bb47];
    }

    bb15: {
        _16 = <std::result::Result<(), std::io::Error> as Try>::branch(move _17) -> [return: bb16, unwind: bb47];
    }

    bb16: {
        _22 = discriminant(_16);
        switchInt(move _22) -> [0: bb17, 1: bb18, otherwise: bb5];
    }

    bb17: {
        _26 = &mut _3;
        _28 = const b": ";
        _27 = _28 as &[u8] (PointerCoercion(Unsize));
        _25 = <grep::grep_cli::StandardStream as std::io::Write>::write_all(move _26, move _27) -> [return: bb19, unwind: bb47];
    }

    bb18: {
        _23 = move ((_16 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _23) -> [return: bb53, unwind: bb47];
    }

    bb19: {
        _24 = <std::result::Result<(), std::io::Error> as Try>::branch(move _25) -> [return: bb20, unwind: bb47];
    }

    bb20: {
        _29 = discriminant(_24);
        switchInt(move _29) -> [0: bb21, 1: bb22, otherwise: bb5];
    }

    bb21: {
        _31 = const true;
        _34 = &_14;
        _33 = FileTypeDef::globs(move _34) -> [return: bb23, unwind: bb47];
    }

    bb22: {
        _30 = move ((_24 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _30) -> [return: bb54, unwind: bb47];
    }

    bb23: {
        _32 = <&[std::string::String] as IntoIterator>::into_iter(move _33) -> [return: bb24, unwind: bb47];
    }

    bb24: {
        _35 = move _32;
        goto -> bb25;
    }

    bb25: {
        _37 = &mut _35;
        _36 = <std::slice::Iter<'_, std::string::String> as Iterator>::next(_37) -> [return: bb26, unwind: bb47];
    }

    bb26: {
        _38 = discriminant(_36);
        switchInt(move _38) -> [0: bb28, 1: bb27, otherwise: bb5];
    }

    bb27: {
        _39 = ((_36 as Some).0: &std::string::String);
        _40 = _31;
        switchInt(move _40) -> [0: bb29, otherwise: bb33];
    }

    bb28: {
        _56 = &mut _3;
        _58 = const b"\n";
        _57 = _58 as &[u8] (PointerCoercion(Unsize));
        _55 = <grep::grep_cli::StandardStream as std::io::Write>::write_all(move _56, move _57) -> [return: bb39, unwind: bb47];
    }

    bb29: {
        _43 = &mut _3;
        _45 = const b", ";
        _44 = _45 as &[u8] (PointerCoercion(Unsize));
        _42 = <grep::grep_cli::StandardStream as std::io::Write>::write_all(move _43, move _44) -> [return: bb30, unwind: bb47];
    }

    bb30: {
        _41 = <std::result::Result<(), std::io::Error> as Try>::branch(move _42) -> [return: bb31, unwind: bb47];
    }

    bb31: {
        _46 = discriminant(_41);
        switchInt(move _46) -> [0: bb33, 1: bb32, otherwise: bb5];
    }

    bb32: {
        _47 = move ((_41 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _47) -> [return: bb55, unwind: bb47];
    }

    bb33: {
        _50 = &mut _3;
        _51 = std::string::String::as_bytes(_39) -> [return: bb34, unwind: bb47];
    }

    bb34: {
        _49 = <grep::grep_cli::StandardStream as std::io::Write>::write_all(move _50, _51) -> [return: bb35, unwind: bb47];
    }

    bb35: {
        _48 = <std::result::Result<(), std::io::Error> as Try>::branch(move _49) -> [return: bb36, unwind: bb47];
    }

    bb36: {
        _52 = discriminant(_48);
        switchInt(move _52) -> [0: bb37, 1: bb38, otherwise: bb5];
    }

    bb37: {
        _31 = const false;
        goto -> bb25;
    }

    bb38: {
        _53 = move ((_48 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _53) -> [return: bb56, unwind: bb47];
    }

    bb39: {
        _54 = <std::result::Result<(), std::io::Error> as Try>::branch(move _55) -> [return: bb40, unwind: bb47];
    }

    bb40: {
        _59 = discriminant(_54);
        switchInt(move _59) -> [0: bb41, 1: bb42, otherwise: bb5];
    }

    bb41: {
        drop(_14) -> [return: bb8, unwind: bb48];
    }

    bb42: {
        _60 = move ((_54 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _60) -> [return: bb57, unwind: bb47];
    }

    bb43: {
        _62 = _2;
        _61 = Gt(move _62, const 0_i32);
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(move _61);
        drop(_3) -> [return: bb46, unwind continue];
    }

    bb44: {
        drop(_14) -> [return: bb45, unwind: bb48];
    }

    bb45: {
        drop(_10) -> [return: bb51, unwind: bb49];
    }

    bb46: {
        return;
    }

    bb47 (cleanup): {
        drop(_14) -> [return: bb48, unwind terminate(cleanup)];
    }

    bb48 (cleanup): {
        drop(_10) -> [return: bb49, unwind terminate(cleanup)];
    }

    bb49 (cleanup): {
        drop(_3) -> [return: bb50, unwind terminate(cleanup)];
    }

    bb50 (cleanup): {
        resume;
    }

    bb51: {
        drop(_3) -> [return: bb46, unwind continue];
    }

    bb52: {
        goto -> bb51;
    }

    bb53: {
        goto -> bb44;
    }

    bb54: {
        goto -> bb44;
    }

    bb55: {
        goto -> bb44;
    }

    bb56: {
        goto -> bb44;
    }

    bb57: {
        goto -> bb44;
    }
}

alloc16 (size: 1, align: 1) {
    0a                                              │ .
}

alloc15 (size: 2, align: 1) {
    2c 20                                           │ , 
}

alloc14 (size: 2, align: 1) {
    3a 20                                           │ : 
}

fn pcre2_version(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;

    bb0: {
        _0 = imp(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        return;
    }
}

fn imp(_1: &args::Args) -> std::result::Result<bool, Box<dyn std::error::Error>> {
    debug args => _1;
    let mut _0: std::result::Result<bool, std::boxed::Box<dyn std::error::Error>>;
    let mut _2: grep::grep_cli::StandardStream;
    let mut _3: std::ops::ControlFlow<std::result::Result<std::convert::Infallible, std::io::Error>>;
    let mut _4: std::result::Result<(), std::io::Error>;
    let mut _5: &mut grep::grep_cli::StandardStream;
    let mut _6: std::fmt::Arguments<'_>;
    let mut _7: &[&str];
    let mut _8: isize;
    scope 1 {
        debug stdout => _2;
        let _9: std::result::Result<std::convert::Infallible, std::io::Error>;
        let mut _10: &[&str; 1];
        scope 2 {
            debug residual => _9;
            scope 3 {
            }
        }
        scope 4 {
            debug val => const ();
            scope 5 {
            }
        }
    }

    bb0: {
        _2 = args::Args::stdout(_1) -> [return: bb1, unwind continue];
    }

    bb1: {
        _5 = &mut _2;
        _10 = const _;
        _7 = _10 as &[&str] (PointerCoercion(Unsize));
        _6 = Arguments::<'_>::new_const(move _7) -> [return: bb2, unwind: bb10];
    }

    bb2: {
        _4 = <grep::grep_cli::StandardStream as std::io::Write>::write_fmt(move _5, move _6) -> [return: bb3, unwind: bb10];
    }

    bb3: {
        _3 = <std::result::Result<(), std::io::Error> as Try>::branch(move _4) -> [return: bb4, unwind: bb10];
    }

    bb4: {
        _8 = discriminant(_3);
        switchInt(move _8) -> [0: bb5, 1: bb7, otherwise: bb6];
    }

    bb5: {
        _0 = std::result::Result::<bool, Box<dyn std::error::Error>>::Ok(const false);
        drop(_2) -> [return: bb9, unwind continue];
    }

    bb6: {
        unreachable;
    }

    bb7: {
        _9 = move ((_3 as Break).0: std::result::Result<std::convert::Infallible, std::io::Error>);
        _0 = <std::result::Result<bool, Box<dyn std::error::Error>> as FromResidual<std::result::Result<Infallible, std::io::Error>>>::from_residual(move _9) -> [return: bb8, unwind: bb10];
    }

    bb8: {
        drop(_2) -> [return: bb9, unwind continue];
    }

    bb9: {
        return;
    }

    bb10 (cleanup): {
        drop(_2) -> [return: bb11, unwind terminate(cleanup)];
    }

    bb11 (cleanup): {
        resume;
    }
}

promoted[0] in imp: &[&str; 1] = {
    let mut _0: &[&str; 1];
    let mut _1: [&str; 1];

    bb0: {
        _1 = [const "PCRE2 is not available in this build of ripgrep.\n"];
        _0 = &_1;
        return;
    }
}

fn args::Args(_1: Arc<ArgsImp>) -> args::Args {
    let mut _0: args::Args;

    bb0: {
        _0 = args::Args(move _1);
        return;
    }
}

// MIR FOR CTFE
fn args::Args(_1: Arc<ArgsImp>) -> args::Args {
    let mut _0: args::Args;

    bb0: {
        _0 = args::Args(move _1);
        return;
    }
}

fn args::ArgMatches(_1: clap::ArgMatches<'_>) -> args::ArgMatches {
    let mut _0: args::ArgMatches;

    bb0: {
        _0 = args::ArgMatches(move _1);
        return;
    }
}

// MIR FOR CTFE
fn args::ArgMatches(_1: clap::ArgMatches<'_>) -> args::ArgMatches {
    let mut _0: args::ArgMatches;

    bb0: {
        _0 = args::ArgMatches(move _1);
        return;
    }
}

fn EncodingMode::Some(_1: Encoding) -> EncodingMode {
    let mut _0: args::EncodingMode;

    bb0: {
        _0 = EncodingMode::Some(move _1);
        return;
    }
}

// MIR FOR CTFE
fn EncodingMode::Some(_1: Encoding) -> EncodingMode {
    let mut _0: args::EncodingMode;

    bb0: {
        _0 = EncodingMode::Some(move _1);
        return;
    }
}

fn Logger(_1: ()) -> Logger {
    let mut _0: logger::Logger;

    bb0: {
        _0 = Logger(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Logger(_1: ()) -> Logger {
    let mut _0: logger::Logger;

    bb0: {
        _0 = Logger(move _1);
        return;
    }
}

fn PatternMatcher::RustRegex(_1: RegexMatcher) -> PatternMatcher {
    let mut _0: search::PatternMatcher;

    bb0: {
        _0 = PatternMatcher::RustRegex(move _1);
        return;
    }
}

// MIR FOR CTFE
fn PatternMatcher::RustRegex(_1: RegexMatcher) -> PatternMatcher {
    let mut _0: search::PatternMatcher;

    bb0: {
        _0 = PatternMatcher::RustRegex(move _1);
        return;
    }
}

fn Printer::Standard(_1: Standard<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::Standard(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Printer::Standard(_1: Standard<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::Standard(move _1);
        return;
    }
}

fn Printer::Summary(_1: Summary<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::Summary(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Printer::Summary(_1: Summary<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::Summary(move _1);
        return;
    }
}

fn Printer::JSON(_1: JSON<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::JSON(move _1);
        return;
    }
}

// MIR FOR CTFE
fn Printer::JSON(_1: JSON<W>) -> Printer<W> {
    let mut _0: search::Printer<W>;

    bb0: {
        _0 = Printer::<W>::JSON(move _1);
        return;
    }
}
